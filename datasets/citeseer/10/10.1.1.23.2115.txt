ownership types flexible alias protection david clarke john potter james noble microsoft research institute macquarie university sydney australia potter mri mq edu au object oriented programming languages allow inter object aliasing 
necessary construct linked data structures networks interacting objects aliasing problematic aggregate object state change alias components aggregate aware aliasing 
ownership types form static type system indicates object ownership 
provides flexible mechanism limit visibility object restrict access paths objects controlling system dynamic topology 
type system shown sound specific aliasing properties system object graph satisfies formulated proven invariant typed programs 
keywords alias protection sharing containment ownership representation exposure programming language design sharing objects aliasing powerful feature object oriented programming weakness :10.1.1.30.5600
changes object potentially affect objects refer object changed may unaware objects 
complicates reasoning objectoriented programs specifically lack modularity reasoning due inability localise object 
programs difficult understand knowledge complete program behavior required ultimately leading programs difficult maintain 
takes steps imposing discipline controlling aliasing absent current programming languages 
earlier dynamic change detection schemes aggregate objects developed notion flexible alias protection 
proposed aggregate objects defined components potential aliasing components statically determined aliasing modes 
provided rationale model flexible alias protection supported illustrative examples suggested incorporating aliasing modes programming languages 
flexible alias protection key properties required representation exposure role confusion entities different modes limited dependence mutable state objects addressed 
current introduce ownership types static types annotated context declarations represent object ownership 
object language construct type system ownership types establish soundness subject reduction theorem 
refine notion representation exposure restricted visibility property limits extent object visibility representation containment property provides notion containment articulation points called dominators 
absence role confusion phrased terms role separation 
properties particular representation containment property represent structural invariants object graphs typed programs indicate kinds aliasing possible 
organised follows 
section describes ownership types object contexts intended semantics terms object ownership considers illustrative examples java language extended ownership types 
section introduces core language formalises static semantics terms ownership types 
section describes operational semantics providing novel interpretation ownership types proves subject reduction property demonstrating soundness ownership type system 
section formalises proves representation containment properties 
section discusses model containment suggested articulation point formulation correspondence flexible alias protection model limitations 
section considers related including proposals providing alias protection 
section concludes current status theoretical prototype implementation pizza directions 
ownership types object contexts typically object systems objects live global address space called heap object store 
strict constraints parts object store object access restrictions way ob ject passed 
repercussions preventing representation exposure aggregate objects 
components constitute aggregate object considered contained aggregate part representation 
object store global general way prevent objects accessing representation 
enforcing notion containment standard semantics impossible 
key solving problem introduce notion object contexts 
object owns context owned context resides 
object contexts provide nested partitioning object store reflecting nesting objects allows speak object interior exterior 
annotate types context declarations yield ownership types 
variables having ownership types different declared contexts refer part store aliases object 
ownership type system establishes sensible notion object interior 
informally develop ideas 
program begins execution root context 
program text denoted context norep representation 
root context global objects considered owned system potentially accessible objects system 
provides mechanism sharing value objects objects provide system wide services 
context norep represents standard constraints objectoriented programming languages 
new object created new context considered inside object contents deemed owned object 
program text partition denoted rep partition holds representation 
impose restriction rep approximately objects access rep partition object owns objects inside partition inside partitions objects inside partition explicit access rep partition 
words rep partition accessible outside owner 
informal statement mean representation containment 
note rep object dependent denotes different context object just different object 
definition object class context parameter owner denotes object context owns object referred 
owner new object necessarily owner rep context object creating 
follows owning object having necessarily 
context parameter owner 
utility extension seen examples 
essential assigning ownership type 
context parameters allow object context information passed 
treat object contexts class values impossible construct static type system 
treat context parameters analogously type parameters generic class eiffel pizza template macro expand perform type checking 
context parameters allow ownership information passed context newly created object 
allows example create container links hidden representation contents owned object outside container 
possible balloons islands 
object context parameters including owner give system flexibility 
ownership type consists class name context representing owner bindings context parameters 
bindings owner context parameters visible contexts class type declared rep norep owner plus context parameters class header 
examples ownership types sections 
discussion suggests explicit class stores local stores 
partitioning stores merely metaphor enhance understanding 
notion ownership static object stores denoted object contexts object fixed life object 
operations object contexts value affect computation 
contexts statically enforceable run time interpretation require runtime support 
object contexts ownership types static conceptual entities 
object contexts rep norep example illustrates object contexts rep norep 
executing main main line marked get object graph root theta driver ss car vv engine ww diagram solid arrows objects dotted arrows refer object owner 
arrow marked theta allowed system 
engine part car external alias 
engine started violating implied precondition method go car driver start engine 
giving field engine ownership type rep engine saying engine part car representation belongs context owned instance car 
furthermore engine accessible outside instance 
theta marked characterise representation containment property follows paths root system object pass object owner 
points note example follows 
typing field driver norep driver consider car driver owned system 
engine accessed field name returned external method call 
class engine void start void class driver class car rep engine engine representation norep driver driver representation car constructor new engine part representation engine new rep engine driver null rep engine return engine void rep engine engine void go driver null engine start class main void main norep driver bob new norep driver norep car car new norep car car driver bob car go car engine fails car fails java rep engine new rep engine car fails different rep car example prevented java making engine private 
java allows contents private field returned method 
allowed objects rep annotated type 
reason say system provides object protection stronger name protection offered conventional programming languages 
call car fails rep caller callee refer different contexts root car context respectively distinct 
types incompatible 
interpretation rep implies type rep engine different different instances class car 
implies different cars different engines 
context parameters example illustrates context parameters bindings restrictions impose 
class pair fst snd class intermediate rep pair rep norep 
pair norep pair rep norep 
pair rep pair rep norep 
return pair norep pair rep norep 
return pair rep return pair fst norep return pair snd void pair fst new rep class main norep intermediate safe void main rep pair rep norep 
norep pair rep norep 
rep norep safe wrong safe wrong safe wrong safe valid safe valid context parameters example class pair context parameters giving fst type snd type specifying values stored fst snd come potentially different contexts 
actual context depends bindings context parameters class pair 
class intermediate uses pair number times 
type field pair rep pair rep norep 
read follows field pair owned current instance parameter pair bound rep meaning contents field pair fst owned current instance parameter bound norep meaning contents field pair snd owned system 
diagram illustrates typical object graph code represent root theta safe hh pair hh pair fst snd fst zz snd ee main calls safe invalid create alternative access paths object representation 
particular indirectly creating path fst pair circumventing owner safe 
consequently type rules prevent external visibility fields types rep parameter position 
call valid create illegal access paths owner snd root system 
typing point view invalidity calls occurs type containing rep class different syntactically identical type containing rep different class 
call valid involves rep rep field pair fst type rep intermediate binding pair context parameter expect 
require textually distinct types appearing class distinct regardless bindings 
means example field snd type incompatible values type keeps type checking modular provides strong notion role separation 
type system guarantees sets values different ownership types kept separate 
sense inside class different virtual partitions created context parameter may ultimately unified 
owner context illustrates code unbounded stack built singly linked list link nodes 
class provides handle links 
link node contains data element context parameter context parameter bound link 
means contents appropriate data elements owned context corresponding binding parameter 
example illustrated diagram top oo link vv link dd link ll data data jj data ll class link owner link data link null data class rep link top top null void push data rep link newtop new rep link data newtop top top newtop pop rep link top rep link top return top data boolean isempty return top null owner context example context know owners data elements unknown binding context parameter owner instance 
illustrates reusability class context parameters analogous generic classes object oriented language parametric polymorphism 
main interest example effect owner expressiveness representation containment 
wit links owned object visible outside 
links freely manipulated 
provides flexible notion containment 
see works observe top link rep owned instance 
inside instance link stored top owner bound rep context 
seen diagram 
field top type owner link 
owned 
argument see owns links shown 
similarly data links belongs partition 
worth noting links incompatible links different instance 
links data structure built manner owned exclusively handle object 
unlimited structures built mechanism 
point worth owner object object creates object owner refer objects owns 
owner merely forms boundary inside outside object 
formalisation ownership type system technical part spans sections 
object language resembles core java inheritance extended object contexts 
ownership types defined followed usual machinery required build type system 
key element type system static visibility constraint type rules field access update method call 
expressions represent object access invalidate give access object representation 
type system checks class types purported class declaration 
keeps type system simple modular 
operational semantics language 
reduction rules standard demonstrating require ownership information run time 
additional type rules determine valid stacks stores little different 
type rules ownership structures novel provide runtime interpretation ownership types 
ownership structures form ownership types contexts replaced object identifiers owner objects type owners objects uses 
ownership structures formulate prove subject reduction 
ownership structures allow formulate desired structural properties object graphs type system enforces role separation restricted visibility representation containment 
proving properties conclude discussion impact aliasing 
core language core language simple object language object contexts 
language subsequent type rules extensions 
unfortunately treatment diverges concise operational semantics due object dependence ownership types 
core language syntax defn local defn class field meth field fd meth md arg local new null fd fd md arg local variable name class name object context parameter rep norep theta fd field name md method name jm represent program collection classes followed expression evaluate local variables 
classes take number context parameters consist collection fields methods 
simple control constructs added affecting type rules 
expressions order object creation null sequencing local variable access local variable update field access field update method call 
treat method arguments local variables obvious restriction updated 
types written jm underlying class 
parameter preceding owner remaining parameters bindings context parameters class notation differs slightly examples type previously written rep written 
furthermore theta shorthand denote owner treat treat context parameters 
expression new 
understood follows firstly creates new object class context passes new object context information available new object 
simplicity explicit constructors 
flexible alias protection suggested piggybacking context parameters type parameters objectoriented language parametric polymorphism understand essence ownership types include parametric polymorphism core language 
ownership types defining ownership types introduce ownership schemes notational convenience 
ownership scheme template create ownership types ownership structures 
ownership schemes denoted thetaj context parameters taken declaration theta implicit owner context 
create ownership type ownership scheme substituting parameters theta ownership types appear inside class bodies declared types fields method arguments return values local variables 
substituted values taken rep norep theta set context parameters declaration class ownership type appears 
example assume class declared class 
ownership scheme 
sigma theta pj fpg sigma valid ownership type appearing body class captured definition sigma known context 
definition ownership type sigma set context parameters thetaj 
ownership scheme 
ownership type substituting elements sigma parameters static visibility constraint key type system static visibility constraint 
restricts access fields methods declared rep type 
fields methods contain access representation particular object 
want restrict access fields methods object corresponds owner representation 
class expression statically guaranteed denote object owns rep 
expressions denote potentially different objects rep type fields methods may different 
observations formulate static visibility constraint follows definition static visibility expression ownership type say visible condition satisfied sv def rep contexts 
sv called static visibility constraint function contexts extracts arguments ownership scheme structure built ownership scheme substitution 
defined follows contexts mj 
def fmg restrict access denote object context say provide object protection 
note static visibility check performed declared type 
allows bind rep context parameters internal containers preventing containers accessible outside current object allowing representation stored 
type system rules type system define substitution related functions appear explicitly type system 
substitution substitution function context parameters set substitutions applied ownership schemes ownership types 
set depend context substitutions 
thetaj 
ownership scheme substitution oe map thetag substitutions applied follows oe njn nn 
def oe joe oe 
oe def 
oe oe def dom oe example oe theta 


prg substitution ownership scheme thetaj oe mn 
pn 
oe theta norep 
norep allied substitutions function kind inverse substitution 
returns substitution performed ownership scheme generate structure defined njn nr 
def theta 


nrg thetaj 
ownership scheme class definition oe ownership scheme underlying oe notation simplify presentation type system compress class program field method dictionary follows def ffd 
tg map field names types def fmd 
gamma 
tres fy 
tg ig map method names tuple consisting method type argument types result type tres argument variable names body mapping local variables types 
dictionaries easily determined program 
underlying class ownership scheme determined inspection allow dictionaries associated ownership schemes types structures 
type system type system defined respect program environments object context environment type environment 
object context environment denoted sigma collection context parameters defined follows sigma ffl sigma context parameters ffl empty environment 
generally context parameters appear class declaration theta 
type environment denoted gamma mapping variables ownership types defined follows gamma ffl gamma system domain gamma include appropriate arguments local variables checking method definition 
notation gammaf tg represents extension type environment multiple variables types 
type system judgements 
formed ownership type defn defn formed sigma gamma meth meth formed sigma gamma formed ownership type sigma formed explanation rule program states program valid definitions valid expression evaluated typed types local variables 
local variables types contain context parameters expression evaluated body class 
class validity checked rule class 
assigns type thetaj 
methods typed environment type sigma includes theta context parameters class header 
require field types formed sigma 
program defn defn defn ym class sigma sigma thetaj class 
ft fd fd meth sigma thetag type sigma sigma 
method sigma sigma sigma sigma gammaf sigma gamma md xn ft ym new sigma sigma gamma new null sigma sigma gamma null sequence sigma gamma sigma gamma sigma gamma local access dom gamma sigma gamma gamma local update sigma gamma gamma dom gamma sigma gamma gamma field access sigma gamma oe fd sv sigma gamma fd oe field update sigma gamma oe fd sigma gamma oe sv sigma gamma fd oe method call sigma gamma oe md gamma 
sigma gamma oe sv sv sigma gamma md en oe type system type uses ownership schemes extracted program build valid types performing substitution target set consists object contexts rep norep plus context parameters scope sigma 
method checks body method type environment resulting adding argument local variable types gamma 
rule requires type argument local variable formed respect sigma 
new creates objects ownership type 
similarly null type 
restriction new object null considered free subsequently coerced type 
notion free requires linearity restriction new object shared know correct ownership type integration subject research 
note free unique free applies newly created objects null 
sequence enforces type expressions sequence type expression 
local variables type declared type environment gamma local access 
rule local update enforces updatable requires expression type local variable 
rules field access field update method call initially extract type left hand side expression substitution oe 
type field method extracted appropriate dictionary 
type type declared program text 
applying substitution type check remainder expression give type entire expression 
step implicit standard formulation type system 
properly check static visibility separate reps different contexts need declared type perform sv check 
expressions syntactically different type appearing context incompatible 
subtyping object contexts type level 
type coercions lose information require recovery unknown information inheritance subtyping supported 
extensions focus active research 
operational semantics section presents complete operational model core language terms reduction rules 
rules describe expression evaluation respect state consisting stack store 
surprising feature operational semantics object contexts play role demonstrating type system imposes runtime overhead 
demonstrate soundness type system prove subject reduction 
provide type rules valid execution environments manner similar 
introduce run time interpretation ownership types 
context dependent nature type system clearly apparent interpretation function 
technical lemmas help prove subject reduction 
subject reduction result takes form generalised subject reduction theorem applies open expressions state closed expressions 
get ordinary subject reduction theorem specifying initial execution environment execute program environment combined generalised subject reduction theorem allows formulate structural properties proven section 
stacks stores evaluation environment consists stack store 
defined follows definition store store map object identifiers objects object map field names values null 
ffl def fo 
fg def ffd 
vg dom dom class operations stores ffl fo 
fg store obtained adding new object field map dom 
ffl 
store obtained updating object field map dom 
ffl fd 
result updating field fd value method arguments local variables stored stack object method invoked variable 
stack contents depend invoked object stacks grouped stack frames built left right stack top rightmost stack frame 
definition stack stack frame ffi def fx 
vg map variables values 
operations ffl ffi def 
ffi frame lookup ffl ffi 
stack frame formed replacing value maps frame update stack delta def ffi psi delta delta delta psi ffi list stack frames 
ffi top stack 
stack operations ffl delta psi ffi stack constructed pushing ffi delta ffl delta def ffi lookup ffl delta 
def delta psi ffi 
update delta delta psi ffi operations 
typed programs lookups updates performed operational semantics valid variable names 
particular variable exists stack frames 
reduction rules operational semantics 
expressed terms reduction relation associates store stack delta term value store stack delta relation written delta delta delta delta red new delta delta dom delta delta new fo 
ffd 
null fd dom gg delta delta red local access delta delta delta delta delta delta delta red local update delta delta delta delta delta delta delta delta 
red field access delta delta delta delta delta delta fd delta delta fd red field update delta delta delta delta delta delta delta delta delta delta fd 
fd 
delta delta red sequence delta delta delta delta delta delta delta delta delta delta delta delta red method call delta delta delta delta delta delta delta delta 
delta delta en vn delta delta delta delta psi 


delta delta psi ffi delta delta md en delta delta type 
delta delta md li dom dom ffi reduction rules means store stack delta term reduces value yielding updated store updated stack delta reductions natural big step reduction style semantics 
reduction rules standard unsurprising capture behaviour simple object language 
assumptions rules red new red local access typedness store stack 
defined section 
red method call requires explanation evaluate expression md en evaluate value object null argument evaluated value resulting context new stack frame built mapped argument mapped appropriate value local mapped null body method evaluated new stack store 
evaluation finished top stack frame discarded 
expression evaluates note stack frames lower stack touched 
fact verified induction rules definition stack 
note rules ignore dereferencing expressions evaluate null 
technically evaluate error configuration additional rules expressions 
handling null omitted change results omission simplifies presentation 
ownership structures ownership structures provide basis semantic interpretation ownership types 
proving soundness type system 
interpretation novel certain extent natural 
object context denotes owner object interpreting ownership type replace object context context parameter owner denotes 
gives ownership structure defined follows definition ownership structure set object identifiers thetaj 
ownership scheme oj fog ownership structure 
object ownership type interpreted oj owner objects constitute owners objects semantic interpretation defined object takes ownership types ownership structures 
uses ownership structure definition 
ownership type interprets appears body class defined terms rep norep theta context parameters class interpretation gives values object context context parameter scope class function uses ownership information interpret types objects provides way ownership information context context parameters statically 
definition semantic interpretation function object ownership structure thetaj 
ownership scheme oe 
define semantic interpretation function follows rep def theta def oe theta def oe norep def root njn def translating rep confirms fact representation 
norep consistently mapped root object representing root system defined precisely specify initial configuration 
substitution oe allows propogation bindings context defined objects stressed rep interpreted differently different interpretation functions 
ownership types containing rep incompatible precisely come different objects 
clear ownership structures built interpretation function 
means types visible contexts 
particular types rep visible outside owner 
subject reduction theorem amounts saying point program execution object context type visible 
notion visibility defining valid execution environments 
valid execution environment precisely define valid stacks stores delicate essential task proving subject reduction imperative languages 
complicated definition ownership structures introduce additional circularity definitions objects defined terms types types defined terms objects 
see causes real difficulty start definitions collection object identifiers assumed 
provides complete definition stacks store typings 
types ownership structures built set object identifiers type type 
store typing type environment object identifiers mapping object identifiers ownership structures store type 
object type null type correspond value typings object types store typing null available type 
stack frame constrains construction valid stack frames type elements frame interpreted correctly respect object method invoked 
empty stack stack type build stacks lists stack frames 
store component similar stack frame ownership structure object fields interpretation object ownership types class definition 
empty store store construction build stores objects 
stack store defines valid stores stacks store typing require store valid stack valid object assigned type appears store 
subject reduction soundness type system generalised subject reduction theorem states semantic interpretation term type invariant reduction 
prove theorem terms closed having free term variables context parameters 
object identifier null value set object identifiers ffd 
vg object fo 
fg store ffi fx 
vg stack frame fx stack frame typing delta ffi psi delta delta delta psi ffi stack psi delta delta delta psi dn stack typing ownership structure fo 
store typing formed type judgement formed store judgement valid typing judgement sf ffi valid stack frame judgement st delta valid stack judgement 
valid store component judgement valid store typing judgement delta delta valid stack store judgement type type fog oj 
store type dom dom object type null type dom null stack frame sf 

vg og contexts contexts ownership scheme empty stack st stack type st delta sf ffi st delta psi ffi psi store component 
ffd 

delta delta fd dom fd empty store store construction 
dom fo 
fg stack store st delta dom dom delta delta valid execution environment full proof subject reduction straight forward tedious omitted 
aspect captured visibility lemma dynamic version static visibility constraint 
object deem ownership structure visible object interpretation function produce ownership structure 
visibility lemma captures notion object object ownership types rep correctly interpreted fields methods validly access ones visible rep type fields methods rep type invisible 
lemma visibility lemma ownership scheme ownership scheme dom 
ownership type contexts contexts oe oe 
clause states object correct ownership structure respect interpretation function 
second clause states ownership structure object interpreted respect object interpretation function second object interpretation function interpret type object function long ownership type contain rep lemma apply rep rep different objects guaranteed different interpretation 
proof 
holds definition pi contexts 
note oe defined pi 
firstly oe definition 
thetaj 
definitions oe oe oe thetaj thetaj oe theta joe thetaj oe theta oe theta pi theta pi oe 
norep maps root equation holds norep 
definition contexts pi oe evaluating non closed expressions require condition relating free term variables gamma stack delta free context parameters sigma appropriate interpretation 
condition requires execution environment typed free variables appropriate ownership structure respect current object delta context parameters ownership scheme current object type correspond exactly sigma 
definition valid predicate valid sigma gamma delta true delta sigma contexts ownership scheme dom gamma dom dom gamma gamma delta psi validity condition constrains top frame stack 
appropriate environment stack frames defined rules validly typed stack value reduction 
demonstrated induction reduction rules 
statement theorem requires store typing extension 
full proof appropriate extension replacement lemmas hold analogous 
definition extension say extension written dom dom dom 
note transitive 
theorem generalised subject reduction sigma gamma delta delta delta delta delta delta valid sigma gamma delta exists ownership structure store typing delta delta delta valid sigma gamma delta 
proof 
proof induction derivation delta delta delta delta style 
aspects captured visibility lemma 
static visibility condition invalidates expressions visibility lemma apply representation accessed outside owner 
initial configuration obtain subject reduction programs need define initial configuration execution 
configuration section proving structural properties object graphs 
definition initial configuration program defn define initial store init def froot 
initial stack single stack frame ffi init def 
root 

valid typing introduce class root context parameters 
initial store typing init froot gives init root root 
define root rep root def root norep root def root object root class root purely semantic artifacts need object corresponding owner values norep owner completeness give type 
initial configuration get subject reduction theorem corollary defn tg init delta delta init delta delta init root local variable exists ownership structure store typing init root structural properties object graphs section formulate structural invariants hold typed programs 
role separation restricted visibility representation containment 
interesting consequences respect alias protection containment devote additional section discussing 
role separation role separation property type system 
coercion operations type system type checking modular role separation different ownership types appearing context compatible regardless ensuing bindings 
means type rules necessarily conservative guarantee class behave way regardless bindings context parameters 
static guarantee values ownership types mixed class regardless bindings 
restricted visibility restricted visibility says dynamic aliasing representation allowed 
dynamic alias access may occur field access stack result method call 
imagine valid assignment 
aren 
recall say object visible context interpretation exists ownership structure 
required property restricted visibility objects assigned fields passed arguments method calls returned field access method call visible context callee caller 
particular access object rep type outside owner 
restricted visibility follows subject reduction 
representation containment representation containment formulation representation exposure property 
characterise property terms paths root system follows representation containment property paths root system pass object owner 
alternatively path root system object representation object 
sense means object control representation rest system object interface affect changes representation 
strong sense representation viewed inside owner 
remainder section devoted formalising terms articulation points 
property prove stronger 
definition articulation point graph node articulation point paths paths pass define object graph 
requires simple modification program newly created objects appear object graph explicitly 
done simply requiring point creation new object stored new local variable correct type 
shown transformation preserves program semantics 
trick simplified version normal form 
notation indicate dom 
intuitively edges object graph definition object graph store typing store stack delta ffi psi delta delta delta object graph gs delta delta smallest graph satisfying 
ffi gs delta delta method invocation target 
non null rng ffi gs delta delta gs delta delta ffi stack frame reachability 
gs delta delta non null rng gs delta delta gs delta delta store reachability furthermore root graph ffi 
object define ap def contexts ownership structure definition representation containment representation containment property rc object graph gs delta delta defined follows rc gs delta delta def gs delta delta ap articulation point paths root defines representation containment particular snapshot program evolving object graph 
remains prove invariant object graphs entire program execution 
argument inductive size graph 
easy see removing edges nodes adding nodes invalidate graph just consider adding new edges 
lemma provides necessary condition exist 
lemma derivation tree evaluation init delta delta init delta delta delta delta store stack pair appearing side evaluation relation gs delta delta ap ap fo 
proof 
gs delta delta exists due store stack 
types valid store store component 
stack stack frame 
definition contexts rng ap fo 
ap contexts definition ap ap fo 
lemma standard articulation points 
lemma articulation point paths graph adding preserves articulation point proof representation containment property invariant execution program theorem representation containment invariance derivation tree reduction init delta delta init delta delta delta delta store stack pair appearing side reduction relation rc gs delta delta 
proof 
clearly rc gs init delta delta init 
inductive step 
assume formed delta delta gs delta delta rc 
sufficient consider effect adding edge valid field update stack frame construction produce new graph contradiction assume representation containment property fails lemma ap ap fp 
assignment create invalid store stack 
ap root 

ap 
articulation point lemma articulation point contradiction 

removing breaks paths root containing edge assumption path root articulation point 
remains articulation point contradiction 

root removing root node articulation property vacuously true 
contradiction 
discussion discuss consequences basing representation containment articulation points compare flexible alias protection point limitations 
containment model alias protection restricting scope aliasing containment linearity constraints entirely compatible object oriented programming 
considering interpretation articulation point obtain clear notion inside outside 
articulation point partitions graph subgraphs inside objects reachable root paths articulation point outside remainder objects 
consider articulation point owner boundary 
diagram illustrates idea 
root oo ww oo outside inside owner oo ee vv idea say flexible alias protection prevents object access outside owner 
go inside outside vice versa 
model require objects referred owner 
allows arbitrary self referencing data structures inside object 
furthermore articulation points form tree dominator tree corresponds having nested containment relationships 
pursued idea recognise inherent containment relationships evolving object graphs 
furthermore model articulation points faithful model containment object oriented modelling part relationship 
relationship flexible alias protection formalisation core flexible alias protection 
precise correspondence discussed section 
flexible alias protection annotated types mode declarations 
context declarations expressing restrictions effects dependence mutable state 
ownership types address issues outlined 
introduced context parameter owner absent allowing type 
doing increased modelling power build arbitrary self referencing data structure impose restriction nodes owned handle object 
example stack implemented linked list 
context parameter owner adds flexibility flexible alias protection 
flexible alias protection aliasing mode var described loophole obtain normal semantics required 
optional role parameter imposes restriction role kept independent call role separation 
system norep corresponds var role parameter context parameters correspond var role parameter 
semantics internal object context rep consistent 
system lacks elements flexible alias protection model 
significant arg mode restricts object access interface depend immutable state 
roughly corresponds parts object extended state fixed moment object initialised 
mode free omitted simplicity represents newly created objects owned 
mode val value objects omitted concerned effects 
value objects object context particular norep values shared arbitrarily 
furthermore omitted parametric polymorphism simplicity 
include inheritance mention due difficulty caused loss information 
maintaining representation containment invariant presence subtyping achieved extending system obvious way 
limitations apart object oriented features inheritance particular incorporated limitations containment model articulation points 
firstly example construct external iterators representation object 
example solves lifting owner representation highest context iterator list 
clearly unsatisfactory defeats purpose containment 
path intend take solving having multiple owners reformulating containment terms cut sets 
unsure affects static typing 
second limitation support multiple representations visible context 
example required friendly functions plus objects representing money example 
easy resolve relaxing allowable forms dynamic aliasing 
change ownership fit model easily captured static type system 
related problems engendered semantics aliasing known 
problems particular severe object oriented programming languages aliasing common place 
control aliasing researchers considered explicit notions aggregation object containment ownership 
hogg islands almeida balloons similar aim called full alias encapsulation prohibits crossing encapsulation boundaries 
unfortunately full encapsulation aliasing restrictive common design idioms object oriented programming sharing data collections 
islands balloons distinguish static dynamic aliases dynamic alias caused short lived stack allocated variable 
gain flexibility systems permit various forms dynamic aliases encapsulated objects 
unfortunately flexibility defeats system safety 
system protect static dynamic aliases 
intuition underlying kent heart 
proposed informal extension eiffel programming language ownership annotations explicitly tracked monitored run time 
statically achieving constraints run time checks impose apart extension multiple ownership system restricts object visibility dynamic aliases system fails 
approaches completely formalised despite considerable effort 
sound formalisation proven alias protection guarantees 
done program language semantics proposing means coping pointers including 
special attachment mechanisms proposed language run time systems enforce unique linear pointers 
unfortunately proposals forbid common uses aliasing object oriented programs 
common approach preventing representation exposure restricting access variable names 
private protected modes java example related mechanisms formal models fail adequately constrain sharing object 
name protection enforce alias protection example externally aliased object assigned private field contents private field exported means 
happen subclassing class internal invariants unknown 
creating external break invariants 
type system prevent external providing stronger form protection name protection 
calculus resources protected restricting scope name 
process calculi model capabilities control access resources 
notions applicable alias protection 
calculi operational models provide static protection 
exception introduces location types provides static type system prevents access control resources capability held 
concrete notion object object unclear system translates object calculi 
security calculi type systems certainly related 
part leroy formalisation security properties strongly typed applets constrains environment accessible 
prevent leaked applets browsers api contain types 
see major limitation system system overcomes 
closely resembles purely formal level regions 
regions aimed improving memory management functional language sml region information inferred hindley milner style type inference 
hand ownership types declared provide alias protection object oriented languages 
nonsensical infer objects representation information part programmer intention 
underlying techniques similar modulo encoding objects functional language 
precise rep corresponds letregion context parameters correspond region variables 
regions include read write effects 
knowledge existing formal system statically models object ownership statically prevents object access outside object owner 
necessary object oriented programming unrestricted aliasing problematic controlled :10.1.1.30.5600
presents formalised system providing alias control proves soundness invariance specific aliasing properties role separation restricted visibility representation containment welltyped programs 
static type system object language offering alias protection 
key mechanisms limiting visibility objects internal object context rep safely extending visibility context parameters 
implemented flexible alias protection extending pizza 
implementation statically validates ownership types type system 
experience allow gain clearer picture limitations ownership types 
directions research 
extending type system include inheritance immediate goal 
control aliasing respect programming language constructs friendly functions multimethods subsequently considered 
include developing thorough understanding relationship static dynamic semantics studying properties induced ownership structures extending ideas concurrent object systems 
colleagues ryan geoff ian anonymous referees insight criticism better 
supported microsoft australia 
mart abadi luca cardelli 
theory objects 
springer verlag 
alfred aho john hopcroft jeffrey ullman 
design analysis computer algorithms 
addison wesley 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
paulo almeida 
balloon types controlling sharing state data types 
ecoop proceedings june 
pierre america frank de boer 
sound complete proof system spool 
technical report technical report philips research laboratories 
henry baker 
variables linear objects storage management reflection multi threading 
acm sigplan notices january 
edwin blake steve cook 
including part hierarchies object oriented languages implementation smalltalk 
ecoop proceedings 
alan borning 
programming language aspects constraint oriented simulation laboratory 
acm transactions programming languages systems october 
kim bruce luca cardelli benjamin pierce 
comparing object encodings 
theoretical aspects computer software tacs lncs pages 
luca cardelli andrew gordon 
mobile ambients 
foundations software science computation structures european joint conferences theory practice software march 
edwin chan john boyland william scherlis 
promises specifications analysis manipulation 
ieee international conference software engineering icse 
franco 
roles composite objects objectoriented analysis design 
oopsla proceedings 
alain deutsch 
interprocedural may alias analysis pointers limiting 
acm sigplan conference programming language design implementation june 
jin song dong roger duke 
exclusive control object oriented systems 
tools pacific 
margaret ellis bjarne stroustrup 
annotated manual 
addison wesley 
matthew flatt shriram krishnamurthi matthias felleisen 
classes mixins 
th acm conference principles programming languages january 
goldberg robson 
smalltalk language implementation 
wesley 
james gosling bill joy guy steele 
java language specification 
addison wesley 
peter patrice 
copying sharing aliasing 
proceedings colloquium object orientation databases software engineering montreal quebec may 
douglas harms bruce weide 
copying swapping influences design reusable software components 
ieee transactions software engineering may 
laurie hendren gao 
designing programming languages analyzability fresh look pointer data structures 
proceedings ieee international conference programming languages april 
matthew hennessy james 
resource control systems mobile agents 
technical report university sussex february 
john hogg 
islands aliasing protection objectoriented languages 
oopsla proceedings november 
john hogg doug lea alan wills dennis de richard holt :10.1.1.30.5600
geneva convention treatment object aliasing 
oops messenger april 
stuart kent john 
value types eiffel 
tools paris 
stuart kent ian 
encapsulation aggregation 
tools pacific 
william landi 
undecidability static analysis 
acm letters programming languages systems december 
rustan leino raymie stata 
contribution specification object oriented software 
technical report src tn digital systems research center april 
xavier leroy francois 
security type applets 
th acm conference principles programming languages january 
john lucassen david gifford 
polymorphic effect systems 
proceedings eighteenth annual acm sigact sigplan symposium principles programming languages january 

values objects programming languages 
acm sigplan notices december 
bertrand meyer 
eiffel language 
prentice hall 
robin milner joachim parrow david walker 
calculus mobile processes parts ii 
information computation september 
minsky 
alias free pointers 
ecoop proceedings july 
gregory morrisett 
refining class stores 
acm sigplan state programming languages 
hanne riis nielson flemming nielson 
semantics applications formal 
wiley 
james noble john potter 
change detection aggregate objects aliasing 
australian software engineering conference sydney australia 
ieee press 
james noble jan vitek john potter 
flexible alias protection 
ecoop proceedings 
martin odersky philip wadler 
pizza java translating theory practice 
proc 
th acm symposium principles programming languages january 
john potter james noble david clarke 
ins outs objects 
australian software engineering conference adelaide australia november 
ieee press 
appear 
john reynolds 
control interference 
th acm symposium principles programming languages january 
jon riecke stone 
privacy subsumption 
fifth workshop foundations object oriented languages 
james rumbaugh michael blaha william premerlani frederick eddy william lorensen 
object oriented modeling design 
prentice hall 
amr sabry matthias felleisen 
reasoning programs continuation passing style 
acm conference lisp functional programming pages san francisco ca june 
acm 
mads tofte jean pierre talpin 
region memory management 
information computation 
mark 
reasoning aliasing 
fourth australasian refinement workshop 
