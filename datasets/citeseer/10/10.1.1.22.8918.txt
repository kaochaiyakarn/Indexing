matching events content subscription system marcos aguilera robert strom daniel sturman mark tushar chandra content subscription systems emerging alternative traditional publish subscribe systems permit flexible subscriptions multiple dimensions 
systems subscription predicate may test arbitrary attributes event 
matching problem content systems determining event subset subscriptions predicates match event open problem 
efficient scalable solution matching problem 
solution expected time complexity sub linear number subscriptions space complexity linear 
specifically prove predicates reducible conjunctions elementary tests expected time match random event greater gamma number subscriptions closed form expression depends number type attributes cases 
optimizations algorithms improve search time 
results simulations validate theoretical bounds show acceptable performance levels tens thousands subscriptions 
department computer science cornell university ithaca aguilera cs cornell edu ibm watson research center yorktown heights sturman watson ibm com department computer science university illinois urbana champaign springfield ave urbana cs uiuc edu publish subscribe pub sub paradigm interconnecting information providers information consumers distributed environment 
information providers publish information form events pub sub system information consumers subscribe particular category events system system ensures timely delivery published events interested subscribers 
pub sub system typically implemented network brokers responsible routing events publishers subscribers 
earliest pub sub systems group 
systems event classified belonging fixed set groups known subjects channels topics 
publishers required label event group name consumers subscribe events particular group 
example group pub sub system stock trading may define group issue 
publishers post information labeled appropriate issue group name subscribers subscribe information regarding issue 
past decade systems supporting paradigm matured significantly resulting academic industrial strength solutions 
similar approach adopted omg corba event channels 
emerging alternative group systems contentbased subscription systems 
systems support number information spaces associated event schema defining type information contained event 
stock trade example may defined information space event schema tuple containing attributes issue price volume string dollar integer types respectively 
subscription predicate attributes issue ibm price volume 
note content pub sub subscribers added flexibility choosing filtering criteria multiple dimensions requiring pre definition groups 
stock trading example group subscriber forced select trades issue name 
contrast content subscriber free orthogonal criterion volume collection criteria issue price volume 
furthermore content pub sub removes administrative overhead maintaining defining groups making system easier manage 
content pub sub general easily implement group pub sub reverse true 
content pub sub powerful paradigm efficient scalable implementations systems developed 
order efficiently implement pub sub system find efficient solution problem matching event large number subscriptions 
refer problem matching problem 
strengths group pub sub systems problem straightforward solve mere table lookup 
content pub sub systems matching problem known scalable solution 
simple algorithm content matching test subscriptions event 
naive algorithm runs time linear number subscriptions 
practice pub sub systems may deployed environments tens thousands publishers subscribers general pub sub systems aimed providing support large scale widely distributed applications 
linear time solution matching problem adequate 
propose algorithm time complexity sub linear number subscriptions space complexity linear 
algorithm initially pre processes set subscriptions data structure allows fast matching 
pre processing sense pub sub environments subscriptions tend change infrequently considered approximately static events published fast rate 
cases speed gained pre processing far outweighs cost 
furthermore algorithm allows subscription updates incrementally incorporated existing pre processed data 
pre processing phase algorithm creates matching tree 
matching tree node test attributes edges results tests 
lower level tree refinement tests performed higher levels leaves tree subscriptions 
tree find subscriptions match event traversing tree starting root node perform test prescribed node follow edges consistent result may edge 
repeat steps get leaves 
leaves visited correspond subscriptions match event 
case subscriptions consist equality tests attributes asymptotic complexity algorithm significantly better naive algorithm 
precisely expected time match random event gamma number subscriptions depends number type attributes cases 
constants hidden big notation quite reasonable 
summary main contributions follows 
generic matching algorithm performance scales better naive algorithm 
case subscriptions consist equality tests show matching time grows sub linearly number subscriptions space requirement linear number subscriptions 
matching algorithm characteristics 
optimizations matching algorithm show result simulations validate practicality algorithm 
organized follows section formally define matching problem 
give general version algorithm problem section 
version allows subscriptions consist conjunctions arbitrary tests attributes 
section version algorithm specialized case subscriptions contain equality tests attributes show asymptotic time complexity algorithm sub linear number subscriptions 
section discuss enhancements speed algorithm 
section describe related conclude section 
appendices provide algorithmic details omitted explanations 
matching problem event schema defines space possible events specifying attribute names types 
subscription sub boolean predicate events 
say event matches subscription sub sub true matching problem event schema finite set sub subscriptions 
subsequently event goal determine subscriptions sub match allow pre processing set sub solution matching problem phases pre process sub match pre processed data event 
phase pre process sub takes set subscriptions sub outputs internal representation subscriptions 
second phase match pre processed data event takes internal representation event outputs subscriptions match event 
measure performance solution parameters ffl pre processing space complexity 
amount data generated pre process ffl pre processing time complexity 
time needed run pre process ffl matching time complexity 
time needed run match tree matching algorithm matching problem solved easily testing event subscription case pre processing 
naive solution runs time proportional number subscriptions 
applications number subscriptions extremely high order magnitude tens hundreds thousands 
events published fast rate events need matched fast rate naive solution perform adequately 
section provide algorithm performs significantly better 
algorithm initially pre processes set subscriptions matching tree 
describe tree detail explain match events 
henceforth assume subscription conjunction elementary predicates elementary predicate represents possible result elementary test 
elementary test simple operation attributes event subscription sub follows sub pr pr delta delta delta pr pr test res notation test res means test produces result res example subscription city new york temperature elementary predicates pr pr pr test new york pr test test examine attribute city test compare attribute temperature assume subscriptions identical predicates coalesced single subscription 
example matching tree matching tree non leaf node contains test edges node represent results test 
leaf node contains subscription sub test 
intuitively sub subscription described walking tree root conjunction elementary predicates 
precisely node tree define predicate pred follows path root test res test res test res pred test res delta delta delta test res require subscription sub contained leaf satisfies pred sub denotes logical equivalence 
simple examples matching tree 
suppose subscriptions sub sub share test follows sub test res test res sub test res test res case matching tree shown 
tree special don care edges call edges represent fact subscriptions reachable edge care result test 
edges necessary subscriptions independent test 
example suppose sub test res test res sub test res test res case matching tree shown 
matching tree edges node define pred exactly see equation assume convention test equivalent true 
example pred sub test test res test res test res test res sub test test happen related matching tree look different 
precisely test res test res possible matching tree shown 
note case pred sub sub intuitively matching tree better match event need evaluate test test evaluate test test evaluates res root node define pred true matching tree edge matching tree test res test res procedure match tree event visit tree root event procedure visit tree event leaf node tree output perform test prescribed event edge result test visit tree child endpoint tree event edge visit tree child endpoint tree event general matching algorithm specialization generic matching algorithm consider section different tests tree related 
algorithm pre process creates matching tree works follows 
assume elementary predicates subscriptions ordered fixed total order 
create matching tree start empty tree process subscription time examining elementary predicates order adding nodes tree necessary 
instance processing sub see equation create nodes test test sub subsequent processing sub see equation create remaining nodes note test added tree 
details algorithm appendix algorithm match uses tree match events 
idea walk matching tree performing test prescribed node edge represents result test edge 
set matching subscriptions leaves visited 
particular algorithm traverses tree depth order clearly orderings breadth 
matching equality tests consider version tree matching algorithm specialized case subscriptions consist conjunctions equality tests attributes constant values 
analyze performance tree matching algorithm special case show time complexity match events sub linear number subscriptions space complexity linear number subscriptions time complexity pre process linear number subscriptions 
precisely section assume subscriptions form sub attr delta delta delta attr vk number attributes schema constant meaning value matches th predicate 
assumption assign level matching tree attribute 
simplicity assume th attribute assigned level level nodes contain test examine contents attribute edges nodes values th attribute tested 
example suppose set subscriptions sub attr attr attr matching tree equality tests sub attr attr attr sub attr attr attr case subscription tree shown 
pre processing function creates tree straightforward appendix matching function section 
analyze performance algorithm 
pre processing time complexity subscription need add matching tree spend time proportional number attributes procedure pre process 
subscriptions total time spent pre process nk 
constant depends event schema pre processing time linear number subscriptions 
space complexity space complexity note subscription add nodes matching tree attribute leaf node containing subscription 
space required matching tree nk linear number subscriptions 
matching time complexity analyze time required match event procedure match 
measure event matching time counting number tree nodes visited match 
reasonable implementation matching procedure match number proportional actual time necessary match event algorithm performs simple elementary test node assumed take constant time 
example typical implementation attribute evaluated value searched hash table determine successor edge successor edge edge followed 
event matching time function set subscriptions large set subscriptions generates large matching tree requires larger time run algorithm 
matching time function particular event matched different events cause different sets nodes visited matching set subscriptions kept constant 
way note algorithm reads subscriptions requires time nk 
handle difficulty consider worst case long take match worst possible event function set subscriptions 
unfortunately cases worst case performance linear number subscriptions 
example value consider tree contains edges labeled edges 
match event attributes need visit nodes tree 
matching time equal size tree 
easy see size tree jsj jsj set subscriptions number attributes schema 
example worst case matching time grows linearly number subscriptions 
rest section take different approach 
compute expected time match random event show subscriptions chosen maximize expected time expected time sub linear number subscriptions 
assume uniform distribution events techniques describe analyze distributions 
simplifying assumption attributes range set values analysis extended general case attributes range different set values extension cumbersome 
henceforth ffl number attributes schema ffl number possible values attribute ffl arbitrary set subscriptions 
ffl expected time match random event set subscriptions 
obtain easy upper bound noting match event follow branches level tree 
total number nodes visited delta delta delta bound unsatisfactory exponential interested bounds polynomial jsj show bound sublinear jsj 
theorem suppose events equally 
expected time match random event bounded gamma gamma ln ln gamma ln ln ln ln gamma 
ln 
introducing results equation derive corollary gamma ln ln 
proceed prove theorem 
henceforth st subscription tree obtained pre process node tree define cost number times node visited run matching algorithm possible events 
note number power example root node tree cost general cost gamma number non edges path root node gives bound time match event just average matching time 
events equally probability node visited matching random event clearly equal gammak cost 
expected number nodes st visited gammak nodes cost nodes st set nodes tree st lemma st contains gamma delta nodes cost equal gammaj proof 
node cost gammaj path root node exactly non edges 
paths uniquely determined number edges path position non edges values non edges 
bound number paths non edges counting possible ways specify 
number edges position non edges distinct numbers gamma delta gamma delta ways choosing 
assign distinct values non edges 
number paths st exactly non edges gamma delta corollary st contains kv nodes cost equal gammaj proof 

kv lemma st nodes 
proof 
subscription associated path edges edge attribute 
path contains nodes 
tree jsj subscriptions nodes 
henceforth order nodes st decreasing order cost cost th node order greater number nodes zero 
equation lemma gammak definition henceforth ax gamma gamma gamma gamma ln ln ln lemma proof 
corollary definition gamma kv kv holds gammai gamma kv delta gamma kv gamma kv gamma delta definition conclude gamma kv delta gammai lemma follows non increasing function 
proof theorem 
gammak gammak gammak dx gammak gamma gamma gamma gamma replacing values simplifying obtain gamma jsj gamma gamma gamma gamma fact gamma jsj gamma replacing value obtain equation 
optimizations general tree matching algorithm certain amount static analysis subscription tree streamline search algorithm 
extremely straightforward obvious optimization collapse chain edges single edge intermediate nodes edge 
example edge node node rewritten lead directly node simulation runs discussed attributes rarely tested subscription simple transformation tree led reduction matching time 
second optimization allows successor nodes precomputed analysis time reducing number attribute re evaluations needed matching time 
optimization assumption parallel steps performed known serial order non edge followed edge 
annotate search data structure information obtained traversing non edges skip tests path implied tests performed non path 
example suppose subscriptions equality tests elementary test simple evaluation attribute matching tree shown follow non paths paths 
suppose matching tree successor node annotations matching event 
follow path ha node find blocked non path follow 
static analysis predict search reaching node traverse paths labeled ha ha ha exist predicates implied ha 
second third paths exist lead nodes analysis time designate successors remaining path dotted node labeled exist successors nodes paths ha ha designated successors 
course node reached edge designated successor 
formally path node ends consecutive non segments successor set ss corresponding path consists paths obtained replacing non segments 
successor node set stored node contains ss pointer node reached path exists nodes successor node set node child node reachable segment labeled child node included successor node set 
general case node successor iff pred pred exist intermediate node pred pred pred 
aggressive static analysis performed 
example suppose know analysis time follow successful test edges 
reached node blocked know ha 
information allows refine successor set know nodes test fail 
replace successor nodes case single node successor form static analysis order nodes matching time constrained non branches followed node reached child node labeled value tested attribute leaf reached 
successor node set determine continue search 
performance approach measured leads increased linear space additional improvement search time relative optimization 
search improved cost increased space factoring certain attributes 
certain attributes preferably subscriptions rarely contain don care tests selected indices 
separate subtree built possible value index attributes 
subtrees include tests index attributes 
subscription minus tests index attributes placed subtree consistent elementary predicates test index attributes 
means subscription don care index attributes values attribute inserted subtrees 
order optimization scalable number index attributes kept small small relative number subscriptions 
related far know algorithms matching problem sub linear time complexity linear space complexity 
content subscription systems developed far adapted scalable matching algorithms 
siena allows content subscriptions distributed network event servers brokers 
siena filters events forwarding servers clients 
scalable matching algorithm server developed 
elvin system uses approach similar siena 
publishers informed subscriptions may quench events generate events subscribers 
plans discussed optimizing elvin event matching integrating algorithm similar 
algorithm converts subscriptions deterministic finite automata matching 
main difference seek matching algorithms worst case space complexity linear number subscriptions space complexity exponential 
algorithm optimizing matching discussed 
analysis time tests ij subscription chosen gating test remaining tests subscription residual tests 
matching time attributes event matched examined 
event value select subscriptions gating tests include ij residual tests selected subscription evaluated residual test fails subscription matched residual tests succeed subscription matched 
tree matching algorithm performs type test attribute just single gating test attribute 
discussion matching algorithm suitable content subscription system 
case subscriptions contain equality tests algorithm matches events expected time sub linear number subscriptions uniform distribution events worst case set subscriptions 
space requirement matching tree linear number subscriptions 
addition theoretical analysis algorithm performance tested variety simulated loads 
tests assumed event schema attributes attribute having possible values 
generated random mix subscriptions follows assumed attributes varied popularity popularity measured likelihood particular performance matching algorithm simulated workload tion contain test attribute opposed don care 
convention attribute popular successive attribute progressively popular degradation factor 
values tested subscriptions varied zipf distribution 
generated random events assuming possible values attribute uniformly distributed 
shows set simulations factoring optimization index attributes subtrees 
values chosen number matches event held independent space measured counting number edges plus size successor sets optimization discussed section 
measurements actual java prototype shown subscriptions match event milliseconds fairly unoptimized algorithm 
analysis results special case attribute tests equality tests 
version algorithm inequality range tests 
definition typical ranges generate simulated loads performance analysis 
theoretical analysis algorithm range tests underway 
working analyzing performance improvements optimizations section 
authors gryphon pub sub system uses matching algorithm equality inequality tests implement distributed high performance content pub sub system 
goal gryphon project advance state art distributed messaging simple group pub sub full featured message brokering system incorporating content queries customized message transformations 
anonymous referees helpful comments 
simulation run pentium mhz 
subscriptions generated randomly probability having attribute 
pre processing algorithm detail pre process algorithm briefly outlined section 
algorithm generate matching tree shown 
matching tree represented set triples triple represents fact edge labeled node node root tree represented specially designed node called tree root node data represents data associated data test leaf subscription leaf 
procedure pre process processes subscription set sub time invoking procedure process sub procedure responsible adding subscription currently existing tree 
initially check tree exists create lines 
loop primitive predicates subscription check tree loop lines 
add remaining primitive predicates tree lines 
loop lines starts root tree tree root proceeds tree successively checking tree contains primitive predicates tq rq subscription 
line check current tree node leaf case replace node primitive predicate exit loop setting false 
line deal case current tree node current test case sub cases tree contain edge current result line tree contains edge line 
sub case simply exit loop setting false 
second sub case follow edge tree continue loop primitive test 
current test continue searching tree follows test current node related result test described section data edge tree follow edge line edge follow edge line edges create edge pointing node exit loop lines 
exit loop lines check primitive predicates need added tree line 
case add predicates followed subscription lines 
add subscription tree follows current node leaf node done subscription tree line follow edges longer possible add subscription tree lines 
pre processing algorithm equality tests section pre process algorithm specialized case subscriptions contain equality tests 
algorithm simpler general 
section assume matching tree represented just leaf nodes contain subscriptions non leaf nodes contain data test associated non leaf node implicit position node tree 
precisely node level tree test associated node level examine contents attribute edges leaving possible values attribute edge 
procedure pre process sub works loops subscription added invokes process sub 
function follow takes value returns node obtained edge node edge exist node function adds tree 
procedure process sub sub set value attribute tested subscription attribute tested set 
done line 
simply call function follow values rk lines 
obtain leaf node add subscription node line 
banavar tushar chandra bodhi mukherjee jay robert strom daniel sturman 
efficient multicast protocol content publish subscribe systems 
technical report ibm 
appear proceedings th ieee international conference distributed computing systems austin texas 
birman 
process group approach reliable distributed computing 
communications acm december 
antonio carzaniga david rosenblum alexander wolf 
design scalable event notification service interface architecture 
technical report cu cs department computer science university colorado august 
john gough glenn smith 
efficient recognition events distributed system 
proceedings adelaide australia 
object management group 
object service specification 
technical report object management group july 
eric hanson chang ho kim wang 
predicate matching algorithm database rule systems 
proceedings sigmod pages atlantic city new jersey may 
mishra larry peterson richard schlichting 
substrate fault tolerant distributed programs 
technical report tr depart 
computer science university arizona november 
brian oki manfred alex dale skeen 
information bus architecture extensible distributed systems 
operating systems review december 
david powell 
group communications 
communications acm april 
bill segall david arnold 
elvin left building publish subscribe notification service quenching 
proceedings auug brisbane australia september 
procedure pre process sub sub sub process sub sub procedure process sub sub sub tq rq number conjunctions sub tree root tree root new node tree root data false true tree root leaf node edge going new node data false data false data data new node data false new node data data sub leaf node nop subscription tree leaf node nop subscription tree new node data sub pre processing algorithm procedure pre process sub sub sub process sub sub function follow node return new node return procedure process sub sub number attributes schema sub attr rk set attribute tested sub tree root tree root new node tree root follow data sub pre processing algorithm equality tests 
