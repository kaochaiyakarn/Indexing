query optimization yannis ioannidis computer sciences department university wisconsin madison wi yannis cs wisc edu imagine standing front bu lled numerous 
goal try need decide order 
exchange tastes maximize pleasure 
pleasurable subjective type problem query optimizers called solve 
query plans database management system dbms follow process produce answer 
plans equivalent terms nal output vary cost amount time need run 
plan needs amount time 
query optimization absolutely necessary dbms 
cost di erence alternatives enormous 
example consider database schema partially supported national science foundation iri iri pyi award dec ibm hp informix oracle 
chapter emp name age sal dno dept dno dname oor budget mgr ano acnt ano type balance bank address consider simple sql query select name oor emp dept emp dno dept dno sal 
assume characteristics database contents structure run time environment parameter description parameter value number emp pages number emp tuples number emp tuples sal number dept pages number dept tuples indices emp clustered tree emp sal levels deep indices dept clustered hashing dept dno average bucket length pages number bu er pages cost disk page access ms consider di erent plans tree nd tuples emp satisfy selection emp sal 
hashing index nd corresponding dept tuples 
nested loops index relations 
dept page scan entire emp relation 
emp tuple agrees dno attribute tuple dept page satis es selection emp sal emp dept tuple pair appears result 
page level nested loops index 
dept tuple scan entire emp relation store emp dept tuple pairs 
scan set pairs check values dno attributes satis es selection emp sal 
tuple level formation cross product subsequent scan test join selection 
calculating expected costs plans shows tremendous di erence ciency equivalent plans may 
needs seconds needs bit hour needs day 
query optimization system may choose plan execute query devastating results 
query optimizers examine alternatives trouble choosing process query 
path query traverses dbms answer generated shown 
system modules functionality query parser checks validity query translates internal form usually relational calculus expression equivalent 
query optimizer examines algebraic expressions equivalent query chooses estimated cheapest 
code generator interpreter transforms access plan generated optimizer calls query processor 
query processor executes query 
queries posed dbms interactive users programs written general purpose programming languages fortran pl queries embedded 
interactive ad hoc query goes entire path shown 
hand embedded query goes rst steps program query parser query optimizer code generator interpreter query processor query language sql relational calculus relational physical algebra record time calls query ow dbms 
compiled compile time 
code produced code generator stored database simply invoked executed query processor control reaches query program execution run time 
independent number times embedded query needs executed optimization repeated database updates access plan invalid index deletion highly suboptimal extensive changes database contents 
real di erence optimizing interactive queries distinction chapter 
area query optimization large database eld 
studied great variety contexts di erent angles giving rise diverse solutions case 
purpose chapter primarily discuss core problems query optimization solutions touch wealth results exist 
speci cally concentrate optimizing single sql query boolean connective quali cation known conjunctive query select project join query nonrecursive horn clause centralized relational dbms assuming full knowledge run time environment exists compile time 
likewise attempt provide complete survey literature cases providing example 
extensive surveys jk mcs 
rest chapter organized follows 
section presents modular architecture query optimizer describes role module 
section analyzes choices exist shapes relational query access plans restrictions usually imposed current optimizers process manageable 
section focuses dynamic programming search strategy commercial query optimizers brie describes alternative strategies proposed 
section de nes problem estimating sizes query results frequency distributions values describes detail histograms represent statistical information typically systems derive estimates 
section discusses query optimization non centralized environments parallel distributed dbmss 
section brie touches advanced types query optimization proposed solve hard problems area 
section summarizes chapter raises questions related query optimization answer 
query optimizer architecture architecture section provide abstraction query optimization process dbms 
database query execution plans exist employed answer query 
principle alternatives need considered best estimated performance chosen 
abstraction process generating testing alternatives shown essentially modular architecture query optimizer 
build optimizer architecture real systems modules shown clear cut boundaries 
entire query optimization rewriting stage declarative planning stage procedural algebraic space method structure space rewriter planner query optimizer architecture 
cost model size distribution estimator process seen having stages rewriting planning 
module rst stage rewriter modules second stage 
functionality modules analyzed 
module functionality rewriter module applies transformations query produces equivalent queries hopefully cient replacement views de nition attening nested queries transformations performed rewriter depend declarative static characteristics queries take account actual query costs speci dbms database concerned 
rewriting known assumed bene cial original query discarded sent stage 
nature rewriting transformations stage operates declarative level 
planner main module ordering stage 
examines possible execution plans query produced previous stage selects cheapest generate answer original query 
employs search strategy examines space execution plans particular fashion 
space determined modules optimizer algebraic space method structure space 
part modules search strategy determine cost running time optimizer low possible 
execution plans examined planner compared estimates cost cheapest may 
costs derived modules optimizer cost model size distribution estimator 
algebraic space module determines action execution orders considered planner query sent 
series actions produce query answer usually di er performance 
usually represented relational algebra formulas tree form 
algorithmic nature objects generated module sent planner planning stage characterized operating procedural level 
method structure space module determines implementation choices exist execution ordered series actions speci ed algebraic space 
choice related available join methods join nested loops merge scan hash join supporting data structures built duplicates eliminated implementation characteristics sort predetermined dbms implementation 
choice related available indices accessing relation determined physical schema database stored catalogs 
algebraic formula tree algebraic space module produces corresponding complete execution plans specify implementation algebraic operator indices 
cost model module speci es arithmetic formulas estimate cost execution plans 
di erent join method di erent index type access general distinct kind step execution plan formula gives cost 
complexity steps formulas simple approximations system certain assumptions regarding issues bu er management disk cpu overlap sequential vs random impor tant input parameters formula size bu er pool corresponding step sizes relations indices accessed possibly various distributions values rela tions 
rst determined dbms query estimated size distribution estimator 
size distribution estimator module speci es sizes possibly frequency dis tributions attribute values database relations indices sub query results estimated 
mentioned estimates needed cost model 
speci es approach adopted module determines form statistics need maintained catalogs database 
description focus modules discussed detail chapter rewriter method structure space cost model 
rewriter module exists commercial dbmss db client server illustra 
transformations normally performed module considered advanced form query optimization part core planning process 
method structure space speci es alternatives regarding join methods indices decisions outside development query optimizer really ect rest 
cost model alternative join method index access ered method structure space standard straightforward formula people devised simple accounting corresponding actions formula tuple level nested loops join numerous variations formulas people proposed approximate actions formulas nding tuples relation having random value attribute 
case derivation formulas considered intrinsic part query optimization eld 
reasons discuss modules section rewriter transformations described 
sections provide detailed description algebraic space planner size distribution estimator modules respectively 
algebraic space mentioned sql query corresponds select project join query relational algebra 
typically algebraic query represented tree leaves database relations non leaf nodes algebraic operators selections denoted projections denoted joins denoted 
intermediate node indicates application corresponding operator relations generated children result sent 
edges tree represent data ow bottom top leaves correspond data database root nal operator producing query answer 
gives examples query trees query select name oor emp dept emp dno dept dno sal simplicity think cross product operator special case join join quali cation 
sal name floor dno dno dept emp emp name floor sal dno dno dept name sal dno name floor name dno dno floor sal examples general query trees 
emp dno dno dept complicated query number query trees may enormous 
reduce size space search strategy explore dbmss usually restrict space ways 
rst typical restriction deals selections projections selections projections processed generate inter mediate relations 
selections processed relations accessed rst time 
projections processed results operators generated 
example plan section satis es restriction index scan emp nds emp tuples satisfy selection emp sal attempts join furthermore projection result attributes occurs join tuples generated 
queries join moot 
queries joins implies operations dealt part join execution 
restriction eliminates suboptimal query trees separate processing selections projections incurs additional costs 
algebraic space module speci es alternative query trees join operators selections projections implicit 
set relations combined query set alternative join trees deter mined algebraic properties join commutativity associativity 
rst determines relation inner outer join execution 
second determines order joins executed 
restriction alternative join trees generated commutativity associativity isvery large relations 
dbmss usually restrict space explored 
particular second typical restriction deals cross products 
cross products formed query asks 
relations combined joins query 
example consider query select name oor balance emp dept acnt emp dno dept dno dept ano acnt ano shows possible join trees modulo join commutativity combine emp dept acnt relations answer query 
trees gure emp dno dno ano ano acnt ano ano dno dno emp dept acnt dept emp acnt examples join trees cross product 
ano ano dno dno tree cross product lower join involves relations emp acnt dept explicitly joined query 
restriction eliminates suboptimal join trees due large size results typically generated cross products 
exceptions cases relations forming cross products extremely small 
algebraic space module speci es alternative join trees involve cross product 
exclusion unnecessary cross products reduces size space explored remains large 
systems restrict space ingres db client server require smaller space db mvs 
particular third typical restriction deals shape join trees 
inner operand join database relation intermediate result 
example consider query select name oor balance address emp dept acnt bank emp dno dept dno dept ano acnt ano acnt bank shows possible cross product free join trees combine emp dept acnt bank relations answer query 
tree satis es restriction trees join intermediate result inner relation 
shape join trees satisfy restriction tree called left deep 
trees outer relation database relation tree called right deep 
trees join intermediate results tree called bushy 
restriction heuristic nature may eliminate optimal plan cases 
claimed optimal left deep tree expensive optimal tree 
typical arguments having original database relations increases preexisting indices 
dno dno emp dept ano ano acnt bank bank acnt dno dno emp dept ano ano acnt bank dept ano ano examples left deep right deep bushy join trees 
dno dno emp having intermediate relations allows sequences nested loops joins executed pipelined fashion 
index usage pipelining reduce cost join trees 
restriction signi cantly reduces number alternative join trees queries relations 
algebraic space module typical query optimizer speci es join trees left deep 
summary typical query optimizers restrictions reduce size space explore 
noted descriptions follow restrictions 
similar argument favor right deep trees regarding sequences hash joins 
planner role planner explore set alternative execution plans speci ed algebraic space method structure space nd cheapest determined cost model size distribution estimator 
subsections deal di erent types search strategies planner may employ exploration 
rst focuses important strategy dynamic programming essentially commercial systems 
second discusses promising approach randomized algorithms third talks search strategies proposed 
dynamic programming algorithms dynamic programming rst proposed query optimization search strategy context system selinger sac 
commercial systems various forms various extensions 
algorithm pretty original form sac ignoring details arise sql queries focus 
algorithm essentially dynamically pruning exhaustive search algorithm 
constructs alternative join trees satisfy restrictions iterating number relations joined far pruning trees known suboptimal 
algorithm detail need discuss issue interesting order 
join methods usually speci ed method structure space module merge scan 
merge scan rst sorts input relations corresponding join attributes merges synchronized scan 
input relations sorted join attribute earlier tree index sorting part earlier merge scan join sorting step skipped relation 
partial plans query optimization compare cost prune expensive take account sorted order result comes 
plans may expensive may generate result sorted attribute save sort subsequent merge scan execution join 
take account possibilities query de nes interesting orders orders intermediate results relation attributes participate joins 
general sql queries attributes order group clauses give rise interesting orders 
example query section orders attributes emp dno dept dno dept ano acnt ano acnt bank interesting 
optimization query result comes sorted attributes partial plan gave result treated specially 
give detailed english description dynamic programming algorithm optimizing query relations step relation query possible ways access existing indices including simple sequential scan obtained 
accessing index takes account query selection index key attribute 
partial single relation plans partitioned equivalence classes interesting order produce result 
additional equivalence class formed partial plans results interesting order 
estimates costs plans obtained cost model module cheapest plan equivalence class retained consideration 
cheapest plan order equivalence class retained cheaper plans 
step pair relations joined query possible ways evaluate join relation access plans retained step obtained 
partitioning pruning partial relation plans proceeds 
step set relations joined query cheapest plans join interesting order known previous step 
step set possible ways join relation creating cross product evaluated 
set relations generated partial plans partitioned pruned 
step possible plans answer query unique set relations joined query generated plans retained previous step 
cheapest plan nal output optimizer process query 
query algorithm guaranteed nd optimal plan satisfying restrictions 
avoids enumerating plans space able dynamically prune suboptimal parts space partial plans generated 
fact general exponential query forms generates plans ol 
example shows dynamic programming full detail takes space 
illustrate basic mechanism showing proceed simple query select name mgr emp dept emp dno dept dno sal oor assume tree index emp sal tree index emp dno hashing index dept oor 
assume dbms supports join methods nested loops merge scan 
types information speci ed method structure space module 
note de nition potential interesting orders emp dno dept dno join attributes query 
algorithm proceeds follows step possible ways access emp dept 
interesting order arises accessing emp tree emp dno generates emp tuples sorted ready join dept entire set alternatives appropriately partitioned shown table 
relation interesting order plan description cost emp emp dno access tree emp dno 
access tree emp sal 
sequential scan 
dept access hashing dept oor 
sequential scan 
partial plan associated hypothetical cost reality costs obtained cost model module 
equivalence class cheapest plan retained step indicated boxes surrounding corresponding costs table 
step query relations step algorithm 
possible ways join emp dept supported join methods partial plans individual relation access retained step 
nested loops method relation inner outer speci ed 
step algorithm issue interesting orders 
entire set alternatives shown table similar step 
hypothetical costs plans optimizer produces output plan indicated box surrounding corresponding cost table 
example illustrates choices ered method structure space addition algebraic space result extraordinary number alternatives optimizer search 
memory requirements running time dynamic programming grow join method outer inner plan description cost nested loops emp dept emp tuple obtained tree emp sal scan dept hashing index dept oor nd tuples matching dno 
emp tuple obtained tree emp dno satisfying selection emp sal scan dept hashing index dept oor nd tuples matching dno 
dept emp dept tuple obtained hashing index dept oor scan emp tree emp sal nd tuples matching dno 
dept tuple obtained hashing index dept oor probe emp tree emp dno value dept dno nd tuples satisfying selection emp sal 
merge scan sort emp tuples resulting accessing tree emp sal 
sort dept tuples resulting accessing hashing index dept oor 
merge 
sort dept tuples resulting accessing hashing index dept oor 
merge emp tuples resulting accessing tree emp dno satisfying selection emp sal 
exponentially query size number joins worst case viable partial plans generated step stored 
fact modern systems place limit size queries submitted usually fteen joins larger queries optimizer crashes due high memory requirements 
queries seen practice involve joins algorithm proved ective contexts 
considered standard query optimization search strategies 
randomized algorithms address inability dynamic programming cope really large queries appear novel application elds algorithms proposed 
randomized algorithms algorithms ip coins decisions appear promising 
important class optimization algorithms plan transformations plan construction dynamic programming includes algorithms simulated annealing iterative improvement phase optimization 
generic algorithms applied variety optimization problems brie described adapted query optimization 
operate searching graph nodes alternative execution plans answer query 
node cost associated goal algorithm nd node globally minimum cost 
randomized algorithms perform random walks graph series moves 
nodes reached move node called neighbors move called uphill resp 
downhill cost source node lower resp 
higher cost destination node 
node global minimum lowest cost nodes 
local minimum paths starting node downhill move comes uphill move 
algorithm description iterative improvement ii nss sg swa performs large number local optimizations 
starts random node repeatedly accepts random downhill moves reaches local minimum 
ii returns local minimum lowest cost 
simulated annealing sa performs continuous random walk accepting downhill moves uphill moves probability trying avoid caught high cost local minimum kgv iw ik 
probability decreases time progresses eventually zero point execution stops 
ii sa returns node lowest cost visited 
phase optimization po algorithm combination ii sa ik 
phase ii run small period time local optimizations performed 
output phase best local minimum initial node phase 
phase sa run starting low probability uphill moves 
intuitively algorithm chooses local minimum searches area able move local minima practically unable climb high hills 
results nite amount time randomized algorithms performance depends characteristics cost function graph connectivity determined neighbors node 
studied extensively query optimization mutually compared compared dynamic programming sg swa iw ik kan 
speci results comparisons vary depending choices regarding issues algorithms implementation setup choices modules query optimizer algebraic space method structure space cost model 
general follows 
joins dynamic programming preferred randomized algorithms faster guarantees nding optimal plan 
larger queries situation reversed despite probabilistic nature randomized algorithms ciency algorithms choice 
second randomized algorithms ii usually nds reasonable plan quickly time sa able nd better plan ii 
po gets best worlds able nd plans sa better shorter time 
search strategies complete picture search strategies brie describe algorithms people proposed past deterministic heuristic randomized 
ibaraki kameda ones proved query optimization np complete problem considering nested loops join method ik 
result orts obtain algorithms solve important subcases query optimization problem run polynomial time 
ibaraki kameda algorithm referred ik takes advantage special form cost formula nested loops optimizes tree query joins logn time 
algorithm applicable cyclic queries nds optimal plan time 
kbz algorithm uses essentially techniques general runs time tree queries kbz 
ik applicability kbz depends cost formulas joins speci form 
nested loops hash join satisfy requirement general merge scan 
ab algorithm mixes deterministic randomized techniques runs time si 
uses kbz subroutine needs time essentially execute times randomly selected spanning trees query graph 
interesting separation cost merge scan part ects optimization part ab applicable join methods despite dependence kbz 
addition sa ii po genetic algorithms gol form class generic ran optimization algorithms applied query optimization 
algorithms simulate biological phenomenon random set solutions problem cost represent initial population pairs solutions population matched cross generate spring obtain characteristics parents new children may randomly changed small ways mutation parents children cost survive generation 
algorithm ends entire population consists copies solution considered optimal 
genetic algorithms implemented query optimization promising results bfi 
interesting randomized approach query optimization pure uniformly random gen eration access plans 
uniform generation hard problem solved tree queries 
cient implementation step experiments algorithm shown potential dependence plan transformations random walks 
arti cial intelligence community heuristic algorithm extensively com plex search problems 
proposed query optimization seen direct extension traditional dynamic programming algorithm yl 
proceeding steps plans relations generate plans relations proceeds expanding generated plans hand time expected prox optimal plan 
generates full plan earlier dynamic programming able prune aggressively branch bound mode 
proposed query optimization shown quite successful large queries 
context extensible dbmss unique search strategies proposed rule 
rules de ned plans constructed modi ed planner follows rules explore speci ed plan space 
representative orts starburst loh volcano exodus gm gd 
starburst optimizer employs constructive rules volcano exodus optimizers employ transformation rules 
size distribution estimator nal module query optimizer examine detail size distribution estimator 
query estimates sizes results sub queries frequency distributions values attributes results 
speci techniques proposed estimation example clarify notion frequency distribution 
consider simple relation left frequency distribution values department attribute right name salary department zeus general management poseidon defense justice aris defense commerce apollo energy energy general management athena education domestic airs demeter agriculture domestic airs energy department frequency general management defense education domestic airs agriculture commerce justice energy generalize discuss distributions frequencies combinations ar numbers attributes 
fact calculate estimate size query involves multiple attributes single relation multi attribute joint frequency distributions approximations required 
practical dbmss deal frequency distributions indi vidual attributes considering possible combinations attributes expensive 
essentially corresponds known attribute value independence assumption rarely true adopted current dbmss 
techniques proposed literature estimate query result sizes frequency distributions contained extensive survey chu sager mcs chr 
commercial dbmss db informix ingres sybase microsoft sql server base estimation histograms description focuses 
brie summarize techniques proposed 
histograms histogram attribute relation domain partitioned buckets uniform distribution assumed bucket 
bucket histogram value vi frequency fi vi approximated vj fj jbj 
histogram single bucket generates approximate frequency attribute values 
histogram called trivial corresponds making uniform distribution assumption entire attribute domain 
note principle arbitrary subset attribute domain may form bucket necessarily consecutive ranges natural order 
histogram histogram frequency approximate frequency approximate department bucket frequency bucket frequency agriculture commerce defense domestic airs education energy general management justice continuing example relation di erent histograms department attribute buckets 
histogram rst show frequencies grouped bucket enclosing shape box circle show resulting approximate frequency average frequencies enclosed identical shapes 
various classes histograms systems researchers proposed es 
earlier prototypes commercial dbmss trivial histograms uniform distribution assumption sac 
assumption rarely holds real data estimates usually large errors chr ic 
ing trivial ones histograms typically belong class equi width histograms koo 
number consecutive attribute values size range attribute values associated bucket independent frequency attribute value data 
histograms store lot information trivial histograms typ ically buckets estimations better 
histogram equi width rst bucket contains values starting second bucket contains values starting 
aware system currently uses histograms class mentioned advanced classes proposed worth discussing 
equi depth equi height histograms essentially duals equi width histograms koo psc 
sum frequencies attribute values associated bucket independent number attribute values 
equi width histograms higher worst case average error variety selection queries equi depth histograms 
dewitt md extended multidimensional histograms appropriate multi attribute selection queries 
serial histograms ic frequencies attribute values associated bucket greater frequencies attribute values associated bucket 
buckets serial histogram group frequencies close interleaving 
histogram earlier table serial frequencies appear bucket frequency appears histogram various optimality criteria serial histograms shown optimal reducing worst case average error equality selection join queries ic ioa ip 
identifying optimal histogram serial ones takes exponential time number buckets 
usually order correlation attribute values frequencies storage serial histograms essentially requires regular index lead approximate frequency individual attribute value 
complexities class biased histograms introduced 
number highest frequencies number lowest frequencies attribute explicitly accurately maintained separate individual buckets remaining middle frequencies approximated single bucket 
biased histograms serial buckets group frequencies interleaving 
identifying optimal biased histogram takes slightly linear time number buckets 
biased histograms require little storage usually attribute values belong single bucket stored explicitly 
experiments shown errors estimates biased histograms far corresponding optimal errors serial histograms 
compromise optimality practicality suggested optimal biased histograms real systems 
techniques addition histograms techniques proposed query result size esti mation mcs chr 
histograms store information database typically approximate frequency distribution parameterized mathematical distribution 
requiring little overhead approaches typically inaccurate real data follow mathematical function 
hand sampling primarily operate run time lns hs hs compute estimates collecting possibly processing random samples data 
producing highly ac estimates sampling quite expensive practicality query optimization questionable especially optimizers need query result size estimations frequently 
non centralized environments preceding discussion focuses query optimization sequential processing 
section touches issues techniques related optimizing queries non centralized environments 
focus method structure space planner modules optimizer remaining ones signi cantly di erent centralized case 
parallel databases parallel architectures shared shared memory paradigms emerged viable ones database query processing 
query optimization research con 
processing choices paradigms er represent increase alternatives ered method structure space module sequential envi ronment 
addition sources alternatives discussed earlier method structure space module ers number processors database operation intra operator parallelism placing operators groups executed simultaneously available processors inter operator parallelism vided pipelining independent parallelism 
scheduling alternatives arise questions add super exponential factor total number alternatives searching formidable task 
systems research prototypes adopt various heuristics avoid dealing large search space 
stage approach hs query rst identi es optimal sequential plan conventional techniques discussed section identi es optimal parallelization scheduling plan 
various techniques proposed literature second stage claims provide complete optimal answer scheduling question remains open research problem 
segmented execution model considers schedules process memory resident right deep segments possibly bushy query plans time independent inter operator parallelism 
shekita syt combined model novel heuristic search strategy results shared memory 
may restricted deal right deep trees sd 
contrast search space reduction heuristics dealt deep bushy trees considering schedules independent parallelism pipelines execution divided phases pipelines phase executed parallel phase start previous phase ended 
search strategy randomized algorithm similar po proved ective identifying cient parallel plans shared architecture distributed databases di erence distributed parallel dbmss formed collection independent semi autonomous processing sites connected network spread large geographic area individual systems controlling multiple processors location usually machine room 
prototypes distributed dbmss implemented bgw ml commercial systems ering distributed versions products db informix sybase oracle 
necessary extensions cost model module main di erences centralized distributed query optimization method structure space module ers additional processing strategies opportunities transmitting data processing multiple sites 
early distributed systems network cost dominating cost key idea processing order transmit tuples certainly contribute join results bgw ml 
extension idea bloom lters bit vectors approximate join columns transferred sites determine tuples participate join may transmitted ml 
advanced types optimization section attempt provide brief glimpse advanced types optimization re searchers proposed past years 
descriptions examples details may provided 
furthermore issues discussed due lack space interesting done nested query optimization rule query optimization query optimizer generators object oriented query optimization optimization materialized views heterogeneous query op timization recursive query optimization aggregate query optimization optimization expensive selection predicates query optimizer validation 
semantic query optimization semantic query optimization form optimization related rewriter module 
basic idea lies integrity constraints de ned database rewrite query semantically equivalent ones kin 
optimized planner regular queries cient plan answer original query 
simple example hypothetical sql syntax consider integrity constraint assert sal constraint emp sal job sr programmer 
consider query select name oor emp dept emp dno dept dno job sr programmer 
integrity constraint query rewritten semantically equivalent include selection sal select name oor emp dept emp dno dept dno job sr programmer sal 
having extra selection help tremendously nding fast plan answer query index database tree emp sal 
hand certainly index exists 
reasons proposals semantic query optimization various heuristics rules rewritings potential bene cial applied 
global query optimization far focused attention optimizing individual queries 
quite multiple queries available optimization time queries unions queries multiple concurrent users queries embedded single program queries deductive system 
optimizing query separately may able obtain global plan possibly suboptimal individual query optimal execution group 
techniques proposed global query optimization sel 
simple example problem global optimization consider queries select name oor emp dept emp dno dept dno job sr programmer select name emp dept emp dno dept dno budget 
depending sizes emp dept relations selectivities selections may computing entire join applying separately selections obtain results queries cient doing join twice time account corresponding selection 
developing planner modules examine available global plans identify optimal goal global multiple query optimizers 
parametric dynamic query optimization mentioned earlier embedded queries typically optimized compile time executed multiple times run time 
temporal separation optimization execution values various parameters optimization may di erent execution 
may chosen plan invalid indices plan longer available simply optimal number available bu er pages operator selectivities changed new indices available 
address issue techniques gw inss cg proposed various search strategies randomized algorithms inss strategy volcano cg optimize queries possible compile time account possible values interesting parameters may run time 
techniques actual parameter values run time simply pick plan optimal little overhead 
drastically di erent avor technique rdb vms ant dynamically monitoring probability distribution plan costs changes plan switching may occur query execution 
summary large extent success dbms lies quality functionality sophistication query optimizer determines system performance 
chapter bird eye view query optimization 
abstraction architecture query optimizer focused techniques currently commercial systems various modules 
addition provided glimpse advanced issues query optimization solutions way practical systems certainly 
query optimization exists eld years surprising fresh remains terms source research problems 
single module architecture questions complete answers simple single query sequential relational optimizations 
worth consider bushy trees just left deep trees 
model bu ering ectively system cost formulas 
ective means estimating cost operators involve random access relations index selection 
search strategy complex queries con dence providing consistent plans similar queries 
optimization execution interleaved complex queries estimate errors grow large 
course attempt mention questions arise various advanced types optimization 
believe years active previous bring advances query optimization technology changing approaches currently practice 
despite age query optimization remains exciting eld 
iwould minos garofalakis joe hellerstein kabra poosala helpful comments 
astrahan system relational approach data management 
acm transactions database systems june 
ant 
dynamic query optimization rdb vms 
proc 
ieee int 
con ference data engineering pages vienna austria march 
bfi bennett ferris ioannidis 
genetic algorithm database query optimization 
proc 
th int 
conference genetic algorithms pages san diego ca july 
bgw bernstein goodman wong reeve 
query processing system distributed databases sdd 
acm tods december 
cg cole graefe 
optimization dynamic query evaluation plans 
proc 
acm sigmod conference management data pages minneapolis mn june 
chr christodoulakis 
implications certain assumptions database performance eval uation 
acm tods june 
chr christodoulakis 
estimation selectivities database performance evaluation 
research report cs dept computer science university june 
gd graefe dewitt 
exodus optimizer generator 
proc 
acm sigmod conf 
management data pages san francisco ca may 
kersten 
fast randomized join order selec tion transformations 
proc 
th int 
vldb conference pages santiago chile september 
available cwi tech 
report cs 
gm graefe mckenna 
volcano optimizer generator extensibility cient search 
proc 
ieee data engineering conf vienna austria march 
gol goldberg 
genetic algorithms search optimization machine learning 
addison wesley reading ma 
gw graefe ward 
dynamic query evaluation plans 
proc 
acm sigmod conference management data pages portland may 
haas starburst mid ight dust clears 
ieee transactions knowl edge data engineering march 
hs hong stonebraker 
optimization parallel query execution plans xprs 
proc 
st int 
pdis conference pages miami fl december 
hs haas swami 
sequential sampling procedures query size estimation 
proc 
acm sigmod conference management data pages san diego ca june 
hs haas swami 
sampling selectivity estimation joins augmented frequent value statistics 
proc 
ieee conference data engineering taipei taiwan march 
ic ioannidis christodoulakis 
propagation errors size join results 
proc 
acm sigmod conference management data pages denver may 
ic ioannidis christodoulakis 
optimal histograms limiting worst case error propagation size join results 
acm tods december 
ik ibaraki kameda 
optimal nesting order computing relational joins 
acm tods september 
ik ioannidis kang 
randomized algorithms optimizing large join queries 
proc 
acm sigmod conference management data pages atlantic city nj may 
inss ioannidis ng shim sellis 
parametric query optimization 
proc 
th int 
vldb conference pages vancouver bc august 
ioa ioannidis 
universality serial histograms 
proc 
th int 
vldb conference pages dublin ireland august 
ip ioannidis poosala 
balancing histogram optimality practicality query result size estimation 
proc 
acm sigmod conference man agement data pages san jose ca may 
iw ioannidis wong 
query optimization simulated annealing 
proc 
acm sigmod conference management data pages san francisco ca may 
jk jarke koch 
query optimization database systems 
acm computing surveys june 
kan kang 
randomized algorithms query optimization 
phd thesis university wisconsin madison may 
kbz krishnamurthy boral zaniolo 
optimization nonrecursive queries 
proceedings th int 
vldb conference pages kyoto japan august 
kgv kirkpatrick gelatt jr vecchi 
optimization simulated anneal ing 
science may 
kin king 
system semantic query optimization relational databases 
proc 
th int 
vldb conference pages cannes france august 
koo 
optimization queries relational databases 
phd thesis case western reserve university september 
lns lipton naughton schneider 
practical selectivity estimation adaptive sampling 
proc 
acm sigmod conference management data pages atlantic city nj may 
loh lohman 
grammar functional rules representing query optimization alter natives 
proc 
acm sigmod conference management data pages chicago il june 
valduriez zait 
ectiveness optimization search strategies parallel execution spaces 
proc 
th int 
vldb conference pages dublin ireland august 
mcs chu sager 
statistical pro le estimation database systems 
acm computing surveys september 
md dewitt 
equi depth histograms estimating selectivity factors multi dimensional queries 
proc 
acm sigmod conference management data pages chicago il june 
ml lohman 
validation performance evaluation distributed queries 
proc 
th int 
vldb conf pages kyoto japan aug 
nss sahni 
simulated annealing combinatorial opti mization 
proc 
rd design automation conference pages 
ol ono lohman 
measuring complexity join enumeration query opti mization 
proceedings th int 
vldb conference pages brisbane australia august 
olken rotem 
simple random sampling relational databases 
proc 
th int 
vldb conference pages kyoto japan august 
psc piatetsky shapiro connell 
accurate estimation number tuples satisfying condition 
proc 
acm sigmod conference management data pages boston ma june 
sac selinger astrahan chamberlin lorie price 
access path selection relational database management system 
proc 
acm sigmod conf 
management data pages boston ma june 
sd schneider dewitt 
tradeo processing complex join queries hashing multiprocessor database machines 
proceedings th int 
vldb conference pages brisbane australia august 
sel sellis 
multiple query optimization 
acm tods march 
sg swami gupta 
optimization large join queries 
proc 
acm sigmod conference management data pages chicago il june 
si swami iyer 
polynomial time algorithm optimizing join queries 
proc 
ieee int 
conference data engineering vienna austria march 
swa swami 
optimization large join queries combining heuristics combinatorial techniques 
proc 
acm sigmod conference management data pages portland june 
syt shekita young 
tan 
multi join optimization symmetric cessors 
proc 
th int 
vldb conf pages dublin ireland aug 
yl yoo 
intelligent search method query optimization 
ieee trans 
knowledge data engineering june 

