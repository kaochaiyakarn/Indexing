advances ai planning daniel weld department computer science engineering university washington box seattle wa usa technical report uw cse appear ai magazine october past years seen dramatic advances planning algorithms emphasis propositional methods graphplan compilers convert planning problems propositional cnf formulae solution systematic stochastic sat methods 
related deep space spacecraft control algorithms advances understanding interleaved planning execution 
survey explain latest techniques suggest areas research 
contents preliminaries 
available implementations 
graphplan descendants expanding planning graph 
solution extraction 
optimizations 
solution extraction constraint satisfaction 
closed world assumption 
action schemata type analysis simplification 
regression focussing 
place graph expansion 
handling expressive action languages 
disjunctive preconditions 
conditional effects 
universal quantification 
compilation planning sat space encodings 
action representation 
frame axioms 
kinds encodings 
comparison graphplan 
optimizations 
sat solvers 
systematic sat solvers 
stochastic sat solvers 
incremental sat solving 
interleaved planning execution monitoring propositional encoding spacecraft capabilities 
real time inference 
discussion planning search 
causal link planning 
handling uncertainty 

field ai planning seeks build control algorithms enable agent synthesize course action achieve goals 
researchers studied planning early days ai developments revolutionized field 
approaches particular attracted attention ffl phase graphplan planning algorithm ffl methods compiling planning problems propositional formulae solution latest speedy systematic stochastic sat algorithms 
approaches common impacted progress constraint satisfaction search technology 
current level performance quite impressive planners quickly solving problems orders magnitude harder years ago 
single representative example blackbox planner requires minutes find action logistics plan world possible states 
furthermore propositional planning closely related algorithms autonomous controller nasa deep space spacecraft scheduled launched late 
result understanding interleaved planning execution advanced speed solve classical planning problems 
goal survey explain advances suggest new directions research 
requires minimal ai background simple logic basic search algorithms suitable wide audience 
progress follows 
remainder defines planning problem surveys freely downloadable planner implementations 
sections discuss graphplan sat compilation interleaved planning execution 
conclude quickly mentioning advances suggestion topics research 
preliminaries simple formulation planning problem defines inputs 
description initial state world formal language 
description agent goal behavior desired formal language 
description possible actions performed formal language 
description called domain theory 
planner output sequence actions executed world satisfying initial state description achieve goal 
note formulation planning problem quite fact really specifies class planning problems parameterized languages represent world goals actions 
example propositional logic describe effects actions quite awkward describe actions universally quantified effects machine shop spray paint action coats objects hopper 
describe effects actions order predicate calculus assumes effects deterministic 
general spectrum expressive languages representing world agent goals possible actions 
start explaining algorithms planning strips representation 
strips representation describes initial state world complete set ground literals 
strips representation restricted goals attainment goals defined propositional conjunction world states satisfying goal formula considered equally 
domain theory formal description actions available agent completes planning problem 
strips representation action described conjunctive precondition conjunctive effect define transition function worlds worlds 
action executed world satisfying precondition formula 
result executing action world described state description adding literal action effect conjunction turn eliminating contradictory literals way 
defines called classical planning problem simplifying assumptions atomic time exogenous events deterministic action effects omniscience part agent 
relax assumptions 
available implementations readers find helpful experiment implementations ideas discussed 
fortunately variety freely distributed alternatives accept domains expressed pddl syntax language aips planning competition expect widely adopted standard teaching purposes collaborative domain interchange performance comparison 
ffl graphplan descendants acronym strips stands stanford research institute problem solver famous influential planner built control unstable mobile robot known shakey 
see ftp ftp cs yale edu pub mcdermott software pddl tar gz pddl specification 
see ftp cs yale edu pub mcdermott results html competition results 
graphplan original somewhat dated implementation available www cs cmu edu afs cs cmu edu user avrim www graphplan html :10.1.1.43.7263
ipp highly optimized implementation graphplan extended handle expressive actions universal quantification conditional effects download www informatik uni freiburg de koehler 
stan highly optimized implementation uses place graph representation performs sophisticated type analysis compute invariants 
download www dur ac uk dcs www research html 
sgp simple pedagogical lisp implementation graphplan extended handle universal quantification conditional effects uncertainty see www cs washington edu research projects ai www sgp html 
ffl systems compilation sat highest performance sat compiler blackbox available www research att com kautz blackbox index html 
medic planner flexible testbed implemented lisp allowing direct comparison dozen different sat encodings see ftp ftp cs washington edu pub ai medic tar gz 
graphplan descendants blum furst graphplan algorithm exciting developments ai planning reasons ffl graphplan simple elegant algorithm yields extremely speedy planner cases orders magnitude faster previous systems snlp prodigy ucpop :10.1.1.57.3126
ffl representations graphplan form basis successful encodings planning problems propositional sat familiarity graphplan aids understanding sat systems section 
graphplan alternates phases graph expansion solution extraction 
graph expansion phase extends planning graph forward time achieved necessary insufficient condition plan existence 
solution extraction phase performs backward chaining search graph looking plan solves problem solution cycle repeats expanding planning graph 
start discussion considering initial formulation graphplan restricting attention strips planning problems deterministic fully specified world 
words preconditions effects actions conjunctions literals positive literals denoting entries add lists negative literals correspond elements delete list 
covering basics describe optimizations explain handle expressive action languages 


planning graph alternates proposition circle action square layers 
horizontal grey lines proposition layers represent maintenance actions encode possibility unaffected propositions persist layer 
expanding planning graph planning graph contains types nodes proposition nodes action nodes arranged levels 
numbered levels contain proposition nodes ground literals zeroth level consists precisely propositions true initial state planning problem 
nodes levels correspond action instances node action instance preconditions mutually consistent previous level 
edges connect proposition nodes action instances level preconditions mention propositions additional edges connect action nodes subsequent propositions true action effects 
note planning graph represents parallel actions action level 
means planning graph action levels represent plan actions 
just actions included planning graph level doesn mean possible execute 
central graphplan efficiency inference regarding binary mutual exclusion relation mutex nodes level 
define relation recursively follows see ffl action instances level mutex inconsistent effects effect action negation action effect interference action deletes precondition competing needs actions preconditions mutually exclusive level gamma 
inconsistent effects interference competing needs inconsistent support graphical depiction mutex definition devised david smith 
circles denote propositions squares represent actions thin curved lines denote mutex relations 
parts illustrate deduction new action action mutex dark boxes rightmost part depicts discovery new mutex propositions dark circles 
initial conditions garbage quiet goal dinner garbage actions cook precondition effect dinner wrap precondition quiet effect carry precondition effect garbage dolly precondition effect garbage quiet strips specification dinner date problem 
ffl propositions level mutex negation ways achieving propositions actions level gamma pairwise mutex inconsistent support 
example consider problem preparing surprise date sleeping 
goal take garbage fix dinner wrap 
possible actions cook wrap carry dolly 
cook requires achieves dinner 
wrap precondition quiet gift surprise wake recipient produces 
carry eliminates garbage intimate contact container negates 
final action dolly eliminates garbage noisy negates quiet 
initially house garbage quiet propositions false 
shows planning graph dinner date problem expanded quiet quiet quiet dinner carry dolly cook wrap planning graph dinner date problem expanded level 
action names surrounded boxes horizontal grey lines proposition layers represent maintenance actions encode persistence 
thin curved lines actions propositions single level denote mutex relations 
level zero action proposition level 
note carry action mutex persistence garbage inconsistent effects 
dolly mutex wrap interference dolly deletes quiet 
proposition level quiet mutex inconsistent support 
recall goal dinner date problem achieve garbage dinner 
literals proposition level mutex chance plan exists 
case second phase graphplan executed solution extraction 
solution extraction suppose graphplan trying generate plan goal subgoal conjuncts example extended planning graph level goal propositions pairwise mutex 
necessary insufficient condition plan existence graphplan performs solution extraction backward chaining search see plan exists current planning graph 
solution extraction searches plan considering subgoals turn 
literal level graphplan chooses action level quiet quiet dinner carry dolly cook wrap quiet quiet quiet dinner carry dolly cook wrap planning graph dinner date problem expanded level 
new literals proposition level dinner additional support persistence actions result graphplan solution extraction search find plan 
gamma achieves subgoal 
choice backtrack point action produces subgoal graphplan consider order ensure completeness 
consistent actions chosen far level graphplan proceeds subgoal choice available graphplan backtracks previous choice 
graphplan consistent set actions level gamma recursively tries find plan set formed union preconditions actions level gamma 
base case recursion level zero propositions graphplan solution 
backtracking fails combinations possible supporting actions subgoal level graphplan extends planning graph additional action proposition levels tries solution extraction 
dinner date example subgoals level 
garbage supported carry dolly dinner supported cook supported wrap 
graphplan consider sets actions level cook cook unfortunately sets consistent carry mutex cook dolly mutex wrap 
solution extraction fails graphplan extends planning graph level shown 
note difference levels planning graph 
new literals level fewer mutex relations 
example mutex dinner level 
important difference level additional maintenance actions encoding possible persistence literals achieved level 
means subgoals additional supporting actions consideration backward chaining process solution extraction 
specifically ffl garbage supported carry dolly maintenance action 
ffl dinner supported cook maintenance action 
ffl supported wrap maintenance action 
solution extraction needs consider theta theta combinations supporting actions level theta theta combinations previous attempt solution extraction 
increased flexibility allows solution extraction find plan 
combinations illustrate 
support garbage carry support dinner maintenance action support wrap 
actions mutex choices level consistent 
selection actions lead subgoals level dinner precondition maintenance action quiet precondition wrap carry preconditions level subgoals 
solution extraction recurses chooses cook support dinner maintenance action support quiet actions aren mutex selections level consistent 
preconditions actions create subgoals level zero quiet 
propositions initial conditions selection consistent solution plan exists 
illustrates results solution extraction 
note graphplan generates inherently parallel partially ordered plan 
actions selected level carry wrap executed order achieve effect 
wishes totally ordered sequence actions plan may choose arbitrarily cook carry wrap 
optimizations far covered basic graphplan algorithm optimizations huge effect efficiency 
improvements speed solution extraction forward checking memoization learning 
second set optimizations concern graph expansion process handling closed world assumption compilation action schemata remove static fluents type analysis regression focussing place graph expansion 
carry dolly cook wrap quiet quiet quiet dinner carry dolly cook wrap quiet quiet dinner plans solution extraction 
actions black executed 
benefit achieved optimizations depends specific planning problem solved 
worst case planning graph expansion polynomial time solution extraction exponential :10.1.1.43.7263
planning problems expansion time dominates optimizations described important 
solution extraction constraint satisfaction observing connection graphplan solution extraction process constraint satisfaction problems transfer insights csp field planning 
possible formulations simplest terms dynamic csp constraint satisfaction problem set variables associated constraints changes selection values earlier variables 
csp variable subgoal literals proposition level level zero 
domain variable set possible values set supporting actions previous level 
long history research applying ideas constraint satisfaction planning focus applications graphplan compilation planning sat viewed constraint satisfaction perspective logical see seminal constraint posting planning 
tweak snlp ucpop manipulated explicit codesignation ordering constraints :10.1.1.57.3126
describes planner represented decisions constraints 
provides formal framework planning compares different planners terms way handle constraints 
modern constraint posting planner 
set constraints defined mutex relations 
example consider process solution extraction level dinner date graph shown 
initially create csp variable subgoal level garbage takes value dolly dinner takes value 
assignments garbage carry dinner maintain wrap corresponds part shown 
solution variables proposition level actions corresponding variable values define csp problem level 
note requirement perform search level level 
words previous description solution extraction dictated finding consistent set actions level performing search level gamma 
methodical order unnecessary potentially inefficient 
example blackbox planner takes planning graph compiles sat uses fast stochastic methods perform equivalent solution extraction search jumps level level greedy fashion 
rintanen describes opportunistic non directional search strategy bypasses conversion sat 
csp formulation solution extraction unremarkable suggests certain strategies speeding search forward checking dynamic variable ordering memoization conflict directed backjumping 
ffl assigning value variable simple csp solvers check ensure choice consistent values previously chosen 
better strategy called forward checking checks unassigned variables addition shrinking domain eliminating values inconsistent choice 
domain unassigned variable collapses shrinks empty set csp solver backtrack 
shows analytically forward checking excellent strategy strengthening previous empirical support 
ffl dynamic variable ordering refers class heuristics choosing csp variable assigned value 
course eventually variables values assigned order selected huge impact efficiency 
note variable choice clearly best assignment immediately 
general heuristic select variable fewest remaining nonconflicting values information readily available forward checking employed 
similar heuristics investigated context causal link planners see 
techniques lead significant performance improvements graphplan 
method determining subgoal ordering structural analysis subgoal interactions 
precomputation aimed calculating speedy subgoal orderings closely related abstraction planning 
general distinguish domain specific approaches action definitions problem specific approaches additionally goal initial state specifications problem specific approaches typically provide leverage cost domain specific precomputation amortized planning problems 
koehler describes problem specific method speeds graphplan orders magnitude problems domains 
ffl original graphplan describes technique called memoization caches results learned exhaustive search inconsistent subgoal sets :10.1.1.43.7263
suppose solution extraction called level course search attempts achieve subgoals level 
combinations supporting actions subgoals proves consistent regardless level inconsistency detected graphplan records set fp sg nogood level graphplan extends planning graph level attempts solution extraction attempt achieve goals level time backtrack immediately performing exhaustive search 
memoization process trades space time space requirements large resulting speedups significant 
stated memoization process simplistic sophisticated approaches proven effective systematic sat solvers suspect memoization improvements possible :10.1.1.102.1237
kambhampati demonstrates dramatic speedups times faster depending domain 
basic idea determine subset goals responsible failure level record subset solution extraction returns level set superset failure justified 
approach leads smaller general nogoods example case subgoals unachievable regardless additional idea described regression level failure explanations action definitions level calculate failure conditions level 
level conditions short searches terminated quickly 
methods see additional uses precomputation analysis action interactions drive parameters precondition vehicle location location road connected effect parameterized specification action driving vehicle source location destination 
kambhampati earlier relationship traditional planning speedup methods explanation learning csp methods 
closed world assumption closed world assumption says proposition explicitly known true initial state presumed false 
simple way implementing closed world assumption graphplan explicitly close zeroth level planning graph add negative literals possible propositions explicitly stated true 
infinite number possible propositions restrict approach relevant subset mentioned preconditions action goal literals affect solution 
better solution handle closed world assumption lazily shrinks size planning graph diminishes cost graph expansion 
create zeroth level planning graph adding propositions known true initial state shown 
expanding planning graph action level 
suppose action requires precondition 
planning graph level gamma simply link usual 
missing level gamma check see negation proposition level zero 
absent level zero add level zero add maintenance actions mutexes carry current level 
simple approach changes necessary solution extraction 
note issue closed world assumption rose respect dinner date example actions negative precondition 
goal include negative literal garbage positive proposition garbage initial conditions closed world assumption 
drive truck seattle tacoma precondition truck seattle effect truck seattle truck tacoma ground instance drive type analysis elimination timeless true static preconditions 
compare schema 
action schemata type analysis simplification dinner date example actions propositional realistic domains convenient define parameterized action schemata 
example logistics domain define operation driving truck shown 
intuition simply level abstraction driving vehicle preconditions effects driving write 
action schemata requires changes planning graph expansion routine action levels planner instantiate parameterized schema create possible ground actions considering combinations appropriately typed constants 
example order handle drive schema system create ground drive actions assuming constants defined initial state world 
ground combinations irrelevant selection constants parameters satisfy preconditions 
example bound seattle presumably ground precondition vehicle seattle satisfied 
important optimization involves type analysis determines predicates represent types calculates set constants form extent type instantiates ground actions plausibly typed combinations constants 
simplest form type analysis scans set predicates initial conditions absent effects action schemata 
predicates location vehicle static terms formed predicates location seattle vehicle truck change 
planner may conclude seattle extent location type similarly reason vehicle 
static terms instantiation time need include terms planning graph action schemata include terms preconditions simplified instantiation eliminating static preconditions 
furthermore simplification limited unary predicates 
example vehicle location road connected static instances actions instantiated constants obey preconditions planning graph expansion may add ground action instances shown eliminate static terms proposition levels planning graph 
fox devised sophisticated polynomial time planner independent type inference methods deduce state invariants demonstrate analysis significantly speed version graphplan domains 
method observation planning domain viewed collection finite state machines domain constants traverse states corresponding predicates 
regression focussing described previously planning graph proposition levels contains actions possibly executed initial state world reachable initial state 
actions planning graph may irrelevant goal hand 
words graph expansion algorithm uninformed goal planning problem result time may wasted adding useless actions effects graph reasoning mutex relations involving irrelevant facts 
optimizations proposed graph expansion goaldirected heuristically filtering facts initial state fact generation graph backward expansion planning graph 
fact generation graph graph created problem goal domain actions follows 
root graph node corresponding goal children conjunctive subgoals 
subgoal node children correspond different ground actions effect 
structure tree order avoid exponential blowup nodes reused levels graph 
say node solved initial conditions immediate child solved node solved children solved 
fact generation graph ignores subgoal interactions negative literals solution depth fact generation graph necessary insufficient condition solution depth planning graph 
risk incompleteness may try speed planning eliminating initial conditions ground actions don appear appear infrequently fact generation graph 
note approach similar motivated mcdermott greedy regression graph heuristic 
similar approach due provides speedup sacrificing completeness 
recall graphplan follows simple loop expand planning graph action proposition levels attempt solution extraction plan repeat 
kambhampati modified loop grow planning graph backwards subgoals action proposition level grow graph forwards intersection initial state backward propositional fringe including ground actions added backwards propagation adding mutex relations fox point method dramatically improve process designing debugging maintaining complex planning domains 
word strong planning graph contain actions executed 
strictly speaking planning graph contains proper superset executable actions close approximation set 
forming solution extraction necessary 
solution extraction failed find plan kambhampati system grow graph backwards pair levels compute new larger intersection initial state resume forward growth 
kambhampati implementation regenerated graphs scratch stage duplicating discovery mutex relations resulting planning graph smaller system outperformed basic graphplan problems 
place graph expansion avoid duplicated regression focussing exploiting observations concerning monotonicity planning graph 
ffl propositions increasing proposition level appear level subsequent proposition levels 
ffl actions increasing action level appear level subsequent action levels 
ffl mutexes monotonically decreasing mutex actions level previous action levels appear 
true mutexes propositions 
ffl nogoods monotonically decreasing subgoals unachievable level unachievable previous proposition levels 
observation suggest dispense multi level planning graph altogether 
needs bipartite graph action proposition nodes 
arcs propositions actions denote precondition relation arcs actions propositions encode effects 
action proposition mutex nogood structures annotated integer label field proposition action nodes integer denotes planning graph level proposition action appears 
mutex nogood nodes label marks level relation holds 
adding additional set labels may interleave forward backward expansion planning graph 
scheme time space costs expansion phase vastly decreased bookkeeping required surprisingly tricky see details see stan planner wavefront representation 
proof sketch appear level gamma mutex level definition mutex due inconsistent effects interference competing needs 
mutex due reasons mutex occur level containing mutex due competing needs preconditions respectively mutex level gamma 
propositional mutex result fact level gamma actions supporting pairwise mutex inductive argument combined action monotonicity completes proof 
proof sketch achievable level gamma adding level maintenance actions achieve level handling expressive action languages discussion restricted problem planning strips representation actions limited quantifier free conjunctive preconditions effects 
representation severely limited section discusses extensions expressive representations aimed complex real world domains 
focus disjunctive preconditions conditional effects universally quantified preconditions effects areas received attention 
koehler developed methods handling resource constraints discuss uncertainty describing methods compiling planning problems sat 
capabilities domain axioms procedural attachment numeric fluents exogenous events actions temporal duration beg exploration 
disjunctive preconditions easy extend graphplan handle disjunctive preconditions 
conceptually precondition may contain nested ands ors converted disjunctive normal form dnf 
planning graph extended action schema precondition contains multiple disjuncts action instance may added disjunct conjuncts previous level 
solution extraction phase planner level considers action disjunctive preconditions consider possible precondition disjuncts level gamma ensure completeness 
disjunctive effects harder imply nondeterminism predict precise effect execution advance 
result require general approach uncertainty discuss near 
conditional effects conditional effects describe actions effects context dependent 
basic idea simple allow special clause syntax action effects 
takes arguments antecedent consequent execution action consequent effect just case antecedent true immediately execution action precondition determines execution legal reason antecedent referred secondary precondition 
note action precondition antecedent part refers world action executed consequent refers world execution 
assume consequent conjunction positive negative literals 
illustrates conditional effects allow define single action schema accounts driving vehicle may possibly contain spare tire cargo 
methods devised allowing graphplan derivative planners handle action schemata conditional effects full expansion factored drive parameters precondition vehicle location location road connected effect cargo cargo cargo spare tire spare tire spare tire conditional effects allow drive schema vehicle empty contains cargo spare tire 
expansion partially factored 
simplest approach full expansion rewrites action schema containing conditional effects number mutually exclusive strips schemata considering minimal consistent combinations antecedents conditional effects 
example action schema broken separate strips schemata shown empty vehicle vehicle cargo vehicle spare tire vehicle cargo spare 
full expansion advantage simplicity result exponential explosion number actions 
spare fuel drum vehicle full expansion generate strips schemata 
general action conditional effects containing antecedent conjuncts full expansion may produce strips actions 
explosion common conditional effects universally quantified 
essence schema conditional effect object possibly put truck 
cargo items full expansion yield strips schemata 
approaches dealing conditional effects consider conditional effects primitive elements handled graphplan 
note contrast strips actions produced full expansion action conditional effects mutually exclusive independent antecedent effect may imply 
advantage factored expansion increase performance 
avoiding need expand actions containing conditional effects exponential number plain strips actions factored expansion yields dramatic speedup 
increased performance comes expense complexity essence effects conditional action preconditions added antecedent conditional effect unavoidable effects changing vehicle location form new conditional effect just action preconditions antecedent 
drive empty parameters precondition vehicle location location road connected cargo spare tire effect drive cargo parameters precondition vehicle location location road connected cargo spare tire effect cargo cargo drive spare parameters precondition vehicle location location road connected cargo spare tire effect spare tire spare tire drive parameters precondition vehicle location location road connected cargo spare tire effect cargo cargo spare tire spare tire strips schemas driving possible contents 
ffl factored expansion reasons individual effects actions complete actions complex rules required order define necessary mutual exclusion constraints planning graph construction 
tricky extension stems case conditional effect induced impossible execute effect causing happen 
ffl factored expansion complicates solution extraction need perform analog confrontation prevent antecedent undesirable effects occuring 
ipp planner uses third method handling conditional effects call partially factored expansion 
primary difference stems ipp mutex rules state actions marked mutex unconditional effects preconditions conflict 
difference allows ipp computation graph expansion reduces number mutex constraints 
domains difference doesn matter cases movie watching domain factored expansion performs exponentially better ipp 
drive parameters precondition vehicle location location road connected effect forall object universally quantified conditional schemata driving 
universal quantification graphplan descendants ipp sgp allow action schemata universal quantification 
preconditions universal quantification lets conveniently describe real world actions unix rmdir command deletes directory files inside deleted 
universally quantified effects allow describe actions chmod set protection files directory 
naturally universal quantification equally useful describing physical domains 
shown universally quantified conditional effect say objects vehicle change result driving 
add universal quantification graphplan helps simplifying assumptions 
specifically assume world modeled finite static universe typed objects 
object universe initial state description include unary atomic sentence declaring type 
example initial description include sentences form vehicle truck location vehicle location types 
assumption static universe means action effects may assert type information 
example action allowed assert vehicle truck effect amount destruction object assumption forbids destruction creation objects 
assure systematic establishment goals preconditions universally quantified clauses modify graph expansion phase map formulae corresponding ground version 
herbrand base upsilon order function free sentence delta defined recursively follows upsilon delta delta delta contains quantifiers upsilon delta upsilon delta upsilon delta see previous section action schemata explanation types 
fine object multiple types stated explicitly form inheritance reasoning added graph expansion process 
delta correspond possible interpretation delta universe discourse fc cng possible objects type 
delta replaced constant example suppose universe vehicle loader plane 
delta forall vehicle seattle herbrand base upsilon delta conjunction truck seattle loader seattle plane seattle static universe assumption goal satisfied universally quantified goal satisfied 
note herbrand base formula containing universal quantifiers ground may formulae form action effects 
easy handle existential quantifiers interleaved arbitrarily universal quantification expression goal action precondition antecedent conditional effect 
existential quantifiers allowed action effects equivalent disjunctive effects described imply nondeterminism require reasoning uncertainty 
order handle existential quantification goals needs extend definition herbrand base follows 
upsilon delta upsilon delta upsilon delta upsilon delta upsilon delta delta correspond possible interpretation delta universe discourse type fc cng 
delta replaced constant addition replaced skolem constants 
existential quantifiers eliminated remaining free variables act skolem constants implicitly existentially quantified treated just action schemata parameters graph expansion 
careful generate skolem constant possible assignment values universally quantified variables enclosing scope need generate reason skolem functions 
words enumerate set ff cn member universe generate appropriate set clauses delta substitution renaming 
type universe assumed finite herbrand base guaranteed finite 
examples illustrate handling existential quantification 
suppose universe location delta exists location forall vehicle note definition relies fact type finite universe result skolem constants generated 
leading universally quantified variables type skolem constants necessary 
herbrand base location truck loader plane final example suppose delta forall location exists vehicle universal base contains skolem constants treated parameters vehicle seattle vehicle locations skolem constants exhaust range skolem function domain universe vehicles 
finite static universe assumption expansion creating herbrand base 
summary allow universal quantifiers action effects goals preconditions effect antecedents may interleaved universal existential quantifiers 
quantified formulae compiled corresponding herbrand base remaining variables treated action schemata parameters graph expansion 
resulting planning graph contains quantifier free ground action instances changes required solution extraction 
compilation planning sat despite early formulation planning theorem proving researchers long assumed special purpose planning algorithms necessary practical performance 
algorithms tweak snlp ucpop graphplan may viewed special purpose theorem provers aimed planning problems :10.1.1.43.7263:10.1.1.57.3126
improvements performance propositional satisfiability methods call endeavor doubt 
initial results compiling bounded length planning problems sat unremarkable experiments suggest compilation sat yield world fastest strips style planner :10.1.1.38.4843
shows architecture typical sat planning system medic blackbox 
compiler takes planning problem input guesses plan length generates propositional logic formula satisfied implies existence solution plan symbol table records correspondence propositional variables planning instance 
simplifier uses fast linear time techniques unit clause propagation pure literal elimination shrink cnf formula 
solver uses systematic stochastic methods find satisfying assignment compiler simplifier solver cnf cnf symbol table increment time bound unsatisfiable decoder satisfying assignment plan init state goal actions architecture typical sat planning system 
decoder translates symbol table solution plan 
solver finds formula unsatisfiable compiler generates new encoding reflecting longer plan length 
space encodings compilers high level programming languages lisp compared basis speed quality machine code produce 
notions carry sat compilers 
wishes compiler quickly produce small sat encoding solver speed exponential size formula tested 
measure size complicated fact propositional formula measured terms number variables number clauses total number literals summed clauses decrease parameter variables say increase clauses 
factors determine sizes encoding optimizations 
encoding fundamental notion focus presenting parameterized space possibilities developed dimensions ffl choice regular simply split overloaded split bitwise action representation specifies correspondence propositional variables ground fully instantiated plan actions 
choices represent different points tradeoff number variables number clauses formula 
ffl choice classical explanatory frame axioms varies way stationary fluents constrained 
encodings uses standard fluent model time takes nonnegative integer values 
state fluents occur numbered times actions odd times 
example context dinner date problem described previously propositional variable means garbage initial state signifies garbage executing set parallel actions carry means carry action executed time 
encodings uses set universal axioms init initial state completely specified time zero including properties presumed false closed world assumption 
dinner date problem gets quiet dinner goal order test plan length desired goal properties asserted true time goal state need fully specified 
assuming desired dinner date plan length gets dinner actions imply preconditions effects 
odd time gamma consistent ground action axiom asserts execution action time implies effects hold preconditions hold gamma 
generate numerous clauses applied action schemata context world objects simple non parameterized cook action gets carry dinner carry action representation major encoding choice represent names ground action instances regular simply split overloaded split bitwise format 
choice irrelevant purely propositional planning problems dinner date example crucial parameterized action schemata strips drive schema shown 
regular representation ground action represented different logical variable total ps variables denotes number odd time steps number action schema denotes maximum number parameters action schemata number objects domain 
systematic solvers take worst case time exponential number variables large numbers variables slow stochastic solvers reduce number 
order introduced simple action splitting replaces ary action fluent unary fluents encoding :10.1.1.38.4843
example variables form drive truck seattle replaced conjunction truck seattle 
doing action reduces number note nonstandard notation order emphasize combinatorics 
write denote propositional variable functional term order predicate calculus 
treated substructure 
aspect clear better write symbol prefer notation clearly illustrates effects representational differences cnf size 
variables needed represent actions action single variable described conjunction variables 
simple splitting representation instances action schemata share propositional variables 
alternative overloaded splitting operators share split fluents 
overloaded splitting replaces drive truck seattle conjunction act drive arg truck arg seattle arg different action load truck drum replaced act load arg truck arg drum 
technique reduces number variables needed represent actions 
bitwise representation shrinks number variables representing action instances dlog ps propositional symbols odd time step variable representing bit 
ground action instances numbered ps gamma 
number encoded bit symbols determines ground action executes odd time step 
instance ground actions bit bit replace action bit bit replace second forth 
action representation best 
experiments need performed preliminary results suggest regular simply split representations choices 
contrast bitwise overloaded result convoluted encodings resist simplification type analysis 
example bitwise encoding yields smallest number propositional variables simplification linear time procedure described shrunk cnf formulae representations bitwise variables 
frame axioms encoding requires axioms confront frame problem 
frame frame axioms constrain unaffected fluents action occurs 
alternatives classical explanatory frames 
classical frame axioms state fluents left unchanged action 
example classical frame axiom strips drive schemata say driving vehicle truck seattle leaves truck location kent unchanged truck kent gamma drive truck seattle truck kent encoding propositional write version axiom combination possible location truck source location truck destination truck 
aren trucks combinations 
note regular action representation implied choice variable drive truck seattle different representation desired frame axiom contain literals 
adding classical frame axioms action odd time universal axioms produces valid encoding planning problem 
action occurs time axioms encoding infer truth value fluents time take arbitrary values 
solution add axioms time step 
disjunction possible fully instantiated action ensures action occurs odd time step 
maintenance action inserted preprocessing step 
note action representation huge effect size axiom 
resulting plan consists totally ordered sequence actions corresponds roughly linear encoding include exclusion axioms see ensure action active time 
exclusion axioms unnecessary classical frame axioms combined axioms ensure actions occurring time lead identical world state time 
action occur time step selected form valid plan 
explanatory frame axioms enumerate set actions occurred order account state change 
example explanatory frame axiom say actions caused truck left seattle 
truck gamma truck drive truck seattle drive truck seattle kent drive truck seattle tacoma note choice action representation affects length frame axioms 
furthermore note axiom simplified dramatically different representation chosen 
example simply split representation straight translation yields 
truck gamma truck truck seattle truck seattle kent truck seattle tacoma disjunction really just enumerating possible destinations silly compiler factoring optimization recognizing parameters affect literals generating simplified frames axioms example compiler generate vastly simpler fact factoring optimization applied axiom types just frame axioms 
truck gamma truck truck seattle supplement universal axioms explanatory frame axioms added ground fluent odd time produce reasonable encoding 
explanatory frames change fluent truth value implies action occurs action occurs time step correctly treated maintenance action 
axioms required 
explanatory frame axioms brings important benefit explicitly force fluents unaffected executing action remain unchanged explanatory frames permit parallelism 
specifically actions preconditions satisfied time effects contradict executed parallel 
parallelism important allows encode step plan odd time steps small encodings 
uncontrolled parallelism problematic create valid plans linear solution 
example suppose action ff precondition effect action fi precondition effect actions executed parallel effects contradictory legal total ordering actions 
explicitly rule type pathologic behavior axioms exclusion linearizability resulting plans guaranteed restricting actions may occur simultaneously 
kinds exclusion enforce different constraints resulting plan ffl complete exclusion odd time step distinct action pairs ff fi add clauses form ff fi complete exclusion ensures action occurs time step guaranteeing totally ordered plan 
ffl conflict exclusion odd time step distinct conflicting action pairs ff fi add clauses form ff fi framework actions conflict precondition inconsistent effect 
conflict exclusion results plans actions form partial order 
total order consistent partial order valid plan 
note conflict exclusion isolation split action representation splitting causes unique variable fully instantiated action 
example simple splitting impossible instantiations action schema execute time split fluents interfere 
overloaded splitting contrast definition conflict graphplan :10.1.1.43.7263:10.1.1.38.4843
kautz selman parallel encoding linear encodings axioms stating actions imply effects parallel encoding prohibits effect effect conflicts 
disallows instantiations different actions execute time requires complete exclusion 
simple splitting may conflict exclusion augmented additional axioms ban multiple instances single schema executing 
bitwise action representation requires action exclusion axioms 
time step fully instantiated action index represented bit symbols total ordering guaranteed 
best way represent frame axioms 
experience shows explanatory frame axioms clearly superior classical frames case 
parallel actions encode longer plans number time steps conflict exclusion possible regular action representation minimal additional exclusions necessary simply split representation 
kinds encodings medic planning compiler uses taxonomy described generate twelve different encodings 
addition medic incorporates switch selectable optimizations type analysis features medic powerful testbed research sat planning 
encodings fit taxonomy generated medic 
causal encoding causal link representation partial order planners snlp 
encoding shown smallest encoding measured asymptotically constant factors large despite efforts succeeded building practical compiler idea 
done exploring ways encoding hierarchical task network htn planning sat problem 
comparison graphplan note strong similarities graphplan derivative sat planning systems 
ffl approaches convert parameterized action schemata finite propositional structure planning graph cnf formula representing space possible plans length 
ffl approaches local consistency methods mutex propagation propositional simplification resorting exhaustive search 
ffl approaches iteratively expand propositional structure find solution 
kautz selman showed planning graph automatically converted cnf notation solution sat solvers constructing propositional formulae stating :10.1.1.38.4843
fully specified initial state holds level zero goal holds highest level init goal axioms 

conflicting actions mutually exclusive conflict exclusion axioms 

actions imply preconditions precondition part axioms 

fact positive levels implies disjunction actions previous levels including maintenance actions 
example consider dinner date proposition level obtains dolly carry maintain kautz observe encoding close combination explanatory frames regular action representation differences 
encoding explicitly include explanatory frame axioms may generated resolving axioms type actions imply preconditions axioms maintenance actions 
second axioms stating actions imply effects spurious actions may included solution removed decoder 
fortunately conflict exclusion axioms prevent spurious actions interfering rest plan 
blackbox system uses graphplan encoding provide fast planner 
blackbox uses graph expansion phase ipp create planning graph converts graph cnf performing traditional solution extraction 
keys blackbox performance observation simplification algorithm employed graphplan powerful unit propagation previous sat planning system 
specifically graphplan employs negative binary propagation limited way binary exclusion clauses corresponding mutex relations qg resolved proposition support sets fp infer optimizations ways improve encodings discussed section discuss compile time type optimization addition domain specific information 
principles objectives underlying type analysis sat compilation previously discussed context graphplan 
approaches inertia optimization tim aimed shrink size planning graph eliminating static fluents avoiding nonsensical action schemata instantiations 
approaches shrink size cnf formula sat compiler generates 
medic compiler performs optimizations reduce cnf size variety problems 
way optimize cnf formula produced compiler add domain specific information 
typically knowledge impossible express terms strips actions natural writing general logical axioms induced processing action schemata initial state specifications 
example blocks world state axioms effect relation non commutative irreflexive block may time 
ernst show adding types axioms increased clause size resulting cnf formulae decreased number variables simplification speeded solver time significantly 
domain axioms may classified terms logical relationship knowledge encoded original problem statement ffl action conflicts derived effects entailed solely preconditions effects domain action schemata 
ffl heuristics entailed initial state conjunction domain action schemata include state invariants 
example vehicle location time 
ffl optimality heuristics restrict plans disallowing unnecessary subplans 
example package delivery domain specify packages returned original location 
ffl simplifying assumptions logically entailed domain definition goal may restrict search eliminating plans 
example specify trucks loaded immediately move 
preprocessing system infers state constraints domain definitions 
basic idea look general axiom patterns discovered low order polynomial effort 
example single constraint discovered logistics world saying vehicle place time 
ipp planning graph discover constraints deduced special purpose analysis 
attempt deduce optimality heuristics simplifying assumptions constraints completeness preserving 
cnf formulae inferred axioms solved times faster plain medic satplan formulae regardless sat solver :10.1.1.38.4843
cases plain encodings unsolvable time augmented encodings quickly yielded plan 
researchers devised alternative methods detecting constraints 
example describes method similar addition uses regression search restrict predicate domains 
rintanen modified algorithms computer aided verification discover binary invariants 
earlier subject 
despite promising efforts exciting remains done area optimizing sat encodings speedy solution 
sat solvers efficient solver planning sat compiler useless section review state art 
best summary area research highly dynamic 
year bring new method previous leader 
selman excellent summary state art propositional reasoning sketches challenges coming years 
discussion brief 
sat solvers best distinguished type search perform systematic stochastic 
systematic sat solvers discovered years ago dpll algorithm remains central algorithm summarized minimum background 
oe cnf formula conjunction clauses disjunctions 
clauses just single literal clearly true order satisfy conjunction called unit clause 
furthermore exists literal clause oe refers polarity true false said pure literal 
example cnf formula unit clause pure literal 
notation oe denote result setting literal true simplifying 
example describe dpll simple terms performs backtracking depth search space partial truth assignments pure literal heuristics 
tableau satz tight implementations dpll careful attention datastructures indexing 
additional heuristics proposed guide choice splitting variable preparation divide conquer recursive call 
example satz selects variables considering unit propagation facilitated branches variable 
see discussion heuristics 
procedure dpll cnf formula oe oe empty return 
empty clause oe return 
pure literal oe return dpll oe unit clause fug oe return dpll oe choose variable mentioned oe 
dpll oe return 
return dpll oe 
backtracking depth search space partial truth assignments 
procedure gsat cnf formula oe integer restarts flips equals restarts set randomly generated truth assignment 
equals flips satisfies oe return 
set variable oe change gives largest increase number clauses break ties randomly 
modify flipping truth assignment random restart hill climbing search space complete truth assignments 
incorporating csp look back techniques conflict directed backjumping generalization relevance bounded learning solver speed increased substantially :10.1.1.102.1237
interesting direction construction special purpose sat solvers optimized cnf encodings planning problems 
effort direction insight propositional variables corresponding action choices important variables corresponding fluent values follow deterministically action choices 
insight suggests small change dpll restrict choice splitting variables action variables 
interestingly result restriction dramatic orders magnitude speedup 
solver uses high level structure planning problem speed sat solver uses knowledge propositions correspond goals actions guide search resulting solver competitive walksat described 
time find satisfying assignment probability variable ordering time required dpll find satisfying assignment highly dependent order variables chosen 
distribution times function variable order varies problem problem problems show heavy tailed distribution dashed curve gaussian curve 
note mean value heavy tailed distribution infinite probability mass stretches rightwards bound 
sizable probability mass left time land area small number restarts sample different orderings 
stochastic sat solvers contrast systematic solvers stochastic methods search locally random moves escape local minima 
result stochastic methods incomplete called hard problems stochastic solver may simply report unable find satisfying assignment allotted time 
output leaves observer uninformed sure way distinguish unsatisfiable formula satisfying assignment difficult find 
hand stochastic solvers frequently faster finding satisfying assignments exist 
simple popular gsat solver random restart hill climbing search algorithm 
successors truth assignment assignments differ value assigned single variable 
gsat performs greedy search assignment number satisfied clauses 
note algorithm may move sideways change number satisfied clauses negative progress 
hill climbing fixed amount flips directed flips gsat starts anew freshly generated random assignment 
restarts restarts gsat gives 
walksat improves gsat adding additional randomness akin simulated annealing 
flip walksat things probability chooses variable gsat chosen selects random variable unsatisfied clause 
variants algorithms constructed compared 
especially promising new method reported exploits fact time required dpll procedure highly dependent choice download www informatik tu darmstadt de ai satlib 
splitting variable producing heavy tailed distribution running times 
augmented version dpll adding randomization choice splitting variable causing algorithm quit restart failed find solution small time limit restarts curtail unpromising choices ones lead extremely long running times consume time 
number restarts odds high algorithm stumble choice leads quick solution running time time limit 
little time wasted restarts result speedup orders magnitude 
stochastic methods perform extremely performance usually sensitive variety parameters random noise restarts flips 
optimal values parameters function problem solved specific algorithm question take considerable experimentation tune parameters specific problem distribution 
stochastic methods reach potential automated tuning methods don require solving complete problem instances 
developed reports direction 
incremental sat solving problem propositional satisfiability closely related truth maintenance focus style truth maintenance systems :10.1.1.38.9249
problems concern cnf formula represented set clauses sigma set propositional variables sat solver seeks find truth assignment function ftrue falseg sigma true 
differences ffl manipulates function ftrue false general truth assignment 
ffl doesn just find mapping maintains incremental changes additions deletions set clauses sigma 
uses unit propagation update mapping 
unit clauses assigned values immediately clause single unknown literal remaining literals labeled false updated 
new clause added sigma may enable additional inference dependency records allow retract inferences depended clauses removed sigma 
nayak williams describe especially efficient method maintaining mapping call resulting algorithm powerful foundation building real time planning execution systems describe 
interleaved planning execution monitoring exciting developments partially sat reactive control system command nasa deep space autonomous valve pyro valve main engines tanks helium tank regulator schematics spacecraft engine adapted 
closed valves shown filled black 
pyro values may opened closed 
spacecraft launched autumn 
expect magnitude task complete agent quite complex focus configuration planning execution subsystem best explained example 
shows simplified schematic main engines spacecraft 
helium tank fuel tanks forced valves open combine engines ignite produce thrust 
valves opened valve drivers sending commands control unit 
long voyage destination saturn components possible turned order save energy control units drivers turned operational valves adjusted 
radiation space harsh environment damage electronic physical components 
valves may jam open shut control units may fail soft permanent fashion 
counteract problems engines high degree redundancy 
paths flexible pyro valves fail may switched 
spacecraft configuration management system satisfy high level goals achieve thrust orbital insertion identifying failures occurred executing actions powering control units switching valves goals quickly achieved minimum cost terms power spent pyro valves 
shown decisions pipeline major components ffl execution monitor mi interprets limited sensor readings de clarity consistency different terminology williams nayak original papers include acronyms facilitate correspondence reader recourse primary literature 
williams nayak name process execution monitoring mode identification abbreviation mi 
intuition system mode state execution monitoring determines system expected execution monitoring mi goal interpretation control action percepts spacecraft incremental replanning mrp desired state current state high level goals architecture deep space spacecraft configuration planning execution system 
termine current physical state spacecraft includes recognizing execution failure occurred 
frequently possible states consistent previous values current sensors case execution monitor returns single state 
ffl goal interpreter determines set spacecraft states achieve high level goals reachable current state 
returns lowest cost state minimal power consumption fewest blown pyro valves 
ffl incremental mrp calculates action plan reach state selected goal interpretation 
propositional encoding spacecraft capabilities modules utilizes propositional encoding spacecraft capabilities despite superficial differences quite similar strips domain theories considered earlier 
example valve engine described terms modeling variables valve mode variables domains shown valve mode fopen closed stuck open stuck fout zero pout nominal note discretized qualitative representation real valued flow pressure variables 
cross product variables defines state failure occurred 
process goal interpretation called mode reconfiguration call incremental replanning called model reactive planning mrp 
space possible valve states states physically attainable 
example valve open equal pressure sides infeasible states eliminated writing set propositional logic formulae underlying propositions form modeling variable value 
valve example may write valve mode open valve mode stuck open valve mode closed valve mode stuck closed zero zero note descriptions implicitly parameterized 
valve variables propositions 
augmenting domain axioms control actions specified temporal modal logic adds operator fl propositional logic 
example behavior valve driver may partially described formulae driver mode failed cmd reset fl driver mode driver mode cmd open valve mode stuck closed fl valve mode open transition equations akin strips operator antecedent left hand side implication corresponds action name precondition consequent right hand side equations follow fl effects take place time step 
name parameter distinction bit subtle stems fact modeling variables partitioned disjoint sets state variables driver mode dependent variables control variables 
subexpression antecedent consists solely propositions referring control variables corresponds name strips action remainder antecedent propositions referring dependent state variables corresponds strips action precondition 
summary williams nayak model spacecraft combination strips actions propositional constraints defining space feasible states 
real time inference suppose agent knows state modeling variables propositions time zero 
information suffices predict actions ignore parameterization 
assumption transition equation proposition involving control variables antecedent 
executed expected spacecraft state 
actions don desired effects williams nayak included additional transition equations describe possible failure modes 
example contrast expected result setting cmd open shown failure transition enumerate possibility valve mode stuck closed 
normal failure transition rules annotated probabilities 
predicting unique spacecraft state may predict ranked list possible states ordered likelihood 
framework processes execution monitoring goal interpretation cast terms combinatorial optimization subject set propositional logic constraints 
input execution monitoring takes set observations current values subset state dependent variables observations set values corresponding propositions 
execution monitoring seen problem finding state logically consistent current observations 
incremental sat solver forms core optimization computation 
goal interpretation similar 
objective find spacecraft state entails high level goals cheaply reached state execution monitoring deems 
estimating cost reaching goal state relatively easy compares number switched pyro valves differential power usage logical entailment computed incremental sat solver central 
incremental takes input initial state computed execution monitoring cost goal state computed goal interpretation 
output incremental produces action guaranteed step successful cycle free plan initial state goal 
beauty williams nayak algorithm guarantee speedy response glance appears contradict results showing strips planning pspace complete 
underlying williams nayak method insight spacecraft configuration planning far easier general strips planning spacecraft engineers specifically designed creations controllable 
williams nayak formalize intuition set crisp constraints satisfied spacecraft domain 
important restrictions presence serialization ordering satisfiable set goals 
previous theoretical shown serialized subgoals solved extremely quickly backtracking necessary subgoals 
give intuitive blocksworld example set goals 
block table 

block block 
block block absence failure transitions 
serializable solving order correct serialization 
doesn matter goal achieved goals solved making goal false 
goals achieved need violated order solve goal 
summary researchers long known serializable goals ideal special case williams nayak contribution twofold 
recognized spacecraft configuration task serializable real world domains second developed fast algorithm computing correct order 
step crucial attempts solve serializable problem wrong order exponential amount time wasted backtracking search 
example solved goal getting block block solving goal wasted 
williams nayak goal ordering algorithm notion causal graph vertices state variables directed edge proposition mentioning antecedent transition equation consequent mentions williams nayak observe spacecraft model causal graphs acyclic topological sort graph yields serialization ordering 
goals solved upstream order goals involving solved backtracking required goals 
essentially search eliminated incremental generates control actions real time 
discussion focus dramatic explosion graphplan algorithms close briefly mentioning trends 
planning search refinement search forms elegant framework comparing different planning algorithms representations 
results extend theory handle partially htn domains 
mcdermott showed emphasis automatically computing informative heuristic simple planner extremely effective 
tlplan uses user provided domain specific control information offset simple forward chaining search strategy impressive results 
hector interesting compare similar research subgoal ordering discussed earlier section solution extraction constraint satisfaction 
graphs operator graphs share causal graphs 
knoblock alpine abstraction system viewed finding serialization ordering eliminate search problem acyclic structure towers hanoi 
causal graph constructed offline compiled version domain theory eliminates dependent variables 
geffner demonstrated impressive performance planning competition problems heuristic search space world states 
causal link planning causal link planners snlp ucpop received attention years outperformed graphplan satplan domains :10.1.1.57.3126
intuitions underlying planners adopted propositional approaches 
example biggest advantages causal link planners resulting regression search insensitivity irrelevant information initial state 
regression focussing described previously provides advantages propositional planners 
situation causal link planners excel software domains domain discourse unknown agent 
agent faced incomplete information construct herbrand base unable propositional planning methods 
causal link planners xii hand 
handling uncertainty starting cnlp buridan systems ai planning community seriously considered extensions action languages allow specification uncertain effects incomplete information 
course related performed uai community usually different assumptions 
example markov decision processes mdps typically assumes agent complete immediate free observability world state actions completely deterministic 
partially observable mdps relaxes assumption remains done area pomdp solvers typically efficient mdps 
mdp pomdp researchers typically state agent objective terms maximizing utility function fixed finite horizon 
planning researchers hand usually seek achieve fixed goal configuration complete confidence probability greater threshold time horizon considered 
past thought planning approaches goal directed natures sensitive high dimension state descriptions presence attributes initial state 
mdp abstraction aggregation calls intuition question 
order field advance needs done comparing approaches testing relative strengths limitations 
initial results area start empirical comparisons badly needed 
researchers extended graphplan handle uncertainty 
conformant graphplan cgp handles uncertainty initial state action effects allow sensing resulting conformant plan works presence uncertainty choosing robust actions cover eventualities 
sensory graphplan sgp extends cgp allow branching contingent plans run time information gathered noiseless sensory actions may preconditions 
cgp sgp incorporate numerical probabilistic reasoning build separate planning graph structures possible world specified problem uncertainty scaling concern 
adopts mdp framework numerical probability complete observability builds optimal step contingent plan single planning graph structure accelerate forward chaining search see 
researchers investigated compilation approach planning uncertainty compiling sat target probabilistic variant called boolean formula choice variables variables truth status arbitrarily set chance variables variables truth status determined set independent probabilities find setting choice variables maximizes probability satisfying assignment respect chance variables 
describes planning compiler idea presents solver akin dpll 
caching expensive probability calculations leads impressive efficiency gains 
past years state art ai planning systems advanced extraordinary speed 
graphplan sat planning systems quickly solve problems orders magnitude harder tackled best previous planners 
developments extend systems handle expressive action languages metric resources uncertainty 
domain analysis promises provide additional speedup ideas constraint satisfaction compiler areas usefully applied 
modern planning system control real nasa spacecraft demonstrates ai planning matured field increase number fielded applications 
common thread running research propositional representations support extremely fast inference 
corin anderson mike ernst mark friedman alfonso gerevini rao kambhampati henry kautz todd millstein bart selman david smith brian williams steve wolfman enlightening discussions planning comments 
research funded office naval research national science foundation iri arpa rome labs 
anderson smith weld 
conditional effects graphplan 
proc 
th intl 
conf 
ai planning systems june 
bacchus teh 
making forward chaining relevant 
proc 
th intl 
conf 
ai planning systems pages june 
bacchus van run 
dynamic variable ordering csps 
proceedings conference principles practice constraint programming pages september 
barrett weld 
partial order planning evaluating possible efficiency gains 
artificial intelligence 
bayardo schrag :10.1.1.102.1237
csp look back techniques solve realworld sat instances 
proc 
th nat 
conf 
ai providence july 
blum furst :10.1.1.43.7263
fast planning planning graph analysis 
proc 
th int 
joint conf 
ai pages 
blum furst 
fast planning planning graph analysis 
artificial intelligence 
blum langford 
probabilistic planning graphplan framework 
aips workshop planning combinatorial search pages june 
bobrow editor 
special issue qualitative reasoning physical systems 
artificial intelligence december 
boutilier dean hanks 
planning uncertainty structural assumptions computational leverage 
proceedings second european workshop planning 
boutilier dearden goldszmidt 
exploiting structure policy construction 
proc 
th int 
joint conf 
ai pages august 
bylander 
complexity results planning 
proceedings ijcai pages 
chapman 
planning conjunctive goals 
artificial intelligence 
cheng irani 
ordering problem subgoals 
proc 
th int 
joint conf 
ai pages august 
cook mitchell 
finding hard instances satisfiability problem survey 
proceedings dimacs workshop satisfiability problems appear 
crawford auton 
experimental results cross point satisfiability problems 
proc 
th nat 
conf 
ai pages 
davis logemann loveland 
machine program theorem proving 
acm 
de kleer 
assumption truth maintenance system 
artificial intelligence 
dearden boutilier 
abstraction approximate decisiontheoretic planning 
artificial intelligence 
doyle 
truth maintenance system 
artificial intelligence 
draper hanks weld 
probabilistic planning information gathering contingent execution 
proc 
nd intl 
conf 
ai planning systems june 
ernst millstein weld 
automatic sat compilation planning problems 
proc 
th int 
joint conf 
ai 
erol hendler nau 
htn planning complexity expressivity 
proc 
th nat 
conf 
ai pages july 
etzioni weld 
softbot interface internet 
acm 
oren etzioni 
acquiring search control knowledge static analysis 
artificial intelligence 
oren etzioni steve hanks daniel weld denise draper neal lesh mike williamson 
approach planning incomplete information 
proc 
rd int 
conf 
principles knowledge representation reasoning pages 
falkenhainer forbus 
setting large scale qualitative models 
proc 
th nat 
conf 
ai pages august 
reprinted 
fikes nilsson 
strips new approach application theorem proving problem solving 
artificial intelligence 
fox long 
automatic inference state invariants tim 
technical report university durham uk 
knoblock 
combining expressivity ucpop efficiency graphplan 
proc 
th european conference planning sept 
genesereth nilsson 
logical foundations artificial intelligence 
morgan kaufmann publishers los altos ca 
gent walsh 
understanding hill climbing procedures sat 
proc 
th nat 
conf 
ai pages 
mit press aaai july 
gerevini schubert 
accelerating partial order planners techniques effective search control pruning 
artificial intelligence research 
gerevini schubert 
inferring state constraints domainindependent planning 
proc 
th nat 
conf 
ai madison wi july 
giunchiglia sebastiani 
act rest follow exploiting determinism planning satisfiability 
proc 
th nat 
conf 
ai pages madison wi july 
golden 
leap look information gathering planner 
proc 
th intl 
conf 
ai planning systems june 
keith golden oren etzioni dan weld 
omniscience sensor management planning 
proc 
th nat 
conf 
ai pages 
gomes selman kautz 
boosting combinatorial search randomization 
proc 
th nat 
conf 
ai pages madison wi july 
green 
application theorem proving problem solving 
proc 
st int 
joint conf 
ai pages 
haas 
case domain specific frame axioms 
frame problem artificial proceedings workshop 
morgan kaufmann 
haralick elliott 
increasing tree search efficiency constraint satisfaction problems 
artificial intelligence 
irani cheng 
subgoal ordering goal augmentation heuristic problem solving 
proc 
th int 
joint conf 
ai pages august 
joslin pollack 
cost flaw repair plan refinement strategy partial order planning 
proc 
th nat 
conf 
ai july 
joslin pollack 
early commitment plan generation idea 
proc 
th nat 
conf 
ai pages 
kambhampati lambrecht parker 
understanding extending graphplan 
proc 
th european conference planning sept 
kambhampati mali srivastava 
hybrid planning partially hierarchical domains 
proc 
th nat 
conf 
ai pages 
kambhampati 
challenges bridging plan synthesis paradigms 
proc 
th int 
joint conf 
ai pages 
kambhampati 
refinement planning unifying framework plan synthesis 
ai magazine 
kambhampati 
ebl 
department computer science engineering tr arizona state university august 
kambhampati 
relations intelligent backtracking failure driven explanation learning constraint satisfaction planning 
department computer science engineering tr arizona state university 
appear artificial intelligence 
kambhampati knoblock yang 
planning refinement search unified framework evaluating design tradeoffs partial order planning 
artificial intelligence 
kautz mcallester selman 
encoding plans propositional logic 
proc 
th int 
conf 
principles knowledge representation reasoning 
kautz selman 
planning satisfiability 
proc 
th eur 
conf 
ai pages vienna austria 
wiley 
kautz selman :10.1.1.38.4843
pushing envelope planning propositional logic stochastic search 
proc 
th nat 
conf 
ai pages 
kautz selman 
blackbox new approach application theorem proving problem solving 
aips workshop planning combinatorial search pages june 
kautz selman 
role domain specific knowledge planning satisfiability framework 
proc 
th intl 
conf 
ai planning systems june 
cohen 
automatically synthesizing domain constraints operator descriptions 
proc 
th eur 
conf 
ai vienna austria 
wiley 
knoblock 
learning abstraction hierarchies problem solving 
proc 
th nat 
conf 
ai pages august 
knoblock 
automatically generating abstractions problem solving 
phd thesis carnegie mellon university 
available technical report cmu cs 
knoblock 
analysis 
proc 
st intl 
conf 
ai planning systems june 
knoblock 
planning executing sensing replanning information gathering 
proc 
th int 
joint conf 
ai pages 
koehler 
planning resource constraints 
proc 
th eur 
conf 
ai 
koehler 
solving complex planning tasks extraction subproblems 
proc 
th intl 
conf 
ai planning systems pittsburgh pa june 
koehler nebel hoffmann dimopoulos 
extending planning graphs adl subset 
proc 
th european conference planning pages sept 
koehler nebel hoffmann dimopoulos 
extending planning graphs adl subset 
tr institute computer science university freiburg 
see www informatik uni freiburg de koehler ipp html 
van beek 
theoretical evaluation selected backtracking algorithms 
artificial intelligence 
korf 
planning search quantitative approach 
artificial intelligence september 
kushmerick hanks weld 
algorithm probabilistic commitment planning 
proc 
th nat 
conf 
ai 
kushmerick hanks weld 
algorithm probabilistic planning 
artificial intelligence 
lansky 
localized planning action constraints 
artificial intelligence 
li anbulagan 
heuristics unit propagation satisfiability problems 
proc 
th int 
joint conf 
ai august 
littman 
probabilistic propositional planning representations complexity 
proc 
th nat 
conf 
ai pages 
littman 
new approach probabilistic planning 
proc 
th intl 
conf 
ai planning systems pages june 
littman 
caching solve larger probabilistic planning problems 
proc 
th nat 
conf 
ai pages july 
mali kambhampati 
encoding htn planning propositional logic 
proc 
th intl 
conf 
ai planning systems june 
mcallester 
outlook truth maintenance 
ai memo mit ai lab 
mcallester 
truth maintenance 
proc 
th nat 
conf 
ai pages 
mcallester rosenblitt 
systematic nonlinear planning 
proc 
th nat 
conf 
ai pages july 
david mcallester bart selman henry kautz 
evidence invariants local search 
proc 
th nat 
conf 
ai pages providence rhode island july 
mccarthy hayes 
philosophical problems standpoint artificial intelligence 
machine intelligence pages 
edinburgh university press 
mcdermott 
heuristic estimator means ends analysis planning 
proc 
rd intl 
conf 
ai planning systems pages may 
steven minton jaime carbonell craig knoblock daniel kuokka oren etzioni yolanda gil 
explanation learning problem solving perspective 
artificial intelligence 
nayak williams 
fast context switching real time propositional reasoning 
proc 
th nat 
conf 
ai providence july 
nebel dimopoulos koehler 
ignoring irrelevant facts operators plan generation 
proc 
th european conference planning sept 

parallel cooperative propositional theorem proving 
submitted publication preliminary version fifth international symposium artificial intelligence mathematics rutgers edu 
pednault 
adl exploring middle ground strips situation calculus 
proc 
st int 
conf 
principles knowledge representation reasoning pages 
pell bernard chien gat muscettola nayak wagner williams 
autonomous spacecraft agent prototype 
proc 
intl 
conf 
autonomous agents pages 
penberthy weld :10.1.1.57.3126
ucpop sound complete partial order planner adl 
proc 
rd int 
conf 
principles knowledge representation reasoning pages october 
see www cs washington edu research projects ai www ucpop html 
peot smith 
conditional nonlinear planning 
proc 
st intl 
conf 
ai planning systems pages june 
pollack joslin paolucci 
flaw selection strategies partial order planning 
artificial intelligence research 
rintanen 
planning algorithm directional search 
proc 
th int 
conf 
principles knowledge representation reasoning june 
selman kautz cohen 
noise strategies improving local search 
proc 
th nat 
conf 
ai pages july 
selman kautz cohen 
local search strategies satisfiability testing 
dimacs series discrete mathematics theoretical computer science 
selman levesque 
mitchell 
new method solving hard satisfiability problems 
proc 
th nat 
conf 
ai pages july 
bart selman henry kautz david mcallester 
computational challenges propositional reasoning search 
proc 
th int 
joint conf 
ai 
smith 
controlling backward inference 
artificial intelligence 
smith peot 
postponing threats partial order planning 
proc 
th nat 
conf 
ai pages june 
smith peot 
suspending causal link planning 
proc 
rd intl 
conf 
ai planning systems 
smith weld 
conformant graphplan 
proc 
th nat 
conf 
ai july 
smith weld 
temporal graphplan 
technical report univ washington dept computer science engineering 
srinivasan howe 
comparison methods improving search efficiency partial order planner 
proc 
th int 
joint conf 
ai pages 
stefik 
planning constraints part 
artificial intelligence 
tenenberg 
abstraction planning 
ph thesis university rochester department computer science may 
van gelder 
propositional theorem prover solve planning problems 
submitted publication preliminary version fifth international symposium artificial intelligence mathematics rutgers edu 
van gelder tsuji 
satisfiability testing reasoning guessing 
johnson trick editors cliques coloring satisfiability second dimacs implementation challenge dimacs series discrete mathematics theoretical computer science 
american mathematical society 
manuela veloso 
flexible strategy learning analogical replay problem solving episodes 
proc 
th nat 
conf 
ai pages july 
weld 
commitment planning 
ai magazine pages winter 
available ftp ftp cs washington edu pub ai 
weld de kleer editors 
readings qualitative reasoning physical systems 
morgan kaufmann san mateo ca august 
weld anderson smith 
extending graphplan handle uncertainty sensing actions 
proc 
th nat 
conf 
ai pages july 
williams nayak 
model approach reactive systems 
proc 
th nat 
conf 
ai portland august 
williams nayak 
reactive planner model execution 
proc 
th int 
joint conf 
ai nagoya japan august 
yang 
formalizing planning knowledge hierarchical planning 
computational intelligence february 
yang chan 
delaying variable binding planning 
proc 
nd intl 
conf 
ai planning systems pages june 
yang tenenberg 
abstracting nonlinear planner 
proc 
th nat 
conf 
ai pages august 

