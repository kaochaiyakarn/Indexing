derivative regular type type hole contexts extended conor mcbride polymorphic regular types tree datatypes generated polynomial type expressions set free variables closed fixed point 
equality types core ml expressed form 
type expression free shows way represent hole contexts elements elements operation plug element hole context 
hole contexts inhabitants regular type computed generically syntactic structure mechanism better known partial differentiation 
relevant notion containment shown appropriately characterized terms derivatives plugging 
technology exploited give hole contexts sub elements recursive types manner similar huet hue 
gerard huet zipper hue defines representation tree data decomposed subtree interest surroundings 
shows informally equip datatype associated type hole contexts representing tree subtree deleted 
collect subtrees forking step step path starts hole returns root 
type contexts independent particular tree decomposed subtree hole 
decomposition seen kind department computer science university durham mcbride durham ac uk subtraction operation inherently troubled need subtract smaller things larger inversion kind addition see 
tree hole context plus subtree exhibits similar technique defined formally generic large class tree data structures regular datatypes 
essentially equality types core ml polynomial type expressions closed fixed point 
particular define characterize operations ffl types computing regular recursive datatype type hole contexts ffl terms computing big term plugging small term hole context 
operations recursion structure algebraic expressions name types 
wrote rules corresponding empty type unit type sums products find leibniz beaten centuries exactly rules differentiation learned child 
motivating examples describe hole contexts recursive type 
huet suggests regard backwards hole root recording pass way 
propose follow suggestion start root way forwards hole 
choices uses backwards better tree editing applications forwards approach conceptually simpler 
consider binary trees btree leaf node btree btree point hole step journey list steps list btree appropriate step type btree 
step record binary choice left right btree passed 
may take btree bool define plugging operation follows btree btree btree true 
node false 
node ss list btree btree ss btree 
ss 
ss define btree algebraically sum choice unique leaf nodes pairing subtrees powers denote repeated product btree btree correspondingly write huet write ss 
ss btree imagine similar list ternary trees step chooses directions remembers bypassed trees looks remarkably type steps calculated differentiating original datatype 
fact exactly happening shall see examine compute description hole contexts regular datatypes 
presenting regular types order give precise treatment differentiating datatype precise expressions define 
particular availability fixed points requires consider binding fresh type variables 
activity area research place issues 
approach take regular type expressions finite sequences available free names 
explain interpret expressions relative environment interprets names 
choose give inductive definitions natural deduction style 
requires space datatype declarations conventional programming languages allow dependent families clearly nested types bm bp defined uniformly indices whilst full notion family allows constructors apply particular indices 
give type signatures defined functions way preferring universal quantification inherent type dependency schematic variables complex formulae 
sequences distinct names presume existence infinite set name names equipped decidable equality 
may think name string 
set may defined contain finite sequences distinct names 
sequence viewed set 
name set sigma sigma set sigma name sigma sigma shall names founded manner 
explanation name sequence sigma involve prior names intuitively explained 
important define pair restriction sigma sequence names sigma prior sigma sigma sigma sigma xx 
sigma sigma 
sigma equality names decidable shall freely allow names occur nonlinearly patterns 
order recover disjointness patterns recourse prioritizing introduce notation mean 
correspondingly clause definition holds schematically equation 
write 
indicate directed computation rule reserving equational propositions 
describing regular types regular types free names expressions describe inductive infinite mean choose fresh name need create new binding 
family reg sigma 
firstly embed type variables sigma reg sigma give building blocks polynomials fixed point 
sigma reg sigma set sigma reg sigma reg sigma reg sigma reg sigma reg sigma reg sigma thetat reg sigma reg sigma reg sigma reg sigma reg sigma jx reg sigma reg sigma reg sigma descriptions regular types constructors may mysterious 
redundancy introduce save come interpret descriptions types 
choose interpret reg closed descriptions keeping open types underwater dangerous bits iceberg 
require substitute free names exposed example expanding fixed point 
turn forced take account equational properties substitutions prove closure properties respect 
dispense substitution 
alternative adopted interpret open descriptions environments explain free names 
unusual constructors perform roles definition weakening respectively growing shrinking environment scope 
definition replaces substitution weakening adds free names modifying old descriptions 
avoids propagation substitutions syntactic structure concerns capture shall interpret value variable binding time environment 
fact am abusing notation suppressing constructor symbol 
type environments type environment name sequence sigma associates sigma type description prior names sigma sigma env sigma set env sigma gamma env sigma reg sigma gamma env sigma may equip environments operators restriction extracting prefix prior name projection looking name associated type description 
gamma environment explains free names gamma delta gamma env sigma sigma gamma env sigma gamma env sigma sigma gamma delta reg sigma gamma 
gamma gamma 
gamma gamma delta 
gamma delta 
gamma delta interpreting descriptions means describe regular types say data contained type description relative environment explaining free names give semantics syntax 
defines interpretation gamma inductively 
note supplied constructor symbols embedding rules corresponding variable lookup definition weakening 
apparent types gamma gamma harmless types tell embeddings operative 
semantic brackets represent meta level operation intended suggestive object level syntax dependent family types 
gamma env sigma reg sigma gamma set gamma gamma delta gamma gamma inl gamma gamma inr gamma hi gamma gamma gamma hs ti gamma thetat gamma jx con gamma gamma gamma jx gamma gamma data regular types examples regular types briefly examine familiar types setting 
unit type build booleans bool 
reg sigma sigma true 
inl hi gamma bool gamma false 
inr hi gamma bool gamma may build recursive datatypes natural numbers tree examples sigma gamma fresh bound variable chosen nat 
zero 
con inl hi suc 
con inr btree 
thetax 
con inl hi 
con inr hl ri 
theta thetax 
con inl hi tnode 
con inr hl hm rii may weakening define operation computes list types list 
thetax nil 
con inl hi xs 
con inr hx xsi finitely branching trees may ftree 
list ts 
con ts subterm orderings regular types define inductive relation gamma gamma characterizing subterms term accounted relation characterizes role container 
omit obvious wellformedness premises 
gamma inl inr thetat hs ti thetat hs ti jy con jy jy observe subterms accounted composite type characterized rule component type 
particular rules definition jy find subterms due respectively occurring subterms due note rule exploits fact may see inhabiting gamma gamma 
effect local type variables reflected place binding places 
significance phrase accounted shown simple example take gamma bool derive true thetay htrue falsei false thetay htrue falsei point false type account particular gamma definition irrespective gamma derive thetay hs ti discharging definition example gamma bool derive true htrue falsei false htrue falsei accounted indicated type derivations follow respectively definition rules 
similar phenomenon occurs try specialize ordering contained list determine thetay ts rule fixed points applies showing derived rule complete thetay jy thetay tts list con tts premise simplified definition rules direct rule finds head list indirect rule second premise finds tail demands search tail 
derive show complete rules hoped interesting investigate notion subterm single rule definitions capturing subterms term remembering really means pay extra complexity rule variables need carry extra environmental information explicitly 
list ts list ts list ts may exploit containment relation define usual subterm relation recursive types gamma follows con find subterm cont gamma move level contained repeat 
go level free little specialize rules btree btree btree btree btree btree hole contexts turn generic representation hole contexts recursive regular types 
shall need see step immediate recursive subterms con type gamma subterms correspond occurrences recall type gamma 
need describe contexts 
may contain fixed points primitive operation need define compute type hole contexts free names 
operation exactly partial differentiation 
partial differentiation partial derivative regular type description respect free name computed structural recursion syntax defined 
sigma reg sigma reg sigma 




thetat 
theta theta 
jy jy theta jy 
jy jy theta 

partial differentiation lines familiar calculus 
hole contexts tell ffl contains trivial surroundings ffl contains ffl constants contain ffl find ffl find thetat left passing right passing note partial differentiation independent environments defined syntax types 
just subterm ordering takes account possibility gamma expand terms partial differentiation basic tool total differentiation constructed exactly need go binder liable encounter local names potentially conceal 
rule definitions handles local variables place binding summing types contexts depressing mathematics teachers impart vital clue calculus students giving rules method 
learned differentiation pattern matching algorithm mcb 
occurring directly indirectly buried conventional calculus effectively chain rule extended functions arguments special case know differentiate definitions leap fixed points 
expand fixed point apply chain rule obtain jy jy jy theta tempting solve recursive equation fixed point give correct type hole contexts 
inside piece payload data attached node buried finite depth 
journey takes outermost node stops base case subnode onwards step case eventually 
weaken free journey clearly linear body fixed point syntactically linear set isomorphism holds showing journey list steps tip gamma gamma list thetat rules differentiating explicit weakening simply short circuit process name seek excluded 
examples derivatives develop technology check partial differentiation giving kind answers expect 
course types get back contain lots theta usual algebraic laws simplify expressions hold set isomorphisms 
hard show recursive type base cases empty gamma jx gamma writing fold product sum check induction gamma thetax gamma viewed hole context tells hole gamma records remaining 
involved example finds list list thetay 
thetay jy list thetay jy list list xjy list list theta list hope hole context list element pair lists prefix suffix 
power series resembles list delta delta delta gamma jxj conventional calculus tells gamma gamma plugging hole context able construct plugging hole 
need operation behaves ft gamma gamma gamma 
gamma gamma ft gamma hi 
inl fs 
inl inr fs 
inr ft inl hc ti fs thetat 
hc ti inr hs ci fs thetat 
hs ft ui con inl fy 
con ff con inr hc csi fy 
con ff cs fy inl ff jy 
ff inr hc ff jy 
ff lx 
ft plugging define operation 
tell shape term trying build tell path take supply subterms corresponding path components pairs 
effect operation proceeds structural recursion flow control involves primary case analysis course need consider cases 
definition 
subtrees recursive regular types operation picks containers 
suggested gives tool need pick subtrees tree recursive datatypes interpreting container immediate subtrees con intuition contexts recursive type inhabit list rigorous 
step type trees jx hole contexts inhabit sub abuse notation sub really operation reg sigma sub reg sigma sub 
list jx informally inhabitant sub looks nil brief calculations gamma sub list gamma list gamma sub sub gamma sub gamma sub btree gamma list gamma sub gamma theta theta list gamma sub ftree gamma theta theta list list ftree corresponding notion addition signature cs gamma sub gamma cs gamma cs depicted appropriate expect cs con con con course defined iterating ff list nil 
cs 
con ff cs observe example nat really behaves plus whilst list effectively append 
hard show general 
monoid append action monoid subterms derivatives relationship containment orderings derivatives intimate subtree orderings types computed sub 
effect containment ordering exactly induced plugging subtree ordering induced done give concrete representation witnesses relational properties 
may prove theorems theorem containment gamma gamma gamma ft theorem subtree gamma cs gamma sub cs proofs theorems easy inductions derivations direction structure huet write cs 
cs con ff cs direction 
case distinct cs right give rise distinct derivations left vice versa 
omit details reasons space 
implementation extensions haskell type system jansson jeuring polyp begun realise potential generic programming development highly reusable code instantiable wide class datatypes characterised equally generic theorems jj 
systems show sign allowing operations compute types generically recursion closed syntax type expressions crucially regarding type variables concrete objects 
dependent type theory supporting inductive families datatypes dyb syntaxes reg sigma represented ordinary data index families gamma reflect 
merely operation data requiring extension computational power theory 
programming language type theory envisaged mcb promising setting implement technology described 
way computer assisted reasoning group durham 
payoffs implementation substantial extending far applications editing trees 
library generic tools working contexts allow define functions terms higher level structures manipulating data large chunks constructor time 
furthermore dependently typed setting richer structure data facto richer structure indices datatypes 
highly desirable extend class datatypes hole contexts manipulated generically regular types include indexed families 
concrete representation hole contexts syntax binding offer metaprogramming metatheory 
shown hole contexts elements contained polymorphic regular type represented inhabitants regular type computed original partial differentiation 
technology characterize data structures equivalent huet hole contexts subtrees trees inhabiting arbitrary recursive types class 
operations plug appropriate data holes contexts exhibited 
connection mere coincidence surprising find laws infinitesimal calculus discrete setting 
obvious notion tangent limit datatypes connect intuitions school mathematics 
offer sense integration mean just differentiation backwards 
observation relevant syntactic operation differentiating expression respect generates approximation change value expression summing contributions generated varying expression turn 
derivative sum terms corresponding hole context expression 
key connection focusing infinitesimally varied sake linear approximation curve kept 
apart implementation technology development library related generic utilities opens host fascinating theoretical possibilities open old school textbooks random ask mean datatypes 
surely relationship joyal general characterization species structure terms taylor series joy 
regular types hole second hole context generally gives hole contexts 
orders 
strong resonance taylor series worthy pursuit active topic research 
summary establishment connection contexts calculus step long road knows 
feel lucky interpretation differentiation datatypes potential utility intriguing day connection whilst changing trains 
benefited greatly hours spent trains enthusiastic discussions people notably james mckinna alex simpson daniele turi martin hofmann thorsten altenkirch especially peter hancock 
roland backhouse patrik jansson johan jeuring lambert meertens 
generic programming 
doaitse pedro jose oliveira editors advanced functional programming third international summer school afp braga portugal volume lncs pages 
springerverlag 
bm richard bird lambert meertens 
nested datatypes 
mathematics program construction volume lncs pages 
springer verlag 
bp richard bird ross paterson 
de bruijn notation nested datatype 
journal functional programming 
dyb peter dybjer 
inductive sets families martin lof type theory 
huet plotkin editors logical frameworks 
cup 
hue gerard huet 
zipper 
journal functional programming 
jj patrik jansson johan jeuring 
polyp polytypic programming language extension 
proceedings popl pages 
acm january 
joy andre joyal 
de structures 
enumerative volume lnm pages 
springer verlag 
mcb fred mcbride 
computer aided manipulation symbols 
phd thesis queen university belfast 
mcb conor mcbride 
dependently typed functional programs proofs 
phd thesis university edinburgh 

