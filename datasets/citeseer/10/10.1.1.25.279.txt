extracting safe precise control flow binaries henrik universitat des saarlandes absint angewandte informatik gmbh saarbrucken germany cs uni sb de starting point static program analysis control flow graph cfg needed 
binary executable available cfg reconstructed sequences instructions 
usual way top approach executable information routines split sequence routines instruction analysed branch targets order compute basic block boundaries 
analysing safety critical real time systems safe precise results needed 
cfg analyses traverse satisfy safety precision requirements analyses inherit deficiencies 
bottom approach cfg approximation 
starts set entry points clusters sequence instructions larger units blocks routines 
algorithm able account uncertainties early generate safe cfg 
important characteristic hard real time systems subject timing constraints determine actions taken 
failure safety critical real time system lead considerable damage loss lives 
schedulability analysis performed order guarantee timing constraints met 
existing techniques schedulability analysis require wcet task system known 
general computable estimations wcet calculated 
estimations safe may underestimate real execution time tight overestimation small possible 
wcet prediction usually starts assumption cfg program available 
cases executable program available cfg recon uses group university saarland embedded systems group partially supported deutsche forschungsgemeinschaft 
structed 
analysing real time systems cfg safe precise analyses 
research project uses developed generic tool reads executable files analyses machine instructions reconstructs cfg analyses real time systems 
exact reconstruction cfg binary modern architectures difficult 
problem memory indirections jump call tables procedure variables guarded code ambiguous usage machine instructions 
constant propagation helpful get precise control flow 
analysis cfg needed chicken egg problem 
approach similar compute approximation conservative cfg annotated aspects uncertainty perform constant propagation cfg resolve uncertainties left 
focuses step cfg approximation approximation conservative cfg knowledge compiler target architecture 
construct approximative cfg real time systems analysis mind safe precise possible 
steps refining cfg constant propagation loop reconstruction performing analyses discussed literature 
bottom algorithm overcomes deficiencies top algorithms 
topdown algorithms rely information routine boundaries executables 
usually start addresses 
common compiler technique store certain data code sections target addresses switch tables 
searching target addresses looking instruction routine separated method data portions misinterpreted instructions incorrect target addresses control flow reconstruction 
aspect routines interlocked cache aware compiler 
described start addresses 
bottom approach suffer deficiencies 
instruction classified completely correctly analyses 
safe classifications jump call targets compute routines extents 
means data portions skipped interlocked routines handled correctly 
bottom algorithm rely additional information executable 
available consistency checks 
approach aims retargetability designed generic wrt 
underlying architecture compiler input format executable 
achieved module concept allowing extensions 
selected architectures shown cfg approximation algorithm able reconstruct total cfg need constant propagation 
overview structured follows 
section identify problems cfg reconstruction faces 
section formalise bottom approach cfg reconstruction 
section module interface section show generic algorithms solve problems 
section give overview modules describe examples architectures 
section evaluate algorithms practical tests section outlines 
related discussed section 
section drawn 
control flow reconstruction program inter procedural control flow graph icfg split parts 

call graph cg describes relationship routines nodes represent routines edges represent routine calls returns 

routine control flow graph cfg describing jumps routine 
nodes called basic blocks 
sequences instructions entered instruction executed possibility control flow exiting entering instruction 
edges cfg called functions procedures addi ld ld bu add mov mov ld ji lea ld ji examples switch table code generated gnu compiler 
aspects extracted switch table base address size bold 
instructions need considered italic 
inserted optimising compiler instruction scheduler 
describe jumps fall edges 
cg edges cfg edges called branches 
input cfg approximation binary executable object code assembly file 
contain series instructions coded bytes text 
additional information may need available entry points label routine addresses label routine names relocation tables problems icfg reconstruction 
branch targets determined 
possible computed branches 
examples switch tables exception handling code tool cfg approximation resolve possible 

delay slots complicate computation basic block boundaries 

instruction sets may instructions ambiguous wrt 
program flow controlled 
complicated find routine target dedicated return instruction 

guarded code analysis complicated 

architectures long instruction words vliw instructions consist operations may branches 
semantics situation differs target target 
fall edges point immediate successors reached jump simply serial execution machine instructions 
bgt lis ori xd add blr stw addi ori blr powerpc blr switch tables left routine exits typical routine prologue epilogue right 
routine exits necessarily routine 

object code linked binaries analysed multiple entry points external routines handled 

procedures interlocked overlapping due optimising compilers hand written assembly 

data portions contained inside code blocks 
branch target unknown branch marked subsequent analyses decide transform cfg contain chaos nodes see 
cfg approximated steps 
conservative icfg produced static analysis performed refine constant propagation interpretation 
precise intra procedural control flow graph pcfg known cfg edge missing jump influence analysed properties point program 
assuming wellformed compiler output assembler may possible restrict scope interference routine 
table labels available possible targets unpredictable jumps 
fortunately uncertain missing inter procedural edges easier handle split basic blocks 
subsequent analysis steps assume worst case invalidating results points program 
knowing calling conventions callee save registers may possible perform intra procedural analyses interference 
theory bottom approach icfg computation formalised 
technical details suspended subsequent sections 
functions 
denotes functional composition 
set 
jmj cardinality power set bottom approach machine description instruction set mapping instructions call target addresses mapping instructions target addresses address immediately instruction reachable 
assumed computed instruction contains information target addresses memory lookup 
binary jaj finite set addresses contain instructions program entry address mapping addresses instructions memory contents 
assume jumps calls leave executable restrict 
shall omniscient wrt 
computed branch targets 
sections general 
problem extend construction sets entry points analyse object files 
describe icfg known set routine entry addresses set addresses instructions belonging routine starting routine cfg fully described 
cg described describes cg edges applied series defined routine starts entry point 

finds routine entries routines known edges new ones routine entry address 
jaj addresses removed 
analysis analysis icfg semantics module tdl description executable tdl parser exec crl structure analysis framework 
part discussed exec crl 
exec crl provides analyses control flow graph tdl provides semantics machine instructions 
analyses instruction cache analysis need tdl 
decoder decoder writer output file writer reader reader executable exec crl core module concept communication exec crl 
currently selected modules framed solid line unselected ones dashed line 
core implements cfg approximation algorithms generic code slicing generic machine code pattern matching functionality 
modules shows framework structure 
exec crl approximates icfg 
depicts modules 
tdl target description language see framework description language hardware resources semantics operations target 
tdl specifications decoder plug ins exec crl architecture dependent generic analysis framework created 
crl files control flow representation language store icfg target independently 
crl consists routines containing basic blocks containing instructions containing operations 
structure store additional information attributes mark unpredictability 
icfg reconstruction generic targets 
modules wrap target file format dependent parts 
reader modules readers split streams code data extract entry points function label names useful human users 
henceforth assume binary input assembly handled 
writer modules writers store crl visualisation files graph description language see 
procedure find cfg program entry new agenda new callgraph insert program entry empty routine find routine get add routine insert call targets return outer decoding loop pseudo code 
decoder modules decoder exists architecture family possibly parameterised processor compiler 
main task classify instructions 
aspects exist 
means information marked preliminary postprocessing needed 
instruction width bytes operations contained instruction architectures exactly operation number delay slots instruction impact operations control flow normal operations jumps calls returns fall edges instruction reachable jump targets call targets implied call targets 
calls known routines routine entries extracted 
decoders disassemble operations available operands subsequent analyses generic code slicing pattern matching provided framework 
core algorithms cfg approximation works outer loop collects routines cg edges inner finding pcfgs 
gathering routines analysis starts entry address 
traverse executable uses agenda consists stack routine start addresses hash table marking addresses processed prevent multiple processing 
outer loop puts addresses routines agenda determined find routine 
decoding routine shows algorithm routine decoder 
safe successors returns addresses possibly reached instruction 
jump targets fall edges 
important mark procedure find routine routine entry new routine new agenda new set address routine call targets insert routine entry forever empty instruction decode instr get add instruction insert safe call targets insert safe successors delay slots routine final call targets return insert revealed call targets insert revealed jump targets pseudo code find routine 
reader module decoder module currently 
unpredictable aspects preliminary examination routine 
function return computed branch targets due limited scope instruction 
delay slots returns addresses delay slots 
analyses account delay slot instructions sparc architecture 
safe call targets returns addresses safe callees 
routine checks resolves uncertainties 
routine analysed decide context uncertain operations really 
revealed jump targets returns computed jump targets 
compiler known find switch tables 
revealed call targets call targets 
external routines knowing program address space calls leave marked external 
additional information information routine boundaries sections types code vs data labels check consistency approximated icfg 
routine label names attached output 
properties algorithm problems listed section solved directly providing easily plug ins mechanism 
section refers problem items 
algorithm finds overlapping routines share code portions merged function tails produced optimising compilers 
possible splitting byte blocks routine boundaries branches input program top approaches try 
overlapping routines analysed separate ones addresses 
algorithm finds interlocked procedures may produced cache aware compilers 
consecutive block structure assumed algorithm 
done boundary information 
accordingly holes code data portions handled 
algorithm prepared switch tables dynamic program flow 
decoders may pattern matching code slicing detect 
delay slots handled icfg approximation available subsequent analyses 
uncertainties marked clearly icfg 
subsequent constant propagation disambiguate 
keeps unresolved analyses provided fact take account 
module system solves problems allowing architecture compiler dependent plug ins needed 
holds problems section especially useful 
code multiple entries algorithm simply adds initial agenda 
worst case runtime number routines number instructions runtime outer loop runtime inner loop runtime routine 
outer loop iterates routines worst case runtime 

inner loop execute body new branch targets hash table marks processed addresses 
iterations performed 
universal hashing expected runtime operation 


routine resolves iterating instructions looking constant number instructions follows 
case implemented decoders 
total worst case runtime 

expected runtime expected runtimes called previous paragraph pessimistic assumptions 
inner loop re iterates uncertainties occur 
usually number repetitions small compared number instructions routine 
powerpc decoder re iteration due ambiguous routine prologue epilogue code re iterates switch tables 


expected number re iterations instructions 
expect top level loop runtime 
number instructions routine total linear runtime expected 
comparison top approach worst case runtime top approach typically 
splits program routines analyses instruction 
approach slightly complex solves problems encountered 
practice large executables processed seconds difference theoretical 
implementation able analyse large executables data structures storing decoded routines kept freed soon routine analysed important aspects current analysis step extracted 
keeps analysis small structures tend large operation fine grained classification generated 
reader modules straightforward implement 
plug ins read elf intel hex ieee motorola record files implemented 
decoder modules interesting 
routines disambiguating operations usually complex 
focusing processors embedded systems completed implementation decoder plug ins rider architecture powerpc 
plug motorola processors compiled ada code available prototype 
powerpc powerpc dedicated return instruction 
jump link register lr performed 
subroutine calls fill lr return address 
callee leaf routine calling subroutines address necessarily stored system stack may kept lr function returns 
problem compiler uses lr computed branches making instruction blr ambiguous 
switch tables implemented way 
routine function powerpc implemented analyse blr instruction context find switch tables disambiguate return instructions 
additional jump targets analysis routine iteration 
compiler instruction scheduler instructions performing return switch general adjacent 
code slicing trace register usage certain machine instruction patterns 
decoder provides generic information instruction operands slicing algorithms implemented machine independent way 
architecture dedicated instructions subroutine calls returns complex disambiguation necessary 
switch tables techniques powerpc 
exec crl implementation exec crl modules currently lines code 
lines decoding executable formats lines simple lengthy task 
lines spent implementation tools splicing algorithms declaration module interface lines 
core algorithm lines code due defined module interface 
implementation looks slightly explicit pseudo code implementation 
powerpc decoder module lines code including instruction opcode tables automatically generated quite small 
shows complete pcfg effort needed write decoder plug small 
decoder module lines code including necessary pattern descriptions computed branch target extraction 
evaluation evaluate algorithm powerpc elf executables counted number uncertainties examined resolved 
real time systems mind statically linked executables evaluation 
dynamically linked executables screened ensure external routine calls analysed correctly 
powerpc architecture metaware high compiler compile test pro program arch 
instr 
bytes comp 

recogn 
fft avl panel powerpc ball powerpc ball powerpc results icfg reconstruction 
program sizes number computed jumps number unresolved computed jumps 
example marked unreachable library code analysed 
grams 
architecture compiler gnu compiler 
maximum available optimisation level 
sizes executables ranged small program instructions livermore loop benchmarks produced executable sizes instructions bytes 
additionally analysed unused parts bigger executables parts standard library order analyse optimised library code 
bytes instructions 
shows results 
computed branches predicted 
ones left unpredictable occurred highly optimised library code 
library frequently address kept register routines 
address switch table depended 
powerpc code targets computed branch written jump table run time depended caller routine 
research project cfgs reconstructed methods described perform analyses real time systems 
prototypes implemented instruction cache analysis path analysis pipeline analysis value analysis 
adapted new generic approach cfgs reconstructed 
targets additional constant propagation needed refine cfg especially guarded code 
expect method architectures 
examination guarded code philips processor revealed guard trivial true relevant parts pcfg 
applicability algorithm proven 
currently effort disambiguate computed calls 
ones encountered calls function pointers hard find possible call targets 
check implementation compilers 
framework evaluated gnu compiler powerpc soon 
related wisconsin architectural research tool set control flow reconstructed program slices 
early prototype tools sparc architecture eel library see genericity new approach necessary order cope complex architectures compiler techniques 
works concerning icfg reconstruction 
addresses step icfg reconstruction disambiguating uncertainties static analysis constant propagation shows analyse dec alpha architecture 
focused basic step complicated obtain conservative icfg due ambiguous usage machine instructions 
problems solves additional analysis step solved bottom algorithm disambiguation takes place reconstruction icfg 
think architectures ones evaluated far constant propagation interpretation needed 
done order restructure cfgs optimised code debugging purposes see 
assumes instructions easily recognisable intel see basic icfg known 
reconstruction usually uses top approach assuming basic cfg exists 
algorithm icfg approximation binary executables 
provides real time systems analysers safe cfg 
algorithm designed modern processors involves concepts uncertainty low level reconstruction streams bytes making possible generate conservative icfg approximation uncertainties disambiguated 
bottom approach icfg reconstruction fine grained instruction classifications available core algorithm resulting safer precise produced top algorithms 
cope interlocked overlapping routines skips data portions located inside routines 
implementation algorithm follows generic approach module interface showed pcfg edges disambiguated powerpc architectures 
reinhard wilhelm support fruitful discussions 
lot christian ferdinand remarks help 
due daniel markus proof reading giving useful hints improvement 

adl tabatabai gross 
source level debugging scalar optimized code 
proceedings acm sigplan conference programming language design implementation pldi 
cifuentes gough 
new approach debugging optimized code 
proceedings acm sigplan conference programming language design implementation pldi 
cifuentes gough 
decompilation binary programs 
software practice experience 
ferdinand 
cache behavior prediction real time systems 
phd thesis universitat der saarlandes 
ferdinand martin schmidt schneider wilhelm 
run time guarantees real time systems uses approach 
proceedings informatik programmiersprachen paderborn 
ferdinand martin wilhelm 
cache behavior prediction interpretation 
science computer programming 
fur sas 
ibm 
ppc embedded controller user manual edition 

retargetable system postpass optimisations analyses 
proceedings acm sigplan workshop language compiler tools embedded systems 

tdl hardware assembly description language 
technical report universitat saarlandes 
kim min ha 
efficient worst case timing analysis data caching 
proceedings ieee real time technology applications symposium 

crl uniform representation control flow 
technical report universitat saarlandes 
larus schnarr 
eel machine independent executable editing 
proceedings acm sigplan conference programming language design implementation pldi 

li malik wolfe 
cache modeling real time software direct mapped instruction caches 
proceedings th ieee real time systems symposium rtss 
martin 
generation program analyzers 
phd thesis universitat saarlandes 
ramalingam 
loops dominators dominance frontier 
proceedings acm sigplan conference programming language design implementation pldi 
sander 
graph layout vcg tool 
proceedings dimacs international workshop graph drawing volume lecture notes computer science 
springer verlag 
schneider ferdinand 
pipeline behaviour prediction superscalar processors interpretation 
proceedings acm sigplan workshop languages compilers tools embedded systems 

zur des von daten caches 
diploma thesis universitat saarlandes 
sreedhar gao 
lee 
identifying loops dj graphs 
acm transactions programming languages systems toplas 
bus 
static analysis indirect control transfers binaries 
proceedings international conference parallel distributed processing techniques applications pdpta 

uber die verwendung programmierung zur nach 
diploma thesis universitat saarlandes 
ferdinand 
combining interpretation ilp microarchitecture modelling program path analysis 
proceedings th ieee realtime systems symposium rtss madrid spain 
tice graham 
optview new approach examining optimized code 
proceedings workshop program analysis software tools engineering montreal 
