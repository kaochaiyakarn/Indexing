automatic generation data flow analyzers tool building optimizers dissertation department computer science committee graduate studies stanford university partial fulfillment requirements degree doctor philosophy steven weng tjiang july ii copyright steven weng tjiang rights reserved iii certify read dissertation opinion fully adequate scope quality dissertation degree doctor philosophy john hennessy principal advisor certify read dissertation opinion fully adequate scope quality dissertation degree doctor philosophy mark linton certify read dissertation opinion fully adequate scope quality dissertation degree doctor philosophy daniel weise approved university committee graduate studies dean graduate studies iv professor john hennessy advisor building excellent environment computer systems laboratory doing research writing interesting software 
thesis possible advice support confidence patience 
professor daniel weise professor mark linton members reading committee 
professor monica lam professor donald serving committee 
suif compiler system possible saman amarasinghe rob french monica lam amy lim dror maydan jason karen pieper mike smith bob wilson michael wolf 
suffered early unstable stages compiler 
attention suif kept entire compiler system working 
owe special 
graduate school lonely depressing 
fortunately bad moments balanced times spent family friends annette ng teresa chin elizabeth buss tim bruce king steve pollock geoff reeves yamaguchi times spent beer gang gopinath ramsey haddad shing kong scott mcfarling steve richardson larry soule malcolm wing michael wolf 
dave sun labs graciously gave quiet 
special goes charlie margaret keeping running smoothly cis 
people played pivotal roles stanford years 
aho peter unofficial mentors bell labs took time busy schedule talk came visit stanford 
monica lam inspired keen insight willingness chat listen 
michael wolf kurt put life employment research thesis perspective yamaguchi michael wolf kept running sane 
annette ng wife gave patience support love surely 
research supported darpa contract 
grandparents parents wife 
vi modern compilers generate code performing global optimizations 
functions compiler parsing code generation examine statement basic block time optimizers examine large parts program coordinate changes widely separated parts program 
optimizers complex data structures consume time 
generate best code optimizers perform global transformation concert 
transformations interact unforeseen ways 
dissertation concerns building optimizers modular extensible 
optimizer architecture proposed kildall phase data flow analysis dfa program optimization function transforms program 
support architecture set abstractions flow values flow functions path simplification rules action routines provided 
tool called sharlit turns dfa specification consisting abstractions solver dfa problem 
heart sharlit algorithm called path simplification extension tarjan fast path algorithm 
path simplification unifies powerful dfa solution techniques 
path simplification rules compiler writers construct wide range data flow analyzers simple iterative ones solvers local analysis interval analysis sparse data flow evaluation 
sharlit frees compiler writers details various solution techniques 
compiler writer view program representation simple flow graph instruction node 
data structures represent basic blocks regions automatically generated 
sharlit promotes modularity making possible build complex data flow analyzers simpler ones 
sharlit promotes extensibility easier add new flow functions path simplification rules represent new kinds instructions existing analyzers 
complete optimizer built sharlit 
measurements showed optimizer compete code quality commercial optimizing compilers 
vii contents iv vi contents vii list figures xi list tables xiii list procedures xiv chapter sharlit tool building scalar optimizers kildall model optimizers integrating parallelization scalar optimization interactions parallelization scalar optimization stanford university intermediate form organization dissertation chapter data flow analysis basis optimizers data flow analysis optimizers example reaching definitions example liveness analysis example constant propagation viii solving data flow analysis iteration exploiting monotonicity elimination exploiting flow graph structure sparse data flow evaluation graphs skipping regions deficiencies existing data flow analyzers automatic generation dfas chapter path simplification tarjan fast path algorithm efficient implementation example applying path compression path simplification extension control flow analysis simplify header forest routines reduce iterate propagate chapter writing data flow analyzers sharlit preliminaries example iterative analysis eliminating flow variables path simplification rules local analysis summarizing extended basic blocks elimination summarizing loops irreducible graphs sparse data flow evaluation graphs rules compute paths absorb rules save space rules path computation summary ix chapter architecture modular flexible optimizers data flow analyzers control flow graphs data flow analyzers solvers control flow graphs control flow analysis combining data flow analyzers chains products example constant propagation product flow values product specifications modifying non modifying solvers functions generic solver supporting products initialization path simplification reduction iteration propagation summary chapter prototype optimizer structure prototype optimizer flow graph nodes code motion value numbering availability partial availability placement insert expressions implementation placement sharlit code generation strength reduction value numbering changes epr algorithm induction variable rewrite representing relationships induction variables representing loop structures computing induction variables step size propagating induction variable relationships results chapter suif overview suif il registers paths high suif annotations overview status suif compiler system high level transformations analysis status experience chapter flow values efficient iteration flow graphs incremental updates experience sharlit bibliography xi list figures structure optimizer simple flow graph example simple loop eliminating back edges flow graphs skipping identity nodes simple graph header forest loop graph header forest processing loop header forest processing header tree processing outermost region outline sharlit solves data flow problem basic path expression computation simplify node path simplification fails simplification stopped irreducibility phase optimizer structure data flow analyzer iteration solve available expressions meet var nodes applying create rule applying create rule applying absorb rule applying star rule applying join rule example applying path simplification rules copying paths simplifying extended basic blocks local analysis solve available expressions flow function declaration functions xii enhancing solver interval analysis path simplifying rules doing sdfeg example simplification sdfeg reusing flow functions sequences node computing data flow solution node example control flow analysis creating chain multiplying constant propagation structure suif optimizer redundancy partial redundancy partially redundant insertions occur partial availability elimination strength reduction induction variable rewrite loop summarization control flow graph loop program fragment associated suif code path forest suif compiler system xiii list tables table functions provided sharlit solving dfa problems table functions generated sharlit table functions building modifying control flow graph table functions generic solver access flow graph table iteration step product solver table functions generic solver supporting products table fields flow graph node class table comparison suif optimizer commercial optimizer xiv list procedures procedure control flow analysis procedure simplifying graph procedure computing simplified graph procedure header forest routines procedure reduce procedure propagation procedure solution iteration procedure solution iteration procedure reduce revisited procedure propagation finding solutions eliminated nodes procedure control flow analysis detail procedure paraphrase df iterate df propagate 
procedure initialization phase product solver procedure sketch new simplify node simplify region procedure reducer product solver procedure reconstruction product flow value iterator procedure product propagator cp propagate chapter procedure compiler construction decade increasingly emphasized global analyses transformations programs example scalar optimizations parallelization vectorization 
global techniques important ways 
improve usability sophisticated high performance computers letting programmers program computers high level languages minimal performance penalty 
second complement hardware achieving high performance global information generate code architectural features registers multiple functional units effectively 
global information expensive discover pure hardware techniques unreliable programmer tedious programmer give 
unfortunately increasing reliance global techniques compilers larger complex 
building compiler constitutes substantial undertaking requiring years development 
compiler larger generating best code requires global transformation working concert 
compiler complex transformations interact unforeseen ways 
difficulty compiler construction impeding development evaluation adoption new computer architectures 
need global analyses transformations easier build 
need compiler easily retargeted new processors substantial effort invested building compiler go waste 
retarget compilers high performance computers need retargetable instruction selection 
need fine tune global transformations add new transformations 
need compiler flexible extensible 
scalar optimizers exemplify inflexibility 
global analyses transformations consume time traditional compiler algorithms parsing instruction selection 
efficiency concerns resulted scalar optimizers burdened chapter implementation details obscure algorithms 
sequences transformations compilers rigid increase efficiency optimization depends optimization analyses goes 
rigid ordering hinders reordering transformations addition new ones 
dissertation addresses issues building flexible extensible compilers 
major portion thesis discusses sharlit tool simplifies building data flow analyzers scalar optimizers form significant portions compiler 
thesis presents new intermediate language suif stanford university intermediate form integrates conventional scalar optimizations high level transformations parallelization high level analyses dependence analysis 
sharlit suif part suif compiler parallelizing optimizing compiler developed stanford 
sharlit tool building scalar optimizers sharlit tool building scalar optimizers 
optimizer performs program transformations constant propagation folding forward backward code motion removing useless computations register allocation 
transformations applied generally computations involving scalars including addressing computations array accesses 
shows structure optimizer 
logically composed phases 
front compiler translates program intermediate language il 
optimizer reads procedure il program 
phase optimizer analyzes transforms procedure 
typical sequence phases value numbering constant propagation code motion dead store elimination 
phases complete optimizer writes il program 
larger scope scalar optimizations sets apart compiler algorithms parsing instruction selection 
parsing instruction selection need examine statement basic block time 
contrast optimizers need examine change large portions program 
larger scope means optimizers detect relationships widely separated parts program 
compared local information front ends code generators relationships complex time consuming extract 
furthermore scalar optimizers lots phases 
phase different information requirements particular demands program representation 
despite complexity optimizers tools exist building 
situation stands stark contrast parts compiler years experience chapter culminated models structures embodied specialized tools construct parts 
example lexical analysis generators lex 
parser generators yacc 
front analyses attributed grammars 
instruction selection interpretation twig graham generators attributed parsing 
tools provide layer abstractions hide implementation details compiler writer provide powerful algorithms tailored needs compiler writers 
tools writing compiler parts easier 
lack tools justified concern efficiency meant optimizers built ad hoc manner implementation details complicate transformations unnecessarily 
basic blocks example imposes level structure transformations 
local level deals analysis transformations basic blocks global level deals control flow graph nodes basic blocks 
levels introduced lower space time required structure optimizer conceptually optimizers organized fixed sequence phases 
optimization source program translated intermediate language il front 
optimizer reads il program procedure time converting internal representation ir typically control flow graph 
optimizer phase operates flow graph analyzing transforming 
phase finished ir written better efficient il program internal optimizer phase optimizer phase 
program il reader representation procedure optimizer phase il il writer better program il chapter form data flow analysis dfa 
levels force dfa proceed steps 
local analysis phase computes data flow effect basic block composing data flow effects instructions 
global solution phase uses computed effects find solution dfa problem entrance exit block 
ad hoc propagation step computes data flow information instruction information entry exit block 
sharlit insulates compiler writers implementation details optimizers just tools parts compiler 
sharlit provides view dfa consisting abstractions flow graphs consists nodes data structures specified compiler writer 
flow values represents data flow information flows flow graph 
solution dfa problem consists set flow values node 
flow functions represent data flow effects effects flow values pass nodes 
action routines dfa solution perform program optimizations 
routines analogous action routines parser description 
path simplification rules show combine flow functions flow functions 
abstractions compiler writer describe dfa unencumbered implementation details flow graph dfa solved 
particular basic blocks necessary efficient data flow analysis flow graph simpler node individual ir instruction 
abstractions general implement wide range program analyses traditional bit vector sophisticated symbolic analysis 
key achieving versatility algorithm called path simplification 
path simplification version tarjan fast path algorithm computes path expression node flow graph 
expression represents paths source path expression regular expressions built node labels operators 
example path expression exit source node exit node sharlit uses path expressions data flow analysis interpreting node labels flow functions path concatenation function composition path addition meet functions finding flow function loop 
short interpreting path expression manner yields data flow effect paths represented 
empty path identity function 
da aa aaa 
chapter compiler writer tells sharlit perform interpretation path simplification rules 
rules implement local analysis interval analysis compute sparse data flow evaluation graphs 
rules applied reducible irreducible flow graphs 
kildall model optimizers sharlit compiler writers organize phase optimizers dataflow analyzer followed optimization function uses solution dfa problem modify program 
organization proposed kildall 
organization general implement classical optimizations 
structure optimization usually data flow analysis step collects information followed ir graph traversal checks node collected information enables optimization 
example aho sethi ullman chow organization describe optimizations 
sharlit extends kildall model path simplification techniques combining simpler data flow analyzers complex ones 
extensions compiler writers optimizers simpler modular extensible 
optimizations operate simple flow graphs node instruction 
phase optimizer module consisting data flow analyzer parts expressed flow functions simplification rules 
format ir changed changes accommodated adding new flow functions simplification rules 
analyzer turn composed smaller simpler analyzers 
integrating parallelization scalar optimization aspect compilation covered thesis scalar optimizations parallelizing optimizations integrated 
compiling programs parallelism simple flow graph source sink chapter memory hierarchy efficiently requires parallelizing transformations scalar optimizations interact ways 
scalar transformations analyses prerequisites parallelizing transformations 
likewise information gathered parallelism analyses improve scalar optimizations 
machines instruction level parallelism scalar parallelizing transformations intimately linked 
key challenge integrating transformations require different kinds knowledge manipulate code differently 
interactions parallelization scalar optimization existing parallelizing compilers stages 
stage compilers source syntax trees high level representation parallelize program source source translation 
second stage parallelized source compiled optimized traditional scalar compiler 
distinguish scalar parallelizing transformations information 
scalar optimizations rely information gathered traditional data flow analysis parallelizing transformations rely data dependence information information tells array refer location relationships 
compilers strictly separate categories transformations representations low level high level syntax trees 
representations functions provided scalar phases re implemented representation high level analyses longer directly communicate low level transformations 
scalar phases valuable preparing code data dependence testing 
example dependence tests require array indexes affine functions loop index variables bounds arrays constants 
consider code shown 
testing apply induction variable expansion constant propagation scalar optimizations 
induction variable expansion translates 
induction variable expansion detects induction variables loops expresses terms loop index 
example simple loop chapter affine function 
propagating constant variable data dependence tester tell refer loop parallelizable 
scalar phases simplify transformations cleaning 
constant propagation example potentially create dead code eliminated scalar privatization 
reduce scalar privatization privatizing dead code large performance penalty 
eliminating dead code necessary remove code redundant scalar optimizations 
instances suif compiler eliminates dead code phase 
situations totally different representations scalar parallelizing transformations write different sets optimizations source source compilers 
example different elimination phases 
il support categories transformations scalar phases parallelizing phases freely intermixed 
freedom permits take tool approach building suif compiler 
phase tool 
tool prepare code tools just constant propagation induction variable expansion data dependence analysis 
tool clean 
tool simple easy implement test 
integrating levels advantage ease information flow high level low level phases 
superscalar instruction scheduling example sufficient just high level analyzer label loop doall loop 
non doall loops loop carried data dependences contain useful parallelism 
general high level data dependence information available superscalar scheduler maximum flexibility reordering loads stores loops 
stanford university intermediate form suif compiler program representation integrating high low levels intermediate language 
parallelizing scalar phases read write programs intermediate language 
integration offers key advantages existing compilers 
duplication effort 
different representations traditional compilers require versions transformations analyses stage high level representation second stage low level representation 
compiler version 
chapter availability high level information low level 
having representations hinders communication high level information low level transformations 
consider low level transformation instruction scheduling 
highlevel information data dependence aliasing information information attached individual loads stores 
doing source level sufficiently fine grained identify individual memory requires auxiliary files ad hoc commenting conventions 
compiler provides simple mechanism called annotations attach information individual instructions 
suif intermediate language supports wide range high low level transformations 
suif small core simple instructions manipulate infinite number virtual registers 
core commonly considered suitable lowlevel scalar optimizations thesis shows core suitable highlevel transformations 
example suif explicit representations high level control structures loops array indexing instruction features necessary data dependence testing 
suif compiler set scalar parallelizing phases reordered 
scalar phases implemented sharlit 
adding new flow functions extend phases recognize high level control flow indexing instructions 
extended scalar phases high low levels parallelization 
organization dissertation rest thesis divided chapters 
second chapter discusses data flow analysis serve model optimizers 
show dfa problems commonly optimizers outline techniques solve problems 
third chapter presents path simplification algorithm 
path simplification modification tarjan fast path algorithm 
show algorithm detail show sharlit uses flow graph solve dfa problems efficiently posed graphs nodes individual ir instructions 
fourth chapter demonstrates sharlit versatility sharlit generate space efficient solvers 
give examples compute reaching definitions available expressions 
examples demonstrate progressively sophisticated dataflow analyzers specified 
fifth chapter presents architecture sharlit provides building optimizers 
architecture includes abstractions control flow graphs combining sharlit solvers data flow analyzers 
chapter sixth chapter discusses suif scalar optimizer constructed sharlit 
detail optimization algorithms partial redundancy elimination strength reduction induction variable rewrite 
outline optimizations 
give experimental results showing optimizer effective 
seventh chapter presents suif describes macro expansion certain conventions names permit integrate types program transformations 
eighth final chapter concludes thesis indicates directions research 
chapter data flow analysis basis optimizers procedure data flow analysis basis optimizers determine program transformations apply program apply optimizer needs information run time behavior program 
information gathered data flow analysis dfa 
dfa computes data flow information assertions conditions program states point program 
determining assertions true execution program tantamount solving halting problem 
data flow analysis estimate run time behavior general dfa determine assertions true false undetermined 
general technique estimation interpretation maps user program equations domain 
solving equations yields desired data flow information 
dfa extensively studied literature 
properties dfa problems formalized authors cousot graham wegman hecht kam ullman marlowe ryder ryder tarjan 
efficient algorithms solve dfa problems developed choi graham wegman hecht ullman horwitz tarjan ullman 
kildall recognize program analysis serve basis implementing optimizations 
choosing appropriate domain data flow analyzer compute simple information reaching definitions liveness detect recurrences perform code motion 
authors chow joshi dhamdhere morel renvoise kildall model data flow analysis optimizations 
dissertation presents tool supports kildall model directly 
chapter data flow analysis basis optimizers chapter gives general model dfa problems commonly solved optimizers 
describes concepts flow values flow functions lattices meet functions 
gives methods commonly solve dfa problems 
closes discussing deficiencies current implementations data flow analyzers 
sharlit primarily concerned intraprocedural optimizations 
model dfa applies single procedure 
word program taken mean procedure 
data flow analysis optimizers optimizers perform dfa programs represented directed graph called control flow graph cfg 
cfg consists nodes basic blocks edges represent flow control 
propose dfa performed graph node simpler representing operation instruction 
nodes graph respectively unique source final nodes cfg number nodes cfg 
usually nodes simple instructions form program variables constants operator 
execution path trace operations executed execution procedure sequence nodes 
path refer operation executed 
model dfa sharlit uses parts flow values sharlit represents assertion program state flow value 
node cfg flow variables hold flow values representing assertion true node representing assertion true node 
meet operator flow graph paths meet sharlit combines flow values commutative meet operator frequently written flow functions sharlit associates function node function maps flow values flow values represents data flow effect instruction flow equations flow functions flow variables sharlit forms equations relating variables 

chapter data flow analysis basis optimizers equations composed flow functions meet operators 
give examples equations subsections 
solve dfa program mapped set flow equations 
solution equations consists flow values variables node parts sharlit adds path simplification rules action routines 
rules generate efficient data flow analyzers 
action routines solutions modify program 
rules action routines discussed chapters 
examples illustrates describe data flow analyses commonly existing optimizers model 
examples basic blocks need explain arrive data flow effect basic block effects instruction block distinguish local global data flow information effects 
example reaching definitions reaching definitions analysis determines assignments variable program affect uses variable program 
normally problem solved simultaneously variables 
simplify description stating problem single variable set set definitions operations procedure may define assign values definition reaches node execution path executes executing definitions executed execution path value assigned value solution reaching definitions problem consists subset reaching node 
possible execution procedure value node equal value assigned definition set parts reaching definitions problem definitions 
flow values represent definitions reaching node subsets optimizers bit sets represent subsets meet operator control flow edges meet definition reaching meeting point arrived control flow paths 
meet operator set union 
avoid halting problem loops assumed eventually exit 
execution paths assumed unbounded finite 


chapter data flow analysis basis optimizers flow functions node definition flow function constant function definition identity flow equations cfg set equations equations node input output 
optimizers reaching definitions constant propagation 
definitions variable reach node assign constant optimizer directly replace uses node test definitions done optimization function suggested 
example liveness analysis reaching definitions problem propagates information forward cfg determines definitions may executed node 
dfa problems propagate information backward 
example liveness analysis determines uses variables executed node 
liveness problem single variable stated follows 
set set uses operations procedure variable variable dead node execution paths leading exit procedure execute member live 
solution liveness problem consists indication live dead node 
just reaching definitions define flow values meet operator flow functions flow equations 
time role reversed showing information propagates backwards 
parts defined 
flow values represent liveness boolean value 
meet operator information flows backwards meet operator point control flow edges meet point control flow edges leave node 
point live live successors meet operator boolean disjunction flow functions node constant function predecessor true chapter data flow analysis basis optimizers flow equations problem flow equations optimizers liveness analysis detect computations store values dead variables 
computations removed results 
example constant propagation previous examples flow functions identity simple constant functions 
dfa problems flow functions resemble interpretation program instructions 
problem constant propagation problem 
problem tracks values variables performs computations tracked values 
dfa flow value maps program variable value 
represent flow value set ordered pairs program variable value constant special value called bottom 
pair constant variable value just node executed 
special value indicates dfa determine constant may constant dfa determine value constant 
constant propagation requires extend operations program accept operator define arguments bound parts dfa defined flow values flow value contains ordered pair program variable meet operator define operator follows flow functions define flow functions type instruction node instruction false successors 



chapter data flow analysis basis optimizers words identity node instruction flow equations flow equations defined reaching definitions problem set union operation replaced meet operator defined mappings described 
initial value input flow variable start node solving constant propagation problem requires translating operations program complex functions previous examples 
reaching definitions propagate constants optimizer dfa directly uses node replaced solving data flow analysis posing dfa problem defining flow values meet operator flow functions mapping procedure set flow equations compiler writers methods disposal solve equations 
commonly techniques fall classes iteration elimination sparse data flow 
sections discuss briefly gives conditions best 
sharlit combines solution method chapter 
iteration exploiting monotonicity iteration simplest main method solve dfa problems optimizers 
iteration requires analysis cfg works directly reducible irreducible flow graphs 
solve set data flow equations iteration set flow variables initial value evaluate equations repeatedly assignments reaching fixed point initial value depend particular dfa problem described 
procedure converge flow values flow functions obey variables chapter data flow analysis basis optimizers properties flow values form semi lattice finite descending chain condition meet operator dfa satisfy relationship partial order semi lattice 
finite descending chain condition states non increasing sequence flow values finite 
intuitively partial order lattice compares relative information content flow values 
information 
monotonicity flow functions satisfy relationship flow values 
monotonicity ensures iteration assigned progressively smaller flow values 
initial value larger respect partial order semi lattice fixed point iteration converge 
finite descending chain condition guarantees convergence occurs finite time 
distributivity flow function dfa problem distributes meet operator necessary convergence distributivity pertains quality solution iteration 
distributivity guarantees fixed point iteration largest possible respect 
solution dfa problem fixed point distributivity ensures solution information solution iteration 
dfa problems described previous sections satisfy conditions solved iteration 
example reaching definitions subset forms semi lattice partial order set inclusion types flow functions identity monotonic finite descending chain finite 
iteration requires cfg analysis examining graph create order equations evaluated iteration converge faster 
hecht ullman shown convergence asymptotically fastest requiring fewest equation evaluations equation order corresponds topological sort graph ignoring back edges loops 
order called reverse post order computed 
chapter data flow analysis basis optimizers depth traversal flow graph 
practice decrease number equation evaluations techniques horwitz demers teitelbaum 
techniques require control flow analysis complicated simple depth walk graph similar elimination algorithms 
elimination exploiting flow graph structure elimination methods structure cfg solve dfa 
chief advantages 
faster iteration 
improvement analysis time depends time spent discovering program structure control flow analysis compares time spent evaluating flow equations 
flow functions simple bit vector dfa problems equation evaluation fast compared control flow analysis 
case hecht ullman shown elimination roughly performance iteration 
hand flow functions complex dfa problems involving symbolic analysis advantage swings favor elimination methods assuming finding data flow effect loop done quickly 
second importantly elimination methods discover program structure 
information useful detecting transforming recurrences solving dfa problems finite descending chains 
removing back edges loops key idea elimination methods 
flow graph loops just iteration graph evaluates flow equations eliminating back edges show graph back edges eliminated 
shade node processed 
process removing back edges computes new flow equations relating nodes loop header 
indicate new edges 
chapter data flow analysis basis optimizers reverse post order solve data flow problem 
flow graph loops flow equation depend variable value may change evaluating equation order 
nodes numbered reverse post order input variable node depends output variable node 
changes iteration graph required recompute elimination removes back edges rewriting flow equations replacing flow functions nodes course changing final solution dfa problem 
example back edge node node removed rewriting flow equation depend require computing new flow function node flow function reflects data flow effects loop formed node 
example new flow function defined flow equation write function rewrite equations data flow analyzer know combine flow functions ways composition flow function 
meet flow functions defined obvious way fixed point flow function defined way rules write dfa problem distributive 
elimination repeatedly applies back edge elimination reducible graph acyclic 
example shows repeated application 
part innermost back edge removed outer back edge removed 
sideeffect back edge removal computes new flow function relating nodes loop header 
elimination methods disadvantages 
manipulate flow functions implementation complex iteration 
second practical elimination algorithms operate reducible flow graphs 
elimination methods graphs complex implement 
existing compilers deal node splitting enlarges graph isolating irreducibility small subgraph iteration applied 


fg 
chapter data flow analysis basis optimizers sparse data flow evaluation graphs skipping regions sparse dfa problems flow functions identity functions solved efficiently sparse data flow evaluation graphs sdfeg generalization static single assignment representation ssa 
sparse dfa problems occur example wish consider subset procedure variables example trying find reaching definitions single variable section 
partitionable dfa problems partitioned set sparse dfa problems example ssa separated set sparse dfa problems variable 
sparse techniques ssa extensions applications studied extensively authors alpern cytron ferrante wegman zadeck 
solving dfa problem sdfeg efficient sdfeg contains subset nodes original flow graph flow functions identity flow values generated distinct nodes meet 
edges sdfeg connect nodes represent identity paths original flow graph paths effect flow values 
iterating entire flow graph dfa problem solved iterating smaller sdfeg 
shows flow graphs corresponding 
smaller original flow graph sdfeg fewer variables 
flow graph node sdfeg lies identity path connected node sdfeg identity path 
variables equal variables eliminated 
flow variables value output flow variable overcome problem shared iteration elimination maintain data flow information nodes change interest information 
example reaching definitions problem section nodes flow variables containing reaching definitions 
sparse techniques eliminates flow variables recognizing equal flow variable sdfeg 
iteration propagate flow value modified node nodes flow functions identity 
sdfeg skips nodes relate directly addition nodes need flow variables refer directly 
equivalences eliminate flow variables save substantial amount space solving sparse dfas 

chapter data flow analysis basis optimizers deficiencies existing data flow analyzers data flow analysis consumes lot time space compiler writers concerned implementing analyzers efficiently 
concern led deficiencies existing optimizers 
compiler writers lower time space requirements limiting kinds dfa compute 
unfortunately limits restrict kinds code optimizations done restriction contrary goal building extensible optimizer 
second optimizers designed control flow graph levels 
node graph basic block 
level graph reduces number nodes flow variables instruction need flow variables required dfa 
unfortunately level graph obscures data flow analysis code transformation 
major drawback level approach complicates programming dfas 
analyzer local analysis propagation phase 
local analysis com flow graphs flow graphs left corresponding right 
graphs shaded node non identity flow functions 
lower flow graph sdfeg contain meet node flow values reaching meet node generated node 
sdfeg eliminates input output flow variable node value output flow variable node chapter data flow analysis basis optimizers flow function basic block composing flow function instructions 
propagator uses global dfa solution basic block compute local solution instruction 
phases custom built compiler writer 
second drawback compiler writers understand dfa levels build prototype dfas 
levels appear published descriptions dfas 
dfa understood solved knowing data flow effect instruction level structure implementation detail constitutes unnecessary concepts 
third drawback level structure encourages non modularity 
minimize number cfg traversals compiler writers combine local analysis dfa problems traversal corresponding propagators traversal 
compiler writer shoulder burden orchestrating phases perform desired 
automatic generation dfas limiting analyses basic blocks dissertation takes different approach efficient dfa 
data flow analysis plays central role implementing optimizations suggested 
provide tool sharlit associated framework construct data flow analyzers 
framework compiler writers describe dfa problems modular fashion 
data flow effects instructions described flow functions flow values skipping identity nodes graph node identity node 
information needed node sdfeg sends information directly having propagate information nodes 
chapter data flow analysis basis optimizers details dfa problems 
compiler writers pose dfa problems node cfg instruction 
details required solve problems described separately path simplification rules 
descriptions sharlit generates efficient data flow analyzers 
analyzers dfa solution techniques described chapter 
analyzers combined form complex analyzers 
key concept capabilities path simplification 
chapter path simplification procedure path simplification crux thesis optimizers easier build built framework espoused previous chapter framework optimizations performed automatically generated data flow analyzers 
success approach depends general efficient automatically generated data flow analyzers 
chapter shows analyzers fulfilling requirements generated 
sharlit analyzers solve wide range program analysis problems traditional bit vector dfas ones sophisticated symbolic analysis 
analyzers general algorithm path simplification solve dfas 
algorithm tarjan fast path algorithm 
path simplification extends previous algorithms integrating iteration elimination sparse data flow evaluation techniques algorithm 
compiler writers pose dfa problems directly cfg node instruction 
graphs flow equations flow variables 
solve dfa problems graphs efficiently sharlit data flow analyzers path simplification reduce number flow equations nodes graph solve equations arrive solution original cfg 
emphasize compiler writer specifies dfa problem sharlit supplying information implementation flow value 
set flow functions function kind instruction 
set path simplification rules describe compose join certain pairs flow functions take kleene star flow functions chapter path simplification chapter concerned path simplification process automatically generate analyzers called solvers reduce size graph 
important remember generated analyzer simplify paths sharlit 
chapter give examples sharlit specifications 
tarjan fast path algorithm sharlit generated data flow analyzers tarjan fast path algorithm 
algorithm customized solve different dfa problems efficient 
section give outline 
tarjan algorithm solves single source path problem 
accompanying tarjan recognized generalization graph problems data flow analysis 
finds path expression representing paths source node graph 
convention path node node starts exit node ends exit node path expressions regular expressions built node labels operators see section need page number 
turn algorithm dfa algorithm interpreting paths expressions data flow effects 
interpretation map node labels flow functions dfa problem map path concatenation composition flow functions path addition meet flow functions kleene star finding flow function loop 
mappings algorithm construct flow functions represent data flow effects paths flow graph 
solving equivalent finding flow functions source exit node 
evaluating flow functions yields solution dfa problem 
uses loop structure reducible graph solve 
similar elimination algorithms graham wegman ullman 
algorithm finds natural loops program removes back edges loops inner loop replacing edges 
key steps algorithm 
control flow analysis cfa determine loop structure flow graph 
information computed lets steps determine loops innermost loop node belongs nodes headers loops 

apply graph acyclic simplify reduce node innermost loop compute path expression represents paths header entry node loop chapter path simplification replace new node sole predecessor 
important note edges replaced exactly edge 
fact key representing reduced graph efficiently 
label path expression 
solve node follow path reduced graph source concatenating path expressions label nodes path 
path unique computed path expression path expression source time performs third step reduced graph acyclic fact tree edges replaced edge header parent tree 
tree ness reduced graph means solve save factoring path expression node need computed child example demonstrates steps 
efficient implementation simplify reduce step algorithm ways implement edge replacement 
notable efficient elegant way replaces edges 
naive implementation explicitly updates graph slow 
path simplification auxiliary data structure header forest record sequence graphs reductions computed path expressions 
header forest represents reduced graph efficiently exploiting fact simplify reduce replaces node edges exactly edge step simplify reduce turns innermost loop body tree 
initially header forest contains nodes flow graph edges 
computed path expression header node region adds edge linking path application simplify reduce think reduced graph combination header forest original graph 
section demonstrates viewpoint 
example applying example shows header forest applied graph 
step cfa finds loop structure interval headers graph source node considered header outermost interval backedge connects final node source 
starting deepest interval headed computes path simply expression recorded header forest 
chapter path simplification loop processed header 
path bc 
come account back edge gives path ed 
paths back edge subsumed path expression computed path expression computed ed path expressions recorded header forest shown 
shows hypothetical reduced graph composed header forest original graph shaded nodes indicate nodes replaced corresponds source simple graph header forest loop source chapter path simplification shaded nodes header forest 
header forest processing shown 
final application simplify gives header forest implement step solve computing path expressions node top traversal header tree 
path compression processing region headed source simplify find path expressions nodes node nodes left node header forest simplify considers node demand path expression required compute path expressions nodes 
case node path expressions computed necessary computing path expression node tarjan calls demand computation path compression 
shows path compression gives complexity size flow graph 
path simplification extension stated earlier chapter solve dfa problems interpreting path expressions data flow effects 
correspondence path expressions flow graph header forest processing loop shaded nodes graph left corresponds shaded nodes header forest right 
new node label path expression bc ed ed leave old labels nearby just new nodes remind original nodes 
source source nlogn chapter path simplification header forest processing label bc ed ed source header tree processing outermost region label fa fa 
header forest solve walking tree concatenating path expressions node labels 
source chapter path simplification functions exact set flow functions complete 
call complete combinations functions satisfies conditions composition flow functions member join flow function member kleene star flow function member completeness guarantees path expression computed interpreted flow function 
set incomplete path expression may corresponding flow function 
sharlit compiler writer defines set describes functions combined 
incompleteness occur compiler writer provide combinations 
path simplification computes path expressions interpreted flow functions 
set flow functions complete path simplification behaves just find expressions paths node loop header 
set incomplete longer path simplification works 
finds representable path expressions node dominators 
ability gives path simplification versatility 
depending flow functions incomplete path simplification behaves data flow analyzer local analysis computes sdfeg identical 
section explain incompleteness causes behaviors 
incompleteness lets path simplification handle irreducible graphs 
rare irreducible flow graphs occur practice 
majority programs reducible flow graphs irreducible graphs appear solve backward data flow problems reverse reducible graph necessarily reducible 
path simplification splits simplify reduce step steps simplify reduce 
shows steps relate steps data flow analyzer generated sharlit 
sections discuss step detail 
steps path simplification compute information node 
ancestor pointer node ancestor node header tree 
initially ancestor contains nil pointer indicating point node 
flow flow function node compiler writer provides node flow function mapping see chapter 
nf flow function computed reduce step 
flow function ancestor flow function relabel nodes header tree section 
initially nf equals flow chapter path simplification keep flag indicate node kept reduce step 
initially flag false solved flag indicate iteration solution output variable initially flag false control flow analysis procedure control flow analysis cfa discovers looping structure flow graphs 
presents information list loop bodies ordered deeply outline sharlit solves data flow problem control flow graph simplify reduce iterate propagate simplified graph reduced graph solution reduced graph control flow analysis dfa solution loop structure chapter path simplification nested loops appear 
loop body represented topologically sorted list nodes loop 
example applying cfa gives lists loops control flow analysis computes reverse post ordering nodes ordering iteration propagation 
control flow analysis uses algorithm tarjan compute information time 
algorithm traverses graph twice 
depth traversal computes reverse post ordering graph back edges loop headers 
second traversal uses loop headers back edge information compute lists nodes described 
amount cfa existing optimizers 
detail algorithm see section 
simplify control flow analysis step path simplification computes path expressions innermost loops outward see procedure 
loop simplification visits nodes topological order 
header outer loop header visited nodes procedure shows path computation single node 
depicts computation path expression node flow function simplify node path computations enclosed quotes indicate computations interpreted operations compositions joins kleene star flow control flow analysis control flow analysis sharlit similar existing optimizer 
depth traversal finds reverse post ordering nodes topologically ordering nodes ignoring backedges 
ordering compute lists loop bodies 
procedure uses reverse post ordering iteration 
cfa step needs performed different data flow analyzers 
cfa control flow analysis control flow graph 
perform depth traversal discover loop structure output list lists depth depth depth topologically ordered set nodes loop body source log chapter path simplification tions 
operations accomplished invoking path simplification rules described chapter 
step simplify node computes path expression loops starting node nodes loops dominated computing requires calls eval see procedure page performs path compression 
second step calls eval path compress predecessors third step finds new ancestor dominator final fourth step computes path expression ancestor procedure simplifying graph path expressions computed visiting innermost loops 
loop nodes visited topological order 
note means header loop visited nodes loop 
simplify computed cfa simplify region simplify region body simplify node header basic path expression computation simplify node show graphical schema various nodes involved path computation combined 
incoming edges node flow function replaced edge new path expression 
eval eval eval pq eval eval eval chapter path simplification procedure computing simplified graph procedure simplify node computes path expression single node procedure determines ancestor dominator path ancestor representable flow function 
flow function kept nf 
important piece information keep indicates reduce step remain reduced graph 
simplify node step 
back edges nodes back edge identity eval eval eval nf step 
edges nodes connected back edge eval step 
determine ancestor ancestor ancestor 
ancestor ancestor special unique predecessor step 
compute new flow function eval eval eval nf bottom ancestor nf return keep keep keep return chapter path simplification procedure header forest routines version eval 
version computes path expression root header tree belongs auxiliary function path compress path computation 
second version eval 
computes path expressions version 
returns new path expression second argument ancestor procedure travels path root header tree belongs 
way computes path expression node path path expression root possible simplification failures procedure compress far 
works functional composition path concatenation associative 
eval ancestor nil path compress return nf return identity eval ancestor nil path compress return identity ancestor return nf return bottom path compress ancestor ancestor nil path compress ancestor nf ancestor nf bottom nf ancestor ancestor ancestor chapter path simplification path computations may fail compiler writer flow function represent combination flow functions graph irreducible 
cases quoted expression returns special predefined flow function represented bottom simplify node 
instructive see simplify node confronted irreducibility 
irreducibility manifests predecessors common ancestor 
causes common ancestor tests fail step simplify node 
failure results nf set bottom step 
path computation fails procedure simplify continues find path expressions albeit path expression may longer headers nodes 
shows happens 
path simplification blocked simplification continue root new header tree 
node loop header path simplification fails path simplification fails predecessors different ancestors 
simplification stopped irreducibility simplification stopped continue find ancestors nodes simplifier sets ancestor xy xyz outlined subgraphs right indicate nodes form header trees header forest 
xy xyz chapter path simplification simplify paths leading nodes dominates 
chapter shows incompleteness simplification perform local analysis basic blocks extended blocks build 
header forest routines procedure gives routines manipulate header forest 
header forest implemented pointers ancestor computed simplify node 
path compression computes path expressions paths header forest 
done demand simplify node calls eval procedures 
reduce imagine procedure simplify node computes simplified graph 
consider simpler may fewer back edges 
may back edges path computation failure 
simplified graph nodes original flow graph edges defined follows node ancestor simplified graph single edge say edges incident original graph replaced 
data flow effect exit exit stored nf 
procedure reduce procedure computes reduced graph back propagating keep flag 
procedure assumes reduced graph contains loop headers 
works simplify node set keep flag predecessors connected backedges 
reduce empty list nodes traverse reverse order reverse reverse post order header keep prepend ancestor nil keep ancestor keep predecessor return chapter path simplification ancestor nil simplified graph retains edges incident original graph 
data flow effect entrance exit stored flow 
path simplification rules correctly compute compositions joins kleene star correctly solving dfa problem simplified graph gives solution solving original flow graph 
simplified graph simpler removing nodes procedure reduce shown procedure 
clearly making reduced graph smaller reduce performed iteration 
procedure reduce partitions graph graphs reduced graph nodes dfa solutions computed propagating solutions nodes reduced graph 
reduced graph computed single scan graph reverse reverse post order 
scan procedure reduce back propagates keep flag set earlier simplify node 
procedure reduce need scan nodes connected back edges follow reverse post order see hecht nodes keep flag set simplify node 
reduce determine nodes returned graph returns reverse post order reduced graph 
iterate propagate iteration procedure efficiently solve dfa problem iterating smaller reduced graph 
iteration follows edges reduced graph evaluation test ancestor 
back edges eliminated procedure propagation procedure walks graph topological order computing flow variables previously computed procedure 
propagate solved meet predecessors flow chapter path simplification limit iterate pass setting second argument limit 
finding fixed point iterate sets solved flag nodes reduced graph 
nodes reduced graph flow variables computed procedure propagate shown procedure 
pass graph reverse post order fill missing flow variables 
sharlit lets compiler writer simple model dfa model nodes individual ir instructions data flow information computed available instruction optimizations 
model pitfalls nodes flow variables 
chapter shows path simplification deal problem nodes 
builds simplified graph replacing edges original flow graph 
suc procedure solution iteration procedure solves data flow problem graph stored list nodes list may reduced list resulting procedure reduce 
iterate limit iter changed changed iter ancestor ancestor meet predecessors ancestor nf flow changed iter solve chapter path simplification cess replacement depends completeness 
simplified graph property partitioned sets reduced graph solved quickly iteration rest solved traversal graph propagation 
chapter show eliminate flow variables 
instructive compare sharlit data flow analyzers data flow analyzers existing optimizers 
control flow analysis sharlit analyzers performs analyzers 

simplify closest analog step traditional analyzers local analyzers 
overhead reduction step chapter shows simulate local analysis general perform styles data flow analysis 

reduce traditional data flow analyses reduce size graph collapsing linear sequences instructions basic blocks 
sharlit reduction phase general collapse removes nodes way elimination algorithms 

iterate step identical sharlit traditional analyzers sharlit reduced graph smaller 

propagate step identical sharlit traditional analyzers 
chapter writing data flow analyzers sharlit procedure writing data flow analyzers sharlit previous chapter showed path simplification eliminates nodes flow equations 
path simplification lets solve dfa problem solving equivalent dfa problem reduced control flow graph computing solution solution solution general dfa solution procedure subsumes traditional method basic blocks extended basic blocks interval analysis sparse data flow evaluation graphs 
chapter shows kinds data flow analyzers programmed sharlit 
process examples explain flow variable elimination flow equations eliminated instruction flow variables 
flow values occupy large amounts storage 
exploit reverse post ordering show flow variables particular associated instructions basic blocks computed fly need stored 
eliminate redundant flow variables arise nodes connected identity paths see section path simplification rules path simplification combines flow functions constructs path expressions 
chapter show affect simplification process 
chapter demonstrate simplification controlled path simplification rules 
incomplete path simplification explained previous chapter irreducibility results paths simplified 
way incomplete simplification arise incomplete set rules 
complete set rules possible combinations flow functions represented flow function chapter writing data flow analyzers sharlit simplification 
incomplete set may mean path may failed simplified contains combination flow functions combined rule 
demonstrate incomplete rule sets showing compute sdfeg described chapter choi 
extensibility sharlit generates analyzers extensible 
demonstrate sharlit examples solving available expression problem avp 
expression available node path source evaluated expression value expression remains reevaluated determining available expressions important global common subexpression elimination code motion 
built example previous adding new flow functions new path simplification rules 
example prototype solver uses iteration solve avp 
example ir instruction node flow graph making prototype inefficient 
adding simplification rules extend prototype local analysis reducing needed iteration 
adding rules meet star rules enhance solver interval analysis 
assume reader familiarity 
sharlit implemented uses way yacc uses preliminaries optimizer built sharlit consists data flow analyzers shown 
analyzers may execute series running input program 
combined described chapter cooperate input program 
shows automatically generated analyzer generated sharlit parts control flow analyzer path simplifier iterator propagator 
controlflow analyzer done dfas discovers loop structure control flow graph 
path simplifier consists simplifier reducer described chapter 
iterator phases reduced graph calling flow functions solution data flow problem 
propagator computes solution eliminated nodes solution nodes reduced graph 
process propagator calls user supplied action routines node routines solution perform optimizations 
chapter writing data flow analyzers sharlit phase optimizer phase optimizer consists data flow analyzers generated sharlit 
dfa dfa dfa 
input program output program structure data flow analyzer data flow analyzers automatically generated sharlit 
dotted line separates provided compiler writer generated provided sharlit 
flow functions action routines simplifier rules sharlit specification flow function classes data flow analyzer control flow analyzer path simplifier iterator propagator flow value implementation graph routines user sharlit chapter writing data flow analyzers sharlit components compiled linked black arrows internal phase optimizer 
flow value implemented class compiler writer 
compiler writer implement flow graph way provide graph routines generated data flow analyzer view flow graph doubly linked directed graph edges stored adjacency vectors 
examples ir quad ir instruction implemented structure fields relevant examples shown 
ir types instructions distinguished field kind 
expressions built recursively arithmetic operations variables interested kinds ir op performs arithmetic operation src src storing result variable dst 
ir ldc loads constant variable dst 
ir kill modifies variable dst 
ir initial instruction type mark source node graph 
ir doesn affect contents variables 
assume value numbering performed possibly previous phase instructions 
ir instruction value numbering set field expr identify symbolic expression computed instruction 
variable value numbering computed set expressions killed write variable see kill sets 
example iterative analysis example shows sharlit specification uses iteration solve avp 
simplest kind specification possible contains minimal ingredients necessary working dfa solver 
braces specification delimit code sharlit inserts code framework build solver just yacc inserts user supplied code code framework build parser 
parts variables underscore class ir instruction public int kind ir variable dst src src expression expr 
chapter writing data flow analyzers sharlit special 
playing role variables yacc refer variables sharlit generated parts solver communicate user supplied code 
shows sharlit specification 
major parts specifications described data specific dfa problem keyword solver begins declaration variables specific dfa problem 
variables user supplied code procedure solution iteration procedure refinement procedure chapter 
previous procedure assumes node output flow variable procedure handles eliminated flow variables 
node variable var set 
node requires meet operation compute input flow value meet set 
flag helps iterate avoid unnecessary meets 
procedure calls procedures sharlit specification 
procedure new value creates new flow value returns pointer 
procedure copy value copies second argument src specification argument dst 
procedure meet assigns argument dst meet second argument list flow values 
compute data flow effects procedure calls nf flow 
expect points input flow value 
modify flow value output flow value 
iterate limit iter changed new value changed iter ancestor copy value ancestor meet copy value meet predecessors ancestor nf flow var changed changed copy value iter solve chapter writing data flow analyzers sharlit iteration solve available expressions avail solver expr set kill sets node base ir instruction value base expr set new value expr set new expr set mk universal return copy value src dst return dst src return meet int dst mk universal dst av expression flow expr kill sets dst av initial flow mk empty av kill flow kill sets dst flow map switch kind case ir op case ir ldc return new av expression case ir kill return new av kill case ir initial return new av initial case ir return identity chapter writing data flow analyzers sharlit parts sharlit specification 
example flow functions refer kill information expression kill sets 
flow graph nodes node base line tells sharlit node flow graph object type ir instruction 
sharlit doesn need know internal details type generate analyzer need name type declare variables 
flow values keywords value base new value copy value meet tell sharlit type flow values operations flow values operations called process solving dfa problem 
value base line indicate sharlit name type flow values declared 
keywords define operations 
allocate new flow value dfa solver calls code new value 
copy flow value src dst solver calls code copy value 
take meet set flow values pointed array pointers solver calls code meet 
copy value operation important duty tells solver source flow value src equal destination flow value dst copying 
returning indication destination changed copy termination test solver 
flow functions shows flow functions 
flow functions incoming flow value pointed variable 
code keyword flow computes output flow value leaving pointer 
available expressions dfas code modify incoming value directly outgoing value 
large complex values modification place avoids unnecessary copies 
flow function corresponding instruction type discussed 
av expression corresponds ir ldc ir op instructions 
function inserts expr expression number generated current node incoming flow value removes killed expressions value may change variable dst modified 
av kill corresponds instruction ir kill 
function removes killed expressions flow value 
chapter writing data flow analyzers sharlit av initial corresponds initial node ir initial 
function initializes output value empty set 
av identity corresponds ir instruction 
function uses incoming flow value outgoing value 
flow map provide mapping instructions flow functions 
part flow map function called control flow analysis establish correspondence flow functions instructions 
specification simplification rules sharlit generate data flow analyzer uses iteration 
procedure page shows iteration procedure differs somewhat previous chapter uses fewer flow variables 
eliminating flow variables interface generated analyzer user code hides flow variables section 
example flow function sees procedure reduce revisited version reduce added code sets var 
eliminated nodes connected identity path functions 
reduce empty list nodes traverse reverse order reverse reverse post order nf identity meet var predecessor header var header keep prepend ancestor nil keep ancestor keep predecessor return chapter writing data flow analyzers sharlit flow value 
suppose flow function associated node flow function equals input flow value flow function modifies directly reflect data flow effect flow function returns passed directly successor node stored away sharlit hides activities compiler writer 
compiler writers direct access flow variables sharlit eliminate flow variables save space 
elimination transparent compiler writer 
propagation values eliminated flow variables generated passed action routines show procedure 
eliminating variables demonstrated procedure procedure updated versions iterate reduce chapter 
procedure eliminates input variables computed fly traversing graph 
eliminate output flow variables procedure iterate uses flags var tells output flow variable meet tells perform meet compute input flow value flag meet set control flow analysis nodes successor immediately precede reverse post order 
meet set predecessors var flow function relating ancestor identity flow function 
happens determine ancestor meet var nodes meet performed compute input flow value nodes predecessor precede immediately reverse post order 
nodes marked 
important note nodes labelled need meet set predecessor precede reverse post order 
nodes successor meet var output flow variable 
output flow variable ancestor referenced repeated nodes ancestor var 
meet var computed control flow analysis 
chapter writing data flow analyzers sharlit fact generate efficient solvers sparse data flow evaluation graphs 
reason node may var ancestor node 
see examples node flags turned 
interesting consequence flags iterate flow variables necessary nodes linear sequences nodes basic blocks 
consider nodes unique successor unique predecessor calling flow function contains value 
equals passed flow function input bypassing copy operation meet operation copies 
flow equations need value variables eliminated 
nodes ancestors require output flow variables 
difficult determine times flow variable ancestor evaluating flow functions simplify matters insisting ancestors output flow variables 
path simplification rules path simplification builds path expressions process computes flow functions composition join kleene star flow functions 
operations directed compiler writer path simplification rules 
examples rules local analysis interval analysis 
obvious way tell analyzer combine flow functions times table approach 
example analyzer needs compose flow functions index special table flow functions find actions necessary composition 
tables simple specifying directly tedious complete specification composition table flow functions require entries 
sharlit generate complete table rules new kind flow function path function 
iteration path function behaves just flow function represents data flow effect path 
path simplification path function treated differently efficiency reasons modified directly reused 
show kinds rules describe conceptually 
rule code part executed computes new path function modifying path function left hand side rule 

create create new path data flow effect identity 
rule situations depicted 
analyzer inserts identify flow functions intention extending path chapter writing data flow analyzers sharlit see 
inserting identity data flow effects graph change solution data flow problem 

create create new path data flow effect flow function see 
replacement change solution data flow problem 
replacement analyzer create paths graph begins nodes flow function 
absorbs extend path data flow effect old composed modify represents data flow effect 

star replace path path represents data flow effect rule rules remove backedges see 

join replace path path represents data flow effect path 
rules resemble graph reductions ullman 
sharlit uses similar fashion 
example apply sequence rules com applying create rule identity path denoted square box inserted flow graph node flow function id applying create rule second kind create rule converts flow function path function chapter writing data flow analyzers sharlit pute path expression loop 
path created updated directly absorbs joins nodes 
update possible node subsequently removed reduce 
example reduce eliminates node flow function path simplifier update directly compute absorption applied directly node successors 
absorb analyzer copy copy performed rule form absorbs 
relating back procedure chapter see path computation steps application rules 
computing path expression applying absorb rule gf applying star rule applying join rule rule applies paths share common endpoints 
condition enforce path simplifier ancestors nodes see procedure chapter 
gf chapter writing data flow analyzers sharlit example applying path simplification rules show conceptually paths computed path simplification rules create absorb star 
part shows subgraph loop 
purposes data flow analysis subgraph equivalent introducing identity id doesn change data flow problem 
applying create gives graph apply absorb form composition gf apply star get fixed point gf 
apply absorb get data flow effect entire loop gf 
flow function stored header forest node originally associated node ancestor id id id gf gf gf copying paths node header tree ancestor 
successor necessary copy path function proceeding 
copy absorption applied 
fg fh chapter writing data flow analyzers sharlit means applying sequence path simplification rules 
conceptually applying rules reducing graph 
course graph isn really reduced expensive final path expression saved header forest 
local analysis summarizing extended basic blocks section shows data flow analyzer section efficient adding path simplification rules 
analyzer section inefficient iteration visits ir instruction 
simple analyzers serve prototypes experimenting new optimizations 
need efficiency arises add rules specification rules reduce number nodes iteration 
existing optimizers group instructions basic blocks reduce size flow graph therefor reducing amount iteration 
optimizers perform local analysis act computing data flow effect basic block instructions 
sharlit explicitly represent basic blocks achieves similar reduction path simplification 
shows computation data flow effects extended basic blocks ebb 
extended basic block tree flow graph nodes root node may predecessor internal nodes ebb predecessor 
applying create absorbs rules simplifier computes path functions represent data flow effect value exit leaves entrance exit flow functions ebb computed internal nodes longer needed iteration reduce removes 
simplifying extended basic blocks generated solver computes path expressions nodes longer referenced eliminated graph fed iterate procedure 
lack join rule means path summarized starts extended basic block 
cf bd chapter writing data flow analyzers sharlit extend example section code compute paths 
part declares path function av bb 
local part av bb declares defs kills variables computed simplification rules computation compute data flow effect path iteration 
simplified path flow graph associated av bb private defs kills 
rules define local variables code part rules 
absorb rule av bb absorbs av expression defines pointer variables rule applied variable points flow function type av bb variable flow function type av expression variable node associated av expression 
code part rule updates local analysis solve available expressions 
av bb local expr set defs expr set kills path kills defs simplifier av bb create av bb absorbs av expression expr set kill set kill sets dst kills kill set defs add expr defs kill set av bb absorbs av kill expr set kill set kill sets dst kills kill set defs kill set av bb absorbs av bb defs kills defs defs kills kills kills defs chapter writing data flow analyzers sharlit defs kills fields path function pointed directly represent composition path function pointed create absorbs rules join rules 
path simplifier finds paths internal ebb 
path simplifier attempts compute path expression node predecessor fail join rule necessary combine incoming paths 
nodes predecessor exactly root nodes ebb 
example path simplifier fail find path expression node remain graph start ebb 
simplification procedure reduce removes nodes internal ebb 
simplified graph represented list nodes solved iterate procedure solution consists flow values output nodes form boundaries ebb 
solution internal nodes apply procedure propagate procedure walks ebb topological order computing solution internal nodes form predecessor 
part propagation calls action routines perform optimizations flow value input output node 
action routines provided flow functions shown 
elimination summarizing loops previous example incomplete set path simplification rules 
rules express composition flow function single path function express join paths fixed point path 
incompleteness resulted path simplifier breaking flow graph ebb eliminating nodes 
flow function declaration functions name local local variables flow code uses flow value entry node code uses flow value exit node chapter writing data flow analyzers sharlit rules complete adding rules 
rules form joins fixed points flow functions 
completing set rules possible path simplifier summarize loops remove backedges 
situation path simplifier implements 
reducible flow graph removes back edges possible solve data flow problem iterating 
potentially quicker solve dfa problem importantly possible solve dfa problems may converge iteration descending chain condition 
irreducible graphs confronted irreducible graph example simplify paths albeit simplify cycles include header irreducible region 
procedure propagation finding solutions eliminated nodes procedure iterate procedure solves data flow problem nodes retained reduce 
procedure computes solution input output flow values nodes removed reduce 
flow values computed handed special optimizer routines making available having store 
optimization detect nf identity 
case meet avoided flow variables predecessors 
propagate new value meet nf identity copy value ancestor meet predecessors solved copy value flow var copy value chapter writing data flow analyzers sharlit example path simplifier simplifies irreducible region formed nodes find path expressions nodes simplifier find path expressions nodes paths node enhancing solver interval analysis av bb joins av bb expression set sum sum sum universal sum universal sum defs sum kills sum defs sum kills sum kills kills sum kills sum defs defs av bb star kills defs defs clear path simplifying ba de source ba source chapter writing data flow analyzers sharlit sparse data flow evaluation graphs path simplification versatile 
able local analysis interval analysis path simplification build sdfeg solve sparse data flow problems efficiently 
compute sdfeg necessary find paths consisting solely identity flow functions prune away flow graph nodes connected nodes sdfeg nodes identity paths 
sharlit identifies paths path simplification rules 
compares sdfeg computed sharlit computed choi 
sharlit sdfeg differs nodes represent edges choi sdfeg indicate nodes dashed circles 
nodes required way sharlit modify edges node graph replace edges edge ancestor node way connect sdfeg predecessor indirectly ancestors key point sdfeg efficient eliminate flow variables identity path functions 
procedures reduce propagate takes advantage property 
rules compute paths section introduces path simplification rules described informally 
section goes details discussing absorb rules save space rules doing sdfeg part sharlit specification reaching definitions problems preferably single variable 
flow functions defs id path predefined identity 
flow function defs corresponds nodes generate definitions identity types nodes 
flow function id path represents paths nodes identity indicated keyword identity 
indication versions propagate reduce eliminate nodes flow variables 
defs flow 
id path path identity simplifier id path create id path absorb identity id path join id path id path star chapter writing data flow analyzers sharlit procedures reduce step eval path compress path computations rules compute paths 
absorb rules save space path functions computed analyzers potentially take lot storage 
example path function av bb sets expressions just careful flow variables retain careful path functions retain 
traditional way dealing problem traditional optimizers group instructions basic block 
path function required basic block 
example simplification sdfeg show control flow graphs left original flow graph middle graph path simplification eliminated nodes unshaded right sdfeg obtained applying choi algorithm 
graphs abbreviations ip stands path function id path defined 
nodes identity flow function 
middle graph path simplifier simplified paths identity id paths 
shaded nodes retained reduce 
unshaded eliminated nodes ip paths ancestors 
special note path path source 
reached unique ancestor id path reached manner ancestor source 
sdfeg differs nodes represent edges choi sdfeg indicate nodes dashed circles 
wish avoid modification edge information flow graph operation may expensive 
edges represented efficiently setting ancestor source exit source ip ip ip exit source exit ip ip ip ip chapter writing data flow analyzers sharlit sharlit primary mechanism save space absorb rules counting flow functions 
see absorption saves space see 
assume rules create absorb absorb absorb absorb apply rules create followed absorb compute path function corresponding path expression apply absorb directly giving path expression ab 
reuse know node won need path function reduce remove 
node removed node corresponding path expression ab reused ab may compute path expression successor 
simplifier copy continuing node decide reuse path function keep count count successors path function 
composing path function successor count directly absorb rule count copied count decremented copy directly absorption 
add successor path function path simplification connect nodes ancestors count incremented 
exceptions counting 
path functions associated loop headers treated infinite counts 
necessary eliminated reduce 
identity flow functions treated similarly 
identity flow functions local variables allocated statically shared 
reusing flow functions sequences node computing path expressions know eliminated reduce reuse data structure represent flow function 
absorption 
result absorption appears 
indicate eliminated hashing 
reduce step set new flow nil indicate path function reused 
equal path expression ab reused successors 
fact copied shown 
path function absorb giving graph 
ab ab abc ab ab ab chapter writing data flow analyzers sharlit rules path computation procedures simplify eval path compress builds path expressions abstractly operators 
show sharlit turns process computing path expressions invocation rules 
define functions corresponding path operators 
compose return indicate failure 
create new path function representing data flow effect creation occur applying rules create sequence create followed create exactly possibilities possible rules specification return return path function apply absorb possible go case 
return compose compose rule sequence exists 

join return copy path doing apply join join return successful return 
star invoke rule join rule specification return functions interpret path computation functions generated table lookups 
example compose index composition table determine action take 
rule sets small sharlit generates tables exhaustive search rule sequences 
summary chapter shown solve dfa problems sharlit sharlit generate solvers problems 
chief benefit sharlit compiler writer simple model data flow analysis model instruction node data flow information computed available node 
sharlit space time efficient manner 
id id compose id id compose join pq compose star chapter writing data flow analyzers sharlit sharlit dfa specifications extensible 
easy add flow functions simplification rules 
sharlit takes care incorporating analyzer 
extensibility easy prototype data flow analyzers 
start straightforward slow analyzer local analysis 
add rules analyzer faster 
furthermore add new rules reflect changes intermediate representation 
sharlit integrates powerful data flow analysis techniques 
generate dataflow analyzers perform loop analysis programs generate sparse data flow evaluation graphs 
chapter architecture modular flexible optimizers procedure table architecture modular flexible optimizers writing large complicated software programmers commonly decompose software smaller manageable modules 
similarly decompose large complicated optimizer set smaller manageable data flow analyzers 
previous chapters show write specifications data flow analyzers called solvers sharlit generates descriptions 
chapter describes software architecture sharlit offers building optimizers 
architecture defines interfaces control flow graphs solvers 
includes proposed mechanism compose generated solvers complex ones 
abstractions ability combine solvers offer new method write optimizers modular flexible 
optimizers consists distinct phases correspond roughly individual optimizations 
architecture promotes modularity level finer phase level build optimizations chains products solvers 
chain constituent solvers operate sequentially flow graph 
product constituent solvers cooperate solve complex dfa problem 
chain multiply solvers sharlit architecture external interface generated solvers flow graph interface supports chaining multiplying 
standardizing interfaces constrains solvers depend contributing modularity 
interfaces restrict power sharlit 
contrary show products powerful showing build static single assignment graph program product solvers 
sharlit architecture lends flexibility optimizer reordering adding solvers easy solvers modify control flow graphs cfgs 
solvers delete nodes 
chapter architecture modular flexible optimizers add new information node 
add new nodes new kinds instructions 
long changes facilities architecture easy solver operate modified flow graph 
augment flow functions corresponding new type instructions inserted graph rest chapter major sections 
discusses major abstractions form optimizer architecture 
second shows combine solvers 
data flow analyzers control flow graphs sharlit provides main abstractions buildings optimizers solvers control flow graph 
subsections define abstractions describing external interfaces implemented classes 
interfaces tell functions abstractions provide functions abstractions sharlit expect compiler writer 
data flow analyzers solvers solver consists classes sharlit builds subclassing predefined classes df form solvers nc form classes hold information nodes 
example available expressions problem sharlit generates classes avail av expr av identity av bb 
class avail subclass df contain functions responsible solving dfa problem 
classes subclass nc wraps object related information routines kind node information local part node specification routines flow function action routines 
class df implements generic solver template contains functions basic dfa problems 
functions summarized table 
class df contains slots virtual functions lingo customized solver 
build avail sharlit fills slots functions specific availability expressions problem 
slots template described table 
functions generic solver help combine solvers 
describe functions section 
described dfa problem avail example turned description solver object installed part optimizer solve available expressions calling function avail solve flow graph solve functions called 
member function init initializes analyzer object invokes control flow analysis invokes member functions correspond step chapter architecture modular flexible optimizers member function description df solve lim apply procedures 
code outlines steps solve invokes solve cfg int lim init simplify rg reduce iterate rg lim propagate rg df init initialize solver operate graph invokes controlflow analysis graph initialize data structures solve dfa problem calls df flow map assign flow function node 
df simplify simplify paths graph sharlit specification simplification rules reduced graph equals graph rg df reduce information computed df simplify build reduced graph rg form list nodes 
sharlit specification path simplification rules graph rg equals graph df iterate rg lim evaluate nodes flow functions reaching fixpoint graph rg 
argument lim bounds number iteration 
df propagate rg pass graph compute data flow solution nodes graph rg 
solutions computed pass action routines perform optimization 
df value return flow value solution dfa problem entry node df value return flow value exit node df alloc var indicate flow variable stored hold flow value entry df alloc var indicate flow variable stored hold flow value exit table functions provided sharlit solving dfa problems table describes member functions analyzer class perform data flow analysis 
symbol df denotes name analyzer class 
chapter architecture modular flexible optimizers dfa simplify path simplification reduce graph reduction iterate iteration propagate propagation 
chapter describes steps detail 
generic solver virtual functions interact way 
initialization df init calls nc flow map assign node type flow function node 
path simplification simplify calls df create create paths df times extend paths df join join paths 
path manipulation functions constructed path simplification rules solver specification 
iteration propagation data flow effect node computed calling nc flow node type class associated propagation propagate computes flow value represents solution dfa problem node passes action routines nc nc 
member function description df create create empty path label df times extend path flow function second argument flow function path function 
df join join paths flow function join converts path 
nc flow evaluate flow function passing node input flow value flow function modifies reflect data flow effect node nc perform optimization node input flow value nc perform optimization node output flow value df flow map returns flow function represented class ff 
sharlit associates returned function node table functions generated sharlit functions differ table sharlit generates parts analyzer specification 
functions table calls functions solve dfa problems 
class nc represent flow function classes 
sharlit generates class flow function analyzer specification 
chapter architecture modular flexible optimizers technique generating solution immediately action routines serves primary means optimization occurs 
implementing optimizations manner frees task storing flow values part flow graph lets sharlit decide store flow values flow values omit evaluation strategy compute missing flow values stored ones 
section describes elimination flow variables 
ways access flow values 
action routines solver access flow values solver combined 
describe section 
second solver provides functions called value value access solution dfa problem outside context propagation 
sharlit stores flow values nodes graph calling value value requires general meet operations evaluations flow functions compute desired flow value flow variables stored cfg depicted 
access function called repeatedly node prudent call alloc var alloc var tell sharlit maintain stored variable entry exit subsequent calls value value fetch directly stored flow variable avoiding unnecessary repetition meets flow function evaluations 
control flow graphs key goal sharlit flow graph abstraction restrict choices internal representation available compiler writers 
internal representation long representations offer interface described 
sharlit provides default computing data flow solution node shows general computation meets flow function evaluations necessary compute solution node flow graph 
compute flow value entry node necessary take meet node evaluate flow functions chapter architecture modular flexible optimizers flow graph implementation class fg 
class serves template functions replaced class derivation 
compiler example represent programs syntax trees supplies subclass fg solvers 
flow graph interface delineates border views internal representation 
side generic solver views cfg graph structure considering internal structure node 
view provided class fg 
class contains edge information functions compute information required path simplification data flow analysis 
side code supplied compiler writer customize generic solver flow functions flow maps path simplification rules necessarily manipulate internal structure nodes code depends program operations 
code customizes solver supply class called 
class field holds unique non negative number called unique 
add node graph class fg assigns unique number node 
solvers unique number index tables information dataflow information node type objects 
example solver store ancestor see chapter array node pointers indexed unique identifier unique number storing pointers associate information node advantages 
clutter nodes fields 
solvers operate flow graph nodes knowing increasing modularity flexibility 
compiler writers unique number associate information node 
free add fields flow graph nodes deriving base class 
example build flow graph quads making quad data structure subclass 
declares nodes having type instruction sharlit assumes previously defined instruction subclass 
solve dfa problems build flow graph functions described table 
register node flow graph enter connect directed edge node node call link 
indicate source sink flow graph calling member function set 
solve dfa problems graph giving argument solver 
propagation step solver action functions add remove nodes push remove 
changes go effect fg update called 
delay necessary may unsafe change flow graph solver operating 
table shows functions fg generic solver calls 
finds suc chapter architecture modular flexible optimizers cessors predecessors node call nodes prev nodes 
functions table control flow analysis 
control flow analysis apply solver flow graph apply control flow analysis cfa graph 
cfa derives information flow graph information operation solvers 
path simplification solver examines deeply nested loops deeply nested 
cfa discover loop structure graph 
reduction iteration propagation solver examines nodes reverse post order 
cfa discover order 
graph loop structure reverse post ordering depends nodes connected depend particular solver particular dfa problem 
natural perform cfa flow graph class fg replicating analysis solver 
cfa invoked calling function fg analyze 
result analysis fetched calling functions fg headers returns list loop headers fg body returns loop header argument body loop list nodes reverse post order fg returns reverse post ordering function description fg enter add node control flow graph 
entering say registered 
fg link add edge node node fg set source sink identify source sink flow graph previous registered nodes source sink 
fg update update flow graph changes logged functions 
fg push log insertion node front node graph 
predecessors predecessors unique successor fg remove log removal node graph 
table functions building modifying control flow graph chapter architecture modular flexible optimizers entire flow graph 
reducible flow graph loop unique entry node called header dominates node loop 
call body returns list nodes loop headed header 
list inner loops represented headers 
example headers body returns see section 
irreducible flow graph loops called improper entry points 
entry points designated loop header dominate nodes loop 
section shows solver handles irreducible flow graphs 
solvers operate forward backward flow graph cfa technique discussed applicable direction returns sets information 
flag argument dir tells fg headers fg body set return 
default cfa algorithm provided fg tarjan algorithm testing reducibility flow graph closely related algorithm graham wegman 
addition finding loop headers tarjan algorithm computes ordering nodes apply ullman transformations graph 
description fg nodes returns vector nodes follow node fg prev nodes returns vector nodes precede node fg analyze performs updates control flow analysis 
call analyze performs control flow analysis described procedure 
subsequent calls updates control flow information respond modifications graph 
fg headers dir dir returns list headers forward flow graph ordered inner loops appearing outer loops 
dir returns headers backward flow graph fg body dir dir returns loop header forward flow graph 
dir returns information backward flow graph table functions generic solver access flow graph routines gives view flow graph solver 
routines facilitate access edges 
third performs control flow analysis 
routines return information computed analysis 
chapter architecture modular flexible optimizers cation order turn reducible graph irreducible graph single node providing convenient test reducibility 
modified tarjan algorithm computes loop bodies application ordering 
procedure shows main analysis function fg cfa called fg analyze 
fg cfa steps 
outline steps context reducible flow graphs 
readers interested aspect controlflow analysis refer literature 
see path simplifier operates see section 
step df dfs performs depth search assigns numbers node preorder postorder correspond respectively orderings nodes pre order post order traversal depth spanning tree graph 
numbers detect back edges compute reverse post ordering 
loop back edge edge flow graph target dominates source 
node dominator lie path root node back edge connect nodes path 
detect edges observing dfs visits node nodes path root node stacked node path represented activation dfs call stack 
dfs assigns preorder entry assigns postorder exit edge back edge node non zero pre order zero postorder 
second step sorts back edges nesting loops back edges inner loops appear back edges outer loop 
sort condition consider back edges 
appears preorder preorder 
condition gives desired loop order loop loop formed contains loop header dominate header dfs visit third step sorted back edges compute reach set set nodes dominated loop header reach loop header loop back edge 
visualize step generating set derived graphs 
computing set innermost loop replaces loop header 
replacement accomplished setting reach uses skip replaced loop bodies 
reach computation repeated loop loops 
point remaining nodes loop body loop headed source node 
see example application fg cfa 
important recognize fg reach resembles depth traversal chapter architecture modular flexible optimizers procedure control flow analysis detail pseudo code expands control flow analysis procedure 
step computes depth spanning tree represented sets numbers preorder postorder 
part computation back edges 
back edges sorted direct reach computation see text 
fg cfa int pre post number nodes compute depth spanning tree dfs source node pre post sort back edges perform reach computation back edges append headers list reach append source headers list put remaining nodes loop body loop body source fg dfs int pre int post preorder pre pre pre successors preorder visited dfs pre post postorder back edge add list back edges postorder post post post append list fg reach reach postorder mark loop body improper predecessors reach add loop body chapter architecture modular flexible optimizers source example control flow analysis shows original flow graph derived graphs fg reach processed loops headed table shows information computed controlflow analysis 
pre post loop bodies source source source original flow graph derived graph second derived graph chapter architecture modular flexible optimizers topological sort follows predecessors successors 
resemblance fg reach inserts nodes loop body topological order desired path simplification 
combining data flow analyzers generating solver directly sharlit specification build solver chaining multiplying solvers 
chain solvers applies flow graph updates control flow information accommodate changes applies solver updated graph 
main benefit chains allow build optimizations composition simpler optimizations represented example solvers 
product solvers interleaves steps solver path simplification reduction iteration propagation 
flow functions solvers depend flow values solvers 
action routines solutions computed solvers change program 
main benefits products allow build complicated solvers simpler solvers cooperate solve dfa problem build optimizations solution dfa problem drive code transformation 
chains chains implemented part sharlit build optimizations 
think optimizations chain solvers composition optimizations 
changes flow graph adding deleting nodes invalidate information computed cfa 
sharlit update cfa information long changes graph performed functions table 
suppose solver compatible solver introduces new kinds instructions flow graph understand 
output palatable adding new flow functions new kinds instructions 
shows create chain outlines solve routine 
calls solve constituents solvers calls fg update function updates cfa information header list loop bodies reverse post ordered list 
done traversal reverse post ordered list loop bodies 
nodes inserted front node inserted front loop bodies reverse post ordering 
node inserted header replaces chapter architecture modular flexible optimizers headers list prepended loop body 
general changes flow graph invalidate solution dfa problems 
solution computed original flow graph account modifications 
chained solver needs careful data flow information computed previous solvers 
products products build solvers complex dfa problem combining simple solvers 
products introduce new concepts product flow values interacting flow functions 
sections give example multiplying solvers desirable explain new concepts show phase product solver operate 
particular show iteration propagation interleaves evaluations flow functions solvers product 
example constant propagation consider constant propagation section procedure 
simplicity formulate dfa problem variables dfa problem flow value set bindings defines values entrance exit node 
create output flow value input flow value flow function instruction extract value add value store result back disadvantage dfa problem flow value stored carry creating chain declaration declares chain solvers 
procedure solve outlines occurs inside chain 
creating chain solve fg int lim solve lim update solve lim update 
solve lim chapter architecture modular flexible optimizers value 
reduce space time sparse data flow evaluation graphs pointed section sparse data flow problems dfa problem nodes identity flow functions sdfeg stores fewer flow variables traditional formulation 
furthermore storage bindings decoupled 
shows flow graph 
sdfeg variable contains kinds nodes 
kind nodes modify flow values node binds new values node performs meet binds new value second kind nodes required kind node hold flow values meet operation node 
similarly sdfeg variable contains kinds nodes corresponding edges sdfeg represent identity paths flow graph 
store bindings nodes nodes 
key advantage product lets solvers communicate iteration 
multiplying constant propagation original flow graph shown left sdfeg variable middle sdfeg variable left 
variable sdfeg described section contains nodes generate new value variable meets 
dotted arrows communicate values 
solid arrows communicate values graph branch return return return original flow graph sdfeg sdfeg chapter architecture modular flexible optimizers example communication occurs node sdfeg node sdfeg 
determine new values flow functions nodes obtain values sdfeg 
shows flow information dashed arrows 
communication occurs product flow values cartesian products sdfeg flow values interleaved evaluation flow functions different 
nodes require cross communication assigned interacting flow functions 
table shows actions taken iterator steps product solver 
iterator visits nodes reverse post order node evaluate flow functions 
interacting nodes product flow value reconstructed 
flow functions obtain flow value sdfeg extracting product flow value 
reconstruction occurs propagation action routines access flow values 
action iterator input flow value output flow value eval sdfeg node 
eval sdfeg node reconstruct input product flow value eval sdfeg node eval sdfeg node eval sdfeg node reconstruct input product flow value eval sdfeg node eval sdfeg node eval sdfeg node eval sdfeg node eval sdfeg node table iteration step product solver table shows actions taken iterator solver formed multiplying 
dash column indicates variable referenced action 
question mark indicates value unknown 
interacting flow functions assigned node node iterator reconstructs input flow product flow value 
chapter architecture modular flexible optimizers product flow values product specifications imagine product flow value cartesian product flow values products component solvers 
components solvers called slices 
sharlit expects compiler writer supply declaration product flow values restrict represented 
example represented list lookup table constant propagator 
product solver extracts components product flow value passes components slices 
extraction functions depend type product flow value sharlit expects compiler writer provide extraction functions 
slice extraction function add deriving solver class defines parts slice 
adding different extractors solver reuse solver different products 
product flow values associated functions allocate copy take meet provided sharlit product specification 
specification just normal solver specification containing new value copy value meet excluding flow map flow functions action routines simplifier rules 
product specification creates empty product object turn working solver adding slices 
modifying non modifying solvers product slices slice permitted modify flow graph 
need distinguish modifying non modifying solvers 
modifying solver action routines don modify flow graph 
non modifying solvers action routines 
functions generic solver supporting products products interleave phases slices provide functions give access finer details phase 
providing just single iteration function operates graph refine iteration functions operate individual nodes 
refine propagation similar manner 
described procedure procedure function iterate propagate consists loops nests iteration inner loop operates single node 
expose inner loop body functions iterate iterate propagate propagate 
table shows functions 
intuitively think functions computing input flow value 
reconstruct product flow value 
think functions computing data flow effects 
functions permit paraphrase df iterate df propagate shown procedure 
corresponding functions product solver structure calls replaced chapter architecture modular flexible optimizers series calls slices calls slices 
give details phases product solver 
initialization suppose product solver solvers phase initialization 
straightforward consists calls initialization phase component solvers show procedure page 
initialization check node assigned interacting flow function 
ll explain restriction discuss iterator 
member function description df extract returns component product flow value corresponds slice 
important note extract returns pointer component changes component reflected product flow value 
df iterate compute input flow value path starts exit node ancestor exit node nil path starts entrance ends exit flow value returned copying flow variable pointed 
df iterate compute output flow value node argument points input flow value argument points product flow value flow function solver outside product null pointer 
df propagate similar df iterate doesn consider ancestors computed input flow value fed action routine df propagate df iterate call action routine propagation original flow function assigned flow function assigned node path simplifier 
table functions generic solver supporting products chapter architecture modular flexible optimizers procedure paraphrase df iterate df propagate 
df iterate list lim int changed int iter changed iterate ancestor iterate df propagate rpo propagate propagate procedure initialization phase product solver init init 
init check node interacting flow function chapter architecture modular flexible optimizers path simplification solvers product interact 
solvers interact adjust ensure iterator reconstruct input flow value interacting flow path functions 
danger lies solver deems node interacting solver eliminates predecessor interacting node necessary computing input flow value elimination occur know required add simplify node flag indicate iterator needs reconstructs input flow value encounters node code flag tells simplifier retain predecessors interacting flow functions procedure sketches simplifier look new flag named needs input 
important see flag hamper simplification node retained flow function participate simplification 
interacting flow path functions absorbed paths 
sharlit enforces restriction disallowing rules absorbing interacting flow functions 
restriction necessary paths represented noting ancestor node 
predecessor connected ancestor identity path 
procedure sketch new simplify node simplify region df simplify node int needs input needs input keep predecessors code old df simply node see procedure cp simplify region body keep simplify node interacting keep simplify node interacting chapter architecture modular flexible optimizers information flows final node information flows 
admitting interacting flow functions inside path mean information flows path ends 
complicate path representation 
procedure shows product simplifier region 
shown chapter simplify region called loop graph 
product simplifier invokes slices node passing flag indicate interacting node 
solvers keeps node indicated return value product solver keeps node 
reduction reduction takes result simplification produces smaller graph apply iteration 
takes nodes marked kept back propagates keep flag reverse topological ordering ignoring back edges 
propagating keep flag back edges taken care simplifier finds headers kept 
node kept may reduced graph subject elimination due identity path optimization 
procedure shows reducer product solver omitted optimization procedure reducer product solver cp reduce empty list 
reverse rpo loop header prepend ancestor keep ancestor keep prepend keep order solver list interacting flow come ancestor keep ancestor return chapter architecture modular flexible optimizers identity paths simplify exposition 
details identity path optimization see chapter 
generic reducer reducer generates list nodes ordered reverse postorder iteration solve dfa problem 
generic solver reducer associates list slices nodes list list slices indicate node solvers reduced graph 
referring slices sdfeg list slices node sdfeg list node 
iteration iterator shown procedure page product iterator solves dfa problem reduced graph evaluating flow functions dictated list generated reducer 
generic iterator particular node product iterator may execute flow function 
ostensibly product solver uses product flow values iterator uses product flow values encounters interacting flow functions 
non interacting nodes components product values distributed slices 
particular node may flow variable slice 
interacting flow functions need entire flow value iterator gather information 
process depicted function reconstruct procedure 
previously simplifier ensured solver maintains information generate component product flow value 
usually means predecessors interacting node remain reduced graph 
product iterator encounters interacting node evaluate interacting flow functions 
requirement artifact flow functions compute output input 
transform input flow value directly output flow value 
transformation saves space time sharlit doesn need create new flow value flow function evaluation 
product iterator evaluates non interacting flow functions may modify product flow value components 
reconstructed flow value longer represent valid input interacting flow functions 
furthermore validity guaranteed node interacting flow function 
propagation procedure shows product propagator 
propagator pass graph computing flow value node flow graph 
case product flow values product flow values component represents solution dfa problem slice 
chapter architecture modular flexible optimizers procedure reconstruction product flow value iterator cp reconstruct iterate extract iterate extract 
cp iterate list lim int changed int iter iterate init changed changed interacting di changed iterate node extract changed iterate node extract 
di assigned interacting function node 
reconstruct ancestor changed iterate node extract changed iterate node extract iter chapter architecture modular flexible optimizers iteration propagator handle interacting nodes specially nodes propagator evaluate interacting flow functions 
iteration propagator builds product flow value node 
passes product flow value action routines perform optimizations 
summary chapter shown sharlit architecture writing optimizers promote modularity flexibility 
modularity achieved writing optimizers series data flow analyzers solvers 
current version optimizer architecture chain solvers multiplying solvers fully implemented 
flexibility achieved dependences solvers controlled 
reorder easily reorder optimizations conventionally written optimizers 
key feature architecture objects defined slots virtual functions 
defaults overridden customize solvers flow graphs 
phases initializer simplifier reducer iterator propagator solvers overridden 
example replace simplifier reducer ones efficient particular dfa problem 
procedure product propagator cp propagate dk refers unique solver assigned interacting flow function 
cp propagate rpo propagate extract propagate extract 
propagate extract call propagate solvers chapter prototype optimizer procedure table procedure prototype optimizer chapter gives example optimizer organized software architecture espoused chapter 
optimizer operates outputs suif programs 
describe scalar optimizations demonstrating sharlit applicable wide variety dfa problems code transformations 
show architecture optimizer modular design flexible extensible optimizations connect effective generating code 
delve details transformations code motion induction variable rewrite 
code motion moves computations frequently executed regions program earlier frequently executed regions 
consists data flow analysis steps traditional bit vector techniques 
shows data flow analysis compute directly code move move 
demonstrate flexibility turn code motion algorithm strength reducer 
induction variables rewrite ivr example code transformation performed symbolic analysis extensive path simplification 
ivr demonstrate sharlit implementing code transformation thought dfa problem 
describing suif optimizer try keep explanations optimizations independent specifics suif 
exception section suif easy comprehend 
suif explained chapter 
structure prototype optimizer shows structure suif optimizer 
unshaded square boxes represent sets dfa solvers correspond optimization 
encourage prototyping chapter prototype optimizer experimentation easy reorder add data flow analyzers 
solvers take input modify control flow graph cfg 
solver adds new kinds instructions flow graph new instructions acceptable solvers adding new flow functions suggested previous chapter 
shaded box represent special phases 
graph constructor builds cfg calling functions structure suif optimizer envisage optimizer set data flow analyzers generated sharlit operate central program representation control flow graph 
diagram groups analyzers group corresponds optimization register allocation code motion 
shaded boxes represents special phases 
graph constructor uses facilities provided sharlit build control flow graph 
code generator implemented sharlit analyzer performs cleanup writes code 
suif input program suif output program constant propagation dead code elimination suif code generator control flow graph value numbering availability partial availability placement possible recurrence detection graph constructor register allocation code motion liveness analysis coloring chapter prototype optimizer flow graph interface 
special phase code generator cleans cfg writes suif program 
clean routine takes form sharlit solver 
optimizer reads suif program procedure time translates procedure cfg 
sequence phases applied cfg 
phases implement analysis transformations code motion suif optimizer moves code eliminating partial redundancies technique proposed morel renvoise refined joshi dhamdhere chow 
approaches eliminating partial redundancy offer important advantage perform global common subexpression elimination loop invariant code motion strength reduction simultaneously 
code motion consists phases solve available partially available anticipated expressions 
information serves input placement phase data flow analysis problem solves expressions delete expressions insert insert 
implemented analyses sharlit 
register allocation priority coloring approach implemented chow 
optimization consists data flow analysis steps compute live ranges followed coloring routine builds interference graph colors 
coloring routine fit data flow model write sharlit 
reaching definitions optimizer applies standard bit vector reaching definitions problem annotates variable set definitions reach 
suif parallelization phases information 
constant propagation folding phase uses kildall technique determines instruction flow graph set variables constant values 
phase replaces instruction computes constant value instruction loads constant 
copy propagation phase similar constant propagation folding tracks assignments form program variables 
call assignment available instruction procedure executes assignment path leading instruction 
assignment available instruction copy propagator substitutes dead store elimination phase performs liveness analysis eliminates instructions computes values 
induction variable rewrite section explains optimization detail 
chapter prototype optimizer flow graph nodes discussed chapter flow graph nodes subclass class 
suif optimizer add fields show table 
data flow information stored node information stored flow variables solvers 
program code associated node held field instruction 
field points subclasses instruction base class provided suif libraries 
example subclasses hold suif instructions 
way modify graph define new subclasses instantiations inserted flow graph 
insert regular suif instructions 
suif instructions may suit optimizations extension subclasses gives flexibility 
strength reduction example manipulates linear combination variables 
appropriate replace instructions equivalent linear combinations 
place machine instructions internal representation wish experiment machine dependences optimizations 
code motion store expression number node 
expression number represents value numbers computed instructions participate code motion 
section discusses value numbers defined 
code motion code motion algorithm elimination partial redundancies epr operates solving dfa problems suited implementation sharlit 
sections discuss steps involved eliminating partial redundancies sketch implement sharlit 
field description kind tag flow map conjunction instruction opcode determine flow function assign node 
instruction pointer instruction suif instruction internal instruction defined solvers 
expr expression number code motion computed value numbering 
table fields flow graph node class chapter prototype optimizer suppose node evaluates expression expression redundant execution path contains execution variables depends modified execution expression partially redundant path meeting condition 
illustrate epr works example 
expression node redundant 
remove redundancy node save temporary value node replace expression node partially redundant available incoming path paths 
remove partial redundancy insert instance path available 
insertion renders redundant node removed 
especially interesting see eliminating partial redundancy move loop invariant expressions loops 
expression partially redundant available back edge outside loop 
eliminate partial redundancy insert tx just loop replace inside loop effect move expression loop 
value numbering step code motion value numbering process identifies movable expressions 
value numbering gives syntactically equivalent expression modulo commutativity different node register numbers unique expression number index bit vectors expressions 
bit vectors flow values epr solvers 
suif instructions left expression number corresponding suif instructions right ldc nr ldc nr add nr pr pr add nr pr pr instructions row compute expression pr pr 
give unique number syntactically equivalent expressions value numbering determine arbitrary expressions equivalent 
speed time consuming process hashing 
compute hash value confused unique expression number expression hash values subexpressions 
expressions different hash values different 
expressions hash numbers recursively test equivalence subexpressions 
hashing reduces number explicit expression comparisons 
value numbering resembles constant propagator described section resembles interpretation instructions 
case flow values associate chapter prototype optimizer redundancy partial redundancy tx tx tx tx chapter prototype optimizer node register expression computed register 
associates pseudo register unique atomic expression 
value numbering maps suif instruction operations hash values commutative suif instructions mapped commutative operations hash values 
value numbering differs constant propagation meet operator resets flow values meet operator initialize flow value null binding contains associations node registers 
value numbering takes pass flow graph 
expressions kill vectors computed 
pseudo register kill vector set expressions value depends value pseudo register 
write pseudo register kills expression set sense re evaluating write may yield different value evaluation write 
availability partial availability steps epr solve classical dfa problems iteratively 
solutions dfa problems serve input step placement phase decides expressions moved 
define availability chapter define partial availability follows 
expression partially available node path source evaluated value remains re evaluated express problems solving set bit vector equations partial availability availability represents expression field expr node represents set expressions killed assignments node sharlit specification problems similar available expressions chapter 
flow functions implement essentially equations output flow variable suif instruction gets turned pav source pav pav succ pav en killed pav av source av av succ av en killed av en killed av pav chapter prototype optimizer flow functions 
meet operators compute product sum availability partial availability respectively 
path simplification local analysis 
flow function basic block form expressed equation en set single expressions 
solvers modular self contained suif data structures expression table 
placement insert expressions section gives informal explanation pre algorithm 
explain solve dfa problem determine computations move compute 
section discusses details implementation dfa problem sharlit 
ll omit proofs authors covered 
morel renvoise originators pre defined dfa problem called anticipated expressions leads formulation code motion 
suppose node computes expression anticipated node execution path contains form computing yields result computing sufficient condition nodes modify variables depends 
incidentally anticipated nodes definition leads naturally set equations solve anticipated expressions imagine copies expression floating reverse control flow source paths anticipated 
paths anticipate join floating replicates copy floats adjoining path 
floating expressions meet merge continuing 
eventually floating reach source reach points exits entrances nodes progress blocked nodes anticipate reached entrance node anticipated exit predecessor reached exit anticipated entrance 
points floating stops marks frontier anticipation 
insert expression frontier 
insertions safe anticipation guarantees introduce nodes evaluating cause errors 
source 
ant en killed ant ant ant succ ant sink ant chapter prototype optimizer insertions render original computation redundant node redundant deleted 
method doesn guarantee inserted expressions partially redundant situation depicted shading indicates nodes anticipate insertions exit node partially redundant entrance node deficiency code motion caused critical edges edges connect node successor node predecessor edges 
converting critical edge illustrated node moves insertion node partial redundancy 
suif optimizer doesn convert critical edges nodes tries important case loops 
optimizer inserts loop shown converting critical edge connects loop pretest loop header providing place hold code moves loop 
critical edges handled placement dfa problem 
critical edges converted nodes method finding insertion points optimal sense execution path contains original number computations expression set safe insertions requires just evaluations optimal set insertions 
particular insertions followed deletions newly redundant expressions move code loops 
optimality defined guarantee optimized programs run faster 
fact epr eager tends place expressions far paths anticipation possible lengthening live ranges causing register allocator insert spills slowing program 
reformulation anticipated expression call placement placement possible limits unnecessary expansion live ranges 
placement problem shown 
striking differences placement anticipation presence factors discuss 
compute sets called insert delete computed placement information follows pav pp source pp pav en killed pp pp pp succ pp sink pp av pred chapter prototype optimizer partially redundant insertions occur consider expressions nodes shaded indicate anticipated exits 
chapter prototype optimizer deletion occurs expression floats away expression node deleted condition indicates inserted redundant factor ensures fact node computes deletion moot 
expression inserted frontier anticipation placement 
factor ensures frontiers exist entrance exit node entrance node exits predecessors 
words situation happen node situation happen predecessor available 
insertions occur exits nodes placement possible exits possible entrance 
expression available skip insertion computed value 
advantage restriction frontiers tell node frontier expression checking needing check data flow information predecessors successors 
shaded nodes nodes shaded 
insertions occur exits nodes example illustrates advantage factor role suppressing partial redundant insertions critical edges 
factor equation stops unnecessary code motion expansion live ranges 
partially available paths leading computes moving improve run time 
implementation placement sharlit placement problems availability partial availability solved iteratively path simplification perform local analysis 
placement unique peculiarities sharlit handle specially 
placement backwards dfa problem contains bidirectional computations 
second placement uses solutions forward dfa problems available partially available expressions reverse 
data flow problems unidirectional 
equations show forward backward information flow input output flow value node depends output input flow values predecessors successors output input flow value depends input output flow value 
predominantly backwards placement exhibits bidirectionality factor factor forward information delete en pp insert pp pp av pp en pp pp pp pp av pp pp pp ant pav pp chapter prototype optimizer flow input node depends output predecessors 
sharlit automatically performs products compute sharlit product flow functions compute explicitly 
sharlit doesn know information flow may delete flow variables required computing treating placement backwards problem sharlit eliminates output flow variables 
tell sharlit keep variables necessary compute need output flow variables nodes 
quite true 
suppose successor node show fact lets remove term equation successors fork points 
indicate flow variable needed fork points calling df alloc var flow map assign flow functions fork points 
vexing peculiarity placement availability partial availability direction opposite direction availability flow values generated 
df value df value expensive repeated meets flow function evaluations needed compute flow values problems 
expense trade time space tell sharlit allocate flow variable node availability partial availability 
code generation sets insert delete interpreted action routines inserting deleting expressions 
expression set insert added graph new node zeroed instruction field 
code generation phase turns expressions suif instructions 
deletions occur action routines calls function fg remove 
strength reduction strength reduction turns affine expressions induction variables replacing multiplication operations expensive additions 
suppose loop affine expression induction variable initial value step strength reduction turns induction variable initial value step strength reduction general handle complex expressions 
deal affine expressions coefficients variables loop constants 
replace expensive operations exponentiations multiplications example 
comprehensive discussion strength reduction see allen cocke 
suif optimizer uses restricted form strength reduction operates affine expressions coefficients constants 
restricted form sufficient pp pp pp pp pp pp pp chapter prototype optimizer improving programs major opportunities strength reduction address computations arising array 
address computations usually affine expressions 
reducer closely related epr code motion algorithm discussed 
joshi dhamdhere pointed epr perform strength reduction candidates expressions eligible strength reduction defined increments induction variables interpreted having effect candidates 
illustrated loop candidate increment ii effect candidates candidate considered partially redundant loop 
epr moves loop 
liveness phase determines candidates live dependent node containing ii 
temporaries holding candidate example temporary incremented 
suif optimizer strength reducer constructed grafting new value numbering phase adding new flow functions increments dfa problems epr algorithm 
partial availability elimination strength reduction ii tt ii chapter prototype optimizer value numbering suif optimizer restricts candidates affine combinations form increments form pseudo registers integer constants candidates increments determined modified version value numbering phase section 
expression number candidate associated linear combination 
scans instructions value numbering combines linear combinations 
suppose encounters suif instruction add nr nr nr node registers nr nr bound candidates 
candidates added form candidate nr 
new candidate associated instruction expression number 
suppose value numbering encounters suif instruction cpy pr nr nr bound candidate 
instruction regarded increment linear combination associated nr form pr information collected described section value numbering computes set called candidates candidates detected procedure 
set compute data flow effects increments 
changes epr algorithm change epr algorithm performs strength reduction increments add flow functions dfa problems epr algorithm 
flow functions compute data flow equation killed set defined killed sr killed candidates chapter prototype optimizer optimizer insert increments strength reduction candidates immediately variables depend incremented 
modify dead register elimination algorithm 
suppose node increments variable candidates depend live exit node require increment 
modify code generator algorithm knows generate suif instructions linear expression 
induction variable rewrite previous optimizations path simplification relatively simple way local analysis 
section shows program transformation induction variable rewrite ivr uses path simplification rules extensively 
nesting loops ivr detects synchronized induction variables 
ivr replaces uses synchronized induction variables equivalent affine combination loop indices 
example ivr detects variables synchronized loop indices iteration inner loop increases continue continue induction variable rewrite statement compiler rewrite induction variables terms loop indices 
substitution induction variables redundant removed 
strength increasing substitution slow execution iteration enables compiler parallelize loop 
continue continue chapter prototype optimizer increases 
iteration outer loop increases increases 
detection ivr substitutes uses expressions compute value value subsequent pass dead store elimination removes increments redundant substitutions 
face ivr slow programs replaces simple expressions may include multiplications 
ivr improves effectiveness dependency analysis enhancing effectiveness parallelization optimizations relies dependence information 
ivr usually runs parallelization 
parallelization run scalar optimizations remove introduced multiplications 
implementation ivr consists solvers 
solver path simplification step 
iterate propagate 
second solver performs iteration propagation 
path simplification step solver discover synchronized induction variables step sizes summarizing effects loops induction variables 
effect innermost loop increment 
shown replacing loop statements 
summarizing inner loop path simplification discover effect outer loop increment 
continue loop summarization path simplification computes effect loops induction variable 
part shows effect inner loop summarized statements 
part shows effect loop body outer loop 
continue chapter prototype optimizer iteration step second solver initial value step size induction variables computes relationships induction variables loop indexes 
example top outer loop solver brings information initial values loop effects initial value loop index 
information determine top loop 
relationships initial values inner loop 
top inner loop 
propagation step second solver replaces induction variables relationship 
example replaced corresponding expressions loops 
representing relationships induction variables suppose loop variable index bounds step size iteration increments iteration value suppose loop induction variable compiler determine bound step size loop expressed bound appear expression isn necessary computing relationship needed determine loop exits incremented loop nested loop expression needed order relate loop index outer loop 
compiler general represent expressions symbolically expensive proposition 
fortunately purposes improving dependency analysis suffices compiler consider induction variables affinely related loop index 
suffices compiler find affine relationships coefficients integers relationships strength reduction 
chapter prototype optimizer representing loop structures apply ivr loop compiler determine index variable lower bound step size index variable 
information easily discovered loops coincidentally ones interest dependence analysis 
suffices compiler consider loops 
loop exits early index reaches upper bound induction variables defined loop compiler compute expressions described previous section 
loops interest ivr represented flow graph 
nodes demarcate loop 
node generates information propagated loop body 
second exit node generates information pertains effect loop 
information evident sections 
computing induction variables step size flow functions solver ivr represent effects cfg paths integer variables 
node computes flow function set containing assignment control flow graph loop ivr loops interest compiler 
loop delimited special nodes node exit node 
exit loop body chapter prototype optimizer set tells value exit node computed sum values entrance node 
suppose flow functions represent respectively node unique successor find flow function entrance exit composing case substituting obtain flow function interpreting flow functions important remember variables right arrow denote values entrance path variables left denote values exit path 
paths joined intersection flow functions sets 
apply kleene star flow function expose induction variables 
induction variables exactly variables appear sides assignment form expression isn modified loop 
call step expressions 
example flow function kleene start exposes variables induction variables step sizes respectively 
loops kleene star applied flow function loop body path simplifier examines loop header node 
time exposed induction variables step sizes attached header 
represent kleene star flow function term iv represents induction variables initial value step size expressed terms values outside loop 
composing flow function loop exit node gives function represents effect loop induction variables 
flow function outer loop body exit exit inner loop path simplification determine expression variable sets variable bottom constant propagation chapter 
iv iv chapter prototype optimizer propagating induction variable relationships second solver resembles constant propagator described chapter 
constant propagation flow values bind constants variables flow values ivr binds expressions variables 
input flow value node contains binding safely replaced expression constant propagation second solver symbolically interprets instructions 
adding new bindings second solver remove bindings longer valid removal analogous killing expressions available expression problem 
example flow function instruction replace bindings input flow value bindings output flow value contains variable second solver exit nodes play special roles 
node computes relationships induction variables loop index binds relationship induction variable propagation loop 
exit node binds induction variable final values propagation outside loop 
results sharlit useful tool 
facilities ideal describing dfas simple iterative ones ones symbolic analysis recurrence detection ones interval analysis 
extensibility sharlit suited experimenting different internal representations implementing optimizations building simple prototype sophisticated necessary 
suif optimizer real 
results table show optimizer optimize large real programs perfect club effectively commercial compilers 
knowledge reported tool build practical optimizer 
thesis demonstrates modular way modular level individual optimizations build optimizers 
modularity significantly easier extend modify optimizer 
tool easier bind modules 
particularly important aspect sharlit imposes structuring discipline constrains compiler writers way implement optimizer 
tool yacc lex kind constraint easier understand ultimately compiler easier modify 
chapter prototype optimizer description lines suif seconds mips seconds suif mips lg lattice guage quantum lw liquid water simulation molecular dynamics na nucleic acid simulation molecular dynamics sd structural dynamics engineering design sr supersonic reentry fluid dynamics tf transonic flow fluid dynamics ti electron transform integrals molecular dynamics table comparison suif optimizer commercial optimizer perfect club execution results seconds runs decstation version mips compiler chapter suif procedure table procedure suif far thesis addressed problem structuring internals optimizer 
turn attention problem integrating optimizer compiler system incorporates scalar parallelizing transformations 
overview suif il difficult support scalar optimization parallelization il desires program representations different levels abstraction 
effective scalar optimization prefers low level il expose operations possible 
array indexing instance expressed address calculations expose common subexpressions strength reduction candidates 
loops expressed terms labels jumps landing pads optimizer insert code preserve control dependences 
parallelizing transformations prefer loop structure unique induction variable explicit representation loop bounds 
dependence tests example extended gcd require index expression multidimensional array identifiable 
linearizing array combining index expressions lengthy computation limit choice dependence tests 
suif core small set simple instructions register operands 
set called low suif similar quad ils traditional scalar optimizers 
support parallelization suif uses register naming convention helps extract expression trees suif instructions suif explicit representation highlevel control flow array indexing 
features suif program say program represented high suif 
having high suif having separate high level il 
highlevel control flow array indexing operators instructions high chapter suif low suif identical 
low suif proper subset high suif 
high suif features exclude low suif features branches labels low level control flow address arithmetic high level control flow array indexing operators coexist 
low suif instructions chosen minimize case analysis optimization code generation 
reduce number cases having small set operations hiding operations 
computational instructions require type argument 
instruction require operands virtual registers branch targets memory addresses results returned registers 
load store instructions way move values registers memory 
load constant instructions lines way put constants registers 
suif type system similar type system 
suif types represent data types sizes naturally representable target machine 
types stand bit signed integer bit address respectively 
suif types machine dependent past experiences shown easily control dependency parameterizing compiler 
registers normally registers low level instructions suif scalar optimizations undesirable high level transformations 
transformations prefer expression trees represented explicitly 
expression trees reduces high level transformations large number instructions grouped smaller number trees 
trees bound computation intermediate values reducing number variables considered 
hand scalar optimizations treat values intermediate equally 
optimizations want find redundant computations strength reduction candidates regardless compute intermediate values 
suif resolves conflict providing different views instructions expression trees lists quads 
done register naming convention 
suif kinds registers hard registers suif uses hard registers refer real machine registers 

call instruction cal hide operations load argument registers stack copy returned result 
operations depend target machines 
hide machine dependence simplify inliner 

case multi way branch mbr occurs rarely opted format easy code generation list branch targets 
chapter suif program fragment associated suif code ldc nr cpy pr nr ldc nr cpy pr nr pr pr pr pr ldc nr cpy pr nr ub cpy pr pr step ldc nr cpy pr nr body ldc nr ldc nr ldc nr array nr nr nr nr lod nr nr ldc nr ldc nr array nr nr pr nr str nr nr ldc nr add pr pr nr chapter suif node registers intermediate values data point definition point points limited basic block held node registers 
values single def single correspond values generated inside expression tree 
node registers instruction operands nr prefixes 
node registers easy reconstruct expression trees 
build trees tree node suif instruction connect instruction defining node register instruction node register tree edge 
easy build trees bounding lifetimes node registers useful parts compiler don trees 
example node registers provide clues interpretive code generators 
generators associate information machine resources machine instructions encountered node register scans suif program 
node register encountered forget associations 
node registers distinguished registers form instruction independent kind registers uses 
internal representation instruction list lifetime information provided node registers 
reaching definitions analysis takes advantage situation 
knows definitions node registers limited extent ignores reducing number cases consider 
pseudo registers pseudo registers hold values single def single values flow basic blocks 
register names prefix pr denote pseudo registers 
compiler assigned pr pr pr respectively 
pseudo registers form infinite register file allocate user temporary variables 
suif compiler identifies procedure local variables aliases assigns permanently pseudo register duration procedure 
find local variables front scans procedure list locals addresses taken 
variables candidates permanent residence pseudo registers 
variable including global compiler generated temporary variable aliases region procedure promote variable region pseudo register 
finding candidates difficult requiring tracking pointer values alias analysis 
splitting register allocation phases allocating pseudo registers allocating pseudo registers machine registers benefits 
pseudo registers ideal candidates allocation machine registers 
chapter suif addition assigning pseudo register machine register involves substituting pseudo register number assigned hard physical register number 
global data flow analysis suif concentrates pseudo registers 
pseudo registers aliased gen kill information simple 
analysis encounters assignment pseudo register data flow information register changed 
assignment affect information collected registers 
similarly assurance simplifies passes restricting changed assignment pseudo register 
suif virtual registers mediate data flow 
memory required arrays variables referenced indirectly 
simplify representation operations memory addresses suif organizes memory paths 
paths addressing details relationships expressed paths 
paths hide addressing details high level phases details accesses function activation record accesses record level accesses 
paths encode aliasing relationships language independent way making easy pass aliasing information low level phases 
path system organizes names program variables including temporary ones labels tree structure 
leaves variables temporary variables fields aggregates refer storage areas 
internal node groups set children nodes related example scope components aggregate form larger storage area 
node labeled identifier necessarily unique 
unique name derived concatenating identifiers path root node 
example code int int struct int int variables declared function specified path function individually names function function fields variable function function function fig chapter suif ure path function label label path global refers array 
path serves unique identifier succinctly encodes address variable generated 
stored symbol table addressing relationship internal node path child node code generated derives child address parent 
high level phases concerned address computations address represented path treated constant 
necessary path expanded series instructions looking code corresponding edge path 
technique accesses data structures variables stack level accesses nested functions 
importantly suif hierarchical name space design simplifies optimizations 
example inlining 
suppose function inlined call site function get new name space duplicate subtree rooted function give root new subtree unique name place copy new subtree func tion result shown 
name clashes automatically avoided give variables inlined obscure names 
contrast provides level grouping memory blocks 
function memory block variable represented region block 
instructions variables index length 
inlining merge variables callee caller flat area losing high level information 
paths simplify alias analysis 
approach alias analysis modeled path forest trees represent relationships paths program 
notice represent functions inlined function replicating subtrees 
function function scope inline fd fd chapter suif resource ids coutant 
alias analysis tracks variable set set addresses point 
variable aliased address set pointer memory address load store 
computing sets exactly undecidable sets conservative 
sets succinctly represented sets paths suif 
register example points record global necessary enumerate fields record set simply global 
paths particularly convenient large sets set global variables global 
enumerating global variables inefficient 
example need describe global variables set procedure call 
interprocedural analysis performed conservative set function globals 
high suif previous sections described low suif set features high low level phases suif compiler 
high suif suif high level constructs array instruction explicitly indicates index expressions array 
array instruction appears line 
ldc instruction line loads node register nr base address array 
node register nr holds index value constant nr holds upper bound nr holds computed address indexed element 
construct represents fortran loop 
lines character parts construct 
line tells pr pr pr pr loop variable lower bound upper bound step respectively 
bounds step registers compiler generated invisible programmer source program modified loop body required fortran loop semantics 
string indicates loop test pr pr 
labels break continue labels 
break continue statements inside loop translated front jumps labels 
lower bound computation follows loop marker ub marker precedes upper bound calculation step maker precedes step initialization code 
body lines mark boundaries loop body 
construct lists instructions corresponding test part optional part 
chapter suif loop construct contains lists instructions representing body representing test test implicitly occurs bottom loop body 
represent loops matching fortran loop semantics loop construct surrounded construct 
outer decides loop execute test loop construct decides execute loop 
control flow high suif represented constructs unstructured control flow represented usual low level jumps labels 
front translates source programs high suif directly 
preprocessor restructures fortran structured code 
high suif constructs array indexing loop structures convenient sufficient analysis loop transformations sacrificing functionality 
fields array instruction provide arguments dependence testing 
controlflow constructs delimit code regions interest loop transformations 
loops permuted updating fields constructs loops distributed surrounding new loop bodies constructs 
analysis optimizations high level constructs expander phase lowers high level constructs low level suif 
approach harrison auslander expander macro replaces high level constructs lower level code code template 
construct lowered independently 
expander attempt generate tight fast code 
optimizations tune customize result fit surrounding code 
example expanding array instruction representing expander fold constants done constant folding propagation phase 
high suif includes low suif subset built compiler passes accept high suif extending passes accepts low suif 
scalar optimizations fit model accept high suif 
instance obtained high suif reaching definitions analyzer including data flow analyzer knowledge construct generates uses definitions 
operations hidden high level constructs scalar phases equally effective high suif low suif 
annotations annotations suif offer flexible way transmitting information data dependence results phases compiler 
analyzers attach annotations instructions procedures data declarations control constructs program transformers look interpret specific annotations leaving annotations intact subsequent passes 
par chapter suif pass example annotate loop doall indicating loops need implemented parallel multiprocessor code 
likewise interprocedural analysis tool annotate procedure call sites summary information 
currently phases suif compiler tell wide variety information symbol table information data dependences annotations 
annotation consists name string followed list fields 
field string register integer suif type path 
specific annotation known format agreed compiler phases producing consuming annotations 
example alias analysis phase determines store instruction write global function local variable attach annotation store instruction alias set subsequent passes look alias set annotation loads stores information 
general annotation format simple flexible 
easy add new information suif important property research compiler 
annotations allow separate analysis phases compiler transformation phases improving modularity compiler 
separation permits substitution analysis phases capability invaluable experimental purposes 
overview status suif compiler system section shows suif compiler organized take advantage integration optimizations 
suif compiler separates functions distinct phases communicate suif files 
suif representation free ordering phases respect 
structure invaluable experimentation permitting implementation projects coexist 
shows progress typical fortran program flows suif compiler 
phase fortran converter translates program equivalent program 
program fe front portable compiler translates program high suif program 
parallelization program representations features high suif 
high suif program passed sequence phases 
sequence includes parallelizing phases includes scalar optimizations providing information preparing program phases sequence 
phases ordered sequence depend goal compilation compiling multiprocessors compiling superscalar machines require different sequences 
depend information requirements phases chapter suif fortran program program fe high suif program expander low suif program code gen expander low suif program suif compiler system parallelization dependence testing privatization loop distribution unimodular loop transformation iteration tiling scalar code motion inlining recurrence detection dead code elimination reaching definitions constant copy propagation register allocation scalar chapter suif phases dependence analysis better constant propagation induction variable expansion precede sequence 
output sequence program high suif parallelized improved scalar optimizations 
expander translates high level constructs high suif program low suif see section low suif program optimized customized scalar phases previously applied high suif 
eventually low suif translated target code 
developed code generators mips vax 
compiler comprehensive repertoire transformations analyses discuss 
scalar optimizations described sections 
high level transformations analysis array loop level analyses transformations require data dependence information 
arranging dependence tests increasing strengths costs memoization suif compiler generate exact dependence information efficiently 
dependence information low level passes superscalar vliw instruction scheduler high level passes scalars distribute transform loops 
loop optimizations suif compiler unified unimodular transformations interchange reversal skewing new transformation theory 
theory shows transformations tiling blocking expose parallelism improve data locality introducing excessive communication committing caches 
theory simplifies implementation finding directly optimal loop transformations computing directly loop bounds searching exhaustively transformation space 
addition unimodular transformations suif compiler contains known transformations loop distribution scalar privatization scalar expansion 
scalar privatization important allows loops define scalars iteration parallelized 
loop distribution scalar expansion concert allow sequential portions loop split parallel computations loop 
status experience years suif compiler effective research compiler compiler extended run new experiments compiler capable generating optimized parallelized code 
compile validate perfect club benchmarks full scalar optimizations 
high level phases functioning 
tests run perfect club 
linear loop transformations auto chapter suif matically block matrix algorithms qr decomposition lu decomposition pivoting performance measured sgi multiprocessor 
chapter dissertation contributions building optimizing compilers 
software architecture write scalar optimizers modular extensible 
second integrate scalar optimizations require lowlevel program representation code transformations require high level program representation 
optimizer architecture kildall original proposition data flow analysis basis describing optimizations 
simplify construction dataflow analyzers encourage kildall model tool called sharlit provided 
key features sharlit sharlit separates description dfa problem flow values flow functions description problem solved 
compiler writer may flow values flow functions solution techniques 
independence promotes flexibility choosing solution technique 
sharlit provides dfa solution procedure path simplification unifies common solution procedures existing optimizers 
dissertation shown local analysis tarjan interval analysis sparse data flow evaluation graphs implemented sharlit 
path simplification decreases effort required build optimization 
advantage path simplification permits compiler writer pose dfa problems need consider local analysis basic blocks 
concepts complicate dfa problems partial redundancy elimination 
path simplification dataflow analyzer efficient 
chapter sharlit provides facilities combining data flow analyzers 
facilities enable create complex analyzers simpler ones increase modularity optimizer 
sharlit tested construct complete optimizer 
best knowledge dissertation realize kildall proposition fully working optimizer compiles real large programs 
optimizer modular extensible phases data flow analyzers reordered new phases relatively easy add 
reordering addition phases facilitated ability add new flow functions path simplification rules 
optimizer modular analyzers built simpler ones chains products 
optimizer generates efficient code nearly efficient best commercial optimizing compilers 
second component dissertation integrate scalar optimizations require low level program representation code transformations require high level program representation 
optimizing compilers modern high performance computers implement just traditional scalar optimizations array level analyses loop transformations 
optimizing compiler large system 
keep rapid pace processor architecture advances compiler system capable incorporating new optimizations developed specific architectures 
important system modular engineered support growth experimentation 
fulfil needs thesis proposed intermediate language suif features register naming convention helps high level phases identify expression trees 
technique encoding high level control flow construct manner amenable scalar optimizations high level transformations 
naming convention variables permit easy things inlining encodes high level storage relationships variables 
annotation mechanism allows phases communicate wide variety information 
suif compiler system intermediate format 
compiler system consists set tools ranging scalar data flow optimizations compound loop transformations 
compiler development stanford years 
suif experience suggests intermediate language design provide useful platform multiple simultaneous projects variety compiler research topics 
ability share phases inherent suif reasonable time frame obtained interesting results individual topics data dependence analysis parallelization loop transformations 
subjects chapter explored suif platform 
suif project continues comprehensive compiling system gather meaningful statistics complete programs experiment new architectural designs evaluate new compilation techniques 
sharlit suif optimizer limitations resolution widen applicability usefulness sharlit suif optimizer 
sections address issues facilities build flow values 
algorithms efficient iteration 
program representations control flow graphs 
mechanisms update data flow information incrementally 
furthermore experience obtained implementing optimizations sharlit architecture 
experience give better idea overhead incurred due increased modularity flexibility 
flow values implementing analyzer solve dfa problem sharlit requires writing flow functions simplification rules implementing flow values 
sharlit provides facilities implementing flow values 
adding libraries help implementing objects sets expression trees graphs simple symbolic manipulation routines hasten development analyzers 
ideally libraries independent internal program representation 
efficient iteration iteration algorithm sharlit evaluates node flow values enter node changed 
technique hecht ullman 
efficient algorithm proposed horwitz demers teitelbaum header forest flow graph regions change status nodes reduce number node evaluations 
worst case running time algorithms identical expected horwitz algorithm better average running time 
algorithm incur minimal overhead sharlit computes header forest change status 
chapter flow graphs incremental updates primary focus sharlit control flow graphs 
graphs control flow explicitly represented edges graph data flow relationships data dependences control dependences implicitly represented part flow values 
focus cfg suits optimizations uniform representation dependencies benefit optimizations 
example powerful techniques formulated graphs control dependence data flow uniformly represented 
sharlit support techniques flow values abstractions interesting see sharlit support techniques directly sharlit sparse data flow evaluation graphs 
high level analyses transformations generally applied syntax trees control flow graph 
discussed chapter analyses transformations require data flow analyses scalar optimizations applied program 
approach taken suif compiler run scalar optimizations high level transformations 
approach flexible inefficient program written suif intermediate file times 
reduce intermediate file traffic build control flow graphs directly tree apply dataflow analyzers directly graphs 
integrating sharlit system uses parse trees introduces interesting possibilities 
parse tree speed control flow analysis cfa 
example cfa described section essentially re discovers loop structure program 
information evident parse tree 
furthermore structures ifthen participate cfa 
limit parse tree program define regions cfa 
leads natural interpretation viewing data flow analysis attribute evaluation attributed parse tree 
attribute grammars data flow analysis may allow apply efficient incremental update algorithms attribute evaluation data flow analysis 
idea put forth carroll ryder 
attribute evaluation applied solving dfa problems largely taken advantage techniques developed traditional data flow analysis 
integrating sharlit attribute evaluation system interesting 
experience sharlit dissertation shown possible build effective optimizer sharlit suif optimizer fully test sharlit facilities especially combine dfa solvers 
optimizations implemented test features 
try facilities improve speed suif opti chapter 
phases take advantage sharlit facilities combine optimizations 
example constant propagation run code motion writing suif intermediate file code motion re invoking optimizer propagate constant 
overhead intermediate file quite large suif optimizer times slower mips optimizer 
remove overhead modifying constant propagation phase accept output code motion algorithm eliminating intermediate files 
believe modification performed current sharlit architecture suif optimizer faster 
additional run time overhead exists interfaces architecture 
believe overhead tolerable light flexibility provided sharlit 
sharlit flexibility extensibility suif compiler vehicle investigate different scalar optimizations optimizations interact 
suif compiler project stanford continuing investigations 
bibliography bibliography 
aho ganapathi tjiang 
code generation tree matching dynamic programming 
acm trans 
programming lang 
systems october 

aho sethi ullman 
compilers principles techniques tools 
addison wesley 

allen 
basis program optimization 
ifip congress pp 


allen burke charles cytron ferrante 
overview analysis system multiprocessing 
tech 
rept 
technical report rc ibm sept 

allen carter fabri ferrante harrison 
experimental compiling system 
ibm journal research development november 

allen cocke kennedy 
reduction operator strength 
muchnick jones ed program flow analysis theory applications prentice hall pp 


allen johnson 
compiling vectorization parallelization inline expansion 
sigplan conference programming language design implementation 

alpern wegman zadeck 
detecting equality variables programs 
th acm symposium principles programming languages 

harrison iii 
automatic recognition induction variables recurrence relations interpretation 
sigplan conference programming language design implementation 

cutler jr 
engineering compiler vax code generation optimization 
digital equipment 
bibliography 
auslander hopkins 
overview pl compiler 
sigplan conference compiler construction 

maccabe ottenstein 
program dependence web representation supporting control data demand driven interpretation imperative languages 
sigplan conference programming language design implementation pp 


banerjee 
dependence analysis supercomputing 
kluwer academic 

benitez davidson 
portable global optimizer linker 
sigplan conference programming language design implementation 

berry chen kuck lo pang pointer sameh chin schneider fox messina walker lue seidl johnson martin 
perfect club benchmarks effective performance evaluation supercomputers 
tech 
rept 
technical report university illinois urbanachampaign 
center supercomputing research development 

newcomer lamb levine mary van william wulf 
ada revised report intermediate representation preliminary ada language 
tech 
rept 
technical report cmu cs carnegie mellon university february 

burke ryder 
incremental iterative data flow analysis algorithms 
tech 
rept 
technical report lcsr tr rutgers university laboratory computer science research august 

carroll ryder 
incremental data flow analysis dominator attribute updates 
th acm symposium principles programming languages 

choi cytron ferrante 
automatic construction sparse data flow evaluation graph 
th acm symposium principles programming languages 

chow 
portable machine independent global optimizer design measurement 
ph th stanford university 

chow 
register allocation priority coloring 
sigplan conference compiler construction 

cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
fourth acm symposium principles programming languages january pp 

bibliography 
coutant 
retargetable high level alias analysis 
th acm symposium principles programming languages 

coutant hammond kelly 
compilers new generation hewlett packard computers 
hewlett packard journal january 

cytron ferrante rosen wegman zadeck 
efficient method computing static single assignment form 
acm trans 
programming lang 
systems october 

cytron lowry zadeck 
code motion control structures high level languages 
acm symposium principles compiler construction 

davidson fraser 
code selection object code optimization 
acm trans 
programming lang 
systems october 


pattern languages prototyping compiler optimizers 
ph th university california berkeley 

ferrante ottenstein warren 
program dependence graph optimization 
acm trans 
programming lang 
systems july 

fong kam ullman 
application lattice algebra loop optimization 
nd acm symposium principles programming languages january pp 


fraser wendt 
integrating code generation optimization 
sigplan conference compiler construction 

ganapathi 
retargetable code generation optimization attribute grammars 
ph th university wisconsin madison 

ganapathi fischer 
description driven code generation attributed grammars 
th acm symposium principles programming languages 

ganapathi fischer 
attributed linear intermediate representations retargetable code generators 
software practice experience april 

ganapathi fischer hennessy 
retargetable compiler code generation 
acm computing surveys 

gay 
private communication 
att software 

samuel 
universal code project 
tech 
rept 
csl technical note stanford university aug 
bibliography 

machine independent algorithm code generation retargetable compilers 
ph th university california berkeley 

graham wegman 
fast usually linear algorithm global flow analysis 
acm january 


graph transformations program flow analysis 
ph th university california berkeley 

harrison 
new strategy code generation general purpose optimizing compiler 
acm fourth symposium principles programming languages pp 


hecht 
flow analysis computer programs 
elsevier north holland 

hecht ullman 
simple algorithm global data flow analysis problems 
siam comput 
december 

henry 
graham code generators 
ph th university california berkeley 

henry 
codegen user manual 
tech 
rept 
technical report university washington 

horwitz demers teitelbaum 
efficient general iterative algorithm dataflow analysis 
acta inf 


johnson 
portable compiler theory practice 
fifth annual acm symposium principles programming languages pp 


johnson 
yacc compiler compiler 
tech 
rept 
cstr bell laboratories 

johnson miller 
effectiveness machine level global optimizer 
sigplan conference compiler construction 

joshi dhamdhere 
composite hoisting strength reduction transformation global program optimization part 
intern 
journal computer math 


joshi dhamdhere 
composite hoisting strength reduction transformation global program optimization part ii 
intern 
journal computer math 


kam ullman 
global data flow analysis iterative algorithms 
acm january 
bibliography 
kam ullman 
monotone data flow analysis frameworks 
acta inf 


kildall 
unified approach global program optimization 
acm symposium principle programming languages pp 


knoop steffen 
lazy code motion 
sigplan conference programming language design implementation pp 


lalonde des rivieres 
flexible compiler structure allows dynamic phase ordering 
sigplan conference compiler construction 

lam 
systolic array optimizing compiler 
ph th carnegie mellon university may 
available cmu cs 

lamb 
sharing intermediate representations interface description language 
ph th carnegie mellon university may 
available 

lengauer tarjan 
fast algorithm finding dominators flowgraph 
acm trans 
programming lang 
systems july 

lesk 
lex lexical analyzer generator 
tech 
rept 
cstr bell laboratories 

maclane birkhoff 
algebra 
macmillan 

marlowe ryder 
properties data flow frameworks unified model 
tech 
rept 
technical report lcsr tr laboratory computer science research rutgers university april 

marshall 
linear graph package compiler building environment 
sigplan conference compiler construction 

maydan hennessy lam 
efficient exact data dependence testing 
sigplan conference programming language design implementation june 

morel renvoise 
global optimization suppression partial redundancies 
comm 
acm february 

ottenstein 
data flow graphs intermediate program form 
ph th purdue university 

perkins sites 
machine independent pascal code optimization 
proceedings sigplan symposium compiler construction pp 

bibliography 
pieper 
parallelizing compilers implementation effectiveness 
ph th stanford university 
preparation 

reif 
code motion 
siam comput 
may 

reif lewis 
evaluation global value graph 
th acm symposium principles programming languages january pp 


reif lewis 
efficient symbolic analysis programs 
tech 
rept 
technical report tr harvard university aiken computation laboratory 

reps generating language environments 
press 

rosen wegman zadeck 
global value number graphs redundant computations 
th acm symposium principles programming languages 

ryder 
incremental data flow analysis 
th acm symposium principles programming languages january pp 


ryder marlowe 
incremental iteration 
tech 
rept 
technical report lcsr tr rutgers university laboratory computer science research march 

ryder 
elimination algorithms data flow analysis 
comput 
surv 
september 

schwartz sharir 
design optimizations class 
tech 
rept 
courant institute mathematical sciences 

sharir 
structural analysis new approach flow analysis optimizing compilers 
computer languages 

stroustrup 
programming language 
addison wesley 

tarjan 
finding dominators directed graphs 
siam comput 
march 

tarjan 
testing flow graph reducibility 
comput 
syst 
sci 


tarjan 
fast algorithm solving path problems 
acm july 
bibliography 
tarjan 
unified approach path problems 
acm july 

tjiang hennessy 
sharlit tool building optimizers 
sigplan conference programming language design implementation pp 


tjiang wolf lam pieper hennessy 
integrating scalar optimization parallelization 
fourth workshop languages compilers parallel computing aug pp 


ullman 
fast algorithms elimination common subexpressions 
acta inf 
july 


framework construction evaluation high level specifications program analysis techniques 
sigplan conference programming language design implementation pp 


warren jr auslander chaitin hopkins mackay 
final code generation pl compiler 
tech 
rept 
technical report rc ibm thomas watson research center june 

wegman zadeck 
constant propagation conditional branches 
th acm symposium principles programming languages 

white 
charlotte web 
harper row 

soffa 
automatic generation global optimizers 
sigplan conference programming language design implementation pp 


wolf 
improving parallelism data locality nested loops 
ph th stanford university june 

wolf lam 
algorithmic approach compound loop transformations 
third workshop languages compilers parallel computing aug 

wolf lam 
data locality optimizing algorithm 
sigplan conference programming language design implementation 
bibliography 
