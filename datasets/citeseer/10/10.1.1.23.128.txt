integrating scheduling theory formal models hard real time systems victor departamento de computaci universidad de buenos aires argentina ar survey physical design notations models hard real time systems 
study features capabilities support verification issues 
delineate new proposal integrating analytical scheduling results operational formal methods increase tractability analysis properties 
real time systems increasing variety application fields including industrial control robotics aerospace automobiles communications multimedia domestic appliances 
timing requirements define real time systems design complex difficult 
applications critical safety requirements adds difficulty development 
common practice real time system development requires designer deal low level physical structuring system solve check performance requirements shared resource platform 
designers intensive interaction needed implement timing constraint available services 
designers need tools set simulate reason predict test system behaviour adequate abstraction execution environment 
structured follows classification survey design notations models aimed representing reasoning physical design 
conclude common characteristics trade offs approaches 
motivated remarks delineate new proposal integrates techniques different fields scheduling theory state space exploration methods cope verification common application models 
survey notations models analysis physical design believe order classify technique appropriate physical design able deal temporal phenomena arise share processing resources 
aspects usually ignored requirement specification phases timing information expressed consideration described behavior implemented 
worth mention proposals consider designer responsible conveying global real time requirements real time scheduler 
tool classification ways classifying approaches 
mainly concerned correctness designs choose divide type scope analysis provide suggest 
ffl scheduling results 
group constituted formal informal notations scheduling results periodic task model asses timing requirements 
usually deadline satisfaction requirements come sampling rate response time requirements 
functionality taken account analysis 
control structure task represented response structure event attended sequential parallel select ordering actions 
action described terms way consumes resources amount priority see 
tasks considered periodic interruptions handled kind sporadic attendance scheme 
support certain degree analysis certain multiprocessing environment model 
major strength polynomial complexity number tasks 
group tools kind results 
analytical results 
subgroup find tools suggest known results statically asses schedulability set tasks 
examples tools scheduling analyzer 
methods semiformal design notations suggest apply analytical methods carry timing correctness verification 
bounded execution tools periodical critical instant results deriving schedulability property bounded simulation 
ffl state space exploration mc ra 
group constituted tools operational formal kernels verification techniques state space exploration reachability analysis model checking 
normally able solve broader family queries group environment modeled queries include global timing requirements deadline satisfaction 
hypothesis application model restrictive approach support richer process models considered scheduling theory 
integrated previous phases software development done formal methodology 
major drawback fact suffer state space explosion problem associated verification problem high time space complexity decidable 
operational formal methods techniques adapted tackle difficulties arise physical design modeling 
process algebraic approaches numerous petri net automata approaches 
way classify tools ability model preemption operations 
support preemption modeling 
tools able model effect sharing processor execution time actions 
dense time domain discrete time domain 
support preemption modeling tools actions supposed atomically executed amount time specified designer 
dense time domain discrete time domain 
ffl deductive reasoning 
approaches semiautomated syntactical reasoning refinement verification fashion theorem provers transformational tools 
nature deductive frameworks prone allow integration external knowledge scheduling theory 
example scheduling results verify feasibility transformations data flow net 
tla approach claiming separation concerns scheduler program correctness abstracting away scheduler scheduler policy proving program correctness 
duration calculus approaches suit specification execution environment durations particularly adequate describe preemptive nature scheduling policies 
ffl integer programming 
group numerous 
key idea apply integer programming synthesizing distance events 
proposed alternative space exploration techniques solve questions temporal distance events 
deal deterministic analysis hard real time software stochastic techniques performance analysis left aside purpose 
guiding features characteristics section explain different aspects studied different proposal 
different nature notation analysis models formal informal notations aspects applied particular cases 
anyway goal keep description uniform possible allow easy comparison 
survey refers features compare approaches ffl modeling features 
section brief review notational characteristics approach 
worth say modeling approaches pay attention verification phase minimum front expressing structure requirements system 
try point limitations provided features circumstantial respond expressive constraints underlying formalism 
components connectors 
notations studied share basic notion concurrent sequential activities interacting competing achieve systems goals 
statically represented notation kind software component 
components merely tasks set services provided class objects 
describe capabilities approach express distribution activities processing resources 
point sequential activities component coexist system run 
notations address communication sequential activities briefly describe basic connectors provided 
functional control description components 
notations require allow type description behavior activities control functional level 
informal notations merely suggest pseudocode timing information formal ones allow precise functional descriptions 
try point special control flow schemes exception handling supported 
time issues 
point common notations require allow designer establish timing information software external components eventually analysis 
serve sort timing information repositories local global requirements response times sampling times frequency periodic outputs estimations 
point underlying time domain model dense discrete 
processing issues 
analyze way actions supposed evolve time granularity actions monolithic preemption modeled 
particular focus limitations model operative platform characteristics scheduling policies supported run time overhead 
environment behavior description 
environment description plays important role development control systems 
notations address degree description assumptions system controlled known plant 
structuring criteria analysis influenced expected timing characteristics code associated components section describe special capabilities define connectors hardware components 
ffl verification 
underlying formalism optional 
notation semantics formally supported report class formalism 
shared processors modeling optional 
formalisms physical phase usually adhere maximal parallelism assumption common feature formalism aimed specification phase requirements stated 
key aspects formal approach supports preemption modeling dichotomy elapsed real time remaining processing time handled 
try understand way maximal parallelism abolished scheduling policy modeled built described 
verification technique 
understand verification approach report technique analytical worst case response time calculation model checking reachability analysis 
queries 
understand scope approach necessary know kind properties queried ones provided logic fragment ad hoc queries minimal maximal separations events 
interesting know formulated logic manual adaptation reachability problem 
treatment functional aspects optional 
think important know extent data functional aspects taken account verification phase queries involve data infinite domains data allowed 
complexity 
modeling querying capabilities impact complexity solve general verification problem approach computable tractable 
reported observations 
approaches different characteristics goals scopes analyzed points 
think help understanding flavor utility limitations approaches 
survey detailed survey extensive describes representative informal notations automatic techniques field 
interested automatic potentially automatic techniques deductive formal methods treated detail 
approaches scheduling results ffl sad aad sad software architecture diagram notation notation goal describe systems task structure 
aad ada architecture diagram notation introduces ada specific tasking notation providing ada direct features packages rendezvous 
modeling features 
components connectors 
task structures periodic task model described node statically distributed system 
instant executing instance task job task 
notation presents various mechanisms loosely prioritized tightly coupled message communication 
types event synchronization possible external timer internal 
external event typically interruption external devices 
information hiding modules encapsulating data stores 
tasks access data store indirectly operations manipulate contents data stores 
functional control description 
pseudocode serves tasks behavior specification language functional descriptions ignored verification phase 
time issues 
notation suggest designer define estimations computation requirements deadlines interarrival time interruptions processing issues 
node scheduled fixed priority policy 
operative hypothesis sophisticated allowed rate monotonic analysis 
environment behavior description 
tool aimed studying basically software artifacts behavior 
notation support notion event externally generated 
timing information interarrival time external interruptions perform analysis aperiodic tasks attend 
dataflows passive read write information depicted 
verification 
verification technique 
rate monotonic analysis suggested applied annotated estimations 
queries 
local deadlines satisfaction jitter requirements average response time events 
complexity 
formulas polynomial complexity respect number tasks 
ffl hrt hood 
hrt hood object oriented notation guides designer produce designs high degree analyzability terms scheduling theory worst case blocking predictable 
interesting semantical adaptation object oriented notation room deal hard real time systems development 
modeling features components connectors 
objects components shown static representation system 
notation provides object classes common hard real time active abstractions cyclic objects periodic activities sporadic objects 
static distributive computing supported 
activities communicate trough requests asynchronous loosely coupled blocked ready serve csp highly synchronous execution request blocked serviced rendezvous associated time 
passive information hiding version shared memory protected objects similar monitors may act data repositories 
functional control description 
functional control description translation ada 
just resource usage described 
time issues 
timing attributes associated objects cyclic period deadlines offsets sporadic minimum arrival interval offsets deadlines 
depending type scheduling approach attributes annotated 
processing issues 
node scheduled fixed priority scheduling policy adhering models supported results 
environment behavior description 
tool aimed studying basically software artifacts behavior 
notation supports notion event externally generated 
timing information interarrival time external interruptions perform analysis aperiodic tasks attend 
dataflows passive read write information depicted 
verification 
verification technique 
schedulability analysis performed corresponding analytical theory worst case estimation fixed priority scheduling theory 
queries 
local deadlines satisfaction jitter requirements average response time events 
complexity 
formulas polynomial complexity number tasks 
ffl prototyping environment real time systems prototyping environment evaluation real time systems 
key component schedulability analyzer 
basic version version supports analysis validation real time systems built framework periodic task model 
chose example analysis tool analytical results 
similar analysis capability provided stress case scheduling analyzer provides results commercial tools rate monotonic analysis 
modeling features complex task resource model available simulation environment taken account description 
components connectors 
tasks resources represented model periodic task model assumptions 
aperiodic tasks scheduled variety schemes including pure persistent polling server sporadic server 
instant executing instance task job task 
tasks statically bound processors 
shared resources controlled priority ceiling protocols non preemptive critical approach priority inheritance stack protocol 
functional control description 
functional control description 
just resource described 
timing aspects 
jobs annotated worst case execution time deadline release time 
processing issues 
processing rate processors specified 
resources preemptable preemptable 
node scheduled priority driven scheduling rm deadline monotonic edf 
environment behavior description 
tool aimed studying basically software artifacts behavior 
external bounded bursty events treated periodic 
verification 
verification technique analytical results periodic task model 
analysis multiprocessor systems multiprocessor model scheduling model 
queries 
deadline satisfaction worst case execution time blocking time jitter satisfaction analysis 
complexity 
formulas polynomial complexity number tasks 
approaches state space analysis ffl rtd formal notation sa rt requirement notation 
semantics high level timed petri nets graph grammar rules 
modeling features components connectors 
allows describe system set tasks terminators 
instant executing instance task job task 
version studied models systems 
connectors inspired posix standards 
message queue shared memory signal user 
functional control description 
task comprises sequential activities default thread exception threads signals executed mutual exclusion 
internals task specified means data control flow tool graphical language definition rtd just particular instance 
description 
functionality bubbles processes expressed operational fragment vdm 
control specification facility available controlling activation bubbles describing manipulation signals 
timing aspects 
expression data dependent defines upper lower bound functional activities bubbles 
period cyclic tasks timing parameter notation 
dense time model 
processing issues 
actions preemptable 
version studied allows fixed scheduling policy 
run time overhead potentially 
environment behavior description 
terminators modeled data streams independent received signals semantics details 
verification 
underlying formalism 
formally defined base formalism 
shared processors modeling 
timestamps manipulated way remaining execution time activity kept token 
scheduler modeled subnet 
verification technique 
simulation symbolic execution available 
bounded reachability analysis partial model checking 
queries 
language available bounded time queries 
treatment functional aspects 
functional aspects annotated fragment vdm translated functions performed transition firings resulting tokens 
queries predicate data values 
complexity 
general reachability model checking problem computable 
ffl approach corbett approach aimed analyzing ada code hybrid automata 
seen technique analyze ada design notation 
extension deals partially implemented systems queries graphic interval logic 
related approach parametric hybrid automata synthesizing processors speeds amount processor time task accomplish performance goal 
modeling features components connectors 
components ada tasks 
instant executing instance task job task 
currently dynamic task creation modeled 
version deals environments 
supports rendezvous communication protected objects similar monitor communication media 
models asynchronous transfer control allows completion blocking operation abort execution sequence statements 
functional control description 
ada code 
time issues 
delay operation estimations bounding sequential code execution time 
continuous time time unit definition largely irrelevant 
processing issues 
actions preemptable 
major advantage modeling technique potentially allows reasoning scheduling context non scheduling theory known system fit theory hypothesis periodicity 
currently supports static priority scheduling accounting run time overhead task synchronization timer services context switches interrupts 
environment behavior description 
approach separation interruptions modeled communicate task system occurrence external event 
verification 
underlying formalism approach presents way model ada code slope linear hybrid automata allows preemption modeling 
automata nodes represent different states application reach 
continuous time domains gets conservative abstractions software 
virtual techniques reduce size automaton 
shared processors modeling 
scheduler modeled state transition representation 
hybrid automata allows express derivative clocks 
derivatives models idea task running idling respectively 
verification technique 
symbolic model checking hytech applied hybrid automata 
queries 
property automaton build compose system reachability analysis applied 
treatment functional aspects 
finite domain data modeling allowed 
complexity 
unfortunately general model checking reachability problem hybrid automata undecidable claim queries terminate 
state space explosion problem currently limits small size system 
believe task scheduling deterministic nondeterminism transition system caused timer transition delay statements alternatives unmodeled program variables 
ffl approach mathematically founded process algebra 
describe control communication behavior timing behavior timing constraints deadlines system 
algebra provides high level real time constructs watchdogs exception handlers 
modeling features components connectors 
system modeled set sequential processes process description language syntax semantics loosely ccs acp 
models platforms 
complementary synchronization actions models synchronization channels ada select statement data passing 
functional control description 
process built actions 
data modeled 
process algebraic approach aimed representing communicating structure processes account duration internal communication actions 
timing exception handling modeled 
time issues 
internal communication actions labeled durations measured time units 
operators express delay deadline timing constraints 
discrete time model 
processing issues 
tick resolution approach allows preemption modeling 
scheduling discipline modular component formal model changed 
parametric priority function arbiters selection process progress rm edf modeled 
environment behavior description 
environment modeled processes interact control software 
language constructs available description 
verification underlying formalism 
process algebra formal semantics 
shared processors modeling 
system semantics establishes just highest priority process advances idle 
difference elapsed time executed time reflected time constructs deadlines reduced enclosed process 
verification technique 
reachability analysis applied 
queries 
deadline satisfaction problem reachability question states record unhandled exceptions arise deadlines missed 
complexity 
state space explosion problem may arise 
hypothesize filtering effect scheduling disciplines regular structure real time systems tend control problem practice 
ffl tool quantitative analysis finite state real time systems labeled transition systems 
modeling features components connectors 
task described syntax 
task corresponds executing sequential activity 
models platforms 
shared variables available task communication 
protected accessing high priority level 
protocols communication models implemented 
functional control description 
done trough syntax 
data types allowed integer boolean 
interruption features directly modeled 
time issues 
language provides primitives express timing aspects deadlines priorities time delays imperative fashion 
language wait operator model discrete time duration actions 
processing issues adopt tick resolution interleaving 
timed formalism action visible state changes instantaneous 
passage time controlled wait statement 
discipline modeled fixed priority scheduling subtasks different priorities 
environment behavior description 
tool aimed studying basically software artifacts behavior 
periodic task statement describe indirectly actions performed sporadic task attendance external request 
verification 
underlying formalism 
language translated untimed transition systems global variables 
shared processors modeling 
interleaving semantics transition systems models shared processor 
verification technique 
adaptation symbolic model checking technique 
algorithms provide valuable timing information minimum maximum delay counting number transitions condition counting max min 
number times condition holds path starting final 
queries 
extension symbolic ctl expressing time bounded properties 
complexity issues 
tick resolution interleaving exacerbate state space explosion phenomena 
influence functional aspects 
finite data language translated labeled transition graph 
ffl arc formalism extends csp communicating sequential processes global clock 
modeling features components connectors 
components csp processes tasks 
models platforms 
basic connector synchronous communication csp 
processes involved communication synchronize operation 
functional control description 
typical untimed csp description shows possible behavior terms communication structure 
functional data aspects specified 
interruption features modeled 
time issues 
events represents advance time units 
time model discrete 
processing issues 
language addresses non preemptive fixed priority scheduling 
actions monolithic 
environment behavior description 
environment modeled processes interacts control software 
language constructs available description 
verification underlying formalism 
extension untimed csp 
global discrete clock increased time advancing events 
shared processors modeling 
interleaving semantics events models shared processor environment 
verification technique 
arc compiled labeled transition system 
refinement equivalence checking applied 
queries 
asked refinement equivalence holds terms modeling systems 
complexity 
solves extra production states tick resolution action resolution 
anyway state space exploration approaches potentially suffers state space explosion problem 
ffl graphical communicating shared resources graphical language allows descriptions system structured charts fashion 
supports explicit representation system resources priorities arbitrate resource contentions 
modeling features components connectors 
real time systems consists set communicating processes 
supports multiprocessor platform modeling 
processes synchronize matching event names 
interruption communication occur execution processes 
functional control description 
control description trough set nodes model time consuming actions connected directed edges events communication time 
time issues 
discrete model actions takes tick established resources priorities events timeless priorities assigned 
possible express actions taken time external internal interruption 
processing issues 
aimed modeling fixed priority scheduling 
dense model actions take certain amount time preemption actions modeled monolithic actions 
environment behavior description 
environment modeled agents interacts control software 
language constructs available description 
verification 
underlying formalism 
graphical language translated process algebraic approach takes account share resources contention resources arbitrated fix static priorities 
shared processors modeling 
processors resources 
actions compete arbitrated fixed priority scheme 
verification technique 
tool supporting process algebraic view provides bisimulation algorithms compare designs specifications 
reachability analysis tools provided 
queries 
queries solved rephrased reachability problem 
complexity 
state exploration approaches suffers state space explosion problem 
approaches linear integer programming 
ffl approach technique deriving upper lower bounds time elapse events execution concurrent software system running single processor arbitrary scheduling 
modeling features components connectors 
static set processes 
possibility top model dynamic task creation 
version deals extended treat distributed systems 
synchronous asynchronous communication events processes modeled 
functional control description 
control structure processes described deterministic finite automata 
guide model interruption features 
time issues 
event assigned duration 
upper bounds cycles provided user 
time domain irrelevant approach 
processing issues 
events preemptable activities overlap 
atomicity importance approach due technique calculating distance events 
consider complex software characteristics system developer little control scheduling provided semantics interprocess communication incapable verifying systems scheduling policy essential timing correctness 
environment behavior description 
tool aimed studying basically software artifacts behavior 
external behavior directly modeled aimed analyzing complex interaction aperiodic processes transaction firing 
verification 
underlying formalism 
system run coherent interleaving events processes 
intended runs constrained set inequalities 
shared processors modeling 
objective function optimized sum durations events overlapping 
range function depends desired time domain 
verification technique 
model executions linear inequalities linear programming techniques generating state spaces 
inequalities system deduced constitute necessary conditions satisfied subsequences events queries 
upper lower bounds pair events system run 
complexity inherits complexity integer linear programming problem results reported 
treatment functional aspects 
finite state processes modeled variables infinite ranges remarks informal notations richer high level features 
provide languages closer user needs 
obviously due informal nature automatic support verification phase procedure error prone 
tools scheduling analyzers solve fact just asses deadline meeting set task 
hand formal languages difficult describe system terms available mechanisms eventual implementation 
dual notation approach needed 
unfortunately expressive power formal languages necessary feature real phenomena impact tractability verification 
functional aspects data treatment modeled taken account verification process approaches 
timing properties analyzed independently functional characteristics separation concerns criterium followed designers temporal correctness depend software reaction dependent data characteristics worst case computation time estimation 
consequence methods directly address data modeling conservatively replaced non determinism control timing description 
regarding environment modeling divide approaches groups ones represent interacting external agents complex patterns ones indirectly address issue trough possibility modeling interruptions arrivals software system 
group usually allows sophisticated contextual analysis interarrival parameters 
observe formalisms scheduling policy fixed priority tacitly built semantics 
approaches potentially provide flexibility model scheduler just component drawback generating twisted heavy dependence components scheduler 
third group constituted formalisms scheduling syntactical semantical category providing certain flexibility encouraging smoother transition requirement 
conclude main obstacles efficiency property verification granularity actions 
discrete fully preemptive models tick resolution produce unnecessary states nn hand dense time preemptive models hybrid automata undecidable verification problems complexity prohibitive 
known specification formalisms temporal automata approaches process algebras petri nets approaches able model preemption 
oriented maximal parallelism assumption right approach specification 
example case automata time clocks measure minimum maximum elapsed time node 
unfortunately clocks stopped hybrid automata possible accurately model preemption 
observation originally inspired state space exploration methods usually motivated need reasoning non standard situations known scheduling theory 
scheduling theories known completely ignored state verification techniques 
proposal integration schedulability analysis formal analysis properties motivate main ideas proposal lets review alternatives reason designs scenery designer naturally express execution architecture timing requirements subclasses hybrid automata accurately expressible conservatively expressible timed automaton non zero constant slope non zero linear hybrid system integration graphs suited non fixed preemption modeling 
estimations system 
estimations expressed lower upper bounds execution time functionalities dedicated environment computation requirement software 
designer sure high level requirements satisfied physical model 
application properties task deadlines analyzed known theory developed selected scheduling policy fixed priority scheduling trivially imply satisfaction safety requirements particularly true example property depends subtle task interrelationship distributed data consistency 
hand resort state space exploration methods provide framework querying safety requirements formal model obtained designer notations 
unfortunately formalisms allow run time preemption modeling typical characteristic scheduling policies verification problems decidable high computational complexity time space 
true known analytical results tools profited model checking reachability techniques 
key idea observation scheduling analysis techniques usually produces intermediate result real response times certain code areas 
means tools provide measure worst case time deformation execution functionalities 
information building non preemptive model system scheduler modeled 
model tractable original eventual formal analysis 
non preemptive vision system bottleneck explicit scheduler modeling represents compositional analysis 
rol scheduling theories approach provide calculus response time sequential code deformation theory 
lets observe deadlines satisfaction just property queried general formal framework 
integration seen restricted mix deductive model checking techniques scheduling theory serves basis abstraction procedure build model traditional model checking reachability techniques applied 
true scheduling policy imposes deterministic behavior system consequently reduces state space explosion problem 
sight eliminating scheduling modeling harmful 
observed scheduling modeling eliminates possibility redundant interleaving lowest level atomicity performed intolerable 
scheduling eliminated spurious non determinism remain imposed unknown execution times bounded ignorance original detailed model 
believe elimination scheduling details harmless get coarser grain model 
sections illustrate approach giving notational features technique support guidelines construct formal model 
guidelines define user language modeling features main criterion designing user language intention getting models high degree analyzability 
technique analytical results construct simplified formal model 
known analytical theories expressive power selected formalism impose certain constraints modeling features 
think restrictions acceptable family applications strict discipline periodic model 
believe restrictions eventually overcome trade sophistication application models supported ability verify properties predict behavior obtained designs 
ffl components connectors 
language provide elements express execution architecture composed tasks distributed network processors 
node tasks communicate shared data structures internal signaling 
previously said inspired periodic application model hypothesis analytical results define language features 
authors believe features suits applications real time field 
just simplify discussion language just support shared memories example non blocking abstraction circular queue overwrites full achieve asynchronous message passing 
perform analysis assume code run server monitor priority assigned warrant mutual exclusion operations pcp emulation 
signaling mechanism available internal communication 
signaling net asynchronous medium communication processing nodes sporadic server attend signal 
signaling network sporadic server attendance chosen avoids phenomena complicates calculus deferred execution effect periodic attendance scheme suspension response remote call procedure scheme 
ffl functional control description 
task behavior finite set sequential activities perform depending run time control data conditions 
activities finite sequences internal visible actions 
internal action specified coded express data processed evaluated 
data functional manipulation represented reduced finite domains 
actions considered visible read write operation ports interface external devices 
invocation service communication abstraction 
ffl time issues 
designer provide interval range rational numbers min max express estimations computational time requirement internal action execution service 
task periodic case cycle specified 
task defined aperiodic follow sporadic server scheme replenish period suppose just invocation released tickets provided 
ffl processing issues 
actions fixed priority scheduling applied node 
ffl environmental behavior description 
environment plant behavior expressed simple timed formalism 
choose formalism accurately translated kernel formalism restriction sketched 
integration plant controller expressed shared memories modeling passive ports usually sampled periodic tasks signaling mechanism attended sporadic servers 
highlighting features constraints designer language list summarizes important assumptions class application platform modeled 
constraints mainly imposed degree complexity implementation situations known scheduling theory handle calculate worst case response times 
limitations circumstantial just complicate presentation 
ffl tasks scheduled fixed priority technique 
fixed priority assigned scheme subtasks different priorities eventually handled 
ffl execution job task 
dynamic task creation tasks 
ffl task activities periodically awaken respond signals sporadic server scheme 
case execution capacity sporadic server worst case computation time replenish time minimum separation time 
finite bounded processing blocking abstraction eventually easily modeled 
set finite internal iteration constructs allowed level control flow abstraction considered restriction hold language expressing functionality internal actions 
ffl worst case execution time task activity exceed cycle job accumulation interruption 
task deadline requirement checked analytical tools applied model 
restriction motivated willing keeping formal modeling simpler possible instant released job associated task 
expect technique able deal bounded number launched jobs 
formal modeling constraint 
ffl mode change supported jitter clocks phase offsets supported 
run time overhead considered version notation 
ffl tasks communicate trough data abstractions operations blocking 
means exclusion operations supported operation blocked caller task unbounded amount time time outs 
ffl mutual exclusion server operations achieved trough priority ceiling protocol emulation 
means server method code executed priority slightly higher client task 
ffl support observable interruptions interruptions arrive cause immediate change activity behavior eventual return interrupted action 
general interruptions modeled sporadic scheme tasks attend waiting state delayed till moment 
preemption supported interruption 
ffl finite data domains functional description system 
guidelines formal modeling analysis key idea simplest temporal formalisms analyze conservative abstraction system behavior 
criterium called separation concerns idea away scheduler modeling just leaving influence temporal behavior system 
previously mentioned accurate modeling preemptive scheduling requires formalism deal adequately concepts elapsed executed time 
formalisms undecidable highly complex decision problems 
profit known scheduling results times estimated designer deformed analytical preprocessing conservative abstraction system behavior represented simpler formalism tasks activities treated dedicate resources 
accomplish goal getting temporal information construct formal model system need synthesized worst case response times relevant points activities 
relevant points visible actions data elements read potentially available rest application environment 
scheduling theories results mainly concerned deadline satisfaction problem pay attention calculus response times events activity 
values essential reasoning satisfaction temporal requirements 
fortunately results fixed priority scheduling tasks composed serially executed subtasks priorities deadlines analyzed 
definition tasks suits hypothesis particular case task virtually composed subtasks fixed priority represents code alternated subtasks models client code visible operations execute higher priority statically imposed pcp emulation scheme 
stage development technique assumption cycle time exceeded job effectively released previous jobs completed technique case pessimistic worst case execution times considered effective release start cycle real release calculus 
worst case response times calculated subtasks get worst case execution time visible actions release instant 
accomplish goal adaptation mentioned results see appendix 
represent system model choose fragment kernel formalism formalisms timed automata 
fragment safe nets finite data domain temporal bounds constants added time enabling tokens 
formalism express inequality linear system maximum minimum distance constraints events 
fragment expressive safe time petri nets think full automation reachability graph construction adapting existing methods 
illustrate details modeling lets observe net topology activity structure task visible actions represented transitions see 
data structures modeled high level tokens circular queue 
important note worst case response times intermediate points task relative precedent event measured release instant 
subnet augmented release places keep track release time upper bound expression time transitions need longest path visible actions set sequence activities 
task net 
model closed system obtained able ask possible controlled plant reaches dangerous state 
query reveal design errors directly related deadline meeting property reside bad treatment data 
query language include predicates data included tokens functional temporal properties studied direct integrated way temporal data coherence distributed system 
survey approaches analyze physical designs hard real time systems 
important aspects notations models highlighted ease classification 
particular point impact modeling non monolithic actions verification performance 
proposal analytical results simplify formal models increasing tractability 
proposal seen extension analytical techniques calculus relative precedence event give pessimistic results sum worst cases constituent activities greater worst case calculus activity 
sophisticated framework reasoning design properties 
currently working validating kernel formalism reachability graph generation verification process 
thinking possible ways cope sophisticated application models 
appendix adaptation calculus fixed priority scheduling fixed priority analytical techniques calculus worst case execution times task 
achieve goal interference higher priority tasks blocking effect lower priority tasks calculated trough call busy period task 
referred extend standard theory cope tasks composed subtasks different priorities 
priority profile easier calculus altering worst case response time result subtask 
having mind priority profiles constitute special case adapted original technique directly obtain intermediate subtasks 
priority profile task analysis task composed subtasks 
subtasks representing actual task code alternated subtasks representing service code reside service monitor run higher priority pcp emulation protocol 
resulting priority profile modeling constraints interruption handler context switching run time overhead key property simplifies procedure priority subtask task static priority lowest priority subtask priorities pmin pmin 
referred means difference analysis job busy period rest 
fixing task analyzed rest tasks classified types general version handles types higher priority tasks lower priority ones ones blocking segment 
calculus busy period min hp 

ceiling integer part 
hp set tasks priority greater equal priority task period task computational requirement task li number jobs executed busy period 
calculate worst case response time subtask job get maximum busy period 
recursive definition min gamma hp 
worst case response time subtask task job 
ij min ij ij mp ij 
gamma 
max 
worst case response time subtask task job 
generalization wrt original canonical form 
calculate know point jobs task executed 
surely need consider computation requirements rest jobs potentially accumulated precedent higher priority subtasks calculate worst case response time subtask 
acknowledgments due miguel mauro helpful comments 
alur courcoubetis halbwachs henzinger ho nicollin olivero sifakis yovine 
analysis hybrid systems 
theoretical computer science vol 
pp 
alur dill 
automata modeling real time systems 
proceedings international colloquium automata languages programming 
ashcroft manna 
formalization properties parallel programs 
machine intelligence vol 
pp 

audsley 
flexible scheduling hard real time systems 

thesis department computer science university york uk august 
audsley burns richardson wellings 
applying new scheduling theory static priority preemptive scheduling software engineering journal vol 
pp 
september 
audsley burns richardson wellings 
stress simulator hard real time systems 
software practice experience 
avrunin corbett 
practical technique bounding time events concurrent real time systems 
proceedings international symposium software testing analysis 
cambridge ma pp 
june 
published software engineering notes july avrunin corbett dillon 
analyzing partially implemented real time systems 
proceedings international conference software engineering pp 
may 
avrunin corbett dillon 
automated derivation time bounds uniprocessor concurrent systems 
transaction software engineering vol 
september 
weijland 
process algebra 
cambridge university press 
baker 
stack allocation policy real time processes 
proceedings th real time systems symposium pp december 

introducing formal specification methods industrial practice 
ieee international conference software engineering 
tool analysis real time specifications 
proceedings seventh international workshop software specification design 
ben abdallah si kim lee 
schedulability safety analysis graphical communicating shared resources 
ieee workshop object oriented real time systems february 
liu 
scheduling meet deadlines distributed systems 
th international conference distributed computing systems yokohama japan june 
diaz 
modeling verification time dependent systems time petri nets 
ieee transactions software engineering vol 
march 
henderson kendall robson 
designing implementing correct rts 
technical report university newcastle 
lee 
process algebra communicating shared resources dense time priorities 
technical report university pennsylvania ms cis 
calculus general needed assumption worst case response times smaller periods job executed 

tools specifying real time systems 
real time systems journal vol 
issue kluwer academic publisher march may 

compositional validation time critical systems communicating time petri nets ieee transactions software engineering vol 
december 
fisher gerber 
compositional verification model checking counter examples 
proceedings international symposium software testing analysis 
burch clarke dill 
symbolic model checking states 
proceedings th logic computer science 

un de la de 
proceedings ii de informatica pages granada pp 
july 

task system analysis slope parametric hybrid automata 
euro par workshop real time systems constraints passau germany august 
burns 
preemptive priority scheduling appropriate engineering approach 
technical report york university 
burns wellings 
hrt hood structured design method hard real time systems 
report york university real time systems journal vol 
issue january 
campos 
priority inversion problem real time symbolic model checking 
technical report carnegie mellon university cmu cs 
campos clarke 
tool quantitative analysis finite state real time systems 
proceedings sigplan 
campos grumberg 
selective quantitative analysis interval model checking verifying different facets system 
proceedings computer aided verification 
clarke lee 
xie 
versa tool specification analysis resource bound real time systems 
journal computer software engineering 
cleaveland smolka 
concurrency factory development environment concurrent systems 
proceedings computer aided verification 
chan van hung 
duration calculus specification tasks shared resources 
proceedings algorithms concurrency knowledge asian computer science conference thailand december 
lecture notes computer science springer verlag 
cheng ramamritham 
scheduling algorithms hard real time systems brief survey 
chen 
schedulability analysis resource access control protocols real time systems 
ph thesis university illinois urbana champaign 
corbett timing analysis ada tasking programs transaction software engineering vol 
july 
argenio 
katoen tretmans 
bounded retransmission protocol time 
proceedings rd international workshop tools algorithms construction analysis systems 
enschede netherlands april 
lecture notes computer science pages 

formal approach design real time systems 
included report 
hayes 
integrating real time scheduling theory program refinement 
proceedings formal methods europe oxford march 
lecture notes computer science 
cleaveland 
formal language real time schedulability analysis 
proceedings real time systems symposium pages durham north carolina december 
computer society press 
freedman 
temporal analysis object oriented real time software development case study room proceedings ieee real time technologies applications symposium boston june 
gerber hong 
guaranteeing real time requirements resource calibration periodic process 
transaction software engineering vol 
july 
ghezzi 
unified high level petri net formalism time critical systems 
transaction software engineering vol 
pp 
february 

software design methods concurrent real time systems sei series software engineering 

harbour klein lehoczky 
timing analysis fixed priority scheduling hard real time systems 
transaction software engineering vol 
pp january 
strategies real time system specification house 
new york 

henzinger nicollin sifakis yovine 
symbolic model checking real time systems 
information computation 
hill joseph 
automated timing analysis real time programs 
software engineering journal pages september 
hoare 
communicating sequential processes 
prentice hall 
stankovic 
tool real time scheduling assistance 
proceedings ieee real time system symposium 
ieee posix 
real time extensions portable operating systems ieee 

introspect technologies colorado springs 
technical overview 
introspect technologies colorado springs 
jourdan 
static timing analysis real time systems 
acm sigplan 
kang lee 
efficient state space generation analysis real time systems 
proceedings international symposium software testing analysis january 
kesten pnueli sifakis yovine 
integration graphs class decidable hybrid systems 
proceedings workshop theory hybrid systems pages lyngby denmark june 
lecture notes computer science springer verlag 
klein sha 
rate monotonic real time systems technical report sei cmu 
tr 

klein pollak harbour 
carnegie university software engineering institute 
practitioner handbook real time analysis guide rate monotonic analysis real time systems 
kluwer academic publishers 
lee gerber 
process algebraic approach specification analysis resource bound real time systems 
proceedings ieee special issue real time systems january 
lehoczky sha ding 
rate monotone scheduling algorithm exact characterization average case behavior 
proceedings th real time systems symposium december 
liu joseph 
verification schedulability real time programs 
formal aspects computing 
liu layland 
scheduling algorithms multiprogramming hard real time environment 
journal association computing machinery vol 
pp january 
liu redondo deng ha shih 
prototyping environment real time systems 
department computer science technical report uiucdcs university illinois urbana champaign may 
merlin farber 
recoverability communicating protocols 
ieee transactions communications vol 
september 
milner 
communication concurrence 
prentice hall 
olivero sifakis 
abstractions validation linear hybrid systems 
proceedings th computer aided verification pages california july 
lecture notes computer science springer verlag 

deciding properties timed transition models 
ieee transactions parallel distributed systems vol 
pp 


arc verification tool concurrent systems 
proceedings third australasian parallel real time conference brisbane australia september 
rajkumar sha lehoczky 
real time synchronization multiprocessors 
proceedings th real time systems symposium pp 
december 
crespo mok 
improvement feasibility testing real time tasks 
rts journal vol 
september 
sha rajkumar lehoczky 
priority inheritance protocols approach real time synchronization 
ieee transactions computers vol 
pp 
september 
sha real time scheduling theory ada 
ieee computer vol 
pp 
april 
sha lehoczky 
aperiodic task scheduling hard real time systems 
journal real time systems pp 

zhou hansen ravn 
duration specifications shared processors 
ieee transactions parallel distributed systems vol 
pp 

formal techniques real time fault tolerant systems vol 
lecture notes computer science springer verlag 
zhou hoare ravn 
calculus durations information processing letters december 

