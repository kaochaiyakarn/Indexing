appeared applicable algebra engineering communication computing 
veri cation erlang processes dependency pairs urgen giesl thomas arts informatik ii rwth aachen 
aachen germany mail giesl informatik rwth aachen de computer science lab ericsson ab box sweden mail thomas cslab ericsson se received date revised version date erlang functional programming language developed ericsson telecom particularly suited implementing concurrent processes 
show methods area term rewriting presently ericsson 
verify properties processes property transformed termination problem conditional term rewriting system ctrs 
subsequently termination proof performed automatically dependency pairs 
illustrates dependency pair technique applied termination proofs conditional trss 
secondly re nements technique viz 
narrowing rewriting instantiating dependency pairs 
re nements industrial applications sketched generally applicable arbitrary trss 
way dependency pairs prove termination trss automatically 
keywords veri cation distributed processes rewriting termination patent application ericsson developed protocol query lookup distributed database 
products ericsson example newer telecommunication switches database plays key role recovery shutdown crash system 
clearly critical part software trustworthy 
originates attempt verify protocol implementation written erlang 
save amount increase reliability aim perform partially supported dfg gi 
urgen giesl thomas arts possible veri cation automatically 
model checking techniques applicable properties proved require consideration nite state space processes 
user guided approach theorem proving specialized proof checking tool successful labour intensive 
describe properties veri ed sect 
sect 
respectively show represented non trivial termination problems 
general proving termination considerably dicult showing termination unconditional trss 
standard techniques see fail termination proofs required protocol veri cation described 
due complexity safety requirements arising practical applications industry high degree automation desirable termination proofs required 
reasons motivate chose apply dependency pair technique currently powerful termination proof method amenable automation 
turned extensions dependency pair technique perform required termination proofs automatically 
sect 
show termination problems reduced termination problems unconditional trss 
basic notions dependency pairs sect 
important extensions viz 
narrowing sect 
rewriting sect 
instantiating dependency pairs sect 
particularly useful context 
re nements dependency pair approach solve termination problems automatically 
process veri cation problem prove properties processes network 
process receives messages process consist list data items integer item list process computes new list data items 
example data items telephone numbers process generate list calls number certain date 
resulting list may arbitrary length including zero 
integer message indicates items newly computed list sent process restriction number items may sent imposed practical optimization reasons 
pn pn fig 
process pn network course process may computed new items case stores remaining answers accumulator implemented veri cation erlang processes dependency pairs extra argument store process 
sent rst items process process may receive new message respond new message rst checks store contains items 
case sends rst items store depending incoming message probably new items computed 
store contains fewer items process wait new items computed 
computation rst items newly obtained item list store sent items exceed limit stored process accumulator 
order empty store process repeatedly sends empty list process claim process send empty list 
describe able formally verify claim high degree automation 
erlang code executed processes save space code obvious library functions app leq 
process store receive mg case leq length store true split store mg process app map self items false split app map self items store mg process 
map pid nil nil map pid cons app pid map pid 
list split returns pair lists fl contains rst elements length shorter contains rest command denotes sending data mg stands sending items integer process identi er 
process obtain identi er calling function self 
item list items function map pid items computes new data items means function pid item 
actual computation performs depends process identi er pid 
compute new data items incoming items process pass identi er function map calls map self items 
urgen giesl thomas arts note process terminating function fact designed non terminating 
aim prove termination verify certain property expressed terms termination 
part correctness proof software prove process continuously receives message fnil mg integer eventually process send message fnil mg 
property hold independent value store way new data items generated ones 
left unspeci ed may terminating function returns list arbitrary length 
framework term rewriting useful veri cation 
prove desired property constructing ctrs containing binary function process arguments represent stored data items store integer sent messages 
example may process communication 
erlang function self constant drop send command 
argument ctrs 
assume process constantly receives message fnil mg hard code ctrs 
variable items replaced nil 
want reason variable added arguments process 
model function split returns pair lists ctrs separate functions fstsplit sndsplit components split result 
fstsplit store results rst elements store sndsplit store results rst elements store 
idea force function process terminate empty list nil 
continue computation application function empty result fstsplit yields false 
evaluations ctrs terminate original process eventually outputs demanded value 
usual semantics rule redex may reduced reduces reduces vertical bar separates conditions actual rule 
leq length store true empty fstsplit store false process store process app map self nil sndsplit store leq length store false empty fstsplit app map self nil store false process store process sndsplit app map self nil store auxiliary erlang functions functions empty fstsplit sndsplit straightforwardly expressed unconditional rewrite rules 
fstsplit nil fstsplit nil nil fstsplit cons cons fstsplit veri cation erlang processes dependency pairs sndsplit sndsplit nil nil sndsplit cons sndsplit empty nil true empty cons false leq true leq false leq leq length nil length cons length app nil app cons cons app map pid nil nil map pid cons app pid map pid rules erlang function speci ed verify desired property terminating function erlang eager call value evaluation strategy terminating erlang function straightforwardly transformed trs library functions evaluation rules nite 
prove desired property erlang process show ctrs extra rules auxiliary functions permits nite evaluations 
construction ctrs straightforward presupposes understanding program veri cation problem hardly mechanized 
obtaining ctrs proof evaluation ctrs nite done automatically 
describe extension dependency pair technique perform automatic proofs 
extension general termination proofs trss 
results signi cantly increase class systems termination shown mechanically 
termination conditional term rewriting systems ctrs trs conditions may added rewrite rules restrict variables conditions occur depending interpretation equality sign conditions di erent rewrite relations associated ctrs cf 

veri cation example transformed problem oriented ctrs equality signs conditions rewrite rules interpreted reachability 
denote rewrite rules urgen giesl thomas arts fact normal ctrs ground normal forms trs results dropping conditions 
reduction rule possible reduces formally rewrite relation ctrs de ned 
jl fl ng cf 

ctrs terminating founded 
termination ensure evaluation ctrs nite 
example assume evaluation condition leq length store ctrs require reduction process store 
evaluation process store yield nite computation 
process store rewritten ctrs terminating 
case desired property hold original erlang process correspond deadlock situation messages sent 
reason termination interested decreasing 
slightly modi ed notion evaluation strategy conditions checked left right cf 

th condition checked previous conditions hold 
de nition left right decreasing ctrs left right decreasing exists founded relation containing rewrite relation subterm relation holds rules ng substitutions 
de nition left right exactly captures niteness recursive evaluation terms 
obviously implies left right vice versa 
aim prove ctrs corresponding erlang process left right decreasing 
standard approach proving termination ctrs verify termination trs results dropping conditions impose additional demands 
approach fails conditions necessary ensure termination 
happens example conditions empty false ctrs longer terminating left right decreasing 
solution problem transform unconditional trss cf 

unconditional rules tr fl rg 
conditional rule de ne tr fl fif ng fif rg veri cation erlang processes dependency pairs tuple variables new function symbols 
ease readability just write function symbol 
tr tr 
extra variables tr unconditional trs 
extension deterministic extra variables possible 
transformation rule results process store store leq length store store true store empty fstsplit store store false process app map self nil sndsplit store aim prove termination tr left right 
transformation restricted limited class convergent 
show purpose restriction necessary 
words termination tr implies left right termination transformation generally applicable technique reduce termination problem termination problem unconditional trss 
similar approach proofs left right transformation conditions rule checked parallel 
rst prove reduction simulated tr particular equational theory subset tr equational theory 
lemma terms 
tr proof depth reduction 
prove theorem induction depth length reduction lexicographic induction relation 
reduction form induction hypothesis know tr suces prove tr reduction done unconditional rule conjecture trivial 
context rule 
depth reductions depth reduction induction hypothesis tr 
implies tr ut desired result direct consequence lemma 
corollary left right termination tr tr terminating left right decreasing terminating 
proof known tr founded tr founded direct consequence tr closed context transitive closure tr founded 
urgen giesl thomas arts lemma relation satis es conditions imposed relation def 

left right decreasing 
ut converse corollary hold 
ctrs conditional rule holds transformed trs tr original ctrs 
transformed trs tr terminating original ctrs left right decreasing 
independently transformation studied ohlebusch prove restricted completeness result transformation viz 
left right implies innermost termination tr 
notion left right called quasi 
example conditional rule transformed additional unconditional rules 
apart root symbol righthand side rst rules identical 
obtain overlapping rules transformed trs correspond overlapping conditional rules 
ctrs critical pair infeasible conditions rules exclude 
transformation trss introduces unnecessary rules overlap 
construct rule form exists rule identify ect soundness approach termination trs occurrences symbol substituted symbol arity implies termination original trs 
obtain additional rules store false store empty fstsplit app map self nil store store false process sndsplit app map self nil store termination ctrs depends conditions general termination transformed trs shown examines terms may follow reduction 
classical approaches simpli cation orderings cf 
considerations take place 
fail proving termination 
reason transformations unconditional trss rarely applied termination proofs 
demonstrate dependency pair approach transformation useful 
possibility eliminate unnecessary overlap advantage transformation compared transformed unconditional trss remain overlapping 
practice proving termination non overlapping trss signi cantly easier may techniques speci cally tailored innermost termination proofs see 
veri cation erlang processes dependency pairs verify original goal prove termination transformed trs consists rules auxiliary library functions sect 
unknown rules unspeci ed function note auxiliary erlang function straightforwardly transformed trs trs non overlapping 
assume possible rules unspeci ed function non overlapping 
sucient just prove innermost termination resulting trs innermost termination non overlapping systems implies termination cf 

order apply veri cation large scale aim perform proofs automatically 
rest extensions dependency pair technique possible 
dependency pair technique including extensions implemented tool written erlang provides user friendly interface manual applications dependency pairs possibility perform fully automatic termination proofs trss dependency pairs 
see collection benchmarks demonstrate power dependency pair approach 
dependency pairs dependency pairs allow existing methods simpli cation orderings automated termination innermost termination proofs applicable 
section brie recapitulate basic concepts approach theorems need rest 
details explanations see 
contrast standard approaches termination proofs compare left right hand sides rules examine subterms responsible starting new reductions 
purpose concentrate subterms right hand sides rules de ned root symbol terms rewrite rule applied 
precisely rule de ned symbols compare argument tuples avoid handling tuples de ned symbol introduce fresh tuple symbol ease readability assume original signature consists lower case function symbols tuple symbols denoted corresponding upper case symbols 
tuples compare terms 
de nition dependency pair trs 
rule de ned symbol hf dependency pair root symbols left hand sides de ned functions constructors 
urgen giesl thomas arts rules obtain dependency pairs 
store store leq length store hif store true store empty fstsplit store hif store false process app map self nil sndsplit store hif store false store empty fstsplit app map self nil store hif store false process sndsplit app map self nil store trace newly introduced redexes innermost reduction consider special sequences dependency pairs called innermost chains 
sequence dependency pairs hs hs innermost chain exists substitution consecutive pairs hs hs sequence 
denotes innermost reductions rewrite steps innermost redexes contracted 
way right hand side dependency pair seen newly introduced redex traced reductions necessary normalize arguments redex traced 
note regarding innermost reductions arguments redex normal form redex contracted 
may restrict substitutions normal form 
de nition innermost chains trs 
sequence dependency pairs hs hs called innermost chain exists substitution normal form holds consecutive pairs hs hs sequence 
assume di erent occurrences dependency pairs disjoint variables regard substitutions domains may nite 
showed absence nite innermost chains sucient necessary criterion innermost termination 
theorem innermost termination criterion trs innermost terminating exists nite innermost chain 
improve criterion introduced graph contains arcs dependency pairs may follow innermost chains 
de nition innermost dependency graph innermost dependency graph trs directed graph nodes dependency pairs arc hs ti hv wi hs ti hv wi innermost chain 
veri cation erlang processes dependency pairs example arcs 
subgraph innermost dependency graph containing nodes depicted 
fig 
subgraph innermost dependency graph example innermost dependency graph general computable estimation graph automation purposes cf 

estimation arcs original graph estimated graph 
cap result replacing subterms de ned root symbols di erent fresh variables 
estimated innermost dependency graph directed graph nodes dependency pairs arc hs ti hv wi cap uni able mgu normal forms 
dicult see hs ti hv wi innermost chain arc hs ti hv wi estimated innermost dependency graph 
estimated graph supergraph real innermost dependency graph 
non empty set dependency pairs called cycle hs ti hv wi path hs ti hv wi innermost dependency graph traverses pairs obviously cycle graph cycle estimated innermost dependency graph 
example dependency pairs form cycles cycle dependency pair dependency pairs rules auxiliary library functions unspeci ed function assume call process 
leads re ned criterion 
theorem modular innermost termination criterion nite trs innermost terminating cycle innermost dependency graph exists nite innermost chain dependency pairs note soundness theorem regard cycles just minimal ones just cycles contain urgen giesl thomas arts cycles proper subsets 
example trs rules dependency pairs hf hf hg cycles nite innermost chain minimal cycles trs innermost terminating nite innermost chain non minimal cycle de nition cycle set dependency pairs 
cycle contains multiple occurrences dependency pair nite trs exist nitely cycles automation dependency pair technique generation inequalities 
cycle estimated graph search quasi ordering sequence dependency pairs hs substitution hs ti demand strict inequality 
founded ordering compatible 
exists innermost chain dependency pairs traverses dependency pairs nitely times 
require closed substitution 
ensure respectively substitutions 
restrict weakly monotonic quasi orderings 
quasi ordering weakly monotonic implies 
guarantee holds sucient demand rules trs may reduction 
restrict normal substitutions rules usable reduction 
general contains de ned symbol rules usable rules usable right hand sides rules usable de nition usable rules trs 
symbol rls fl root fg 
term de ne usable rules ur ur rls ur ur rls 
set dependency pairs de ne ur hs ti ur 
veri cation erlang processes dependency pairs note recursive de nition decreasing second equation de ning ur 
obtain theorem automated innermost termination proofs 
theorem innermost termination proofs nite trs innermost terminating cycle weakly monotonic founded ordering compatible closed substitution rules ur dependency pairs hs ti dependency pair hs ti demonstrated thm 
thm 
considering just minimal cycles unsound 
fact thm 
unsound just consider maximal cycles cycles contained cycle 
problem suf cient just dependency pair maximal cycle strictly decreasing 
strictly decreasing dependency pair subcycle 
counterexample regard trs 
maximal cycle fhf hf ig 
constraints cycle easily ful lled trs clearly innermost terminating 
crucial consider cycles thm 

sect 
rules auxiliary functions process example 
proving absence nite innermost chains cycles dependency pairs straightforward thm 

library functions trs innermost terminating 
assumed terminating function cycles lead nite innermost chains 
recall cycles remaining dependency pairs 
left verifying desired property proving absence nite innermost chains cycles rules trs possible candidates usable rules rules unspeci ed function 
thm 
demands resp 
dependency pairs hs ti cycles 
inequalities satis ed quasi simpli cation ordering 
automated proof fails 
unclear inequalities add usable rules rules 
extend dependency pair technique 
additional re nements automation 
essentially reason left hand side dependency pair embedded right hand sides pairs 
urgen giesl thomas arts narrowing dependency pairs prove absence nite innermost chains dependency pair hv wi sucient demand resp 
just instantiations instantiated right component previous dependency pair hs ti reduces 
example regarded instantiations instantiated right component store empty fstsplit store reduces instantiated left component store false 
fact happen store empty store reduces form cons 
observation inequalities thm 
nd ordering 
idea perform computation empty level dependency pair 
purpose known concept narrowing extended pairs terms 
de nition trs 
term narrows term substitution pair terms hs ti narrows pair hs usually speak narrowing narrowing trs clear context 
example dependency pair hif true empty nil hif nil true nil empty nil hif cons true cons empty cons fstsplit dependency pair hs ti followed dependency pairs hv wi innermost chain uni able rule needed reduce order approximate possible reductions may replace hs ti 
replace dependency pair new pairs contain hidden step reduction 
enables extract necessary information arguments conditions ctrs 
narrowing re nement main reason transformation trss useful analyzing termination behaviour dependency pairs 
number pair nite variable renaming easily computed automatically 
note narrowing may applied dependency pairs right hand side unify left hand side dependency pair variable renaming 
example regard trs 
veri cation erlang processes dependency pairs trs innermost terminating nite innermost reduction dependency pairs cycle hg hh dependency pair narrowed hh cycle innermost dependency graph falsely conclude innermost termination 
example demonstrates requirement necessary restrict non overlapping systems 
showing narrowing helps solving inequalities process example rst prove soundness technique 
theorem narrowing pairs set pairs terms hs ti var var renamings hv wi terms uni able 
result replacing hs ti 
exists nite innermost chain pairs exists nite innermost chain pairs 
proof suppose innermost chain hv hs ti hv pairs suces prove exists narrowing hs hs ti hv hs hv innermost chain 
hs ti resp 
hs may rst pair chain hv may missing 
proved occurrences hs ti nite innermost chain may replaced pairs innermost chain substitution instantiated left hand sides pairs normal forms instantiated right hand side reduces innermost instantiated left hand side pair innermost chain 
note equal uni er term reduction take place variables contained normal form 
contains subterm rule applied 
words matches 
reduction form usual de nition narrowing assume variables renamed fresh ones 
extend behave variables remains variables pairs innermost chain 
uni er exists general uni er 
de nition general uni ers substitution urgen giesl thomas arts term 
hs ti narrows hs may assume variable disjoint pairs may extend behave variables hv hs hv innermost chain 
ut may replace dependency pair 
re nement sound general destroys necessity innermost termination criterion thm 

example trs rules innermost terminating 
dependency pair hf replaced hf hf hf forms nite innermost chain instantiation fx 
application domain process veri cation restrict trss unique normal form property 
fact trss resulting translation erlang functions nonoverlapping 
non overlapping innermost terminating trss con uent satisfy unique normal form property 
requirement unique normal form property theorem replaced non 
theorem shows trss narrowing dependency pairs completeness preserving technique 
precisely innermost termination proved pairs proved pairs theorem narrowing pairs preserves completeness innermost terminating trs unique normal form property thm 

exists nite innermost chain pairs exists nite innermost chain pairs 
proof show innermost chain hv hs hv transformed innermost chain length 
substitution pairs instantiated lefthand side normal form instantiated right hand side reduces instantiated left hand side pair innermost chain 
particular trs said unique normal form property term normal form veri cation erlang processes dependency pairs know hs ti narrows hs substitution 
variables hs ti disjoint variables may extend behave variables 
de nition narrowing implies normal form 
innermost terminating term unique normal form repeated application innermost reduction steps yields normal form 
hv hs ti hv innermost chain 
ut independent technique check absence nite innermost chains trss unique normal form property narrowing dependency pairs preserves success innermost termination proof 
may narrow dependency pairs risk new pairs obtain form nite innermost chain original system innermost terminating 
thm 
replacing dependency pairs obtains sucient necessary criterion innermost termination 
narrowing course repeated arbitrary number times 
replacing may subsequently replace respective 
hif true true aa hif nil true nil true ba excludes cycle estimated innermost dependency graph 
dependency pairs consider 
narrowing necessary purposes thm 
harm 
right component dependency pair uni es left component narrowed 
narrow 
nil nil leq cons cons leq length store store true narrowing determined regard instantiations store form cons form 
occur cycle replaced 
right component unify left components longer may narrow 
repeated narrowing steps dropping pairs occur cycles replaced hif cons false process sndsplit aac urgen giesl thomas arts hif cons false process app nil sndsplit ad hif cons false process app map self nil sndsplit cycle example sucient demand aac ad strictly decreasing usable rules weakly decreasing 
similar applied pairs results analogous inequalities cycles standard orderings amenable automation strongly monotonic path orderings cf 
need weak monotonicity 
synthesizing suitable ordering arguments function symbols may eliminated cf 

example inequalities may eliminate third argument term inequalities replaced new binary function symbol 
comparing terms resulting replacement original terms take advantage fact strongly monotonic third argument 
similarly example eliminate third arguments rst argument sndsplit 
note nitely possibilities eliminate arguments function symbols 
possibilities checked automatically 
way recursive path ordering rpo satis es inequalities aac dependency pairs resulting known usable rules 
inequalities resulting ad cons process app nil sndsplit cons process app map self nil sndsplit satis ed app terms right hand sides app rules force app greater cons precedence rpo 
map term inequalities requires consider usable rules corresponding unspeci ed erlang function 
get rid terms perform narrowing map app 
general narrowing subterms right components unsound 
replace pair 
narrowing ad provides solution narrowing sndsplit subterm results pairs containing problematic app map terms 
section describe technique solves problem 
example regard trs 
replace dependency pair hg viz 
hg falsely prove innermost termination term starts nite innermost reduction 
veri cation erlang processes dependency pairs rewriting dependency pairs performing narrowing steps unsound non overlapping trss sound perform possible rewrite steps 
may replace dependency pair hs ti hs ri 
note technique applicable dependency pairs rules trs 
reducing right hand side rule non innermost terminating trs transformed terminating trs non overlapping 
example regard trs rules clearly innermost terminating 
right hand side rst rule rewritten resulting trs terminating 
theorem proves re nement dependency pair approach sound 
theorem rewriting pairs non overlapping set pairs terms 
hs ti result replacing hs ti hs ri 
exists nite innermost chain pairs exists nite innermost chain 
proof replacing renamed occurrences hs ti corresponding renamed occurrences hs ri innermost chain hs ti hv wi translated innermost chain length 
reason substitution normal form 
weakly innermost terminating non overlapping thm 
con uent terminating 
obtain 
terminating reduces innermost normal form con uence implies 
hs ri hv wi innermost chain 
ut theorem enables perform rewrite step right hand side dependency pair continue dependency pair original 
note weakening thm 
just demanding innermost con uence non possible allow innermost reductions right hand side dependency pair 
counterexample consider trs innermost con uent innermost terminating starts cycling reduction set dependency pairs forms nite innermost chain 
perform innermost rewrite step dependency pair hh replaced hh resulting set pairs nite innermost chains falsely conclude innermost termination 
call term innermost terminating innermost reductions starting nite 
analogously weakly innermost terminating exists nite innermost reduction starting urgen giesl thomas arts demand trs non overlapping may weakened demanding innermost normal form preserving term holds normal form non overlapping trss innermost normal form preserving vice versa consider 
practice version thm 
important usually easier show trs non overlapping innermost normal form preserving 
converse thm 
holds obtained dependency pairs repeated narrowing rewriting steps 
similar narrowing rewriting dependency pairs preserves necessity criterion 
theorem rewriting pairs preserves completeness innermost terminating trs unique normal form property thm 

exists nite innermost chain pairs exists nite innermost chain pairs 
proof innermost chain hs ri hv wi replacing renamed occurrences hs ri corresponding renamings hs ti yields innermost chain length 
reason 
innermost terminating normal form reachable innermost reduction steps implies unique normal form property 
ut example may eliminate app map rewriting pairs ad 
better narrowing rst rewrite 
simplify rewriting 
resulting pairs cycles interested cons cons leq length hif cons true cons false hif store false process sndsplit store hif store false store empty fstsplit store hif store false process sndsplit store analogous sect 
narrow perform rewrite step delete resulting pairs cycle 
way replaced hif cons false process sndsplit hif cons false cons false hif cons false process sndsplit eliminating rst argument sndsplit third arguments cf 
sect 
obtain inequalities 
note veri cation erlang processes dependency pairs thm 
inequalities prove absence nite innermost chains cycles built cycles dependency pairs strictly decreasing 
process cons cons cons cons cons cons cons process sndsplit cons process sndsplit sndsplit sndsplit nil nil sndsplit cons sndsplit rules root inequalities satis ed rpo 
sndsplit leq length inequalities ones correspond usable rules rules map longer usable 
trs sect 
innermost terminating 
way left right ctrs sect 
proved automatically 
desired property holds original erlang process 
verifying networks processes applications interested verifying certain properties single process network wants verify property network processes 
processes asynchronously exact order messages passed network 
modelling kind behaviour usually results trss overlapping fact con uent 
section extend known result innermost termination non overlapping trss implies termination class overlapping trss result describing process networks framework 
show techniques narrowing rewriting dependency pairs applied overlapping trss 
introduce third technique modify dependency pairs viz 
instantiating dependency pairs particularly useful dealing non con uent trss 
extensions show important property network erlang processes successfully veri ed 
veri cation problem ring asynchronous processes similar process described sect 

aim prove rst process disregards input performs repeatedly gets empty list input eventually third process send empty list 
course prove ring processes similar proof number processes works analogously 
urgen giesl thomas arts model situation ctrs similar sect 

regard processes simultaneously need new de ned symbol ring describe current state network 
term ring st st st describes situation stores processes values st st st respectively 
variable list lists containing messages sent process process received process 
similarly list messages sent process process received process 
messages sent process process ignored veri cation problem assume process receives new input 
maximum length messages allowed 
order prove desired conjecture force reduction terminate soon processes ring send empty message 
addition auxiliary functions sect 
need functions head tail de ned rules 
head cons tail cons ctrs describe behaviour processes ring 
empty fstsplit st false ring st st st ring sndsplit st cons fstsplit st st st leq length st true empty fstsplit st false ring st st st ring st sndsplit st cons fstsplit st st leq length st false empty fstsplit app map head st false ring st st st ring st tail sndsplit app map head st cons fstsplit app map head st st veri cation erlang processes dependency pairs empty map head true ring st st st ring st tail st st leq length st true empty fstsplit st false ring st st st ring st st sndsplit st leq length st false empty fstsplit app map head st false ring st st st ring st st tail sndsplit app map head st empty map head true ring st st st ring st st tail st rule describes process sends message consisting rst items store st fstsplit st added items sent input process received process 
rst items taken store st new value sndsplit st 
rules describe case process sends message 
store contains items rule applies rst items fstsplit st directly sent process items removed store 
st contains items rule receive incoming messages replaced tail 
received items head process computes new items map head appends newly computed items store 
sends rst items new extended store process 
rule deletes messages process generate new items map head empty 
rule required order allow process continue receiving messages tail fstsplit app map head st empty 
similarly rules describe sending messages process 
di erence messages sent process delivered process ignored 
analogous rule rule remove messages process compute new items 
ring term irreducible soon processes send non empty message longer 
urgen giesl thomas arts prove desired conjecture show ctrs left right decreasing 
note ctrs models asynchronous behaviour processes 
reason determine order processes send messages process ring 
consequently translation ctrs yields non con uent unconditional trs 
trs 
abbreviates arguments st st st 
ring empty fstsplit st false ring sndsplit st cons fstsplit st st st ring leq length st true empty fstsplit st false ring st sndsplit st cons fstsplit st st false empty fstsplit app map head st false ring st tail sndsplit app map head st cons fstsplit app map head st st ring empty map head true ring st tail st st ring leq length st true empty fstsplit st false ring st st sndsplit st false empty fstsplit app map head st false ring st st tail sndsplit app map head st ring empty map head true ring st st tail st corollary suces show trs terminating 
note trs obviously simply terminating 
example adding embedding rules fstsplit st st sndsplit st st empty cons rst rules obtain cycling reduction ring false st st 
veri cation erlang processes dependency pairs fact prove termination trs dependency pair approach combination simpli cation orderings need re nements narrowing rewriting dependency pairs 
recall re nements theorems restricted innermost termination proofs 
example sect 
resulting trs nonoverlapping innermost termination conclude termination 
trs con uent existing results proving termination innermost termination applicable 
theorem shows trss example innermost termination implies termination 
note trs hierarchical combination non overlapping trs de nes auxiliary functions overlapping trs ring rules describe network veri cation problem 
fact trss form occur frequently process veri cation domain auxiliary erlang functions result non overlapping rules description asynchronous process network requires overlapping rules 
theorem gives syntactical characterization trss shows systems innermost termination implies termination 
theorem important result order facilitate termination proofs 
theorem suciency innermost termination non overlapping non collapsing rules form critical pairs rules 
contain root symbols left right hand sides rules froot froot rule contains symbols rule contains symbols root level innermost termination implies termination proof ground term write provided non empty context contain symbols root level provided root easy see possibilities case speak bottom rewrite step ii fs ft case speak top rewrite step iii case top collapsing rewrite step 
reason reducing term root yields term root symbols occur root level rule root redex really step form ii iii 
urgen giesl thomas arts assume innermost terminating terminating 
minimal ground term subterm relation starts nite reduction 
context due minimality subterms terminating 
nite reduction top collapsing rewrite step nitely bottom rewrite steps 
starts nite reduction 
words terminating exists non terminating context contain symbol root level 
standard notation denote context context just term possibly containing symbols 
suppose contain symbol 
rules applicable reduction innermost termination implies innermost reductions starting nite 
innermost terminating non overlapping thm 
know terminating yields contradiction 
innermost termination fact implies termination terms symbols 
suppose root form terms symbols 
nite reduction form 
terms contain symbols substitutions rules substitution 
terms symbols normal form de ned terms terminating nonoverlapping 
form critical pairs rules convergence terms symbols 
implies terminating innermost steps reduce normal form steps reduction innermost steps arguments normal form 
reduction nite innermost reduction yields contradiction innermost termination ut example innermost termination transformed trs implies termination trs implies left right original ctrs 
way property process network proved 
veri cation erlang processes dependency pairs indicated perform innermost termination proof need re nements narrowing rewriting dependency pairs 
trs con uent purpose techniques extended overlapping trss 
turns extension possible theorems fact sucient demand non resp 
unique normal form property just usable rules trs example usable rules ring cycles consist rules auxiliary functions rules usable 
demonstrated sect 
auxiliary rules nonoverlapping 
extensions theorems allow apply new techniques trss 
way conjectures asynchronous networks processes veri ed dependency pairs 
theorem completeness narrowing non con uent systems innermost terminating trs thm 
unique normal form property 
exists nite innermost chain pairs exists nite innermost chain pairs 
proof proof similar thm 

di erence proof implies normal form 
reason innermost termination implies exist normal form note rules reduction contained 
unique normal form property conclude 
ut theorem rewriting pairs non con uent trss trs set pairs terms non overlapping 
hs ti result replacing hs ti hs ri 
exists nite innermost chain pairs exists nite innermost chain 
proof proof similar proof thm 

extra observation needed implies rules applicable reduction contained 
apply thm 
conclude termination con uence 
rules applicable reductions contained means terminating con uent 
rest proof identical thm 

ut theorem completeness rewriting non con uent trs innermost terminating trs thm 
unique normal form property 
exists nite innermost chain pairs exists nite innermost chain pairs 
urgen giesl thomas arts proof changes proof thm 
similar proof thm 

normal form innermost termination implies normal form reduction steps rules 
unique normal form property implies ut note re ned theorems handle trss di erent equivalent symbols identi ed cf 
sect 

practice identi cation useful simpli es trss considerably 
particular due extended theorems may apply narrowing rewriting dependency pairs resulting rules 
dependency pair resulting rule cycle narrowing rewriting dependency pair deleting resulting pairs cycles yields cons cons false regard dependency pair hif ring resulting rule 
perform narrowing dependency pair 
possible right hand side uni es lefthand sides dependency pairs resulting rules 
fact problem typical regarding overlapping trss 
pair may occur hif ring innermost chain 
regarding immediately sees regard instantiations hif ring st replaced cons replaced 
recall estimating innermost dependency graph dependency pair hs ti check renamings dependency pairs hv wi cap uni es mgu satisfy additional normality condition 
cap results replacing subterms de ned root symbols di erent fresh variables 
mgu terms form cap 
may replace dependency pair hs ti instantiations hs 
hs specializations instantiations ones needed nite innermost chains 
leads technique instantiating dependency pairs 
theorem instantiating pairs set pairs terms hs ti var var hv wi fhs tig fhs mgu cap hv wi pg assume di erent occurrences pairs variable disjoint 
exists nite innermost chain pairs exists nite innermost chain pairs veri cation erlang processes dependency pairs proof hv hs ti hv innermost chain exists substitution 
form context contains de ned symbols de ned root symbol 
reductions take place normal form know cap fresh variables 
modi cation obtain cap cap uni able 
mgu cap exists substitution variables occurrences pairs may assumed disjoint may modify behave variables hs 
hv hs hv innermost chain 
way replace occurrences hs ti innermost chains pairs rst pair chain 
hs ti hv hv nite innermost chain hv hv nite innermost chain 
deleting possibly remaining rst occurrence hs ti nite innermost chain transformed nite innermost chain direction hs innermost chain 
di erent occurrences dependency pairs may assumed variable disjoint extend substitution behave variables direction theorem immediately proved 
ut remarked technique instantiating dependency pairs termination innermost termination proofs 
dependency pairs arbitrary termination proofs prove absence nite chains innermost chains hs hs chain exists substitution consecutive pairs hs hs cf 

ren result renaming occurrences variables fresh variables particular di erent occurrences variable renamed di erent new variables 
fhs tig fhs mgu ren cap hv wi pg exists nite chain pairs exists nite chain pairs proof similar proof thm 

di erence write contains de ned symbols variables de ned root symbol variables 
know ren cap fresh variables 
rest proof completely analogous 
example right hand side pair cap uni es left hand side st st st false dependency pair rule cons st st false pair 
urgen giesl thomas arts instantiate st cons dependency pair hif ring rule 
subsequent rewriting yields hif cons false ring sndsplit dependency pair resulting rule cycle leq length st dependency pair hif rule proceed similar way rule yields hif cons true cons false rule gives rise dependency pair hif ring dependency pair may precede innermost chains 
instantiation technique st replaced cons replaced 
subsequent rewriting yields hif st cons ring st sndsplit dependency pair hif rule yields narrowing 
hif st cons st cons dependency pair resulting rule regard instantiation replaced cons 
rewriting pair yields hif st cons ring st similarly narrowing dependency pair rule yields st cons st cons dependency pair hif ring rule regarded instantiation cons rewriting results hif st cons ring st dependency pairs resulting rules proceed analogous way obtain pairs similar 
resulting constraints dependency pair approach satis ed lexicographic path ordering lpo eliminates arguments symbols rst argument sndsplit bene fact symbols strongly monotonic arguments 
way dependency pairs weakly decreasing ones ring term right component strictly decreasing 
precedence lpo ring symbols equally great tuple symbols veri cation erlang processes dependency pairs greater lower case symbols 
course assume rules function weakly decreasing lpo 
reason consider problem non empty lists processed rules usable 
soon actual rules function determined weak checked 
section demonstrated asynchronous networks described non con uent trss proving innermost termination sucient termination proof 
subsequently shown techniques rewriting narrowing dependency pairs extended trss just usable rules rules auxiliary functions satisfy non requirements 
introduced third technique manipulating dependency pairs viz 
instantiation 
way dependency pairs prove statements asynchronous networks processes 
shown dependency pair approach successfully applied process veri cation tasks industry 
motivated speci process veri cation problems developed techniques general term rewriting 
showed dependency pairs utilized prove conditional term rewriting systems decreasing terminating 
re nements considerably increase class systems dependency pairs successful 
rst re nement narrowing dependency pairs innermost termination introduced 
contain explicit proof soundness completeness technique trss unique normal forms new result 
ensures application narrowing technique preserves success innermost termination proof 
fact narrowing re nement main reason approach handling transforming trss successful combination dependency pair approach transformation usually standard termination proving techniques 
strengthen power dependency pairs introduced novel technique rewriting dependency pairs proved soundness completeness innermost termination non overlapping trss 
re nement instantiating dependency pairs showed lift non restrictions narrowing rewriting dependency pairs order apply techniques non con uent trss 
developed new syntactical characterization class possibly uent trss innermost termination implies termination captures rewrite systems describing asynchronous process networks 
substantially revised extended version 
urgen giesl thomas arts note modularity results dependency pair technique split conquer approach dealing incompleteness speci cation 
reasons practice rule exception speci cation lacks information de nition function example 
usually certain level abstraction stops specifying built functions speci cation preferably hidden add date time stamp message cases computation date relevant 
assuming properties missing part speci cation proving part available sense 
context modularity dependency pair technique great help 
techniques shown successfully applicable small real examples eventuality properties proved 
experiences demonstrate approach particularly useful verifying properties processes lot data manipulation involved communication plays minor role 
typically properties hard handle model checking 
examples represent situations model checking arbitrary lengths stores 
problems tackled specialized proof checker erlang 
compared dependency pairs proof checker approach generally applicable 
approach proofs great extend provided hand dependency pair approach important advantage better suitable automation 

arts dam verifying distributed database lookup manager written erlang 
proc 
fm toulouse france 
lncs vol 
pp 

springer 
arts giesl automatically proving termination simpli cation orderings fail 
proc 
tapsoft lille france 
lncs vol 
pp 

springer 
arts giesl proving innermost normalisation automatically 
proc 
rta spain 
lncs vol 
pp 

springer 
arts giesl termination term rewriting dependency pairs 
technical report darmstadt university technology germany 
www informatik rwth aachen de giesl papers ps 
arts giesl modularity termination dependency pairs 
proc 
rta tsukuba japan 
lncs vol 
pp 

springer 
arts giesl veri cation erlang processes 
proc 
th international workshop termination dagstuhl germany 

arts giesl applying rewriting techniques veri cation erlang processes 
proc 
csl madrid spain 
lncs vol 
pp 

springer 
arts giesl termination term rewriting dependency pairs 
tcs 
preliminary extended version appeared 
veri cation erlang processes dependency pairs 
arts system description dependency pair method 
proc 
rta uk 
lncs vol 
pp 

springer 
baader nipkow term rewriting 
cambridge university press 
bergstra klop conditional rewrite rules con uence termination 
jcss 
ganzinger completion time optimization rewrite time goal solving 
proc 
rta chapel hill usa 
lncs vol 
pp 

springer 
dershowitz plaisted equational programming 
machine intelligence 
dershowitz termination rewriting 

dershowitz okada sivakumar canonical conditional rewrite systems 
proc 
cade argonne usa 
lncs vol 
pp 

springer 
dershowitz okada rationale conditional equational programming 
tcs 
dershowitz jouannaud rewrite systems 
handbook theoretical computer science vol 
pp 

elsevier 
dershowitz natural termination 
tcs 

notes eliminations conditions 
proc 
ctrs orsay france 
lncs vol 
pp 

springer 
gramlich termination con uence conditional rewrite systems 
proc 
ctrs jerusalem israel 
lncs vol 
pp 

springer 
gramlich relations restricted termination con uence properties rewrite systems 
fundamenta informaticae 
gramlich termination con uence properties structured rewrite systems 
phd thesis 
universit kaiserslautern germany 
gramlich termination con uence properties disjoint constructor sharing conditional rewrite systems 
tcs 
patent pending ericsson telecom ab 
kamin levy generalizations recursive path ordering 
department computer science university illinois il 
jouannaud reductive conditional term rewrite systems 
rd ifip working conference formal description programming concepts denmark 
pp 


kaplan conditional rewrite rules 
tcs 
marchiori ultra properties 
proc 
alp aachen germany 
lncs vol 
pp 

springer 
middeldorp modular properties conditional term rewriting systems 
information computation 
ohlebusch transforming conditional rewrite systems extra variables unconditional systems 
proc 
lpar georgia 
lnai vol 
pp 

springer 

steinbach simpli cation orderings history results 
fundamenta informaticae 
suzuki middeldorp ida level con uence conditional rewrite systems extra variables right hand sides 
proc 
rta kaiserslautern germany 
lncs vol 
pp 

springer 
wirth gramlich constructor approach positive negative conditional equational speci cations 

