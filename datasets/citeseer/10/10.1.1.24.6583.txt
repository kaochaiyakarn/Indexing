computing diameter constrained minimum spanning tree parallel deo abdalla school computer science university central florida orlando fl usa deo abdalla cs ucf edu 
minimum spanning tree mst small diameter required numerous practical situations 
needed example distributed mutual exclusion algorithms order minimize number messages communicated processors critical section 
diameter constrained mst dcmst problem stated follows undirected edge weighted graph nodes positive integer find spanning tree smallest weight spanning trees contain path edges 
problem known npcomplete values 
depend heuristics live approximate solutions 
explore heuristics dcmst problem time algorithm constructs dcmst modified greedy fashion employing heuristic selecting edges added tree stage tree construction 
algorithm fast easily parallelizable 
particularly suited specified values small independent second algorithm starts unconstrained mst iteratively refines replacing edges long paths path left edges 
heuristic better suited larger values discuss convergence relative merits parallel implementation heuristics maspar mp massively parallel simd machine processors 
extensive empirical study shows heuristics produce solutions wide variety inputs 
diameter constrained minimum spanning tree dcmst problem stated follows undirected edge weighted graph positive integer find spanning tree smallest weight spanning trees contain path edges 
length longest path tree called diameter tree 
garey johnson show problem np complete transformation exact cover sets 
denote number nodes problem solved polynomial time special cases edge weights identical 
cases np complete 
consider graph complete nodes 
incomplete graph viewed complete graph missing edges infinite weights 
eds lncs pp 

springer verlag berlin heidelberg deo abdalla dcmst problem arises applications distributed mutual exclusion message passing 
example raymond algorithm imposes logical spanning tree structure network processors 
messages passed processors requesting entrance critical section processors granting privilege enter 
maximum number messages generated critical section execution diameter spanning tree 
small diameter essential efficiency algorithm 
minimizing edge weights reduces cost network 
satyanarayanan muthukrishnan modified raymond original algorithm incorporate executed fairness criterion prevent starvation messages process 
subsequent distributed algorithm readers writers problem multiple nodes need access shared serially reusable resource 
algorithm number messages generated read operation write operation upper bound respectively 
distributed mutual exclusion wang lang token algorithm solving entry critical section problem maximum processes allowed critical section time 
node owns tokens system may enter critical section broadcast request nodes tokens 
request passes pd messages 
dcmst problem arises linear networks multi cast calls sent source multiple destinations 
desirable short spanning tree transmission minimize interference network 
algorithm bala decomposed lln edge disjoint trees spanning tree 
algorithm builds trees small diameter computing trees maximum node degree parameter optimizing diameter directly 
furthermore lines network assumed identical 
lln lines different bandwidths lines higher bandwidth included spanning trees traffic 
employing algorithm solves dcmst problem help find better tree decomposition type network 
network modeled edge weighted graph edge weight represent line bandwidth exact solution algorithms dcmst problem developed branch bound methods reduce number subproblems 
algorithms implemented sun sparc ii workstation operating mips 
algorithms tested complete graphs different orders cases order edge weights randomly generated numbers 
best algorithm produced exact solution second average took average seconds 
clearly exact algorithms exponential time complexity suitable graphs thousands nodes 
large graphs abdalla fast approximate algorithm 
algorithm computed unconstrained mst iteratively refined increasing weights log edges near center tree recomputing mst diameter constraint achieved 
algorithm able produce dcmst reproduced spanning trees considered earlier iterations entering infinite cycle 
computing diameter constrained minimum spanning tree parallel general method evaluating solutions dcmst problem section 
approximate algorithms solving problem employing distinct strategies time tree construction ottc iterative refinement ir 
ottc algorithm prim algorithm section 
special ir algorithm general sections respectively 
evaluating quality dcmst exact dcmst weights determined reasonable amount time large graphs ratio computed weight dcmst unconstrained mst rough measure quality solution 
obtain crude upper bound dcmst weight diameter constraint observe dcmst dcmst feasible grossly suboptimal solutions dcmst 
polynomial time exact algorithms dcmst dcmst solutions upper bounds weight approximate dcmst 
addition develop special approximate heuristic dcmst compare weight dcmst verify provides tighter bound produces better solution 
upper bounds ratio unconstrained mst weight evaluate quality dcmst obtained 
special ir heuristic dcmst special algorithm compute dcmst starts optimal dcmst replaces higher weight edges smaller weight edges allowing diameter increase 
exact dcmst computation clearly dcmst graph node degree nodes call edge central edge spanning tree 
construct dcmst select edge central edge node include spanning tree smaller edges 
get optimal dcmst compute spanning trees edge central edge take smallest weight 
edges choose compute different spanning trees 
trees requires comparisons select 
total number comparisons required obtain optimal dcmst deo abdalla approximate dcmst computation compute dcmst start optimal dcmst 
relax diameter constraint reducing spanning tree weight edge replacement get smaller weight dcmst 
refinement process starts arbitrarily selecting node central edge say center dcmst 
denote weight edge 
node adjacent attempt obtain tree smaller weight replacing edge edge 
furthermore replacement edge adjacent nodes adjacent 
edge exists keep edge tree 
method compute second dcmst center 
accept dcmst smaller weight solution 
suppose nodes adjacent dcmst 
nodes adjacent comparisons get dcmst 
shown employing procedure complete graph expected number comparisons required obtain approximate dcmst exact dcmst 
time tree construction time tree construction ottc strategy modification prim algorithm compute approximate dcmst pass 
prim algorithm experimentally shown fastest computing mst large dense graphs 
ottc algorithm grows spanning tree connecting nearest neighbor violate diameter constraint 
approach keeps tree connected iteration easy keep track increase tree diameter 
modified prim algorithm formally described maintain information node near node tree nearest non tree node weight edge near 
dist distance unweighted path length node tree tree set tree 
ecc eccentricity node distance tree farthest node tree set tree 
update near determine edges connect partially formed tree increasing diameter criterion edges want minimum weight 
efficiently having recompute tree diameter edge addition 
code segment ottc algorithm set dist ecc values node copying parent node near 
code segment update values dist ecc parent node steps 
code segment update values dist ecc nodes 
dist ecc arrays described simplify ottc computation 
computing diameter constrained minimum spanning tree parallel procedure input graph diameter bound output spanning tree initialize select root node included initialize near uv compute nearest node min vt select node smallest value set near 
set dist ecc dist near dist dist near dist ecc ecc near 
update dist near ecc near dist near ecc near ecc near 
update nodes values dist ecc tree node near dist dist near ecc max ecc dist 
update near values nodes node tree ecc near examine nodes determine near compare weight 
fig 

ottc modified prim algorithm code segment intuitive 
update near values node tree selecting edge increase tree diameter specified constraint minimum weight edges 
adding tree may may increase diameter 
tree diameter increases near lies longest path tree adding tree connecting near may violate constraint 
case reexamine nodes tree find new value near violate diameter constraint 
achieved examining ecc nodes deo abdalla tree need recompute tree diameter 
computation includes adding new node tree 
hand near feasible edge near best choice nodes tree possibly newly added node 
case need determine edge increase tree diameter constraint weight 
complexity code segment diameter constraint small requires looking node tree node tree 
time complexity algorithm higher prim algorithm 
loop requires iterations 
iteration requires steps worst case time complexity algorithm 
algorithm find dcmst 
furthermore algorithm sensitive node chosen starting spanning tree 
sequential parallel implementations compute trees starting node 
output spanning tree largest weight 
reduce time needed compute dcmst develop heuristic selects small set starting nodes follows 
select nodes independent smallest sum weights edges emanating node 
defining criterion spanning trees diameter complete graphs polynomially computable 
algorithm produces spanning trees reducing time complexity factor choose constant value general iterative refinement algorithm ir algorithm recompute spanning tree iteration new spanning tree computed modifying previously computed 
modification performed produces previously generated spanning tree guarantees algorithm terminate 
algorithm algorithm removes edge time prevents cycling moving away center tree cycling imminent 
new algorithm starts computing unconstrained mst input graph 
iteration removes edge breaks longest path spanning tree replaces non tree edge increasing diameter 
algorithm requires computing eccentricity values nodes spanning tree iteration 
initial mst computed prim algorithm 
initial eccentricity values nodes mst computed preorder tree traversal node visit consists computing distances node nodes spanning tree 
requires total computations 
spanning tree changes recompute eccentricity values change 
computing mst initial eccentricity values algorithm identifies edge remove tree replaces edge diameter constraint met algorithm fails 
implemented executed variety inputs process required iterations 
iteration consists parts 
part described subsection find computing diameter constrained minimum spanning tree parallel edge removal contribute reducing diameter second part described subsection find replacement edge 
ir algorithm shown different edge replacement shown figures 
ecc denote eccentricity node respect spanning tree maximum distance node diameter spanning tree max ecc nodes selecting edges removal reduce diameter edge removed break longest path tree near center tree 
center spanning tree identifying nodes ecc diameter node nodes minimum eccentricity 
may edge candidate removal keep sorted list candidate edges 
list call mid implemented max heap sorted edge weights highest weight candidate edge root 
removing edge tree guarantee breaking longest paths tree 
nodes longest path maximum eccentricity equal diameter verify removing edge splits tree subtrees subtree subtree subtrees contains node ecc equal diameter tree highest weight edge list mid satisfy condition remove mid consider highest 
process continues find edge breaks longest path list mid empty 
go entire list mid finding edge remove consider edges farther center 
done identifying nodes ecc diameter bias bias initialized zero incremented time go mid finding edge remove 
recompute mid edges incident set nodes time succeed finding edge remove reset bias zero 
method examining edges helps prevent cycling consider different edge time edge removed 
guarantee prevention cycling select replacement edge reduces length path guarantee refinement process terminate reduce diameter bound bias large try remove edges incident points longest paths tree 
procedure input graph diameter bound output spanning tree diameter compute mst ecc mid move false deo abdalla repeat diameter max ecc mid move true move false mid edges edge farther center previous iteration mid edges center repeat highest weight edge mid splits trees subtree subtree mid max ecc max ecc subtree subtree mid edge remove move true remove get replacement edge add recompute ecc values diameter removing edges farthest center fig 

general ir algorithm worst case computing list mid requires examining edges requiring comparisons 
addition sorting mid take log time 
replacement edge time recompute eccentricity values nodes find replacement helps reduce diameter 
iterative process removes replaces edges iterations take time worst case 
list mid sorted time computed execution time reduced constant factor prevent mid large 
achieved edge replacement method keeps tree fairly uniform small number edges near center show subsection 
mid constructed edges near center keep mid small 
selecting replacement edge remove edge tree split subtrees subtree subtree 
select non tree edge connect subtrees way reduces length longest path increasing diameter 
diameter reduced longest paths broken 
develop methods erm erm find replacement edges 
computing diameter constrained minimum spanning tree parallel edge replacement method erm method shown selects minimum weight edge connecting central node subtree central node subtree 
edges connect subtree subtree edge produce tree diameter subtree subtree smaller diameter subtree subtree 
edge guaranteed exist incomplete graphs 
procedure erm recompute ecc ecc subtree subtree subtree min ecc subtree subtree min ecc subtree subtree minimum weight edge subtree subtree ecc ecc subtree subtree add edge mid bias move true mid fig 

edge replacement method erm central nodes subtree edges select 
central nodes subtrees computing ecc subtree ecc subtree subtree nodes ecc subtree min ecc subtree nodes subtree contains selection done time 
set boolean variable move true time remove edge incident center tree 
causes removal edges farther center tree iteration algorithm prevents removing edge just added 
edge replacement method fast look selects edges 
early iterations algorithm method creates nodes high degree near center tree causes mid large 
shown previous section causes time complexity algorithm increase constant factor 
furthermore having edges select replacement causes tree weight increase significantly 
edge replacement method erm method shown computes ecc subtree ecc subtree values subtree individually erm 
subtrees joined follows 
removed edge subtree subtree 
replacement edge smallest weight edge guarantees new edge increase diameter guarantees reducing length longest path tree 
enforce condition deo abdalla ecc subtree ecc subtree ecc subtree ecc subtree condition ecc subtree ecc subtree ecc subtree ecc subtree edge remove edge farther center tree 
procedure erm recompute ecc subtree ecc subtree subtree ecc subtree ecc subtree minimum weight edge subtree subtree ecc subtree ecc subtree ecc subtree ecc subtree edge add edge add removed edge back move true fig 

edge replacement method erm erm restricted centers subtrees works better erm incomplete graphs 
addition produce smaller weights selects replacement large set edges fewer edges erm 
larger number edges increases total time complexity ir algorithm constant factor erm 
furthermore method create nodes high degree near center tree erm 
helps keep size list mid small early iterations reducing time complexity ir algorithm constant factor 
implementation section empirical results obtained implementing ottc ir algorithms maspar mp massively parallel simd machine processors 
processors arranged mesh processor connected neighbors 
complete graphs represented weight matrices input 
mst randomly generated graph small diameter log suited studying performance dcmst algorithms 
generated graphs minimum spanning trees forced diameter 
computing diameter constrained minimum spanning tree parallel time tree construction parallelized ottc algorithm implemented maspar mp graphs nodes 
dcmst generated start node graph nodes took roughly seconds means take hours run start nodes 
address issue running algorithm carefully selected small set start nodes 
different methods choose set start nodes 
snm selects center nodes smallest stars start nodes 
snm selects nodes random 
seen quality dcmst obtained heuristics chose similar 
execution times heuristics identical 
results running ottc algorithm start nodes obtained graphs nodes compared results obtained start nodes graphs 
results compare average value smallest weight snm snm average weight ottc algorithm runs iterations 
quotient values reported 
dcmst obtained snm weight times weight iteration ottc algorithm 
cost snm tree times iteration tree 
snm weight ratio snm 
snm weight ratio snm weight ratio 
cases snm outperforms snm terms quality solutions cases 
results obtained confirm theoretical analysis predicted improvement execution time described section 
execution time snm snm approximately 
time significantly time taken iteration algorithm expected 
snm viable alternative iteration algorithm 
weight ratio number nodes fig 

weight dcmst obtained different node search heuristics multiple mst weight 
initial diameter iterative refinement algorithms heuristic dcmst parallelized implemented maspar mp 
produced dcmst weight approximately half dcmst snm snm dcmst dcmst deo abdalla see figures 
time refine dcmst took time calculate dcmst 
parallelized implemented general ir algorithm maspar mp 
expected algorithm enter infinite loop terminated iterations 
algorithm unable find dcmst diameter cases graphs nodes 
graphs nodes empirical results show failure rate 
algorithm successful finding dcmst graphs nodes 
shows failure rate algorithm depend fraction value depends small constant see take close look way move away center tree select edges removal 
note algorithm fail try remove edges incident points longest paths spanning tree 
note move away center tree time go entire set mid finding replacement edge return center spanning tree time succeed 
weight ratio dcmst mst number nodes dcmst erm erm dcmst fig 

quality dcmst obtained different edge replacement methods 
initial diameter way algorithm fails unable find replacement edge diameter consecutive attempts includes going different set mid 
empirical results show algorithm fail consecutive times suitable finding dcmst value constant greater equal 
algorithm performs fairly data analysis excluded cases algorithm achieve diameter 
exclusion affect analysis excluded cases achieved diameter approximately speed successful attempts 
quality dcmst obtained ir technique different edge replacement methods erm erm shown 
diagram shows weight computed dcmst multiple weight unconstrained mst 
time taken algorithm erm erm obtain dcmst shown 
expected erm performs erm time quality 
addition erm uses memory erm size mid erm significantly larger size erm 
computing diameter constrained minimum spanning tree parallel caused creation high degree nodes erm explained subsection 
tested general ir algorithm erm random graphs 
quality obtained charted 
comparing obtained randomly generated graphs forced unconstrained mst diameter seen quality dcmst graphs starting msts diameter better unrestricted random graphs 
ir algorithm keeps removing edges close center constrained spanning tree contain low weight edges unrestricted random graphs coming unconstrained mst 
unconstrained mst diameter heavy weight edges near center added earlier iterations algorithm 
dcmst type graphs lose low weight edges unrestricted random graphs 
fig 

time reduce diameter different edge replacement methods weight ratio dcmst mst time seconds number nodes number nodes dcmst dcmst dcmst fig 

quality dcmst dcmst unrestricted random graphs furthermore weight dcmst lower dcmst unrestricted random graphs 
note dcmst heuristic approaches diameter optimization 
diameter constraint small difficult general ir algorithm find solution allows large increases tree weight order achieve required diameter 
approach upper bound guarantees tree weight increase refinement process 
performance dcmst erm erm deo abdalla algorithm change unrestricted random graphs 
quality dcmst deteriorated exceeding upper bound 
clearly dcmst algorithm provides better solution type graphs 
algorithms produce approximate solutions dcmst problem diameter constraint small constant 
modification prim algorithm combined heuristic reduces execution time factor selecting small constant number nodes start nodes ottc algorithm cost small increase weight dcmst 
second ir algorithm find approximate dcmst 
algorithm guaranteed terminate succeeds finding reasonable solution diameter constraint constant 
third special ir algorithm compute dcmst 
algorithm especially effective random graphs uniformly distributed edge weights outperformed speed quality solution 
algorithm provides tighter upper bound dcmst quality provided dcmst solution 
implemented algorithms processor maspar mp various types graphs 
empirical results implementation support theoretical obtained 

abdalla deo parallel heuristics diameter constrained mst problem 
congressus numerantium appear 
abdalla deo kumar terry parallel computation diameter constrained mst related problems 
congressus numerantium vol 


algorithms minimum weight spanning tree bounded diameter problem 
optimization techniques applications 
bala stern multicasting linear network 
ieee infocom vol 


chow johnson distributed operating systems algorithms 
addison wesley reading ma 
deo kumar constrained spanning tree problems approximate methods parallel computation 
dimacs series discrete mathematics theoretical computer science vol 


garey johnson computers intractability guide theory np completeness 
freeman san francisco 
moret shapiro empirical analysis algorithms constructing minimum spanning tree 
dimacs series discrete mathematics theoretical computer science vol 


bounded diameter minimum spanning tree problem thesis george mason university fairfax va computing diameter constrained minimum spanning tree parallel 
palmer graph evolution theory random graphs john wiley sons new york 
raymond tree algorithm distributed mutual exclusion 
acm transactions computer systems vol 



satyanarayanan muthukrishnan note raymond tree algorithm distributed mutual exclusion 
information processing letters vol 


satyanarayanan muthukrishnan static tree algorithm distributed readers writers problem 
computer science informatics vol 



wang lang tree distributed algorithm entry critical section problem 
proceedings international conference parallel distributed systems 
