calculational reasoning revisited isabelle isar experience bauer markus wenzel technische universit nchen institut informatik nchen germany www tum de www tum de 
discuss general concept calculational reasoning isabelle isar provides framework high level natural deduction proofs may written human readable fashion 
setting basic logical concepts underlying meta logical framework isabelle higher order unification resolution calculational commands added basic isar proof language flexible non intrusive manner 
calculational proof style may combined remaining natural deduction proof language liberal manner resulting useful proof patterns 
case study formalizing computational tree logic ctl simply typed set theory demonstrates common calculational idioms practice 
proof calculational reasoning basically proceeds forming chain intermediate results meant composed basic principles transitivity similar relations 
advanced calculations may involve substitution case inequalities usually includes monotonicity constraints 
informal mathematics kind proof technique routinely casual manner 
mathematicians write sequences mixed equalities inequalities underline subexpressions replaced doing calculational reasoning 
fact calculational reasoning occasionally proposed simple means rephrase mathematical proof slightly formal setting necessarily include machine checking proofs course 
observing logical equivalence implication may just calculations set away traditional natural deduction style reasoning altogether discipline appeal 
calculational reasoning offers relatively simple conceptual basis build tools logical manipulations 
popular math pad tool supports manipulation algebraic expressions systematic way acquired means formal proof checking pvs backend 
mizar system focuses formal proof common mathematics style place 
offers mechanism iterated equality reasoning shall serve example calculations formal setting 
trivial proof taken article mizar library 
theorem th set holds union union proof set union union union union union union mizar indicates subsequent statement meant solve pending goal 
continued equality sign indicates actual result shall emerge number individual equations proven separately results composed transitivity scenes 
discusses quite general concepts calculational reasoning may expressed isabelle isar framework human readable proof documents 
isar provides high level view natural deduction open incorporate additional derived language elements calculational reasoning 
techniques natural deduction calculations may conveniently proof enabling writer apply appropriate particular situation hand 
paradigms may coexist benefit 
need conflict natural deduction versus calculational reasoning occasionally raised followers dijkstra proof format 
going details shall see example works isar proof language 
observe easily finished single stroke automated proof method isabelle 
theorem auto fact calculations mizar library trivial perspective automated proof tools available isabelle hol pvs indicates mizar builtin automation handle equality 
hand usually lucky automated tools applications get realistic 
contrast defined concepts structured proof calculations provide means arrange formal reasoning robust scalable manner oriented human reader writer proof texts machine 
automated methods find proper place solving local proof obligations 
subsequent version mimics original mizar proof closely possible 
formal proofs processed isabelle 
theorem proof auto 
auto 
auto 
auto show qed isar provides explicit mechanism finish calculation mizar 
canonical style writing calculations reiterate final result readers determine 
calculations restricted fixed scheme may freely composed additional commands encountered 
notation right hand side statement see 
text merely turns idiomatic expression general language framework see 
inspect bit proof proceeds recall original mizar proof basically imitates simplification process 
justifications intermediate claims indicated marginal interest 
look closely transformational process equations involved represented top level plain transitive chain essentially performs substitution steps 
isabelle isar handles substitution may explain technical details directly formal text 
theorem proof auto auto auto auto show qed apparently result calculation need left hand side equal right hand side general rules get involved 
foundations calculational reasoning logical preliminaries standard mathematical notation far possible just note write lists appending lists basic logical foundations isabelle pure framework minimal higher order logic universal quantification implication underlying term language simply typed calculus application abstraction examples object logic isabelle hol extends pure common connectives classical axiom hilbert choice operator 
theorem denote set derivable theorems pure write indicate proposition theorem furthermore facts set lists theorem 
theorems pure represent derived rules embedded object logic 
main derived operations pure resolution back chaining generalized modus ponens proof assumption quite powerful primitives may involve higher order unification 
write resulting theorem resolving facts parallel rule goal represented theorem initially gets refined resolution eventually note isabelle isar content goal state finished proof assumption 
isabelle isar proof language isar proof language provides general framework human readable natural deduction proofs basic concepts somewhat oriented basic isabelle pure framework happens offer basis primitive operations natural deduction especially resolution 
isar language consists primitives appendix fix assume augment context indicates forward chaining show claim local statements solves pending goal proof performs initial proof step applying method qed concludes sub proof manage block structure note binds reconsidered facts abbreviates terms higher order matching form may appended statement 
basic proof methods resolve facts directly performs goal rule apply rule resolved facts performs goal 
arbitrary automated proof tools may simp isabelle simplifier auto combination tools 
standard abbreviations include thesis initial claim head proof 
right hand side latest finished statement refers result previous step 
default methods rule proof qed 
derived proof commands proof qed rule note 
isar natural deduction kernel directly corresponds underlying logical framework 
meta level statement may established follows 
proof fix assume show proof qed reality rule statements typically emerge different claim refined initial proof method encountered 
calculational sequences syntactical point view essence calculational proof shall call calculational sequence calculation freely generated constructors start facts calculation continue calculation facts calculation 
apparently calculation simply represents non empty list facts 
fine tune notation write canonical calculational sequences continue 
continue start 
concisely 
interpreted calculation sequence shall result achieved mapping start continue primitive recursive fashion 
consider interpretations calculation back facts result calculation facts fix result start degree freedom left specify result order give interpretation continue steps 
kinds calculational steps considered isabelle isar framework 
rule step specify result result suitable rule taken set transitivity rules 
produce single result applying rule current calculational result plus new facts 
accumulation step specify result result simply collect facts applying rule 
basic example interpreted calculation sequences just fix singleton set transitivity rules perform rule steps result 
may represent canonical chains equations composed plain transitivity 
alternatively perform accumulation steps achieve result simply get number facts collected single list 
shall see case seemingly degenerate calculational sequences turns quite useful practice 
calculational elements proof language stage investigate suitable proof development systems may provide language interface user compose calculational sequences 
sight way taken mizar obvious simply invent concrete syntax primitive operations composing calculational sequences implementation support directly probably link basic mechanisms stating proving facts 
way making system particular usually limited just specific feature mind planning implementation 
isabelle isar calculational reasoning process composing calculational sequences may mapped natural flow reasoning existing isar framework non intrusive fashion 
adding abbreviations conventions achieve general framework calculational reasoning minimal effort 
resulting space possible combined proof patterns shall explored 
fix special facts register called calculation hold current state partially interpreted sequence user currently working 
start calculation shall determined implicitly indicated calculation empty 
calculation finished explicit command calculation reset await sequence start 
result finished sequence exhibited subsequent goal statement explicitly highlighted facts actual subsequent proof controlled calculational process anymore 
wish exploit isar inherent block structure support nested calculations 
update operation calculation needs track current nesting level order commence new sequence blocks opened 
derived isar proof commands maintain calculation register defined follows leaving policies initializing resetting state implicit 
note calculation initial case note calculation calculation calculation note calculation calculation ultimately calculation main elements corresponding accumulation steps introduced 
variants ultimately finish current sequence performing final step 
due forward chaining involved operation command goal statement show cf 
isar semantics 
element arrive viable calculational proof language isar framework standard term binding 
refers right hand side explicit fact statement 
enables user include relevant parts previous statement succinct manner 
mizar mode hol provides similar element mizar uses construct 
may write previous examples calculational sequences follows 
proof 
proof 
proof calculation ultimate list accumulated facts prove result certain rule 
proof proof proof ultimately rule certainly may rephrase calculations basic natural deduction backwards style performing exactly inferences internally 
proof rule trans show proof rule trans show proof show proof qed show proof qed rules proof search proof rule show proof show proof show proof qed philosophy isar keep automated proof tools basic mechanisms interpreting high level structure proof texts 
linear search limited number choices plus higher order unification permitted 
reconsidering commands outlining calculational sequences isar see single non deterministic parameter rule selected command 
isar proof texts interpreted strictly left right subsequent result calculation calculation achieved facts rule instance determined system appropriately 
long holds mixed result uniquely determined providing facts invariably yields isar uses refined strategy support general rule selections 
assume canonical order rule context calculation input calculational step 
enumerate members enumerate canonical sequences results obtained parallel higher order unification back chaining filter raw result sequence disallow mere projections words remove results actual progress sense members list strategy subsumes simple case unique results considered job substitution declare tried plain considered far 
expression requires plain order unification unique general result 
critical part solve expression genuine higher order problem 
resulting unifiers assign certain term abstracts possible occurrences sub expression standard strategy start solution occurrences followed possible partial occurrences fixed order finish occurrences 
note case solution occur pathological case purpose collapses substitution rules filtering mere projections original facts basic calculational rule step able produce sensible result occurrences certain sub expression may replaced equal cf 
final example 
replacing occurrences way specify intended result 
case better plain transitivity simplifier justify step 
substitution inequalities involving additional monotonicity constraints works see common patterns 
notion progress filtering strategy needs ignore local premises detect degenerate cases properly 
idioms calculational reasoning space possible calculational expressions isar somewhat due particular way calculational primitives incorporated proof language 
certainly creative users isabelle isar may invent ways calculational reasoning time 
point possible dimensions variety hint practically useful idiomatic patterns 
subsequent categories guided way primitive calculational sequences cf 
may mapped isar proof configurations cf 

variation rules basic form plain transitive chain equations cf 
second isar example 
mixed may follows observe canonical single dot proof exhibits result explicitly 
proof 
proof 
proof 
proof 
proof likewise may combinations relations antisymmetry long clear functional mapping facts result serious conflict rules 
proof proof covered substitution equals equals near inequalities works quite similarly 
proof proof simp rule premises filled facts calculation remaining monotonicity constraint left hypothesis result eventually solved final simplification step 
hard part instantiating side condition performed calculation relevant propositions text 
see high level proof outlining nicely cooperates dumb automated reasoning 
simple cases may provide facts place 
example see phrase note ag mono appears 
may calculate directly logical propositions approaching original proof style 
pattern essentially achieves light weight natural deduction implicit modus ponens rule 
proof proof proof certainly transitivity may 
hand chaining implications conveniently expressed directly isar primitive cf 
circumventing overhead explicit logical connectives altogether 
variation recall actual business managing calculational process finishes concluding ultimately command just offers result forward chaining indicated cf 

command may kind goal show powerful obtain 
claim followed proof 
basic meaning goal statement reiterates calculational result directly 
useful idiom feed result may just number accumulated facts single rule premises see proof ag ag 
may generalize principle arbitrary automated methods resulting kind big step inferences 
calculational infrastructure mode operation usually require lot name intermediate facts tend degrade readability 
variation facts virtually calculational schemes discussed far facts placed chain produced local statements proof 
isar language element produces facts may calculations 
includes note recall existing theorems goal elements show obtain context commands assume 
see uses note note 
combinations obtain useful typical computer science applications results representations syntactic entities incrementally put 
assume calculation represents basic case combining calculational reasoning natural deduction induction 
theorem proof induct show 
auto fix suc auto assume suc auto show suc suc qed assume line indicates substitution induction hypothesis 
variation structure calculational sequences basically linear arbitrarily intermediate steps may taken fact produced 
includes nested calculations long arranged separate level block structure 
see common case implicit block structure induced local proofs explicit blocks indicated braces 
case study properties ctl order demonstrate idiomatic expressions calculational reasoning practice case study formalizing basic concepts computational tree logic ctl simply typed set theory hol 
proofs algebraic reasoning basic set operations 
ctl formulae common technique shallow embedding ctl formula identified corresponding set states holds 
consequently ctl operations negation conjunction disjunction simply complement intersection union sets 
require separate operation implication point wise inclusion usually encountered plain set theory 
types ctl set imp ctl ctl ctl infixr ctl path operators interesting arbitrary fixed model simply transition relation states 
see isabelle tum de library hol ctl document pdf consts model set operators ex ef taken primitives ax af ag defined derived ones 
denote ex set states successor state respect model expression ef denotes set states path starting state state path expression set states path starting states path known ef may expressed greatest fixed points 
ex ctl ctl ex ex 
ef ctl ctl ef ef lfp ex ctl ctl gfp ex ax af ag defined dually terms ex ef 
ax ctl ctl ax ax ex af ctl ctl af af ag ctl ctl ag ag ef basic fixed point properties de morgan property fixed points lemma lfp gfp lfp gfp proof order give dual fixed point representations af ag lemma af lfp af lfp ax auto simp add lfp gfp lemma ag gfp ag gfp ax auto simp add lfp gfp greatest fixed point definition ag derive consequence knaster tarski theorem hand ag fixed point monotonic function ax lemma ag fp ag ax ag proof mono ax proof show thesis proof qed fact may split inequalities merely transitivity instance overloaded isabelle hol 
lemma ag fp ag proof note ag fp ax ag auto show thesis qed lemma ag fp ag ax ag proof note ag fp ax ag ax ag auto show thesis qed hand knaster tarski fixed point theorem post fixed point ax smaller ag post fixed point set states ax leads induction principle ag lemma ag ax ag simp ag gfp rule gfp upperbound tree induction principle basic facts available able establish interesting results leading tree induction principle ag see 
elementary monotonicity distributivity rules 
lemma ax int ax ax ax proof lemma ax mono ax ax proof lemma ag mono ag ag proof state set ag ax substitution monotonicity 
lemma ag ax ag ax proof ag ax ag rule ag fp ag rule ag fp note ax mono show thesis qed furthermore show idempotency ag operator 
proof example accumulated facts may get feed single rule step 
lemma ag ag ag ag ag proof show ag ag ag rule ag fp show ag ag ag proof rule ag ag ag 
ag ax ag rule ag fp ultimately show ag ag ax ag 
qed qed give alternative characterization ag operator describes ag operator operational way tree induction ag set states reachable states starting state holds condition state lies successor state 
induction principle ag establish purely algebraic manner 
theorem ag induct ag ax ag proof show ag ax ag lhs rhs proof rule ag show lhs ax lhs proof show lhs 
show lhs ax lhs proof ag ax ax rule ag fp ax ax 
lhs ax auto ag ax ag ax 

ax 
rule ag fp lhs ax ag ax ultimately lhs ax ax ag ax 

ax lhs simp ax int show thesis qed qed qed show ag ag ax proof show ag rule ag fp show ag ag ax proof ag ag ag simp ag ag ag ax rule ag ax note ag mono ax ax 
note ag mono show thesis qed qed qed middle part proof provides example nested calculations explicit blocks contributing results established separately calculations ultimately put 
application tree induction interesting properties ctl expressions may demonstrated help tree induction show ax ag commute 
theorem ag ax commute ag ax ax ag proof ag ax ax ax ag ax rule ag fp 
ax ag ax simp ax int ag ax ag lhs rhs proof ax ax 
ag ax ag rule ag induct note int mono ag mono ultimately show lhs ag auto ag rule ag fp ag ag ag simp ag ag ag ax rule ag ax note ag mono ultimately ag ag ax ultimately show ag lhs 
qed show thesis qed example nested calculation implicit block structure managed automatically proof qed 
naturally users complain calculations sub proofs affect general course reasoning 
note indicates non trivial substitution monotone context 
discussion theory ctl serves nice example kinds calculational reasoning mainly due high level algebraic view set operations 
alternatively worked point wise explicit set membership 
proofs certainly cumbersome primitive natural deduction steps accommodate quantified statements 
interesting story example 
served assignment isabelle course summer tu munich 
students exposed isabelle weeks crude tactical part instructors intended pose relatively simple realistic application set theory turned harder expected 
reason hand instructors simply started developing theory interactively isabelle isar proper proof language basically think aloud formally 
relatively experience involves number algebraic manipulation 
hand students knew traditional tactic scripts strong bias hairy natural deduction operations performed backwards style 
posed real problem students assignment impossible finish knowledge 
retrospect understandable rephrasing kind algebraic reasoning seen tactic scripts quite cumbersome expert 
related seen calculational reasoning isabelle isar provides viable concept arranging large variety algebraic proof techniques manner 
requiring minimal conservative additions basic isar proof engine able achieve large space useful patterns calculational reasoning including mixed transitivity rules substitution equals equals substitution greater equal sub expressions 
underlying mechanisms isabelle isar need advanced proof search apart plain higher order unification simple filtering scheme 
interestingly traditional tactic interactive proof systems classic isabelle hol coq pvs lack support calculational reasoning altogether 
addressed times past 
simons proposes tools support calculational reasoning tactical proof scripts 
grundy provides general transformational infrastructure window inference 
harrison mizar mode hol simulates number concepts declarative theorem proving top tactic hol light system including calculational reasoning mixed transitivity rules 
concerning class theorem proving environments human readable proofs canonical representative mizar supports fixed format iterative equations implicit application transitivity general substitution rules 
syme declare system declarative theorem proving address calculations 
outlines generalized version calculations spl observes required examples hand implemented 
users isabelle isar calculational reasoning useful tool everyday applications just typical mathematical ones system verification tasks 
calculations fit general high level natural deduction framework isar may say calculational reasoning natural deduction reconciled 
back grundy von wright 
structured calculational proof 
formal aspects computing 
back von wright 
structured derivations method doing mathematics carefully 
technical report turku centre 
bauer wenzel 
computer assisted mathematics hahn banach theorem isabelle isar 
coquand dybjer nordstr smith editors types proofs programs types lncs 
bertot dowek hirschowitz paulin editors 
theorem proving higher order logics tphols lncs 
dijkstra scholten 
predicate calculus program semantics 
texts monographs computer science 
springer 
gentzen 
untersuchungen ber das logische schlie en 
mathematische zeitschrift 
grundy 
window inference hol system 
archer joyce levitt editors proceedings international workshop hol 
acm sigda ieee computer society press 
harrison 
mizar mode hol 
wright grundy harrison editors theorem proving higher order logics tphols lncs 
mcmillan 
lecture notes verification digital hybrid systems 
nato summer school www cad eecs berkeley edu tutorial toc html 
mcmillan 
symbolic model checking approach state explosion problem 
phd thesis carnegie mellon university 
mizar mathematical library 
www mizar org library 
muzalewski 
outline pc mizar 
logic mathematics informatics mizar users group 
paulson 
isabelle generic theorem prover 
lncs 

simons 
proof presentation isabelle 
gunter felty editors theorem proving higher order logics tphols lncs 
syme 
declare prototype declarative proof system higher order logic 
technical report university cambridge computer laboratory 
syme 
tactic theorem proving 
bertot 
trybulec 
features mizar language 
workshop turin italy 
backhouse 
interfacing program construction verification 
wing woodcock editors fm world congress formal methods volume lncs 
wenzel 
isar generic interpretative approach readable formal proof documents 
bertot 
wenzel 
isabelle isar manual 
part isabelle distribution isabelle tum de doc isar ref pdf 
wenzel 
aspects unix file system security 
isabelle isar proof document isabelle tum de library hol unix document pdf 
wiedijk 
mizar impression 
unpublished 
www cs kun 
nl mizar ps gz 

implementation extensible declarative proof language 
bertot 

