elimination motive conor mcbride department computer science university durham 
tactic type theory proof systems apply elimination rules refinement setting 
applicable rules parametric expressing leverage hypotheses yield phi choose 
phi represents motive elimination job construct phi suited goal hand 
inhabit instance phi domain adopt technique standard folklore generalizing expressing restriction equation 
novel notion readily permits dependent equations second tactic unify equational hypotheses appearing subgoals 
technology effective express properties datatypes relations functions style 
small extension couples rewriting allowing complex techniques packaged single rule 
computations datatypes proof assistant lego elimination rules playing dual role induction principle primitive recursor 
phd developed technology help working rules cause programming 
technology soon acquired wider applications works theorem resembling datatype elimination rule 
pays characterize kinds information style 
claim exploit hypothesis terms immediate consequences terms leverage exerts arbitrary goal give elimination motive 
technical purpose document elimination technology benefit implementers 
political purpose persuade users properties need style supported technology 
motivation shall introduce issues help examples 
conjunction disjunction undergraduates learning natural deduction time typically taught elimination rules conjunction disjunction project project elim 

students usually grasp project rules easily finds elim 
trouble appears students struggle dream eventually lead goal 
learn proof refinement elim sense instantiate goal splitting cases 
need prove goal eliminating goal motive elimination 
choose appropriate motive precisely appears elim parametric motive 
elimination rules parameter motive variable allow exploit hypothesis goal just left rules sequent calculus analyse hypotheses regardless stands right turnstile 
light simplicity project rules attractive may exploit want know want know join advocates alternative exploiting motive elim 
structural induction recursion mathematical induction common example elimination motive induction phi prop phi phi phi phi phi stands family propositions indexed number 
bold suggest search collection established facts pair related phi order add phi collection 
induction needs motive elim splits proof cases eliminated instantiated case 
point induction just decompose hypothesis simplify goal constructor symbols appear computation happen 
allow phi stand indexed family types supply appropriate computational behaviour induction dependently typed primitive recursion supporting functions return type depends explicit indexing phi numbers strong connection pattern matching structural recursion 
expose patterns simply typed examples making definition definition plus 
goal plus induction base plus induction step plus plus 
directed computational equalities reserving propositional equality 
return type goal reads left hand side functional program construction 
induction splits programming problem read instantiated patterns case legitimate class recursive calls 
elimination rule indexed motive variable phi justifies kind pattern analysis matching phi arguments goal patterns phi arguments premises subgoal patterns phi arguments inductive hypotheses recursion patterns allow corresponding recursive calls 
equip elimination rule computational behaviour give associated pattern matching structural recursion operational semantics 
relation induction inductively defined relations may elimination rule corresponding induction derivations 
example may defined follows prop induction phi prop phi phi phi phi relation induction easy apply eliminated hypothesis ranges entire domain relation choose phi naive undergraduate textual matching 
hypothesis instantiated need phi indexed domain employ known goal transformation learned james mckinna general constrain equations goal phi obvious generalize add equation generally elimination rule inductive relation prop typically requires phi prop motive typical goal typical phi plugging phi proof rule delivers proof subject trivial equations 
technique gives slightly phi chose constrains argument needs equation 
hard see remove unnecessary equation 
note chosen phi resembles goal equations inserted missing 
phi indexed proof elimination tells safely omit motive 
adopt pollack convention binding parameters wish keep implicit subscripts need explicit 
denotes batch equations delta delta delta xn tn induction dependent datatypes datatype analogue inductively defined relations dependent families datatypes vectors lists length defined follows type vect type type vect xs vect vcons xs vect vect elim type phi vect type phi phi xs phi vcons xs xs vect phi xs proof terms relations interesting say indices structure unimportant 
terms dependent datatypes actual data 
correspondingly motive phi vect elim indexed length vector care vector vcons 
hand phi indexed element type parametric entire inductive definition 
constraint equation works instantiated datatypes 
example definition 
type xxs vect vect goal type xxs vect xxs motive phi 
xs vect xxs vect xs xxs xxs base case type xxs vect xxs xxs step case type xs vect delta delta delta xxs vect vcons xs xxs xxs solving equations refutes base case premises reduces step case type xs vect delta delta delta vcons xs return type shows pattern possible xs tail seek 
chosen phi quantify eliminated xxs matched xs goal patterns 
omitted time parametric definition kept parametric elimination 
sensitive distinctions order deliver appropriate behaviour elimination rule 
equational constraints dependent types eagle noticed write batched equations worrying type safety 
example wrote xs xxs xs vect xxs vect 
conventional martin lof definition forbids heterogeneous equations relating elements different types 
deduce am unconventional definition 
define follows prop refl elim phi type phi refl phi compare correspondingly may form heterogeneous sequences elimination rules follow conventional homogeneous definition shall treat equal type really call john major equality widens aspirations equality affecting practical outcome 
vectors telescope leftmost equation homogeneous vulnerable elimination 
homogeneity maintainable invariant solving facto unifies types 
john major equality equivalent extending martin lof equality altenkirch streicher uniqueness identity proofs axiom referred axiom 
clear new equality subsumes old 
hand write heterogeneous equation homogeneous equation pairs type sigma type clearly equals 
elimination rule follows consequence known variant axiom details construction thesis 
elimination rule eliminate 
order elimination shall need means determine kind thing rule eliminates rule target 
elim rules come inductive definitions clearly target inhabitants datatype relation family defined 
wish tactic apply widely think little carefully issue 
firstly establish minimum requirement 
suppose rule needs motive phi type 
basic goal motive phi 
apply rule equations reflexive 
ensured instantiating rule arguments fill goal patterns instantiated rule delivers phi choice equations clear 
demand information user determine arguments goal patterns depend 
looking back examples see requirement satisfied elimination select disjunction foolish apply rule mind 
induction need choose number 
induction vect needs vector length length inferred type vector user need indicate 
form motive induction identify numbers compared sense infer matching hypothesis form permit rules targets double induction principle datatype implements lexicographic recursion arguments type 
imagine rules application restricted side condition proof prefer defer 
naive machine strategy divine arbitrary rule point say eliminate 
ingenious machine strategies disturb propose manufacturers responsible expect elimination rules come operating instructions 
describe rule type giving list targetting expressions user supply actual targets aid mouse targets unify expressions solving selection complete may proceed elimination provided instantiated rule type reduces fully targetted form delta delta delta phi type delta delta delta phi effect explicit targetting procedure allows delay appearance motive variable phi 
computational world type theory may choose targets compute appropriate rule 
shall see constructors injective disjoint property datatypes expressed rule selects effect case analysis constructors involved 
operating instructions approach benefit user interfaces 
catalogue known elimination rules target point hypothesis ask rules eliminate 
machine sort responses give best matching rule 
elimination tactic implements ideas 
argument rule typically elim elim remaining arguments user chosen targets 
phases plug instantiated rule fully targetted construct motive adding equations goal simplifying perform refinement step leaving rest rule premises subgoals targetting builds refinement applying elim 
phase constructs maintains full application elim terms goal premises containing holes time keeps list user nominated targets far unmatched 
write state follows elim unknowns targets full application mean weak head normal form type 
presume way annotate targetting expression shall denote 
phase successively fills unifying user 
initialization start state elim unknowns targets loop state form 
elim unknowns targets type marked targetting expression collect unused target try unify 
fails fails 
unifier oe solving leaving residue unsolved 
instantiated type may reduce weak head normal form revealing unknown arguments rule targetting expressions oe wh move state elim oe unknowns targets postcondition state form elim unknowns targets type phase successful consumes targets matches targetting expressions constructs application elim holes heads return type 
rename phi motive variable 
postcondition ensures phi argument types arguments contain holes instantiated rule fully targetted 
constructing motive basic choice motive copies goal inserting equations 
phase refines choice avoid useless constraints maximize amount rewriting done instantiation subgoals remove premises eliminated mentioned goal patterns rules elim induction 
start guessing phi 
tactic performs refinements oleg type theory holes known metavariables host names adequate support useful byproduct thesis 
written type universe phi inhabits universe acceptable 
fix unhelpful premises basic motive contains local copies premises goal 
better forgo generality originals effectively fixing elimination local phi local inductive hypotheses change recursion 
fix premise follows substitute bound occurrences remove binder classes unhelpful premise fix parametric premises element type vect parametric local copy type phi parametric subgoal structure remain constant 
large premises large premise type big universe phi inhabits fix premises keep phi typed 
irrelevant premises proof irrelevant premise local copy occurring arguments elim computed targetting instantiated goal patterns 
eliminated subgoals tell new may fix 
course fix premises remaining helpful yield stronger inductive hypotheses 
delete duplicating constraints increasing constraint remove substitute delete point having phi equal phi arguments provided type just remove constraint 
ensures get equations really necessary example 
search left right earlier deletions may unify types 
plugs motive helpful necessary equations phi 
performing refinement having computed motive application typed follows elim unknowns adds arguments local goal premise copies constraint proof refl elim refl unknowns type hole may depend subset goal premises usually parametric 
build refinement 
unknowns generalized holes local copies premises need context original goal 
elim refines term solving goal subgoals 
eliminating equational constraints unify applies rule instantiated hypothesis converting instantiations equations 
expect equational premises subgoals instantiated subgoal patterns 
approach treat equations unification problem leading tactic solves problems 
absence unifier indicates subgoal holds vacuously unique general unifier simplifies subgoal turning equations back instantiations 
tactic ancestor tactic unify 
may observe datatype rule schemes derivable deletion phi phi coalescence phi phi distinct variables conflict phi distinct constructors injectivity phi phi constructor substitution phi phi fv cycle phi constructor guarded just rules seen transition rules unification algorithm operating refinement problems expressed equational premises arbitrary goal 
key differences earlier john major equality allows consider equations arbitrary telescope overcoming previous restriction simple types 
consequently conflict injectivity cycle rules require subtle proofs simply typed fragment 
transition rules seen elimination rules targetting equation 
apart cycle tactic apply 
unify demands goal equational premises relate vectors telescope order terms constructor form composed solely variables constructor symbols 
goal unify behaves follows goal remains equational premises eliminate leftmost appropriate rule applying symmetry necessary 
precondition ensures leftmost equation preserved transitions subgoals 
process sound complete terminating arguments unify proves goal leaves subgoal simplified general unifier 
course order rules prove deletion trivial coalescence substitution follow easily elim 
proven specifically datatype 
derived elimination rules datatypes section sketches construction useful classes theorem proven inductive family datatypes 
included separation induction case analysis structural recursion proof constructors injective disjoint property dubbed confusion proof datatypes contain cycles theorems elimination rules 
sake readability shall give proofs concrete typical examples vectors case recursion confusion binary trees cycles 
defined tree type leaf tree tree node tree general constructions thesis 
results extend easily mutual definitions case mutual definition recast inductive family indexed finite datatype representing choice branch 
decoupling elim rule datatype case recursion principles recovering flexibility coq case fix primitives way readily extensible instances dependent families 
presentation necessary connection case analysis structural recursion exposes predecessors valid 
recursion rule choice case analysis strategy elim analyses straight away forces step recursion 
gain just fibonacci friends recursion case indices dependent type differently counterparts type combine wish 
example unification algorithm indexes terms number variables may outer recursion index initial case analysis terms 
case case analysis principle datatype formed deleting inductive hypotheses step cases induction principle elim 
vect case type phi vect type phi xs vect phi xs phi vcons xs xs vect phi xs effectively case splits pattern variable constructor cases exposing predecessors 
course unify simplify removing impossible cases 
having stronger premises case follows directly elim 
may prove case relation called inversion principle 
treatment inversion relies equations constrain indices relations case gives rule indexed motive equations required particular inversion supplied 
recursion facilitate recursion guarded subterms fashion gim enez 
technique introduce auxiliary structure collects inductive hypotheses 
motive phi datatype inhabitant phi oe contains proof phis strictly smaller gim enez defines oe inductively computation 
vect phi vect type xs vect phi oe xs type phi oe 
phi oe vcons xs 
phi xs phi xs 
phi oe xs theta phi xs phi oe xs primitive recursive easily defined vect elim 
generally phi oe 
theta phi tree phi oe leaf 
phi oe node 
phi theta phi phi 
phi oe theta phi state vect recursion vect recursion type phi vect type xs vect phi oe xs phi xs xs vect phi xs vect recursion weakens goal hypothesis collector phi oe xs apply case xs subterms phi oe unfolds revealing inductive hypothesis newly exposed subterm 
proof uses gim enez argument fixing phi premise step say 
holds projection lemma xs vect phi xs proven vect elim 
subgoal computes phi oe theta phi step gives phi phi oe may unfold case step phi oe vcons xs phi xs exactly inductive hypothesis 
generally hypotheses phi goal product 
see decoupling compute element nonempty vector type xs vect eliminating vect recursion introduces collector phi oe xs phi xs 
ys vect sm xs ys equational constraints appearing phi oe xs unfolds allow recursion nonempty vectors 
length clearly crucial may analyse case type xs vect phi oe xs type xs vect phi oe xs singleton subgoal case xs delivers head element need longer vectors case exposes tail equations constraining recursion satisfied 
avoid looking steps vector know length 
confusion generalizing injectivity conflict dependent datatypes requires subtlety methods simple types cornes coq adapted lego 
particular longer construct predecessor functions show injectivity obvious candidates dummy values unimportant cases 
approach compute pair terms elimination rule appropriate equal injectivity constructors conflict 
terms constructor headed conf thm function choose right theorem vect conf thm type xs vect ys vect type vect conf thm 
phi type phi phi vect conf thm vcons ys 
phi type phi vect conf thm vcons xs 
phi type phi vect conf thm vcons xs vcons ys 
phi type xs ys phi phi clearly construct vect conf thm applications vect case 
prove vect confusion states type xs ys vect xs ys vect conf thm xs ys need consider vectors type unify eliminates homogeneous equations 
may attack xs ys elim leaving diagonal type xs vect vect conf thm xs xs vect case xs leave trivial injectivity goals 
fortunate conflict theorems chosen vect conf thm true 
dummy values arise subgoal specifically adapted constructor type phi type phi phi type xs vect phi type xs xs phi phi vect confusion target equation vect apply identifies motive variable targetting enabled computation appear 
cycles remaining theorem need states goal follows guarded constructors computed collector phi oe exposes phi guarded subterms may express proper subterm 
phi type phi 

oe 
appears guarded 
reduces product containing follows 
correspondingly tree cycles states tree 
unify turns induction gives trivial base case unfolding step tree hs 
node ht 
theta node branch product follows corresponding hypothesis aid generalization prove tree 
node analogue computational behaviour oe suggests employ induction base case tree 
theta node leaf follows conflict 
step case unfolds follows arrows give proof tree hl hr 

node node theta 

theta theta theta node node injectivity theta node node apply tree cycles containing 
reduces single fully targetted elimination rule style product elimination rules 
specified smart root proof phi type phi 
path proof determined exactly position difficult implement step unify separately 
elimination abstraction traditional way reason recursively defined function inductions arguments allow reduce amounts recursive structure constructed place 
functional abstraction allows synthesize programs highly compositional manner analyse programs level data scalability technology seriously limited 
alternative level relations induced recursive definitions 
example induces place relation form elim phi type phi phi phi phi rules recursive calls premises follow substituting premises 
elimination rule exactly corresponding relation induction principle follows combination recursion case analyses constructed 
shall explain purpose box shortly 
elim eliminates equations form equation equation 
consider transform goal introduce equation eliminate reduce unify leaving easy subgoals transformed base case step case essentially standard proof associative avoids choice induction data derived rule gives design exactly computation need 
similar techniques proving properties inductively defined functions appear james mckinna thesis 
build technology facilitate way working functions 
write tactic abst abstracting occurrences goal course may typed abst equation want 
box elim indicates rule targets expressions form eliminates equations abstraction precede elimination 
call extended tactic 
homogeneous equational law gives derived rule elim phi type phi phi rule rewrites law targetting allows select term rewrite provided unification infer commonplace step rewriting implemented simple wrapper 
recursive structure function key characteristic 
deriving useful properties 
consider example equality test natural numbers eq bool eq 
true eq 
false eq 
false eq 
eq obvious induction principle guess cases false eq elim phi bool type phi true delta delta delta eq phi phi bool eq phi suppose trying prove goal eq eq elim helpful analyses inputs test step case learn output 
prefer inversion principle eq inv phi true phi false bool eq phi problem arises rewriting tactics deserves closer attention 
applying rule goal instantiates result test constructor allowing reduce yielding easy prove eq inv eq elim details thesis key technique demonstrated section 
inversion principle useful characterization theorem eq true derived structure datatypes long ago phil wadler proposed mechanism allow type necessarily inductive alternative constructor presentation view mappings old new 
permits pattern matching programs view regardless underlying representation overcoming key drawback datatypes 
achieve similar effect deriving elimination rules 
suggested earlier elimination rule datatype motive indexed induces notion pattern matching consequently derived elimination rule induces derived notion pattern matching 
example function attaches element vector prove vect snoc elim type phi vect type phi phi xs phi xs xs vect phi xs gives alternative destructor functions element operation described earlier 
case analysis respect advantages destructor pattern xs clearly shows decomposition 
derived notion bigger yields derived notion structurally smaller recursive calls 
course comparing lengths types xs clearly smaller plenty derived notions smaller obvious 
example clearly smaller 
derive corresponding recursion principle plus rec phi type phi phi phi course says thing founded induction important way says matched recursive call legitimate 
plus rec explain find match just installs hypothesis collector style recursion rules proof similar 
patterns need derived notion case analysis 
possible compares numbers showing difference compare phi type phi phi phi phi rule splits plane regions diagonal proof illustrates key technique prove eq inv induction case allowing phi vary inside induction motive 
base cases positive axis origin positive axis fit neatly regions covered rule premises 
step case subtle know region point lies 
inductive hypothesis fully targetted elimination rule locates 
reduces goal instances corresponding premises 
phi type phi 
phi 
phi phi phi type oe phi oe phi oe phi phi unify phi phi phi example plus rec compare allow write euclid algorithm gcd 
gcd eliminating turn plus rec installs hypothesis collectors recursive calls lexicographically smaller pairs numbers 
analyse arguments compare case generated patterns compare gcd case gcd gcd gcd gcd gcd case gcd gcd diagonal case return cases return respectively 
remaining cases solved appeal hypothesis collectors recursive calls producing gcd 
program justified external argument relating subtraction right 
analysed data declaratively left terms employed structural recursion 
derived structure gets operational semantics clever matcher executing plus rec compare 
ideas underlying tactics techniques rooted folklore equational constraints induction instantiated relations hardly novel gap folklore implementable general purpose tactic gap bridged 
current theorem prover provides tactic comparable flexibility 
concise powerful style characterization supports data relations functions believe optimize large developments considerably people way new john major definition equality adequate express systems equations presence dependency 
supplied proofs confusion cycles properties constructors extend dependent datatypes underpinning unify update unification tactic 
hope technical contributions prove useful 
story far number ways technology improved extended 
example current separation abst suboptimal introduces equation eliminate little thought possible deliver analysis directly 
reason basic elimination behaviour functions generated automatically definition 
just datatypes split case rule capturing function pattern analysis recursion rule capturing termination structure 
mind important potential benefit elimination technology declarative power gives programming especially dependent types 
case analysis determines control flow refines type information 
separation case recursion characterization functions support derived notions structure role function depending computed index may terminate native derived structure analysis probably examine unify enable construct new programs interactively 
desirable high level term language elimination rules special kind dependently typed function defined invoked explicitly delivering derived patterns left hand side program 
deriving new elimination rules old potential add significant declarative power languages programming proof need extend underlying operational semantics calculus inductive types 
possible considerable inheritance technology coq project particular cristina cornes 
detail worked supervision goguen rod burstall owe debt gratitude 
james mckinna planted seeds grew uk epsrc gr continues support 

coq 
coq proof assistant manual 
pauillac 
inria fr coq doc main html apr 

cristina cornes 
inverting inductive predicates coq 
types proofs programs volume lncs 
springer verlag 

de bruijn 
telescopic mappings typed lambda calculus 
information computation 

gim enez 
codifying guarded definitions recursive schemes 
peter bengt nordstrom jan smith editors types proofs programs volume lncs pages 
springer verlag 

gim enez 
structural recursive definitions type theory 
proceedings icalp lncs 
springer verlag july 

zhaohui luo robert pollack 
lego proof development system user manual 
technical report ecs lfcs laboratory foundations computer science university edinburgh may 

conor mcbride 
inverting inductively defined relations lego 
gim enez paulin mohring editors types proofs programs volume lncs pages 
springer verlag 

conor mcbride 
dependently typed functional programs proofs 
phd thesis university edinburgh 

conor mcbride 
order unification structural recursion 
submitted journal functional programming february 

mckinna 
deliverables categorical approach program development type theory 
phd thesis laboratory foundations computer science university edinburgh 

alan robinson 
machine oriented logic resolution principle 
journal acm 

wadler 
views way pattern matching cohabit data abstraction 
popl 
acm 
