real time frp wan walid taha paul hudak yale university department computer science new haven ct usa taha walid hudak cs yale edu functional reactive programming frp declarative programming paradigm basic notions continuous time varying behaviors discrete event reactivity 
frp successfully reactive programming domains animation robotics graphical user interfaces 
success frp domains encourages consider real time applications crucial cost running program bounded known run time 
previous semantics implementation frp explicitly concerned issues cost 
fact resource consumption frp programs current implementation hard predict 
rst step addressing concerns presents real time frp rt frp statically typed language time space cost execution step program statically bounded 
take advantage existing languages bounded resources split rt frp parts reactive part captures essential ingredients frp programs base language part instantiated generic programming language shown terminating resource bounded 
allows focus issues speci rt frp forms recursion 
presenting operational explanation go wrong due presence recursion show typed version language terminating resource bounded 
frp programs expressible directly 
rest expressible simple mechanism integrates rt frp base language 
funded darpa nsf ccr 
funded subcontract johns hopkins university nsf agreement eia 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp september florence italy 
copyright acm 

real world software systems required respond external stimuli bounded amount time 
addition need execute xed amount memory 
today real time embedded systems designed implemented maintained 
trend continues reliability safety programming languages systems concern real time systems natural domain high level programming language 
functional reactive programming frp paradigm building host interesting reactive systems domains animation graphical user interface design robotics :10.1.1.17.7696
frp candidate high level language real time programming 
central semantic notions frp behaviors events 
provided user form parametric type behavior event respectively 
original denotational semantics frp behavior simply function continuous time corresponding intuition behavior value instant 
time modeled real numbers 
event contrast time ordered sequence event occurrences 
notions provide natural foundation describing systems recursive equations time parametric hybrid continuous discrete operators 
problem frp proven fast applications considered easy establish strong guarantees time space behavior 
goal provide practical framework clear guarantees cost frp computation 
distinct problems need addressed semantics frp denotational 
denotational model helps understanding meaning frp program explain program ectively executed digital computer nite resources provide natural notion cost 
second frp initially implemented embedded language haskell making assertions cost computation nontrivial 
third embedding language higher order language introduces power lambda calculus 
inherent expressiveness possibility writing programs perform unreasonable unbounded amounts computation time step subtle hard nd space leaks 
approach rst step addressing problems specify operational model execution frp program 
nature frp programs terminate continuously emit values interact environment 
appropriate model frp program execution nite sequence steps 
step current time current stimuli read result output value updated program state 
goal guarantee step executes bounded time program execution occurs bounded space 
guarantees arbitrary frp programs de ne subset frp called real time rt frp guarantees 
approach solve problems follows 
rt frp operational semantics provides de ned notion cost 
size derivation judgment de ning step execution provides measure amount time space needed execute step digital computer 

rt frp closed language sense embedded larger language haskell 
possible give direct operational semantics language provide tractable notion cost 
addition having explicit notion state feature model previous 
making state explicit allows specify ef cient destructive update semantics hard enforce embedded approach 

key aspect approach split rt frp naturally distinguishable parts reactive part base language part 
roughly speaking reactive part comparable synchronous system base language part language wish extend reactive setting 
show reactive part bounded cost terms time space independent base language 
reuse approach new base language having re establish results 
real time behavior base language carried independently techniques exist functional base language 
important question needs address treatment recursion source expressiveness computational cost 
key contribution restricting reactive part language limit time space needed execute computations 
achieve rst distinguishing di erent kinds recursion frp pure signals reactivity 
constraint rst form recursion lead programs getting stuck second form cause terms grow size 
address problems carefully chosen syntax carefully designed type system 
restrictions forms recursion inspired tail recursion 
organization section introduces syntax basic concepts 
section de nes explains type system operational semantics rt frp 
section explain di erent forms recursion rt frp cause semantics get stuck unbounded space 
section presents main technical results termination type preservation resource boundedness 
properties quali ed explicit assumptions base language 
section discusses related 
operational semantics example base language appendix 
brief rt frp section introduce syntax basic concepts rt frp 
behaviors events signals key di erence discrete models operational semantics continuous models denotational semantics discrete case behaviors events need values countable set points 
means interesting type isomorphism relating behaviors events event behavior data type data constructors just isomorphism possible combine behaviors events common type call signal treat concepts uniformly 
concrete base language syntax simplify presentation concrete base language syntax 

syntactic categories variables real numbers respectively 
unusual feature terms 
concise way writing just introduced earlier 
clarity occasionally take liberty common syntax provided clauses 
values base language represented terms reactive language syntax reactive part rt frp ev input time ext delay snapshot switch ev continue ev syntactic category continuation variables 
note base language terms occur inside signal terms way 
furthermore variable bound snapshot base language 
rest section explain reactive constructs rt frp detail 
primitive signals primitive signals rt frp current stimulus input current time time seconds 
time sucient illustrating operations want de ne external stimuli 
practice input may instantiated interesting types mouse clicks keyboard presses network messages interesting systems react time 
interfacing base language reactive part rt frp provide primitive operations addition subtraction values signals 
relegated base language interface base language reactive part rt frp mechanism exporting snapshots signal values base language mechanism importing base language values back signal world 
speci cally export signal snapshot current value snapshot construct invoke external computation base language ext construct 
illustrate suppose wish de ne signal representing current time minutes 
snapshot time ext compute externally signal snapshot separately 
example term snapshot snapshot ext signal point wise sum signals familiar frp recognize idea lifting primitive operations signal world 
de ne lifting operators lift ext lift snapshot ext lift snapshot snapshot ext case examples written simply lift time lift lift stateful constructs stateful constructs rt frp delay switch 
signal delay delayed version initial value illustrate delay term computes di erence current time time previous program execution step snapshot time snapshot delay time ext example operator frp turns boolean signal event occurs transitions false true 
useful operator de ned delay snapshot snapshot delay false ext 
second stateful construct switch de ne signals react signals 
example sample register remembers event value received de ned ext switch ev ext signal starts 
event ev occurs current value substituted body ext value current value switch construct 
recursion addition role exporting signal values base language snapshot construct de ne recursive signals 
combining delay recursive signals add internal state signals 
example de ne running maximum signal follows snapshot cur snapshot rmax delay ext ext rmax rmax initial step 
th step updated larger previous value value step rmax records maximum value previous step 
particularly useful stateful operation express rt frp integration time de ned forward euler method integral snapshot time snapshot snapshot st delay ext st ext fst st note internal state integral tuple running integral previous value previous sample time 
integration extremely useful de nition control systems 
example velocity mass force friction kv described recursive integral equation kv dt rt frp encoding signal simply snapshot integral ext modes continuations rt frp provides additional constructs allow de nition multi modal signals signals shift operating mode depending occurrence events 
example system switches signals technically possible snapshot switch result awkward requires extensive escape base language 
depending occurrence event ev snapshot snapshot snapshot ev continue ext ext ig ext continue declaration de nes set mutually recursive continuations 
continuation essentially signal parameterized variable corresponds naturally mode control systems design 
construct jump continuations event occurrences 
concrete example consider task implementing thermostat rt frp 
thermostat modes 
mode heater temperature rises ow condition 
condition temperature high occurs switches mode temperature gradually drops 
thermostat jumps back mode temperature true 
program de nes system snapshot temperature continue ext ext high ext ext oni ext ext high switch terms continuations possible express switch construct terms continuations fresh switch ev snapshot ev continue fk ki clarity de ne typing rule operational semantics switch directly 
semantics easy verify translation preserved execution 
reason consider switch proving properties rt frp 

semantics rt frp section explain type system operational semantics rt frp 
notation notation hf ng shorthand nite sequence hf fn omit superscript ng obvious context 
similarly write ff ng ff nite set ff 
fng 
type system simplicity presentation explicitly distinguish reactive types rt frp types provided base language 
types syntax rt frp types de ned follows input real unit 
meaning types vary depending assigned base language terms rt frp signals 
rst case usual interpretation 
second case mean signal carrying value type 
frp written behavior respectively 
di erent interpretations possible describe case signal type 
type input placeholder signature external stimuli visible system 
real real numbers unit singleton type 
type 
value 
having type base language allows treat behaviors events uniformly signals manner explained previous section 
type functions take argument type return value type convenient de nition type system identify set base types types functional part input real unit 
contexts variable context function variables annotated types 
annotated type written local written 
annotations need ensure phase distinction evaluation term updating term re ected detail allow guarantee type safety presence recursion 
treat contexts functions sets graph 
require variable names program distinct 
variable contexts annotated type 
annotations allow de ne functions variable contexts called expose export respectively xk gk continuation context 
function continuations types 
continuation contexts 
binding 
means continuation takes value type returns signal type typing judgment de nes rt frp type system judgment 
read signal type 
signal input type input 
signal time type real 
term ext signal type base language term type typing rule typed 
intuitively means continuations exported base language 
type delay type base language term type 
note term base type technical restriction necessary ensure type preservation 
term snapshot type assuming typed 
typing re ects fact recursive binding construct occur 
switch ev ev 
input input 
time real fx 
fx 

snapshot 
ext 

delay 

ev fx 

switch ev fx fk 
fk 
continue ev 
fk gg ev type system reactive part rt frp fx gg real unit 


fx type system example base language rt frp event type type scope type continuation form meaning fed value type signal type group mutually recursive continuations de ned continue 
continuation de nition form formal parameter term de nition body 
note contain continuations de ned declaration 
constraints resemble tail recursion call terms tail signals 
intuitively constraints establish set simple scoping rules continuations 
de nitions fu new continuation declaration refer surrounding continuation declarations 

ev sub terms contain free continuations shown rule 
analogy tail recursion lies just tail calls calls invocation tail signal invocation 
term type event ev match parameter type continuation result type type concrete example base language de nes fairly standard type system judgment read base language term type 
operational semantics full details operational semantics reactive part rt frp 
environments program execution takes place context variable environment continuation environment variable environments fx 
continuation environments fk 
variable environment store current values signals maps signal variables values 
environment maps continuation de nition 
lambda abstraction explicit formal argument signal parameterized argument 
judgment forms de nes single step semantics means judgments 
read evaluates read updated 
note semantics step parameterized current time current input combine judgments write 
environments empty write 
role evaluation compute output term 
role updating modify state program 
explain rules judgments shortly 
execution run rt frp program modeled nite sequence interactions environment sense terminate 
formally sequence time stamps external stimuli run rt frp program produces sequence values hv sk 
vk sk sequence run visualized nite chain form 

sn 
vn sn evaluation rules updating rules input 
input input time 
time time 
ext 
ext ext delay 

delay delay 
fx 

snapshot 

fx 
fx 
snapshot snapshot 
switch ev 
ev 
ev switch ev switch ev ev 
ev switch ev switch ev 
continue 
fk 
continue continue 
ev 
ev 
ev ev ev ev 
evm 

ug ev operational semantics rt frp mechanics evaluating updating evaluation rule calls base language rule uses judgment 
evaluate term example de nition judgment appendix 
lambda terms left unchanged updating 
evaluating input time constructs simply returns current value input time respectively 
updating constructs leaves unchanged 
note operationally time just inputs 
instantaneous value delay just updated new term delay previous instantaneous value new term resulting updating evaluation snapshot consists stages rst evaluated get second evaluated bound yielding result 
updating term done updating rules switch ev bit involved 
event occur default signal evaluated usual 
note updating rules update signal eventually switched 
means signal begins execution event occurs 
moving rule event occur new default value consisting replaced current value event 
evaluation continue straightforward exception value returned depend events fev behavior similar switch 
motivation design allow user de ne signals react snapshot switch ext switches signal value exceeds 
updating rules continue involved 
construct continue fk continuation de nitions fk unchanged executed continuation environment extended new de nitions 
construct events tested rst occurrence signal evolves de nition corresponding continuation formal parameter replaced value event 
event occurs get back original term sub terms updated 
go wrong 
rt frp supports forms recursion recursive pure signals de ned snapshot recursive switching de ned continue 
section discusses forms concrete run time problems cause 
getting stuck see untyped programs snapshot get stuck consider example evaluating snapshot ext ext requires evaluating ext environment bound rule 
essence problem occurrence body snapshot needed evaluation updating 
fact distinction evaluation updating exists primarily evaluation bootstrap recursion early phase give sensible notion updating expressions 
needing space second rule updating requires special attention replaces reactive term possibly larger reactive term environment lead unbounded program size 
example program continue ki ki larger ev occurs size larger 
properties rt frp section prove basic resource boundedness properties rt frp time space execution step bounded theorem main 
closed typed program know 
single step execution terminates preserves type 
bound time space needed execution 
proof 
proof rst part special instance lemma 
proof second part requires formalizing notions cost showing bounded execution program 
rest section technical details required establish result 
type preservation termination compatibility order express type safety property concisely concise way expressing necessary constraints environments involved statement properties 
general need assume value environment consistent type context 
say environment fx 
compatible context fx de ne follows fx fx fx 
similarly say fk 
compatible 
fk de ne 
follows fx fk fk fk 
easy show de nitions enjoy forms weakening lemma basic properties 
fx gg fx 
vg 

fx 
fx 
assumptions base language order prove key properties rt frp explicit assumptions base language 
assume key properties base language evaluation terminates preserves typing 
second values lifted type obvious forms distinguished head 
third type system enjoys substitutivity 
requirements formalized follows 

fx gg substitutivity substitutivity assumption base language possible establish lemma rt frp lemma substitution 
fx gg 

main lemma lemma type preservation termination 



exists value 



exists term 
proof 
proof parts induction height typing derivation 
proof rst part uses assumptions base language establish soundness ext construct 
proof second part uses substitutivity property rst part lemma 
property established easy see evaluation terminating deterministic base language deterministic 
resource boundedness having established language terminating come proof second part main theorem time space boundedness 
measure time space needed executing program term size run time modulo size base language terms 
measure reasonable observations size derivation tree bounded term size 
second derivation syntax directed time needed propagate information rule bounded size term assuming naive implementation term copied full 
focus showing exists measure programs increase run time 
formally de ne size term written jsj number constructors base language expressions continuations term jext ej sj jsj snapshot js js continue ng sj ju jsj js ev ng jsj mentioned earlier size term grow runtime 
show exists bound size term run time 
function continuation environments terms de ne bound 
gjj max jju jj sjj snapshot jj jjs jj jjs jj continue ng sjj ju maxf ng jj mg jjs ev ng jj max jj size bound free continuations order establish bound consider term context particular continuation environment 
de ne term size bound term continuation environment useful know measure upper bound term size jsj lemma 
jsj proof 
induction show term size grow execution size bound de ned lemma 
bound preservation implies jjs jj proof 
proof induction derivation follows 

rule derivation 
case jjs jj 
rule derivation 
delay delay induction hypothesis jjs jj jjs jj jjs jj 
rule 
proof induction hypothesis 

rule 
know continue continue fk 
note jjk fk 
gjj jj mg 
gjj mg induction hypothesis jjs jj ju jjs jj maxf gjj mg ju jjs jj maxf gjj mg 
rule 
case ev ng 
jjs jj jjujj maxf jjs jj jj ng maxf jjs jj jj mg 
done 

discussion related languages proposed synchronous data ow notion computation 
generalpurpose functional language lucid example style language 
relevant languages signal lustre esterel speci cally designed control real time systems 
signal central notion signal time ordered sequence values 
analogous sequence values generated execution rt frp program 
designers signal developed clock calculus reason signal programs 
lustre language similar signal rooted notion sequence owing nature lucid 
esterel ambitious language class 
compilers available translate esterel programs nite state machines digital circuits embedded applications 
relation current large ort develop formal semantics esterel including constructive behavioral semantics constructive operational semantics electrical semantics form digital circuits 
semantics shown correspond certain way constrained notion stability 
synchronous data ow languages considered recursion 
synchronous kahn networks extended proposals recursion higher order programming yielding large increase expressive power 
downside extension resource boundedness longer guaranteed 
rt frp shown syntactic restrictions type system possible achieve bound 
mycroft sharp develop statically allocated parallel functional language speci cation hardware 
language allows recursion restricts recursive calls tail calls 
explicit notion syntactic context specify tail call restrict recursive functions 
integrated restriction type system 
interesting see integration possible setting 
hybrid automaton commonly formal model hybrid system consists nite number control modes 
discrete events trigger system jump mode 
mode system state changes continuously 
formally established result expect limit maximum sampling period goes zero rt frp program implement hybrid automaton 
cml concurrent ml formalizes synchronous operations rst class purely functional values called events 
frp event combinators correspond cml choose wrap functions 
basic di erence meaning events approaches 
cml events ultimately perform action reading input writing output le process 
contrast events purely values generate 
previous frp de ned implementation semantics uses streams potentially nite sequences 
semantics basis current frp implementations 
fundamental di erence de ne sequences program execution just sequences values 
presents explicit model mechanics executing subset frp programs shows model establish guarantees relevant embedded systems applications 
may surprising reader familiar frp basic constructs missing rt frp 
constructs de nable rt frp 
de ned lift operators integral 
addition frp operators generate event values occur occur exactly respectively 
expressed rt frp follows ext ev snapshot ev snapshot delay 
ext ext frp till operator similar construct rt frp translated follows till ev switch ev ecient implementation subset frp java 
exact subset formally described characterized 
suitable extensions rt frp serve model addition number interesting evaluation strategies called push pull hybrid explored context interested formalizing models studying properties 
model machines environment provides type stimulus 
discussed base language invoked frp proposed method combining integrating kind machines 
ongoing yale antony courtney henrik nilsson john peterson suggests hughes arrows provide natural mechanism modeling signals explicitly parameterized input type expect approach bases language combining rt frp machines 
particularly interested antony courtney personal communication december 
personal communication may 
seeing approach model asynchronous systems synchronous processes 
chosen focus issue bounded resources presence recursion 
ultimately interested sophisticated models real time systems resources allocated priority see kieburtz nice account haskell point view 
signal lustre synchronous kahn networks account clock calculus 
technique may apply directly rt frp remains established 
connections semantics semantics multi stage languages 
evaluating recursive snapshot declarations requires evaluation binder 
problem arises constantly context multi level multi stage languages 
approach treatment problem annotations type system inspired multi stage languages 
evaluation updating functions analogous evaluation rebuilding functions multi stage language 
interesting see analogy continues hold continue development rt frp 
interested study cost preserving notions equivalence rt frp lines developed sands 
members flint frp groups arvind krishnamurthy simon peyton jones anonymous reviewers comments drafts improved nal version 
especially antony courtney henrik nilsson john peterson valuable discussions sharing ideas relation frp 
appendix base language semantics gives operational semantics base language 
berry 
esterel synchronous programming language mathematical semantics 
roscoe brookes editors winskel editors seminar concurrency volume lect 
notes computer science pages 
springer verlag 
gerard berry 
constructive semantics pure draft version 
draft version ecole des mines de paris inria july 
caspi halbwachs pilaud plaice 
lustre declarative language programming synchronous systems 
th acm symp 
principles programming languages january 
paul caspi marc 
synchronous kahn networks 
acm sigplan notices 
antony courtney 
functional reactive programming java 
proceedings symposium practical aspects declarative languages 
acm 
anthony daniels 
semantics functions behaviours 
phd thesis university nottingham december 
roberto di cosmo 
isomorphisms types calculus information retrieval language design 
progress theoretical computer science 
birkh auser 
conal elliott 
modeling interactive multimedia animation embedded language 
proceedings rst conference domain speci languages pages 
usenix october 
conal elliott paul hudak 
functional reactive animation 
international conference functional programming pages june 
thierry gautier paul le guernic besnard 
signal declarative language synchronous programming real time systems 
gilles kahn editor functional programming languages computer architecture volume lect notes computer science edited goos hartmanis pages 
springer verlag 
thomas henzinger 
theory hybrid automata 
technical report university california berkeley 
martin hofmann 
type system bounded space functional place update 
european symposium programming esop lecture notes computer science 
springer verlag 
hudak peyton jones wadler editors 
report programming language haskell non strict purely functional language version 
acm sigplan notices may 
paul hudak 
building domain speci embedded languages 
acm computing surveys electronic december 
paul hudak 
modular domain speci languages tools 
proceedings fifth international conference software reuse pages 
ieee computer society june 
paul hudak 
haskell school expression learning functional programming multimedia 
cambridge university press new york 
john hughes 
generalising monads arrows 
science computer programming may 
john hughes lars pareto 
recursion dynamic data structures bounded space embedded ml programming 
proceedings fourth acm sigplan international conference functional programming icfp volume acm sigplan notices pages september 
acm press 
john hughes lars pareto amr sabry 
proving correctness reactive systems sized types 
guy steele jr editor proceedings acm symposium principles programming languages popl volume st petersburg florida 
acm press 
richard kieburtz 
real time reactive programming embedded controllers 
available author home page march 
richard kieburtz 
implementing closed domain speci languages 
pages 
fx 
vg 












operational semantics functional base language 
oded maler editor 
hybrid real time systems international workshop hart grenoble france march proceedings volume lecture notes computer science new york ny usa 
springer verlag 
eugenio moggi walid taha el benaissa tim sheard 
idealized metaml simpler expressive 
european symposium programming esop volume lecture notes computer science pages 
springer verlag 

ong 
safe recursion interpreted light logic 
second international workshop implicit computational complexity santa barbara june 
alan mycroft richard sharp 
statically allocated parallel functional language 
automata languages programming pages 
oregon graduate institute technical reports 
box portland usa 
available online ftp cse ogi edu pub tech reports readme html 
viewed august 
john peterson gregory hager paul hudak 
language declarative robotic programming 
international conference robotics automation 
john peterson paul hudak conal elliott 
lambda motion controlling robots haskell 
international workshop practical aspects declarative languages 
sigplan jan 
gordon plotkin 
structural approach operational semantics 
technical report computer science department aarhus university 
rees clinger eds 
revised report algorithmic language scheme 
sigplan notices december 
alastair reid john peterson greg hager paul hudak 
prototyping real time vision systems experiment dsl design 
proc 
int conference software engineering may 
john reppy 
cml higher order concurrent language 
proceedings acm sigplan conference programming language design implementation pages 
sage 
declarative gui language haskell 
proceedings fifth acm sigplan international conference functional programming pages montreal canada september 
acm 
david sands 
na time analysis theory cost equivalence 
journal logic computation 
walid taha 
multi stage programming theory applications 
phd thesis oregon graduate institute science technology 
available 
walid taha editor 
semantics applications implementation program generation volume lecture notes computer science montr eal 
springer verlag 
walid taha el benaissa tim sheard 
multi stage programming axiomatization type safety 
th international colloquium automata languages programming icalp volume lecture notes computer science pages aalborg 
wadge ashcroft 
lucid data ow programming language 
academic press 
wan paul hudak 
functional reactive programming rst principles 
proceedings symposium programming language design implementation 
acm 
