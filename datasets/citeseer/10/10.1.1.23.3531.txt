proceedings symposium ai programming languages acm sigplan notices aug 
incremental garbage collection processes henry baker jr carl hewitt massachusetts institute technology cambridge massachusetts investigates problems associated argument evaluation order call order different call name call value 
call formal parameter function bound separate process called dedicated evaluation corresponding argument 
mechanism allows fully parallel evaluation arguments function shown augment expressive power language 
discuss approach problem arises context futures thought relevant created irrelevant ignored body expression bound 
problem irrelevant processes appears multiprocessing problem solving systems start processors working problem different methods return solution finishes 
parallel method strategy drawback processes investigating losing methods identified stopped reassigned useful tasks 
solution propose garbage collection 
propose goal structure solution plan explicitly represented memory part graph memory lisp heap garbage collection algorithm discover processes performing useful recycled new task 
incremental algorithm unified garbage collection storage processes described 
key words phrases garbage collection multiprocessing systems processor scheduling lazy evaluation eager evaluation 
cr categories 
copyright association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit direct commercial advantage copies show notice page initial screen display full citation 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists component works directly incorporation link requires prior specific permission fee 
permissions may requested publications dept acm broadway new york ny usa fax permissions acm org 
report describes research done artificial intelligence laboratory massachusetts institute technology 
support laboratory artificial intelligence research provided part advanced research projects agency department defense office naval research contract 

processors cheap evidence trend continue years 
result considerable interest apply large numbers processors solution single task 
efficient utilization processors requires lot communication sorting networks devised allow processor processor system send receive message clock pulse highest priority messages getting providing success failure sender 
furthermore transit time network log size network nlog 
clear processors communicating 
friedman wise quite rightly note applicative languages languages side effects pure lisp suited purpose representing algorithms intended execution host processors lack side effects eliminates great source complexity parallel execution 
church rosser theorems proved ensure invariance value applicative expression regardless order relative speed evaluation 
keep mind kind parallelism implement general form communication processes 
example possible implement airline reservation system language due nondeterminate behavior 
consider eager beaver evaluator applicative programming language starts evaluating subexpression soon possible parallel 
done mechanism futures roughly algol thunks evaluator process thinks 
friedman wise call futures promises hibbard calls 
expression evaluator user expression returned promise deliver value expression time expression value 
process created new immediately starts evaluating expression 
value needed explicitly primitive function evaluation process may may finished 
finished value immediately available requesting process forced wait finishes 
futures created recursively evaluation expression eager evaluator encounters functional application 
new created argument resulting parallel collateral evaluation arguments main evaluator process tackles function position 
call main evaluator process parent futures directly creates offspring 
proceedings symposium ai programming languages acm sigplan notices aug 
precisely tuple process cell queue process virtual processor initialized evaluate argument expression proper environment cell writable location memory save value argument computed avoid recomputing queue list processes waiting value 
process starts evaluating expression environment 
process needs value value ready requesting process enters queue goes sleep 
value promised ready process stores value cell wakes processes waiting queue dies 
henceforth process needing value find cell waiting computation 
main problem eager interpreter anticipates values going required compute final result wasteful 
process may assigned computation value needed case say process irrelevant 
way determining irrelevant processes tie significant amount system computing power 
furthermore caught non terminating evaluation computational power lost system forever 
sections argue garbage collection passive storage extended reclamation irrelevant active processes 
furthermore collection done incremental manner eliminating long delays required classical garbage collection 

garbage collecting irrelevant futures classical garbage collector passive storage proceeds marking root heap propagating marks marked nodes offspring unmarked node marked parent 
termination procedure unmarked nodes accessible root returned free list 
key garbage collecting active processes process states addressable vectors words common address space processors marked special type code 
vector stores contents registers process 
top level process assigned top level kept directly accessible root heap 
suppose processes garbage collection 
classical collector traces heap recognize encounters process 
marking process collector proves relevant restarted garbage collection finished 
process marked garbage collected processor reassigned 
irrelevant processes go away garbage collection fact accessible static data structure root heap 
relevant futures bound environment structure program variable temporary variable marked retained 
busy waiting extended system having sideeffects process synchronized busy assume processors embedded single global shared address space 
waiting accessible long parent accessible regardless process needs result 
may collected irrelevant 
reason busy waiting synchronization method 
garbage collection incremental ideas earlier turn dijkstra lamport 
mark phase incremental garbage collector process employs colors object white grey black 
intuitively white nodes known accessible grey nodes known accessible offspring checked black nodes accessible accessible offspring 
initially nodes including processes white 
white node grey shading making grey grey node marked shading offspring making node black indivisible processes 
marking initiated stopping processes shading root 
marking proceeds finding grey node shading offspring making node black 
grey nodes garbage collection done white nodes colors white black switch interpretations 
garbage collection begun user process restarted soon collector 
top level process pointed directly root heap restarted immediately 
obvious process black point directly white node 
wish preserve assertion 
running black process violate inserting registers white component node pointing immediately shades white node proceeding 
furthermore new node process needs created black 
intuitive rationale policies far black process concerned garbage collection finished 
furthermore nodes accessible garbage collector exactly accessible time garbage collection started 
prove correctness garbage collector informally 
garbage collector head start processes stopped started 
process restarted black sees grey collector wake 
process attempts catch collector tracing edge node access directly node immediately shaded 
pass catch collector 
collector traced node process get registers process affect connectivity nodes collector sees 
white grey processes allowed run created nodes black nodes darken monotonically number white nodes monotonically decrease proving termination 
garbage collector phase mark phase uses compacting copying algorithm marks copies operation 
algorithm copies accessible list structures old semispace new semispace 
node copied 
forwarding address left old address old semispace 
minsky copying algorithm collector stack keep track grey nodes proceedings symposium ai programming languages acm sigplan notices aug 
cheney algorithm uses scan pointer linearly scan new semispace updating pointers newly moved nodes moving nodes point 
correspondence coloring scheme algorithms white nodes reside old semispace grey nodes copied new semispace outgoing pointers updated point new semispace encountered scan pointer cheney algorithm black nodes moved updated scan pointer 
scanning done grey nodes accessible nodes copied old new semispaces interchange roles 
processors simple processors withdrawn start garbage collection allocated process 
garbage collection finished relevant processes restarted 
restriction white processes run relaxed condition white process may cause black node point white 
happen white process trying perform side effect black node 
operations type suspended process black proper garbage collector operation ensured convergence guaranteed 
conditions white processes create white cells 
white process encountered garbage collector allow colored black continuing 
notion processes marked storage may explain trouble dijkstra lamport trying prove parallel garbage collection algorithm correct 
algorithm mark user process coloring black prohibiting directly touching white nodes allows white processes run proof algorithm collects garbage long subtle see 

coroutines generators problem eager beaver evaluator expressions finite values continue evaluated mercy 
consider example infinite sequence squares integers 
give set lisp functions computing list 
lx 
cons compute element 
cons lx 
lz 
car define cons function 
car lx 
car ask st component 
cdr lx 
cdr ask nd component 
list squares start recursion 
evaluation start evaluating cons start evaluating forth 
computation terminate worry useful get done 
way ensure computation clog system convert lazy computation allowing proceed past point infinite list forces go far 
easily done performing lambda abstraction expression evaluation delayed 
evaluator try evaluate expression protect body evaluation eager 
lx 
cons lz 
protect early evaluation 
hack really necessary exponential scheduler proportion effort assigned process 
scheduler operates recursively assigning system effort top level spawns new futures allocates allowed effort offspring 
process waiting queue lends processing effort computation 
finishes returns effort helping system siblings 
set futures ordered created ordering forms tree 
result exponential scheduling tree top level lower priority scheduling 
eager produce squares exponentially discouraged 
processes enter queue square large number lend encouragement computation 
evaluator uses call cons obvious program mapcar lisp analog apl parallel application function vector arguments automatically function applications parallel pipe lined fashion 
due scheduler values earlier list accorded effort ones 
scheduler omniscient system effort reallocated garbage collector discovers irrelevant processes returns computing power help relevant tasks 

time space lazy evaluation call name evaluate thunks optimal strategy evaluating applicative expressions single processor sense number reductions procedure calls 
processor available evaluate expression clear strategy optimal 
known particular expression evaluated conjecture reasonable strategy allocate processor lazy evaluation processors performing eager evaluation 
believe eager beaver evaluator implements policy processors interfere excessively computation run faster eager evaluator running multiple processors lazy evaluator running single processor 
processors allocate believe exponential scheduling policy dynamically allocate processor effort needed 
universal creation futures reduce time necessary evaluate expression unbounded number processors available consider space requirements method compare methods 
space requirements futures hard calculate certain schedules order evaluation approximates call value schedules equivalent call name evaluated 
worst case space requirements proceedings symposium ai programming languages acm sigplan notices aug 
futures arbitrarily bad depending relative speed processors assigned non terminating futures 

power futures intuitive semantics associated runs asynchronously parent evaluation 
effect achieved assigning different processor multiplexing futures processors 
implementation language easily extended construct having form 
means evaluate expressions parallel return value finishes 
ward shows give scott type lattice semantics construct 
starts power set base domain gives usual subset lattice structure extends primitive function operate sets elements base domain obvious way defines result construct upper bound lub subset lattice 
construct approximated spawning futures polling parent process finishes 
point answer returned value expression futures inaccessible root heap 
give examples power construct multiply integrate exp bvar fast heuristic integrate exp bvar risch integrate exp bvar example numeric product routine value zero arguments zero non zero argument undefined 
second example integration routine symbolic manipulation language macsyma relatively fast heuristic integration routine looks common special cases general slow decision procedure called risch algorithm 
values methods guaranteed assuming perform integration properly need worry possibility non determinacy value expression non singleton subsets base domain ward lattice model 
may ask power construct increase expressive power language embedded 
partial answer question respect uninterpreted schemata 
uninterpreted schemata answer questions expressive power programming language constructs implicit language simulated 
example compare power recursion versus iteration context stacks simulated 
hewitt patterson shown uninterpreted parallel schemata strictly powerful recursive schemata 
difference parallel schemata simulate non deterministic implementation approximation singleton sets elements base domain returned 
computation infinite branch branches parallel 
ward shown construct strictly increases power calculus sense exist functions base domain inexpressible trivially expressible 

shared databases advantage garbage collection explicit processes apparent parallel processes access shared database 
databases usually protected inconsistency due simultaneous update mutual exclusion method 
process killed inside database database remain locked unresponsive processes requesting access 
solution propose database keep list pointers processes currently inside 
way irrelevant process accessible long inside accessible database 
moment emerges forgotten database subject reclamation garbage collection 
crowds component serializer synchronization construct designed manage parallel access shared database automatically performs bookkeeping 

method managing allocation processors storage subcomputations computation way tries minimize elapsed time required 
done anticipating subcomputations needed starting running parallel results compute needed 
anticipation subcomputations may started results needed 
method identifies revokes allocations storage processing power incremental garbage collection method 
scheme assumes processors reside common global address space mmp 
networks local address spaces look promising methods garbage collecting systems need developed 
currently plans implement method due lack access suitable hardware 
implemented systems mmp straightforward manner 

early thinking call done years ago rumbaugh 


baker jr list processing real time serial computer 
ai working mit ai lab feb cacm april 

sorting networks applications 
april 

berry gerard levy jean jacques 
minimal optimal computations recursive programs 
acm popl jan 

cheney nonrecursive list compacting algorithm 
cacm nov 
proceedings symposium ai programming languages acm sigplan notices aug 

dijkstra lamport martin scholten fly garbage collection exercise cooperation 
dijkstra note june 

dijkstra experience 
dijkstra note 

erman lesser multi level organization problem solving diverse cooperating sources knowledge 
proc 
ijcai sept 

fenichel lisp virtual memory computer systems 
cacm nov 

friedman wise cons evaluate arguments 
michaelson milner eds automata languages programming edinburgh university press edinburgh 

friedman wise impact applicative programming multiprocessing 
international conference parallel processing 

hewitt patterson comparative 
record project mac conference concurrent systems parallel computation june 

hewitt atkinson parallelism synchronization actor systems 
acm popl jan cal 

hibbard parallel processing facilities 
new directions algorithmic languages ed 
stephen 

lamport garbage collection multiple processes exercise parallelism 
mass comp 
associates ca feb 

lamport fly garbage collection rigor 
mass comp 
associates ca aug 

moravec role raw power intelligence 
unpublished ms stanford cal may 

vuillemin jean 
correct optimal implementations recursion simple programming language 
jcss 

ward functional domains applicative languages 
mac tr project mac mit sept 

wulf hydra kernel multiprocessor operating system 
cacm june 
