coherence qualified types mark jones translations equal translations equal 
apologies george translation farm 
research report yaleu dcs rr september meaning programs language implicit overloading described translating second language overloading explicit 
single program may distinct translations important show translations semantically equivalent ensure meaning original program defined 
property commonly known coherence 
deals implicitly typed language includes support parametric polymorphism overloading system qualified types 
typical applications include haskell type classes extensible records subtyping 
general case possible find examples coherence property hold 
extending development type inference algorithm language include calculation translations give simple syntactic condition principal type scheme term sufficient guarantee coherence large class programs 
interesting aspects terms target language provide semantic interpretation ordering relation types establish existence principal types 
practical level results explain importance unambiguous type schemes haskell 
consider task evaluating expression form depending way parsed expression treated 
fortunately matter choose fact associative necessary sufficient guarantee equivalent 
free choose whichever convenient retaining defined semantics case 
deals similar problem occurs programs oml simple implicitly typed language summarizes carried author member programming research group oxford supported serc studentship 
current address yale university department computer science box new haven connecticut usa 
electronic mail jones mark cs yale edu 
supported part darpa contract number 
overloading 
meaning programs described translating op extended language uses additional constructs overloading explicit 
different typing derivations oml program lead distinct translations just example important show translations meaning 
terminology need show meaning term depend way type checked property refer coherence 
type system oml extended form ml type system includes support qualified types 
central idea allow type expressions form oe represent instances oe satisfy predicate types 
applications qualified types include haskell type classes extensible records subtyping 
previous described standard type inference algorithm ml extended calculate principal type schemes terms oml 
extend results show arbitrary translation oml term written terms particular principal translation determined type inference algorithm 
exploiting relationship give conditions guarantee translations term equivalent 
remaining sections follows 
section outlines qualified types defines languages oml op translation 
simple example section shows single term may semantically distinct translations hope establish general coherence result arbitrary terms 
look conditions ensure coherence wide class programs possible 
step need specify exactly means translations equivalent 
dealt section syntactic definition typed equality op terms 
important tools development type inference algorithm ordering relation type schemes 
notion ordering possible talk principal general type schemes 
motivated section gives semantic interpretation op terms call conversions 
sections extend development type inference qualified types include calculation translations 
particular show translation oml term written form conversion particular kind principal translation fixed collections variables 
task establishing equivalence arbitrary translations reduces showing equivalence terms form conversions particular type 
obvious way approach problem show conversions equivalent 
exploring possibility section obtain sufficient conditions equivalence pair conversions particular type arbitrary pair translations 
particular show meaning term unambiguous principal type scheme simple syntactic condition defined generalizing earlier result special case system type classes 
section concludes description related ideas research 
details described full proofs results may 
basic definitions section outlines principal features system qualified types oml particular 
refer reader details 
predicates evidence language predicates types essential component system qualified types 
example predicates form eq hold precisely equality operator defined values type type classes 
predicates identify particular sets types term type treated having types set type holds object qualified type provide evidence predicates involved satisfied 
simple choice predicate form eq equality function values type exact form evidence particular application affect described think purely semantic interpretation predicates 
evidence values written language evidence expressions includes set evidence variables set evidence variables expression denoted ev 
final component system predicates entailment relation may vary application 
expression form indicates obtain evidence predicate predicate assignment list pairs form example eq eqlist eq indicate bound equality test values type expression eqlist gives equality test lists values 
lists properties entailment relation expected satisfy 
rules simple abbreviations blurring distinction sequences id term fst snd univ trans close sp sq ev predicate entailment evidence 
individual objects 
example list predicates vn list evidence variables write predicate assignment vn empty sequence written concatenation sequences written letter rule close denotes arbitrary substitution types type variables 
terms types deals relationship implicitly typed calculi support qualified types 
extension ml referred oml abbreviation overloaded ml 
terms oml simple untyped calculus addition construct enable definition polymorphic overloaded terms variable ef application abstraction local definition distinction types type schemes ml types terms oml type variables function types ae qualified types oe ae type schemes denotes type variable finite sequence predicates finite set type variables 
symbols treated right associative infix binary operators binding tightly 
additional type constructors lists pairs record types required 
set type variables appearing free expression denoted tv defined obvious way 
particular tv ae tv ae second language referred op abbreviation overloaded polymorphic calculus 
terms op oml additional constructs evidence abstraction application ee evidence application evidence abstraction convenient abbreviations dealing sequences evidence abstractions applications 
example vn en write ee abbreviations vn ee en respectively 
language types op grammar oe type variables oe oe function types oe polymorphic types oe qualified types oml qualified type identified op type op types considerably flexible oml distinction simple types type schemes 
particular op allows functions polymorphic overloaded values arguments 
strictly speaking need include construct op code polymorphic local definition important benefit including easier treat oml proper sublanguage op 
typing rules reasons space prevent including full typing rules oml op 
systems hybrid judgements oe oml term corresponding op term referred translation component judgements predicate assignment type assignment finite set pairs form oe term variable appears 
type assignments interpreted finite functions mapping term variables types 
write type assigned ax assignment obtained removing domain oe assignment maps oe 
typing rules 
note symbols ae oe restrict application certain rules particular kinds type expression grammar oml types 
restrictions mind ignoring translation component judgement gives typing rules oml 
hand disregard oml term judgement ignore distinction classes type oml obtain typing rules op 
significance hybrid formulation enables deal simultaneously oml op terms typing derivations structure 
relationship oml terms translations rules functional unicity type different derivations typing oml result distinct translations 
hand recover original oml term corresponding translation function erase erase ef erase erase 
erase ee erase erase erase ordering type schemes oml typing includes predicate set restricts environments predicates hold 
convenient slightly general notion type scheme contains constraints environments may 
definition constrained type scheme expression form oe set predicates oe type scheme 
type scheme oe may identified constrained type scheme form oe 
note need constrained type schemes op treat oe abbreviation op type oe write oe oe indicate oe general oe 
suitable ordering relation extending ordering type schemes damas milner treatment type inference ml suggested characterized follows definition suppose oe ff oe fi variables fi appears free oe oe oe types ff ff coherence problem justify translations semantics oml need show ffl oml term op term translation ffl translation typed oml term welltyped op 
ffl mapping terms translations welldefined 
words show translations oml term derivations oe oe precise sense equivalent 
properties follow immediately typing rules relatively simple show third property hold general 
example haskell provides standard functions read text string show text string converting values printable representations strings 
suppose type assumption containing functions implementations provided integers booleans predicate assignment fu text int text 
var oe oe ef ax ae ae ae ae oe oe oe oe tv tv oe ax oe hybrid typing rules oml op consider composition functions read show converting string type values back string 
instantiating quantified type variable type read show determines type intermediate values leads derivations translations clearly equivalent read show read show string string read show read show string string clearly hope establish general coherence result third item translations arbitrary oml term semantically equivalent 
rest modest goal identify collection oml terms coherence property established 
equality op terms establish sufficient conditions guarantee coherence need specify formally means terms specifically translations equivalent 
section gives syntactic characterization typed equality op terms judgements form oe implicit side condition oe oe op 
uniqueness evidence predicate assignments definition equality enables capture uniqueness evidence precise require evidence values constructed entailments semantically equivalent case write intend judgements meaningful entailments hold definition equality evidence expressions described directly condition essential degree coherence obtained 
example possible semantically distinct versions overloaded operator distinguished name type 
reduction op terms base definition equality op terms notion typed reductions judgements form oe implicit side condition oe op 
need include oe second side condition follows subject reduction theorem reduction preserves typing 
split definition reduction parts appears 
includes familiar definitions fi conversion evidence term abstractions expressions rule conversion evidence abstractions 
unfortunate consequence approach axiom fi sound models calculus call value semantics results applied languages lazy call name semantics 
limitation stems difficulty axiomatizing call value equality implicit particular application discussed section 
second collection rules describe renaming bound variables abstractions evidence fi oe fi oe fi oe je ev ev oe rules computation ff fv 
oe ffe ev 
oe ff fv 
oe rules renaming bound variables oe oe oe oe oe ef oe ax oe oe oe oe oe ee oe oe oe oe oe oe tv tv oe oe ax oe 
structural laws reductions terms 
abstractions expressions 
renaming permitted long avoid clashes free variables 
final group structural rules closely modeled typing rules op describe reduction subterms term 
equalities terms rules define equality relation terms op transitive symmetric closure reduction relation described 
rules ensure oe oe oe oe oe oe oe definition equality terms 
equality equivalence relation 
need include reflexivity direct consequence structural rules 
rule shows reductions give rise equalities 
practice rules definition equality implicitly proof equalities terms 
example uses rules subject reduction justify fact intermediate steps typed fi oe fi context equality established oe play part calculation 
examples quite common avoid mentioning context altogether situations writing indicate oe choice oe required side conditions hold 
property expressions may unfamiliar worth illustrating useful 
suppose eq int denotes equality function type eq bool consider oml term function applied integer values sufficient treat having type int int bool translation type inference algorithm calculates type eq bool results translation form calculation shows translations equal possible eliminate evidence abstraction second case 
second step justified result 
step equalities terms obtained replacing subterm equivalent term 
steps justified structural rules implicitly proofs 
conversions important tools treatment type inference ordering relation describe constrained type scheme general 
example assuming eq int ordering eq bool int int bool justify replacing integer equality function say int int bool generic equality function general type eq bool previous section 
breaks op due presence evidence abstraction application simply replacing give typed expression 
correct approach replace generally deal examples op terms interpretation ordering type schemes 
oe oe identify particular collection terms call conversions oe oe conversion closed op term oe oe term type oe treated having type oe applying conversion 
possible conversion example xe eq bool int int bool note type conversion general case expressed oml type scheme uses richer structure op types 
purposes type inference sufficient take term type oe oe conversion oe oe clearly inadequate concerned semantics terms involved replace ce guarantee terms equivalent evidence abstraction application 
formally need ensure erase ce erase op terms occurring translations oml terms 
erase ce erase erase obvious way ensure condition holds require erase equivalent identity term id ideas extend conversions arbitrary constrained type schemes 
tempting define set conversions oe oe set closed op terms oe 
oe erase equivalent id practice convenient choose conservative definition gives information structure conversions definition suppose oe ff oe fi fi appear free oe conversion oe oe written oe oe closed op term type oe 
oe ffl erase id ffl ff ffl ff ffl types evidence variables evidence straightforward verify term mentioned definition conversion oe oe follows equivalent op term type conversion kind 
hand assume conversions equivalent particular term may choice types evidence expressions definition 
immediate definitions oe oe conversion oe oe may require renaming bound variables oe apply definition conversions 
result properties ordering described extended analogous results conversions 
example proposition shows reflexivity corresponds identity conversion transitivity corresponds composition conversions 
proposition oe conversion id oe oe 
furthermore oe oe oe oe ffi oe oe ffi cx 
categorical perspective proposition show category objects type schemes arrows equivalence classes conversions 
additional properties needed justify composition equivalence classes welldefined associative easily verified 
ordering relation preserved substitutions corresponding result conversions proposition oe oe substitution types type variables oe oe 
ordering type schemes extends ordering constrained type assignments writing indicate dom dom useful extend definition conversions orderings type assignments 
purposes sufficient consider case orderings form just special case second 
simple approach define conversion ordering function gives conversion dom conversion oe oe treat term type oe having type oe typically conversion type assignments simultaneously replace occurrence variables mentioned type assignment appropriate new term 
perspective sensible think conversion type assignments term substitution 
furthermore translations term calculated respect particular predicate assignment component derivation oe may involve evidence variables domain assignment 
necessary specify variables explicitly part type conversion 
definition conversion type assignment constrained type assignment domain written substitution ffl dom dom dom particular dom cx ffl cx dom note expression cx definition denotes application meta language substitution particular variable op term 
continuing previous example assuming eq int possible conversion type assignment ordering int int eq substitution maps fixes variable 
see consider op term treated having type int int bool replace generic equality function general type need include evidence eq int 
precisely effect obtained applying conversion original term 
syntax directed translation sections follow development describe relationship arbitrary translation oml term particular translation determined type inference algorithm 
reasons space sketch details refer reader explanation motivation 
rules suited type inference algorithm clear obtain optimal principal typing term 
solution set typing rules structure derivation uniquely determined syntactic structure oml term show approach equivalent original type system 
var ff ff xe ff ef ax ax oe oe gen syntax directed typing rules translation note op translation oml term need uniquely determined may distinct choices evidence values introduced var course source incoherence translation semantics oml 
simple proof induction establishes soundness syntax directed rules respect 
theorem reverse process establish form completeness property showing translation typing obtained general rules sense described syntax directed derivation obvious 
example oe general possible derive typing system oe type scheme simple type 
theorem shows general typing obtained gen gen ae tv ae tv ae theorem shows possible find derivation way inferred type scheme gen general constrained type scheme oe original derivation translations related corresponding conversion 
theorem oe predicate assignment type term oe conversion gen oe 
proof structural induction quite complicated results interest right 
particular assume ffl sp sa substitution ffl ffl ce extends earlier results described 
type inference translation gives rules necessary extend type inference algorithm include calculation translation 
rules interpreted attribute grammar type assignment oml term judgement form ta inherited attributes predicate assignment substitution op translation type synthesized 
typing translation obtained type inference algorithm derived syntax directed system theorem ta ta combining theorem obtain corollary ta ta important shows translation oml term produced algorithm valid translation particular welltyped op term 
refer translations produced algorithm principal translations 
theorem provides strong motivation terminology showing translation obtained system expressed terms principal translation 
theorem substitution rq sa rt notation rt means ff rt ff finite number new type variables ff 
theorem describe relationship arbitrary translations oml term principal translation corollary ifv oe oe substitution conversion rgen ta oe rt sa oe 
var ff fi new fi ff xv fi ff ta ta ff ff new ut ta ef ff ax ff ff new ta ff 
ta tax oe oe gen ta ta type inference algorithm translation coherence results corollary important shows translation oml term particular context written form principal translation corresponding conversion 
applied arbitrary derivations oe oe follows oe oe conversions principal type scheme oe 
obvious way ensure translations equal show equality conversions slightly general view suppose conversions oe oe 
loss generality assume oe ff oe ff variables ff appear 
definition conversions follows types ff ff similarly types ff xe ff clearly sufficient show prove conversions equivalent 
equality immediate consequence uniqueness evidence evidence predicates evidence assignment equal 
argument applied second equality predicates ff may ff due differences ff ff ff tv 
fff tv tv predicate sets ff ff equal required 
give special name type schemes property definition type scheme oe ff unambiguous fff tv tv 
concept unambiguous type schemes haskell motivating term 
discussion shows conversions unambiguous type scheme equivalent proposition oe oe conversions oe unambiguous type scheme equality translations immediate corollary follows principal type scheme term unambiguous translations equivalent theorem oe oe principal type scheme unambiguous oe 
generalizes earlier result blott special case type system :10.1.1.47.1059
theorem easy concrete implementations 
step type checking oml program type inference algorithm calculate principal type translation 
program principal type typed rejected 
principal type unambiguous guarantee defined semantics program rejected 
example principal type scheme term example section int ambiguous program accepted 
note theorem gives condition sufficient necessary guarantee coherence 
example attempt compare empty list haskell evaluating leads error term ambiguous principal type eq 
bool evaluate true choice type variable hand established definition equality section conjecture restriction terms unambiguous principal types necessary sufficient guarantee coherence respect formulation provable equality 
related number researchers investigated coherence properties particular type systems process normalization typing derivations 
examples include systems explicit subtyping form implicit subtyping called scaling earlier treatment type classes 
basic idea case give collection reduction rules prove confluent preserve meaning reduction sequence terminates rules strongly normalizing confluence property guarantees existence unique normal form fact meaning preserved reduction sufficient guarantee coherence 
described rules reductions terms section correspond reductions derivations formulation syntax directed system thought means identifying normal forms derivation 
perspective theorem interpreted proof reduction process terminates preserves meaning 
having shown coherence property hold general case section guarantee existence unique normal forms confluence 
important novel feature conversions give semantic interpretation ordering constrained type schemes 
effect conversion acts record way derivation reduced 
information lost distinguish conversions provably equal seen retain sufficient detail establish useful conditions guarantee coherence 
conversions closely related mitchell functions give minimal typings restricted set terms version pure polymorphic calculus 
flexibility language types systems considered mitchell essentially op qualified types largely responsible difficulty extending larger collection terms 
problems avoided working oml type system restricted collection type schemes 
biggest limitations caused decision include fi reduction definition equality section 
immediate consequence results applied languages call value semantics 
problem occurs including coherence proof 
possibility rework results axiomatization equality call value semantics riecke clearly preferable find single formulation cases 
promising approach ideas category theory language intersection types subtyping system type classes 
main attractions categorical approach theoretical standpoint increased generality resulting higher level abstraction 
main benefit practical variable free approach avoids messy technical details involving free bound variables 
mentioned section treatment conversions strong categorical flavour hope able extend techniques developed provide general treatment coherence qualified types 
blott 
approach overloading polymorphism 
ph thesis department computing science university glasgow july draft version 
breazu tannen coquand gunter scedrov 
inheritance coercion 
ieee symposium logic computer science 

curien ghelli 
coherence subsumption 
fifteenth colloquium trees algebra programming 
springer verlag lncs 
damas milner 
principal type schemes functional programs 
th annual acm symposium principles programming languages 

categorical semantics type classes 
theoretical aspects computer software 
springer verlag lncs 
hudak peyton jones wadler eds 
report programming language haskell version 
acm sigplan notices may 
jones 
theory qualified types 
european symposium programming 
springer verlag lncs 
jones 
qualified types theory practice 
phil 
thesis 
programming research group oxford university computing laboratory 
july 
mitchell polymorphic type inference containment 
huet ed logical foundations functional programming addison wesley 
reynolds 
coherence languages intersection types 
theoretical aspects computer software 
springer verlag lncs 
riecke 
complete decidable proof system call value equalities preliminary report 
th international colloquium automata languages programming 
springer verlag lncs 
thatte 
type inference implicit scaling 
european symposium programming 
springer verlag lncs 
wadler blott :10.1.1.47.1059
ad hoc polymorphism ad hoc 
acm principles programming languages 

