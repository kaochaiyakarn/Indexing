journal parallel distributed computing article id available online www com scalable parallel algorithms geometric pattern recognition laurence boxer department computer information niagara university new york department computer science engineering state university new york buffalo buffalo new york russ miller department computer science engineering state university new york buffalo buffalo new york andrew rau chaplin faculty computer science university box halifax nova canada received october revised may accepted may considers variety geometric pattern recognition problems input sets size coarse grained multicomputer model consisting processors local memory memory cells log bits apiece processors connected arbitrary interconnection network 
introduces efficient scalable parallel algorithms number geometric problems including rectangle finding problem maximal equally spaced collinear points problem point set pattern matching problem 
algorithms scalable applicable efficient wide range ratios problem size number processors 
addition practicality imparted scalability algorithms easy implement required communications achieved small number calls standard global routing operations 
academic press key words parallel algorithms computational geometry scalable algorithms coarse grained multicomputer 
mail boxer niagara edu 
research partially supported niagara university research council 
mail miller cse buffalo edu 
research partially supported nsf iri 
mail arc ca 
research partially supported natural sciences engineering research council canada 
copyright academic press rights reproduction form reserved 

geometric pattern recognition important area research applications computer image processing manufacturing robotics vlsi design military intelligence typical problem parallel computational geometry calls efficient solution query involving geometric objects points lines polygons parallel computer processors 
previous theoretical parallel computational geometry assumed fine grained parallelism machine models including pram mesh hypercube pyramid computer 
commercial parallel computers coarse grained desirable parallel algorithms scalable implementable efficient wide range ratios interest coarse grained computational models vali design coarse grained geometric algorithms bmr dfr de dy motivated part observation fast algorithms fine grained models rarely translate fast code running coarse grained machines 
continues effort describing new scaleable algorithms variety problems pattern recognition 
organized section 
define model computation discuss fundamental data movement operations 
section 
give scaleable parallel algorithm find rectangles determined set planar points discuss straightforward solutions related problems 
section 
give scaleable parallel algorithm find maximal equally spaced collinear subsets finite point set euclidean space 
section 
give scaleable parallel algorithms find subsets finite set euclidean space match sense geometric congruence pattern 
section 
give concluding remarks 
preliminary versions appear bmr bmr 
results current improve cases correcting errors demonstrating faster running times results bmr bmr 

model computation scalable parallel algorithms 
preliminaries coarse grained multicomputer model cgm short considered consists set processors local memory memory cells log bits apiece processor 
processors may connected arbitrary interconnection network may share global memory 
commonly interconnection networks cgm include boxer miller rau chaplin mesh mesh hypercube fat tree 
processor may exchange messages log bits immediate neighbors constant time 
determining time complexities consider local computation time interprocessor communication time standard way 
term coarse grained refers fact size local memory assumed considerably larger 
definition considerably larger processor local memory store id number processor 
detailed description model associated operations see dfr 

terminology notation assumptions denote euclidean dimensional space 
sorting algorithms 
assume data sets may linearly ordered fashion clear context 
set tuples lexicographic order means integer xj xj 

fundamental operations problem suppose seq par respectively running times problem best sequential best parallel solutions 
par seq parallel algorithm optimal constant factor 
practice analysis cgm algorithm usually account time necessary interprocessor communications data exchanges global sorting operations order evaluate par 
time communications may cause par asymptotically greater seq 
denote sort time required efficient algorithm sort data cgm 
sorting fundamental operation implemented efficiently models parallel machines theoretical existing 
sorting important right basis variety parallel communications operations 
particular data movement operations implemented sorting 
permutation exchange 
permutation function 
processor pi sends list data items processor operation rotate data circularly sets processors 
semigroup operation 
xn data distributed evenly processors binary operation associative may computed serial time 
compute xn 
examples operations include total product minimum maximum 
scalable parallel algorithms parallel prefix 
xn data distributed evenly processors binary operation associative may computed serial time 
compute members xn 
parallel search 
xk yn ordered lists necessary sort separately distributed evenly processors 
xi searches value range values case mean xi learns indices members sort key interval ii 
formation combinations 
xn fixed positive integer form set combinations members exactly members xi xik ik 
formation pairs lists 
xk yn 
form pairs xi yj xi yj result useful comparing resources required problems different sizes 
lemma bmr 
positive integers sort sort kn cgm kn 
results discuss algorithms fundamental data operations implemented sorting 
proposition 
permutation exchange operation may implemented time sort cgm 
proof 
algorithm suffices 

permutation function operation 
parallel processor pi sequentially assigns tag value data items 
takes time 

sort data tag values 
takes tsort time 
algorithm running time dominated sort step assertion follows 
proposition bmr 
semigroup operation evenly distributed data may implemented time sort cgm 
operation processors value proposition bmr 
prefix operation may implemented sort time cgm 
operation prefix processor 
proposition 
lists data evenly distributed processors cgm parallel search member searches value range values may performed sort time 
boxer miller rau chaplin proof 
give algorithm search member searches single value 
minor modifications give algorithm member searches range values 
sort tsort time 

value sought xi letx 
xi create record ri components xi xi report 
rk 
takes time 

sort xi component members key field 
takes tsort time 

parallel prefix postfix operations member learns nearest member sorted desired value 
set report field equal corresponding member set report field fail 
takes tsort time 

sort members xi component 
takes tsort time 

member processor created reports report component corresponding xi 
takes time 
algorithm takes tsort time 
proposition 
xn 
fixed integer 
set combinations members members apiece xi xik ik formed tsort tsort time cgm 
log happen running time optimal 
proof 
algorithm follows 

circular rotation operations data processor processor entire list takes sort time 

parallel processor pi computes pth combinations members takes time 
time required tsort 
lemma tsort tsort np tsort 
running time tsort 
consider sorting term running time parallel sorting faster serial np tsort np log log 
log happen follows statement tsort log running time optimal output 
proposition 
lists evenly distributed processors cgm kn set may computed kn sort sort kn time 
log running time reduces kn optimal 
proof 
zij xi yj algorithm suffices 
allocate space array ij entries uninitialized kn time 

circular rotations processor copy entire list takes tsort time lemma tsort kp sort kn 

processor original share parallel processor computes share corresponding share kn time 
algorithm requires scalable parallel algorithms kn sort sort kn time 
parallel sorting faster serial sorting term running time sort kp log kp log log follows sorting term kn tsort boxer miller rau chaplin running time kn optimal kn output 
algorithms desirable remove efficiently duplicate list entries 

lemma 
list sets cardinality duplicate members may removed sort kn time cgm kn 
proof 
give algorithm 
sort tuples lexicographically 
takes tsort kn time 

sort lexicographically 
takes tsort kn time 

perform prefix operation remove entry ordered list equals predecessor 
running time algorithm proposition assumption prefix values complexity prefix values current operation complexity takes kn sort kp time iso tsort kn 
algorithm requires sort kn time 

rectangle problems section give scalable parallel algorithm solve rectangle finding rectangles ar problem 
say polygon vertices belong ar problem find rectangles serial solution problem vk 
proposition vk 
solution ar problem log output worst case 
log time required serial algorithm solves ar problem 
cgm solution ar problem obtained forming line segments endpoints sorting segments sweeps parallel prefix operations ordered segments yield rectangles 
algorithm follows 
theorem 
input 
ar problem solved sort log time cgm log 
proof 
note rectangle may determined pair opposite sides nonnegative slope 
observation allows avoid duplicate construction rectangles 
give algorithm steps 

form set line segments endpoints nonnegative slopes member represented pair members respect lexicographic order 
may done sort time trivial modification algorithm associated proposition 

define order elements decreasing order significance slope length equation ax nonzero coefficient equal line perpendicular endpoint order equations lexicographic order triples endpoint note order pair opposite sides rectangle pairs opposite sides rectangles 
sort members takes sort time 

parallel prefix operations 
determine unique exist opposite sides rectangle 
determine scalable parallel algorithms ord ord number rectangles side number rectangles sides precede proposition operations require sort time 

assign side log rectangles follows 
ith rectangle gets side 
values may assumed associated corresponding ordered set side rectangle parallel search operations proposition sort log time 

assign second side opposite side log rectangles follows 
ith rectangle second side member index ord 
second side rectangles may determined parallel search operations sort log time 
running time algorithm sort log 
boxer miller rau chaplin straightforward modifications algorithm theorem yield output estimates vk sh problem worst case output par rectangles sort cgm squares sort cgm 
maximal collinear sets section give scalable parallel algorithm solve maximal equally spaced collinear subsets problem set points euclidean space find maximal equally spaced collinear subsets determined segments length problem studied 
algorithm runs optimal serial time 
essentially sequential algorithm 
different algorithm efficient fine grained pram optimal fine grained mesh 
say collinear line contains members 
collinear set spaced members lexicographic order line segments length set equally spaced collinear subset determined segments length properly contained equally spaced collinear subset determined segments length problem interesting regularity sought meaningful seemingly irregular environment 
collinear equally spaced subsets represent street lights fence posts land mines algorithm sorting steps searches sweeps reminiscent standard propagation algorithms 
give algorithm 
theorem 
fixed positive integer 
problem solved sort time cgm 
proof 
give algorithm 

sort members lexicographic order 
takes sort time 

determine set ordered pairs distinct data points member pair precedes second 
may done algorithm proposition sort time 
sorted ordered pair formed set 

sort members ofl respect length primary key lexicographic order secondary tertiary keys respectively 
takes sort time 

parallel processor determines ordered pairs xi xj third point xi xj equally spaced collinear triple xi 
done time 

perform parallel search determine pair xi xj note value xk 
takes tsort time 

xi xj create record li xi xj determined previous step takes time 

perform component labeling step 
ordering allows records inherit order members li length consecutive xk enumeration members 
regard third fourth components record representing indices line segment endpoints fifth component finite indicating vertex graph component sixth seventh components forming component label 
perform parallel prefix operation sort time compute members defined follows 
suppose 
scalable parallel 

step prefixes identical components represent maximal equally spaced collinear subsets sort respect decreasing priority sixth seventh third components records members maximal equally spaced collinear set grouped consecutively sixth seventh components maximally equally spaced collinear sets points ordered third components 
takes sort time 
running time algorithm sort 

point set pattern matching section give scalable parallel algorithms solve point set pattern matching problem set points euclidean space pattern find subsets congruent 
serial fine grained parallel solutions problem papers including dr sl 
boxer miller rau chaplin assume coordinates members input problem evenly distributed processors cgm 
give different algorithms solving point set pattern matching problem different values dimension ambient euclidean space 
roughly different dimensions produce different constraints complexity output 
give algorithms restricted realization rotation translation 
serial algorithm case dr shown worst case output complexity 
cgm algorithm determining translations reflection followed translations satisfy theorem 
point set pattern matching problem solved cgm sort time 
proof 
give algorithm 

sort members coordinates tsort time 

sort members coordinates tsort time 

broadcast processors 
takes time 

compute 
values represent translations member members greater 
takes time 

define true true associate index values computed parallel search operation sort time 

tsort time sort ai respect primary key secondary key 

observe matched translation sends sj ai true 
sort time perform parallel prefix operation ai determine indices yield translations 
lq qth index translation sending sj satisfies note members forming set matches translation marked indices associated ai 

sort time parallel prefix operation produce list indices lists lq index member translated 
list ordered list indices translated copies 
steps find matches obtained translating order find matches obtained reflecting translating compute set repeat previous steps substituted takes sort time 

may happen subset match may eliminate duplication algorithm lemma sort time 
algorithm takes sort time 
optimal wish output ordered worst case output 

scalable parallel algorithms fixed constant 
euclidean plane complexity output point set pattern matching problem part limited complexity function number line segments length endpoints function introduced erd 
proposition sst 

implicit 
proposition 
output point set pattern matching problem complexity kd 
proof 
length line segment 
line segments length endpoints endpoints necessary condition existence ik ik match existence match 
values determines matching matching complexity assertion follows 
sequential time necessary find line segments length endpoints denoted 

proposition 
fixed 
theorem 
point set pattern matching problem solved sequentially kd log time 
cgm algorithm solving point set pattern matching problem finding rigid transformations euclidean plane take fixed line segment endpoints line segment endpoints satisfy algorithm 
boxer miller rau chaplin theorem 
point set pattern matching problem solved tsort kd tseq tsort kd time cgm kd 
kd running time sort kd seq sort kd proof 
note follows theorem seq 
give algorithm 

broadcast processors determine processor euclidean distance function 
takes time 

determine combinations si sj si sj done follows 
parallel processor pi determines pairs members distance 
si subset contained pi 
perform circular rotations keeping processor pi si 
rotation operation pi copies si sj processor pi finds combinations sq sr sq si sr sj sq sr operations take sort seq pt sort time 

pairs si sj members distance determine points zm matches si sj zm 
takes time 

pairs si sj members distance determine zm may done parallel search operation tsort time 

triples si si si si si si matches determine exist si sik si si si si sik matches done follows 
triple determine unique matches 
takes kd time 
zj determine zj jth component tuple components indices respectively si si si zj jth component tuple fail 
may done parallel search operation tsort kd time 
perform parallel prefix operation remove tuples constructed fail entry 
remaining tuples represent matches step requires kd tsort time 

may happen subset match may eliminate duplication algorithm lemma sort kd time 
algorithm requires pt sort sort kd seq pt sort sort kd time 
follows lemma pt sort sort np kd np kd running time reduces 
sort kd seq sort kd section scalable parallel algorithm solving point set pattern matching problem considerations construct upper bound complexity output 
fixed positive integer 
suppose members polynomial functions degree maximal number polynomial pieces minimum lower envelope function denoted 
shown atal maximal length davenport schinzel sequence defined parameters function worst slightly linear extremely slowly growing inverse ackermann function sh 
current discussion 
example general result 
theorem 
scalable parallel algorithms 
proposition 
maximum number line segments length endpoints 
boxer miller rau chaplin follows theorem expression appears analysis algorithm nearly constant 

proposition 
output point set pattern matching problem complexity kn 
theorem 
point set pattern matching problem solved serial computer kn log time collinear set kn log time general case 
give algorithm special case 
proposition 
finite subsets 
suppose line subset matches identified cgm kn sort kn time 
proof 


give algorithm 

sort lexicographic order 
takes tsort time 

sort lexicographic order 
takes tsort time 

form list ordered pairs si sj distinct members proposition takes tsort time 
note 

time broadcast pk processors 

prefix operation form list members representing line segments length equals length line segment pk 
proposition takes sort time 
proposition 

identify subset matches including necessary sufficient determine exists tuple ik sim sim belongs line segment sis length im equals length determine desired points im im match may done kn time 
perform parallel search determine im proposition may done sort sort kn time 
parallel prefix operation consolidate matches previous step contiguous list 
may done sort kn time 
list matches complexity kn 

may happen subset appears list matches twice 
wish eliminate duplications subsets represented may algorithm lemma sort kn time 
algorithm takes scalable parallel algorithms sort kn time 
proposition follows lemma prove theorem 
lemma 
finite subsets 
listing member subsets line segments determined match line segments determined output 
cgm algorithm solving general point set pattern matching problem may described follows 
determine collinear set 
collinear apply algorithm proposition 
triangle determine rigid transformations take triangle vertices satisfy algorithm 
theorem 
finite subsets 
subset congruent identified cgm kn sort kn time collinear set tsort kn time general case 
proof 
loss generality implies give algorithm 

circular rotations processors processor 
takes tsort tsort kp time 

determine collinear set 
done follows 
note processor 
determine ak boxer miller rau chaplin collinear kp time 
collinear set ak collinear 
collinear set note index ar collinear 
may done minimum respect indices operation sort time proposition followed time broadcast ar processors 

collinear set execute algorithm proposition 
finishes current algorithm additional sort kn time 
continue steps 

sort lexicographically 
takes tsort time 

pair si sj distinct members form line segment si sj 
set line segments 
proposition step takes tsort time 

form set 
line segment ai 
processor value takes time 

sort set lengths members primary key lexicographic order coordinates endpoints secondary key 
takes sort time 

number members length equal length 
mark sublist members length equals length determine value performing parallel prefix operation 
time required sort 
length matched member report failure halt 
note proposition 
mark sublist entries length equal length done parallel prefix operation sort time 
report failure halt 

sij si sj find sjm sj sm sij sjm matches may done parallel search find sij subrange members sj initial endpoint testing member sjm subrange match 
members requires search determine subrange containing suitable candidates sjm searches may performed parallel search operation sort sort time 
follows lemma pairs sij sjm sij sjm sij sjm matches pairs ij sjm may formed circular rotations accompanied formation pairs time 
lemma sort mp tsort time form pairs sij sjm 
note pair sij sjm corresponds triple si sj sm vertices match ar 

collinear triple si sj sm vertices matches ar describe time unique rigid transformation si sj sm 
triples creating descriptions takes time 

proceed follows 
rigid transformations ijm determined compute set ijm ijm members determine search member equals 
processor operations done computation sets parallel search operation 
altogether operations require respectively kn ando tsort kn time 
operations required step take tsort kn time 

sets match may duplicate sets determined distinct 
desired may eliminate duplication algorithm lemma tsort kn time 
algorithm requires scalable parallel algorithms sort kn time collinear set tsort kn time general case 

rotations translations section give scalable parallel algorithms problem restrictions pattern matching realized rotation translation assume pattern set cardinality sampling set cardinality 
theorem 
rotation origin may kn log serial time 
translation may kn log serial time 
give scalable parallel version theorem 
algorithm rotations observation set rotations origin intersection set rotations origin similar observation translations key algorithm translations 
boxer miller rau chaplin theorem 
rotation origin may tsort kn time cgm kn 
translation tsort kn time cgm kn 
may proof 
set angles rotation origin satisfies set angles rotation origin satisfies worst case happens contained circle centered origin 
give algorithm 

sort distance origin primary key angular coordinate secondary key 
takes tsort time 

compute forming kn pairs angle may rotated distance origin 
may done tsort kn time follows 
form algorithm proposition tsort kn time 
kn time processor examines pairs distance origin forms corresponding pair 

sort ai respect angular coordinate 
takes tsort kn time 

note appears angular component consecutive entries ordered list ai 
set may com puted parallel prefix operation ai ino kn sort time 
algorithm compute takes tsort kn time 
similar algorithm find set translations tsort kn time 
modifications algorithm step sorted lexicographical order 
replace second step follows 
define 
sets computed forming pairs tsort kn time 
sorted follows 
sorted lexicographically union lists sorted lexicographically 
step translation vector takes subset appears translation component consecutive entries ordered list 

summary scalable parallel algorithms 
remarks examples optimal efficient scalable parallel algorithms 
finding rectangles determined set planar points 
indicated solutions related problems 
finding maximal equally spaced collinear subsets finite set euclidean space 
solving various versions point set pattern matching problem euclidean spaces 
far know algorithms cases scalable parallel algorithms solution respective problems 
cases parallel algorithms solution respective problems machines granularity 
acknowledgments gratefully acknowledge suggestions anonymous referee concerning presentation results 
agarwal partitioning arrangements lines 
ii 
applications discr 
comput 
geom 

agarwal intersection decomposition algorithms planar arrangements cambridge univ press cambridge 
agarwal sharir shor sharp upper lower bounds length general davenport schinzel sequences combin 
theory ser 

akl lyons parallel computational geometry prentice hall new york 
atal atallah dynamic computational geometry problems comp 
math 
appl 

boxer finding congruent regions parallel parallel comput 

boxer point set pattern matching pattern recognit 
lett 

boxer faster point set pattern matching pattern recognition letters 
boxer miller parallel algorithms maximal equally spaced collinear sets maximal regular coplanar lattices pattern recognition letters 
bmr boxer miller rau chaplin scalable parallel algorithms geometric problems suny buffalo department computer science technical report 
bmr boxer miller rau chaplin scalable parallel algorithms geometric problems proceedings iasted conference parallel distributed computing systems pp 

boxer miller rau chaplin bmr boxer miller rau chaplin scaleable parallel algorithms lower envelopes applications parallel distrib 
comput 

chazelle optimal convex hull algorithm new results cuttings proc 
nd ieee symposium foundations computer science pp 

clarkson edelsbrunner guibas sharir welzl combinatorial complexity bounds arrangements curves surfaces discrete computational geometry 
culler karp patterson schauser santos von eicken logp realistic model parallel computation proc 
th acm sigplan sym 
principles parallel programming davenport schinzel combinatorial problem connected differential equations amer 
math 

dfr dehne fabri rau chaplin scalable parallel geometric algorithms multicomputers pp 

proc 
th acm symp 
computational geometry dehne deng fabri randomized parallel convex hull algorithm coarse grained multicomputers proc 
th acm symp 
parallel algorithms architectures pp 

de dy deng efficient routing message bounds optimal parallel algorithms pp 

proceedings international parallel processing symposium dr de lee point set pattern matching dimensions algorithmica 
ferreira rau chaplin scalable convex hull triangulation algorithms coarse grained multicomputers parallel distrib 
comput 

erd erdos set distances points amer 
math 
monthly 
goodrich point set pattern matching johns hopkins university department computer science technical report jhu 
architecture independent model coarsegrained parallel machines purdue university computer sciences technical report csd tr 
sh hart sharir nonlinearity davenport schinzel sequences generalized path compression schemes combinatorica 
kahng robins optimal algorithms extracting spatial regularity images pattern recognit 
lett 


lei 
parallel algorithm finding congruent regions comput 
graphics 
miller stout parallel algorithms regular architectures meshes pyramids mit press cambridge ma 
sh pach sharir repeated angles plane related problems combin 
theory 
sl shih lee yang parallel algorithm finding congruent regions parallel comput 

sst spencer trotter jr unit distances euclidean plane graph theory combinatorics pp 
academic press london 
vali valiant bridging model parallel computation comm 
acm 
vk van kreveld de berg finding squares rectangles sets points bit 
wi sh sharir planar realization nonlinear davenport schinzel sequences segments discrete computational geometry 
