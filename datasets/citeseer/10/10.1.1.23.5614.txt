compositional reasoning model checking sergey campos edmund clarke carnegie mellon university usa universidade federal de minas january 

brayton 
symbolic model checking method verifying complex finite state reactive systems 
models computer system state transition graph 
efficient algorithms traverse graph determine various properties satisfied model 
bdds possible verify extremely large systems having states :10.1.1.1.5124
systems industrial complexity verified technique 
systems include parts futurebus standard pci local bus robotics systems aircraft controller :10.1.1.38.358
spite success symbolic model checking limitations 
cases bdd representation exponential size system description 
behavior called state explosion problem 
primary cause problem parallel composition interacting processes 
problem occurs number states global model exponential number component processes 
explicit state verifiers suffer state explosion problem severely symbolic verifiers 
problem symbolic verification systems preventing applied larger complex examples 
state explosion alleviated special techniques compositional reasoning 
method verifies component system isolation allows global properties inferred entire system 
efficient algorithms compositional verification extend applicability formal verification methods larger interesting examples 
describe approaches compositional reasoning 
automatic completely transparent user 
require user intervention achieve better results 
suited applications efficient 
example partitioned transition relations lazy parallel composition automatic preferred cases user intervention research sponsored 
desired user expert 
techniques provide way compute set successors predecessors state set constructing transition relation global system 
transition relations component separately traversal state graph 
individual results combined give set states global graph corresponds result operation performed 
automatic technique interface processes 
technique attempts minimize global state transition graph focusing communication component processes 
method considers set variables interface components minimizes system eliminating events relate communication variables 
way properties refer interface variables preserved model smaller 
assume guarantee reasoning manual technique verifies component separately 
behavior component depends behavior rest system environment 
user specify properties environment satisfy order guarantee correctness component 
properties assumed 
assumptions satisfied component satisfy properties called guarantees 
combining set assume guarantee properties appropriate way possible demonstrate correctness entire system constructing global state graph quite large 
methods verify realistic systems 
shows compositional reasoning effective method increasing applicability model checking tools 
furthermore necessity verification complex industrial systems 
remainder organized follows section introduces formal model finite state systems kinds parallel composition consider 
section describes partitioned transition relations section discusses lazy parallel composition 
interface processes reasoning described sections respectively 
concludes section summary directions research 
model description system verified constructing model involves important steps 
constructing model individual components 
second composing submodels global model 
start showing represent component symbolically graph 
describe parallel composition algorithm create global model 
representing single component representing state transition graph symbolically involves determining set states deriving transition relation graph models component 
consider system set variables synchronous circuit set typically outputs registers circuit primary inputs 
case asynchronous circuit usually set nodes 
protocol software system set variables program 
state described giving values variables system finite state encode states boolean vectors 
assume encoding done variables boolean 
state described valuation assigning variable 
valuation write boolean expression true exactly valuation 
example fv valuation hv derive boolean formula boolean formula represented bdd 
general boolean formula may true valuations 
adopt convention formula represents set valuations true describe sets states boolean formulas bdds 
practice bdds efficient representing sets states explicitly 
denote sets states letter denote bdd representing set set variables bdd may depend 
arbitrary boolean functions 
addition representing sets states circuit able represent transitions circuit 
extend idea 
just representing set states bdd represent set ordered pairs states 
just single copy state variables create second set variables think variables current state variables variables state variables 
variable corresponding state variable denote valuation variables viewed ordered pair states circuit represent sets valuations bdds 
write formula true iff transition state represented state represented example transition state hv state hv write formula disjunction transitions transition relation model 
transition relation write denote bdd represents 
ordering bdd variables current state variables interleaved current state variable adjacent corresponding state variable usually heuristic decreasing size bdd transition relation 
parallel composition technique shows construct graph models component system 
usually systems described set components execute concurrently 
synchronous asynchronous circuits components smaller circuits connected construct bigger circuit 
protocols programs components processes execute parallel 
major ways composing processes circuits synchronously asynchronously 
synchronous composition processes execute time step process corresponds exactly step processes 
asynchronous composition hand process executes point time 
process steps remain unchanged 
choice process steps time nondeterministic 
different algorithms composing synchronous asynchronous systems 
fig 

modulo counter synchronous systems method deriving transition relation synchronous system illustrated small example 
consider circuit modulo counter fig 

fv set state variables circuit fv copy state variables 
transitions modulo counter phi phi equations define relations phi phi describe constraints satisfy legal transition 
constraint seen separate component composition generates counter 
constraints combined conjunction form transition relation general case synchronous system components fn delta delta delta nn gamma set transition relations component 
transition relation determines values subset variables state 
analogous modulo counter conjunction relations forms transition relation delta delta delta nn gamma transition relation synchronous circuit expressed conjunction relations 
bdd transition relation possible compute bdd represents say transition relation monolithic represented single bdd 
monolithic transition relations primary bottleneck verification size exponential number equations define 
asynchronous systems synchronous systems transition relation asynchronous system expressed conjunction relations 
alternatively expressed disjunction 
simplify description transition relations obtained assume components system exactly output internal state variables 
case possible describe completely component function values state variables component drives output value specified 
components elements function may depend current value output component inputs 
extending method handle components multiple outputs straightforward 
speed independent asynchronous systems arbitrary delay transition enabled occurs 
model allowing component choose nondeterministically transition 
results conjunction parts form gamma delta model similar synchronous case discussed allows variable transition concurrently 
normally interleaving model asynchronous variable allowed transition time 
apply distributive law conjunction giving disjunction terms indices ae terms corresponds simultaneous transitioning subset variables model 
second keep terms correspond exactly variable allowed transition disjuncts vector contains exactly 
results disjunction form delta delta delta nn gamma gamma delta notice method asynchronous systems composed components synchronous systems composed components 
partitioned transition relations model checking necessary compute image pre image set states transition relation state successor transition words holds image set states set successors set transition relation boolean formulas image formula theta denotes existential quantification variables similarly state predecessor state iff true 
set predecessors state set described formula theta formulas type called relational products 
possible implement relational product conjunction series existential quantifications practice fairly slow 
addition obdd larger obdd final result avoid constructing possible 
reasons special algorithm compute obdd relational product step obdds gives algorithm arbitrary obdds function obdd set variables obdd return return result cache return top variable top variable topmost obdd ifthenelse obdd endif insert result cache return endif fig 

relational product algorithm algorithms uses result cache 
case entries cache form set variables quantified obdds 
entry cache means previous call returned result 
algorithm works practice exponential complexity worst case 
situations complexity observed cases obdd result exponentially larger obdds arguments 
situations method computing relational product exponential complexity 
previous section described construct global transition relation individual transition relations component processes 
size significantly larger sum sizes goal able compute relational products constructing global transition relation explicitly 
disjunctive partitioning global transition relation asynchronous system may written disjunction transition relations individual components system 
case relational product form theta delta delta delta nn gamma practice computing value large formula quantifiers usually expensive 
existential quantifier distributes disjunction shrink scope quantifier individual components theta delta delta delta theta nn gamma technique possible compute relational products larger asynchronous systems 
conjunctive partitioning synchronous systems relational product form theta delta delta delta nn gamma unfortunately existential quantification distribute conjunction directly apply transformation asynchronous case 
simple counterexample reduces true apply partitioning circuits exhibit locality depend small number variables subformulas moved outside scope existential quantification depend variables quantified optimize computation relational product early quantification variables pick order ae considering partitions relational product 
define set variables process depends subset consisting variables process ordering depends ae ae gamma gamma ae illustrate example modulo counter 
depends fv phi depends fv phi depends fv choose ordering ae fv fv fv transform relational product ae theta ae ae theta ae 
sn ae gamma theta sn gamma ae gamma putting theta delta delta delta 
sn ordering ae significant impact early computation state variables quantified 
affects size bdds constructed efficiency verification procedure 
important choose ae carefully just bdd variable ordering 
example badly chosen ordering ae modulo counter yields fg fg fv results optimization 
practice fairly easy come orderings give results 
search ordering ae greedy algorithm find ordering variables eliminated 
ordering variables obvious ordering relations relation ordering variables eliminated order greedy algorithm 
algorithm fig 
gives basic greedy technique 
start set variables eliminated collection sets set variables depends 
eliminate variables oe compute cost eliminating eliminate variable lowest cost updating fig 

algorithm variable elimination 
time choosing variable cost appropriately 
remains determine cost metric 
consider different cost measures 
simplify discussion refer relation created eliminating variable conjunction depend quantifying refer set variables depends 
minimum size cost eliminating variable simply jd cost function try insure new relation create depends fewest number variables 
minimum increase cost eliminating variable jd gamma max jaj difference size size largest containing intuition try avoid eliminating variables create large relation small relations 
words prefer small increase size large relation create new large relation 
minimum sum cost eliminating variable jaj simply sum sizes containing cost conjunction depends sizes arguments approximate cost number variables argument depends 
goal size largest bdd created elimination process 
abstraction translates finding ordering minimizes size largest set created process 
making locally optimal choice guarantee optimal solution counter examples cost functions 
fact problem finding optimal ordering shown np complete 
cost function provide best approximation cost actual bdd operations practice best performance 
lazy parallel composition lazy parallel composition alternative method compositional reasoning related partitioned transition relations 
way partitioned transition relations global transition relation constructed 
contrast previous method restricted transition relation processes created 
restricted transition relation agrees global transition relation important states may behave different way states 
advantage comes fact cases possible construct restricted transition relation significantly smaller global transition relation 
possible ways constructing restricted transition relation produce correct results 
original global transition relation state set computation set successors restricted transition relation satisfies condition formula means agree transitions start states possible represent significantly fewer nodes cases constrain operator 
boolean formulas constrain formula truth value variable assignments satisfy variable assignment satisfy value arbitrary 
words ae don care cases size significantly smaller size lazy composition algorithm uses constrain operator simplify transition relation process generating global restricted transition relation 
computing set successors state set represented boolean formula algorithm computes constrain transition constrain agrees transitions start definition constrain operator 
consequence transition relation agrees global transition relation transitions start 
computing set successors produces result method applied computing set predecessors state set case constrain operator maintain transitions implemented lazy composition algorithm obtained significant gains space time verification 
example verification took seconds memory dropped seconds eager composition lazy composition fig 

lazy parallel composition 
meg memory method applied 
example verified partitioned transition relations took time twice memory comparison lazy composition algorithm 
significant part savings come constructing global transition relation 
savings partitioned transition relation case 
new method requires memory 
reason partitioned transition relations heavily influenced order partitions processed order determines variables quantified early 
proposed method happen variables quantified time 
susceptible order partitions processed suitable cases determining processing order difficult 
new technique easier automate 
partitioning vs lazy composition mentioned earlier lazy parallel composition sensitive partition ordering partitioned transition relations 
comes fact step partitioned transition relation depends step gamma shown diagram theta theta step step consequences final degree partitioning heavily depends order quantify variables 
seen example dependency section 
lazy parallel composition hand requires independent processing component depend order constraints applied theta step step interface processes important observation leads approach compositional verification 
communication processes defined explicitly usually involves small number variables 
communicate variables assume processes communicate set variables oe 
observe behavior oe 
means replace equivalent process indistinguishable respect oe completely preserve behavior idea find smaller hides events irrelevant oe 
interface rule guarantees correctness abstraction respect oe restriction variables oe oe set ctl formulas free variables oe 
interface rule states conditions satisfied oe jja ctl formula oe true jjp remainder section describe algorithm practice meaning rule precise 
cone influence reduction compute oe cone influence reduction 
assume system specified set equations define cone influence variable minimal set variables depends construct new reduced model removing equations left hand side variables appear oe 
easily shown iff contains variables oe 
consider example modulo counter fig 

set equations phi phi clearly fv depend variable fv depends variables variable depends set variables 
soundness interface rule order interface rule sound need specify properties process equivalence satisfy 
process sigma set atomic propositions state variables sigma language temporal formulas alphabet sigma processes sigma sigma oe sigma axioms satisfied 
implies sigma 
jjq jjq qjjp qjjp 
jjp oe jj oe jjp oe oe jjp 
sigma sigma sigma iff sigma theorem soundness 
interface rule sound 
remind reader interface rule states oe jja ctl formula oe imply jjp 
proof 
oe ka oe 
oe kp oe jja jjp oe ka oe derive kp oe immediately get jjp required 
definition equivalence define concrete equivalence relations processes fulfil requirements suitable framework 
bisimulation equivalence synchronous systems stuttering equivalence asynchronous systems 
give efficient polynomial algorithms determine equivalence processes cases 
bisimulation equivalence 
consider models set atomic propositions 
definition 
binary relation theta called bisimulation relation implies ii definition 
bisimulation equivalence maximum bisimulation relation subset inclusion preorder 
notice definition bisimulation relation viewed fixpoint equation 
bisimulation equivalence just greatest fixpoint equation 
gives rise simple polynomial algorithm computing bisimulation equivalence known iterative procedure 
compute decreasing sequence relations sequence converges fixpoint th step 
convergence guaranteed finite state case subset inclusion preorder founded directions 
choosing appropriate guarantees fixpoint greatest fixpoint en required bisimulation equivalence 
sequence relations defined inductively follows 
se iff 
sen iff implies en implies en complexity algorithm mn number states size transition relation 
efficient algorithms computing bisimulation equivalence example paige tarjan algorithm 
complexity log time space number states size transition relation 
unclear algorithm employ bdds 
general state space infinite convergence possible continuous models define bisimulation equivalence words bisimulation equivalence intersection 
memory system access controller access unit execute controller execute unit pa pe fig 

cpu controller 
stuttering equivalence 
bisimulation stuttering equivalence defined computation paths models 
intuitively paths considered stuttering equivalent partitioned finite blocks repeated states corresponding blocks equivalent paths relative labeling functions models 
distinguish executions differ number idle cycles transitions 
stuttering equivalence definition terms greatest fixpoint give resulting algorithm compute 
fixpoint definition easily extracted algorithm 
similarly bisimulation define inductively sequence relations converges finite state case stuttering equivalence intersection 
se iff sen iff 
path starts ffl path starts ffl partition ffl partition ffl nonempty finite ffl sen 
path starting path satisfying conditions 
interface processes example consider cpu controller units fig 

comprises parallel processes access unit fetches instructions stores instruction queue 
execution unit pops instructions interprets 
interface process ape able verify number states times small kp assume guarantee reasoning assume guarantee manual method verifies component separately 
ideally compositional reasoning exploits natural decomposition complex system simpler components handling component time 
practice component verified may necessary assume environment behaves certain manner 
components system guarantee behavior conclude verified properties true entire system 
properties deduce additional global properties system 
assume guarantee paradigm uses method 
typically formula triple hfi temporal formulas program 
formula true part system satisfying system satisfy typical proof shows hfi hold concludes hfi true 
proof strategy expressed inference rule hfi hfi soundness assume guarantee rule form straightforward 
order automate approach model checker able check property true systems built component 
generally able restrict class environments doing check 
elegant way obtain system property provide preorder finite state models captures notion behaviors logic semantics relates preorder 
preorder preserve satisfaction formulas logic formula true model true model smaller preorder 
additionally composition preserve preorder system smaller preorder individual components 
satisfaction formula correspond smaller particular model tableau formula preorder 
take combination formalisms satisfy requirements 
standard definition synchronous process composition simulation preorder temporal logic actl subset ctl existential path quantifiers 
choice motivated existence efficient model checking algorithm actl expressiveness important verification tasks done logic 
simulation preorder natural choice simple intuitive easily automated 
employ tableau construction methods converting formulas processes 
informally tableau formula greatest process preorder 
distinguish formulas processes write example mean easy see choice formalisms meets requirements 
particular synchronous composition restrict possible behaviors 
greater system containing focus proving properties separately automatically prove properties arbitrary system containing tableau construction verify checking relation 
assumptions model correspond composition 
model set behaviors assumptions model mk assumptions 
triple im corresponds km 
words discharging assumptions corresponds checking preorder 
rule allows multiple levels assume guarantee 
earlier mentioned logic preserve preorder 
formalize state properties explicitly 

removing behaviors change formula true false 
check know system containing satisfies 

structure allows assumption composing 
model model proved actl satisfies properties 
implementation assume guarantee reasoning suppose want show 
terms triples need prove assume satisfies property verify assumption show satisfies auxiliary property 
show satisfies required property assumption extends system containing done 
intermediate formulas processes smaller respectively transition relations construct significantly smaller mathematical notation apply assume guarantee rule hai haim im framework corresponds km soundness assume guarantee rule 
theorem 
assume guarantee rule sound 
proof 
transitivity 
composing sides get km km parallel composition commutative associative group left hand side composing sides obtain km assumption km transitivity draw rule 
example futurebus protocol 
david long type reasoning verify liveness cache coherence protocol futurebus :10.1.1.38.358
design divided parallel components represent single modules cache memory bus example requires levels assumptions guarantees 
technique specifications satisfied single bus configuration multiple bus configurations 
details verification 
describe methods fighting state explosion problem arises frequently due parallel composition communicating processes 
clear compositional reasoning critical formal verification 
dramatically reduces complexity permits verification significantly larger systems 
compositional methods extensively verify large complex systems futurebus pci bus protocols 
doesn cover existing methods 
plenty compositional techniques successfully partial model checking automatic method encoding processes formula simplifying theorem proving techniques decompose prove manually property component approaches different kinds limitations remains done 
general problem hard trade efficiency automation 
powerful methods handle enormous complexity usually require expert user lot manual efforts 
usually involve heavy theorem proving intricate manipulations system modeling order verification go 
hand completely automatic tools handle complex systems manual ones 
problem heavily rely heuristics may may different types examples intellectual done user 

henrik andersen 
partial model checking extended 
technical report id tr department computer science technical university denmark october 
accepted lics 

bryant 
graph algorithms boolean function manipulation 
ieee transactions computers august 

burch clarke long 
symbolic model checking partitioned transition relations 
vlsi edinburgh scotland 

jerry burch edmund clarke david long kenneth mcmillan david dill 
symbolic model checking sequential circuit verification 
ieee transactions computer aided design integrated circuits april 

campos clarke 
tool quantitative analysis finite state real time systems 
workshop languages compilers tools real time systems 

campos clarke 
computing quantitative characteristics finite state real time systems 
ieee real time systems symposium 

campos clarke 
verifying performance pci local bus symbolic techniques 
proceedings ieee international conference computer design pages 

campos 
quantitative approach formal verification real time system 
phd thesis scs carnegie mellon university 

clarke grumberg jha long mcmillan ness 
verification futurebus cache coherence protocol 
editor proceedings eleventh international symposium computer hardware description languages applications 
north holland april 

coudert madre 
verification synchronous sequential machines symbolic execution 
sifakis editor proceedings international workshop automatic verification methods finite state systems grenoble france volume lecture notes computer science 
springer verlag june 

dam 
compositional proof systems model checking infinite state processes 
proceedings concur volume lecture notes computer science pages 
springer verlag 

orna grumberg david long 
model checking modular verification 
acm transactions programming languages systems may 

ieee computer society 
ieee standard futurebus logical protocol specification 
ieee standard edition 

intel 
pci local bus specification 

misra chandy 
proofs networks processes 
ieee transactions software engineering se july 

paige tarjan 
efficient algorithms partition refinement 
siam journal computing dec 

pnueli 
transition global modular temporal reasoning programs 
apt editor logics models concurrent systems volume nato asi series 
series computer system sciences 
springer verlag 

touati lin sangiovanni vincentelli 
implicit state enumeration finite state machines bdd 
ieee int 
conf 
computer aided design pages 
