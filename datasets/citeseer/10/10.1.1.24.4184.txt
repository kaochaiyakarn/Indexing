limits control flow parallelism monica lam robert wilson computer systems laboratory stanford university ca discusses techniques useful relaxing constraints imposed control flow parallelism control dependence analysis executing multiple flows control simultaneously speculative execution 
evaluate techniques trace simulations find limits parallelism machines employ different combinations techniques 
major results 
local regions code limited parallelism control dependence analysis useful extracting global parallelism different parts program 
second superscalar processor fundamentally limited execute independent regions code concurrently 
higher performance obtained machines multiprocessors dataflow machines simultaneously follow multiple flows control 
speculative execution allow instructions execute control dependences resolved modest amounts parallelism obtained programs complex control flow 
potential parallelism evaluated different perspectives 
propose actual system design performance system lower bound amount available parallelism 
second perform studies limits parallelism particular approach enforcing constraints associated approach relaxing constraints 
upper bound performance unacceptably low approach inadequate 
hand upper bound expectations approach may sufficient 
low limits draw interesting 
study wall contains surprising result suggests severe limitation current approaches :10.1.1.115.6325
experiments study examines performance research supported part darpa contract nsf graduate fellowship 
proceedings th annual international symposium computer architecture gold coast australia may pp 

copyright fl acm processor uses aggressive hardware algorithm predict outcomes branches 
instructions predicted path branch speculatively executed branch resolved 
processor perfect memory disambiguation perfect register renaming unlimited instruction fetching large number functional units 
reported speedups processor set non numeric programs range 
assumptions perfect memory disambiguation large number functional units speedups quite small 
wall result contrasts sharply experiments assume perfect branch prediction 
machine perfect branch prediction requires refer machine oracle 
effects control flow parallelism essentially eliminated oracle machine branch outcomes known advance 
parallelism available oracle machine suggesting bottleneck wall experiment due control flow 
ultimate goal study discover ways increase parallelism order magnitude current approaches 
focus control flow 
study limits parallelism hope establish inadequacy current approaches handling control flow identify promising new directions 
offers evidence limit parallelism discussed wall apply non numeric programs measured 
processor uses speculation exploit local parallelism mispredicted branches fundamentally limited 
compiler locate global parallelism code extracting true control dependence program 
increased opportunity parallelization fully exploited machine simultaneously pursue multiple flows control 
degree parallelism fundamentally limited von neumann architecture 
higher performance obtained machines simultaneously follow multiple flows control 
analyze techniques speculative execution control dependence analysis multiple flows control 
evaluate techniques empirically computing limits parallelism set programs machines employ different combinations techniques 
far research superscalar sor architectures conducted independently 
studies instruction processor levels parallelism interact 
study suggests useful characteristic predicting parallelism program control flow data dependent 
introduce major concepts section 
explain speculative execution control dependence analysis pursuing multiple flows control 
section presents set machine models techniques various combinations 
section describe experimental framework evaluate limits parallelism 
section presents results experiments analyzes parallelism machine model 
section presents study describes implications specific architectures proposed implemented 
relaxing control flow constraints perfect branch prediction oracle machine upper bound techniques relax control flow constraints 
unfortunately unrealistic upper bound 
branch outcomes known advance oracle machine instructions wait branches resolved 
achieve performance machine speculatively execute possible paths program 
requires hardware resources exponential number outstanding conditional branches 
perfect branch prediction realistic practical techniques required handle control flow 
section examines techniques speculation branch prediction control dependence analysis flows control 
speculation branch prediction speculation possible paths infeasible practice limited speculation commonly computer systems improve performance 
example modern processors prefetch instructions conditional branch 
machines ibm pursue execution paths prefetching instructions branch target 
common technique improve efficiency speculation speculate instructions execution path 
success approach depends accuracy branch prediction 
non numeric code hardware software prediction algorithms shown accurate time 
extending speculative instruction fetching speculative execution creates additional parallelism 
instruction fetching speculatively executing instruction may generate unwanted side effects 
side effects discarded branch prediction incorrect 
software techniques implement speculative execution 
various hardware structures proposed support speculative execution 
structures store results speculative instructions branch direction determined 
branch prediction correct results committed discarded 
hardware scheduling limited fact instruction simply execute fetched 
difficult fetch instructions far ahead predicted execution path especially programs complex control flow 
software techniques overcome instruction fetch limitations reordering instructions 
trace scheduling identifies executed trace schedules instructions trace belong large basic block 
implemented trace scheduling algorithms employ limited forms speculation 
smith extend software scheduling hardware support speculative execution 
instructions speculatively executed boosted conditional branch 
instructions labeled results discarded committed branch condition determined 
combines ability software eliminate fetch limitations ability hardware speculatively execute instructions side effects 
control dependence analysis hardware instruction schedulers speculatively executed instructions discarded conditional branch mispredicted 
constraint unnecessarily strict 
consider simple example assignment executed assignment executed regardless value say control dependent condition control independent 
refer branch instruction control dependent control dependence branch 
hardware scheduler generally determine instructions control independent 
example suppose scheduler speculatively executes condition resolved 
branch mispredicted hardware discard assignment repeat identical assignment 
compiler compute control dependence eliminate inefficiency 
generally control dependence analysis allows instructions moved branches 
expanding range code parallelism extracted control dependence analysis increases available parallelism 
control dependence intuitively simple concept 
block structured programs immediate control dependence instruction simply condition closest enclosing control construct 
example code foo bar call foo function control dependent condition turn control dependent loop exit condition 
bar function control dependent part loop execute parallel loop assuming data dependence foo bar 
control dependences programs arbitrary control flow easily computed compiler reverse dominance frontier algorithm 
hardware techniques analyzing control dependences considered detect small subset control independent instructions require complex hardware 
executing multiple flows control control dependence analysis discovers parallelism different regions code may flow control 
example control dependence analysis shows bar function run concurrently preceding loop 
uniprocessor typically follow flow control time 
uniprocessor fetch execute instructions loop arbitrary control flow may bar function 
support flows control necessary fully exploit parallelism uncovered control dependence analysis 
multiprocessor architectures general means providing support 
processor mimd multiprocessor follow independent flow control 
extreme possible generate uniprocessor code corresponds pursuing multiple flows control original computation 
small number code segments packed generating different versions code possible combination control flow 
general combining independent control flows lead significant code expansion 
machine models establish fundamental limits techniques relaxing control flow constraints define set machine models analyze parallelism machine ideal conditions 
machine model uses different combination techniques 
approach examine set instruction traces real programs base instruction execute immediately preceding branch trace resolved 
implies branch instructions execute order cycle 
cd instruction execute control dependence branches resolved 
addition branch instructions execute order cycle reflect inability pursue multiple flows control simultaneously 
cd mf instruction execute control dependence branches resolved 
multiple branch instructions execute parallel need ordered 
sp instruction execute immediately preceding mispredicted branch trace resolved 
implies branch instruction wait preceding mispredicted branches 
sp cd instruction execute mispredicted control dependence branches resolved 
addition branch instruction wait preceding mispredicted branches just ones control dependent 
sp cd mf instruction execute mispredicted control dependence branches resolved 
additional constraints branches 
oracle constraints due control flow 
control flow constraints machines compute available parallelism simply enforcing true data dependence constraints control flow constraints associated machine model 
constraints due imperfect memory disambiguation reuse variables limited resources ignored 
define machines 
base machine uses techniques provides baseline comparison 
oracle machine perfect branch prediction performance represents upper bound parallelism assumptions experiments 
machines combinations control dependence analysis cd multiple flows control mf speculative execution branch prediction sp 
interesting combinations recognize independent flows control control dependence analysis 
machine distinguished ability handle control flow 
model abilities imposing sequencing constraints shown execution instruc tions dynamic traces 
aggressive machines restrictive constraints 
base machine uses techniques control flow constraint severe prevents instructions executing preceding branches 
cd machine perfect control dependence information instructions dependent branch need wait resolved 
reflect limitation flow control impose ordering branch instructions 
model behavior current compilers ordering requires branches program execute original sequential execution order 
cd mf machine may follow unlimited number flows control require branch ordering constraint 
machines speculative execution study speculatively execute instructions execution path 
simultaneously executing instructions alternate paths require instructions cancelled regardless branch outcomes 
various sp machines speculative instructions potentially useful making machines realistic oracle machine 
sp machine speculate infinite number consecutive branch outcomes 
essentially creates infinitely long path predicted instructions program 
instructions path may execute parallel 
branch mispredicted instructions predicted path branch cancelled 
instructions cancelled appear traces analyze 
control flow constraint instruction trace execute preceding mispredicted branches resolved 
long branch predictions correct flow control change branch instructions execute order 
mispredicted branch requires flow control transfer unpredicted branch path mispredicted branch execute cycle 
sp cd machine differs sp machine treatment mispredicted branches 
cancelling instructions predicted path instructions control dependent mispredicted branch cancelled 
due single flow control mispredicted branches executed order 
sp cd mf machine follow multiple flows control simultaneously mispredicted branches execute parallel 
illustrate power different machine models consider flow graph 
assume data dependences program 
node graph consists single instruction 
node set branch instructions immediately control dependent 
edges represent possible flow control branch outcomes highlighted bold arcs 
possible trace graph example flow graph trace shown 
instruction trace identified instruction node number letter distinguish specific instance 
branch instructions written boldface circled mispredicted 
edges trace represent control dependence relationships 
data dependences program oracle machine simply executes instructions cycle 
executions machine models shown edges represent dependences due control flow instructions level execute time 
base machine executes branches sequentially non branch instruction cycle preceding branch 
cd machine executes instructions earlier control dependent immediately preceding branches 
cd mf machine need execute branches order edges simply control dependence edges trace 
sp machine executes instructions mispredicted branches parallel 
sp cd machine behaves similarly executes instructions earlier control dependent mispredicted branches 
sp cd mf machine executes instructions cycle 
instruction predicted path machine speculatively execute instruction 
instruction executed processor discovers mispredicted branch 
contrast achieve performance oracle machine instructions executed parallel iteration 
illustrates fundamental difference sp cd mf oracle sp cd mf machine pursue alternate paths simultaneously 
base cd cd mf sp sp cd sp cd mf execution machines experimental framework section describes methodology analyze parallelism machine model 
interested evaluating techniques handling control flow limit scope experiment include fundamental constraints related control flow 
data dependence assume idealistic approach handling data dependences 
data dependence constraint enforced read operation trace wait immediately preceding write operation location 
relaxes constraints reality 
enforcing true data dependences reads writes eliminated writes reads output dependences writes writes register memory accesses 
practice various renaming techniques remove spurious data dependences 
second assume memory perfectly disambiguated machines determine addresses identical computed 
perfect disambiguation upper bound achieved compiler analysis speculative hardware disambiguation 
third instruction wait determined preceding instructions alter instruction operands 
different data dependences may occur different control flow paths shown example depending outcome condition assignment may may executed 
value assigned depends outcome condition 
potential data dependence delays assignment condition resolved 
potential data dependence constraints force instructions wait branches speculation branch prediction relax constraints 
example predict execute execute speculatively assumption 
prediction incorrect assignment re executed correct value unable include potential data dependence constraints experiment execution path captured trace 
constraints analyzed statically 
static analysis completely accurate presence indirect memory perfect disambiguation possible trace 
ensure results upper bounds avoid introducing constraints imperfect disambiguation ignore potential data dependence constraints 
program transformations procedure calls loops control constructs commonly implemented ways introduce unnecessarily serializing constraints 
constraints eliminated alternate implementation techniques simple transformations procedure inlining loop unrolling 
study tries model upper bound techniques 
procedure calls returns introduce unnecessary control flow cause problems branch prediction 
furthermore new stack frame typically allocated deallocated procedure incrementing decrementing stack pointer 
true data dependence increment decrement stack pointer manipulations executed sequentially 
programs small procedures may limit parallelism 
simulate optimal case inlining procedures including recursive procedures ignore call return instructions trace instructions manipulate position stack pointer 
parallelism loops inhibited dependences loop index variables 
loop index variables induction variables incremented loop iteration creating true data dependences iterations 
dependences result way code generated scalar processors inherent part loop semantics 
loop unrolling simple technique compilers reduce effects 
experiment simulate perfect complete unrolling 
analyze object code discover loops program 
iterative data flow analysis identify registers incremented constant exactly loop iteration 
check registers memory locations assume compiler allocated index variables registers 
index variables register allocated loop index update critical path loop execution 
analysis marks instructions increment loop index induction variables comparisons loop indices loop invariant values branches results comparisons 
instructions ignored occur trace 
admittedly transformations applied 
sophisticated compiler may able translate program equivalent amenable parallelization 
experiment means establish limit parallelism problem solved program 
finding limit undecidable problem 
experiment establishes limits parallelism particular code generated compiler subject assumptions experiment 
resulting limits considered inadequate techniques considered study 
benchmark programs benchmark suite consists spec programs benchmarks shown table 
included fortran spec programs comparison non numeric programs 
standard inputs spec benchmarks 
programs assumes compiler identified induction variables performed strength reduction 
program language description awk pattern scanning compiler front eqntott truth table generation espresso logic minimization gcc cc gnu compiler vlsi layout simulator latex document preparation matrix fortran matrix multiplication spice fortran circuit simulation tomcatv fortran mesh generation table benchmark programs compiled mips processor mips fortran compilers full optimization 
traces obtained mips pixie tool program simulated instructions 
instruction traces include library routines system calls ignore dependences occur operating system 
simulation algorithm basic simulation algorithm determine execution time trace 
completion time instruction execute total execution time trace 
resulting parallelism ratio sequential execution time parallel execution time 
want measure actual parallelism speedup realistic machine clock cycle latencies instructions 
non unit latencies parallelism fill pipeline bubbles 
instructions removed perfect inlining perfect unrolling contribute sequential time parallelism include speedup due removing instructions 
experiment allows instructions arbitrarily far apart program trace execute parallel 
necessary detect parallelism exposed aggressive compiler transformations loop interchange 
simulator record data dependences limited scheduling window records time write register memory location 
large hash table record writes memory 
bucket table may contain entries different locations additional space allocated bucket overflows 
instruction simulator determines operands available 
straightforward register operands 
memory operands read actual address trace check hash table time write address 
simulator determines control flow constraints satisfied 
base machine execution time branch trace recorded subsequent instructions wait time 
implementations control flow constraints machine models described 
constraints control flow operand availability instruction execution time minimum time satisfying constraints 
simulator records instruction result written 
store instructions actual address destination read trace time entered hash table 
control dependence analysis cd cd mf machines control flow constraint instruction execute immediate control dependence branch executed 
control dependence analysis performed stages 
compute control dependences procedure analyzing object code 
interprocedural control dependences handled dynamically traces analyzed 
analyze control dependences procedure build control flow graph 
mips pixie tool identify basic block boundaries 
decode analyze instructions object file determine successors basic block 
flow graph analysis computes immediate control dependences finding reverse dominance frontier basic block 
instructions basic block immediately control dependent branches reverse dominance frontier block 
instruction may immediately control dependent multiple branches 
dynamic instance instruction depends immediately branches 
example instruction control dependent instructions 
control flows instruction instruction need consider dependence instruction 
accomplished sequentially numbering basic block trace analyze trace simulator records basic block code sequence number instance 
immediate control dependence instance instruction simply branch reverse dominance frontier latest sequence number 
interprocedural control dependences handled maintaining stack contains control dependence information active procedure 
stack records control dependence calling instruction sequence number start procedure 
procedure simply inherits control dependence instruction calls procedure 
recursion control dependence instance instruction control dependence top stack instance branch reverse dominance frontier whichever 
recursion control dependence instruction dependence top stack instance branch reverse dominance frontier procedure invocation 
simulations keep track necessary information accurately compute control dependence recursive procedure 
basic block code sequence number instance simulator remembers sequence number start procedure 
recursion detected branch instruction reverse dominance frontier procedure sequence number greater current procedure 
point provide upper bound control dependence simply ignore control dependence instance instruction 
speculative execution simulations speculative execution static branch predictions profile information 
statistics collected running benchmarks inputs simulations 
prediction rates upper bound static branch prediction techniques 
dynamic techniques provide similar performance 
table shows branch prediction rates conditional branches benchmark 
attempt predict computed jumps 
mispredicted branch trace easily identified comparing actual branch outcome predicted outcome 
simulator sp machine simply remembers execution time mispredicted branch subsequent instructions trace execute time 
sp cd sp cd mf machines instruction wait mispredicted control dependence branch 
recording branch code instance mispredicted simulator compute control flow constraint 
prediction dynamic instructions program rate branches awk eqntott espresso gcc cc latex matrix spice tomcatv table branch statistics evaluation analysis parallelism machine model shown table 
sections examine results non numeric benchmarks discuss implications 
results numeric benchmarks section section discusses effects perfect loop unrolling 
base machine provides standard comparison determining amount parallelism special effort reduce control flow constraints 
non numeric benchmarks base machine harmonic mean parallelism larger studies similar machines assumptions different 
base machine allows instruction scheduling basic blocks 
instruction execute soon previous conditional branch resolved instructions branch completed 
addition overlap basic blocks separated conditional branches may executed parallel 
second operations machines execute clock cycle previous studies realistic operation latencies 
non unit latency operations consume parallelism fill pipeline bubbles reported speedups measure parallelism 
include limitations fetching instructions 
extreme upper bound oracle machine 
expected amount parallelism quite large varies significantly benchmarks 
reflects different types algorithms programs 
example eqntott primarily executes quicksort function contains data dependences 
hand latex composed algorithms inherent parallelism 
factors cause numbers considerably larger previous experiments perfect branch prediction 
unlimited scheduling window exposes parallelism entire program trace 
anti dependences output data dependences considered 
simulation procedure inlining removes instructions adjust stack pointer entry exit procedures 
significant case oracle machine stack pointer increments decrements lengthen critical path program 
control dependence analysis cd machine parallelism base machine basic blocks control dependences executed parallel 
harmonic mean parallelism cd machine slightly better base machine 
shows parallelism benchmark compared base machine 
parallelism cd machine primarily limited constraint branches executed order 
occur frequently benchmarks executing branch time serious bottleneck 
table shows average number dynamic instructions conditional branch instructions program traces 
non numeric programs branch instruction occurs instructions trace 
branches ordered difficult find parallelism 
base cd cd mf awk eqntott espresso gcc latex parallelism control dependence analysis constraint branches removed cd mf machine true control data dependences observed 
parallelism benchmark shown comparison parallelism cd machine 
parallelism increases programs especially gcc espresso 
massive amount parallelism 
really surprising considers types benchmarks analyzing 
may parallelism individual components programs algorithms simply parallel 
constraints cd mf machine require true data control dependences observed parallelism machine limit systems speculative execution 
dataflow architectures example able execute programs essential dependences 
massive amounts parallelism machine attempting exploit parallelism non numeric programs speculative execution low overhead effective 
speculative execution parallelism sp machine ranges witha harmonic mean 
shows parallelism benchmark compared base machine 
results comparable wall results similar machine :10.1.1.115.6325
differences attributed procedure inlining perfect loop unrolling unlimited scheduling window simulator 
parallelism sp machine fairly consistent different benchmarks 
measurements offer explanation consistency suggest limit parallelism probably apply non numeric applications 
sp machine misprediction cancels execution instructions branch base cd cd mf sp sp cd sp cd mf oracle awk eqntott espresso gcc cc latex harmonic mean matrix spice tomcatv table parallelism machine model base sp sp cd sp cd mf parallelism awk eqntott espresso gcc latex parallelism speculative execution tions barriers instruction scheduling 
parallelism instructions mispredicted branches 
limit parallelism sp machine average discrete segments code separated mispredicted branches 
segments vital characteristics degree parallelism misprediction distance number instructions segment 
experiments recorded number occurrences misprediction distance 
cumulative distributions misprediction distances program shown 
distributions quite consistent different benchmarks mispredictions occurring distance instructions 
expect non numeric programs similar distributions 
recorded degree parallelism segment code mispredicted branches relationship degree parallelism misprediction distance similar benchmarks 
combination statistics programs 
misprediction distance plot awk eqntott espresso gcc latex misprediction distance cumulative distribution misprediction distances harmonic mean parallelism segments size 
reflect differences significance numbers bars frequently occurring misprediction distances shaded darker 
short misprediction distances little parallelism 
instructions short segments tend closely related data dependences parallelism limited 
longer misprediction distances greater chance having unrelated instructions segments parallelism 
shown distributions long misprediction distances occur frequently 
non numeric programs predominantly short misprediction distances limited parallelism sp machine due data dependence short segments instructions 
sp cd machine need discard instructions mispredicted branch exploit parallelism mispredicted branches 
result harmonic mean parallelism machine increases misprediction distance harmonic mean parallelism parallelism vs misprediction distance 
compares parallelism benchmark parallelism sp machine 
branch constraint machine requires branch execute preceding misprediction 
restrictive branch constraint cd machine 
flow control changes branch mispredicted mispredictions relatively infrequent branch constraint bottleneck 
parallelism sp cd mf machine larger 
illustrates parallelism benchmark 
eqntott espresso programs especially large amounts parallelism large increase benchmarks 
sp cd mf model provides interesting data point 
aggressive sp machine realistic oracle machine 
achieve performance oracle machine instructions alternate paths executed simultaneously instructions paths useful 
hand long branches correctly predicted sp cd mf machine cancel instructions 
numeric applications numeric programs programs operate floating point data commonly written fortran generally considered contain parallelism programs 
section examines parallelism fortran benchmarks shows type control flow program useful indication available parallelism 
parallelism measured experiments fortran benchmarks shown table 
matrix tomcatv programs higher parallelism machine models 
oracle machine observe data dependence programs 
cd mf machine achieves large fraction oracle machine parallelism 
control flow programs dependent results computation control dependence analysis exposes parallelism different levels nested loops outer loops 
result speculation important 
comparison cd mf machine sp cd sp cd mf machines compress critical path inner loop small constant factor 
data independent control flow sets programs apart non numeric programs 
fortran benchmarks behavior spice clearly different 
control flow spice highly data dependent causing behave non numeric programs study 
numeric programs evolve model complex phenomena increasingly complex control flow data structures 
distinctions source language type arithmetic meaningful 
study suggests relevant characteristic predicting parallelism program control flow data dependent 
effects perfect loop unrolling previous studies limits parallelism remove dependences induction variables :10.1.1.115.6325
question raised induction variable dependences significantly affect results studies 
performed experiments removing induction variable dependences 
table shows percent change parallelism compared case perfect loop unrolling performed 
positive percent change means removing induction variable dependences improves parallelism 
discovered removing data dependences associated control dependences mixed effects 
simulation perfect loop unrolling decreases program execution times necessarily imply parallelism increases 
fact perfect unrolling competing effects parallelism 
removing index variable dependences loop branches parallelism exposed 
time removing loop overhead instructions decreases opportunities overlapping instructions rest computation loop decreasing parallelism 
effects may dominate depending benchmark machine model 
non numeric programs unrolling little effect 
example latex change 
programs primarily contain loops lot control data dependences dependences removed unrolling significant 
loops programs tend iterate small number times 
cd mf machine sensitive perfect unrolling 
removing induction variable dependences allows base cd cd mf sp sp cd sp cd mf oracle awk eqntott espresso gcc cc latex matrix spice tomcatv table percent change parallelism due perfect loop unrolling multiple iterations arbitrary control flow execute parallel 
improve parallelism case espresso 
loop overhead constitutes parallelism loops 
parallelism decreases remove instructions case eqntott 
perfect unrolling biggest impact matrix lesser extent tomcatv 
programs primarily execute simple loops index variable dependences limit parallelism 
programs sp machine benefits perfect unrolling 
nested loops iteration outer loop separated mispredicted branch inner loop 
prevents outer loop iterations executing parallel 
perfect unrolling removes loop branches essentially coalescing loops serializing mispredictions occur 
general effects loop index induction variable dependences parallelism vary depending application program machine model 
expected matrix oriented numeric programs benefit significantly perfect loop unrolling 
programs complex control flow unrolling significant difference 
shows control flow program severely limit available parallelism 
control flow non numeric programs numeric programs complex dependent 
increase available parallelism current level constraints imposed control flow relaxed 
discusses basic techniques handling control flow speculative execution control dependence analysis multiple flows control 
study machines utilize different combinations techniques established importance technique 
basic techniques form useful set criteria evaluate real architectures 
study suggests current highly parallel architectures lack adequate support control flow 
example vliw long instruction word machine follow flow control 
find sufficient parallelism programs control flow highly data dependent 
contrast dataflow machine execute different parts program simultaneously 
study shows instructions executed soon data control dependences satisfied parallelism quite limited 
speculation necessary find sufficient parallelism programs 
study machines helps identify useful architectural features 
concept boosting relies software scheduling small degree hardware support speculative execution appears particularly promising 
interesting concept guarded instructions 
guarded instruction conditionally executed value stored general register 
allows compiler specify amount control dependence information action control dependent guard 
furthermore guarded instructions basic block contain code different conditional statements simply capturing conditions guards 
guarded instructions particularly interesting combined support speculative execution help increase distance mispredicted branches 
guarded instructions give processor ability execute different regions source code inefficient multiple complex flows control simultaneously 
higher performance desired small scale multiprocessor system guarded instructions speculative execution support interesting possibility 
bernstein rodeh 
global instruction scheduling superscalar machines 
proceedings acm sigplan conference programming language design implementation pages june 
nix donnell rodman 
vliw architecture trace scheduling compiler 
ieee transactions computers aug 
cytron ferrante rosen wegman zadeck 
efficient method computing static single assignment form 
proceedings th annual acm symposium principles programming languages pages jan 
fisher 
trace scheduling technique global microcode compaction 
ieee transactions computers july 
hsu davidson 
highly concurrent scalar processing 
proceedings th annual international symposium computer architecture pages june 
hwu conte chang 
comparing software hardware schemes reducing cost branches 
proceedings th annual international symposium computer architecture pages may 
johnson 
superscalar microprocessor design 
prentice hall englewood cliffs nj 
mcfarling hennessy 
reducing cost branches 
proceedings th annual international symposium computer architecture pages june 
murakami irie tomita 
simp single instruction stream multiple instruction pipelining novel high speed single processor architecture 
proceedings th annual international symposium computer architecture pages may 
nicolau fisher 
measuring parallelism available long instruction word architectures 
ieee transactions computers nov 
patt melvin hwu 
critical issues regarding hps high performance microarchitecture 
proceedings th annual workshop microprogramming pages dec 
riseman foster 
inhibition potential parallelism conditional jumps 
ieee transactions computers dec 
smith 
implementation precise interrupts pipelined processors 
proceedings th annual international symposium computer architecture pages june 
smith johnson horowitz 
limits multiple instruction issue 
proceedings third international conference architectural support programming languages operating systems pages apr 
smith lam horowitz 
boosting static scheduling superscalar processor 
proceedings th annual international symposium computer architecture pages may 
sohi 
instruction issue logic high performance interruptible pipelined processors 
proceedings th annual international symposium computer architecture pages june 
wall :10.1.1.115.6325
limits instruction level parallelism 
proceedings fourth international conference architectural support programming operating systems pages apr 

