tutorial stalmarck proof procedure propositional logic mary sheeran gunnar stalmarck prover technology ab chalmers university technology sweden 
explain stalmarck proof procedure classical propositional logic 
method implemented commercial tool successfully real industrial verification projects 
proof system underlying method motivate various design decisions resulted system copes large formulas encountered industrial scale verification 
computer aided design electronic circuits key function tautology checking testing boolean expression true truth assignments variables 
tautology checking hardware verification synthesis optimisation 
known methods tautology checking take time exponential size input formula worst case 
problem known np complete better worst case 
formulas arise practice 
cases binary decision diagrams bdds variants tautology checking applications model checking 
glance proceedings conference formal methods cad confirms bdds ubiquitous hardware verification 
tutorial explain stalmarck method tautology checking may rival bdds applications relatively unknown hardware verification community :10.1.1.1.5124
patented method implemented commercial tool industrial system verification projects 
complex devices engine management units railway interlocking systems modelled propositional logic directly translation industry standard formats 
required properties system expressed propositional logic verify system check formula system properties tautology 
verification problem expressed inductive proof base case step checked stalmarck method 
real world verifications give rise enormous formulas handled current bdd packages 
groote stalmarck method efficient compared methods otter prover verification safety guaranteeing system particular dutch railway station 
largest formula encountered far arose railway interlocking connectives log recording proof independent checking megabytes long 
exciting thing stalmarck method copes formulas provided easy proof theoretic measure discuss 
surprising realworld problems give rise large easy formulas 
give brief informal description method deeper analysis 
stalmarck method brief stalmarck proof method propositional logic understood various different ways 
algorithm briefly 
intention give reader intuition operation algorithm deeper study follows 
presentation section influenced early stalmarck 
straightforward translation formulas propositional logic say negation conjunction disjunction implication formulas built implication 
false 
repeatedly apply transformations 
implication formula propositional variables compound subformulas subformulas invent new name different compound subformula variable representing formula write rep propositional variable represents formula just variable rep formula represented set triplets rep rep rep rep triplet abbreviation 
treat special case propositional variable write triplets 
write 
true 
example formula 
prove formula valid assume false try derive contradiction simple rules branching rule called dilemma rule 
simple rules simple rule takes triggering triplet derives new information variables 
example know false true false 
write rule applying rule element set triplets gives new set triplets substitute newly calculated variable instantiations 
new set need contain triggering triplet triplet triggered triggered triplet terminal defined 
example continued formula 
gave triplets assume corresponds formula false apply rule triplet dropping triplet set single triplet results call terminal triplet 
contradictory false 
assumption 
false gives terminal triplet conclude formula valid 
terminal triplets 
list remaining simple rules note rules gain information exact value variable equality inequality variables 
reader check triggered triplet terminal 
simple rules complete 
need form branching 
dilemma rule derivations proofs 
starts set triplets assumption true 
starts assumption false 
derivations gives terminal triplet result applying rule result derivation 
leads contradiction resulting substitution variable instantiation intersection information gained assuming true assuming false hold independent value example show formula 

tautology 
triplets produced set false apply simple rules repeatedly 
start applying rule triplet applying resulting substitution list place triggering triplet dropped gives opportunity apply rule triplet starts apply rule triplet ends ps followed triplet 
apply rule triplets 
triplets left simple rules applies 
apply dilemma rule 
left branch assume true get triplets second terminal 
branch get triplets reverse order reach contradiction branches application dilemma rule results contradiction 
means assumption formula false leads contradiction conclude formula tautology 
proof system consisting simple rules dilemma rule sound complete formulas variables implication 
boolean formula translated formula linear time procedure described stalmarck 
system sound complete full propositional logic 
proof system proof method making sequence increasingly powerful subsystems dilemma rule 
derivations branches dilemma rule restricted derivations 
proofs open assumption value variable proofs simultaneous assumptions 
stalmarck method seen family algorithms efficiently search short proofs find proof linear time just closure simple rules 
time required exhaustively search proof size formula 
say valid formula gamma hard provable provable notion formula hardness important return 
sufficient note industrial verification problems give rise formulas hardness degree 
formulas may large method sensitive hardness degree formula size terms number variables connectives 
means method applicable industrial verification large scale 
tempting believe reader understands description stalmarck method knows needs know method 
contention case 
gain deeper standing method placing wider context comparing standard approaches 
please read 
remainder tutorial briefly standard proof systems propositional logic gentzen cut free sequent calculus semantic tableaux 
show cut free proofs intrinsically redundant motivate different proof method relations formulas just sets formulas known true false 
system ke davis putnam procedure seen special cases approach 
add new kind rule give dilemma proof system 
system underlies stalmarck method 
outline dilemma proof procedure give important complexity results discuss applications 
necessary background proof systems order understand proof procedure efficient practical point view study underlying proof system 
proof procedure consists parts inductive definition classical consequence relation rules means tautology related algorithm generating proofs 
algorithm really understood showing relates particular way defining consequence relation 
way defines consequence relation choice underlying proof system surprisingly large effect performance resulting algorithm 
step designing efficient proof procedure choose suitable proof system 
review standard proof systems classical propositional logic properties 
gentzen sequent calculus cut gentzen introduced sequent calculus order prove 
states proofs brought form formulas appearing proof subformulas formula proved 
proofs calculus contain expressions form fa fb bm called sequents informally read true true 
proofs start obviously valid sequents form axioms 
complex formulas built sequents applications operational rules 
calculus includes rule introducing new formulas thinning rule rule removes formulas cut rule 
thinning minimize number different sequents proofs reduce proof complexity proofs viewed directed acyclic graphs trees 
presenting rules write gamma set gamma fag 
axiom structural rules thinning gamma delta gamma theta delta cut gamma delta gamma delta gamma delta operational rules left gamma delta gamma delta gamma delta right gamma delta gamma delta left gamma delta gamma delta right gamma delta gamma delta gamma delta imp left gamma delta gamma delta gamma delta imp right gamma delta gamma delta neg left gamma delta gamma delta neg right gamma delta gamma delta removing cut gaining subformula principle sequent calculus complete remove cut rule 
gentzen says 
rules cut free sequent calculus elimination rules system trivially obeys subformula principle 
proof uses subformulas formula proved 
extraneous formulas definitions concepts formula proved 
proof direct gentzen put roundabout 
shall see having subformula principle allows place bounds proof size important practice 
removing thinning addition take axioms sequents form gamma delta add extra formulas axioms thinning rule redundant removed 
resulting system essentially kleene system 
system particularly important automated deduction lends goal oriented proof search 
start sequent proved rules backwards aiming reach axioms obviously unprovable sequents 
proof procedure works rules invertible provability sequent line implies provability sequents line 
note thinning rule invertible 
semantic tableau method system analytic tableaux classic proof method 
valuation formula assignment 
true 
false propositional variables formula true false 
connective examine possible cases 
ab true true true rule 
false false false explore possibilities rule 
combination law excluded middle usual semantic interpretation connectives gives tableau rules propositional logic ajb aj impl ajb impl method analyses formula progressively breaking component parts rules 
branching rules impl disjunction formulas branches consequence formula line 
rules formulas line just shorthand pair rules giving single formula 
start formula proved root tree repeatedly apply rules 
path tree build information possible valuation subformulas gathering set contains formulas path 
think formulas know true particular valuation 
explicitly contradictory set containing formula exploration branch failed find model setting propositional variables formula true 
branches tree contradictory way know model formula contradictory negation valid 
semantic tableaux systems introduced beth kanger hintikka simultaneously 
system elimination rules trivially obeys subformula principle 
important effect placing limit size proofs relation size formula proved 
write size formula jaj 
number variable occurrences plus number connectives 
number subformulas formula size formula maximum length path semantic tableau step path adds formula set formulas 
intrinsic redundancy cut free proofs matter procedure search proofs tableau system search tree grow simple commonly occuring examples 
growth happens smallest possible proof problem procedure cut free nature proof system 
agostino thesis presents small enlightening example minimal tableau refutation cut thinning formula gamma gamma ae ae ae ae gamma gamma paths explored results contradiction 
note righthand side tree explore part search space explored left subtree 
building left subtree know assuming true leads contradiction repeat search assuming true 
don misled picture thinking graphs trees help 
trees really decorated node set formulas path root node tree corresponds different set 
kind redundant pattern repeated inside redundant subtrees combinatorial explosion results 
semantic tableaux rules don really match search space trying explore 
refutation trees better match search space 
solution put back form cut keeping subformula principle 
understand step study space searching rules proofs look 
rules rules tableau systems correspond clauses true valuation 
example true false true 
elimination rules written rules analysing connective ffi consider ffi immediate subformulas complements 
gives different set rules classic tableau rules seen 
extend idea considering just truth values subformulas formulas truth value 
example value value different values true 
examining connective turn generate large set propagation rules 
include proper rules 
general rules connective ffi look fn gn fa ffi rule proper ff fn gn ff fn gn ff fn gn gamma ff systems ke ke subset proper rules corresponds elimination rules propositional fragment system ke proof system introduced studied agostino 
just elimination rules give system complete propositional logic 
adding single branching rule principle pb ja gives proof system complete propositional logic suffer kind redundancy illustrated earlier 
put back cut rule 
subformula formula proved subformula principle associated bound proof size pb rule known analytic form cut 
just elimination rules plus pb rule form complete system ke extensively studied agostino thesis 
formula ab ac earlier showed minimal tableau refutation gives ke refutation 
gamma gamma gamma gamma start ke extend language formulas include generalised conjunction disjunction 
add simplification rules affirmative negative subsumption get proof procedure equivalent known davis putnam procedure version formulas conjunctive normal form cnf 
ke seen generalisation davis putnam require reduction cnf 
proof system underlying stalmarck method uses larger set propagation rules longer constrained longer sufficient maintain sets formulas known true false maintain information sets formulas known value 
introduce formula relations 
formula relations complement formula written 
set containing subformulas including complements 
formula relation equivalence relation domain constraint means equivalence class truth value 
working includes complements subformulas allows encode equalities inequalities subformulas 
encoded write formula relation containing relating call association 
association complementary association 
course explicitly contradictory 
extend notation addition formula relations single associations sets associations obvious way 
fm set associations write 
smallest formula relation identity relation written simply places element equivalence class 
interesting abbreviate partial valuation starting point attempt refute example propositional variables equivalence classes shown square brackets 
call equivalence class containing true class containing false class remaining classes indeterminate classes 
applying rules formula relations schematic rule fn gn corresponds partial function formula relations 
takes formula relation ng returns larger 
continuing previous example applying elimination rules sequence gives contains exactly equivalence classes simple rules applicable 
gives model refuted 
take apply elimination rules get groups formulas domain single equivalence class largest formula relation explicitly contradictory times places formula complement equivalence class 
convenience overload symbol represent explicitly contradictory formula relations 
sequence rule applications refutation assumption true derived contradiction 
examples seen successful application simple rule merges pairs equivalence classes 
class contains particular set subformulas shadow class containing complements subformulas 
real implementations halve number equivalence classes making shadow classes implicit 
result successful application proper rule merges pair equivalence classes reduces number equivalence classes 
dilemma proof system ready dilemma proof system underlies stalmarck method 
large set proper rules introduced allows reach require branching systems smaller set simple rules 
lengths paths refutation graph proofs bounded size formula proved branching critical factor complexity speed 
course branching avoided altogether simple rules complete propositional logic 
introduce special branch merge rule called dilemma rule 
dilemma proof system just rule plus simple rules 
dilemma rule dilemma rule pictured derivation derivation formula relation apply dilemma rule choosing different non complementary equivalence classes new dilemma derivations starting give respectively 
intersect extract common branches 
explicitly contradictory formula relation extended relation single equivalence class intersection operation simply set intersection relations viewed sets pairs 
practice derivation soon formulas placed equivalence class 
defined explicitly contradictory written 
note subset derivation adds relation 
means subset ur rule sound 
rule seen combination cut branch backwards applications thinning context thinning applications appear invertible 
refute refuted possible refute omit thinning simply refute separately proofs common common 
thinning avoids repetition effect akin having lemmas 
dilemma derivations clauses define means dilemma derivation related notion proof depth 

simple rules 
application simple rules gives pi followed dilemma derivation write assertion pi simple rules applies say derivation cases proof depth written depth pi zero 

composition 
pi pi compose proofs pi pi composition contains copy intermediate relation proof depth composition defined max depth pi depth pi 

dilemma rule 
pi pi pi pi derivation ur depth max depth pi depth pi proofs built rules series parallel shape 
depth proof maximum number simultaneously open branches 
example proof depth 
size dilemma proof pi denoted pi number occurrences formula relations pi proof size 
link back derivations involving formula relations proofs formulas note derivation contradictory formula relation constitutes refutation formula similarly check tautology attempting refute 
proof hardness formula relation easy derivation pi depth pi relation hard derivation pi depth pi relation hardness degree easy hard 
note know relation hardness degree exist proof pi depth write proof represent proof prove convenient proofs complexity 
formula bc 
ab ac hardness degree reversing direction implication gives formula hardness degree 
harrison stalmarck algorithm hol derived rule lists hard problems performance statistics harrison implementation method 
examples circuits taken set examples ifip international workshop applied formal methods correct vlsi design held 
practice turns real industrial verification problems produce formulas hardness degree 

reason dilemma system large set propagation rules reducing need branching 
explanation offer observation systems designed person person understands argue informally correctness system tend result easy formulas 
systems components coupled relatively uncontrolled way behaviour hard predict informal analysis hard analyse formally 
empirical observations indicate idea introduce design rules improve verifiability 
main supplier railway interlocking software sweden important move direction introducing software coding rules guarantee verifiability resulting interlocking control software see section 
figuring place constraints designer easy reason correctness products important area research formal methods 
proof system proof procedure studied dilemma proof system 
turn efficient proof procedure 
step find data structure representing formulas 
second provide efficient algorithm searches exhaustively shallow dilemma proofs 
triplets ease manipulation compound subformulas represented triplets having form ffi triplet variable represents compound formula obtained applying binary operator ffi triplet operands represents subformula literals variables real triplet variables negated variables 
example formula 
ab ac reduced triplets follows saturation algorithm relation saturated dilemma derivation pi depth pi holds words proofs depth add new equivalences subformulas 
saturation procedure exhaustively searches proof depth relation hardness degree saturate explicitly contradictory saturation finds procedure defined recursively 
saturation applies propagation rules relation rules applicable 
chooses compound subformula applies related simple rule continues apply simple rules triplets variables affected result rule 
process continues simple rules applied 
pseudo code fragment presents saturation 
saturate compound non empty remove set contradictory return union affected od return set compound initial pool subformulas processed contains compound subformulas domain restricted contain representative classes distinct true false classes 
method representatives indeterminate equivalence classes vital complexity algorithm shall see 
choose element pool apply simple rule related simple rule premises involve formulas set containing immediate subformulas complements simple rule applies just application rule related way leads discovery set new equivalences gamma call set subformulas mentioned new equivalences expect add back pool subformulas subformulas equivalence classes parents formulas 
parent formula contains formula immediate subformula 
triplets affected new information gained applying rule 
adding formulas equivalence classes allows information propagated downwards formula 
adding parents allows information propagate upwards 
optimisations important complexity algorithm 
formula contains variable added indeterminate classes formula placed pool contains second variable equivalence class 
addition continue single variable represent indeterminate classes replacing variables representatives triplets enter pool 
effect triplet evaluated twice saturation 
call set triplets added back pool procedure affected 
having possibly augmented pool update new equivalences repeat pool empty 
point simple rules apply saturation complete 
saturation defined terms branching saturation 
version branches truth falsity subformula equivalence arbitrary subformulas 
version currently implemented 
better strategy try merge largest equivalence classes 
saturate repeat sub non empty remove saturate equiv false saturate equiv true contradictory contradictory return union contradictory contradictory intersect od return set sub contains subformulas variables compound subformulas 
case saturation place pool formulas representative indeterminate equivalence classes 
repeatedly branch subformula turn consequences form new equivalences 
course saturation saturation performed branching minimised 
information gained saturation available subsequent saturation 
continuous gathering information form equivalences distinguishes algorithm breadth search iterative deepening 
note saturation algorithm propagates information upwards downwards syntax tree formula 
relational 
development algorithm described kunz independently developed recursive learning method solving boolean satisfiability problem applications digital test generation 
method common discovers logical relationships subformulas formula nodes circuit 
complexity results lower bound proof length dilemma formula hardness degree lower bound length proof showing proof introduce useful proof theoretic trick 
proving lower bound construct derivations limited depth 
relation hardness degree proof proof depth know proof exist 
happens dealing derivations 
assume proof pi fm set associations 
build proof known depth 
building blocks variants pi lead 
fm gamma construct pi pi extending relation proof final relation proof contains contradictory 
safely proof building block derivation call unroll 
proof proof gamma proof gamma addition know derivation depth 
note trick worked equally original pi derivation 
resulting derivation 
ready show formula hardness degree length proof dilemma turning implication negating components 
show length proof pi hardness relation 
proof induction length pi base case pi pi 
proof contains single relation 
induction step assume pi cases consider 
proof starts simple rule application starts application dilemma rule 
case pi pi pi pi simple rule application pi induction hypothesis derived application simple rule 

case pi form set associations branches dilemma rule 
obviously pi jsj jt ju cases apply pi 
jsj gamma jt gamma 
jsj gamma ju gamma 
jt gamma ju gamma case short apply trick 
take case 
variants lead explained know derivations length gamma induction hypothesis hardness gamma 
unroll depth gamma 
similar argument applies know induction hypothesis proof depth 
plugging derivation unroll unroll proof depth required 
case time concentrate making derivation branch longer moves dilemma rule 
construct left branch ends 
certainly shallow proof unroll just previous case 
shallow proof 
take derivation rewrite derivation extending relation proof gamma resulting derivation length gamma inductive hypothesis gamma proof depth gamma 
similarly version derivation extending relation proof gamma derivation followed new version length pi inductive hypothesis proof depth 
derivation unroll proof proof depth required 
case similar 
analytic ke corresponding lower bound result formula hardness degree lower bound proof length dilemma 
difference comes move relations subformulas series parallel shape derivations 
upper bound length derivations dilemma proper derivation derivation depth redundant rule applications 
show polynomial upper bound length proper derivations dilemma 
define function natural numbers theta sigma gamma show pi proper derivation pi number equivalence classes proof induction base case pi derivation simple rules applied just sequence relations 
long sequence 
equivalence classes simple rule merges equivalence classes maximum length sequence relations pi induction step pi derivation 
treat worst case dilemma rule applied possible 
proof consist gamma applications dilemma rule branches depth equal 
proof fewer uses dilemma pairs simply removed corresponding application simple rule contain fewer uses dilemma 
rm gamma sm gamma tm gamma top relation contains gamma equivalence classes 
js jt induction hypothesis 
calculate pi theta sigma gamma 
polynomial bound conclude upper bound length proper derivation pi number equivalence classes noted upper bound lower bound 
hierarchy hardness interesting question hardness degrees form hierarchy collapse particular degree 
answer know infinite hierarchy exists 
ajtai shown exist polynomial size proofs called pigeon hole formulas propositional encoding pigeon hole principle bounded depth frege systems ref 
furthermore routine task polynomially embed proofs dilemma pigeon hole formulas bounded depth frege system 
surprising hierarchy exists 
collapsed tautologies easy polynomial size dilemma proofs 
mean np np contrary intuition complexity theorists 
dilemma versus analytic ke dilemma superior analytic ke infinite formula sequences hardness constant dilemma grows logarithmically analytic ke interesting note hardness degree analytic ke dilemma related linearly formula relations replaced sets dilemma rule replaced analytic cut relational version 
relational version open opportunities remove repetitions invertible thinning dilemma rule 
time complexity saturation procedure order estimate complexity saturation algorithm count maximum number triplet saturation relation different equivalence classes different variables 
note triplet unassigned variable propagates value variable useless removed 
assume add useless triplets pool triplets 
assume unique variable equivalence class representative class 
pool triplets contains representatives variables replaced representatives entering pool 
consider saturation procedure 
note triplets pool contain different variables 

kinds triplets pool contain variable added true false class leaving remaining variables contain variable added class case add triplet pool contains second variable belongs variables replaced class representative 
triplet distinct variables propagates evaluated useless evaluation put back pool 
variables instantiated value variable left redundant 
hand triplet lifted pool propagating argument contain variable time enters pool 
saturation triplet evaluated twice maximum number evaluations triplets bounded 
calculate complexity saturation easiest consider code earlier 
saturate repeat sub non empty remove saturate equiv false saturate equiv true contradictory contradictory return union contradictory contradictory intersect od return iteration body repeat loop reduces number equivalence classes relation apart iteration leaves unchanged 
body repeat loop executed times number equivalence classes top relation 
initially list length length reduced iteration 
means body loop contains executed times iteration gamma times 
formula initial number equivalence classes number triplets 
define recursive function captures reasoning style earlier upper bound proof proof length 
function characterises maximum number evaluated triplets saturation degree number triplets 
base case comes argument complexity saturation 
step reflects argument iterations repeat loops 
define theta sigma theta theta rate growth bounded 
saturation procedure time required search exhaustively proof depth formula bounded size note upper bound proof search square upper bound proof length exponential related shortest possible proof 
industrial applications brief descriptions different industrial applications stalmarck method 
minimal models method documentation illustrate surprising variety ways propositional logic analysis existing systems briefly describe study area power station control 
sweden nuclear power plants function safety critical control systems documented called logic schemas 
graphical notation shows kinds components combinational memory real time elements connected realise particular function 
typical function control opening closing single valve 
logic schemas advantage giving implementation independent description required function 
regulating authorities suppliers control room staff searching errors 
documents hand drawn difficult maintain analyse 
prover technology ab asked propose ways improve system documentation 
proposed logic schema hand translated np tools format graphical notation propositional logic arithmetic prover technology verification toolkit 
system containing memory elements represented state transition function previous current states represented 
addition proposed schema translated triggering table shows concise tabular form circumstances values variables output function goes high low 
tables constructed finding minimal partial models formula corresponding schema 
partial model formula assignment values variables possible assignments remaining variables give models ordinary sense partial model minimal partial model assigns values fewer variables 
cases necessary simplify schema order give reasonable number minimal models simplifications carefully documented 
typical example input gate modelled new variable representing output 
greatly reduces number models remove important ones 
approach simplifying schemas transition function containing inputs state variable gates reduced schema inputs gates 
produces table open output goes low high 
state variable appear sim man close req open vent open want know combinations variables cause state go low high 
triggering tables capture system behaviour just right level complement schematic diagrams 
facilitate comparison different versions function proved difficult old method documentation 
example technically simple technique related known theory prime implicants answer real need industry 
interesting note saturation tautology checking generate small necessarily minimal models 
applications generate minimal models tautology checking needed generate simply takes long 
saturation gives small models linear time 
verification experiments saab saab military aircraft linkoping sweden put considerable effort developing unified system development methodology 
experiments practical application formal methods formed part expected formal methods components system developer toolbox 
saab applied np tools verification toolkit implementation stalmarck method case studies safety reliability integrated subsystems jas saab aircraft 
briefly project landing gear system jas modelled analysed propositional logic 
details projects saab reader referred 
jas project system controlled consists large wheels called gears smaller nose gear 
gear door closed gear retracted extended 
hydraulic system moves gears doors movement gears doors physically coupled 
control system contains software hardware control unit 
software unit collects information status landing gear system related systems control movement gears doors 
hardware unit provides redundancy take case computer breakdown 
hardware software control units modelled directly level propositional logic 
inputs model status signals sent sensors commands pilot information engine electrical power supply speed 
outputs control signals hydraulic system 
system modelled control part standard control loop continuous signals necessary 
model built bottom fashion existing documentation mixture tabular schematic forms 
macro facility np tools simple form encapsulation give hierarchical system description 
complete system state transition function previous current states explicitly represented approximately inputs outputs 
typical safety critical requirement checked system gears doors collide 
important check properties cases functional test physical test rig revealed kind error damage cause 
typical requirement emergency extension landing gear possible 
control system shown fulfil functional safety requirements fault tolerant behaviour analysed methods related fta fault tree analysis failure mode effect analysis 
errors sensors hardware components explicitly modelled say model realistic 
way behaviour system single multiple faults analysed way familiar hardware designers software developers 
modelling took approximately man month carried part swedish consultancy 
lot time spent modelling integer values time supported implementation stalmarck method means boolean variables 
experience showed simple safety properties form case certain property holds easily verified 
complicated reasoning showing requirement fulfilled certain number time steps proved problematic 
problems stemmed need manual modelling 
synchronous data flow language lustre related notion synchronous observer allow modelling safety properties programming language gives user friendly verification methodology 
tool provides translator lustre synchronous observers np tools format 
frees user having think kinds inductive proofs performing automatically generating required number transition function formulas requirements 
provides effective model checker 
kind system verification vital proofs invisible user aiming acceptance real development projects 
project saab necessary develop user friendly methods tools expressing validating requirements 
area subject ongoing research product development prover part eu project fast 
providing help management validation requirements important niche formal methods industry 
software development railway interlocking systems sweden main supplier railway interlocking software 
railway interlocking software developed written domainspecific synchronous declarative language called 
surprisingly case undoubtedly aided verification efforts area 
reasons think fair say systems verified tools stalmarck method hardware 
point view little difference program circuit 
briefly outline verification tackled application 
picture interesting 
set generic safety requirements apply sweden 
requirements formalised timed order logic 
generic program written contains code kind generic object 
typical examples signals points track sections 
object parameters allow specific instance created example signal lamps 
objects integer variables finite domains 
variable equation group form xn specifies initialisation variable set cycle 
integer expression condition integer expressions relations logical connectives 
describe particular yard programmer connects instances generic objects way closely matches yard physical layout 
cycle object instance follows initialisation fix parameter values initialise variables 
fixpoint computation repeatedly read values evaluate equation groups fixpoint reached 
write values 
computational model object translated formula repeated called single cycle 
object variables finite integer domains formulas produced propositional logic extended finite domain integer arithmetic 
logic handled commercial implementation stalmarck method call prop 
translation allows perform induction proofs invariant properties individual objects 
invariants added object models facilitating proofs yard level 
invariants automatically generated 
checks performed objects example check prove equation group conditions mutually exclusive 
test unintentional nondeterminism avoids potential runtime errors code 
entirely automatic incorporated development environment 
yard encounters unwanted double value runtime automatically set safe state moves error located corrected 
costly 
having automatic way avoid allowed greatly reduce time spent testing 
verifications just discussed done object 
yard 
entire yard performs fixpoint computation 
repeatedly reads values yard environment evaluates objects described fixpoint reached 
writes values yard 
build formula propositional logic finite domain integer arithmetic corresponding transition function entire yard 
consists fixpoint models object instances equalities expressing connections objects 
requirements yard generated instantiating generic requirements yard layout 
quantifiers expanded sets objects requirements simplified partial evaluation 
instantiated yard model checked instantiated requirements proofs induction 
proofs base case step performed stalmarck method logged checked independent proof checker 
experience performing kind formal verification introduced coding rules guarantee verifiability resulting interlocking control software 
rules constrain programmer forcing construct hierarchical state machines particular style 
example resources claimed particular order released reverse order 
result guidelines formulas generated programs hardness degree quickly proved 
effect introducing automatic user friendly formal verification techniques positive 
programming errors detected just method 
safety requirements routinely proved installations 
report time cost reduction installed interlocking system 
project develop new software control yard verification took total man days compared man years formal verification 
formal verification introduced program errors running systems 
solution described marketed product called svt 
contend large scale engineered methodology supporting tool serious convincing applications formal methods 
verification method relies existence generic requirements generic system description 
exist yard layout allows generate formulas requirements program controlling yard 
final step actual proofs yard question formulas 
feel pattern generic requirements generic system descriptions repeated different application areas example programmable logic controller programming factory automation 
variation methods just described partially validated interlocking software madrid subway station 
points neutral position locked correct position 
error cause minor damage train track considered safety critical 
error corrected 
similar verification carried larger finland 
serious safety critical error led 
error currently corrected 
small madrid verification produced formulas containing triplets took man hours total 
largest yard analysed far resulted formula containing half triplets 
stalmarck method cad stalmarck method provides efficient way tautology checking large formulas 
expect applicable cad 
industrial verification problems tackled stalmarck method similar post hoc hardware verification systems built boolean operations arithmetic 
typically systems modelled synchronous boolean automata examples described previous section 
reason circuits verified style 
promising experiments area carried block singh 
verification fpga cores stalmarck method field programmable gate arrays fpgas contain gates designers rely increasingly verified blocks known cores virtual components 
example tool xilinx leading fpga manufacturer generates handcrafted highly optimised designs domains including arithmetic digital signal processing 
cores long development time 
complicated need portability addition customers demand components undergone systematic verification 
reason cores prime target formal verification techniques designed reduce development time give greater confidence system meets specification 
block singh propose core verification flow relies availability high level specification core desired functionality 
note fixed size instances cores verified aim perform fast automatic proofs propositional logic 
intention kind verification run time verify reconfigurable cores 
core decomposition trying verify complete core subcomponents verified bottom 
gives smaller tractable proofs eases location errors 
core specification entity verified provided behavioural register transfer level description hardware description language 
specification possible produce circuit netlist simple components standard commercial synthesis tools 
cores come behavioural specification 
core netlist generation core specification put commercial synthesis tool synopsys design compiler produce netlist fixed size instance core standard interchange format 
implementation netlist generation tool produce netlist real implementation core 
np tools translation need compare produced specification implementation 
possible block singh developed translator np tools format result combinational circuit state transition function 
proof equivalence proof ordinary combinational equivalence checking just tautology checking induction 
failed proofs give examined np tools system automatically generated simulation script model technology vhdl verilog simulator 
pragmatic core verification method advantage fits existing design flow 
shown number cores including adders counters constant coefficient multiplier 
verifying complicated cores progress 
examples tackled far required transition function inductive proof 
expect larger scale systems require developed model checking technique induction additional constraints sequences states considered 
application useful testbed newly developed methods verifying synchronous systems 
just bdds classes circuits proved difficult verify stalmarck method 
multipliers particular give rise hard formulas hardness grows circuit size 
experimenting ways systematically reduce proof hardness regular circuits adding definitions fresh variables system formula akin lemmas 
trick know exactly new definitions add 
benefit fact describe circuits directly propositional logic functional programming language haskell combinator style roots fp ruby 
generate propositional logic formulas instances generic circuits symbolic evaluation 
combinator style easier discover new definitions added 
guided fact proof circuit instance closely related shape circuit 
approach large combinational multipliers verified 
summary stalmarck patented proof procedure propositional logic 
underlying dilemma proof system efficient reasons 

efficient propagation 
provides efficient propagation information subformulas formula refuted 
efficiency propagation comes large set elimination rules fact relations maintain equivalences subformulas 

series parallel graphs trees 
dilemma rule results sides branch 
combination cut invertible form thinning 
avoids repetition proofs 
proof procedure efficient careful design saturation algorithm guarantees find short proofs exist 
method perform industrial strength formal verification hardware systems 
question applied practice cad remains answered 
hope stimulate join quest answer 
koen claessen careful reading drafts colleagues formal methods group chalmers enjoyable discussions 
anonymous referee helped improve dag kindly checked complexity calculations 
ganesh gopalakrishnan encouragement infinite patience 
sheeran prover technology partly funded eu project synchronous reactive formalisms 
stalmarck chalmers funded chalmers 

abdullah meinke fast integrated tool verification validation real time system requirements 
submitted publication 

ajtai complexity pigeonhole principle 
proc 
th annual symposium foundations computer science pp 
ieee press 

beth semantic entailment formal derivability 
der kon 
akademie van 
afd 
amsterdam 

claessen sheeran singh lava hardware design haskell 
proc 
int 
conf 
functional programming acm press 

industrial success verification tools stalmarck method 
proc 
th int 
conf 
computer aided verification springer verlag lncs vol 


formal verification computerized railway interlocking 
formal aspects computing vol april 

stalmarck 
prover technology industrial strength formal methods academic press 

bryant graph algorithms boolean function manipulation 
ieee trans 
comp vol 


cook complexity theorem proving procedures 
proc 
rd acm symp 
theory computing 

agostino investigation complexity propositional calculi 
phil 
dissertation programming research group oxford university 

davis logemann loveland machine program theorem proving 
communications acm 
reprinted 

davis putnam computing procedure quantification theory 
journal acm 
reprinted 

gentzen untersuchungen uber das logische 
mathematische zeitschrift 
english translation collected papers gerhard gentzen szabo ed north holland amsterdam 

groote van safety guaranteeing system station 
technical report logic group preprint series utrecht univ 

harrison stalmarck method hol derived rule 
theorem proving higher order logics springer verlag lncs vol 


hintikka form content quantification theory 
acta philosophica vii 

kanger provability logic 
acta stockholm studies philosophy 

kleene mathematical logic 
john wiley sons new york 

kunz pradhan recursive learning new implication technique efficient solutions cad problems test verification optimization 
ieee trans 
cad vol 


halbwachs caspi raymond pilaud synchronous dataflow programming language lustre proc 
ieee vol 


halbwachs programming verifying real time systems means synchronous data flow programming language lustre ieee transactions software engineering sept 

ljung formal modelling automatic verification lustre programs np tools master project thesis prover technology ab department teleinformatics kth stockholm 

improvement jeffrey deductive trees 
dell universita di ferrara iii discussion universita di ferrara 

schutte proof theory springer verlag berlin 

stalmarck system determining propositional logic theorems applying values rules triplets generated formula 
swedish patent approved patent approved european patent approved 

sheeran prove properties recursively defined circuits stalmarck method 
proc 
workshop formal methods hardware hardware systems june 

sheeran stalmarck model checking induction boolean satisfiability 
submitted publication march 

editors automation reasoning 
springer verlag new york 

singh block formal verification reconfigurable cores 
appear proc 
int 
conf 
field programmable custom computing machines fccm napa valley 

order logic 
springer berlin 

srivas editors proc 
int 
conf 
formal methods computer aided design 
springer verlag lncs vol 


stalmarck note computational complexity pure classical implication calculus 
information processing letters complete 

stalmarck modeling verifying systems software propositional logic 
proc 
ifac london 

modelling formally verifying systems software industrial applications 
proc 
second int 
conf 
reliability maintainability safety xu ed 

evaluation algorithm generating partial models propositional logic stalmarck method 
master thesis royal institute technology 
department numerical analysis computing science 

stalmarck helander formal safety reliability analysis embedded aerospace systems saab 
proc 
th ieee int 
symp 
software reliability engineering industrial track ieee computer society press 
