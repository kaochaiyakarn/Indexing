proc int conf formal ontology information systems fois www cs utexas edu users papers ontology reuse application mike uschold mike healy keith williamson peter clark steven woods boeing applied research technology po box seattle usa 
describe investigation reuse application existing ontology purpose specifying formally developing software aircraft design 
goals clearly identify processes involved task assess cost ectiveness reuse 
re ontology far automated process requires significant ort knowledge engineer 
describe illustrate intrinsic properties ontology translation problem argue fully automatic translators forthcoming foreseeable 
despite ort involved subjective case knowledge reuse cost ective taken significantly longer design knowledge content ontology scratch application 
preliminary results promising achieving larger scale knowledge reuse 
keywords ontology reuse ontology application ontology translation 
construction large scale knowledge systems essential able share reuse representational components built 
despite potential advantages sharing availability components component libraries remains challenging task import components 
despite existence ontologies evident literature published examples reuse 
furthermore cases ontology reused basis building new ontology starting scratch descriptions ontologies applied terse absent describe start finish process reusing applying existing ontology 
conducted experiment consisting steps take engineering math ontology written ontolingua library ontologies stanford knowledge systems laboratory ksl ontology server translate target specification language integrate specification existing small engineering software component transform refine enhanced specification executable code specware system specification formal development software demonstrate ability add units conversion capabilities dimensional consistency checking engineering software 
common usage term reuse ambiguous original new ontology serve specific purpose 
issues objectives goal exercise identify issues ect successful reuse application existing ontologies 
result clearer understanding identify reuse situation succeed kind technical issues problems need faced 
address questions 
process reusing applying ontologies 
specific di culties arise process ontology translation 
reuse cost ective 
specware tool ontology capture reuse application 
re ontology far automated process requires significant ort knowledge engineer 
process applying ontology requires converting knowledge level specification ontology provides implementation 
time consuming requires careful consideration context intended usage idioms source ontology representation language target implementation language specific task current application 
despite subjective experiment knowledge reuse cost ective taken significantly longer design knowledge content ontology scratch application just reading technical papers describing 
cautiously optimistic longer term goal achieving large scale knowledge reuse 
outline brief summary background context motivation experiment 
examine step process reusing applying engineering math ontology 
highlight important issues indicate progress date 
conclude summarizing learned exercise 
context introduce application problem addressing target platform ontology reuse application specware language original ontology written ontolingua 
panel layout application task performed engineering software component functionality trying enhance engineering math ontology simplified version layout design sti panel 
specific task determine placement holes saving weight panel subject cost weight constraints follows length panel constraints hole placement various minimum separation distances cost function determine holes size optimizing cost function panel 
started fragment production code reverse engineered re implemented slang language specware see 
entailed declaratively representing engineering knowledge hidden assumptions implicit original code 
specification refined selecting specifying data structures algorithms specware synthesized executable code lisp 
model panel layout research prototype intended things demonstrate feasibility deriving knowledge engineering software reusable components formalized engineering knowledge 
specware platform demonstrating ontology reuse application specware system specification formal development software 
rigorous mathematical foundation logic category theory 
provides higher order logic representation language called slang semantics founded categorical type theory 
includes rich set primitives composing specifications reusing parameterizing copies specifications 
user specifies various component specifications included colimit operation category theory compute see 
specware created purpose developing software excluding emphasizing knowledge systems 
supports process refining specifications provably correct executable code 
slang designed represent knowledge level ontologies entirely adequate purpose 
higher level specifications slang correspond ontologies ontolingua see intended 
lower level specifications slang contain implementation information order specware generate code 
ontolingua ontolingua developed specifically purpose knowledge sharing reuse context knowledge systems development software general 
ontolingua kif facilitate reuse interoperability acting interchange format knowledge bases translated 
inference engine ontolingua slang way ontology written ontolingua machine translating implemented language 
translating arbitrary sets axioms logic output language feasible 
reason ontolingua biased object oriented representation style 
process ontology reuse application motivation reuse re engineering panel layout application slang performed prior experiment ontology reuse part wider objective capturing engineering knowledge explicit reusable form 
physical quantity engineering software typically represented real valued variable 
slang weight panel represented function mapping things sort panel things sort real weight panel real 
formulation possible convert di erent units test dimensional consistency equations 
goal experiment obtain benefits 
rewriting original application scratch tried reuse apply engineering math ontology incorporating application 
ontology defines principled implementation neutral manner set concepts relations representing manipulating physical quantities units measure 
translation knowledge level engineering math ontology desired tasks combine modified choose data structures algorithms refine executable code ontolingua slang slang implementation specification slang slang specification specification slang classes relations axioms sorts operators axioms units conversion dimensional analysis translated ontology functions implement panel layout application panel layout application plus engineering math lisp combine process ontology reuse application steps reuse due unique nature specware process converting engineering math ontology implemented format single translation step target knowledge representation language 
translate ontology slang specifications refined executable code separate step 
experiment involved steps see 
understanding ontology finding kernel reuse read ontolingua axioms associated documentation understand engineering math ontology 
identify initial kernel ontology sufficient achieve primary intended tasks units conversion dimensional analysis 

ontology translation convert definitions axioms comprising knowledge level ontolingua representation equivalent knowledge level slang formulation 

task specification refinement executable code define specify functions enable required tasks performed 
define refinements specifications produced steps move closer closer implementation ultimately executable code 

verification verify refinement step guarantee executable code true original specification 

integration application merge specification engineering math existing specification panel layout example refine executable code 
describe steps detail 
understanding ontology finding kernel reuse engineering math ontology documented technical ontolingua form 
web browsable contains additional documentation 
process understanding ontology continued translation phase details required 
quality clarity ontology high problems 
engineering math ontology covers wide range mathematical physical concepts engineering domain 
things tensors immediate relevance simplified panel layout application 
step experiment identify kernel subset full ontology captures essential ideas needed intended tasks units conversion dimensional analysis 
initially kernel translated slang 
minimum require engineering math ontology ability convert quantities specified di erent units perform dimensional analysis 
important secondary requirement su cient axioms able prove properties hold order algorithms valid 
requires axioms describing algebraic properties operations included commutativity 
kernel engineering math ontology identified meet tasks described 
physical quantity hypothetically measurable amount earth diameter tom age acres 
physical dimension nature kind quantity amount length time area 
quantity associated physical dimension 
magnitude measure amount respect particular unit measure 
magnitude feet yards 
unit measure physical quantity standard amount foot 
units measure distinguished ordinary quantities magnitudes positive matter unit algebraic operations add quantities physical dimension get meaningful result cm mm sense add feet pounds 
divide dimension get dimension meter second gives velocity dimension sense add dimensions 
operations quantities dimensions specific properties examples common algebraic objects 
example physical dimensions form vector space reals vector addition multiplication physical dimensions scalar multiplication corresponds exponentiation defined physical dimensions real numbers 
understanding algebraic properties provides basis performing dimensional analysis prevent adding feet 
ontology translation describe process results translating knowledge level representation engineering math ontology ontolingua equivalent knowledge level formulation slang 
note somewhat unique way ontolingua ontology 
ontolingua designed expectation ontologies translated directly implemented language loom clips equivalent knowledge level formulation transformed implementation 
initially importing ontolingua representation appeared reasonably straightforward 
informal mapping rules translating ontolingua slang 
ontologies ontolingua map specifications slang classes ontolingua naturally map sorts slang sub classes map sub sorts inheritance works somewhat di erently slots functions relations ontolingua map operators slang instances map constants ontology inclusion maps importing specifications name translations included ontologies local close analogue slang 
ontolingua unsorted logic conversion slang resulted concise notation avoiding frequent unary predicates required ontolingua 
tradeo slang type theory requires relax operator map sorts inconvenient expressions harder read 
di erences relatively minor 
case hope automated assistance possible kick start translation process 
closer examination number important di erences problems identified 
fundamental semantic di erences 
second able produce direct semantically correct translation mapping rules may expected representational idioms conventions target language 
translated version hard understand awkward 
analogous misuse prolog unfamiliar logic programming paradigm 
representational idioms correctly may representational choices influenced intended task 
discuss issues 
semantics ontolingua extension kif semantics founded set theory semantics slang founded categorical type theory 
confident mapping classes subclasses sorts subsorts semantic di erences carefully checked 
inferences possible done identify contain semantic di erences responsible inconsistencies order produce correct translations 
resolved issue 
representational style generating unnecessary sorts ontolingua class subclass thing set theoretic semantics kif means unbounded set 
slang need distinguish bounded vs unbounded sets 
naive application mapping rules result ontolingua class introduced subsort unnecessary undesirable 
furthermore specification superfluous sort corresponding thing brings point 
translating basic infrastructure virtually ontology ontolingua imports frame ontology extension kif 
substantial amount infrastructure including class thing definitions relations numbers slang notion relations explicitly defined slang built part language 
slang specifications exist define numbers 
attempting ensure ontolingua kif infrastructure represented slang introduced things needed basis 
composition obvious significant di erence styles ontolingua slang composition larger modules smaller ones accomplished 
di erence fundamental reflected composition primitives available language 
slang composition mechanism defined diagrams category theory general drawbacks 
ontology inclusion ontolingua results union sets axioms included ontologies 
semantics allows cyclic inclusion ontologies includes includes includes 
slang support 
hand way doing composition impossible compose ontology ontolingua including multiple copies existing ontology instantiated di erently parts ontology parameters 
slang capability fundamental 
specifications highly ectively instantiated times 
example include copies specification commutative operators addition physical quantities multiplication physical quantities 
convenient able introduce di erent local names di erent instantiations pieces specification 
copy call operator named original spec plus times 
importantly slang genuinely di erent things see 
ontolingua allows give thing di erent local names included di erent ontologies 
local name just synonym internally term synonyms refer 
continuing example suppose ontologies cr commutative relation qm qa quantity multiplication addition relation defined cr qm qa include cr renamed times qm plus qa 
results single relation real name cr local names times qm plus qa synonyms 
qa local name times second synonym times qa fa equal times times automatically specware 
specification created fa equal plus plus fa equal times times fa equal plus plus qa quantity addition sort op plus expands plus import translate library specifications commutative operator fa equal op sort sort triv trivial spec qm quantity multiplication sort op times expands times import translate qo quantity operations composition colimit sort op times op plus specifications created directly user 
illustrates specifications parameterized composition specware 
sort operator parameters specification contains axiom stating commutative property 
imported twice local names changed 
results distinct copies distinct sorts qm 
qa distinct operators times plus commutativity axioms 
desire specification combines copies operators sort achieve create diagram containing specification triv single sort mapped qm qa 
colimit operation performed specware joins component specifications required 
composition modules specware di erence real import 
ontolingua composition way create commutative relations 
conversely slang di erent specifications import component specification copies original specification inserted 
copy unique local name may di erent original name ontolingua refer di erent things local name see 
analogous example commutative operator qm qa specifications operator qm qa import specification local renaming 
relationship local names qm qa specify 
copies called times qm plus qa 
qa renamed times second copy called times qa synonym 
suppose wish specify qm qa part larger specification say qo quantity operations 
really want distinct operators far fine 
single sort see result distinct copies qm qa give local name 
desired want operators operate sort order get desired ect create formal diagram defined category theory 
user specify diagram copies sort qm qa refer single term composite specification qo 
specifications diagram brought colimit operation resulting qo 
case names placed equivalence class names means synonyms ontolingua example 
flexibility enables reuse specifications operate parsimonious way 
price paid flexibility simple things specify may appear unduly complicated unfamiliar style composition 
ontolingua alternate ways achieve parsimony multiple reuse basic concepts binary operator slang accomplished importing multiple parameterized versions specifications see algebra ontology ksl ontology library 
language supports di erent way thinking specifying composition 
advantages disadvantages 
di erences large language idioms conventions constitutes way modularize theory 
turns smallest ontologies ontolingua build larger ontologies tend larger smallest component specifications slang 
task specification refinement executable code completed discussion ontology translation 
consider task definition implementing specifications 
define tasks translation initial kernel engineering ontology slang resulted equivalent knowledge level formulation 
aimed increased generality support variety ways implement operations physical quantities dimensions 
certain tasks mind slang specifications units conversion dimensional analysis 
engineering math ontology designed possible perform tasks specified 
identified specified slang order apply ontology see 
adds task specific component slang specification included necessary functions performing units conversion 
missing su cient information implement knowledge level theory physical quantities executable functions 
describe 
refinement keeping design decisions original ontology knowledge level slang encoding commit implementation details 
slang wide spectrum language represent specifications ranging purely mathematical theories sets may completely free implementation biases way detailed specifications include data structures corresponding algorithms 
example implement sets list data structure algorithm required inserting new elements lists prevents duplicates 
slang contains primitives specifying refinements formal mappings specifications move closer closer implementation 
formally consist morphisms category specifications specification morphisms 
higher level specifications refined step step su cient implementation information specware may automatically generate executable code currently lisp 
order generate executable code main tasks 
choose data structures representing quantities dimensions 
second specify algorithms performing operations data structures correspond operations tasks performed quantities dimensions specification addition multiplication units conversion 
strings represent physical dimensions string operations concat specify algorithms 
similarly lists chosen list operations head tail 
experiment chose represent dimension physical quantity tuple real exponents basic dimensions length mass time money 
example represent length velocity respectively 
algorithm multiplication dimensions entails adding exponents 
slang data structures specified sort axiom statement states equivalence sorts 
example sort quantity equivalent tuple argument real number magnitude second argument dimension 
sort dimension turn tuple reals 
see slang specifications data structures algorithms computing multiplication quantities dimensions 
formal relationship stated knowledge level specifications 
refinements 
may sequence refinements just depending particular problem 
specified required refinements specware generated lisp code successfully performed required operations 
di erent units specified necessary conversions take place 
sort axiom quantity real dimension sort axiom dimension real real real real definition times dimension dimension dimension axiom equal times dimension plus length expt length expt plus time expt time expt plus mass expt mass expt plus money expt money expt definition definition times quantity quantity quantity axiom equal times quantity times magnitude magnitude times dimension dimension definition data structures algorithms verification specware system specification formal development software 
assists user producing executable code provably correct respect specification 
previous step described user defines series refinements ultimately lead executable code 
user responsibility prove validity refinement step theorem prover provided 
described implemented physical quantities units measure tuples 
multiplication physical dimensions theory commutative 
verify refinement prove multiplication dimensions defined manipulating tuples commutative 
multiplication implemented adding real exponents follows fact integer addition commutative 
specware automatically generated conjectures requiring proof manually performed proofs verification step remains unfinished experiment 
interestingly discovered axiom original slang specification proved refined implementation level theory 
failure traced error refinement process missing axioms original ontolingua ontology 
specifically proof required axioms concepts treated primitives undefined original engineering math ontology 
subsequently added axioms slang formulation 
absence axiom engineering math ontology need viewed error 
eventually definitions ground primitives 
needed prove theorems add axioms deemed unnecessary original ontology 
example shows required tasks ontology support ects representational choices original design subsequently ects ease reuse 
integration application phase integrate result panel layout application 
integration partially completed 
integration simple matter merging code previous step code generated specware specification panel layout application 
functions equations refer things engineering math specification see 
particular recall original version application represented physical quantities real numbers 
usual thing engineering software 
wish add capabilities doing units conversion dimensional analysis longer appropriate 
proceed modifying specification panel layout task merging engineering math specification 
new version physical quantities represented real numbers instances sort physical quantity slang language 
weight panel real weight panel physical quantity 
allows gain desired functionality 
importantly integration occur implementation level inserting lisp functions applications larger application 
occurs specification level 
advantageous changes level abstraction executable code simpler reusable 
example change refinement step described previous section represent physical dimensions strings tuples integers 
knowledge level specification remain unchanged 
specifications merged combined declarative specifications refined executable code 
generated lisp function computes volume panel dimensions di erent units providing answer specified unit 
demonstrated possible ways perform dimensional consistency analysis 
step goal having general capability producing engineering applications equations dimensionally correct 
important feature specware refinement composite specification may specified terms refinements individual components 
idea refine module containing engineering math panel layout specifications need refine revised versions panel layout specifications leaving engineering math refinements unchanged 
combined results previous step refining engineering math specification 
compositions refinements existing knowledge exist original panel layout example minor adaptations needed 
fundamental achieving reuse comes price complicated 
requires solid understanding basics category theory general category specifications specification morphisms particular 
furthermore limitations specware system require creative arounds 
application fully developed functionality specware 
concluding remarks described start finish process reusing applying existing ontology engineering application 
application small feasibility demonstration 
remains complete integration demonstrate approach ensuring dimensional consistency units conversion su ciently convenient scales larger problems 
learned great deal experiment 
discussion experiment designed explore test premise possible reuse existing bodies engineering knowledge may design aircraft 
reflect experience draw engineering math ontology ontolingua issues involved incorporating ontology application 
ontolingua engineering math ontology ontolingua appears satisfactory ontology representation language providing adequate implementation neutral constructs able read understand ontology 
ksl ontology server provides convenient way browse ontologies 
engineering math ontology high quality right level generality purposes 
reusing ontologies generic carefully designed may di cult 
experiment raised general question shelf ontologies bottom primitives assumed definitions 
choice engineering ontology perfectly appropriate envisioned uses meet requirements 
formal approach required specware meant additional needed augment existing axiomatization 
general issue design sharable ontologies requires investigation 
translation important observation experiment significant manual ort involved translating ontology 
observation particularly significant interest fully automatic translation ontolingua ai languages supporting computation lisp prolog loom 
experience believe issue involves rich source di cult challenges may time inherent barriers fully automating process producing accurate translation highly expressive languages 
technical barriers include requirement translator embody full knowledge syntax semantics languages 
related question foundational infrastructure language translated ontology interest 
problems overcome provably correct mapping possible arbitrary sentences language output may hard understand hard 
arise di erences paradigms intended purposes languages 
especially di cult integrate automatic translations hand crafted knowledge bases correct idioms 
excellent example dramatically di erent styles composition component modules slang ontolingua 
intrinsic problems may overcome arise design decisions required translation depend information original ontology 
particular consider tasks ontology intended serve 
advocate abandoning translation tools suggest tools user assisted foreseeable 
specware believe specware provides platform exploring ontology reuse application 
rich composition framework supports reuse specifications refinements levels 
supporting formal refinements knowledge level implementation way directly apply ontologies 
cost benefits ontology reuse significant involved full process incorporating engineering math ontology application subjective taken significantly longer design knowledge content ontology scratch application just reading technical papers describing 
definitions ontolingua provided clear formal description target vocabulary greatly assisted understanding meant terms defined 
engineering math ontology degree standard longer term potential applications built interoperate easily conform physical quantities vocabulary 
tentative promising achieving larger scale knowledge reuse 
grateful mike barley helpful discussions ontology translation 
barley clark williamson woods 
neutral representation project 
proc aaai spring symposium ontological engineering 
aaai press 
borst akkermans top 
engineering ontologies 
international journal human computer studies submitted 
crole 
categories types 
cambridge university press 
cutkosky engelmore fikes genesereth gruber mark tenenbaum weber 
pact experiment integrating concurrent engineering systems 
ieee computer pages jan 
fikes farquhar rice 
tools assembling modular ontologies ontolingua 
proceedings aaai pages 
genesereth fikes 
knowledge interchange format version manual 
technical report logic computer science department stanford university 
gruber 
translation approach portable ontology specifications 
knowledge acquisition 
gruber olsen 
ontology engineering mathematics 
proc 
fourth international conference principles knowledge representation reasoning 
morgan kau man 
mcguire kuokka weber tenenbaum gruber olsen 
shade knowledge technology re engineering problem 
concurrent engineering applications research sep 
pierce 
basic category theory computer scientists 
mit press 

editor uschold 
knowledge level modelling concepts terminology 
knowledge engineering review 
waldinger srinivas goldberg 
specware language manual 
williamson healy jasper 
formally specifying engineering design rationale 
technical report applied research technology boeing 
