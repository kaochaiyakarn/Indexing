analysis testing programs exception handling constructs sinha mary jean harrold department computer information science ohio state university lab columbus oh usa tel fax cis ohio state edu analysis techniques control flow data flow control dependence variety software engineering tasks including structural regression testing dynamic execution profiling static dynamic slicing program understanding 
applicable programs languages java analysis techniques account effects exception occurrences exception handling constructs failure cause analysis techniques compute incorrect results limit usefulness applications 
discusses impact exception handling constructs analysis techniques 
presents techniques construct representations programs exception occurrences exception handling constructs algorithms representations perform desired analyses 
discusses software engineering applications analyses 
describes empirical results pertaining occurrence exception handling constructs java programs impact analysis software engineering tasks 
keywords exception handling program analysis program slicing structural testing regression testing 
software engineering tasks test coverage analysis test case generation regression testing dynamic execution profiling impact analysis static dynamic slicing require information control flow control dependence data dependence statements program 
research addressed problems computing analysis information individual procedures intraprocedural interacting procedures interprocedural 
research addressed problems performing analyses programs transfers control continue goto statements affect analyses intraprocedural level 
research addressed problems performing analyses programs transfers control exit statements affect analyses interprocedural level :10.1.1.114.5033
applicable programs languages java analysis techniques extent possible account effects exception handling constructs 
analyses representations applied individual procedures applied individual methods 
procedure mean procedure method 
see www cygnus com misc wp iso ansi standard 
exception handling constructs provide mechanism raising exceptions facility designating protected code attaching exception handlers blocks code 
failure account effects exception handling constructs performing analyses result incorrect analysis information turn result unreliable software tools 
example branch coverage testing tool fails recognize flow control exception handling constructs adequately measure branch coverage test suite 
example slicing tool java fails recognize flow control exception handling constructs accurately compute control data dependence may result incorrect slices 
additional expense required perform analyses account effects constructs may justified constructs occur frequently practice 
determine frequency java programs exception handling constructs conducted study examined variety java applications 
subject obtained count classes contain throw statements 
table summarizes results study 
subject table describes subject lists number classes examined lists classes contain throw statements 
table frequency occurrence exception handling statements java programs 
subject number classes name description classes throw debug sun java debugger jar sun java archive tool java cup lalr parser generator java javac sun java compiler javadoc sun html document generator jdk api sun jdk api aas java aristotle analysis system java analyzer jlex lexical analyzer generator java swing api sun swing api total table illustrates examined classes contain throw statements 
subject percentage classes contain throw statements ranges 
study supports belief exception handling constructs practice significant considered various analyses 
researchers considered effects exception handling constructs various types analyses 
approach performs control flow analysis compute points information presence exceptions 
approach performs control flow analysis facilitate interprocedural path profiling handles code contains exception handling constructs 
addresses problem computing exception propagation ada programs 
techniques defines representations analyses control dependence computation software engineering tasks regression test selection performed 
facilitate analyses software engineering tasks investigated effects exception handling constructs various types analysis developed new techniques perform analyses presence exceptions developed representations analysis information analyses applications applied 
results types analysis control flow program slicing discuss analysis information applications structural testing regression test selection 
discuss effects exception handling constructs analyses new techniques performing analyses constructing appropriate representations presence exceptions 
restrict discussion representations programs contain java exception handling constructs representations constructs languages constructed similarly 
restrict discussion problems representations analyses exception handling constructs techniques handling features object oriented languages polymorphism object flow discussed :10.1.1.33.6605
results empirical studies performed program analysis system aristotle analysis system java aas java written java analyzes java byte code files 
studies evaluate precision representations compare results obtained techniques obtained techniques fail account exception handling constructs 
results suggest analyses representations consider constructs fail identify important dependences program 
omitted dependences significant impact accuracy tools require dependences 
section gives overview exception handling constructs specifies constructs techniques handle 
introducing example rest section discusses effects exception handling constructs types analyses 
section presents analysis techniques representations constructed techniques empirical studies pertaining techniques 
section discusses representations applications structural testing regression test selection 
section gives presents 
exception handling constructs section provides overview exception handling constructs java language model details java language 
languages ada provide similar exception handling mechanisms 
java exception object exception instance class derived class java lang throwable 
exception raised point program throw statement 
expression associated throw statement denotes exception object 
try statement provides mechanism designating guarded code associating exception handlers code 
try statement consists try block optionally catch block block 
legal instances try statement try catch try catch try 
code left shows typical try statement 
try block contains statements execution monitored exception occurrences 
catch block may associated try block sequence catch clauses specify exception handlers 
catch clause specifies type exception handles contains block code executed exception type raised associated try block 
try statement block 
block code executed regardless way control transfers try block reaching statement try block aas java provides language dependent analysis java programs byte code level required language independent tools part aristotle analysis system 
handler handler handler exceptions try guarded section 
catch 
catch exception 
cleanup code 
catch java exceptions synchronous unchecked checked 
explicitly 
asynchronous 
implicitly 
explicitly 
implicitly raised raised raised raised syntax exception handling constructs java left java exception types right 
exception may may handled associated catch block break continue return statement 
java follows non model exception handling exception handled control return point exception raised continues statement try statement handled exception 
java exception propagated call stack method raises handle exception exception context caller method 
exceptions java classified criteria graph right shows classification criteria 
criteria reflect semantics raising exception impose requirements way exception handled 
example java exception synchronous asynchronous 
synchronous exception occurs particular program point caused expression evaluation statement execution explicit throw statement 
asynchronous exception hand occur arbitrary non deterministic points program 
synchronous exception checked unchecked 
checked exception compiler find handler signature declaration method raises exception 
unchecked exception compiler attempt find associated handler signature declaration 
purposes program analysis classify synchronous exception explicitly raised implicitly raised 
synchronous exception explicitly raised exception raised throw statement application analyzed 
synchronous exception implicitly raised exception raised call library routine runtime environment 
example call api method java util stack pop raise expression dereferences object cause nullpointerexception 
techniques discuss assumption program point exception raised determined 
techniques apply asynchronous exceptions safe approximation program points may raise exceptions include statements program 
exclude implicitly raised exceptions caused side effect expression evaluation 
analysis type exceptions scope current includes investigating ways extend include 
techniques applicable explicitly raised exceptions discuss implications exceptions raised library routines section 
effects exception handling constructs analyses section describe program illustrate concepts 
discuss impact exception handling constructs analysis techniques control flow analysis data flow analysis control dependence analysis program slicing discuss ramifications exception handling constructs applications 
vending machine program vending machine program shown simulates actions vending machine 
machine lets user insert coins request refund select item numeric keypad 
user selects valid item enters coins value sufficient cover cost item machines dispenses selected item 
user erroneous selection machine asks user reenter selection 
user may reenter selection request refund coins 
machine tracks number erroneous selections entered user number erroneous selections exceeds predetermined value machine aborts transaction returns user coins 
explains various error conditions may arise transaction presents class hierarchy exceptions correspond conditions 
method main lines presents user options user action invokes methods defined class process action 
method insert lines ensures user entered valid coin increments current value value coin insert raises exception user enters invalid coin 
method lines coins value equal current value resets current value raises exception current value zero 
method vend lines accepts user selection current value zero invokes method dispense defined dispenser class 
method dispense lines performs error checks ensure selection valid item line selection available dispensing line current value covers cost selection line 
checks fails code raises appropriate exception 
checks pass dispense simulates dispensing item printing message returns balance transaction 
successful completion dispense vend updates appropriate state variables lines calls return balance user line 
dispense raises exception signals erroneous selection lines vend handles exception line increments 
exceeds constant max attempts vend caught exception line causes main abort transaction 
omit details methods dispenser value dispenser available relevant presentation methods raise exceptions 
brevity exclude details constructors classes initialization constants max attempts min selection 
adapted example kung appeared 
public void vend int selection throw new try catch enter selection throw catch public class new dispenser take coins private int private int private int private dispenser current value public void insert coin coin int value valueof coin value throw new value public throw new public void dispense selection bal bal int bal value selection selection sel unavailable available sel new int val value sel new val null throw take selection sel max selection new selection sel invalid exception null public void dispense int int sel public class dispenser value zero 
enter coins public static void main vm new true try try switch action case insert vm insert coin case vend vm vend selection vm catch illegal coin vm enter coins val catch catch int val getvalue catch transaction aborted case return vm java code vending machine program class top class dispenser bottom left method main bottom right 
impact exceptions control flow analysis control flow analysis determines program statement statements program follow execution program 
program analysis techniques data flow control dependence analyses software engineering tasks structural regression testing utilize zv exception exception condition unavailable user enters number user selects item costs user inserts illegal coin user selects item temporarily available user selects item requests refund inserting coins correspond valid selection value coins inserted ia ic sna hierarchy exception related classes abbreviated names vending machine program left conditions cause various exceptions raised right 
control flow information program 
techniques typically construct control flow representation program 
analyses useful applications effective presence exception handling constructs control flow representation incorporates exception induced control flow required 
vending machine program exemplifies complexity presence constructs introduce control flow program 
example insert control reach line predicate line evaluates true exception raised line terminates execution insert transfers control caller insert 
example consider call dispense line 
call control may return call site dispense raises exception control may return line control may return vend 
effects exception handling constructs impact control flow method methods introduce complex control flow paths program 
control flow relation exists program represented control flow graph cfg nodes represent statements edges represent flow control statements 
depicts cfgs methods vending machine program 
node labeled line number source statement represents nodes represent source statements 
cfg entry node labeled name corresponding method exit node 
call site represented pair nodes call node return node example call site line represented call node return node 
cfgs represent exception induced control flow 
consequently nodes represent throw statements connected exit nodes respective cfgs nodes represent catch statements nodes edges 
section describe approach connecting nodes cfg creating intraprocedural interprocedural representations program 
impact exceptions data flow analysis data flow analysis techniques compute different programs points data flow facts pairs reaching definitions available expressions live variables hold points 
data flow separate call return nodes required call site intraprocedural control flow representation add facilitate construction interprocedural control flow representation 
control flow exit exit insert vending machine exit dispense exit vend main zv control flow exit ia ic zv cfgs methods vending machine program 
information activities program slicing data flow testing compiler optimizations :10.1.1.50.4405
typical data flow problem formulated set data flow equations solutions iteratively propagated program cfg solution dataflow problem fixed point solution equations 
presence exception handling constructs cause analysis solution unsafe solution fails conservative approximation true solution 
unsafe analysis solutions unacceptable applications analyses 
illustrate consider impact exception handling constructs computation pairs 
definition pair pair statement defines variable changes statement uses change path program redefined 
exception handling constructs may cause definition depending type data flow problem conservative safe solution superset subset true solution 
computation unsafe ways 
definition pair may detected cfg path definition 
vending machine program pair includes statement vm defined statement vm 
cfg main path node leads node 
definition computation fail detect definition pair 
second exception handling constructs introduce additional definition pairs program exception object 
definition exception object statement subsequent statement example definition pair 
data flow relation represented data dependence graph nodes represent program statements edges represent data dependence statements 
graph definition pairs data dependence edge exists nodes definition pair 
results data flow analyses points analysis represented data dependence graph 
clearly computation correct data flow information presence exceptions depends correctly representing control flow exception handling constructs 
computation requires interprocedural data flow analysis algorithms modified account additional interprocedural relations caused exception handling constructs 
includes adapting existing interprocedural definition analysis account exception handling constructs 
impact exceptions control dependence analysis control dependence analysis determines program statement predicates control execution statement 
informally statement control dependent predicate cfg edges node edges causes node reached edge may cause node reached 
information required analyses slicing software engineering tools debuggers impact analyzers regression testers 
analyses tools compute correct information control dependence analysis consider effects exception handling constructs 
presence statements raise exceptions alters control dependences program 
example method insert vending machine program throw statement line causes statement control dependent statement 
control dependence statement differs dependence computed line contain ordinary statement throw statement statement control dependent entry insert 
significant impact exceptions individual methods impact interprocedural control dependences control dependence relationships hold method procedure boundaries :10.1.1.114.5033
factor affects interprocedural control dependences presence potentially non returning call sites call sites control may return called methods :10.1.1.114.5033
effects interprocedural control flow exception handling constructs cause programs 
vending machine program call site line call control may return statement statement control may return vend 
causes statements statement follow call site control dependent conditional statements called methods statement control dependent statement dispense 
presence exception handling constructs control dependences certain statements appear catch block computable interprocedural context statements control dependence zv undefined entry control dependence graph method vend 
intraprocedural control dependences 
example execution statements belong main controlled solely decisions insert 
identify control dependences statements interprocedural control dependences computed 
control dependence relation represented control dependence graph 
control dependence graph cdg contains node predicate statement procedure edge predicate statement control dependent unique root node denotes entry predicate represents control dependences statements reached entry procedure 
shows cdg method vend constructed cfg vend shown 
cdg disconnected components control dependences catch handlers vend statements control dependent entry handlers computed interprocedural context control dependences statements undefined unknown 
problem computing control dependences presence exceptions solved constructing correct control flow representation identifying accounting effects control dependences 
correct control flow representation accounts changes intraprocedural control dependences described example 
representation account changes intraprocedural interprocedural control dependences caused traditional control dependence computation applied correct control flow representation fails identify control dependence statement statement 
changes control dependences may fact significant 
section approach correctly computes control dependences caused exception handling constructs 
impact exceptions program slicing program slice program computed respect slicing criterion program point set variables referenced includes statements may influence values variables 
alternative approaches computing slices data flow equations compute slices constructing dependence graphs graph reachability graphs compute slices :10.1.1.50.4405
existing interprocedural slicing algorithms accounts effects exception handling constructs slicing 
slicing criterion slices computed algorithms may omit statements slice affect values variables program point reason omission slices computed forward direction case slice contains statements program may affected value variable program point algorithms intraprocedural control dependence information control flow graphs single methods procedures intraprocedural control dependence 
describes ways intraprocedural control dependence computation inaccurately models semantic dependences exist program statements :10.1.1.114.5033
way intraprocedural control dependence computation inaccurately models semantic dependence seen effects exception handling constructs 
example consider throw statement line vending machine program affects control dependences statements methods vend main 
control dependence computed usual way considering effects throw statement statement example control dependent entry vend 
closer inspection see statement depends immediately execution statement throw statement 
definition semantic dependence statement semantically dependent statement statement included slice includes statement 
control dependence information existing interprocedural slicing algorithms computed considering effects throw statements slice computed existing algorithms include statement 
section technique compute safe slices presence exception handling constructs 
analysis techniques accommodate exception handling constructs section describe analysis techniques control flow analysis control dependence analysis slicing account effects exception handling constructs safely applied programs contain constructs 
facilitate ensuing discussion introduce terminology provide informal definition term 
program unit program block method 
program unit directly raises exception lexically encloses throw statement 
program unit indirectly raises exception lexically encloses call site called method propagates exception 
program unit propagates exception raises exception handle exception 
program unit directly propagates exception directly raises handle exception similarly program unit indirectly propagates exception indirectly raises handle exception 
catch clause type handles exception type propagated try block associated catch clause type subtype catch clause block encloses program statement try block associated catch clause block lexically encloses catch clause local handler handles exceptions directly raised try block associated catch clause 
catch clause interprocedural handler handles exceptions indirectly raised try block associated catch clause 
catch clause global handler local handler interprocedural handler 
control flow analysis saw section presence exception handling constructs creates control flow paths methods 
useful intraprocedural interprocedural control flow representations block block try block raises exception try block raises exception block specified try block raises exception catch block handle try block raises exception catch block handle exception block specified try block raises exception catch block handles exception catch block handles exception block catch block handles exception raises exception block specified catch block handles exception raises exception block block raises exception block raises exception block propagates previous exception raises catch catch block handles exception block specified exception try handle exception block specified exception block block block nested block propagates exception catch block handles exception nested block propagates exception catch block nested block exception propagated try statement normal exceptional method exceptional exit normal exit exceptional exit normal exit control flow java exception handling constructs 
contain paths 
intraprocedural analysis exception raised try block control transfers catch clause handles raised exception 
catch clause may associated try block exception raised may associated lexically enclosing try block 
parameter matching catch clause bound thrown object handler code executed 
execution handler code normal execution resumes statement follows try statement exception handled 
control exits try statement block try statement executed exists regardless control exits try statement unhandled exception 
block level control flow graph shown summarizes control flow try statement 
shows try statement component blocks conditions triggering control flow blocks numbered listed 
discussion type path try statement referenced edges traverses block 
path taken try block raises exception block specified 
path taken try blocks raise exceptions 
path taken try block completes normally block raises exception 
path taken try block raises exception handler catch block handles exception block specified 
path taken try block raises exception nested block propagates exception handler catch block handles exception block specified 
path taken try block raises exception nested block propagates exception catch block handles exception block raises exception 
path taken try block raises exception nested block propagates exception handled catch block block raises exception 
path taken try block raises exception nested block propagates exception catch block handles exception block specified 
path taken try block raises exception nested block propagates exception catch block handles exception raises exception block raises exception 
path taken try block raises exception nested block propagates exception catch block handles exception raises exception block specified 
constructing cfg method contains exception handling constructs connect node corresponding throw statement local handlers handle raised exceptions 
node may multiple edges corresponding type exception raised throw statement 
distinguish edges annotate edge type exception causes edge traversed program execution 
presents cfgs methods vending machine program constructed approach 
throw statement line may raise types exceptions sna ia 
node statement edges type exception labeled exception type 
throw statement raises single type exception cfg node statement single edge labeled exception type 
example node single edge labeled zv corresponding throw statement raises exception type zv 
construct cfg types exceptions raised throw statement available 
cfg construction algorithm performs type inferencing locally method determine exception types address issue section 
exception type corresponding edge caught local handler target edge throw statement node catch handler node 
exception caught interprocedural global handler belongs separate method exception propagated method edge connected catch statement node 
model propagation exception method connect edge exceptional exit node 
exceptional exit node exit point cfg type associated represents propagation exception type corresponding method 
cfg method exceptional exit nodes distinct type exceptions directly propagated method 
cfg vend exceptional exit nodes vend directly propagate exception types 
cfgs insert exceptional exit node methods directly propagate single exception type 
method vend indirectly propagates call dispense exceptional exit node indirectly propagated exception created interprocedural representation section 
discussion identify exceptional exit node associated type 
type inference algorithm section determines throw statement line potentially raise types exceptions 
cfg contains exceptional exit node types 
control flow exit exit exceptional exit exit exceptional insert vending machine exit dispense exit exceptional exit exceptional exit vend main exit exceptional exit exceptional exit exceptional zv sna exit exceptional exit exceptional ia exit ia ic zv ic zv zv sna cfgs methods vending machine program constructed approach 
exceptions propagated method cfg method contains exceptional exit nodes exception type 
create representation multiple exit points distinct exception types propagated method caught distinct interprocedural global handlers handlers 
representation explicitly shows types exceptions propagated method facilitates program comprehension 
nodes correspond catch handlers labeled statement number handler type 
cfg node local handler edges exceptions caught handler 
global handler catches directly raised exceptions node handler edges cfg exceptions 
interprocedural handler catches indirectly raised exceptions exceptions raised methods called method contains handler 
node interprocedural handler edges cfg handler edges interprocedural representation 
handlers vending machine program interprocedural handlers nodes cfgs correspond handlers edges 
presence blocks complicates control flow java programs 
java block execute contexts normal context exceptional context 
instances blocks illustrate contexts 
block executes normal context control reaches try block catch block control leaves try statement transfer control statement break continue return 
block executes exceptional context control leaves try statement propagation exception 
context execution block determines control flows block 
naive representation control flow embeds nodes block cfg containing method creates edges node block execution block edge node edge 
representation cause existing propagation algorithms analysis traverse paths enter block edge represents execution block normal context leave block edge represents execution block exceptional context 
circumvent problem treat block separate method create separate cfg block insert call nodes blocks appropriately 
details cfg construction algorithm 
interprocedural analysis propagation exception called method caller creates interprocedural control flow paths represented interprocedural control flow graph 
interprocedural control flow graph icfg program consists cfgs method procedure call site call node connected entry node called method procedure call edge exit node called method procedure connected corresponding return node return edge 
presents interprocedural block level control flow graph similar shows called method top caller 
call try block shown call edge 
completes normally control returns normal exit propagates exception control returns exceptional exit 
exceptional exit control flows places try block associated catch block handler catches exception raised control flows handler try block corresponding block control flows block block executes exceptional context true method exits exceptionally search handler continues caller presence exception handling constructs icfg contains additional interprocedural edges originate exceptional exit node called method terminate catch statement node call node calls block exceptional exit node caller method 
call edges exceptional return edges 
shows icfg vending machine program 
call node connected entry node cfg called method exit node cfg connected corresponding return node 
method propagates exception caught caller method node type exception connected appropriate catch node caller 
example insert propagates caught statement main catch block block block try block try statement normal exceptional exceptional exit exceptional exit normal exit calling method called method exceptional exit normal exit normal exit interprocedural control flow exception handling constructs 
caller insert 
exceptional exit node cfg insert connected exceptional return edge node cfg main 
method may propagate exception caught immediate caller method method lies call sequence 
example main calls vend vend calls dispense 
dispense propagates vend handle exception indirectly propagates main 
chain exceptional return edges icfg reflect exception propagation exceptional exit node type cfg dispense connected exceptional exit node type cfg vend turn connected catch node cfg main 
icfg construction algorithm adds exceptional exit nodes cfg method node exception type indirectly propagated method creates call return exceptional return edges call site method 
algorithm iteratively determines indirectly propagated exception types method algorithm creates new exceptional exit node method methods call method 
efficient implementation algorithm processes nodes reverse topological order strongly connected nodes program call multigraph causes non recursive method processed groups recursive methods strongly connected component processed iteratively fixed point reached 
call multigraph program contains node method edge node node call site method corresponding calls method corresponding exit exceptional exit insert vending machine exit exit exceptional exit main exit exit exceptional dispense exit exceptional vend exit exceptional exit exceptional exit exceptional zv exit exceptional exit exceptional exit exceptional ia ic zv ic zv exit zv ia sna intraprocedural control flow control flow interprocedural sna icfg vending machine program 
precision control flow representations cfg construction algorithm requires information exception types raised throw statement 
precise type information throw statement includes types reached throw statement execution path 
precision type information determines extent infeasible paths introduced representations 
cfg throw node edges types exceptions raised corresponding throw statement edge exception type 
imprecise safe approximation exception types results additional edges emanating throw nodes paths starting edges infeasible 
example path starting edge labeled node infeasible raised vending machine program 
type inference algorithms attempt determine types expression program solving type constraints propagating local type information program 
techniques path infeasible exists input program cause path executed 
traditionally applied optimization dynamically dispatched function calls 
uses context sensitive points analysis infer types programs contain exception handling constructs 
type inference exception types required throw statements exception type determined inspection throw statement 
example throw statement line vending machine program expression new instance expression requires type inference analysis type exception raised statement 
throw statement line requires type inference analysis raises exception object stored variable different exception objects created assigned variable different paths throw statement 
throw statement may raise exception returned method called throw statement 
table types throw statement expressions 
throw throw statement expressions subject statements new instance variable method call debug jar java cup javac javadoc jdk api aas java jlex swing api total empirical evidence subjects listed table indicates practice overwhelming majority throw statements mention new instance expression require type inference analysis 
table lists numbers types throw statement expressions appeared subjects 
data table illustrates throw statements subjects required type inference analysis 
remaining thirds mentioned variable 
subjects swing api contained throw statements exception object returned method call 
approach determining types throw statements avoids exhaustive propagation type information program 
constructing cfg method perform local analysis method safely approximate exception types raised throw statements method 
local type inference algorithm performs reverse data flow analysis starting throw statement searches statements types reach throw statement defined 
analysis reaches statements define types paths throw statement precisely identifies exception types statically reach throw statement 
example type inference algorithm traverses backwards paths throw statement line precisely determines types throw statement 
analysis reaches entry method catch handler call site conservative approximation potential exception types 
algorithm conservative approximation times analyzing throw statement traverses backwards paths starting throw statement 
conservative approximation cause algorithm imprecise 
example throw statements mentioned variables safe approx 
entry safe approx 
catch precise sizes type sets inferred type inference algorithm cases throw statement expressions variables 
horizontal axis contains calibrations throw statement mentioned variable 
data points indentation appear right preceding indentation indentation 
traversing backwards paths throw statement line analysis reaches catch handler line safely approximates types throw statement 
inspection vending machine program reveals approximation imprecise raised throw statement 
imprecision creates exceptional exit node cfg vend node required 
analysis conservative approximation method boundary safe presence aliasing 
algorithm demand driven computes information point information required exhaustively computing information entire program 
algorithm flow sensitive considers control flow statements method containing throw statement context insensitive conservative approximation method entry catch handler call site 
evaluate efficacy type inference algorithm performed study analysis results obtained aas java subject programs gathered empirical data sizes type sets inferred algorithm throw statements mentioned variable 
throw statement determined type set size type inferencing succeeded dataflow analysis terminated reaching entry node catch node call node 
determined type set sizes type inferencing failed safe approximation entry node catch node call node 
shows type set sizes throw statements 
horizontal axis calibrations corresponding throw statements order subjects listed type set size entry catch type set sizes cases type inference algorithm conservative approximations entry catch nodes 
table 
calibrations represent throw statements debug sixth calibration represents throw statement java cup 
sets data points 
set data points correspond cases type inferencing succeeded type sets precise 
sets data points correspond cases type inferencing failed reaching entry node catch node respectively 
throw statements analyzed type inferencing failed reaching call node 
calibrations horizontal axis data points calibration data points appear right preceding calibration calibration correspond calibration 
example second calibration data points tenth calibration data points 
calibration data point type inference algorithm conservative approximations times 
analyzing throw statement corresponds second calibration type inference algorithm conservative approximations catch nodes 
throw statements type inference algorithm invoked succeeded statements type sets inferred algorithm contained single element cases 
throw statements type inference algorithm conservation approximation entry catch node 
statements type sets contained single element type inferencing precise 
statements type sets contained elements 
remaining throw statements type set sizes ranged 
imprecision type sets cases causes infeasible branches cfgs 
invocations type inference algorithm reached entry node times catch node times 
summarizes type set sizes cases shows percentages type sets sizes various ranges 
times type inference reached catch node conservative approximation resulted single element type set 
performed type inferencing throw statements swing api exception objects returned methods 
cases average type sets contained elements 
extend type inference algorithm perform analysis called methods 
empirical results support belief practice exhaustive type inference algorithms may required determine exception types 
approach type inferencing worked throw statements appeared subjects 
cases type sets contained elements imprecise 
imprecision type information cause infeasible edges cfgs constructed information 
approach type inferencing fails small percentage throw statements imprecision cases generates large type sets 
possibilities improving precision type sets 
example type inference algorithm extended entry catch nodes perform analysis methods 
extension requires iterative approach icfg construction type inferencing interleaved 
optimization may applicable examine object creation sites program utilize information refine type sets 
approach may unsafe exception objects may created library calls application 
third approach propagate information catch handlers enclose call sites program call multigraph information create exceptional exit nodes 
potential approach solicit user input cases imprecision type sets exceeds threshold value 
investigate feasibility approaches 
control dependence analysis section saw exception handling constructs affect control dependence relations interprocedurally causing potentially non returning call sites 
compute correct control dependences control dependence computation account effects 
computation proceeds phases phase identifies caused throw statements uses information compute partial control dependences phase uses partial control dependences propagate control dependence information methods procedures compute interprocedural control dependence :10.1.1.114.5033
computation partial control dependences step algorithm computes partial control dependences identifies call sites 
identify algorithm determines set return sites call node 
return site set call node contains nodes cfg method control return call 
return site set call node contains corresponding return node call site represented call node definitely returning 
return site set contains node corresponding call site 
example return site set call node contains node node exceptional exit node ia call vend control may return nodes 
similarly return site set call node contains nodes 
identification algorithm performs reachability analysis call multigraph identify caused exception handling constructs halt statements 
caused halt statement algorithm adds super exit node explained method containing call site return site set call site 
identify caused halt statement algorithm identifies methods contain halt statements reverse graph reachability analysis call multigraph identifies call sites halt statements reachable 
caused exception handling constructs algorithm adds return site set corresponding call site node control potentially return call 
identify algorithm initializes information directly propagated exception types method iteratively computes indirectly propagated exception types methods 
part algorithm similar icfg construction algorithm section 
icfg constructed information gathered part algorithm directly extracted icfg target standard api method java lang system exit halt statement java 
exit exit exceptional exit exceptional vend zv rp rp exit exceptional super exit control flow control dependence rp exit exceptional exit exceptional rp exit exceptional super exit entry exit zv zv ia ia acfg method vend vending machine program left cdg constructed acfg right 
exceptional return edges called methods nodes added return site set 
return site set call site computed phase control dependence computation constructs augmented control flow graph summarizes effects external control dependences statements method 
augmented control flow graph acfg method control flow graph augmented placeholder nodes represent predicates methods statements control dependent 
acfg contains unique conditional node return predicate acts placeholder predicates return called method control dependent 
return predicate node edge labeled target edge node appears return site set corresponding 
acfg contains unique node super exit represents exits shows acfg method vend 
acfg contains return predicate nodes rp rp call sites statements 
node rp edges node appears return site set call node edge exceptional exit node labeled type exceptional exit node 
node rp likewise edges node appears return site set call node 
partial control dependences intraprocedural control dependences computed acfg 
graph right shows cdg constructed acfg method vend 
partial control dependences nodes control dependent predicates called call multigraph algorithm suffer imprecision due statically unreachable code algorithm flow insensitive 
precise computationally expensive version algorithm icfg identifies removes statically unreachable code performing analysis 
practice expect imprecision caused statically unreachable code significant 
methods contain return predicate node 
example partial control dependence node includes return predicate node rp node control dependent predicate statement method dispense 
table intraprocedural control dependences vend computed cfg partial control dependences method computed acfg 
control control control control dependent dependent dependent dependent node cfg acfg node cfg acfg entry entry undefined rp undefined rp rp rp rp undefined rp rp exit rp undefined rp table lists intraprocedural control dependences partial control dependences nodes cfg vend 
comparison shows control dependences computed acfg differ computed cfg nodes remaining nodes 
partial control dependences useful applications computing slices computing procedure level control dependences computing interprocedural control dependences 
propagation interprocedural control dependences partial control dependences contain correct control dependences nodes control dependent non placeholder nodes 
control dependences nodes control dependent placeholder return predicate nodes adjusted 
phase control dependence computation performs adjustment propagating control dependences methods computes interprocedural control dependences 
phase algorithm iteratively propagates control dependences interprocedural call return exceptional return edges icfg fixed point reached 
fixed point computation algorithm processes nodes call entry return exit catch sources targets interprocedural edges icfg 
computing fixed point solution algorithm adjusts control dependences remaining nodes 
example fixed point computation algorithm propagates control dependence exit node cfg dispense return node cfg vend return edge connects nodes icfg 
fixed point computation algorithm adjusts control dependence nodes 
example algorithm propagates control dependence sna node node exceptional return edge connects nodes algorithm adjusts control dependence node fixed point solution computed 
table lists interprocedural control dependences nodes cfg method vend 
impact exceptions partial control dependences determine extent presence exception handling constructs affect control dependences gathered preliminary data statements different intraprocedural partial control depen table interprocedural control dependences vend 
control control node dependent node dependent entry sna sna exit sna dences 
subject built cfgs methods subject aas java 
analysis tools aristotle analysis system construct method cfg method acfg method 
node cfg excluding entry exit nodes determined node different control dependences 
table effect exception handling constructs partial control dependences 
nodes affected subject statement nodes partial control dependences debug jar java cup javac javadoc jdk api aas java jlex swing api table presents results study 
illustrates control dependences significant number nodes affected average control dependences nearly half nodes subjects affected 
percentage affected nodes ranged jar swing api 
results preliminary indicate actual differences control dependences indicate impact differences control dependences analysis techniques slicing control dependences 
program slicing effects interprocedural control dependence exception handling constructs significant impact slice computation 
alternative techniques slicing data flow equations construct dependence graphs perform graph reachability compute slices 
extends data flow slicing technique compute slices presence halt statements 
control flow representations described technique compute slices presence exception handling constructs 
describe extensions dependence graph slicing technique accommodate exception handling constructs 
system dependence graph sdg collection procedure dependence graphs pdg procedure nodes statements predicate expressions :10.1.1.50.4405
flow dependence edges represent flow data statements expressions control dependence edges represent control conditions execution statement expression depends 
pdg contains entry node represents entry procedure 
model parameter passing sdg associates formal parameter nodes procedure entry node formal node formal parameter procedure formal node formal parameter may modified procedure 
sdg associates call node set actual parameter nodes call site procedure actual node actual parameter call site actual node actual parameter may modified called procedure 
sdg connects pdgs call sites 
call edge connects call node entry node called procedure pdg 
parameter parameter edges represent parameter passing parameter edges connect actual formal nodes parameter edges connect formal actual nodes 
horwitz reps binkley compute interprocedural slices solving graph reachability problem sdg :10.1.1.50.4405
restrict computation interprocedural slicing paths correspond legal call return sequences sdg uses summary edges explicitly represent transitive flow dependence call sites caused data dependences control dependences 
summary edge connects actual node actual node value associated actual node may affect value associated actual node 
initial sdg slicing described sdg imperative language programs 
extended sdg represent object oriented programs 
extensions creates additional parameter nodes call site sends message object parameter node instance variable receiver message referenced modified method invoked response message 
shows partial sdg vending machine program constructed technique :10.1.1.50.4405
shows complete pdgs vend dispense partial pdg main simplify presentation omits pdgs methods 
represents call sites single node traditional sdg distinguish call return nodes 
call node contains actual parameter nodes shown cval selection shown sel passed parameters called method 
call node contains parameter nodes instance variables class referenced modified member method vend 
catch nodes control dependence edges control dependences nodes undefined 
sdg interprocedural slicing algorithm consists phases :10.1.1.50.4405
phase traverses backwards node sdg represents slicing criterion edges edges marks nodes reached 
second phase traverses backwards nodes marked phase edges call parameter edges marks reached nodes 
slice union marked nodes 
shaded nodes represent nodes included slice criterion lighter nodes included phase darker nodes included second phase slicing algorithm 
slice fails include statement transitive dependences slicing criterion semantically dependent statement 
slicing traditional sdg fails correctly identify dependences traditional sdg intraprocedural control dependences 
traditional sdg global variables treated parameters 
cval dispense sel cval sel cval control dependence flow dependence parameter call summary cval sel main cval sel cval vend cval cval vending machine partial sdg vending machine program 
shaded nodes included slice computed criterion 
exception handling constructs permit slice computation initiated catch node 
illustrates slice computation begins nodes terminates immediately nodes edges 
overcome inadequacies extend traditional sdg ways 
extended sdg represents effects control dependences caused accommodates exception handling constructs 
exceptional exit control dependence flow dependence parameter call return exceptional return summary cd summary exceptional exit exit sel cval cval cval cval cval dispense sel cval exit sel sel cval main cval vending machine vend ia sna exceptional exit exceptional exit partial extended sdg vending machine program 
shaded nodes included slice computed criterion 
extended sdg uses call return nodes represent entry exit nodes represent method reached 
extended sdg contains return edges similar call edges traditional sdg connect exit nodes called methods associated return nodes calling methods 
nodes associated represent differences control dependences call return sites nodes associated procedures called similar reason 
previous approaches require call entry nodes call edges assume called methods return call sites 
shows partial extended sdg vending machine program 
call site line represented call return nodes extended sdg 
call site call edge connects call node entry node vend return edge connects exit node vend corresponding return node 
second extended sdg actual parameter nodes associated call node parameter nodes return node similarly formal parameter nodes associated entry node formal nodes exit node 
assignments represented actual formal nodes occur control reaches corresponding return exit node associating actual nodes return exit nodes correctly represents dependences parameter nodes extended sdg 
previous approaches associate actual actual nodes call nodes formal formal nodes entry nodes 
example actual nodes call site line associated call node actual nodes associated return node 
third addition summary edges represent transitive data control dependences variables modified method extended sdg contains summary edges actual node return node edges represent transitive data control dependences influence return called method 
distinguish types summary edges call summary edges traditional sdg df summary edges affect data flow calling method cd summary edges affect control dependences calling method 
cd summary edges represent effects control dependence caused enable computation interprocedural slices minor changes interprocedural slicing algorithm 
example summary edge actual node node node cd summary edge indicates return control call site line depends value 
fourth accommodate exception handling constructs extended sdg treats catch node return node exceptional exit node exit node 
exceptional exit node connected catch node exceptional exit node exceptional return edge 
example exceptional exit node sna pdg dispense connected catch node 
represent interprocedural data dependences introduced exception object extended sdg associates formal parameter exception object exceptional exit node actual node catch parameter catch node interprocedural global handler 
pdg dispense exceptional exit nodes formal parameter exception object catch node actual node corresponding parameter catch handler 
parameter edge connects parameter nodes model data dependence caused exception object 
ensure interprocedural slices include nodes catch handler computed legal call return sequences extended sdg creates summary edges catch nodes df summary edges connect actual nodes call node actual nodes catch node cd summary edges connect actual nodes call node catch node 
catch node cd summary edges incident emanate actual nodes cval sel call node 
edges indicate values cval sel determine control flows catch node call 
df summary edges incident actual node node represent transitive control data dependences determine value summary edges slice computation includes nodes catch handler correctly clarity omit exceptional exit node pdg dispense 
omit catch node summary edges incident exceptional exit node ia pdg vend represented similar catch node represented 
accounts legal call return sequences 
example slice computation begins actual node node includes nodes slice phase reaching node computation avoids descending method vend cd summary edges incident node continues slicing actual nodes node 
second phase slice computation enters pdg dispense exceptional return edge incident node adds nodes pdg slice 
analysis library routines preceding discussions apply application programs exceptions raised explicitly 
application program raise exceptions implicitly calls library routines 
results analyses calls 
orthogonal issues need addressed analysis library routines 
issue concerns library calls considered additional analysis 
safe approach considers library calls analysis may inordinately expensive 
alternative approach exception types caught program analyzed 
approach considers additional analysis library calls enclosed catch handlers 
program may fact contain catch handlers handle exceptions raised library routines 
catch handler edges icfg reachable paths library routine raises exception 
determine occurrences catch handlers constructed icfg subject identified catch nodes edges icfg 
table shows catch handlers occur frequently subjects average catch handlers reachable icfg 
table catch handlers handle exceptions raised library routines 
catch nodes number edges icfg subject catch handlers total percent debug jar java cup javac javadoc jdk api aas java jlex swing api total second issue analysis library routines concerns exception types potentially raised library routine determined 
inspection library routine signature suffice determine potential checked exceptions routine raise 
inspection may reveal unchecked exceptions raised routine java method obligated declare signature unchecked exceptions raise 
cases execution profiles program obtained test cases identify library routines raise exceptions 
catch handler may represent dead code corresponding exceptions raised application library routines 
approach requires modifications java virtual machine success depends test cases 
final issue analysis library routines addresses information saved library routines determined potentially raise exceptions 
simplest level information simply record set exception types raised 
successively higher costs facilitate precise analysis information record parameters library routine determine exceptions raised constraints values parameters cause exceptions raised 
issues consider extend analyses incorporate library routines 
applications representations analyses representations previous sections different testing maintenance tasks 
section discusses briefly tasks structural testing regression test selection 
task discuss implications exception handling constructs task 
structural testing coverage structural testing techniques program structure guide development test cases 
example branch testing test cases developed considering inputs cause certain branches program test executed similarly path testing considers test cases execute certain paths program 
structural coverage techniques give measure structural elements program executed test suite 
example branch coverage measure test suite percentage branches program executed test cases test suite 
structural testing typically performed levels 
level testing specific goals appropriate coverage criteria directed attaining goals 
example unit testing tests individual module isolation 
integration testing hand tests interactions modules caused control data coupling 
testing requirements exception handling constructs stated informally terms coverage throw statements catch blocks 
example existing testing tools java programs provide catch block coverage requires execution catch blocks tool provides catch criterion 
informally stated criteria require exceptions raised re stated throw criterion 
criteria emphasize simple coverage throw statement catch block consider types exceptions raised throw statement types exceptions handled catch block 
example unit testing vend alternatives testing throw statement line execute statement single test case execute statement test case type exception raised statement execute statement tests subset exception types raised statement 
potential exception types explicitly represented cfgs testing methodology easily implemented representations 
similarly unit testing dispense select suitable see www sun com products index html information 
exit exit exceptional dispense exit exceptional vend exit exceptional exit exceptional exit exceptional zv exit exceptional exit exceptional exit exceptional exit zv ia sna sna portion icfg constructed determine interactions methods vend dispense integrating 
alternative testing catch blocks considering types exceptions handled blocks 
effectively test programs integration testing rigorous criteria test interactions throw catch statements required 
example integration methods vend dispense throw catch criteria require executions statements 
drawback testing data coupling vend dispense caused exception object adequately tested definitions exception object statements dispense catch statement vend criteria require definitions exercised 
testing criterion test integration vend dispense exclude coverage catch statement statement contribute interactions vend dispense 
interactions vend dispense analyzed constructing icfg program shows partial icfg illustrates interactions vend dispense 
performing analysis identifies exception propagation interactions modules caused exceptions effective adequate testing exception handling constructs attainable 
current includes development rigorous structured methodology testing constructs different levels 
regression test selection regression testing expensive testing procedure attempts validate modified software ensure new errors introduced previously tested code 
method reducing cost regression testing save test suites developed product reuse re validate product modified 
retest approach re runs test cases may consume excessive time exit exceptional exit exceptional exit exceptional ia sna exit vend zv exit exceptional exit exceptional exit exceptional dispense exit exceptional exit exceptional throw new try dispense selection bal bal int bal value selection transaction aborted catch catch catch enter selection throw zv exit sna public void vend int selection modified version vend new catch handler left partial icfg modified program connects vend dispense right 
resources 
regression test selection techniques contrast attempt reduce cost regression testing selecting subset test suite development subset test modified program 
rothermel harrold developed regression test selection technique uses program cfg 
technique creates cfg original program 
uses cfg insert probes program instrumented program executed test case reports edges executed 
instrumented version program executed test cases test suite technique creates test history associates edge test cases executed 
program modified technique creates cfg modified program 
technique walks cfgs original modified programs depth manner considering labeled edges cfgs finds text associated sink edge original program differs text associated sink edge modified program 
point technique selects test cases test history associated edge 
technique applied object oriented programs consider effects exception handling constructs test selection 
consider modification vending machine program modified version illegal selection causes transaction aborted immediately allow user re enter selection 
modification implemented adding new catch handler method vend catches exceptions type aborts transaction 
shows modified code vend portion icfg affected modification vend dotted box shows changed code 
addition new catch handler exceptional exit node dispense connected node node icfg original program 
assuming test suite exists original version vending machine program tests suite selected test modification traversed edge emanating exceptional exit node dispense original icfg 
selecting tests traverse edges edge exceptional exit causes test selection imprecise 
constructing interprocedural representation program precise test selection modification described possible 
current version technique described associates tests edges cfg technique consider tests associated interprocedural edges icfg 
technique needs adapted functions multiple entry multiple exit cfgs result presence exception handling constructs 
current includes extending technique investigating issues related regression test selection programs contain exception handling constructs 
techniques create intraprocedural interprocedural representations java programs contain exception handling constructs 
representations useful performing analyses constructing representations 
representations explicitly show exception types raised throw statements exception types propagated methods 
representations provide valuable aid understanding behavior exception handling code large software systems 
discussed impact exception handling constructs analysis techniques control dependence program slicing 
preliminary results gathered table indicate control dependences significant number statements affected presence exception handling constructs 
control dependences computed statements traditional techniques omit dependences include incorrect dependences 
incorrect control dependences affect computation slices 
experimentation control dependence computation program slicing reveal extent techniques affected exception handling constructs 
studies provide insights usage patterns exception handling constructs java programs ffl type inferencing determine exception types throw statements required majority throw statements 
throw statements subjects table exception object instantiated throw statement 
ffl cases throw statement mentions variable exception object rarely passed method parameter object caught catch handler method 
ffl exceptions frequently propagated methods raised 
ffl large percentage catch handlers appear programs handle exceptions raised library routines 
insights help guide development practical approach analyzing exception handling constructs improving techniques developed 
type inferencing approach performs local flow sensitive demand analysis determine exception types 
technique computed imprecise results third throw statements invoked 
impact imprecision cfg construction needs investigated 
outlined extensions improving precision type inference algorithm approaches analyzing library routines 
experimentation required diverse set experimental subjects considered far see results generalize 
discussed implications exception handling constructs structural testing regression test selection 
introducing new structural elements control flow paths programs presence exception handling constructs imposes additional requirements test data generation coverage identification test selection 
current includes investigation issues development rigorous disciplined testing methodology programs contain exception handling constructs 
acknowledgments supported part nsf nyi award ccr ess award ccr ohio state university 
jim jones led design implementation aas java empirical studies reported 
helped empirical studies useful suggestions improved presentation 
contributed development intraprocedural control flow analysis technique representation 
gerald baumgartner liang gregg rothermel helpful comments previous versions 
agrawal 
slicing programs jump statements 
proc 
acm sigplan conf 
prog 
lang 
design impl pages june 
aho sethi ullman 
compilers prin techniques tools 
addison wesley publishing reading ma 

issues testing object oriented software 
available www toa com pub net articles oo testing article txt 
bilardi pingali 
framework generalized control dependence 
proc 
sigplan conf 
prog 
lang 
design pages may 
chatterjee ryder landi 
complexity concrete type inference presence exceptions 
lecture notes computer science apr 
cytron ferrante rosen wegman zadeck 
efficiently computing static single assignment form control dependence graph 
acm trans 
prog 
lang 
sys october 
ferrante ottenstein warren 
program dependence graph optimization 
acm trans 
prog 
lang 
sys july 
frankl weyuker 
applicable family data flow testing criteria 
ieee trans 
softw 
eng oct 
gosling joy steele 
java language specification 
addison wesley reading ma 
harrold ning ci 
reuse driven interprocedural slicing 
proceedings international conference software engineering april 
harrold rothermel 
syntax directed construction program dependence graphs 
technical report osu tr ohio state university may 
harrold rothermel 
aristotle system research development program analysis tools 
technical report osu tr ohio state university march 
harrold rothermel sinha :10.1.1.114.5033
computation interprocedural control dependence 
proc 
acm int 
symp 
softw 
testing analysis pages march 
harrold soffa 
selecting data integration testing 
ieee softw pages mar 
horwitz reps binkley :10.1.1.50.4405
interprocedural slicing dependence graphs 
acm trans 
prog 
lang 
sys jan 
korel 
automated software test data generation 
ieee trans 
softw 
eng aug 
kung suchak gao hsia chen 
landi ryder 
safe approximate algorithm interprocedural pointer aliasing 
proc 
sigplan conf 
prog 
lang 
design pages june 
landi ryder zhang 
interprocedural modification side effect analysis pointer aliasing 
pages june 
larsen harrold 
slicing object oriented software 
proc 
th int conf 
softw 
eng pages mar 
laski korel 
data flow oriented program testing strategy 
ieee trans 
softw 
eng may 
liang harrold 
slicing objects system dependence graphs 
proc 
int conf 
softw 
maint pages nov 
reps interprocedural path profiling 
proceedings th international conference compiler construction march 
ntafos 
comparison structural testing strategies 
ieee transaction software engineering june 
ottenstein ottenstein 
program dependence graph software development environment 
proc 
acm sigsoft sigplan softw 
eng 
symp 
practical softw 
dev 
env pages mar 
palsberg schwartzbach 
object oriented type inference 
proc 
object oriented prog 
sys lang 
appl pages october 
plevyak chien 
precise concrete type inference object oriented languages 
proc 
objectoriented prog 
sys lang 
appl pages october 
podgurski clarke 
formal model program dependences implications software testing debugging maintenance 
ieee transactions software engineering september 
rothermel harrold 
selecting regression tests object oriented software 
proceedings conference software maintenance pages september 
rothermel harrold 
safe efficient regression test selection technique 
acm trans 
softw 
eng meth apr 
rothermel harrold regression test selection software 
technical report technical report oregon state university 
schaefer bundy 
static analysis exception handling ada 
software practice experience oct 
sinha harrold 
static analysis programs exception handling constructs 
technical report osu tr ohio state university 
weiser 
program slicing 
ieee trans 
softw 
eng july 

