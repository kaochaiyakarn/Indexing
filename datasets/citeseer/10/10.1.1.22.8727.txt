journal vlsi signal processing kluwer academic publishers boston 
manufactured netherlands 
methodology architecture exploration heterogeneous signal processing systems paul tudelft nl delft university technology dept information technology systems cd delft netherlands pieter van der wolf philips research laboratories eindhoven netherlands ed leiden institute advanced computer science leiden netherlands kees vissers technologies sunnyvale ca received february revised june 
methodology exploration signal processing architectures system level 
methodology named spade provides means quickly build models architectures level easily map applications modeled kahn process networks architecture models analyze performance resulting system simulation 
methodology distinguishes applications architectures uses trace driven simulation technique simulation application models architecture models 
consequence architecture models need functionally complete performance analysis data dependent behavior handled correctly 
methodology exploration architectures mappings mpeg video decoder application 
keywords system level design design space exploration signal processing performance analysis 
problem definition modern signal processing systems increasingly multi functional systems support multiple standards 
example digital televisions set top boxes mobile devices offer variety functions support different standards transmission coding digital contents 
calls programmability 
performance requirements constraints cost power consumption require significant parts systems implemented dedicated hardware blocks 
consequence systems heterogeneous architecture consist programmable dedicated components 
needed design technology helps designers define heterogeneous architectures starting set target appli cations 
classical approach departs single application iteratively pushes transformational process dedicated implementation architecture suited design programmable systems 
methodology named spade system level performance analysis design space exploration architecture exploration heterogeneous signal processing systems 
exploration starts executable specifications set representative target applications 
result definition architecture capable executing applications predefined constraints respect cost real time response order support efficient architecture exploration design start executable models 
illustrated 
cost model construction model evaluation higher detailed levels abstraction flexibility explore alternative architectures significantly reduced levels 
spade methodology permits architecture exploration start level executable models efficiently evaluate architectures selected set applications 
key feature spade methodology allows architectures evaluated different applications easily repeated different architectures 
provides detailed design trajectories 
section discuss related 
section presents number basic principles underlying spade methodology 
methodology discussed detail section 
section presents case study performed spade 
section 
related field application modeling lot research done models computation 
known models synchronous dataflow sdf dataflow process networks kahn process networks studied thoroughly :10.1.1.21.2539
ptolemy project research efforts brought united constitute basis ptolemy framework 
ptolemy mainly focuses application modeling simulation high opportunities abstraction explore explore back envelope executable models cycle accurate models 
vhdl low low high alternative realizations fig 

abstraction pyramid successive exploration increasing levels detail 
support explicit mapping application models models architectures 
various groups currently working architecture modeling performance analysis system level different approach 
environment applications described network codesign finite state machines 
model suited reactive systems suited signal processing applications 
element network mapped hardware part software part architecture consisting micro controller dedicated hardware 
performance mapping evaluated simulation software execution times particular micro estimated accumulating latencies risc instructions 
hardware software including real time kernel synthesized description 
targeted design embedded systems composed commercial shelf components ips typically microprocessors programmable logic blocks 
explicit mapping behavioral description target architecture 
communication components synthesized including device drivers standard communication protocols ethernet 
simulator tool pia allows communication system simulated different levels abstraction 
project dsp systems modeled completely vhdl different levels abstraction 
performance models model timing behavior functional behavior 
behavioral models capture functionality timing functionality completely incorporated architecture cost modeling evaluation model 
part project adept environment developed 
environment system constructed interconnecting collection predefined architecture modules 
separation application architecture architecture modules contain functional timing behavior 
approach quantitative analysis architectures uses architecture models 
result architecture models constructed easily evaluation performance done fast allows exploration large number design alternatives 
environment described limited specific class dataflow architectures 
designers build fully functional dedicated model specific system architecture 
platform systemc may alleviate task 
reusability models moderate 
contrast approaches spade distinguishes application models architecture models supports explicit mapping step 
architecture models need model functional behavior spade handles data dependent behavior correctly employing specific simulation technique 
consequence high reusability application models generic architecture building blocks obtained 
enables efficient exploration alternative architectures 
modeling techniques employed spade particularly suited signal processing systems 

basic principles 
chart claim design programmable systems clear distinction applications architectures explicit mapping step supported 
permits multiple target applications mapped candidate architectures evaluation performance 
line conclude development programmable architectures follow general scheme visualized shaped chart 
upper right part set applications drives design architecture 
typi methodology architecture exploration architecture mapping performance analysis performance numbers applications fig 

chart general scheme design programmable architectures 
cally designer studies set applications initial calculations proposes architecture 
effectiveness architecture evaluated comparison alternative architectures 
architectures evaluated quantitatively means performance analysis 
performance analysis application mapped architecture performance application architecture mapping combination evaluated 
resulting performance numbers may inspire architecture designer improve architecture 
may decide restructure application modify mapping application 
designer actions denoted light 

workload resources distinction applications architectures principle visualized 
application imposes workload resources provided architecture 
workload consists computation workload communication workload 
resources processing resources programmable cores dedicated hardware units communication resources bus structures memory resources rams fifo buffers 
architecture design process concerned specification resources best handle workloads imposed target applications 
spade applications architectures modeled separately 
application models functional models relatively free architectural aspects 
vice versa architecture models define architecture resources way applications benchmark set 
decoupling enables reuse application workload application mapping resources architecture fig 

application imposes workload resources architecture 
models architecture models facilitates explorative design process application models subsequently mapped architecture models 

trace driven simulation order evaluate performance application architecture mapping combination provide interfacing application models architecture models including specification mappings 
purpose extend technique called trace driven simulation 
simulation technique applied extensively memory system simulation field general purpose processor design 
technique performance analysis heterogeneous systems 
application model structured network concurrent communicating processes 
process produces execution called trace represents workload imposed architecture process 
trace contains information communication computation operations performed application process 
operations may coarse grain 
approach differs classical trace driven simulation traces contain information fine grain risc operations 
data dependent behavior application level captured traces trace data depends input data application 
traces get interfaced architecture model accepts workload executed see 
traces drive computation communication activities architecture 
activities executed specified architecture model 
execution time gets assigned events occur architecture model performance execution application architecture measured 
application model trace trace trace architecture model fig 

trace driven simulation execution architecture model driven traces execution application model 

methodology 
application modeling objectives application modeling expose parallelism making communication explicit 
chosen kahn process networks model computation application modeling 
kahn model parallel processes communicate unbounded fifo channels 
process executes sequentially 
reading channels blocking writing channels non blocking 
kahn model timeless ordering data channel 
chosen kahn model reasons 
execution kahn process network deterministic meaning input data set output data set traces produced 
model fits nicely signal processing applications model stream processing guarantees data lost 
model allows application programmer easily combine communication primitives including blocking reads control constructs loops statements 
compared models computation require applications built atomically firing actors return control firing pure dataflow models kahn model easier partition application set parallel communicating processes initially described sequential program :10.1.1.21.2539
applications available sequential programs important advantage 
shows example application modeled kahn process network 
spade offers ap plication programmers interface api application modeling contains functions 
read function 
function read data channel process port 
furthermore function generates trace entry trace process invoked reporting execution read operation application level 
write function 
function write data channel process port 
generates trace entry reporting execution write operation 
execute function 
function performs data processing generates trace entry reporting processing activities application level 
execute function takes symbolic instruction argument order distinguish different processing activities 
example instruction may correspond idct operation matrix 
api functions illustrated code fragment 
trace entries generated read write functions represent communication workload process 
trace entries generated execute trace process channel read write execute process port fig 

example application model 
processes depicted circles small circles process ports circle segments processes api functions 
read input token process token token execute process token write output token fig 

code fragment application process illustrating api functions read write execute 
process token symbolic instruction 
methodology architecture exploration table 
result workload analysis computation workload 
process instruction frequency idct mb skipped mb intra mb communication workload 
channel tokens predict data predict mv function represent computation workload process 
trace entries drive architecture simulation executing application stand analyze computation communication workload application 
results workload analysis form tables exemplified table 
example relates mpeg decoder case described section 
computation workload table shows number times symbolic instruction called processes 
communication workload table shows number tokens communicated channel 
note results workload analysis dependent input data set application 

architecture modeling order efficiently explore different architectures required architecture models easily constructed 
spade functional behavior described application level 
behavior data dependent traces drive operation architecture depend input data 
architecture models need model functional behavior maintaining functional correctness 
architecture models constructed generic building blocks 
building blocks generic provide library blocks 
generic building blocks need model different types resources architecture processing resources communication resources memory resources 
defining architecture easy instantiating building blocks library interconnecting 
compared laborious writing fully functional architecture models save designer lot time enables exploration alternative architectures 
processing resources architecture model take traces generated application input 
taken modular approach allow construction great variety processing resources small number basic building blocks 
processing resource built types blocks 
trace driven execution unit interprets trace entries 
entries interpreted order put trace retaining order execution application process 
configurable number ports 
communication ports generic protocol 
number interfaces connect ports specific communication resource 
interface translates generic protocol communication resource specific protocol may include buffers model input output buffering processing resources 
currently interfaces communication direct link shared bus shared memory buffered unbuffered 
apart interface blocks current library contains generic bus block including serve arbiter generic memory block 
blocks parameterized 
instantiated list symbolic instructions latencies 
list specifies instructions traces executed processing resource cycles instruction takes executed processing resource 
latencies obtained lower level model processing resource estimation tools estimated experienced designer 
instances interface blocks buffer sizes 
bus instance bus width setup delay transfer delay specified 
shows example architecture consisting processing resources composed different interfaces bus 
textual description model 
recall generic building blocks performance models model timing synchronization architecture 
application model captures functional behavior 
addition generic building blocks spade permits user defined blocks definition architecture models 

mapping application model architecture model defined mapping performed 
means workload application assigned resources architecture follows 
process mapped 
mapping case trace entries processes need scheduled 
scheduling policy selected specified user 
process port mapped port 
mapping implicitly maps channels combination communication resources memory resources possibly including user defined blocks specific bus model memory interface 
typically resources equivalent element application model 
trace processor port fifo bus exec 
unit fig 

example architecture model 
processing resources dashed boxes composed trace drive execution unit interface fifo bus 
example mapping shown 
shows textual mapping description example 
appears functionality single process needs distributed processing resource designer rewrite application process partitioned processes 
processes mapped separate 
processor processor instructions idct dct add mult processor processor instructions idct dct add sub fifo fifo number size bus bus width setup transfer structure fifo fifo processor processor bus processor number size processor number size fig 

description architecture model 
processor left processor processor right 
fifo fifo bus interfaces process processor number buffer places certain size 
width bus delay parameters specified 
methodology architecture exploration 
simulation simulation performed concurrently simulating application model architecture model single memory space 
traces generated fly application drive architecture simulation 
storage large amounts trace information avoided 
simulation application model pamela multi threading environment kahn process executed separate thread 
simulation architecture model currently tss tool system simulation philips house architecture modeling simulation framework 
library generic blocks implemented library tss modules 
spade permits user defined blocks implemented tss modules 

performance metrics generic building blocks contain collectors different performance metrics 
metrics data collected simulation resource specific 
metrics processor utilization number read write stall trace channel ab channel cb application model architecture model fig 

example mapping 
mapping processes processing resources indicated traces dotted arrows indicate port mapping 
hdr status cmd prop slice prop pic prop seq bits mpeg video elementary stream prop mb prop seq mb prop pic prop pred prop mv prop pic prop seq predict prop seq predict prop pred predict mv predict prop pic mb cmd predict data predict ref mem id output data idct prop seq add prop seq prop seq store data prop seq idct prop mb mb add prop mb mb prop mb mb cmd mem id prop pic cmd fig 

mpeg video decoder application structured kahn process network 
fig 

measure missed deadlines function frame period period bus requests additional processor 
cycles ports 
generic bus model amount data sent bus utilization wait times bus collected 

case study mpeg decoder spade methodology exploration architecture mapping mpeg video decoder application 
exercise started code mpeg video decoder publicly available uc berkeley 
step partition sequential program parallel kahn process network api functions read write execute 
result shown 
running application stand mode collected statistics workload different mpeg sequences terms numbers operations performed number idct operations amounts data communicated number blocks transferred shown table 
output prop seq output cmd rdy mem id decoded frames architecture exploration started realistic architecture mpeg video decoding mpeg decoder architecture philips semiconductors 
chip heterogeneous system consisting dedicated mpeg decoder processor attached bus structure vliw cpu input processor video output processor dedicated processors 
constructed model architecture generic blocks library see 
additional blocks built order model architecture 
process processor process processor process processor channels channel ab channel cb schedulers processor default fig 

description mapping 
application process specified mapped processors processor processor processor resp 
mapping includes mapping ports port task process mapped porto application channel mapped 
default scheduler selected subsequently mapping defined 
simulations performed yielding wealth performance data operation architecture 
interpreting performance data understanding operation architecture enhanced bottlenecks identified 
spade integrated environment supports design space exploration automatically performing multiple simulations different points design space 
facility useful performing sensitivity analysis multi dimensional parameter space identify valid ranges latencies architecture components 
example studied ability architecture meet deadlines frame decoding relation frame rate additional bus load 
additional bus load generated extra processor periodically claims bus 
shows measure missed deadlines function frame period cycles mhz period bus requests additional processor 
flat part part deadlines met high bus load small period high frame rate deadlines missed 
vin cpu idct bit bus mvu pfu su vout main memory fig 

mpeg video decoder architecture model 
rectangular boxes rounded boxes interfaces 
methodology architecture exploration simulation speed mpeg decoder application mapped architecture model processing resources interface blocks bus memory cycles second minutes frame 

spade supports efficient exploration heterogeneous signal processing architectures satisfy workload demands multiple target applications 
applications structured starting available kahn api functions 
output task reusable application model provides statistics workload architecture handle 
chart spade distinguishes application models architecture models 
uses trace driven simulation technique simulation 
consequence architecture models need model functional behavior performance analysis handling data dependent behavior correctly 
broad class architectures modeled effectively efficiently generic architecture blocks library 
simulation speed currently cycles second relatively complex design enables exploration number alternative architectures mappings 
tss architecture simulator allows inclusion dedicated architecture blocks allows incremental detailing starting spade architecture models 
want goel uc berkeley david la hei ronald martijn rutten contributions spade 
notes 
note gajski proposed different chart illustrate dimensions ic design 

hsieh lavagno suzuki sangiovanni vincentelli 
hardware software design embedded systems approach 
kluwer academic publishers 

joseph buck ha edward lee david messerschmitt 
ptolemy framework simulating prototyping heterogeneous systems 
international journal computer simulation august 
special issue simulation software development 

pai chou ross ortega ken hines kurt gaetano borriello 
integrated ip design framework distributed embedded systems 
proc 
dac new orleans la june 

pai chou ross ortega gaetano borriello 
hardware software synthesis system 
proc 
isss 

gajski 
silicon compilers 
addison wesley 

rajesh gupta stan liao 
programming language digital system design 
ieee design test computers april june 

van den van der linden 
system simulation framework software environments designing complex products 
proc 
dac los angeles ca june 

hein kline 
virtual prototyping dsp systems 
proc 
dac anaheim california june 

ken hines gaetano borriello 
dynamic communication models embedded system simulation 
proc 
dac anaheim california june 

dale ching yu hung dan sriram 
top design cycle simulation mpeg decoder example 
proc 
great lakes symposium vlsi lafayette louisiana february 

gilles kahn 
semantics simple language parallel programming 
proc 
ifip congress 
north holland publishing 


design space exploration stream dataflow architectures methods tools 
phd thesis delft university technology 

vissers van der wolf 
approach quantitative analysis application specific dataflow architectures 
proc 
asap july 

robert moshe james barry johnson ramesh rao ghosh 
integrated design environment performance dependability analysis 
proc 
dac anaheim california june 


tss tool system simulation 
ist newsletter march 
philips internal publication 

edward lee david messerschmitt 
synchronous data flow 
proc 
ieee september 

edward lee thomas parks 
dataflow process networks 
proc 
ieee may 


single chip dtv media processor 
proc 
hot chips symposium high performance chips august 

richard uhlig trevor mudge 
trace driven memory simulation survey 
acm computing surveys june 

pieter van der wolf paul goel david la hei kees vissers 
mpeg decoder case study driver system level design methodology 
proc 
th international workshop hardware software codesign codes rome italy may 

van 
performance prediction parallel processing systems pamela methodology 
proc 
th acm int 
conference supercomputing pages tokyo july 
