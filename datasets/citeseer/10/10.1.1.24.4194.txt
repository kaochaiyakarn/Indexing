compiling sml java bytecode peter bertelsen master thesis january department information technology technical university denmark ii contents preface vii standard ml java bytecode moscow ml module system structure compiler intermediate lambda language design representation sml values simple types primitive operators simple types algebraic types boolean values tuples records unit ref cells functions exceptions polymorphic equality exception handling top level names exporting modules printing values summary sml jvm toolkit toolkit modules class representation abstractions generating class file code emission building constant pool label resolution auxiliary modules iii iv contents new back back modules structure new back lifting environments intermediate target code code generation lvar lfn lprim lcase lif arithmetic exceptions class file generation implemented optimizations run time support classes predefined constructors unit specialized initialization methods improved equality testing target class improvements closure specialization run time types lifting additional environments invoking manifest functions directly compiling specialized closures methods code generation boolean expressions control flow context continuation optimizations local optimizations testing generating correct bytecode util module exception wrapper class contents example benchmarks fibonacci benchmark heapsort benchmark benchmark discussion tail call optimization typed lambda code calling external functions representation sml strings improving closure specialization improving representation values code generation improvements suggestions improving sml jvm toolkit user guide assumptions jvm semantics example fibonacci numbers source program lambda code generated java class file run time support classes sml jvm toolkit source files source files new back test programs vi contents preface report concludes sc 
project department information technology technical university denmark dtu 
carried department mathematics physics royal veterinary agricultural university denmark period february january supervision associate professor peter sestoft 
professor christian gram associate professor hans dtu supervisors project 
report describes development implementation compiler standard ml sml moscow ml compiler written sergei peter sestoft 
compiler back moscow ml generating modified caml light bytecode replaced new back generating java bytecode 
new compiler supports batch compilation interactive top level provided 
new back moscow ml compiler implemented sml 
reader assumed familiar functional programming sml imperative class object oriented programming 
syntax java programming language assumed familiar set run time support classes implemented java small fragments java code examples describing design new back 
detailed knowledge java virtual machine jvm java bytecode semantics necessary understand design new back 
acquaintance high level bytecode languages probably help understanding details java bytecode generation intermediate lambda language moscow ml 
report organized follows ffl chapter provides brief sml java bytecode describes existing moscow ml compiler new compiler 
ffl chapter describes design translation sml java including design set run time support classes representation sml values java 
ffl chapter sml jvm toolkit 
toolkit consists set modules representing java bytecode sml generating java class files class declarations 
understanding internals sml jvm toolkit necessary understand implementation new compiler back 
readers familiar java bytecode instructions set particularly interested details generating java bytecode instructions class files may wish go directly chapter 
ffl chapter describes new back including general unoptimized translation intermediate lambda code java bytecode 
vii viii preface ffl chapter optimizations implemented produce faster smaller java bytecode programs 
ffl chapter describes compiler tested verify expected bytecode produced evaluate performance produced bytecode 
ffl chapter various ideas improving compiler discussed specific suggestions optimization generated bytecode listed 
ffl chapter concludes 
appendices provided ffl appendix presents brief guide download install new compiler 
ffl appendix lists assumptions java bytecode semantics underly implementation new back 
reason java virtual machine specification considered complete specification jvm details semantics java bytecode programs left unspecified treated ambiguously 
ffl appendix shows example compilation sml program 
intermediate lambda code generated front listed followed target java class file generated new compiler back 
ffl appendix list source files run time support classes sml jvm toolkit new compiler back sml programs testing new compiler 
peter bertelsen january chapter standard ml standard ml functional programming language featuring ffl higher order functions ffl strict evaluation ffl automatic garbage collection ffl static type checking automatic type inference ffl polymorphic types ffl support user defined algebraic types ffl advanced module system parameterized modules ffl imperative features looping mutable store ref cells arrays 
language semantics fully defined revised 
java bytecode java class object oriented programming language defined sun microsystems 
java program declares set java classes may compiled class files 
java class file contains field method declarations class plus bytecode instructions implemented method class 
java class file may loaded executed java virtual machine jvm 
invoked class file jvm automatically invokes main method class may turn invoke methods 
referenced classes loaded dynamically run time 
java bytecode instruction set includes instructions ffl manipulating values simple types int double ffl manipulating operand stack ffl accessing local variables class variables instance variables array components ffl creating class instances arrays ffl invoking class methods instance methods ffl branching conditional unconditional new compiler supports flat structures moscow ml 
chapter 
ffl checking object types run time ffl throwing exceptions 
jvm maintains frame stack frame corresponds method activation record comprising local operand stack local variable environment 
java jvm supports multi threading synchronization considered project 
moscow ml moscow ml compiler sml written sml 
developed jointly sergei russian academy science moscow peter sestoft 
compiler backend caml light system developed inria france compiler front owes great deal ml kit system developed diku copenhagen 
description relates moscow ml version new compiler 
moscow ml supports core language sml simple module system described section 
moscow ml provides support required modules forthcoming sml basis library 
moscow ml distribution includes batch compiler interactive top level 
batch compiler considered report 
compiles source programs modified caml light bytecode may executed modified version caml light runtime system provided distribution 
module system moscow ml module system supports subset sml module system functors nested structures supported 
moscow ml structure defined file sml 
case file sig expected contain signature structure compilation sig produces file ui containing compiled signature compilation sml produces file uo containing bytecode number uo files may linked form executable 
order support type safe separate compilation compiled signature file ui includes bit stamp signature structure plus stamps structures depends 
example compilation file sml containing declaration fun file sml containing declaration fun yield files ui uo ui uo 
ui contains compiled signature signature stamp plus copy signature stamp ui contains compiled signature signature stamp 
case file sig inferred signature structure written ui compilation sml 

moscow ml structure linked files ui uo loaded 
module ui files ui uo loaded verified copy signature stamp contained ui identical actual signature stamp defined ui 
structure compiler phases compiler ffl lexical analysis parsing ffl resolution infix operators ffl elaboration top level declarations type checking ffl resolution overloaded constants operators ffl translation intermediate lambda code ffl lifting lambda code renumbering variables lifting functions top level ffl generation target bytecode 
function compiler manages compilation structure 
takes argument list parsed top level declarations invokes functions compiler front top level declaration textual order produce intermediate lambda code 
resulting list lambda expressions passed code generator function back lifts lambda code generates target bytecode top level declaration backwards traversal lambda expression list 
generated bytecode written target file uo compilation proceeds top level declaration 
generating target bytecode backwards intermediate lambda code convenient implementing number local optimizations pattern continuation lambda expression 
example possible avoid jumps jumps remove unreachable code unconditional branch intermediate lambda language intermediate language produced moscow ml compiler front extended version untyped calculus 
lambda clauses represented values data type lambda declared lambda module compiler chapter 
datatype lambda lvar int lambda lambda list lfn lambda lambda list lambda lambda list lambda lprim primitive lambda list lcase lambda lambda list int lambda lambda list lambda lambda lambda lambda lif lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda ref int ref int lambda meaning kind lambda clause lvar represents variable 
lambda language uses de bruijn notation variable carries index name lvar refers variable bound th enclosing lambda abstraction lfn binding letrec binding 
represents atomic structured constant see page 
represents application curried function arguments function may saturated may provided arguments expects may saturated may provided fewer arguments expects 
example function argument returning function may applied argument 
argument remaining arguments function returned lfn represents lambda abstraction 
body variable number lvar implicitly bound parameter abstraction 
indices variables bound context shifted seen body abstraction 
body lvar refers innermost enclosing variable binding lvar refers second enclosing variable binding forth 
represents binding scope variables lvar gamma implicitly bound corresponding right hand side expression gammai indices variables bound context shifted similarly lfn 
represents letrec binding scope similar expression described right hand sides representing mutually recursive functions may refer 
sml semantics guarantees closure building expressions 

moscow ml lprim represents primitive operation arguments primitives described page 
lcase connection lcase es represents pattern matching value assumed simple type es list keys corresponding right hand sides default right hand side chosen value match keys es 
connection es represents pattern matching tag constructed value exception 
represents branch default section innermost enclosing lambda expression 
connection pattern matching generated match compiler 
represents sml exception handler covering expression handler expression expression evaluated case exception raised evaluation lif represents way branch conditional evaluates true evaluated evaluated 
represents sequential evaluation value discarded evaluating represents loop conditional body body evaluated repeatedly long evaluates true 
represents sml andalso expression evaluates true evaluated result false 
represents sml orelse expression evaluates false evaluated result true 
serves dummy lambda expression 
connection anonymous top level declarations val print translates lambda code lprim global ref ref represents shared lambda expression shared expressions generated match compiler connection certain forms complex pattern matching 
integer internally compiler back ensure shared expression processed step compilation 
represents assignment local variable 
optimization code local non escaping ref cells constants constants lambda clauses defined lambda clause exception handling 
lambda clause new compiler optimization local ref cells implemented 
chapter 
datatype list obj ref datatype int word char real string datatype int int tag number span int constructor name stamp clause represents atomic constant clause represents structured constant 
clause compilation special functions interactive top level 
considered report 
structured constant represents sml tuple constructor carries tag list constant arguments 
tag indicates constant represents tuple value constructor tag exception constructor 
primitives primitives lambda language represented values data type primitive declared module prim compiler 
moscow ml datatype primitive int int int int int string int praise unsigned operations int pclosure int int existing moscow ml compiler values data type prim primitive representation caml light bytecode instructions lprim lambda clause 
primitives caml light code generator 
meaning primitives global represents access global variable identifier declared top level 
pset global represents binding value top level identifier 
top level identifier source program exactly pset global primitive intermediate lambda code 
represents comparison values equality test 
represents tuple value constructor ref cell exception constructor 
similar lambda expression representing structured constant takes non constant arguments 
represents access component tuple value ref cell exception constructor 
represents assignment ref cell 
represents call external function function implemented run time system 
praise represents raising exception 
represents boolean negation 
chapter 
represents null constructor 
pclosure represents function lifted top level 
generated compiler back lifting 
primitives represent operations values sml type word primitives represent operations values sml type int 
exceptions different kinds exceptions lambda code moscow ml static dynamic exceptions 
static exceptions include predefined exceptions bind match plus exceptions declared top level program 
dynamic exceptions exceptions declared local scope inside expression 
compiler front generates lambda code declaration static exception lambda code generated exception declaration 
exception raised special constructor arguments name exception tag created 
example declaration local exception fun raise module translates lambda code pretty printed form prim top fn prim raise block top declaration dynamic exception translated lambda code creating pair strings comprising name exception name module 
dynamic exception raised translated static exception name general exception dynamic exception argument raised 
exception constructor reserved tag general exception dynamic exception pair argument created 
example expression exception slam raise slam unit module translates lambda code pretty printed form prim block slam prim raise prim general exception var exception arguments raised arguments exception appear arguments exception constructor created 
example declaration local exception zap int int fun raise zap module translates lambda code pretty printed form 
moscow ml prim top fn prim raise prim top zap var prim var expression exception string string raise hello world unit translates prim block top prim raise prim general exception var block hello world chapter 
chapter design chapter describes design general scheme translation sml programs java bytecode 
design intermediate lambda code produced frontend moscow ml compiler cf 
section serves basis implementation new back described chapter 
number optimizations translation scheme described chapter designed implemented described chapter 
optimizations improvements discussed chapter 
representation sml values original back moscow ml produces caml light bytecode 
sml strongly typed caml light bytecode untyped sml values represented quite efficiently type information required run time values simple types represented unboxed provided fit single machine word 
java bytecode somewhat different caml light bytecode especially typed 
java bytecode verified jvm executed 
example integer value pointer integer operations manipulate 
translation sml java bytecode sml values represented uniform way regardless sml types 
reason value may passed argument polymorphic functions may stored tuples data type constructors arrays solution boxed representation sml types wrapping sml value jvm object instance subclass class java lang object 
operation sml value simple type enclosed proper unwrap wrap operations 
simple types values simple sml types int word char real string may represented instances standard java classes integer double string java standard classes package java lang generally referred package qualifier 
example object implicitly means java lang object 
chapter 
design idea sml value type int wrapped integer object passed primitive operation performed integer addition values operands unwrapped addition performed unboxed integer values result wrapped fresh integer object 
similarly word char real values 
value sml type word char may represented bit integer value wrapped integer object 
jvm represents value type int bit signed complement word arithmetics may encoded jvm integer instructions interpreting result unsigned integer 
char operations may encoded jvm integer operations masking unused bits bit value 
straightforward represent values sml type char character objects 
unfortunately lambda code generated existing moscow ml front cases treats char values int values connection tests 
possible translate values type char character objects modifying lambda code carry extra type information 
value sml type real may represented jvm value type double wrapped double object 
double value represented bit ieee double precision floating point value internally jvm 
natural encoding sml values type string instances class string types represent immutable character sequences 
jvm string literals represented string objects comparison literals may implemented efficiently 
encoding sml strings string objects means certain basis library functions string implemented efficiently possible representation strings mutable character sequences copying necessary immutable character sequences 
alternatively sml string represented mutable array characters value jvm type char connection polymorphic equivalence cf 
section 
similarly representing sml string instance standard java class stringbuffer connection polymorphic equivalence new back sml string compiled instance class string 
values simple sml types bool unit represented sml constructors lambda code cf 
section 
primitive operators simple types general primitive operators simple sml types may translated corresponding java bytecode instructions 
example addition values type real may encoded directly jvm instruction necessary unwrapping wrapping double objects 
similarly conversion simple sml types 
semantics primitive sml integer operators differs corresponding jvm integer instructions 
specifically sml operators div integer object contains value jvm type int bit signed integer complement 
stringbuffer class represents mutable character 
unfortunately class implement method equals implies stringbuffer object inherits method equals class object 
method equals implemented subclass stringbuffer final class 

representation sml values raise overflow case result represented int value overflow ignored corresponding jvm instructions iadd isub idiv 
correct semantics sml integer operators may encoded corresponding jvm instructions bit signed long values ladd explicitly checking overflow 
integer operands converted values jvm type long operation performed proper long instruction 
checked overflow occurred result represented int value result wrapped fresh integer object sml exception overflow raised 
unfortunately encoding integer operations may inefficient 
furthermore sml int word division operators required raise exception div case division zero 
corresponding jvm instructions idiv fact throw jvm exception class case division zero mapped sml exception div run time 
possible solutions 
checking divisor prior division raising sml exception div divisor zero 

inserting jvm exception handler idiv instruction 
handler catch raise sml exception div cf 
section 
solution efficient jvm exception handler introduces run time overhead long exceptions thrown 
approach taken new back 
algebraic types constructors algebraic data type represented way distinguished run time 
possible representations 
pizza language data type class tag instance field constructor separate subclass data type class corresponding tag value instance field constructor argument 
constructor tag pattern matching constructor cases 

instances general class constructor instance tag instance array arguments class constructor int tag object args constructor int tag object args tag tag args args note class constructor span instance field 
constructor span compiler run time 
chapter 
design solution natural encoding sml constructors object oriented language 
requires intermediate lambda code moscow ml compiler augmented type information order distinguish constructors different data types 
example sml expression translated lambda code block block block block block structured constant pretty printed form 
argument block constructor tag span means tag span 
argument block list constructor arguments 
note information lambda code tell fact list integers 
data type declaration datatype expression translates exact lambda code shown integer list 
similarly lambda expression block may represent nil expression may represent sml value type false 
representing sml constructors constructor objects corresponding solution number advantages ffl lambda code existing moscow ml compiler carrying extra type information 
ffl efficient switching constructor tag possible 
ffl translation lambda code primitives java bytecode direct 
example lambda code extracting head list prim field var extracting tail list prim field var lambda expressions may compiled directly java bytecode fetching component number respectively args field constructor object 
ffl fewer classes generated sml program fewer class files loaded run time 
java bytecode generated new back sml constructors compiled constructor objects 

representation sml values boolean values mentioned section sml values type bool represented constructors lambda code 
means boolean values may represented constructor objects java bytecode false constructor null true constructor null boolean expressions tests boolean sub expressions may converted controlflow representation branching constructor tag 
tuples records unit lambda code moscow ml tuple represented block tag span 
possible solutions representation tuples java bytecode 
instances class constructor constructor tag immaterial lambda code 

arrays objects mean component access just array indexing 

constructors tag 
second solution efficient extra indirection connection component access avoided 
lambda code produced moscow ml front extended type information distinguish tuple component access constructor argument access 
example expression prim field var appears lambda code sml functions fun fun xr xr third solution elegant may implemented lambda code produced existing front class block object args class tuple extends block tuple object args args args class constructor extends block int tag constructor int tag object args tag tag args args chapter 
design sml tuples represented instances class tuple constructors represented instances class constructor 
approach taken new back 
note args instance field moved common superclass tuple constructor 
way arguments constructor tuple may accessed uniform way field declared block args 
direct translation tuple component access constructor argument access java bytecode possible 
sml record translated tuple moscow ml front 
similarly value unit translated empty tuple tuple components requires special attention 
ref cells lambda code moscow ml sml ref cell represented constructor block tag span 
represented constructor objects reserved tag value elegant solution representing instances separate subclass class block just described tuples previous section class ref extends block ref object arg object args args args java bytecode generated new back sml ref cells compiled ref objects 
note instance class ref tag carries argument may accessed args 
functions just values simple types constructors sml functions may passed arguments stored tuples data type constructors arrays sml function represented uniform way wrapped object 
possible solutions 
pizza homogeneous translation class closure source program closure class contains instance tag field instance field holding array free variables instance method apply 
closure building expression source program associated tag 
apply method switches instance tag switch entry tag implements closure corresponding tag 

generating class cf closure building expression source program 
class cf implements interface denoted callable method apply moscow ml number tag values reserved special purposes ref cells strings reals values weak pointers finalized objects 

representation sml values implementing body function cf class includes instance field holding free variables closure represents 

general closure class class closure int tag object free object apply object closure building expressions sml program represented instances subclass closure implementing apply method switch closure tag 
switch entry specific tag implement body closure corresponding tag 
approach simplest leads generation fewer classes solutions 
solution new back 
example sml functions fun fun may represented corresponding solution class extends closure int tag object free tag tag free free static object object apply object switch tag case return new integer integer intvalue case return new tuple null static new null new null java java bytecode target language examples sake simplicity clarity 
new back directly produces java bytecode form java class files 
chapter 
design static initializer class binds fresh instances static fields passing argument function simply matter passing object bound similarly invoked take place invocation method closure apply object bound note static fields class declared having type object closure 
lambda code produced existing moscow ml front contain information tell type top level name 
general type top level declarations 
translation polymorphic functions java bytecode straightforward provided values represented objects polymorphic function just takes argument type object returns object 
translation higher order functions java bytecode straightforward provided functions represented instances class closure 
example function declaration fun may represented switch entry method apply shown case return closure apply new integer closure tag function 
curried functions translated nested lfn clauses lambda code require special attention 
application curried function arguments represented sequence closure applications application arguments cf 
section 
exceptions java bytecode sml exceptions may represented instances class class exception extends block object tag exception object tag object args tag tag args args making class exception subclass class block convenient lambda code exception component access identical constructor component access cf 
section 
able throw instances class exception jvm exceptions exception subclass standard java class throwable 
java jvm class immediate superclass class exception immediate subclass block throwable time 
solution changing class block subclass throwable java jvm supports multiple inheritance interfaces special kind classes class multiple immediate superinterfaces 
class block changed interface declares instance field allowed interface 

representation sml values class block extends throwable object args undesirable effect turning subclasses block subclasses throwable 
instance subclass block constructor object thrown jvm exception 
provided instances class exception implementing sml exceptions problem 
static exceptions exception tag may represented named object static object zap new string zap corresponding declaration structure exception zap int int exception raised instance class exception created exception name tag 
example expression raise zap may represented java bytecode object args fn throw new exception zap args described section dynamic exception represented pair strings lambda code compiles directly java bytecode 
raising dynamic exception may implemented throwing instance class exception tag general exception proper arguments 
example sml expression exception string string raise hello world unit may represented java bytecode object args ref new ref new tuple args object args hello world args new tuple args throw new exception general exception args module name 
solution requires class general including static field exception run time java jvm field name include parentheses punctuation characters 
encoding characters hexadecimal ordinal value may exception 
chapter 
design class general static object exception new string general exception overflow new string general overflow div new string general div static fields overflow div class general may implementing corresponding predefined static sml exceptions cf 
section 
polymorphic equality traditionally polymorphic equality challenging features implementations functional languages 
implementation sml testing equality involves recursively traversing sub nodes constructed data arrays compared pointer equality 
java bytecode polymorphic equality may implemented method equals defined class object inherited classes 
values simple sml types corresponding standard java classes directly implement method equals equality values contained wrapper objects 
example new integer equals new integer holds int values similarly instances class double 
instances class string method equals returns true iff objects represent identical sequences characters 
order implement polymorphic equality tuples class tuple override method equals public boolean equals object args null int args length args equals tuple args return false return true method compares current tuple object argument assumed bound instance class tuple 
type system sml guarantees tuple compared tuple arity components corresponding sml types 
need verify argument arrays args args length 
note components tuples compared recursively 

exception handling similarly class constructor override method equals order implement polymorphic equality constructors public boolean equals object tag constructor tag args null int args length args equals constructor args return false return true return false assumed argument instance class constructor 
type system sml guarantees constructor compared constructor sml data type 
need verify argument arrays args args length constructor objects tag represent constructor data type arity 
polymorphic equality sml ref cells need handled explicitly provided represented instances class ref cf 
section 
equality ref objects implicitly implemented equals method inherited class object 
method returns true object iff refer object class block class ref override method equals comparing ref objects method equals corresponds pointer equality ref cells 
type system sml functions exceptions admit equality requires special attention respect polymorphic equality 
exception handling jvm exception mechanism may implement sml exceptions exception handling 
java bytecode method may declare set exception handlers covering specific sequence instructions method handling specific class exceptions 
clause lambda code may represented jvm exception handler catching exceptions class exception 
example expression fn 
handle overflow 
translates lambda code fn prim handle switch var general overflow prim raise var chapter 
design java bytecode body function may represented try return new integer catch exception tag general overflow return new integer throw unfortunately semantics jvm exceptions differs sml exceptions jvm exception thrown operand stack current method purged operands removed local stack 
means sml exception handler appearing value context translated directly jvm exception handler 
example expression div handle div 
hypothetically compiled java bytecode pushing integer stack evaluating division operation 
value removed operand stack division zero occurs jvm exception thrown 
exception handler pushes integer operand addition operation longer available 
possible solutions 
introducing bindings jvm stack operands local variables prior code covered exception handler appearing value context 

lifting body exception handler appearing value context separate method generating jvm exception handler covering instructions method 
way lifted handler body evaluated separate stack 
jvm exception thrown evaluation handler body local operand stack purged 
approach generally lead shorter java bytecode imply copying fewer local variables 
solution new back 
top level names exporting sml module name may declared times top level 
avoid ambiguity lambda code refers top level names unique identifiers comprising toplevel name stamp number declaration counting 
example valid top level sml declarations structure val fun val foo fun lambda code body function 
top level names exporting prim lambda code body prim top level name module referred unique identifier stamp lambda code 
implicitly means exported top level declaration name referenced 
corresponds sml semantics subsequent declarations name overrides earlier declarations name scope 
unique identifier foo lambda code may represented static field foo java bytecode 
cross module may implemented introducing set extra export bindings java bytecode 
exported identifier foo binding foo foo alternatively exported identifier foo module may translated static field foo 
way export bindings omitted 
approach taken new compiler back top level exception identifiers need exported different name 
compiler front translates exported exception module lambda code referencing internal identifier exception 
example structure contains declarations local exception exception second declaration stamp lambda code expression raise module translated lambda code prim raise block words exception exporting requires attention handled compiler front 
unfortunately compiler front properly distinguish top level identifiers top level variable identifiers 
example structure including sml declarations val slam val exception fun raise unit translating exported top level identifier foo foo name foo suffix 
lead potential name clash sml identifiers members target class respect tag free apply instance members class closure 
chapter 
design translated lambda code prim slam prim prim prim fn prim raise block note expression assigned body function refers 
order avoid name clash target program exception identifiers treated differently top level variable identifiers 
solution translating exception identifier static field xk 
solution implemented new back 
modules design described previous sections moscow ml structure may represented java class file 
words source file sml may compiled class file class implementing class compilation signature file sig compiled signature file ui may adopted directly unchanged moscow ml class subclass closure class cf 
section include static member declaration top level declarations source file sml 
furthermore class may contain empty method declaration public static void main string args fg program consisting modules invoked calling special method main main class target program 
normally done invoking jvm name main class argument 
jvm loads class file class recursively loads classes main class depends dynamically 
mechanism replace linking phase existing moscow ml compiler 
semantics sml modules requires execution program comprising modules order correspond evaluation order 
unfortunately order evaluation modules program preserved approach described 
modules program loaded evaluated order referenced starting main module 
presumably structured sml programs tend main module rely specified evaluation order modules problem 
note approach module implementation includes linking phase modules classes represented symbolic generated class files resolved load time run time depending jvm moscow ml compiled signature file ui generated explicit signature file sig 
explicit signature ui generated inferred signature sml 
compilation manager standard ml new jersey similar problems respect evaluation order modules 

modules implementation 
signature matching respect referenced modules take place compile time 
link time verification signature stamps implemented existing moscow ml compiler may mimicked introducing signature stamp generated class file 
signature stamp calculated signature module hashing contents signature practically unique 
static initializer generated class compare value signature stamp modules depends expected value calculated compile time 
example module depends module class declaration generated class extends closure final static long static throw new signature changed initialize compile time signature stamp way actual signature stamp module class file class load time checked expected stamp class loaded initialized 
case signature changed compiled signature stamp longer value expected static initializer class provided signature recompiled provided stamps really unique 
cyclic module dependencies permitted sml 
approach signature stamp verification ensure generated class files cyclic dependencies loaded initialized 
module refers module refers static initializer generated classes check signature stamp class 
note field initialized static initializer class similarly 
class loaded static initializer attempt loading value causing class loaded initialized 
static initializer class load value initialized default value seen signature stamp check fail expected signature stamp 
precise error message case cyclic module dependencies generated inserting test prior stamp check static initializer class vice jvm static field default value type initialized assigned value 
default value type long 
chapter 
design versa static initializer class throw new module depends printing values purpose debugging tostring method declared class object may print sml values user programs 
user may create wrapper class printing string representation returned method tostring specific value 
standard java classes integer double string override method tostring returning string representation contained value 
note sml values type word char signed integer values 
run time support classes representing sml constructors ref cells extended override method tostring 
example method may declared follows class tuple public string tostring string tuple args null args length args int args length args tostring return return string tuple string representations tuple components 
class constructor exception method tostring may declared similarly declaration class tuple include constructor exception tag 
method tostring class closure may simply declared public string tostring return closure tag class ref method tostring may declared similarly declaration class tuple may cause problems connection circular 
call method tostring ref object part cycle data lead infinite recursion eventually jvm frame stack overflow 
possible solutions 
summary 
introducing flag ref object boolean instance field avoid revisiting node graph 

maintaining table visited nodes graph 
cases method tostring class ref check current object visited 
record object visited append string representation current object including argument ref cell result 
cases state ref cells reset method tostring invoked user data 
solution implies traversing data resetting flag ref object 
solution means removing entries table 
generally efficient approach 
run time support class ref java bytecode generated new back problem circular ignored 
invoking method tostring data containing cycle cause infinite recursion frame stack overflow 
approach conversion sml values printable form may extended support printing general just debugging purposes 
example top level interactive loop exploit print result iteration 
require run time support classes extended carry information type contained value 
example constructor object carry name datatype name constructor represents 
summary values simple sml types int word char real string may represented instances standard java classes sml type java class contained value int integer bit signed integer word integer bit signed integer char integer bit signed integer real double bit ieee double precision floating point value string string immutable character sequence values sml types may represented instances classes sml type java class contained value ff theta fi theta tuple tuple components fl ff fi tuple record components sorted label unit tuple datatype constructor constructor tag arguments bool constructor constructor tag ref ref ff fi closure closure tag free variables exn exception exception tag arguments note sml functions fact represented instances subclasses closure 
chapter 
design hierarchy classes may representing sml values java lang object java lang integer java lang double java lang string java lang throwable block tuple constructor ref exception closure general class general holds static exception tags predefined sml exceptions 
structure source fun val translated lambda code moscow ml front prim fn prim var var prim app prim lambda code may compiled class file having structure class extends sml lang closure static object int tag object free tag tag free free object apply object switch tag case return new integer integer intvalue integer intvalue default throw new unmatched closure tag static new null sml lang closure apply new integer 
summary note top level names lambda code exported static fields 
chapter 
design chapter sml jvm toolkit chapter presents sml jvm toolkit set sml structures datatypes functions representing java bytecode class files 
generating java bytecode class files new compiler back described chapter 
sml jvm toolkit started product compiler project tailored generating java bytecode intermediate lambda code moscow ml 
ended separate library modules supporting representation generation entire set java class file bytecode constructs relevant connection compilation sml 
sml jvm toolkit perform complete bytecode verification generated classes 
words possible generate class files may accepted sun bytecode verifier 
toolkit modules modules sml jvm toolkit classdecl class declaration jvmtype jvm data types label labels branch targets localvar local variable indices bytecode bytecode instructions calculation maximum operand stack depth written peter sestoft constant pool representation conversion bytecode instructions binary representation classfile concrete class file structure source files sml jvm toolkit modules listed appendix class representation sml jvm toolkit java class interface represented collection field method declarations 
class interface declaration specifies set access flags direct superclass class object superclass classes set direct superinterfaces set attributes chapter 
sml jvm toolkit type classdecl fflags list access flags jclass class interface super jclass option direct superclass jclass list direct superinterfaces list field declarations list method declarations attrs attribute listg java interface declaration similar class declaration interface simply carries flag 
furthermore access flags specify class interface public final 
attribute number standard attributes specifying source file class may include non standard information arbitrary binary format 
permits flexible attributes classes interfaces fields methods 
general jvm recognize standard attributes defined java virtual machine specification silently ignore non standard attributes recognize 
field declared class interface field name type access flags attributes specified type fflags list access flags name string unqualified name ty field type attrs attribute listg field attributes field access flags specify field public private protected static final volatile transient 
field attributes may specify constant value field may provide non standard information field arbitrary format classes interfaces 
example field declaration corresponding java declaration static final int answer declared sml jvm toolkit val fflags name answer ty tint attrs cint int fromint similarly method declaration specifies method name signature access flags attributes type fflags list access flags name string unqualified name msig method signature attrs attribute listg method attributes method signature specifies list parameter types optional return type means method return value void 

abstractions method access flags specify method public private protected static final synchronized native 
method attributes may specify java bytecode method implemented class interface may specify set exceptions method declared throw 
method attributes may include non standard information method arbitrary format classes interfaces fields 
example empty method main corresponding java declaration public static void main string args fg declared sml jvm toolkit val main fflags name main msig string attrs code locals code hdls attrs note code attribute includes stack field specifying maximum operand stack depth method locals field specifying maximum number local variables method 
function maxdepth module written peter sestoft calculate maximum stack depth bytecodes method 
similarly function localvar count calculate maximum number local variables method 
class decl field decl method decl data types defined classdecl module sml jvm toolkit 
abstractions bytecodes method implementation represented list bytecode instructions type bytecode jvm instr corresponding view jvm instruction set 
example jvm instr data type includes pseudo instruction jlabel counterpart actual instruction set jvm 
sml jvm toolkit labels specifying target branching instructions specifying scope entry point exception handlers 
bytecode instruction sequence emitted labels converted addresses resulting binary code cf 
section 
jvm instr data type contains number amalgamated jvm instructions 
example instruction jiconst represents jvm instructions pushing constant int value operand stack 
bytecode sequence emitted appropriate jvm instruction chosen 
translation performed bytecode emitter chapter 
sml jvm toolkit instruction jvm instruction ldc ldc jaload aload aload wide aload astore astore wide astore ldc wide wide ldc ldc wide wide jgoto goto goto jiconst iconst ldc ldc wide iload iload wide iload istore istore wide istore jsr jsr ldc wide wide newarray ret wide ret areturn ireturn return bytecode emitter translates bytecode instructions compact corresponding jvm bytecode instructions 
introducing level abstraction instruction set jvm user sml jvm toolkit relieved worrying details jvm instruction set jvm instructions iconst ldc pushing integer constant operand stack 
user just inserts jiconst instruction int int argument bytecode emitter chooses compact corresponding jvm instructions value immediate integer argument 
bytecode instructions listed mapped directly corresponding jvm instructions 
example instruction jdup simply maps jvm instruction dup represented binary form opcode 
generating class file generation physical java class file class interface declaration implemented function classfile emit 
function takes arguments writer function initial constant pool class declaration 
class declaration processed steps 
class decl converted concrete class file record 
class file record output physical file writer function writing single byte output file 

code emission class file record represents class interface declaration binary format ffl bytecode instructions methods implemented class emitted binary form cf 
section ffl constants fields methods classes inserted constant pool cf 
section ffl labels resolved instruction addresses cf 
section ffl access flags class interface members converted binary representation 
reason generating class file steps constant pool resulting class file built file written 
constant pool goes binary class file size known completed constants inserted 
constant pool completed remaining parts class file output 
constant pool argument classfile emit basis constant pool resulting class file 
way data referenced non standard attributes class interface declaration included resulting class file 
attributes include part binary content constant pool indices referenced data 
case class interface uses standard attributes empty constant pool passed argument classfile emit 
code emission conversion bytecode binary representation jvm bytecode instructions implemented function emit 
function translates bytecode method byte vector holding binary representation corresponding jvm bytecode instructions 
translation involves mapping bytecode instructions actual jvm instructions cf 
section bytecode instruction choosing compact jvm instruction ffl instruction argument string literal inserted constant pool jvm instructions ldc ldc emitted resulting constant pool index argument 
constant pool index ldc ldc 
ffl jaload instruction index local variable accessed inclusive corresponding jvm load instruction implicit immediate operand emitted 
index inclusive corresponding jvm load instruction immediate operand emitted 
corresponding wide jvm load instruction emitted 
ffl instruction index local variable accessed inclusive corresponding jvm store instruction implicit immediate operand emitted 
index inclusive corresponding jvm store instruction immediate operand emitted 
corresponding wide jvm store instruction emitted 
chapter 
sml jvm toolkit ffl instruction argument corresponding jvm instruction implicit immediate operand emitted 
argument inserted constant pool jvm instruction ldc emitted resulting constant pool index argument 
ffl instruction argument corresponding jvm instruction implicit immediate operand emitted 
argument inserted constant pool jvm instructions ldc ldc emitted depending resulting constant pool index 
ffl jgoto instruction argument label resolved address instruction offset address gamma inclusive jvm instruction goto emitted 
jvm instruction goto emitted 
see section 
ffl jiconst instruction argument gamma inclusive corresponding jvm instruction implicit immediate operand emitted 
argument gamma inclusive jvm instruction emitted 
argument gamma inclusive jvm instruction emitted 
argument inserted constant pool jvm instructions ldc ldc emitted depending resulting constant pool index 
ffl instruction index local variable accessed inclusive increment argument inclusive jvm instruction emitted 
jvm instruction wide emitted 
ffl instruction index local variable loaded inclusive jvm instruction ret emitted 
jvm instruction wide ret emitted 
ffl instruction argument label resolved address offset gamma inclusive jvm instruction jsr emitted 
jvm instruction jsr emitted 
see section 
ffl instruction argument corresponding jvm instruction implicit immediate operand emitted 
argument inserted constant pool jvm instruction ldc emitted resulting constant pool index argument 
ffl instruction dimension array created jvm instruction emitted 
jvm instructions newarray emitted depending component type array component type simple type newarray 
ffl instruction jvm method return instruction corresponding return type method emitted binary representation emitted jvm instructions arguments collected byte array word array array 
array created maximum bytecode size different jvm method return instructions areturn ireturn return examples redundancy jvm instruction set 
typed instructions readily merged untyped return instruction jvm return value proper type return type method 

code emission method bytes 
bytecode instructions method translated vector jvm bytecodes extracted byte array corresponding part array 
vector jvm bytecodes output method code class declaration written class file bytecode generated methods class 
building constant pool module implements pool data type related operations 
implementation uses hash table achieve maximum sharing constant inserted pool checked identical value pool 
index entry returned value inserted constant pool fresh index new entry returned 
process translating sequence bytecode instructions byte vector bytecode emitter builds constant pool target class 
mentioned emission jiconst instruction may lead constant inserted constant pool 
case jvm instructions loading constant pool entry emitted index constant pool entry argument 
similarly symbolic classes fields methods inserted constant pool referencing instruction emitted index resulting constant pool entry emitted argument instruction 
label resolution bytecode emitter implements resolution bytecode labels addresses target jvm bytecode 
done hash table representing map label target status pending ref phs meaning list phs label encountered label resolved address resolved addr meaning label resolved address addr 
label encountered label resolved address target jvm branching instruction emitted address argument 
target jvm branching instruction emitted dummy argument placeholder placeholder added list pending label 
jlabel bytecode instruction encountered pending label address target jvm instruction 
label marked resolved label map 
target jvm bytecode emitted jlabel instruction 
bytecode emitter conservative strictly necessary respect instructions jgoto case branch target lies branch instruction compact jvm instructions goto goto jsr jsr chosen 
branch target lies branching instruction jvm instruction goto jsr 
bytecode emission implemented single pass bytecode sequence 
advanced multi pass algorithm possible choose compact jvm branching instruction 
chapter 
sml jvm toolkit auxiliary modules order support full range constants defined java class file format bit bit bit integer floating point constants number places sml jvm toolkit 
example shown field declaration example section integer argument cint constructor type int int 
moscow ml provides int structure bit signed integers word structure bit unsigned integers real structure bit floating point values 
set utility modules implemented int bit signed integers int bit signed integers real bit floating point values real bit floating point values word bit unsigned integers word bit unsigned integers word bit unsigned integers modules provide limited subset corresponding sml basis library modules primarily conversion usual integer real types int int word word real real 
additionally functions conversion byte vectors provided 
auxiliary modules bytecode emitter conversion class declarations concrete class file records implemented classfile emit 
source files auxiliary modules listed appendix source files sml jvm toolkit 
chapter new back chapter describes implementation new compiler back 
structure back outlined general unoptimized compilation intermediate lambda code java bytecode explained 
implemented optimizations described chapter 
back modules modules new compiler back utility functions generating bytecode coercion coercion different run time representations values freeenv free variable environment generation java class file intermediate target code generation java bytecode lambda code instantiate utility functions instantiation run time support classes jvmcode intermediate representation target code lift lifting lambda code localenv local variable environment runtype representation run time types run time support classes tag representation closure tags source files new compiler back listed appendix modules existing moscow ml compiler modified new compiler const added function comparing unique id values compiler significant changes function fixed bug function peek lambda changed arguments prim changed argument pclosure primitive pr lam printing lambda expressions directly output reporting uncaught exceptions changed function chapter 
new back modified source files compiler sml sml listed appendix source files new back 
modified function compiler described section 
type declaration datatype todo lifted compiled label label specialized label label introduced module lambda 
clause data type lambda lambda modified carry shared lam state mark integer lambda ref ref initially expressions marked todo 
process lifting lambda code clause marked lifted indicate sub expression lifted see section 
compiled mark code generator indicate code generated sub expression see section 
specialized mark connection closure specialization see section 
pclosure clause data type prim primitive modified carry closure tag additional closure information pair integers pclosure tag tag runtype values type tag tag int values closure tags appropriate 
extra closure information closure specialization see section 
function modified return list lambda expressions various writing directly target file 
compilation explicit signature generation ui file sig file adopted directly unchanged moscow ml compiler 
structure new back compilation module sml file java class file controlled function compiler 
function takes arguments name module optional signature specification list parsed top level declarations 
steps performed compile module ffl functions compiler front invoked compile top level declaration list lambda expressions 
results list lists lambda expressions lambda expressions appear reversed order compared original top level declarations module 
ffl function compiler invoked check signature module 
explicit signature corresponding sig file module matched signature encoding inferred signature module 
lifting written corresponding ui file 
signature matching produces export environment see section possibly empty list lambda expressions required exported values module 
lambda expressions added list lists lambda expressions produced front 
ffl function lift folded list lists lambda expressions see section 
result lifting list top level lambda expressions list pending closures 
lifted lambda expressions appear reversed order compared original top level declarations module 
pending closure represents lifted function 
ffl function invoked generate java bytecode top level lambda expressions 
ffl function invoked generate java bytecode pending closures 
ffl function invoked generate java class file intermediate representation target code see section 
functions serve entry points code generator invoke function compile lambda code java bytecode 
folded list top level lambda expressions generate java bytecode top level expressions module 
code generated backwards implies generated instructions may simply added head list target instructions 
resulting bytecode goes method 
target class folded list lambda expressions pending closure 
resulting bytecode goes method apply target class cf 
section 
code generated backwards 
lifting original back moscow ml compiler intermediate lambda code new compiler lifted code generation proper 
new back lifting implemented function lift 
lifting done lambda expression recursively traversing sub expressions 
result lambda expression ffl de bruijn index lvar expression shifted relative innermost enclosing lambda abstraction lfn ffl lfn expression lifted top level replaced corresponding pclosure primitive ffl expression marked lifted ffl expression appearing value context eta expanded lifted body separate function 
method 
corresponds static initializer static java class 
class loaded jvm automatically invokes method initialize class 
chapter 
new back resulting lifted lambda expression represents top level fraction original lambda expression 
lifted expression lvar refers parameter enclosing lambda abstraction lvar lvar refer bound letrec bound variables lambda abstraction lvar refers free variable lambda abstraction 
lifting lambda abstraction lfn means replacing expression lprim pclosure fresh closure tag closure information function optimizations free variables function 
bodies lifted functions collected list pending closures 
list includes function closure tag number arguments free variable environment lifted lambda code function body 
marks todo lifted lifting expressions 
expression marked todo encountered expression marked lifted subexpression lifted recursively 
time expression encountered clause referencing sub expression shared lam state tag lifted clause remains unchanged 
lambda expression may appear value context described section 
order preserve value context expression lifted body new function replaced lambda expression lprim pclosure closure tag corresponding new function closure information function optimizations free variables original expression 
way exception raised sub expression covered expression affect value context original expression 
note new function applied empty list arguments environments number compile time environments new compiler back 
implement various optimizations described chapter 
general compilation described uses environments export environment export free variable environment free local variable environment local 
export environment maps exported top level identifier unique name exported 
environment built prior code generation connection signature matching 
expression lifted separate preserve value context function fact compiled separate jvm method 
method may invoked need take arguments free variables original expression 

intermediate target code free environment maps lvar index free variable location index vector free variables closure 
separate free variable environment compilation closure body 
environment built lifting phase connection lifting original lfn expression cf 
section 
local environment maps lvar index lambda variable corresponding jvm local variable index 
initially local environment empty 
environment updated code generation time value bound local variable connection expression 
generation bytecode top level lambda expressions local variable binding uses jvm local variable index 
bytecode generated lambda expressions closure body local variable binding argument closure uses jvm local variable index 
jvm local variable index holds closure 
intermediate target code code generation intermediate results gathered record type declared module jvmcode type jvm code fclass jvmtype jclass names string binarymap dict ref exns const set ref ref apply ref class component identifier target class 
names component maps top level name information name information optimizations described chapter 
domain map determining static field declarations target class include cf 
section 
exns component jvm code record holds set identifiers declared top level exceptions 
initializing exception tag fields target class cf 
section 
component jvm code record holds bytecode local variable environment exception handler declarations 
method 
apply component jvm code record holds bytecode local variable environment exception handler declarations closure body entries apply method cf 
section jvm code record holds information implementing various optimizations see chapter 
code generation generation java bytecode lambda code implemented function 
sections described lambda clause compiled java bytecode instruction set defined sml jvm chapter 
new back toolkit cf 
section 
compilation shown general direct translation optimizations 
number optimizations implemented described chapter 
generated java bytecode java class files expect run time support classes representation sml values located java package sml lang 
relaxed notation examples showing bytecode sequences generated code generator new back 
bytecodes listed sequences pseudo instructions akin instructions sml jvm toolkit 
lvar lambda expression lvar locally bound variable compiled jaload local bytecode instruction loads local variable number local local jvm local variable index maps current local environment cf 
section 
lambda expression lvar free variable compiled bytecode jaload jgetfield closure free jiconst free bytecode sequence performs steps 
loads value local variable stack 
assuming free variable occurs body closure local variable holds current closure object 

loads value instance field free closure object stack 
array free variables closure 
jgetfield instruction consumes object loaded previous step 

pushes index free requested free variable stack 

loads component number free array stack 
consumes array integer constant loaded previous steps 
net effect bytecode sequence pushing value free variable number stack 
clause represents atomic structured constant 
atomic constant compiled bytecode creating wrapper object constant 
example lambda expression compiled jnew integer jdup jiconst jinvokespecial integer init int 
code generation structured constant compiled bytecode creating instance class tuple constructor exception depending tag span constant 
constant constructor tag span tuple object created constructor tag span constructor object created constant exception tag exception object created 
example lambda expression corresponding sml expression compiled jnew constructor jdup jiconst jiconst object dim jdup jiconst jnew integer jdup jiconst jinvokespecial integer init int jdup jiconst jnew constructor jdup jiconst jinvokespecial constructor init int jinvokespecial constructor init int object bytecode sequence creates constructor instance invokes initialization method init int object initialize 
arguments initialization method tag value array holding actual arguments constructor object 
integer object holding value stored index array constructor object initialized tag value arguments stored index array 
lambda expression representing application function argument compiled special initialization method constructor init int initializing constructor object corresponding sml constructor arguments 
method takes argument constructor tag 
method initializing constructor arguments efficient invoking general initialization method init int object class constructor 
see section 
notation indicating instruction sequence evaluating value expression chapter 
new back jcheckcast closure jinvokevirtual closure apply object bytecode sequence applies value assumed closure value argument note jcheckcast instruction ensures run time value really closure object 
general necessary sun bytecode verifier accept generated code 
see section 
generally lambda expression compiled bytecode applying value assumed closure values arguments jcheckcast closure jinvokevirtual closure apply object jcheckcast closure jinvokevirtual closure apply object jcheckcast closure en jinvokevirtual closure apply object note application curried function arguments translated binary application scheme 
value applied value result application assumed closure applied value forth 
lfn code generator compile lfn lambda clause java bytecode 
lifting replaced lfn expression pclosure primitive cf 
section 
code generator encounters lfn expression exception indicating internal error raised 
lambda expression compiled local bytecode sequence stores value local variable number local unused variable index context expression evaluates generating bytecode current local variable environment augmented binding variable number necessary enabling value variable number general lambda expression compiled bytecode storing values local variables evaluating 
code generation local local en local gamma prior generation bytecode current local variable environment augmented bindings variable gamma unused variable index context expression 
lambda expression assumed pclosure primitive tag free variables compiled jnew jdup jiconst jinvokespecial init int jdup local jiconst object dim jdup jiconst jdup jiconst jdup jiconst gamma closure free bytecode sequence creates instance target class assumed subclass closure initializes tag free variables fresh closure object stored local variable number local unused variable index context expression 
array containing free variables closure created stored instance field free closure object 
evaluated 
special initialization method init int initializing intermediate closure object 
method takes argument closure tag 
method initializing closure object free variables efficient invoking general initialization method init int object 
chapter 
new back generating bytecode initializing free variables closure evaluating current local variable environment augmented binding variable number way closure referring free variables representing recursive function may created 
generally lambda expression binding mutually recursive functions compiled bytecode creating intermediate closure objects binding jvm local variables initializing free variables closures evaluating jnew jdup jiconst jinvokespecial init int local jnew jdup jiconst jinvokespecial init int local jnew jdup jiconst jinvokespecial init int jdup local gamma free vars array closure closure free jaload local free vars array closure closure free jaload local free vars array closure closure free sml semantics guarantees closure building expressions pclosure primitives 
assumed corresponding closure tags prior generation bytecode initializing free variables evaluating current local variable environment augmented bindings variable gamma unused variable context expression 
binding intermediate closure objects local variables initializing free variables closures necessary creating closures refer closures mutually recursive functions 
notation free vars array closure abbreviation bytecode sequence creates array holding free variables closure tag 
code generation lprim general lambda expression lprim compiled bytecode performing steps 
evaluating unwrapping arguments 
executing instructions corresponding primitive 
wrapping resulting value object 
global pset global lambda expression lprim global uid compiled bytecode loading value static field jgetstatic static field corresponding unique top level identifier uid 
uid exported top level identifier field identifier export uid uid maps export environment cf 
section 
names top level identifiers java class file format permit valid sml identifiers 
translation simple alphanumeric characters left unchanged non alphanumeric character replaced xx xx hexadecimal representation ordinal value character 
stamp sml identifier appended name additional character 
example sml top level foo bar stamp translated field name foo bar 
name scheme safe sense introduce name clashes 
lambda expression lprim pset global uid compiled bytecode storing value expression static field static field corresponding unique identifier uid 
uid exported top level identifier identifier export uid 
pset global primitive lambda code name static field accessed recorded order produce required field declarations target class cf 
section 
primitive compiled bytecode performing test pushing constructor value corresponding false true stack 
example lambda expression lprim pint test compiled chapter 
new back jcheckcast number jinvokevirtual number intvalue jcheckcast number jinvokevirtual number intvalue jif lbl jgetstatic constructor jgoto lbl jlabel lbl jgetstatic constructor zero jlabel lbl assumed evaluates number object note inverted test bytecode testing equality generated bytecode branches label lbl values differ 
values equal static field constructor representing true pushed stack constructor zero stacked labels lbl lbl fresh labels 
test appears conditional lif expression appears inside expression bytecode sequence may optimized see section 
similarly lambda expression lprim test compiled jcheckcast number jinvokevirtual number jcheckcast number jinvokevirtual number jifne lbl jgetstatic constructor jgoto lbl jlabel lbl jgetstatic constructor zero jlabel lbl significant difference instructions comparison values jvm type double standard java class number common superclass integer double classes 
class number declares instance methods intvalue extracting wrapped value int value double value respectively 
number intvalue may unwrapping integer value integer object converting double object integer 
number constructor instances arguments predefined class constructor see section 
instruction compares double values pushes integer value corresponding value equal greater second value 

code generation block primitives lambda expression lprim compiled bytecode loading th argument value assuming evaluates block object instance class tuple constructor ref exception jcheckcast block jgetfield block args jiconst mentioned section jcheckcast instruction necessary sun bytecode verifier accept code see section 
lambda expression lprim corresponding assignment ref cell sml compiled jcheckcast block jgetfield block args jiconst jgetstatic tuple unit bytecode sequence stores value th component value loads empty tuple assumed evaluates block object jcheckcast necessary suit sun bytecode verifier 
compilation primitive similar lambda clause representing structured constant 
difference arguments primitive lambda expressions constants 
lambda code produced compiler front polymorphic equality operations represented primitives 
new back lambda expression lprim sml equal compiled bytecode comparing values instance method object equals jinvokevirtual object equals object jifeq lbl jgetstatic constructor jgoto lbl jlabel lbl jgetstatic constructor zero jlabel lbl static field unit class tuple holds predefined empty tuple 
unit sml see section 
chapter 
new back assumed equals method returns corresponding logical values false true respectively 
result equals value constructor zero corresponding false pushed stack value constructor corresponding true stacked 
bytecode generated lambda expression lprim sml equal quite similar result object equals negated branching jinvokevirtual object equals object jiconst jifeq lbl jgetstatic constructor jgoto lbl jlabel lbl jgetstatic constructor zero jlabel lbl primitives external function calls implemented new compiler back 
lambda expression lprim compiled bytecode producing constructor value corresponding boolean negation value jcheckcast constructor jgetfield constructor tag jiconst jifeq lbl jgetstatic constructor jgoto lbl jlabel lbl jgetstatic constructor zero jlabel lbl assumed evaluates constructor object value tag 
tag value constructor zero pushed stack value constructor stacked 
boolean negation appears conditional lif expression appears inside expression bytecode sequence may optimized see section 
arithmetic primitives lambda expression lprim compiled 
code generation jnew integer jdup jcheckcast number jinvokevirtual number intvalue jinvokespecial integer init int assumed evaluates number object 
value unwrapped negated result wrapped fresh integer object 
similarly lambda expression lprim compiled jnew double jdup jcheckcast number jinvokevirtual number jcheckcast number jinvokevirtual number jinvokespecial double init double bytecode sequence values double values adds wraps sum fresh double object 
string vector array primitives lambda expression lprim compiled bytecode calculating length value assuming evaluates string object wrapping result integer object jnew integer jdup jcheckcast string jinvokevirtual string length jinvokespecial integer init int lambda expression lprim compiled jnew integer jdup jcheckcast string jcheckcast number jinvokevirtual number intvalue jinvokevirtual string jinvokespecial integer init int bytecode sequence loads character index value assuming evaluates string object evaluates integer object 
note chapter 
new back resulting character wrapped integer object 
moscow ml primitive implement certain library functions manipulating character sequences 
sml value type string represented immutable string object new back primitive implemented new compiler back 
compilation vector array primitives bytecode quite similar string primitives sml vector array represented jvm array objects pclosure pclosure primitive represents closure building lambda expression lfn lifted top level cf 
section 
lambda expression lprim pclosure closure primitive tag free variables compiled jnew jdup jiconst jinvokespecial init int quite similar creation intermediate closure objects shown 
lambda expression lprim pclosure compiled jnew jdup jiconst jiconst object dim jdup jiconst jdup jiconst jdup jiconst gamma en jinvokespecial init int object bytecode sequence allocates new instance target class assumed subclass closure initializes tag array holding free variables representation vectors changed correctly implement sml semantics equality vectors 
jvm array objects mistake polymorphic equality vectors corresponds pointer equality required semantics sml 

code generation primitives compilation number primitives bytecode implemented prototype compiler 
translation primitives similar translations shown ffl lprim compiled bytecode evaluating ffl lprim praise compiled bytecode throwing value jvm exception assuming evaluates exception object ffl lprim compiled bytecode pushing constructor tag arguments operand stack ffl lprim compiled bytecode evaluating swapping values operand stack 
primitives implemented new compiler back front compiler 
lcase abbreviation es switch list pairs comprising key related lambda expression 
lambda expression es compiled bytecode branching constructor tag value jcheckcast constructor jgetfield constructor tag lbl cases lbl lbl lbl jlabel lbl en jgoto lbl jlabel lbl jgoto lbl jlabel lbl jgoto lbl jlabel lbl jlabel lbl int values corresponding block tag keys lcase clause atomic constants branch keys compiled similarly clause value assumed integer object unwrapped executing instruction 
lcase clause atomic constants keys compiled series tests 
example expression lcase es keys es atomic constants compiled chapter 
new back jcheckcast number jinvokevirtual number jdup jifne lbl jpop jgoto lbl jlabel lbl jdup jifne lbl jpop jgoto lbl jlabel lbl jifne lbl en jgoto lbl jlabel lbl jlabel lbl real values corresponding keys note expression evaluated 
resulting value duplicated jdup successive tests instruction consumes topmost values operand stack pushes result 
order keep operand stack consistent duplicated value removed jpop corresponding jifne instruction 
lambda expression compiled jlabel lbl jlabel lbl jgoto lbl jlabel lbl local jlabel lbl bytecode sequence evaluates branches label lbl bypassing handler code additionally jvm exception exception handler covering instructions label lbl lbl installed label lbl entry point catching jvm exceptions class 
code generation exception 
case exception object thrown evaluation current operand stack purged exception pushed stack execution continues label lbl exception object stored local variable evaluated 
bytecode generated current local variable environment augmented binding variable number unused variable index context expression 
lif lambda expression lif compiled bytecode branching constructor tag value assuming evaluates constructor object jcheckcast constructor jgetfield constructor tag jifeq lbl jgoto lbl jlabel lbl jlabel lbl constructor tag corresponding sml value false evaluated evaluated 
lambda expression compiled bytecode evaluates discards resulting value evaluates jpop assumed evaluation leaves value expression stack pop 
lambda expression compiled bytecode tests constructor tag value assuming evaluates constructor object 
tag non zero evaluated value discarded bytecode evaluates expression testing constructor tag value chapter 
new back jgoto lbl jlabel lbl jpop jlabel lbl jcheckcast constructor jgetfield constructor tag jifne lbl jgetstatic tuple unit loop repeated evaluates constructor object tag value 
loop stops value unit pushed stack 
lambda expression compiled jdup jcheckcast constructor jgetfield constructor tag jifeq lbl jpop jlabel lbl bytecode sequence branches constructor tag value assuming evaluates constructor object 
tag corresponding sml value false value left stack value andalso expression evaluated 
note evaluated 
resulting value duplicated test tag jifeq instruction consumes topmost stack operand 
order keep operand stack consistent necessary remove duplicated value jifeq instruction 
expression appears conditional lif expression appears inside expression bytecode sequence may optimized see section 
compilation lambda expression bytecode dual expression 
bytecode generated expression branches constructor tag value tag evaluated value left stack value expression 
lambda expression expected appear body expression ignored bytecode generated 

code generation time shared lambda expression encountered code generator status assumed lifted cf 
section 
lambda expression ref ref lifted compiled jlabel lbl bytecode sequence shared expression simply labelled label lbl clause marked compiled lbl 
lambda expression ref ref compiled lbl shared expression bytecode generated compiled unconditional branch jgoto lbl effectively re bytecode sequence shared expression 
lambda clause new compiler 
code generator encounters expression exception indicating internal error raised 
arithmetic exceptions order properly implement sml semantics integer operations check overflow division zero described section 
compiler flags declared module new compiler backend 
compiler flag true bytecode generated primitives explicitly check overflow 
example lambda expression lprim compiled chapter 
new back jnew long jdup jcheckcast number jinvokevirtual number jcheckcast number jinvokevirtual number jdup int lbl jdup int maxint lbl jlabel lbl jpop jnew exception jdup jgetfield general overflow jinvokespecial exception init object jlabel lbl jinvokespecial long init long provided true 
bytecode sequence operands values jvm type long adds proper long instruction examines sum checking represented value type int 
sum minimum int value larger maximum int value exception object tag overflow thrown 
sum wrapped instance standard java class long subclass number 
note sum duplicated instruction bytecode sequence 
necessary instruction consumes topmost stack operands 
compiler flag true extra jvm exception handler generated primitives 
exception handler maps thrown case division zero sml exception div 
example lambda expression lprim compiled 
class file generation jnew integer jdup jcheckcast number jinvokevirtual number intvalue jcheckcast number jinvokevirtual number intvalue jlabel lbl jlabel lbl jgoto lbl jlabel lbl jpop jnew exception jdup jgetfield general div jinvokespecial exception init object jlabel lbl jinvokespecial integer init int provided true 
jvm exception handler covering instruction catching exceptions class having label lbl entry point declared target method 
class file generation code generation complete compiler builds class declaration intermediate jvm code representation target bytecode generates class file sml jvm toolkit cf 
section 
construction class declaration intermediate target code implemented function 
function performs steps ffl generates empty method main ffl completes bytecode method ffl completes bytecode method apply ffl generates instance initialization method init int ffl generates instance initialization method init int object ffl calculates maximum operand stack depth maximum number local variables generated method ffl generates static field declarations corresponding top level names declared source module ffl builds class declaration class decl record holding field method declarations target class ffl emits class declaration java class file function classfile emit sml jvm toolkit 
main method contains bytecode instruction chapter 
new back purpose method enabling target class serve main class application cf 
section 
completing bytecode method 
means introducing instructions method initializing static field corresponding top level exception declared module 
necessary properly associate jvm value top level exception tag 
take place prior evaluation top level expressions 
assuming source module declares top level exceptions id id id resulting bytecode method 
id id id top level expr code 
id id id string representations unique exception identifiers field static fields declared exceptions top level expr code 
represents bytecode generated top level expressions module 
note string representations fully qualified stamped exception identifiers exception tag values 
necessary ensure exception tag values unique 
completing bytecode method apply means introducing switch closure tag branching bytecode closure bodies method 
resulting bytecode method apply 
class file generation jaload jcheckcast closure jgetfield closure tag lbl offset targets lbl lbl lbl gamma jlabel lbl jnew jdup unmatched closure tag jinvokespecial init string jlabel lbl gamma body closure gamma jlabel lbl body closure jlabel lbl body closure generated bytecode instance initialization method init int object jaload jdup jinvokespecial closure init closure tag bytecode sequence invokes superclass constructor uninitialized object stores integer argument instance field tag object 
method may initializing instances target class closure objects free variables 
generated bytecode instance initialization method init int object jaload jdup jinvokespecial closure init jdup closure tag closure free bytecode sequence invokes superclass constructor uninitialized object stores integer argument instance field tag stores array argument instance field free 
chapter 
new back chapter implemented optimizations chapter describes optimizations implemented new compiler back support classes representation sml values run time 
run time support classes implemented run time support classes undergone number minor changes improvements compared design chapter 
predefined constructors unit mentioned section number constructor instances arguments predefined constructor class 
specifically field declarations introduced public final static constructor zero new constructor new constructor new constructor new constructor new constructor new constructor new constructor new constructor new constructor new constructor null constructors created initialized bound static fields class constructor loaded initialized 
bytecode may generated loading value static fields creating initializing similar instances class constructor 
mentioned section similar predefined instance introduced class tuple choice predefine null constructors tag values arbitrary declared presumably smallest tag values starting 
chapter 
implemented optimizations public final static tuple unit new tuple null value static field tuple unit corresponds empty tuple 
unit sml 
specialized initialization methods special instance initialization method introduced class constructor public constructor int tag tag tag method may initializing null constructor constructor instance arguments 
similar instance initialization method introduced class exception public exception object tag tag tag method may initializing exception arguments static exception moscow ml sense 
improved equality testing implementation equality testing run time support classes optimized compared naive implementations method equals section 
example implementation method equals class tuple changed public boolean equals object object args tuple args null int length need check args length length assuming arity arity equals return false return true 
target class improvements note values instance fields args args bound local variables loop 
presumably loading value local variable faster loading value instance field 
similar improvements introduced implementation method equals class constructor 
target class improvements generation target classes improved number ways ffl generating special instance initializer method init int initializing instances free variables 
ffl generating instance initializer methods init int init int object method invoked 
flags jvm code intermediate target code determine instance initialization method necessary target class 
ffl making target class subclass object closure case instances closures created provided false 
way apply method omitted target class 
ffl flagging generated instance initialization methods acc private 
way methods target class may instantiate class 
methods classes may utilize instances target class public static fields class 
ffl flagging generated fields methods corresponding non exported top level names module acc private 
ffl optimizing closure tag switch method apply case entry 
generating instruction single entry jifeq instruction branching closure body generated 
closure specialization optimization described section important complex optimizations implemented new compiler back 
purpose calling manifest functions directly 
example program fun xr xr val val sum recursive call inside function compiled direct invocation java bytecode method representing bytecode performing steps ffl loading closure object free variable ffl verifying fact instance class closure ffl invoking instance method closure apply object implying dynamic dispatch 
chapter 
implemented optimizations similarly call function right hand side binding val compiled direct invocation method representing function provided curried arguments expects 
call function right hand side binding val sum need optimized direct call function provided curried arguments expects 
words saturated calls manifest functions optimized 
support direct calls manifest functions specialized versions relevant closures generated separate java bytecode methods information carried compiler back order recognize saturated call manifest function 
run time types data types declared module runtype new compiler back datatype runtype rtint tag tag rtobject general spec runtype list types free variables argtypes runtype list types arguments result type runtype data type representing run time type sml values compiletime 
words runtype value indicates representation run time 
rtobject clauses connection closure specialization 
meaning clauses rtobject represents boxed value unknown type example argument closure declared jvm type object 
represents closure object specialized 
represents closure object closure tag specialized closure generated 
specialization information spec value specifying run time types free variables arguments result type specialized closure 
runtype data type number environments related closure specialization explained section 
lifting lifting phase compiler back extended collect list pending methods 
pending method represents specialized closure arguments 
list pending methods includes closure tag free variable environment number curried arguments context depth lambda expressions pending methods 

closure specialization additional environments order recognize saturated call manifest function number extra environments introduced global environment global method environment method closure environment closure 
global environment maps top level function identifier run time type runtype 
top level function method environment maps corresponding closure tag unique identifier function 
compilation specialized closure java bytecode method see section 
global environment method environment built separate pass lifted lambda expressions module prior code generation 
implemented function compiler 
closure environment acts extension free variable environment general compilation 
closure environment maps closure tag free variable runtype environment closure environment maps free variable closure runtype 
closure environment built code generation runtype local variables passed free variables closure 
addition information gathered environments local variable environment local extended carry runtype function bound local variable 
invoking manifest functions directly compilation expression manifest function recognized different ways ffl direct application pclosure primitive empty list arguments 
application stems exception handler lifted separate function appeared value context 
ffl application variable runtype arguments number curried arguments expected specialized closure bound local variable 
runtype local variable retrieved local environment locally bound variable closure environment free variable 
ffl application top level identifier runtype arguments number curried arguments expected specialized closure bound top level identifier 
runtype top level identifier retrieved global environment 
case specialized closure invoked free variables array free variables original unspecialized closure passed argument specialized closure 
specialized closure invoked instruction 
chapter 
implemented optimizations compiling specialized closures methods generation java bytecode specialized closure bodies implemented function 
method invokes code generator similarly compilation top level lambda expression unspecialized closure bodies cf 
section 
generated bytecode specialized closure collected extra methods component jvm code intermediate target code representation 
methods component holds name argument types result type exporting flag generated bytecode local environment declared exception handlers specialized closures 
name specialized closure bound top level identifier method closure tag specialized closure 
name anonymous functions functions bound local variables clos closure tag specialized closure 
methods component jvm code record module compiler back generating separate java bytecode method specialized closures 
code generation optimizations adopted original compiler back moscow ml ffl re labels possible creating fresh ones avoiding sequences jlabel instructions 
ffl removing dead code instructions unconditional jump return instruction instruction considered unreachable jlabel instruction 
ffl avoiding jumps unconditional jumps 
jumping jgoto instruction target jgoto instruction jumped 
ffl avoiding unconditional jump instruction instruction generated 
boolean expressions control flow context general boolean expression compiled java bytecode pushing constructor representing false true shown section 
boolean expression appears control flow context conditional lif expression inside expression shorter efficient bytecode may generated 
general lambda expression lprim pint test corresponding boolean expression compiled 
code generation jcheckcast number jinvokevirtual number intvalue jcheckcast number jinvokevirtual number intvalue jif lbl jgetstatic constructor jgoto lbl jlabel lbl jgetstatic constructor zero jlabel lbl note inverted test bytecode control transferred label lbl case integer value greater equal value test appears control flow context possible generate compact efficient bytecode shown 
continuation jcheckcast constructor jgetfield constructor tag jifeq lbl bytecode generated integer test jcheckcast number jinvokevirtual number intvalue jcheckcast number jinvokevirtual number intvalue jif lbl bytecode dotted line code generated pint test primitive code line resulting continuation 
note continuation reduced label lbl branched lbl similarly continuation jcheckcast constructor jgetfield constructor tag jifne lbl bytecode generated integer test chapter 
implemented optimizations jcheckcast number jinvokevirtual number intvalue jcheckcast number jinvokevirtual number intvalue jif lbl note comparison operator corresponding test continuation reduced shown section unoptimized bytecode generated lambda expression lprim jcheckcast constructor jgetfield constructor tag jiconst jifeq lbl jgetstatic constructor jgoto lbl jlabel lbl jgetstatic constructor zero jlabel lbl continuation jcheckcast constructor jgetfield constructor tag jifne lbl bytecode generated boolean negation jcheckcast constructor jgetfield constructor tag jifeq lbl bytecode dotted line code generated primitive code line resulting continuation 
note integer instructions perform negation continuation reduced similarly continuation jcheckcast constructor jgetfield constructor tag jifeq lbl 
code generation bytecode generated boolean negation jcheckcast constructor jgetfield constructor tag jifne lbl general bytecode generated lambda expression shown section jdup jcheckcast constructor jgetfield constructor tag jifeq lbl jpop jlabel lbl continuation jcheckcast constructor jgetfield constructor tag jifeq lbl bytecode generated expression jcheckcast constructor jgetfield constructor tag jifeq lbl jcheckcast constructor jgetfield constructor tag jifeq lbl bytecode dotted line code generated expression code line resulting continuation 
note duplication value avoided continuation remains unchanged including unwrapping 
similarly continuation jcheckcast constructor jgetfield constructor tag jifne lbl bytecode generated lambda expression chapter 
implemented optimizations jcheckcast constructor jgetfield constructor tag jifeq lbl jcheckcast constructor jgetfield constructor tag jifne lbl jlabel lbl note continuation reduced optimization expression appearing control flow context dual optimization expression shown 
continuation optimizations addition optimization boolean expressions described previous section number optimizations continuation matching implemented new code generator ffl avoiding instruction sequence wrapping value simple type immediately followed corresponding unwrapping operation wrap unwrap code generated 
implemented function coercion coerce generating bytecode coercion runtype 
ffl avoiding instruction sequence creation object immediately followed jcheckcast instruction class newly created object superclasses jcheckcast instruction generated 
ffl avoiding instruction sequence jaload instruction loading closure object local variable followed jcheckcast instruction jcheckcast instruction generated 
ffl avoiding instruction sequence creation constant immediately followed jpop instruction code generated 
ffl avoiding instruction sequence value stored local variable loaded variable jaload value duplicated stored jaload instruction generated jdup presumably duplicating stack operand efficient loading local variable 
ffl avoiding instruction sequence value stored static field loaded static field 
code generation value duplicated stored jgetstatic instruction generated jdup presumably duplicating stack operand efficient loading static field 
ffl avoiding conversion control flow representation constructor representation boolean values possible 
fully optimized sub expression lambda expression due jdup instruction 
ffl avoiding jcheckcast exception inside exception handler argument exception object catch type generated exception handlers 
local optimizations local optimizations include ffl predefined values class constructor tuple creating null constructors empty tuple cf 
section 
example sml constants nil false compiled bytecode loading static field constructor zero occurences unit compiled bytecode loading static field tuple unit 
ffl special instance initialization method init int initializing instances class constructor exception arguments cf 
section 
similarly initialization instances target class closure objects free variables cf 
section 
ffl compiling lcase lambda expression entry conditional branch jif instruction single entry 
example situation arise compilation pattern match list case 

sml expression translates lambda code compiled bytecode sequence chapter 
implemented optimizations jcheckcast constructor jgetfield constructor tag jifne lbl jgoto lbl jlabel lbl jlabel lbl chapter testing implemented compiler tested verify produces expected java bytecode investigate performance generated bytecode 
chapter describes tests undertaken 
generating correct bytecode process debugging compiler set small test programs implemented 
programs verify specific lambda constructs compiled correctly 
example program tests compilation lambda clause sml val val util println val util println val util println util println similar programs test lambda clauses fact compiled correctly leading expected bytecode 
compilation supported lambda code primitives tested similarly 
source files test programs listed appendix util module note program refers util module 
simple utility class implemented java exports number static fields 
field util println holds closure wrapper instance run time support class closure representing standard java method system println 
closure applied argument invokes system println print argument 
words util class fake sml module providing number special features support printing values output 
necessary chapter 
testing purpose exploiting java output mechanism system println sml sml program refer directly standard java libraries 
source file util java listed appendix test programs 
exception wrapper class problems debugging compiler unexpected uncaught jvm exceptions thrown jvm due errors 
unfortunately sun jvm implementation report uncaught exceptions program jvm simply aborts indication error 
exception wrapper utility developed implemented java 
source file java listed appendix method main class performs steps ffl loads class specified command line argument ffl invokes main method class passing remaining command line arguments ffl catches exception thrown previous steps displays exception followed stack trace 
example exception wrapper utility execute test program java invoke jvm class turn load class invoke main method arguments 
case exception thrown loading initialization class execution main method exception displayed exception wrapper 
example purpose demonstrating new compiler sml program compiled fun fib fun fib fib fib fib val util print fib util println fib intermediate lambda code program target class file generated new compiler back listed appendix jvm initializes java class executing method 
class 

benchmarks lambda code listing includes lambda expressions generated compiler front lifting lifted lambda code lifting plus lifted closures specialized closures methods 
listing lambda code obtained enabling compiler flag compiler new compiler 
generated target class listed utility sun jdk 
listing shows number optimizations implemented new compiler back 
example ffl closure tag specialized method fib argument ffl closure tag specialized method clos arguments array free variables 
bytecode sequences show effect implemented code generator optimizations 
example expression source program compiled bytecode sequence method fib aload checkcast class java lang number 
invokevirtual method int intvalue 
iconst aload areturn general compilation shown chapter integer constant wrapped integer object unwrapped compared value implemented optimization avoid wrap unwrap sequences eliminated wrapping unwrapping integer constant 
instruction sequence demonstrates implemented optimization boolean expressions control flow context 
general compilation chapter test compiled bytecode pushing constructor instance representing false true corresponding result test 
optimized bytecode directly branches section expression source program 
benchmarks order evaluate performance bytecode generated compiler benchmark programs compiled executed 
benchmarks executed host zuse dina dk mhz sun ultrasparc machine mb memory running sunos 
fibonacci benchmark performance test fibonacci algorithm shown section 
program containing sml functions compiled new compiler existing moscow ml compiler version chapter 
testing local fun fib fib fib fun fib fun function quite similar fib function fibonacci program section function naive recursive variant function 
java program containing methods compiled javac compiler sun jdk private static int fib int int int return return fib public static int int switch case return case return default return fib public static int int switch case return case return default return methods fib correspond sml function shown method corresponds directly naive recursive sml function 
table shows results running programs 

benchmarks figures listed running times seconds measured unix shell command time total user system time averaged runs initial warm run jvm javac programs compiled executed modified caml light run time system distributed moscow ml 
programs compiled new compiler corresponding java programs executed jvm implementation sun jdk 
column shows takes jvm approximately seconds load initialize involved classes 
column shows naive recursive versions fibonacci algorithm take significant time execute 
column shows sml programs compiled new compiler run times slower programs compiled moscow ml 
words appears potential significant improvements performance bytecode generated new compiler back 
heapsort benchmark somewhat realistic benchmark program compiled new compiler existing moscow ml compiler datatype heap empty node heap heap fun int empty empty node empty empty node empty node empty node empty empty node node empty node empty node node andalso node andalso node andalso node chapter 
testing fun length xs fun xr xr xs fun xs fun xs empty xs xr val div val ys xr val zs ys zs raise div length xs xs fun del empty empty empty int heap del empty del empty del node node node del node del fun extract heap fun empty res res node res del res heap fun heapsort xs extract xs program implements heapsort algorithm sorting list integers 
algorithm builds balanced heap integer list biggest element located top heap 
sorted list integers built ffl extracting top element heap ffl restructuring heap biggest element remaining heap located top ffl repeating steps heap empty 
table shows results running heapsort program times list pseudo random integers 
figures listed running times seconds measured way fibonacci benchmark 
jvm fibonacci benchmark column shows takes jvm seconds load initialize involved classes 
results column similar fibonacci benchmark java bytecode generated new compiler back executes times slower caml light bytecode generated existing back moscow ml 

benchmarks necessary repeated executions heapsort algorithm achieve measurable running times caml light bytecode program generated moscow ml 
time possible increase number list elements memory requirements java bytecode program generated new compiler 
example attempt failed due insufficient memory required mb 
running times java bytecode program shown table measured maximum heap size mb 
comparison caml light bytecode program uses approximately kb memory 
benchmark lazy machine implemented sml peter sestoft 
program consists lines sml code evaluates terms input language rewriting 
program compiled moscow ml new compiler 
execution resulting bytecode programs sample input indicates java bytecode generated new compiler back times slower caml light bytecode generated existing back moscow ml 
chapter 
testing chapter discussion described previous chapter performance java bytecode generated new compiler back quite poor compared corresponding caml light bytecode generated existing moscow ml backend compared similar java programs compiled java bytecode 
extent performance problems may attributed sun jvm implementation benchmarks performed 
observations run time behaviour java bytecode programs indicate garbage collector sun jvm handle programs allocate intermediate objects heap 
studies class files generated new compiler back reveals potential optimizations 
sections describe important 
tail call optimization lack tail call optimization implemented compiler back presumably single important reason performance problems generated java bytecode compared caml light bytecode generated existing front moscow ml cf 
section 
currently tail calls implemented efficiently java bytecode jvm instruction set includes specific tail call instructions tail calls detected optimized existing implementations jvm 
tail call optimization may introduced jvm implementations specifically improve execution recursive methods 
significant speed java bytecode generated sml may achieved implementing directly tail recursive functions loops jumping 
solution directly tail recursive functions java bytecode method jump bytecode instruction method 
typed lambda code annotating intermediate lambda code type information possible introduce important optimizations new compiler back minimizing run time type checks boxing values simple type 
chapter 
discussion jvm enforces static typing discipline instructions enforcing runtime type checking generated situations satisfy sun bytecode verifier run time type checks necessary ensure type safety sml program 
little type information presently available code generator jcheckcast instructions generated strictly necessary suit sun bytecode verifier 
type information available code generator possible estimate precisely jcheckcast instruction may omitted having sun bytecode verifier accept generated bytecode 
presumably minimizing number jcheckcast instructions generated new compiler back marginal effect performance generated bytecode lead somewhat shorter bytecode programs 
boxing operations probably better candidate performance improvements 
introducing type information intermediate lambda code possible omit coercions number places 
example possible store unboxed values simple types local global variables pass method arguments specialized closures provided lambda code generated front annotated type information functions global variables possible infer necessary type information remaining lambda clauses primitives lambda code 
type information corresponding runtype information described section suffice jcheckcast instructions coercions 
calling external functions mechanism calling static java methods may implemented prim val feature moscow ml translated primitive intermediate lambda code 
example declaration string 
int java lang integer expression translated lambda code front lprim java lang integer lambda expression compiled directly invocation mentioned method method arguments represented boxed values run time 
representation sml strings representing sml values type string string objects represented instances class intelligent jvm ignore excessive jcheckcast instructions 

improving closure specialization public class public char chars public char chars chars chars public boolean equals object instance class holds mutable array characters chars 
idea object serves wrapper character array 
copying necessary build object manipulate contents extract enclosed character array efficient implementation various library functions manipulating character sequences possible 
time sml semantics guarantee string value manipulated user code library functions exploit special primitives manipulate build strings 
copying necessary connection tests involving string literals object compared directly string object 
string literals go constant pool target class represented string objects loaded run time 
improving closure specialization closure specialization implemented new compiler back may improved number ways ffl generating specialized subclasses closure free variables ffl generating subclass closure closure building expression exception specialized closure invoked ffl calling manifest functions modules directly ffl directly creating closure object corresponding actual number supplied arguments non saturated call curried function ffl storing free variables closure local variable closure bound case general version closure free vars loaded directly local variable static field specialized closure method invoked ffl re object free variable set cascaded closures making big way entries array need copied ffl minimizing number free variables passed function passing free variables avoiding functions invoked directly function 
improving representation values run time support classes representation sml values may improved chapter 
discussion ffl introducing instance initialization method init int object class constructor initializing constructor objects single argument ffl introducing instance initialization method init int object class exception initializing exceptions argument ffl specialized tuple constructor exception classes arguments code generation improvements java bytecode generated new compiler may improved ffl comparing pre allocated null constructors tests jif jif ffl integer compare zero instructions jifeq jifne possible ffl switch dense ffl eliminating common sub expressions jdup ffl placing code sml exception handler method seperate code body handler way spare unconditional branch handler body handler branch handler body raises exception returns method 
suggestions ffl generating instance initializer method init int object target class 
initializing closures free variable 
ffl optimizing local non escaping ref cells lambda clause moscow ml 
ffl changing compiler front avoid clause lcase expression necessary 
ffl including function arity compiled signature ui files facilitate implementation direct invocation functions modules 
improving sml jvm toolkit sml jvm toolkit cf 
chapter supports entire java class file format specified java virtual machine specification 
toolkit improved number ways ffl changing field declarations component classfile class decl data type map field name flags type attributes ffl changing method declarations component classfile class decl data type map method name signature flags attributes ffl enhancing label resolution algorithm compact branching instruction cf 
section ffl implementing function classfile scan read contents physical class file convert class declaration class decl 
improving sml jvm toolkit ffl implementing verification class declarations ensure generated class files comply rules java virtual machine specification check class files read disk observe rules ffl adding descriptions sml jvm toolkit signatures order take advantage module documentation feature moscow ml ffl modifying sml jvm toolkit sml basis library facilities improving portability sml implementations 
chapter 
discussion chapter compiler standard ml sml developed moscow ml compiler version 
existing back moscow ml compiler generating caml light bytecode replaced new back generating java bytecode 
new compiler supports core language sml simple module system flat structures moscow ml 
support basis library modules interactive top level provided 
optimizations implemented notably ffl direct calls manifest functions specialized closures ffl avoiding wrap unwrap sequences generated bytecode 
preparations type optimizations 
toolkit java bytecode java class declarations sml generating binary java class files developed implemented 
sml jvm toolkit provides view java virtual machine instruction set java class files 
toolkit proven useful implementation java bytecode generator new compiler back 
sml jvm toolkit may general library representing java bytecode class files tied new compiler 
extending toolkit read class file disk convert class declaration straightforward 
compiler tested verify expected bytecode generated implemented optimizations lead improved bytecode target class files 
benchmarks show java bytecode programs compiled new compiler execute times slower programs compiled moscow ml 
java bytecode generated new compiler back sample program calculating fibonacci numbers executes times slower similar program compiled java 
figures course disappointing 
important potential optimizations identified ffl optimization tail calls ffl avoiding unnecessary run time type checks ffl avoiding boxing possible 
chapter 
tail calls optimized new compiler frame stack space exhausted connection recursion recursion may lead space leaks heap 
general optimization tail calls requires support jvm 
unfortunately available existing jvm implementations 
presumably significant speed may achieved existing jvm implementations compiling directly tail recursive functions bytecode loops jumping calling 
minimizing run time type checks boxing requires type information currently available intermediate language compiler 
introducing type information lambda language inferring information intermediate program presumably lead significantly better performance generated bytecode 
appendix user guide source files new compiler available anonymous ftp ftp ftp dina dk pub staff peter bertelsen jvm zip archive containing source files compiler sml jvm toolkit source files run time support classes 
compiler tested linux solaris presumably may built platforms 
files may extracted archive info zip unzip utility 
create directory structure jvm bin compiler executables jvm classes sml lang compiled run time support classes jvm src classes run time support class source files jvm src compiler compiler source files jvm src sml jvm toolkit sml jvm toolkit source files jvm test test programs jvm test benchmark benchmark programs installing compiler requires ffl moscow ml compiling sml jvm toolkit new compiler 
moscow ml available anonymous ftp ftp ftp dina dk pub 
new compiler sml jvm toolkit compiled moscow ml version 
ffl gnu 
files new compiler tested gnu version 
ffl sun java runtime environment running target programs generated new compiler 
sun available java sun com 
run time support classes tested version sun jvm implementation 
install new compiler change directory jvm src subdirectory invoke 
compile sml jvm toolkit compiler 
edit script jvm bin suit installation equal absolute path subdirectory jvm bin equal absolute path lib subdirectory moscow ml installation 
appendix user guide order run time support classes known jvm include absolute path subdirectory jvm classes classpath environment setting 
assuming installation completed normally compiler may invoked sml program dir jvm bin sml dir path directory unpacked jvm zip archive 
create files ui class provided sml contains valid sml program 
program may executed invoking sun jvm generated class file java note new compiler support full sml module system flat structures supported moscow ml 
interactive top level batch compilation supported 
support sml basis library modules available new compiler 
order implement programs produce kind output user implement java wrapper classes invoking proper methods standard java classes 
example see file jvm test util java 
appendix assumptions jvm semantics java virtual machine specification intended complete specification jvm semantics 
unfortunately specification complete details constraints java class files contents semantics jvm instructions left unspecified treated ambiguously 
sml jvm toolkit perform complete verification classes cf 
chapter generated class files comply required structure java class files 
practice means generated class files accepted sun bytecode verifier order executed sun jvm implementation implemented compiler back generates java bytecode class files satisfying requirements 
java bytecode class file obey static typing discipline 
declared types fields method arguments method return values possible verify statically bytecode instruction applied arguments proper types 
case bytecode instruction requires operand specific type inferred static type information checkcast instruction ensure proper dynamic type check 

entry methods table class file need include code attribute method 
method flagged acc acc native bytecode implementation method included 

entry methods table class file need include exceptions attribute method 

class file contain field declarations identical names 

class file contain method declarations identical names signatures 

order entries exception table code method attribute significant 
exception thrown exception handlers method searched declared order 

uninitialized object operand stack local variable instructions executed negative branch offset argument java virtual machine specification sun jvm implementation implementation 
jvm implementations measured sun implementation considered de facto implementation 
appendix assumptions jvm semantics ffl ffl ffl ifeq ffl ifnull ffl ffl goto goto 
instruction may store uninitialized object array component 

operand stack manipulation instructions dup dup dup dup dup dup pop pop swap may uninitialized objects 

ireturn instruction return methods return type boolean byte char short int 

class object loaded stored getfield putfield instruction class declaring accessed instance field subclass thereof 

invokestatic instruction invoking method flagged acc private acc static 

invokespecial instruction refer init 
method instance method current class instance method superclass current class 

class object invokespecial invokevirtual instruction invoked class declaring invoked instance method subclass thereof 

instance initialization method java lang object init invoke instance initialization method uninitialized object local variable instance members object accessed 
invoked instance initialization method member current class immediate superclass 

special value null may stored field type may passed method argument corresponding formal parameter invoked method type 

areturn instruction may return special value null method return type type 

access permissions classes members correspond defined java language 

array bounds checked access array component 
valid indices gamma length array 

method return instruction executed current frame discarded 
frame frame stack current thread thread terminates 
frame remains frame stack control transferred top frame instruction counter set address instruction immediately method invocation instruction causing frame method return instruction created 

invokevirtual instruction executed object methods object searched implementation referenced method starting class object recursively immediate superclass 

method invocation instruction executed current frame may discarded provided ffl method invocation instruction immediately followed method return instruction corresponding return type current method ffl return type invoked method current method invoked method current method returns value ffl method invocation instruction covered exception handler ffl current method flagged acc synchronized 

exception thrown execution 
method class interface exception caught exception handler method current class interface considered uninitialized exception thrown method caused current class interface loaded initialized 
appendix assumptions jvm semantics appendix example fibonacci numbers source program fibonacci sml fun fib fun fib fib fib fib val util print fib util println fib lambda code lifting prim fibonacci fib fn letrec fn fn fn case var var prim var app var var prim var var var prim test lt var var app var prim var app prim util print fib app prim util println app prim fibonacci fib lifting prim fibonacci fib prim closure app prim util print fib app prim util println app prim fibonacci fib closure depth free letrec prim closure var prim test lt var var app var prim var closure depth free prim closure var var appendix example fibonacci numbers closure depth free prim closure var var var closure depth free case var var prim var app var var prim var var var method depth free args letrec prim closure var prim test lt var var app var prim var method depth free args case var var prim var app var var prim var var var generated java class file compiled fibonacci sml public synchronized class fibonacci extends sml lang closure bit set public static java lang object fib public static java lang object fib java lang object private static java lang object clos java lang object java lang object java lang object java lang object private fibonacci int private fibonacci int java lang object public java lang object apply java lang object public static void main java lang string static static fg method java lang object fib java lang object new class fibonacci 
dup iconst invokespecial method fibonacci int 
dup astore iconst class class java lang object 
dup iconst aload putfield field java lang object free 
aload checkcast class java lang number 
invokevirtual method int intvalue 
iconst aload areturn aload getfield field java lang object free 
new class java lang integer 
dup aload checkcast class java lang number 
invokevirtual method int intvalue 
iconst isub 
generated java class file invokespecial method java lang integer int 
new class java lang integer 
dup iconst invokespecial method java lang integer int 
new class java lang integer 
dup iconst invokespecial method java lang integer int 
invokestatic method java lang object clos java lang object java lang object java lang object java lang object 
areturn method java lang object clos java lang object java lang object java lang object java lang object aload checkcast class java lang number 
invokevirtual method int intvalue 
aload areturn new class java lang integer 
dup aload checkcast class java lang number 
invokevirtual method int intvalue 
iconst isub invokespecial method java lang integer int 
astore aload iconst checkcast class sml lang closure 
getfield field java lang object free 
aload new class java lang integer 
dup aload checkcast class java lang number 
invokevirtual method int intvalue 
aload checkcast class java lang number 
invokevirtual method int intvalue 
iadd invokespecial method java lang integer int 
aload invokestatic method java lang object clos java lang object java lang object java lang object java lang object 
areturn method fibonacci int aload dup invokespecial method sml lang closure 
iload putfield field int tag 
return method fibonacci int java lang object aload dup invokespecial method sml lang closure 
dup iload putfield field int tag 
appendix example fibonacci numbers aload putfield field java lang object free 
return method java lang object apply java lang object aload getfield field int tag 
default new class sml lang 
dup ldc string closure tag 
invokespecial method sml lang java lang string 
aload getfield field java lang object free 
iconst checkcast class java lang number 
invokevirtual method int intvalue 
aload getfield field java lang object free 
iconst areturn new class java lang integer 
dup aload getfield field java lang object free 
iconst checkcast class java lang number 
invokevirtual method int intvalue 
iconst isub invokespecial method java lang integer int 
astore aload getfield field java lang object free 
iconst checkcast class sml lang closure 
getfield field java lang object free 
aload new class java lang integer 
dup aload getfield field java lang object free 
iconst checkcast class java lang number 
invokevirtual method int intvalue 
aload checkcast class java lang number 
invokevirtual method int intvalue 
iadd invokespecial method java lang integer int 
aload getfield field java lang object free 
iconst 
generated java class file invokestatic method java lang object clos java lang object java lang object java lang object java lang object 
areturn new class fibonacci 
dup iconst iconst class class java lang object 
dup iconst aload getfield field java lang object free 
iconst dup iconst aload getfield field java lang object free 
iconst dup iconst aload invokespecial method fibonacci int java lang object 
areturn new class fibonacci 
dup iconst iconst class class java lang object 
dup iconst aload getfield field java lang object free 
iconst dup iconst aload invokespecial method fibonacci int java lang object 
areturn new class fibonacci 
dup iconst invokespecial method fibonacci int 
dup astore iconst class class java lang object 
dup iconst aload putfield field java lang object free 
aload checkcast class java lang number 
invokevirtual method int intvalue 
iconst aload areturn appendix example fibonacci numbers aload getfield field java lang object free 
new class java lang integer 
dup aload checkcast class java lang number 
invokevirtual method int intvalue 
iconst isub invokespecial method java lang integer int 
new class java lang integer 
dup iconst invokespecial method java lang integer int 
new class java lang integer 
dup iconst invokespecial method java lang integer int 
invokestatic method java lang object clos java lang object java lang object java lang object java lang object 
areturn method void main java lang string return method static fg new class fibonacci 
dup iconst invokespecial method fibonacci int 
field java lang object fib 
field java lang object print 
checkcast class sml lang closure 
ldc string fib 
invokevirtual method java lang object apply java lang object 
pop field java lang object println 
checkcast class sml lang closure 
new class java lang integer 
dup invokespecial method java lang integer int 
invokestatic method java lang object fib java lang object 
invokevirtual method java lang object apply java lang object 
return appendix run time support classes package sml lang public class block extends throwable public object args protected stringbuffer header int public string tostring int args null 
args length stringbuffer header append args int append args return append tostring package sml lang public class tuple extends block public final static tuple unit new tuple null public tuple object args args args public boolean equals object object args tuple args appendix run time support classes null int length need check args length length assuming arity arity equals return false return true public string tostring int args null 
args length stringbuffer new stringbuffer tuple append args int append args return append tostring public stringbuffer header int return new stringbuffer tuple package sml lang public class constructor extends block public final static constructor zero new constructor new constructor new constructor new constructor new constructor new constructor new constructor new constructor new constructor new constructor public int tag public constructor int tag tag tag public constructor int tag object args tag tag args args public boolean equals object constructor constructor tag tag return false object args null object args int length need check args length length assuming tag tag 
arity arity equals return false return true public stringbuffer header int stringbuffer new stringbuffer constructor tag return append package sml lang public class ref extends block public ref object arg object args args args note class ref override method block equals equality ref objects corresponds pointer equality required sml 
public stringbuffer header int return new stringbuffer ref appendix run time support classes package sml lang public class exception extends block public object tag public exception object tag tag tag public exception object tag object args tag tag args args appropriate override method equals order throw jvm exception case polymorphic equality invoked exception object 
happen exceptions admit equality sml 
java override method equals throw exception object equals declared throw exceptions 
public stringbuffer header int stringbuffer new stringbuffer exception tag return 
append package sml lang public class closure public int tag public object free public closure fg public object apply object throws throwable appropriate override method equals order throw jvm exception case polymorphic equality invoked closure object 
happen function types admit equality sml 
java override method equals throw exception object equals declared throw exceptions 
public string tostring return closure tag package sml lang public class general public final static object bind new string general bind chr new string general chr div new string general div domain new string general domain match new string general match ord new string general ord overflow new string general overflow fail new string general fail exception new string general exception appendix run time support classes appendix sml jvm toolkit source files classdecl sml peter bertelsen september local open label bytecode jvmtype datatype field method class interface field method field method field method field method class field field method method method class interface class interface interface type exception handler declaration label start handler scope label handler scope entry label handler entry point catch jclass class handled exception datatype attribute string source file name constant value code int max operand stack depth locals int max size local vars code list instruction sequence hdls list exception handlers attrs attribute listg exns jclass list exception classes label line intg list localvar ffrom label label name string ty index localvar list appendix sml jvm toolkit source files attr fattr string info word vector type field declaration fflags list access flags name string unqualified name ty field type attrs attribute listg field attributes type method declaration fflags list access flags name string unqualified name msig method signature attrs attribute listg method attributes type classdecl class interface declaration fflags list access flags jclass class interface super jclass option direct superclass jclass list direct superinterfaces list field declarations list method declarations attrs attribute listg local jvmtype sig peter bertelsen december exception string jclass val class string list name 
jclass val packages jclass 
string list val classname jclass 
string val jclass 
string datatype tint jclass val 
bool val int 
val 
int val 
type list option val width 
int val 
string val string 
option val 
string val string 
option jvmtype sml peter bertelsen december exception string fun raise jvmtype datatype jclass class string list name fun class fun false false false false ok ok fun substring foldl true substring list pkgs andalso name class class invalid class identifier fun classname class fname name fun packages class pkgs fun cs foldl op cs fun cs cs fun cs name list foldl cs pkgs fun class string rev val list foldl fun class string rev name pkgs array datatype tint jclass appendix sml jvm toolkit source files fun case 
true 
true 
true 
true 
true 
true tint 
true 
true 
false type list option fun fun raise domain fun res res res res fun raise domain fun fun raise domain fun width case 





tint 



fun cs case 
cs 
cs 
cs 
cs 
cs 
cs tint 
cs 
cs 
cs class 
cs fun val cs string rev cs fun val cs foldl val cs cs val cs case 
cs 
cs string rev cs local open substring val fn 

andalso 
fun ids ss val id ss ss val id string id val ss ss isempty ss invalid qualified name sub ss rev ids id ss id ids ss fun scan dim ss val ss ss case sub ss 
dim ss 
dim ss 
dim ss 
dim ss 
dim ss 
dim ss 
dim tint ss 
dim ss 
scan dim ss 
val pkgs name ss ss val class class pkgs name dim class ss 
scan invalid type descriptor fun scan ss val dim ss scan ss dim ss fun ss ts sub ss rev ts ss val ss scan ss ss ts fun val rest scan isempty rest fun appendix sml jvm toolkit source files val ss sub ss val args ss ss sub ss args val ret ss scan ss isempty ss args ret label sig peter bertelsen september label type labels val tostring label 
string val labels val newlabel labels 
labels label label sml peter bertelsen august datatype label lbl int datatype labels int fun tostring lbl label int tostring val fun newlabel lbl localvar sig peter bertelsen december exception type locals index val index val fromint int 
index val toint index 
int val tostring index 
string val compare index index 
order val locals val count locals 
int calculate number slots val locals 
locals index val locals 
locals index note fromint raises domain specified index invalid allocates slot word variable allocates slot word variable localvar sml peter bertelsen december exception datatype index var int datatype locals locals int val maximum number local vars val val var fun fromint var raise domain fun toint var fun tostring var var int tostring fun compare var var int compare val locals fun count locals fun locals locals var raise fun locals locals var raise appendix sml jvm toolkit source files bytecode sml peter bertelsen december exception string exception unimplemented string datatype cint int int real real int int real real string local open label localvar jvmtype datatype class jclass class interface array array class element type type fieldref fclass jclass array class name string ty type methodref fclass jclass array class name string msig type jvm instructions extended labels datatype jlabel label string jaload index jaload jaload jaload jaload index int jcheckcast jd jd jd real real index index jdup jdup jdup jdup jf jf jf real real index index jgetfield fieldref jgetstatic fieldref jgoto label label ji ji ji ji ji ji jiconst int int jiconst jiconst jiconst jiconst jiconst jiconst label label label label label label label label jifeq label jifne label label label label label label label fvar index const intg index methodref jinvokespecial methodref appendix sml jvm toolkit source files methodref jinvokevirtual methodref index label label jl jl jl int int index label cases int int label listg index dim intg jnew jclass dim intg jpop jpop fieldref fieldref index int label offset int int key target targets label vector local note jvm instructions omitted datatype 
example need distinguish aload aload binary byte code emitted emitter choose compact aload variant 
translations bytecode emitter emit 
ldc jaload 
aload aload wide aload 
astore astore wide astore 
ldc 
wide 
wide 
ldc 
wide 
wide jgoto 
goto jiconst 
iconst ldc 
wide 
iload iload wide iload 
istore istore wide istore 
jsr 
ldc 
wide 
wide 
newarray 
ret wide ret 
areturn ireturn return utility functions fun intconst jiconst int fromint fun jiconst int fromint word fun jiconst int fromint char ord fun real fun checkcast jcheckcast class fun jcheckcast array peter sestoft peter bertelsen val maxdepth bytecode list 
label label list 
int maxdepth code computes maximal local stack depth reached computation code exception handler entry points 
appendix sml jvm toolkit source files peter sestoft peter bertelsen computes maximal stack depth formed jvm bytecode sequence 
restrictions local subroutines implemented jsr ret enforced code subroutine immediately stores return address stack local variable subroutine subsequently modify variable calling subroutines variable subroutine ret instructions subroutines call subroutines recursive directly indirectly subroutines entered exited means jsr ret instruction belongs main program single subroutine color instruction belongs main program lbl belongs subroutine begins label lbl subroutine may fail return entering infinite loop throwing exception terminating containing method 
belongs exception impossible string belongs fun bug raise impossible local open jvmtype fun width compute difference method return type size arguments type size fun val list foldl fn tot 
width tot case 

width manipulating sets modified local variables abstype intset intset open intset val emptyset empty fun lvar add localvar toint lvar fun lvar val localvar toint lvar add add fun inset lvar intset member localvar toint lvar fun union intset union known code label pending label reached label reached stack depth color resolved subroutine called returned resolving subroutine called returned resolving subroutine called fully resolved datatype pending bytecode list dep int col label label option int ref dep int int option modif int fun maxdepth code open bytecode create table information labels program val fail maxdepth undefined label val fun update lbl info insert lbl info fun lookup lbl find lbl fun jlabel lbl rest update lbl pending rest rest rest rest val code record stack depth return local subroutine lbl fun lbl depth modif case lookup lbl 
depth 
raise fail inconsistent stack depths ret union modif 
update lbl depth ref 
bug fun color color lbl lbl record stack depth ordinary label fun resolve depth modif lbl maxdepth case lookup lbl pending code 
update lbl depth col color finddepth code modif depth maxdepth 
appendix sml jvm toolkit source files col 
color raise fail inconsistent subroutine colors label depth 
dep raise fail inconsistent stack depths label maxdepth 
raise fail subroutine label ordinary label get stack depth subroutine lbl resolve necessary depth lbl case lookup lbl pending 
raise fail code subroutine pending lvar rest 
val update lbl val finddepth rest lvar lbl emptyset depth depth val modif case lookup lbl 
reachable emptyset 

bug val modif lvar modif inset lvar modif raise fail subroutine overwrites return address update lbl depth modif modif modif pending 
raise fail subroutine start 
raise fail ordinary label subroutine label dep modif 
depth 
dep raise fail inconsistent stack depths subroutine modif 
raise fail subroutine call loop find maxdepth code execution resolve labels subroutines finddepth modif depth maxdepth maxdepth finddepth code ins rest modif depth maxdepth fun finddepth modif delta val depth depth delta val maxdepth int max depth maxdepth finddepth rest modif depth maxdepth fun finddepth modif delta lbl val depth depth delta val maxdepth int max depth maxdepth finddepth rest modif depth resolve depth modif lbl maxdepth case ins 
maxdepth 
maxdepth jgoto lbl 
resolve depth modif lbl maxdepth 
val depth depth fun resolve lbl maxdepth resolve depth modif lbl maxdepth val maxdepth list foldl resolve maxdepth cases resolve depth modif default maxdepth targets 
val depth depth val maxdepth vector foldl resolve depth modif maxdepth targets resolve depth modif default maxdepth jlabel lbl 
resolve depth modif lbl maxdepth lbl 
val modif maxdepth depth lbl val modif union modif modif val maxdepth int max maxdepth maxdepth case 
finddepth rest modif maxdepth 
maxdepth lvar 
case 
raise fail local ret subroutine lvar lbl 
lvar 
lvar raise fail wrong lvar local ret lbl depth modif maxdepth 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif jaload 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif jcheckcast 
finddepth modif jd 
finddepth modif jd 
finddepth modif jd 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif appendix sml jvm toolkit source files 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif jdup 
finddepth modif 
finddepth modif 
finddepth modif jdup 
finddepth modif jdup 
finddepth modif jdup 
finddepth modif jf 
finddepth modif jf 
finddepth modif jf 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif jgetfield fty 
finddepth modif ty jgetstatic fty 
finddepth modif ty ji 
finddepth modif ji 
finddepth modif ji 
finddepth modif ji 
finddepth modif ji 
finddepth modif ji 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif jiconst 
finddepth modif 
finddepth modif lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl jifeq lbl 
finddepth modif lbl jifne lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl lbl 
finddepth modif lbl args 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif msig jinvokespecial 
finddepth modif msig 
finddepth modif msig jinvokevirtual 
finddepth modif msig 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif jl 
finddepth modif jl 
finddepth modif jl 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif 
finddepth modif jnew 
finddepth modif 
finddepth modif dim 
finddepth modif jpop 
finddepth modif jpop 
finddepth modif fty 
finddepth modif ty fty 
finddepth modif ty 
finddepth modif 
finddepth modif 
finddepth modif finddepth code emptyset list foldl resolve emptyset sig peter bertelsen december exception string type pool appendix sml jvm toolkit source files index datatype entry string int int word vector vector int int word vector vector index index fclass index fclass index fclass index fname index desc placeholder val create unit 
pool val int 
index val index 
int val pool 
string 
index val pool 
int int 
index val pool 
real real 
index val pool 
int int 
index val pool 
real real 
index val pool 
jvmtype jclass 
index val pool 
jvmtype 
index val pool 
string 
index val pool 
fname string desc 
index val pool 
bytecode fieldref 
index val pool 
bytecode methodref 
index val pool 
bytecode methodref 
index val pool 
bytecode 
index val lookup pool 
index 
entry val emit word word 
unit 
pool 
unit sml peter bertelsen december exception string fun raise datatype index idx int val fun andalso idx raise overflow fun idx note index values produced insert functions exceed due array sub insert 
datatype entry string int int word vector vector int int word vector vector index index fclass index fclass index fclass index fname index desc placeholder note float double entries stored byte vectors real real real real values polymorphic equality constant pool implementation 
datatype pool cp entry array array ref cache entry index hashtable count int note valid entry constant pool pool 
val bytecode insert unexpected find fun create cp ref array array cache count ref fun insert size cp cache entry val count count val index idx count case cache entry index 
array update pool count entry count count size index index 
index val insert insert insert constant occupying entry val insert insert insert constant occupying entries fun cp str insert cp str fun cp insert cp fun cp insert cp real fun cp insert cp fun cp insert cp real fun cp str val ins insert cp ins ins str appendix sml jvm toolkit source files fun ins class val name jvmtype class ins ins name fun cp insert cp fun cp open jvmtype val ins insert cp val desc case 
class 
class 
invalid array class ins ins desc fun ins name desc ins fname ins name desc ins desc fun cp fname insert cp name desc fun cp fclass name val ins insert cp val desc jvmtype ty ins fclass ins class ins name fun cp fclass name val ins insert cp val desc jvmtype msig ins fclass ins class ins name fun cp fclass name val ins insert cp val desc jvmtype msig ins fclass ins class ins name local open bytecode fun cp value case value cint 
cp 
cp 
cp 
cp 
cp 
invalid constant fun lookup cp count idx andalso count array sub pool raise subscript fun res convert character utf representation val ord andalso word fromint res val xc div val mod word fromint word fromint res val div val xe div val mod val mod word fromint word fromint word fromint res note section necessary char characters fun emit cp count val int emit val int emit val emitu word emit val emitu emitu word fromint fun idx emitu fun emit val cs foldr emitu length cs list app cs emit emit bs word vector app bs emit emit bs word vector app bs emit emit emit fclass appendix sml jvm toolkit source files nt emit fclass nt emit fclass nt emit fname desc dg emit emitu count array fn 
emit pool count sig peter bertelsen october exception string val emit pool 
jvmtype option 
bytecode list 
word vector vector label label 
int val isu int 
bool val isu int 
bool val int 
bool val int 
bool sml peter bertelsen december open bytecode jvmtype note assumed localvar toint return integers range 
exception string fun raise fun bug raise type address int datatype placeholder ofs address base ofs address base datatype target pending placeholder list ref resolved address fun case 
word word 




tint 


bug simple jvm type val emit label val wide word word opcode jvm wide instruction prefix fun isu andalso xff fun isu andalso fun andalso fun andalso fun placeholder addr addr fun placeholder addr addr datatype static fun msig val extra case static 

include size list foldl fn res 
width res extra msig fun emit cp code val nextaddr ref instruction goes code val targets val code word array array max bytes code method local open val cp val cp val cp val cp val cp val cp val cp val cp val cp val cp fun setu addr word array update code addr addr note set functions store value specific appendix sml jvm toolkit source files address code array return address emit functions update nextaddr counter return unit 
val setu setu word fromint fun emitu nextaddr setu nextaddr val word vector foldl fn 
setu fun setu addr addr word word fromint val setu fun addr addr int val int fromint fun assuming holds val addr setu nextaddr nextaddr setu addr fun assuming holds val addr setu nextaddr nextaddr setu addr fun index val index index isu index val addr setu nextaddr ldc nextaddr setu index addr val addr setu nextaddr nextaddr setu index addr fun index val addr setu nextaddr ldc nextaddr index addr fun val int toint case 
emitu 
emitu iconst 
emitu iconst 
emitu iconst 
emitu iconst 
emitu iconst 
emitu iconst 
handle overflow 
local open real val bytes val bytes word vector fromlist val bytes val bytes fun val bytes bytes bytes emitu bytes bytes emitu bytes bytes emitu local val zero int fromint val int fromint fun zero emitu emitu local open real val bytes val bytes fun val bytes bytes bytes emitu bytes bytes emitu fun instr assuming isu holds val addr nextaddr isu val addr setu instr addr nextaddr setu addr emit wide instruction variant val addr setu wide addr val addr setu instr addr appendix sml jvm toolkit source files nextaddr setu addr fun imm imm imm imm index val index localvar toint index case index 
emitu imm 
emitu imm 
emitu imm 
emitu imm 
instr index fun instr lbl val base nextaddr val addr setu instr base case peek targets lbl 
val phs ofs addr base val pending ref phs insert targets lbl nextaddr placeholder addr pending phs 
phs ofs addr base phs nextaddr placeholder addr resolved 
val ofs base ofs nextaddr setu ofs addr emit branch offset range fun base lbl addr case peek targets lbl 
val phs ofs addr base insert targets lbl pending ref phs placeholder addr pending phs 
phs ofs addr base phs placeholder addr resolved 
base addr fun val base nextaddr case peek targets lbl 
val addr setu base val phs ofs addr base insert targets lbl pending ref phs nextaddr placeholder addr pending phs 
val addr setu base phs ofs addr base phs nextaddr placeholder addr resolved 
val ofs base ofs val addr setu instr base nextaddr setu ofs addr val addr setu base nextaddr ofs addr fun lbl val nextaddr fun patch ofs case ofs ofs 
val ofs base ofs setu ofs addr emit branch offset range ofs 
base addr case peek targets lbl 
pending phs 
list app patch phs 
emit label resolved insert targets lbl resolved fun fvar val localvar toint var val addr nextaddr isu andalso const val addr setu addr val addr setu addr nextaddr setu const addr const val addr setu wide addr val addr setu addr val addr setu addr nextaddr setu const addr emit constant range fun instr class val addr setu instr nextaddr val index case class class 
array elem 
elem appendix sml jvm toolkit source files nextaddr index addr fun instr args val addr setu instr nextaddr nextaddr args addr fun val nargs msig isu nargs val addr setu nextaddr val addr addr val addr setu nargs addr nextaddr setu addr emit nargs range fun instr isu msig val addr setu instr nextaddr nextaddr addr emit static nargs range fun dim elem val addr setu nextaddr newarray nextaddr setu elem addr val addr setu nextaddr nextaddr elem addr isu dim val addr setu nextaddr val index elem val addr index addr nextaddr setu dim addr emit dim range fun addr addr addr mod fun val base nextaddr val addr setu base val addr base default addr val addr length cases addr fun key lbl map binarymap insert map key lbl val list foldl binarymap int compare cases fun key lbl base lbl key nextaddr binarymap foldl addr fun offset val base nextaddr val addr setu base val addr base default addr val addr offset addr val len vector length targets val high int toint offset len note high calculated int int val addr high addr val vector foldl fn lbl 
base lbl nextaddr addr targets fun word word case 
return 
case 
ireturn 
ireturn 


ireturn 
ireturn tint 
ireturn 

areturn 
areturn fun instr case instr jlabel lbl 
lbl 

emitu 
emitu 
emitu jaload 
imm imm imm imm 
emitu 
imm imm imm imm 
emitu 
emitu 
emitu 
emitu 
emitu jcheckcast class 
class jd 
emitu jd 
emitu jd 
emitu 
emitu 
emitu appendix sml jvm toolkit source files 
emitu 
emitu 
emitu 

emitu 
imm imm imm imm 
emitu 
emitu 
emitu 
imm imm imm imm 
emitu jdup 
emitu 
emitu 
emitu jdup 
emitu jdup 
emitu jdup 
emitu jf 
emitu jf 
emitu jf 
emitu 
emitu 
emitu 
emitu 
emitu 
emitu 

emitu 
imm imm imm imm 
emitu 
emitu 
emitu 
imm imm imm imm 
emitu jgetfield 
jgetstatic 
jgoto lbl 
lbl ji 
emitu ji 
emitu ji 
emitu ji 
emitu ji 
emitu ji 
emitu 
emitu 
emitu 
emitu 
emitu jiconst 

emitu lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl jifeq lbl 
lbl jifne lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl lbl 
lbl 

imm imm imm imm 
emitu 
emitu class 
class 
jinvokespecial 

static jinvokevirtual 

emitu 
emitu 
emitu 
emitu 
imm imm imm imm 
emitu 
emitu 
emitu lbl 
lbl jl 
emitu jl 
emitu jl 
emitu 
emitu 
emitu 
emitu 
emitu 
emitu 

emitu 
imm imm imm imm 
emitu 
emitu 

emitu 
emitu 
emitu 
emitu 
imm imm imm imm 
emitu appendix sml jvm toolkit source files 
emitu 
emitu 
emitu 
emitu jnew class 
class class 

emitu jpop 
emitu jpop 
emitu 


localvar toint 
emitu 
emitu 
emitu 
emitu 
val list app code word array extract code nextaddr fun lbl case peek targets lbl 
emit unknown label resolved 

emit unresolved label classfile sig peter bertelsen october exception string val emit word word 
unit 
pool 
classdecl classdecl 
unit val scan unit 
word word 
classdecl classdecl pool classfile sml peter bertelsen december open classdecl note assumed returned emit return integers range 
exception string fun raise classfile fun bug raise bytecode classfile type word word word word entry word word catch index type word word line word type word word length word word name index desc index index word datatype attribute fattr index file fattr index value code fattr index stack word word locals word word code word vector vector hdls list attrs attribute listg exns fattr index exns index listg fattr index lines listg localvar fattr index vars listg attr fattr index info word vector type member fflags word word name index desc index attrs attribute listg type classfile word word minor word word major word word pool pool flags word word index super index option index list fields member list methods member list attrs attribute listg val magic word vector fromlist val magic valof word magic appendix sml jvm toolkit source files val minor word val major word fun flag case flag 
wx 
wx 
wx 
wx 
wx 
wx 
wx 
wx 
wx 
wx 
wx 
wx fun flag word orb flag val word list foldl val isu isu fun cp fflags super val cp val cp val cp fun entry val word fromint start entry entry catch case catch 
class 
class fun isu line word fromint start line word fromint line number range fun ffrom name ty val start val length start val index localvar toint index isu length isu index word fromint start length word fromint length name name desc jvmtype ty index word fromint index index range length range fun classdecl file fattr file classdecl value fattr value ty classdecl code locals code hdls val code emit cp ty code val val ty isu stack isu locals code fattr code stack word fromint stack locals word fromint locals code code hdls list map hdls attrs list map code range code range classdecl exns exns exns fattr exceptions exns list map classdecl lines fattr lines list map classdecl localvar vs localvar fattr vars list map classdecl attr fattr attr fattr attr info fun invalid nested attributes val note inserting method attribute second argument specifies optional return type method inserting field class attribute faked return type 
fun fflags name ty fflags flags name name desc jvmtype ty attrs list map fun fflags name msig val msig fflags flags name name desc jvmtype msig attrs list map note cp need completed start building appendix sml jvm toolkit source files resulting classfile pool imperative 
magic minor minor major major pool cp flags flags super case super 
class 
class list map fields list map methods list map attrs list map fun cf raise bytecode unimplemented classfile val word word val word word fun minor major pool flags super fields methods val emitu word emit val emitu emitu word fromint val emitu word emit val emitu emitu word fromint val emitu fun emitu word fun entry emitu start emitu emitu entry catch fun emitu start emitu line fun length name desc emitu start emitu length name desc emitu index fun list length lines localvar fvars list length vars attr word vector length info emit invalid nested attributes fun attrs list foldl fn sz 
sz attrs fun fattr attr emitu word file fattr attr emitu word value code fattr stack locals code hdls val codelength word vector length code val list length hdls isu attr emitu codelength attrs emitu stack emitu locals emitu codelength word vector app code emitu list app hdls attrs emit code exception handlers exns fattr val list length exns isu attr emitu emitu list app exns emit exns exceptions fattr val list length lines isu attr emitu emitu list app lines emit lines localvar fattr val list length vars isu attr emitu emitu list app vars emit localvar variables attr fattr attr word vector app info attrs val len list length attrs isu len emitu len list app attrs emit attributes fun fflags name desc emitu flags name desc attrs appendix sml jvm toolkit source files val list length val list length fields val list length methods isu isu isu emitu magic emitu minor emitu major emit pool emitu flags super emitu list app emitu list app fields emitu list app methods attrs emit methods emit fields emit direct superinterfaces fun emit cp decl cp decl fun src raise bytecode unimplemented classfile fun scan src src appendix source files new back sml peter bertelsen december local open prim lambda const jvmtype bytecode runtype jvmcode error val labels ref label val tags ref tag note labels tags unique target class methods val int fmt hex char ord fun char char tostring fun string concat foldr fun member list exists fn 
fun labels label fun tags tag generate fresh label fun newlabel val labels lbl label newlabel labels labels labels lbl generate fresh tag fun val tags tag tag tags tags tags tag fun tag tags add label list instructions appendix source files new back fun case jgoto lbl 
lbl jlabel lbl 
lbl 
val lbl newlabel lbl jlabel lbl generate branch list instructions fun case 
branch jgoto 
branch jlabel 
jlabel lbl 
jgoto lbl 
val lbl newlabel jgoto lbl jlabel lbl discard instructions label fun case jlabel 

critical 
rest 
rest avoid checkcast specified class fun class case jcheckcast class 
class 
avoid checkcast specified classes fun classes case jcheckcast class 
member classes 
generate code store value local variable avoid loading value immediately fun case jaload 
jdup 
generate code store value static field avoid loading value immediately fun case jgetstatic 
jdup 
converting identifier bytecode fieldref val fun id int tostring id fun id int tostring id fun rt idg val class case qual general 
general 
name fclass class name id ty rtg fieldref fun rt idg val class case qual general 
general 
name fclass class name id ty rtg fieldref fun argtypes idg fclass name name id msig argtypes methodref fun idg qual id idg qual id int tostring fun tag clos tag tostring tag fun class name argtypes val argtypes argtypes argtypes fclass class name name msig argtypes methodref fun argtypes uid val argtypes argtypes argtypes argtypes uid invert fun val invert fn 






case 


invert appendix source files new back 
invert 
invert 
invert 
convert jvm int test val fn 
label label 






convert jvm int test zero val fn 
jifeq label label 

jifne 




check list switch clauses contains exception tags tags resolved load time fun clauses list exists fn 
true 
false clauses maximum minimum bit integers val valof int val maxint valof int maxint maximum minimum bit integers represented bit values val int valof int val maxint int valof int maxint convert int operator long operator val fn 





build list copies fun copy fun copy es es copy es copy es copy raise domain identity function fun identity bind lvar local environment updating environment fun localenv rt val localenv localenv bind localenv rt localenv localenv register exception uid fun fclass names exns jvmcode uid idg qual jvmtype classname class val name id val rtobject export trueg names binarymap insert names name exns add exns uid build map free variable index runtype list free variables local variable environment record closure environment fun tag free closureenv fun lvar rest rest intmap insert val free intmap empty closureenv binarymap insert closureenv tag retrieve free variable runtype environment corresponding specified tag closure environment return lookup function free variable runtype environment fun closureenv tag val binarymap find closureenv tag handle binarymap notfound 
tag tag tostring tag fn 
intmap retrieve handle intmap notfound 
tag tag tostring tag free var int tostring local appendix source files new back coercion sig coercion boxed unboxed run time representation sml values 
peter bertelsen december type wrapper bytecode list 
bytecode list 
bytecode list bytecode list val coerce runtype runtype 
runtype runtype 
wrapper coercion sml peter bertelsen december open jvmtype bytecode runtype error type wrapper list 
list 
list list fun new class jnew class jdup fun wrap class init wrapper fn 
new class jinvokespecial init val wrap integer val wrap long val wrap double val wrap string val wrap vector fun val branch val lbl newlabel identity jifeq lbl jgetstatic branch jlabel lbl jgetstatic fun intvalue identity identity ji fun jcheckcast class jinvokevirtual number jinvokevirtual fun identity intvalue identity jl fun jcheckcast class jinvokevirtual number jinvokevirtual fun jcheckcast class jinvokevirtual number andalso identity jinvokevirtual identity fun jcheckcast class jinvokevirtual string andalso identity jinvokevirtual identity jcheckcast class situation may occur connection string test string fun jcheckcast class jgetfield vector andalso identity jgetfield identity fun jcheckcast class jgetfield constructor andalso identity jgetfield identity fun class identity checkcast class fun elem identity elem fun class wrapper val check checkcast class val invoke jinvokevirtual fn 
identity check invoke fun class wrapper val check checkcast class val get jgetfield fn 
identity check get val number intvalue val number val number val constructor val string val vector appendix source files new back fun invokevirtual identity jinvokevirtual fun getfield identity jgetfield fun coerce src src identity case src rtint 
invokevirtual intvalue 
invokevirtual 
invokevirtual rtint 
rtint 
identity ji rtint 
identity ji rtint rtobject 

rtint 
identity jl 
identity jl rtobject 

rtint 
identity jd 

identity jd 
rtobject 

rtobject 

invokevirtual 

getfield 

tuple 
constructor 
ref 
exception 
identity 
identity 
getfield 
identity 
identity 
rtobject 
number rtobject rtint 
rtobject 
rtobject 
rtobject 
rtobject 
rtobject 
string rtobject 
vector rtobject 
object rtobject 
block rtobject 
tuple rtobject 
constructor rtobject 
ref rtobject 
exception rtobject 
closure rtobject 
rtobject 
identity 
coercion coerce invalid coercion freeenv sml applicative map negative lvar id free var index peter bertelsen december type freeenv val fresh freeenv val fromlist int list 
freeenv val intset intset 
freeenv val add freeenv 
int 
int 
freeenv val remove freeenv 
int 
freeenv val lookup freeenv 
int 
int option val find freeenv 
int 
int val freeenv 
int val app int int 
unit 
freeenv 
unit val foldl int int 


freeenv 
val foldr int int 


freeenv 
val shift freeenv 
freeenv val domain freeenv 
int list note remove find raise domain case specified index environment freeenv sml peter bertelsen december open lambda datatype freeenv env int intmap intmap val fresh env intmap empty fun fromlist xs fun env xr xr intmap insert xs intmap empty fun fun intmap insert val intset foldl intmap empty env fun add env env intmap insert appendix source files new back fun remove env val intmap remove handle intmap notfound 
raise domain env fun lookup env intmap peek fun find env intmap retrieve handle intmap notfound 
raise domain fun env intmap fun app env intmap app fun foldl env intmap foldl fun foldr env intmap foldr fun shift env fun intmap insert env intmap foldl intmap empty foldr fun domain env intmap foldr fn 
sml peter bertelsen december local open jvmtype bytecode classdecl localenv jvmcode runtype instantiate error fun entries maxdepth entries handle fail 
print val init val env bind rtint val code jaload localvar jdup jinvokespecial fflags name msig tint attrs code code locals env code code hdls attrs val init val env bind rtint val env bind env val code jaload localvar jdup jinvokespecial jdup jaload fflags name msig tint object attrs code code locals env code code hdls attrs val main fflags name main msig string attrs code locals code hdls attrs fun export export fun name fs fflags export name name ty runtype attrs fs list fun code env hdls code list map entry hdls code locals env code code hdls rev hdls attrs attribute note list exception handler declarations method reversed nested handlers properly 
fun fname argtypes export code env ms fflags export name name msig argtypes appendix source files new back attrs code env hdls ms list fun class exns env val class classname class fun uid idg uid rtobject uid val code foldl code exns fflags name msig attrs code env hdls fun env entries val tag toint tag val tag toint val newlabel generate switch closure tag method apply fun fail lbl rest jaload localvar jgetfield case rest 
jifeq lbl intconst lbl 
fail offset int fromint targets vector fromlist fun xs val array array fun tag lbl val tag toint tag array update lbl list app xs array foldr op val code jlabel jnew jdup closure tag jinvokespecial code val code entries code fflags name apply msig object object attrs code env hdls fun fclass names exns methods jvmcode val val val orelse val ms main class exns val ms apply ms ms val ms init ms ms val ms init ms ms fflags class super closure object binarymap foldl names list foldl ms methods attrs path file classdecl fun jvmcode val fun output val classdecl jvmcode val create classfile emit classdecl handle 
remove raise sig peter bertelsen december type runtype runtype intmap intmap type closureenv tag tag binarymap dict type const runtype runtype binarymap dict type exportenv const const binarymap dict type tag tag string bool binarymap dict val unit 
unit reset label tag generators val 
exportenv 
lambda lambda list 
closureenv ref 
jvmcode jvmcode 
unit generate jvm code top level expressions val 
exportenv 
lift list 
closureenv ref 
jvmcode jvmcode 
unit generate jvm code lifted closure bodies val 

exportenv 
lift list 
closureenv ref 
jvmcode jvmcode 
unit generate jvm code specialized closure bodies appendix source files new back sml generating jvm bytecode lambda terms doug currie back sml peter bertelsen december open mixture lambda prim const lift bytecode runtype coercion instantiate jvmcode val false flag generate code check overflow 
val true flag generate code raising div 
type runtype intmap intmap type closureenv tag tag binarymap dict type const runtype runtype binarymap dict type exportenv const const binarymap dict type tag tag string bool binarymap dict fun gencodeerror error reset code generator state label closure tag counters fun compile clauses lcase statement function declared part large letrec gives typing problem type generalized 
fun gencodeerror compexpr val compexpr val jifne intconst compexpr clause rest val int int fromint val branch fun cases val lbl compexpr branch int lbl cases val cases val clause val lbl compexpr list foldl int lbl rest note generate branch code clause resulting bytecode comes case branch necessary due context term 
fold rest clauses 
val lbl cases case cases 
gencodeerror lbl xr 
lbl xr lbl 
lbl cases note happen case statement fact exhaustive case cases default target 
lbl cases cases translator lambda terms lists instructions 
maps global name uid runtype exportenv maps global name uid exported name uid closureenv maps closure tag runtype environment free vars closure side effected jvmcode target jvm code class info hdls declared exception handlers side effected renumbering compilation specialized closures generating code load value lvar maps lvar id runtype localenv maps lvar id localvar index side effected label branch compilation lambda expressions depth depth front sml stack model excl 
codegen temporaries expr lambda term compile continuation code follows code expr fun exportenv closureenv closureenv ref jvmcode jvmcode hdls localenv localenv localenv ref fun compexpr depth expr case expr lvar 

body args 
depth body args lfn body 
gencodeerror compexpr lfn args body 
depth args body args body 
depth args body lprim prim args 
depth prim args lcase arg clauses 
depth arg clauses size arg cs 
depth size arg cs 
case 
gencodeerror lbl 
jgoto lbl body handler 
depth body handler body handler 
depth body handler lif cond 
depth cond 
compexpr depth jpop compexpr depth cond body 
depth cond body 
depth 
depth 
ref 
compexpr depth 
gencodeerror compexpr jpop appendix source files new back val rt jpop case 
tag scons 
tag scons 
gencodeerror tag span scons case span scons 

scons 
tag 
tag scons uid scons jvmcode uid case scons 
uid 
uid scons depth lprim pclosure tag spec ts free assuming list length argtypes ts val print apply tag ts val fclass jvmcode val class tag ts val tag free closureenv free compexpr depth free depth body lvar args depth args depth body lprim uid args depth uid args depth body args depth body args depth args val fun val jgetfield val jcheckcast class closure note needn checkcast locally bound lvar isn free assumed runtype bound closure object run time 
bytecode verifier accept 
val rt fun val new depth args val rt closure new case tag spec ts 
val argtypes ts list length args list length argtypes val class jvmcode tag ts val depth argtypes args print apply lvar int tostring tag ts 

val new depth args val rt new depth uid args val uid case binarymap peek exportenv uid 
uid uid 
uid fun val new depth args jgetstatic rtobject uid new case binarymap peek uid tag spec ts 
val argtypes ts list length args list length argtypes val ts uid val depth argtypes args print apply uid tag ts gencodeerror free vars uid 
depth argtypes args fun args val new depth args appendix source files new back new rt rtr ar val new rtr ar val new coerce rtobject rt new new compexpr depth gencodeerror val new argtypes args new depth args fun apply identity apply ar val new apply ar val compexpr depth jinvokevirtual val new coerce rtobject new new apply args depth body args fun arg new val compexpr depth arg jinvokevirtual val new coerce rtobject new new val new list foldr identity args new compexpr depth body depth arg special case arising val arg val case 

jpop compexpr depth arg depth args body fun compexpr body ar val rt case lprim pclosure tag spec spec 
tag spec lprim pclosure 

rtobject val localenv rt val ar compexpr depth args depth args body fun ar val rt case lprim pclosure tag spec spec 
tag spec 
localenv rt ar fun cs cs lprim pclosure tag free ar cs val localenv find localenv val case free 

jaload compexpr free tag free closureenv ar tag cs gencodeerror val fclass jvmcode fun initarg tag class tag val depth depth list length args val cs depth args depth args compexpr depth body handle domain 
gencodeerror domain true args 
list foldl initarg cs depth prim args case prim args 
compexpr depth uid 
uid uid 
depth uid 
gencodeerror es 
depth es tag es 
depth tag es 
gencodeerror 
depth 
depth name arity es 
depth name arity es praise 
depth 
depth unsigned integer operations es 
depth es es 
depth es es 
depth es appendix source files new back es 
false depth es es 
false depth es es 
depth es es 
depth es es 
depth es es 
depth es es 
depth es es 
depth es 
depth 
depth es 
depth es es 
depth es es 
depth es es 
depth es es 
depth es 
depth 
depth 
depth 
depth 
depth 
depth 
depth note signed integer operations 
depth 
gencodeerror 
gencodeerror es 
depth es es 
depth es es 
depth es es 
depth es es 
false depth es 
depth 
compexpr depth jpop es 
depth es es 
false depth es pclosure info es 
depth info es es 
depth es 
gencodeerror unimplemented primitive depth es fun val new coerce rtobject rtint new compexpr depth list foldr es integer operation check overflow division zero oper depth es val new coerce rtint new depth es oper oper depth es integer operation check overflow converts operand long value performs long operation checks result int bounds converts back int result builds integer object val new coerce val lbl newlabel val lbl newlabel val oper jdup lbl jdup maxint lbl jlabel lbl jpop jlabel lbl new depth es oper depth es depth es fun val new coerce rtobject new compexpr depth list foldr es depth es fun val new coerce rtobject new compexpr depth list foldr es depth es oper val new coerce new depth es oper depth es fun val new coerce rtobject new compexpr depth list foldr es uid val uid case binarymap peek exportenv uid 
uid uid 
uid jgetstatic rtobject uid depth uid idg val case jpop 

appendix source files new back val field name case binarymap peek exportenv uid 
rtobject uid id rtobject export falseg uid idg 
rtobject uid id rtobject export trueg val jvmcode names binarymap insert names name compexpr depth field depth es val new coerce val lbl case jifne lbl 
lbl jifeq lbl 
lbl val lbl val lbl newlabel val intconst jgoto lbl jlabel lbl intconst lbl val case 
depth es lbl 
depth es lbl 
val test lbl depth es test 
val test lbl depth es test 
val test lbl depth es jinvokevirtual test 
val test lbl depth es test tag 
gencodeerror new depth tag span es val compexpr compexpr depth tag config case es 
compexpr 
gencodeerror malformed ref span compexpr es compexpr tag es note need treat case es specially 
empty tuples aka unit null constructors null exceptions represented 
depth uid es jvmcode uid compexpr depth uid es depth val new coerce rtobject jgetfield intconst new compexpr depth depth val compexpr depth val new coerce rtobject jgetfield intconst new compexpr depth depth name arity es case name arity 
val new coerce val jinvokevirtual new depth es 
val new coerce val case jifne lbl 
jifeq lbl jifeq lbl 
jifne lbl 
intconst val jinvokevirtual new depth es 
gencodeerror unimplemented call depth val rt case lvar 

rtobject val new coerce rt new compexpr depth depth appendix source files new back val new coerce val case jifne lbl 
jifeq lbl jifeq lbl 
jifne lbl 
intconst val new coerce rtobject new new compexpr depth oper depth es case true 
division zero val uid general id div val uid compexpr depth jpop true 
check overflow val new coerce rtint val lbl intconst oper val new coerce rtobject rtint jdup jiconst lbl jpop new new compexpr depth 
need check division zero overflow oper depth es oper depth es val new coerce rtint val branch val lbl newlabel val lbl newlabel val lbl newlabel val jlabel lbl oper jlabel lbl branch jlabel lbl jpop val lbl lbl entry lbl catch val jdup intconst lbl jiconst lbl jpop hdls hdls new depth es oper depth es depth val new coerce rtint val new coerce rtobject jd new new compexpr depth depth val new coerce val new coerce rtobject rtint ji new new compexpr depth depth val new coerce rtint val new coerce rtobject jinvokevirtual new new compexpr depth depth val new coerce rtint val new coerce rtobject rtint jinvokevirtual val new coerce rtobject compexpr depth new new new compexpr depth depth gencodeerror val val compexpr depth val compexpr depth compexpr depth depth val compexpr depth val new coerce rtobject rtint new compexpr depth depth val new coerce rtint new compexpr depth depth val new coerce rtobject rtint new compexpr depth compexpr depth depth val compexpr depth val new coerce rtobject rtint new compexpr depth compexpr depth depth val new coerce rtint val val lbl newlabel appendix source files new back jdup jiconst lbl jpop jlabel lbl val new coerce rtobject rtint new new compexpr depth depth tag free val fclass jvmcode tag free closureenv case free 
true class tag 
true class compexpr depth tag free gencodeerror depth arg cs val new case 
coerce rtobject depth cs 
coerce rtobject depth cs 
val compexpr depth cs coerce rtobject rtint new compexpr depth arg depth clauses val case 
gencodeerror lbl 
lbl val branch fun lbl val compexpr depth branch val lbl newlabel val case 
jlabel lbl jdup jifne lbl jpop 
jlabel lbl jdup jinvokevirtual jifne lbl jpop 
gencodeerror lbl val lbl newlabel case rev clauses rest 
val jlabel lbl jifne compexpr depth list foldl lbl rest rest 
val jlabel lbl jinvokevirtual jifne compexpr depth list foldl lbl rest 
gencodeerror depth size arg clauses assume argument safe producing side effects terminating switches generated match compiler case size clauses 
compexpr depth 
depth arg 
depth arg 
depth arg 
depth arg 
val rt case arg lvar 

rtobject val rt clauses jgetfield depth clauses val compexpr depth clauses jgetfield val new coerce rt rt new compexpr depth arg depth clauses val case 
gencodeerror lbl 
lbl val branch fun tag lbl val compexpr depth branch val lbl newlabel val case tag uid 
val jvmcode uid val rtobject uid jlabel lbl jdup jgetstatic appendix source files new back lbl jpop 
gencodeerror lbl val lbl newlabel case rev clauses uid rest 
val jvmcode uid val rtobject uid val jlabel lbl jgetstatic compexpr depth list foldl lbl rest 
gencodeerror depth body compexpr depth body depth body handler val branch val compexpr depth handler val branch exportenv closureenv jvmcode hdls localenv depth body depth body handler val branch val lbl newlabel val lbl newlabel val localenv depth val jlabel lbl branch jlabel lbl compexpr depth handler val lbl compexpr depth body hdls lbl lbl entry lbl catch hdls depth cond val case 
gencodeerror lbl 
lbl val new coerce rtobject jifne compexpr depth new compexpr depth cond depth cond val case 
gencodeerror lbl 
lbl val new coerce rtobject jifeq compexpr depth new compexpr depth cond depth cond val branch val lbl compexpr depth val compexpr depth branch val new coerce rtobject jifeq lbl new compexpr depth cond depth cond body val lbl newlabel val new coerce rtobject jifne lbl val lbl new compexpr depth cond jgoto lbl jlabel lbl compexpr depth body jpop depth val new case jcheckcast class jgetfield 
constructor andalso val case jifeq lbl 
jifeq lbl compexpr depth jifne lbl 
val lbl val new coerce rtobject jgetfield jifne lbl jifeq lbl new compexpr depth 
gencodeerror coerce rtobject gencodeerror 
val lbl val new coerce rtobject jifeq lbl jpop compexpr depth new jdup new compexpr depth depth jcheckcast class jgetfield constructor andalso val case jifne lbl 
jifne lbl compexpr depth jifeq lbl 
val lbl val new appendix source files new back coerce rtobject jgetfield jifeq lbl jifne lbl new compexpr depth 
gencodeerror val new coerce rtobject new compexpr depth gencodeerror depth val lbl val jifne lbl jpop compexpr depth val new coerce rtobject new compexpr depth jdup depth es list foldr fn 
compexpr depth es compexpr general compilation expression 
assumption expressions flagged lifted compiled 
fun compexpr expr case lifted 
val lbl compexpr expr compiled lbl compiled lbl 
jgoto lbl 
gencodeerror compilation expression specialized closure assumption expressions flagged compiled specialized 
fun compexpr expr case compiled 
val lbl compexpr expr specialized lbl specialized lbl 
jgoto lbl 
gencodeerror compile time model runtime environment mapping lvar id closure args index localvar index free environment free position negative id free closure args index localenv map lvar id localvar index runtype 
fun localenv gencodeerror free lvar int tostring val rt localenv find localenv handle domain 
gencodeerror lvar int tostring rt jaload fun localenv gencodeerror free lvar int tostring val rt localenv find localenv handle domain 
gencodeerror lvar int tostring rt fun free localenv val freeenv find free handle domain 
gencodeerror free lvar int tostring jaload localvar jgetfield intconst val rt localenv find localenv handle domain 
gencodeerror lvar int tostring rt jaload fun free localenv val freeenv find free handle domain 
gencodeerror free lvar int tostring val rt localenv find localenv handle domain 
gencodeerror lvar int tostring rt fun free ofs localenv val ofs val freeenv find free handle domain 
gencodeerror free lvar int tostring jaload localvar fromint intconst val rt localenv find localenv handle domain 
gencodeerror lvar int tostring rt jaload appendix source files new back fun free ofs localenv val ofs val freeenv find free handle domain 
gencodeerror free lvar int tostring val rt localenv find localenv handle domain 
gencodeerror lvar int tostring rt fun exportenv exprs closureenv jvmcode jvmcode val env val env ref env side effected val hdls ref hdls side effected val identity val env val env val val depth val exportenv closureenv jvmcode hdls env depth fun expr code expr code list foldl code exprs env env hdls hdls fun exportenv closureenv jvmcode jvmcode val env entries apply val env ref env side effected val hdls ref hdls side effected val identity val fun ftag free depth val argtypes copy rtobject depth val closureenv tag val free env val free env val env localenv env argtypes exportenv closureenv jvmcode hdls env depth body val lbl tag lbl val code entries list foldl code entries apply code env env entries entries hdls hdls fun exportenv closureenv jvmcode jvmcode fun ftag free nargs body ms val argtypes copy rtobject nargs val freeenv free val env localenv val env ref localenv env argtypes side effected val hdls ref val nargs depth val fn 
val closureenv tag val free env val free env val val depth nargs val code exportenv closureenv jvmcode hdls env depth body val name export case binarymap peek tag 
tag false res 
res fname name argtypes argtypes argtypes rtobject export export specialized closures declared module invoked code code env env hdls ms methods list foldl methods appendix source files new back instantiate sml peter bertelsen december local open const jvmtype bytecode runtype coercion val tuple val constructor val closure generate new instance specified class generate code arguments invoking initialization method init fun class val class fn 
fn init 
fn 
jnew class jdup jinvokespecial init fun class init jnew class jdup jinvokespecial init val tuple val ref val constructor val exception val intconst tag toint generate new object instance fun jnew object jdup jinvokespecial generate new integer object containing specified value fun val new coerce rtint val case ji 
int fromint 
intconst new generate atomic constant fun case 

val new coerce rtint new 
ord 
val new coerce new 
generate object array list expressions fun compexpr es fun er jdup intconst compexpr er intconst list length es object dim es generate empty tuple object 
unit fun jpop jgetstatic generate tuple object specified arguments fun compexpr args fn 
compexpr args generate ref object argument fun compexpr arg fn 
compexpr arg generate constructor object specified tag arguments fun tag val case tag 
jgetstatic 
jgetstatic 
jgetstatic 
jgetstatic 
jgetstatic 
jgetstatic 
jgetstatic 
jgetstatic 
jgetstatic 
jgetstatic 
fn 
intconst tag fun compexpr tag args fun intconst tag compexpr args generate new instance specified class assumed subclass closure specified tag free variables fun class val init methodref fclass class name msig tint fn tag 
class fn 
tag init generate new instance specified class assumed subclass closure specified tag free variables fun class val init methodref fclass class name appendix source files new back msig tint object fn compexpr 
fn tag 
fn free 
fun tag compexpr free class init generate new exception object tag built tag code arguments fun uid fun jgetstatic rtobject uid generate new exception object specified tag arguments fun compexpr uid args fun jgetstatic rtobject uid compexpr args fun id general id idg val div val overflow jvmcode sml intermediate representation target jvm code class info peter bertelsen december open jvmtype bytecode label localenv classdecl instantiate runtype type runtype runtype export type const list set type fname string argtypes runtype runtype list runtype runtype export bool code bytecode list env localenv localenv hdls classdecl listg type bytecode list code method env localenv localenv local variable env hdls classdecl listg exception handlers type bytecode list code method apply env localenv localenv local variable env entries tag tag label label list closure tags body labels hdls classdecl listg exception handlers type jvmcode fclass jvmtype jclass target class id names string binarymap dict ref top level names exns const set ref static exception names methods list ref specialized closures bool ref init int invoked 
bool ref init int object invoked 
ref apply ref generate trailing code target class fun class fclass class names ref binarymap string compare exns ref empty const methods ref ref false ref false ref bytecode env localenv hdls apply ref env localenv entries hdls jvmcode lift sig peter bertelsen january type ftag tag tag free freeenv freeenv depth int body lambda lambda type ftag tag tag free freeenv freeenv nargs int number curried arguments method arguments depth int body lambda lambda val list ref 
list ref 
appendix source files new back bool lambda lambda list lambda lambda list 
lambda lambda list lift sml peter bertelsen december translation lambda debruijn lambda merged 
requires giving unique ids enclosing function unique scope 
maintain depth model translation simply debruijn 
depth debruijn functions lifted top level simultaneously result free variables negative ids 
closure map built lfn term replaced corresponding pclosure primitive 
open lambda const prim runtype error type ftag tag tag free freeenv freeenv depth int body lambda lambda type ftag tag tag free freeenv freeenv nargs int depth int body lambda lambda fun lams exprs fun free depth note indicates expression appears context run time operand stack non empty prior evaluation expression 
significant connection exception handling throwing jvm exception clears operand stack current method 
fun lift expr case expr lvar 
val id depth val id free intset add free id lvar id 
lift cst 
expr body args 
fun lfn body free depth true body free true depth lift body list map args note curried arguments preserved translated single argument applications 
lfn body 
free depth false body optimize special case arising lab arg arg lprim lvar 
lprim lift arg args body 
fun ea acc rev acc free ea body ea expr rest acc val acc free ea expr acc ea rest acc depth args args body 
val ea depth list length args list map free ea args free ea body lprim 
expr lprim er 
lprim lift list map free true depth er body handler 
lift body lift handler 
body handler 
free depth false expr lift body free depth handler lif cond 
lif lift cond lift lift expr expr 
lift expr lift expr cond body 
lift cond lift body expr expr 
lift expr lift expr expr expr 
lift expr lift expr lcase arg clauses 
fun tag act tag lift act lcase lift arg list map clauses size arg clauses 
fun tag act tag lift act size lift arg list map clauses 
ref todo 
lift lifted expr 
expr lift appendix source files new back free depth nargs body val tag free spec nargs nargs body val spec general tag free spec spec copy rtobject freeenv free argtypes copy rtobject nargs spec fun id val depth id val free intset add free lvar lprim pclosure tag spec freeenv foldr free tag free depth val method ftag tag free free nargs nargs depth depth body method nargs depth body val tag val free body method case body lfn body 
val tag free method nargs body fun id lvar id freeenv shift free lprim pclosure tag general freeenv foldr free method 
val free ref intset empty side effected val body free false depth body val method nargs depth depth body body freeenv free body method val nargs tag free depth body tag free method tag free depth body val closure ftag tag free free depth depth body closure fun pure expr exprs note pure ignored val free ref intset empty side effected val expr free false expr intset free expr exprs lift free variables top level list foldl exprs lams localenv sig applicative map lvar id localvar index runtype peter bertelsen december type localenv val int 
localenv create localenv specified number unreachable localvar bindings val localenv fresh localenv static method val localenv fresh localenv instance method val bind localenv 
int 
runtype runtype 
localenv localvar index val localenv 
int 
runtype runtype list 
localenv val lookup localenv 
int 
localvar index runtype runtype option val find localenv 
int 
localvar index runtype runtype val localenv 
int number bindings val localenv 
int highest localvar index note find raises domain requested lvar localenv 
appendix source files new back localenv sml peter bertelsen december open localvar runtype error datatype localenv env index runtype intmap intmap locals fun fun val env intmap empty raise domain val val fun bind id rt case intmap peek id 
val val intmap insert id rt 
val intmap insert id rt fun bind env env id rt val env bind env id rt env env fun env env rts fun id env env env id rt rest env val env bind env id rt id rest env rts env fun lookup env intmap peek fun find env intmap retrieve handle intmap notfound 
raise domain fun env intmap fun env count runtype sml peter bertelsen december run time representation sml values datatype runtype rtint tag tag rtobject general spec runtype list types free variables argtypes runtype list types arguments result type note general fun tag argtypes tag tostring tag int tostring list length free int tostring list length argtypes args note arity typed closure list length args local open jvmtype error val fn 
number rtint 
tint 



string 

vector 
object 
block 
tuple 
constructor 
ref 
exception 
closure 
closure rtobject 
object fun argtypes list map argtypes appendix source files new back sig peter bertelsen december val string val string package java lang val object jvmtype jclass val bytecode methodref val bytecode methodref val number jvmtype jclass val intvalue bytecode methodref val bytecode methodref val bytecode methodref val integer jvmtype jclass val bytecode methodref val long jvmtype jclass val bytecode methodref val double jvmtype jclass val bytecode methodref val string jvmtype jclass val bytecode methodref val bytecode methodref val bytecode methodref val bytecode methodref val bytecode methodref val jvmtype jclass package sml lang val block jvmtype jclass val bytecode fieldref val tuple jvmtype jclass val bytecode fieldref val bytecode methodref val ref jvmtype jclass val bytecode methodref val constructor jvmtype jclass val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode fieldref val bytecode methodref val bytecode methodref val closure jvmtype jclass val bytecode fieldref val bytecode fieldref val bytecode methodref val bytecode methodref val exception jvmtype jclass val bytecode fieldref val bytecode methodref val bytecode methodref val general jvmtype jclass val bytecode fieldref val vector jvmtype jclass val bytecode fieldref val bytecode methodref val jvmtype jclass val bytecode methodref val util jvmtype jclass val bytecode methodref tag sig peter bertelsen december tag type tags val tag val fromint int 
tag val toint tag 
int val tostring tag 
string val compare tag tag 
order val tags val tags 
tags tag val tags 
tag tag sml peter bertelsen december datatype tag tag int datatype tags tags int val tag fun fromint tag fun toint tag appendix source files new back fun tostring tag int tostring fun compare tag tag int compare val tags fun tags tags tag fun tags tag compiler sml adopted moscow ml version modified peter bertelsen december open obj mixture const lambda prim globals location units types parser elab front jvmcode jvmtype bytecode runtype error val true flag show lambda code lifting 
lexer stream fun lexing fn buff 
fn 
buff parsing functions fun fun skip case eof 
semicolon 
skip handle 
skip handle parsing parseerror 
val pos lexing val pos lexing lexer obj repr eof orelse obj repr semicolon skip loc pos pos errprompt syntax error msgeol raise toplevel msg pos pos 
pos andalso pos loc pos pos errprompt lexical error msgstring msg msgstring msgeol skip raise toplevel toplevel 
skip raise toplevel fun val phr handle 
lexer parsing raise lexer parsing phr val parser lexer token val parser lexer token val parser lexer token fun acc acc rest acc list exists fn 
acc rest acc rest acc fun env fn 
fn 
fn acc 
acc env reporting results compiling phrase val verbose ref false fun id status case status 
msgstring 
msgstring infix msgstring 
msgstring infixr msgstring msgstring id fun equ msgstring case equ 

eq 
fun val vs info val lhs map vs lhs fun val val info case appendix source files new back 
msgstring type vs tau 
val lhs map vs msgstring type lhs tau lhs msgstring tau dt 
val uname qual val sign uname location uname val ce sign dt null ce msgstring abstype msgstring datatype 
fun id id handle subscript 
fun app fn 
msgeol app fn id tn 
tn msgeol app fn id sch 
val status id msgstring case info status varname 
val 
val 
con 
exn 
con msgstring id msgstring sch msgeol write signature unit currently compiled value written twice unclear open file read write mode caml light program 
fun val ref val ref val os os os os handle 
os remove raise val val input md sum string 
string md sum size raise size remove md sum handle 
remove raise val os output os os os handle 
os remove raise checks error messages compiling units fun msg loc id uname id uname loc errprompt error msgstring msg msgstring name file name incompatible msgeol raise toplevel fun access fun remove fun appendix source files new back errprompt file msgstring msgstring compiled msgstring msgeol raise toplevel fun errprompt file msgstring msgstring exists signature constraint msgstring msgeol raise toplevel compiling signature fun spec val spec val te spec te verbose te fun uname filename val filename sig val filename ui val msgstring compiling file msgstring msgstring msgeol val uname val val val val fun specs app specs signature uname app specs inputstream ignore ignore handle 
raise compiling implementation fun te re te re verbose te fun key tbl case peek tbl key 
false 
true fun list filter fn idg 
id fun list filter fn id stamp 
id fun uname jvmcode jvmcode val fclass names exns jvmcode val val case 

fun qid uid idg ne names exns qual classname class val name id val rtobject export trueg binarymap insert names name add exns uid ne fun id exportenv val qid uname id idg binarymap insert exportenv qid qid val names exns list foldl names exns val exportenv list foldl binarymap names names exns exns exportenv appendix source files new back fun exportenv lams val binarymap uid 
runtype val binarymap tag compare tag 
uid fun lprim uid arg ge val uid export case binarymap peek exportenv uid 
uid false uid 
uid true val idg uid val name id case arg lprim pclosure tag spec spec 
binarymap insert ge uid tag spec binarymap insert tag name export lprim pclosure 
binarymap insert ge uid 
binarymap insert ge uid rtobject note assumed global names lifted code bound way lprim uid arg 
list foldl lams fun exportenv exportenv fun uid uid print uid uid binarymap exportenv print exporting binarymap app exportenv fun fun lams list app fn lam 
lam print lams list foldr fun lams fun lam lam print list foldr lams fun free freeenv app fn 
print int tostring free fun fun ftag free depth print closure tag tostring tag depth int tostring depth free print free body print list app fun fun ftag free nargs depth print method tag tostring tag depth int tostring depth free print free int tostring nargs args body print list app fun uname filename decs val filename sml val filename ui val filename class val jvmtype name val uname val val val ref side effected lift val ref side effected lift fun dec val dec dec val te dec val dec val re lams dec te re lams val exportenv jvmcode note lifting limiting scope binding give gc chance get rid original lambdas build list lists lambdas list lambdas corresponds top level declaration val list foldl decs create stub jvm code side effected val jvmcode prepare exports module val exportenv exportenv uname jvmcode val exportenv val print lifting lift lambdas creating list lifted lambdas reversed order compared original sequence top level declarations appendix source files new back val list foldr lift print lifting exportenv jvmcode val exportenv val closureenv closureenv ref ref binarymap tag compare closureenv map closure tag free variable runtype map maps free variable index runtype closureenv side effected generate code backwards top level lambdas exportenv closureenv jvmcode generate code pending closures methods exportenv closureenv jvmcode exportenv closureenv jvmcode complete generated code build target class jvmcode fun uname filename val filename sig val filename ui val filename sml val val fun decs true uname filename uname decs false uname filename decs structure uname false uname filename decs structure uname signature uname true uname filename uname decs inputstream handle 
raise sml adopted moscow ml version modified peter bertelsen september open list mixture const prim lambda globals units types front signature matching fun sign csig id find sign id handle subscript 
errprompt type msgstring id msgstring specified signature defined unit body msgeol raise toplevel fun sign csig id find sign id handle subscript 
errprompt value msgstring id msgstring specified signature defined unit body msgeol raise toplevel fun sign csig id find sign id handle subscript 
errprompt value msgstring id msgstring specified signature defined unit body msgeol raise toplevel fun id errprompt mismatch specification value msgstring id msgeol errprompt signature implementation unit body msgeol appendix source files new back raise toplevel fun id errprompt mismatch specification value constructor msgstring id msgeol errprompt signature implementation unit body msgeol raise toplevel fun id errprompt mismatch specification exception constructor msgstring id msgeol errprompt signature implementation unit body msgeol raise toplevel fun tn val vs info tn vs map vs tn fun ts case info 
ts pars body 

ts tn 
val arity list length ts val tn 
arity case 
ts tn pars body 
zip pars ts body 
ts tn 
fun ue tau case tau var 
lookup var ue handle subscript 
unknown variable 
ue ue cont ts tn 
tn map ue ts rect rt 
val fs rho rt rect ue fs rho fun false false false fun val tv false false false tv explicit tv fun vs tau vs tau val ts map fn 
vs val ue zip vs ts val tau ue tau val ue zip vs ts val tau ue tau unify tau tau true handle unify 
false fun ce ce val map fn gci 
id gci ce val map fn gci 
id gci ce non empty abstype allowed signatures primitive types represented 

errprompt realization mismatch variant type constructor msgstring id msgeol errprompt specification realization differ msgeol errprompt names order value constructors msgeol raise toplevel don compare types constructors compared values 
note constructors visible redefining values signatures allowed 
fun refresh var typevar val var val tv false tv explicit tv fun refresh typevar var typevar val var false fun csig csig apply fn uname 
fn stamp 
appendix source files new back val stamp find uname stamp 
stamp errprompt signature msgstring uname msgstring changed msgstring uname msgstring sig depends msgeol errprompt please recompile msgstring uname msgstring sig compiling msgstring uname msgstring sml msgeol raise toplevel handle subscript 
fun val ref val ref fid gg 
errprompt arity mismatch type constructor msgstring id msgstring specified having arity msgeol errprompt declared having arity msgstring unit body msgeol raise toplevel case 

errprompt type constructor msgstring id msgstring specified msgeol errprompt isn realized msgeol raise toplevel 
errprompt type constructor msgstring id msgstring specified admitting equality msgeol errprompt realization doesn admit equality msgeol raise toplevel 
case 
info 


fun csig csig val ref val ref fid gg case 
vs tau 
case 
errprompt realization mismatch type constructor msgstring id msgstring specified msgeol errprompt type abbreviation msgeol errprompt implemented primitive type msgeol raise toplevel vs tau 
vs tau vs tau errprompt realization mismatch type constructor msgstring id msgstring bound msgeol errprompt non equivalent type abbreviations msgeol errprompt signature unit body msgeol raise toplevel 
errprompt realization mismatch type constructor msgstring id msgstring specified msgeol errprompt type abbreviation msgeol errprompt implemented variant type msgeol raise toplevel tn 
dt 
val ce dt case 
errprompt realization mismatch type constructor msgstring id msgstring specified variant type msgeol errprompt implemented primitive type msgeol raise toplevel vs tau 
errprompt realization mismatch type constructor msgstring id msgstring specified variant type msgeol errprompt implemented type abbreviation msgeol raise toplevel dt 
val ce dt ce ce tn 

fun id val vs val ts map fn 
refresh vs appendix source files new back val ue zip vs ts val tau ue tau val vs tau val ts map fn 
refresh typevar vs val ue zip vs ts val tau ue tau unify tau tau handle unify 
val ts map vs val ue zip vs ts val tau ue tau errprompt type mismatch value identifier msgstring id msgstring signature type msgeol errprompt tau msgeol errprompt implementation unit body type msgeol errprompt msgeol raise toplevel fun id thing 
errprompt specified signature expects msgstring thing msgstring msgstring id msgstring defined msgeol errprompt unit msgstring msgstring defined unit msgstring msgeol raise toplevel fun true lprim lprim fun pi true lprim pi fun ci true lprim ci fun ei true lprim ei fun lams val info val info val val id idg case varname 
id value case varname 
val id 
lams lams pi 
pi lams ci 
ci lams ei 
ei lams 
id pi 
id case varname 
id pi 
pi pi lams id ci 
id ei 
id 
id ci 
id value constructor case varname 
id pi 
id ci 
ci 
ci orelse ci 
ci orelse ci 
ci orelse ci 
ci id lams ei 
id 
id ei 
id exception case varname 
id pi 
id ci 
id ei 
ei 
ei orelse ei 
ei id lams 
id 
case varname 
id pi 
id ci 
id ei 
id 
lams fun csig csig val matching stamps mentioned signatures val type realization apply fn id 
fn 
id val apply fn id 
fn 
appendix source files new back id val matching value types apply fn id 
fn 
id id status matching may cause code generated case primitive function value constructor exported value fold fn id 
fn 
fn lams 
id lams appendix test programs andalso sml val util println true andalso false true andalso false sml val val arg dav arg arg clos sml val fn 
clos sml val val fn 
val util println appendix test programs clos sml val fn 
fn 
val val util println clos sml val fn 
fn 
val val fn 
util println val clos sml val fn 
val fn 
val fn 
fn 
fn 
val fg val util println fg clos sml fun val fun val util println clos sml val val fn 
val fn 
val fn 
fn 
fn 
util println clos sml val val fn 
val fn 
val fn 
val fn 
fn 
val fn 
fn 
util println clos sml val fun id util println id fn 
clos sml fun fun fn 
val fn 
val util println val val fn 
clos sml fun val val fn 
util println appendix test programs div sml val val div handle div 
val div handle 
val val div handle div 
val util println exn sml exception exception local exception val exception exception fun raise unit fun raise unit val handle 
handle 
util println exn sml exception slam fail fun raise slam 
util println val handle slam 
util print caught exception util println val handle 
raise slam zap val util println exn sml val val val div handle 
util println exn sml exception zap string val fun raise zap int val val handle zap 
util println exn sml fun exception slam raise slam unit val exn sml fun exception slam raise slam handle slam 
val appendix test programs exn sml val exception slam fun raise slam handle slam 
util println exn sml val exception slam val slam fun exception slam raise handle slam 
util println exn sml fun val val util println exception string local exception int exception exception string exception fail val util println slam bam oops exn sml val open exn util println util println zap fail bingo exn sml open exn val util println util println zap fail bingo exn sml val open exn util println util println zap fail bingo sml val fn 
fn 
val util println sml val util println true appendix test programs sml fun app fun app app xr app xr app fun util print case 



val app util println sml fun mem int list false mem xr orelse mem xr val xs val ys val util println mem xs mem ys sml val val val mod div val util println val val val util println sml fun int util println util println 
val sml val val util println val util println val util println util println letrec sml val fun util print util println util print util println util print util println letrec sml val fun util print util println util print util println util print util println appendix test programs sml fun ints fun ints ints ints ints fun util println nil xr util println xr fun util println nil xr xr util println val xs ints val xs util println xs xs sml fun val util println false true true false orelse sml val util println false orelse true false orelse true overflow sml val val min val max val min handle div 
overflow 

val max handle overflow 
div 

val div handle div 
overflow 

val min div handle overflow 
div 

val handle div 
overflow 

val max handle div 
overflow 

util println sml fun mem false mem xr orelse mem xr val val xs val ys val zs util println mem xs mem ys xs ys xs zs val val xs val ys val zs util println mem xs mem ys xs ys xs zs val val xs val ys val zs util println mem xs mem ys xs ys xs zs datatype int real string val util println util println slam appendix test programs sml fun app fun app app xr app xr app fun util print case 



val app util println sml fun mem real list false mem xr orelse mem xr val xs val ys val util println mem xs mem ys sml fun real util println util println 
val sml datatype option ref val val ref val util println sml fun util println val 
unit util println sig sig type datatype val int 
val 
sig sml datatype int real datatype fun val sml fun app fun app app xr app xr app fun util print case 



val app util println appendix test programs sml fun mem string list false mem xr orelse mem xr val xs val ys val util println mem xs mem ys sml size string 
int sub string 
int 
char val util println size slam sub slam sml fun string util println util println 
val dav dav switch sml datatype int real string fun println util println println util print util println println util print util println println util print util println val println println println println slam tostring sml val util println slam true ref fn 
sml val val ref util println util println lift appendix test programs bibliography bertelsen 
semantics java byte code 
technical report department mathematics physics royal veterinary agricultural university copenhagen denmark april 
available www dina dk 
gosling java language specification 
addison wesley 
isbn 
reppy standard ml basis library 
technical report bell labs lucent technologies 
available www cs bell labs com sml basis 
lindholm yellin 
java virtual machine specification 
addison wesley 
isbn 
milner tofte harper 
definition standard ml 
mit press 
milner tofte harper macqueen 
definition standard ml revised 
mit press 
martin odersky philip wadler 
pizza java translating theory practice 
proc 
th acm symposium principles programming languages pages january 
bertelsen 
unofficial java spec report 
available www demon uk java 
issue released november 
sestoft 
moscow ml language overview version july 
available www dina dk sestoft html 
sestoft 
moscow ml owner manual version july 
available www dina dk sestoft html 

