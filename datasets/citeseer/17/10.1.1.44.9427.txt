application framework compositional modularity banavar dissertation submitted faculty university utah partial fulfillment requirements degree doctor philosophy department computer science university utah december copyright fl banavar rights reserved university utah graduate school supervisory committee approval dissertation submitted banavar dissertation read member supervisory committee majority vote satisfactory 
chair gary lindstrom robert kessler joseph zachary university utah graduate school final reading approval graduate council university utah read dissertation banavar final form format citations bibliographic style consistent acceptable illustrative materials including figures tables charts place final manuscript satisfactory supervisory committee ready submission graduate school 
date gary lindstrom chair supervisory committee approved major department thomas henderson chair dean approved graduate council ann hart dean graduate school dissertation presents framework application compositional modularity module model facilitates extensive reuse highly decomposed software 
compositional modularity supports traditional notions program decomposition encapsulation effective mechanisms module recomposition 
previously developed model suite operators individually achieve effects adaptation combination simple notion modules viewed self referential namespaces 
dissertation extends previous model introducing notion hierarchical nesting composition operation 
furthermore shows compositional modularity unifying scope 
important effects idioms advanced modularity including varieties inheritance object oriented programming find convenient expression model 
compositional modularity applied wide range systems manipulate self referential namespaces 
demonstrate distinctively differing systems model interpreter module extension programming language scheme programmable linker composing compiled object files compiler front compositional interface definition language compositional document processing system 
shown systems derive important benefits incorporating compositional modularity 
facilitate application compositional modularity model realized generic reusable software architecture object oriented application framework named etyma 
etyma comprises collection interacting classes corresponding essential concepts model 
framework may reused efficiently build completions tools compositionally modular systems 
systems mentioned previously built direct completions etyma fourth evolved parallel framework 
significant design code reuse achieved construction system prototypes completions framework 
contents iv list figures list tables xii acknowledgments xiii chapters 
composition reuse compositional modularity compositionally modular systems application framework completions dissertation organization 
setting stage modules module systems classical module systems object oriented programming 
compositionality formal characterization generator manipulation static typing summary 
compositionally modular scheme modules instances encapsulation combination attributes access modules adaptation introspection single inheritance super single inheritance prefixing wrapping idioms cms multiple inheritance mixins linearized mi mi common ancestors mi common ancestors related summary 
module nesting goals benefits nesting cms lexical nesting retroactive nesting applications nesting name space control sharing modeling manager modules hierarchy combination semantics importation closed generators imperative closed generators static typing discussion related summary 
etyma framework oo frameworks design patterns design etyma concepts relationships classes value classes class module 
classes record instance 
classes function method 
classes location 
type classes classes 
classes interface 
class 
class 
recursive types 
concrete classes implementing cms completion vii reuse issues designing reuse documenting reuse framework evolution related smalltalk clos summary 
composition object modules motivation application composition linkage scenario architecture conceptual layering application construction omos server object module management classes instances modules encapsulation instances inheritance wrapping single multiple inheritance solving old problems type safe composition motivation scenario type system type equivalence subtyping implementation omos type safe linkage related omos type safety summary 
interface composition software architecture description interface definition languages compositional interfaces type generators experimental idl viii making idl compositional related summary 
document composition applications document composition report generation architectural specifications revision control system document composition documents compositional modules mt architecture implementation summary 
summary contributions directions framework enhancements completions version management distributed programming ix list figures 
generator definitions primary module combinators 
basic module operations 
module adaptation operations 
pictorial representation adaptation 
introspection operations 
super single inheritance 
prefix inheritance 
pictorial representation single inheritance 
wrapping calls methods 
idioms cms 
linearized multiple inheritance 
multiple inheritance common ancestors 
multiple inheritance common ancestors 
examples nested modules 
example hierarchy combination 
hierarchy combination example shown pictorially 
type rule nest operator 
oo diagramming conventions 
overview classes 
pseudo code template method merge 
overview type classes 
overview concrete classes 
architecture cms interpreter 
subclasses framework classes implement cms 
architecture object file composition 
syntax module primitives 
examples wrapping omos 
wrapping scenarios 
linkage adaption 
subtyping primitive data types 
automatic data coercion language rules 
automatic conversion structs structural subtyping 
programmer defined data conversion 
architecture idl front 
example specifications extended idl 
example report generation 
mt module syntax 
example mt document module 
sample mt primitives 
architecture mt system 
xi list tables informal type rules module combination 
design patterns describe etyma 
reuse design code cms 
type equivalence ansi reuse design code idl 
reuse design code mt acknowledgments foremost go gary lindstrom research advisor 
remember weekly meetings gary ideas 
learned things technical gary 
performing stood shoulders individuals particular 
gilad bracha dissertation paved way 
owes continued involvement including willingness serve formally committee 
second doug orr omos system absolutely essential 
stk package eventually led development cms language 
bob kessler joe zachary mark swanson serving members committee 
jay lepreau feedback encouragement played significant role 
robert mecklenburg critical outlook lively presence talks educational 
want acknowledge wayne thoughts document processing 
parents supported unfailing trust encouragement 
grandfather constant source inspiration childhood 
rest family especially rama support ways 
utah computer science department wonderful place 
members computer systems laboratory great group learn 
jeffrey law pete provided implementation systems help 
quite gotten unix system people especially scott jimmy 
front office staff shawn monica efficient help 
friends utah stay memorable 
particular remember time spent jim elena kumar ravi ranjan group drama group students indian community 
spent memorable times friends outside utah past years especially raghu 
spouse individual responsible continued motivation 
sounding board ideas 
dissertation owes great deal 
defence advanced research projects agency funding research projects possible 
xiv chapter modularity fundamental facility controlling complexity large systems decomposition abstraction 
particular software modules allow programmers develop maintain pieces large system relatively independent 
decomposition support software component reuse widely accepted enabler efficient construction large systems 
necessary provide mechanisms effective recomposition conforming modules composed obtain modules 
dissertation focuses problem linguistic mechanisms broad applications module composition enables high degree reuse 
compositional modularity model supports simple notion modules powerful notion composition 
model unifies advances existing notions modularity 
ultimate goal compositional modularity enable maximal reuse software components 
encourages breaking software smallest possible independently meaningful units fosters extensive reuse providing sophisticated reliable mechanisms build complex programs pieces 
furthermore model realized reusable software architecture 
enables efficiently construct tools compositionally modular systems 
dissertation presents consolidated account model compositional modularity formulation reusable software architecture 
additionally dissertation demonstrates model sufficiently general applied broad spectrum computer software systems 
composition reuse term software composition broad mean number ways putting software 
instance functional programming composition conforming functions understood concept 
data flow programming conforming data filters composed process data compound ways 
conventional modular programming collection software modules interact calling functions said composed system 
dissertation addresses software composition variety composing interfaces implementations software modules obtain new modules 
composition framework typically requires components meet specific criteria order composable 
furthermore properties composition derived properties constituent components 
instance case function composition functions conforming types composable type composite functions derived types constituent functions 
similarly module composition framework described modules conforming types composable type resultant module derived types constituent modules 
furthermore modules framework self referential structures self referential structure resultant module derived self referential structure constituent modules 
composable software components reused situations single component built purpose participate multiple applicable compositions 
programmer point view effective software composition mechanism enables incremental programming 
new components need developed support incremental functionality existing components new components composed existing ones 
dissertation shows effective module composition mechanism enable significant software reuse 
important advantages software reuse 
potential considerably reduce cost program development 
reusing tested code opposed writing new code usually results increased reliability 
reusable software helps control problems associated software maintenance evolution 
furthermore mechanisms software reuse necessary step way longstanding dream shelf pluggable software parts factories 
traditional notion software reuse code reuse obtained function code libraries 
widely agreed software design reuse equally important 
design software embodied decomposition structure interfaces decomposed units 
said accomplished software design reuse reuses decomposition structure interfaces existing software 
order achieve practical reuse software designed specific goal reuse mind 
manner decomposition system modules design module interfaces manner implementation modules factors dictate reusability modules 
reuse clients need know module reused specified interface reuse dependencies informative documentation needed 
set modules designed reusable linguistic mechanisms supported compositional modularity possible reuse 
fact said design reusable software constrained mechanisms eventually reused 
linguistic mechanisms sufficient reuse greatly influence reuse certainly necessary enabling principled reliable efficient reuse 
instance typing discipline require programmers explicitly declare interfaces reusable components type system verify interfaces reused client components conform compiler may able generate efficient code reused software type information 
section introduces model compositional modularity 
compositional modularity somewhat independent lines development modularity programming languages 
notion decomposition programs modules interactions controlled traditional module systems environment tools 
traditional module systems typically support important features encapsulation notion externally visible interface module separated hidden implementation static checking type conformity module interactions imports exports lexical nesting modules 
features widely acknowledged facilitate independent development maintenance modules 
line development notion data abstraction support programmer defined data types data types adts classes object oriented programming 
adts classes represent decomposed program pieces support encapsulation static type checking nesting 
classes may usually larger classes mechanisms inheritance 
oo inheritance linguistic mechanism supports reuse incremental programming program describing software component differs existing 
compositional modularity represents advancement line development achieve surpass goals 
compositional modularity surpasses class inheritance supports stronger flexible notion reuse traditional oo systems 
aspects model compositional modularity modules composition 
module simply collection names associated bindings may turn names defined module external module 
modules adapted fitted various ways compose modules turn entire systems putting lego pieces 
accurate module modeled abstracted namespace namespace abstracted names referenced 
abstracted namespaces manipulated desirable ways instantiating concrete namespaces 
manipulation performed suite operators achieves individual effect encapsulation rebinding hierarchical nesting 
technique shown rest dissertation enable high degree adaptability flexibility manipulation enhanced reuse 
significant characteristic model unifying scope captures existing notions modularity including varieties oo programming 
tasks undertaken dissertation demonstrate detail expressive power model emulating various existing models modularity 
significant characteristic model 
say model analyzed committing nature actual values bound names modules 
model independent particular underlying computational paradigms 
property advantage developing application framework outlined section 
introducing model compositional modularity important acknowledge lineage 
semantic foundations model go back record calculi pioneered cardelli mitchell 
classes modeled record generators records abstracted cook introduced operators manipulate generators 
bracha lindstrom idea oo inheritance really form modularity introduced comprehensive suite operations manipulate record generators 
furthermore bracha expressed model abstractly suggested formulated framework 
dissertation advances semantic models proposed previously introducing notion compositional nesting 
problem previous models direct lexical nesting modules restricts reuse nested modules 
compositional nesting possible retroactively nest independently developed module conforming module composition operation 
mechanism supports enhanced compositionality reuse 
bulk contribution research practical application semantic model various systems engineering reusable software architecture facilitate application described 
compositionally modular systems important idea put forth model compositional modularity applicable wide range systems explicitly 
stems partly simplicity model partly pervasiveness modularity namespace manipulation software systems 
compositional modularity supports reuse akin oo inheritance means operations self referential namespaces 
key insight wide range software artifacts modeled self referential namespaces 
instance known recursive interface types viewed self referential namespaces 
traditional compiled object file viewed self referential namespace 
furthermore structured document fragments modeled self referential namespaces 
artifacts gui components file system directories regarded recursive namespaces 
currently exists range tools manage range artifacts mentioned 
tools usually disparate impoverished underlying models 
argued advantageous manage artifacts viewpoint understood model compositional modularity design tools viewpoint 
primary advantage approach underlying model tools significantly enriched reuse mechanisms akin oo inheritance supported artifacts manage 
uniformity underlying model tools exploited support better interactions 
model compositional modularity easily effectively applied systems manipulate artifacts ones 
demon strate dissertation considers radically differing systems describes construct tools 
way systems modeled compositionally benefits derived viewing 
scheme module composition 
conventional programming language scheme notion module independent naming scope 
module comprises set identifiers bound locations variables various scheme values including procedures 
procedures may contain name bindings module 
manner scheme module may modeled self referential namespace 
module systems scheme proposed previously systems mainly provide facility structuring programs decomposition 
ability class modules additionally support design implementation reuse akin inheritance oo programming 
furthermore notion class modules operations consistent uniform class values expression oriented nature scheme 
consequently argue incorporation compositionality module system scheme beneficial 
ii 
object module composition 
separately compiled object file essentially consists set symbols associated data code 
set symbols represented symbol table object module 
furthermore internal symbols represented relocation information object module 
object file modeled self referential namespace 
traditional notion linking object files corresponds rudimentary notion composition 
full power compositional modularity available programmable linker significantly enhance ability manage bind object modules 
particular facilities function interposition management incremental additions functionality libraries namespace management principled flexible 
iii 
interface composition 
interface essentially naming scope labels bound types 
type constituents interface recursively refer back interface 
interface regarded self referential namespace 
explicit specification composition interfaces embodied interface definition languages idls necessities modern distributed systems 
composition interface specifications help reuse evolution interface specifications 
iv 
document composition 
document regarded naming scope consisting section names associated arbitrary text 
furthermore cross textual body section names 
document composition useful enterprises documents fragments generated edited composed maintained delivered various ways 
document fragments generated purpose reused purposes 
example report user manual composed document fragments design documents 
application framework dissertation presents framework applying concepts compositional modularity 
shows identify compositionally modular systems model modules systems build tools systems 
sense provides conceptual application framework compositional modularity 
term application framework precise technical sense 
oo application framework realization design application software particular application domain 
framework captures essential concepts domain set interacting classes 
individual applications called completions built extending framework specific directions filling incomplete parts framework 
oo programming provides forms effective software design reuse mechanisms inheritance polymorphism suitable developing application frameworks domains user interfaces operating systems commercial business applications 
main point application frameworks enable applications particular application domain reuse design associated code common domain 
argued earlier significantly reduce resources spent developing applications increase reliability applications 
furthermore argued studying application framework particular domain efficient way understand domain framework represents model domain 
naturally implementations tools mentioned share common compositional modularity 
beneficial common aspects realize reusable software architecture 
dissertation presents oo application framework compositional modularity realized language 
framework known etyma consists concrete classes corresponding concepts commonly compositionally modular systems 
instance high conceptual level systems primarily consist domain values corresponding domain types 
slightly detailed level typed values include modules methods constituting attributes 
types values known interfaces function types respectively 
etyma includes classes corresponding concepts 
etyma deliberately stops short completely specifying details concepts precise nature module attributes 
details supplied individual completions details differ completion completion 
instance module attribute may programming language function completion may completely different fragment text completion 
framework differences kinds module attributes abstracted away viewed single interface 
architecture etyma framework documented dissertation concept design patterns 
version etyma documented comprises reusable classes lines evolved iterations years 
tool system compositional modularity said consist front reads command data input processing engine performs compositional operations internal representation ir optional back transforms ir external representation 
primary utility etyma framework enables easily rapidly build processing engines front ends back ends tools 
tool front etyma classes construct ir module source 
module manipulation commands translated operations ir 
manner interpretive processors directly manipulate ir processors compilation additionally provide back appropriately translates ir target representation 
completions order construct processing engine tool compositionally modular system identify various kinds name bindings comprising namespaces system 
identify generalizations concepts specified classes etyma framework 
general etyma class subclass implement specific concept system 
specialized classes relevant concepts defined said modeled system completion etyma 
dissertation completions etyma corresponding tools systems mentioned section 
constructed direct completions framework resulted significant design code reuse 
fourth evolved parallel framework termed parallel completion 
module extension scheme called compositionally modular scheme cms short chapters 
implementation interpreter cms direct completion etyma chapter 
programmable linking tool compiled language code supports compositional modularity chapter 
parallel completion etyma tool framework strongly influenced development 
tool class design framework physically derived framework 
compiler front experimental compositional interface definition language derived direct completion etyma chapter 
outline extend base language corba idl 
compositionally modular document processing system called mt layered top document preparation language chapter 
mt direct completion etyma 
dissertation organization chapter presents foundational motivational concepts compositional modularity 
particular starting point embodied programming language jigsaw detail 
chapter demonstrates expressive power compositional modularity examples shown language cms 
focus emulating important idioms styles oo programming 
chapter illustrates programming style associated compositional modularity 
chapter treats detail new notion compositional nesting embodiment cms 
applications nesting sharing inheritance hierarchy combination explored 
chapters provide reader thorough understanding nature power compositional modularity 
application framework etyma described chapter 
design concrete classes detailed 
immediately implementation interpreter cms completion etyma delineated 
reuse aspects etyma evolution reuse iterations explained 
chapter describes application compositional concepts object modules 
software architecture enables construct entire applications individual components concepts explained 
chapter shows interfaces treated compositional entities describes design idl compiler completion etyma 
system document module composition chapter 
chapter points summarizes accomplishments presents 
points dissertation denotational semantics mathematical formalisms expository tools 
apparent purpose formalism develop complete theory express ideas precise manner clarify relate previous area 
chapter setting stage chapter basic concepts problems motivate framework dissertation 
classical modularity primarily concerned support decomposition encapsulation static typing lexical nesting 
addition features compositional modularity aims support effective software reuse notions module adaptation composition 
historical progression increasing support modularity programming languages systems examined section leading ideas underlying compositional modularity 
particular salient features classical module systems oo programming languages examined 
shown module systems fall short fully supporting reuse 
notion compositional modules abstracted namespaces developed section 
prominent characteristics model compositional modularity described concisely section 
fundamental concepts record generator manipulation static typing summarized section 
modules module systems intuitively software module understood independent unit software defined interface 
module system model supports definition manipulation modules 
module manipulation concerned composing modules adapting necessary order maximize utility 
modules client software invoking interface offered possibly instantiating 
module systems proposed date detailed semantics vary greatly especially far support module manipulation concerned 
classical module systems support notion modules design time program decomposition structuring mechanism barely support module manipulation 
extreme current day oo systems viewed advanced module systems support various forms composition reuse inheritance 
classical module systems simplest understanding module environment binds names values namespace 
names module directly accessible internally module subset names called interface exported module external access 
example modules structure construct standard ml generalized record type value structure components public interface signature 
enforce stronger separation modules systems require interactions modules declared explicitly importing names interfaces modules 
examples module systems modula family scheme module system ref 

typically systems perform level static conformance checking compile time binding link time imports exports modules 
completely dynamic importation proposed 
way specify modules describe completely scratch 
complete specification facilitate reuse portions module potentially common modules 
support reuse better modules parameterized free names module sml functors ada generic packages 
parameterized module multiply instantiated usually run time actual argument values produce concrete modules manner completely specified modules 
despite support import export parameterization module systems significantly impoverished support primary goals decomposition encapsulation reuse 
instance decomposition fixed module definition time module boundaries interactions modified 
public interface module changed fact 
parameterized modules reused instantiating multiple times various argument values mechanisms control bindings names module parameters 
fact systems way module manipulation instantiate parameterized module 
clearly flexible expressive module systems needed 
step direction taken tung supporting simple notion renaming imported names conflict defined module 
support full compositionality reuse requires ability perform operations modules described 
dimension development modularity programming languages considered class run time entity 
value called class passed functions stored variables part data structures programming language 
module systems traditionally regarded design time facility 
languages sml support compile time module language separate core language 
systems usually think modules class run time values producing class run time values 
compelling arguments viewing instances modules class values 
languages support form data abstraction facility instantiated class values data types adts classes 
modules support design time abstraction may desirable mechanism uniformly primary abstraction facility 
furthermore module systems facilitate manipulation namespaces 
namespaces exist environments run time natural support modules class entities 
additionally results uniformity manipulable values 
languages pebble support class modules 
worth mentioning support higher order modules necessarily mean modules class 
instance higher order sml module system ref 
support functors functor parameters higher order modules 
functors run time entities class 
alternatively case functors may considered class respect sml module language respect sml core language 
enormously enhance reusability modules 
instance expressions modules allow various module manipulation mechanisms usefully composed obtain composite effects 
familiar expressive base language mechanisms conditionals functions create modules dynamically 
examples class modules chapters particularly section 
object oriented programming described section typically supports class instances classes modules occasionally class classes 
object oriented programming support data abstraction reuse motivating forces classes various forms inheritance oo programming 
object oo programming abstraction real world entity 
object implements behavior exposed interface 
objects collaborate objects perform user level tasks exchanging messages 
receiving message appropriate method implements behavior associated message located executed 
common characteristics collection objects captured concept class may instantiated individual objects 
classes oo programming essentially correspond notion modules support requirements program decomposition encapsulation reuse inheritance described 
characteristics distinguish oo programming encapsulation notion implementation details object hidden clients inheritance mechanism class reuse design code classes polymorphism notion object context requires subset functionality exported interface 
characteristics interact important ways 
understanding interactions supporting compromising integrity serious research direction past years 
encapsulation primary requirement large scale software development 
implementor free modify implementation module long interface module contract clients changed 
expressiveness interface satisfactorily state contract crucial issue day techniques typically employ notion type specification express contract expressive mechanisms ref 
studied 
mechanism inheritance supports incremental programming 
programmer specify module stating implementation differs existing module 
result inheritance primary implementation reuse mechanism oo programming 
inheritance gives rise implementation hierarchy modules thought implemented hierarchy modules 
inheritance violate encapsulation 
inheritance history module purely implementation detail exposed interface 
happen classes identified types described ancestors inherited multiple inheritance paths shared 
seemingly innocuous situations class cease valid inheritance relationships classes implementation detail changed 
furthermore implementation module directly depends inherited ancestors naming reusability compromised 
extended treatment problems violation encapsulation reader referred bracha thesis chapter 
interface supported objects class called type 
oo programming languages equate concept class type 
type interface partial description behavior class implementation behavior represented type 
interface supports functionality possibly called subtype 
polymorphism accurately inclusion polymorphism direct consequence subtyping relationships objects types 
polymorphism usually implemented techniques late binding method calls actual code implements methods 
polymorphism important reuse mechanism oo programming functions written particular types objects reused objects having subtypes 
question arises inheritance results classes generate objects subtype parent class 
answer 
sufficiently expressive language inheritance necessarily result subtypes 
reason contravariant subtyping binary methods 
inheritance widely understood implementation reuse mechanism divorced subtyping defines relationships objects 
high performance oo languages support static typechecking separate compilation classes impose special requirements implementation inheritance 
possible typecheck compile class knowledge interfaces inherited classes implementation class 
typically object layout information classes necessary 
furthermore ensured typechecked superclasses class continue type correct presence inheritance re typechecking superclass 
inheritance traditionally characterized operational mechanism 
denotational characterizations notion classes inheritance 
relevant due cook original formulation class viewed record abstracted notion self means 
symbols class abstracted self parameter 
furthermore inheritance viewed operation appropriately modifies self 
section puts context idea abstracting self 
shown namespace abstracted largely determines effectively flexibly modules may manipulated 

mentioned earlier module essentially namespace set names bound values 
modeled record lambda calculus function finite set names bindings 
value bindings may functions refer names shown box 
names namespace free 
crucial determine model 
central issue regard decide modules 
consider cases free variables 
module may abstracted free names referenced 
results parameterized module 
example namespace abstracted free parameterized modules may instantiated actual argument values produce concrete namespaces 
manner gets control bindings abstracted names namespace 
ii self 
technique step may desirable get control subset names names namespace 
necessary names namespace 
notion useful way specify default bindings abstracted names subsequently re bound 
goals achieved having modules namespace generated module notion self 
mentioned previous section cook idea lambda abstraction called generator shown 
formal parameter stands namespace notion self effectively abstracts names namespace 
namespace contains names bindings refer names abstracted parameter model binding rebinding names done operations generators appropriately manipulate parameter 
fact generators adapted combined useful ways instantiating 
examples shown section 
bracha shows notion abstracting self achieve comprehensive array individual effects inheritance 
furthermore generator instantiated fixpoint applying fixpoint operator individual instance concrete namespace 
notions explained detail section 
iii self surrounding environment 
model restricts reuse nested modules nested modules accessible outside nesting module prior instantiation outer module 
furthermore consider nested modules may refer names lexically surrounding environment 
may desirable hard wire nonlocal particular environment lexically nesting modules 
way enhance reusability nested modules provide control nonlocal 
done abstracting module surrounding environment 
shown lambda abstraction introduced known closed generator 
closed generator names environment module abstracted parameter 
instantiation time environment namespace bound desired 
closed generators permit retroactively embed module conforming environment 
notion developed chapter 


module namespace modeled record 
namespace abstracted free parameterized module 
module abstracted entire namespace self shown generator 
module abstracted self surrounding environment closed generator 
compositionality notion full compositionality modules unifies major ideas progressions module functionality 
supports encapsulation class modules variety inheritance idioms compositional nesting closed generators 
section concise description goals requirements full compositionality provided 
mentioned earlier ultimate goal compositional modularity simply get maximum possible implementation reuse components program 
order maximize reuse program decomposed smallest possible independently meaningful units 
programs broken units advantageous able put back ways profitably reused 
fact powerful mechanisms meaningfully combine reuse expect get 
viewpoint characterizes essence model compositional modularity 
way describe compositional modularity articulate set characteristics expected module models claim support 
desiderata module systems ref 
starting point list 
describe characteristics traditional modularity describe compositional modularity augments 
encapsulation crucial notion traditional modularity 
modules able hide implementation expose interface 
support nesting hierarchy central decomposition naturally leads hierarchy 
static type safety attained desirable possible 
addition add criteria compositionality 
notion composability says able combine modules produce new modules compatible interfaces 
notion applies combining modules level achieving hierarchical nesting 
second notion adaptability means able modify aspects module suitable reuse new ways 
examples adaptability renaming removal attributes 
practice satisfying requirements composability adaptability means module system supports flexible form inheritance supports large part spectrum effects obtainable single multiple inheritance various oo models 
requirements shown satisfied supporting primary module operators achieves individual effect composition modules 
operators combination achieve familiar varieties oo inheritance 
examples described detail chapters 
contrast common semantics inheritance oo languages classes inheritance composite notions fulfill variety roles 
example class defines module visibility attributes attributes defines type 
similarly inheritance supports class combination method redefinition access overridden methods name conflict resolution definition subtyping relationships types 
compositional modularity defined unification distillation forms modularity 
notion module simple notion abstracted namespace sophisticated forms manipulation performed modules 
simplicity notion module lends application broad range modular languages notions object file linking interface definition combination document manipulation 
fact general concepts compositional modularity abstracted expressed independent particular computational model base language 
generic model expressed oo manner constituting generally referred object oriented framework 
approach suggested bracha thesis engineering strategies implementation 
complete detailed description compositional modularity provided chapters presenting language embodying concepts 
formal characterization section summarize formal semantics jigsaw module language supports notions compositional modularity constitutes starting point research 
concepts section covered concrete context variant scheme chapter section may skipped loss continuity 
formal semantics extensions semantics formally rest dissertation 
generator manipulation semantics specified untyped lambda calculus see original description full details 
mentioned earlier basis generator semantics goes back record calculi 
record characterized function finite domain labels domain values 
label value pair called attribute 
operators records concatenation attribute overriding attribute removal renaming rename selection defined 
subscript signifies operations defined records 
module modeled record generating function generator 
domain equation example follow generator instance instance fa parameter corresponds generator notion self 
fixpoint generator record called instance module 
fixpoint generator binds generator self terms oo programming generator module corresponds class instance corresponds object class 
furthermore bindings labels refer labels defined generator 
undefined labels correspond pure attributes generator corresponds class 
classes instantiated access attributes undefined 
formal characterization reflects fact take fixpoint generator range function smaller domain 
modules combined suite combinators individually achieve effects inheritance 
shows definitions primary combinators merge override rename restrict freeze hide copy 
generator operators sans serif font uniformity rest dissertation 
operators take generators parameters produce new ones parameters modified appropriately 
example operator merge takes generators produces new generator body simple record concatenation records 
merge override rename fa bg rename defines fa bg restrict freeze fa ag hide freeze copy super super fb super ag 
generator definitions primary module combinators 
definitions unary operators involved interested reader referred ref 

chapter explains semantics operators examples idioms concrete context extension scheme language 
order model imperative semantics framework account effect instantiation store 
achieved augmenting semantics generators notion constructors 
augmentation fixpoint generator taken get constructor applied store get instance 
domain equations generator constructor constructor constructor store 
instance theta store modules class semantic entities module attributes modules 
nested modules contain free implicitly refer names surrounding lexical scope module environment 
semantics modeled passing environment argument semantic function creates constructors 
constructor retains environment created 
instantiation applied store extends retained environment bindings arising attribute definitions module 
imperative operators analogous applicative ones formulated 
shall omit details sake simplicity presentation applicative operators 
static typing module type called interface types attributes defined declared 
attribute said defined binds name value said declared simply specifies type binding 
example module defines attributes am values valid type signatures ff ff declares attributes valid type signatures ffi ffi module interface define ff am ff declare ffi ffi static type system determines type new modules generated module operators provided types incoming modules satisfy certain properties 
rules performing called type rules module combinator specified part jigsaw language 
detailed rules reproduced english transcription operator summarized table 
description attributes modules said conflict name 
furthermore subtyping relationships types exist particular computational base language 
subtypes induce partial ordering structure usually lattice structure types cases possible determine greatest lower bound greatest common subtype upper bound common supertype pairs types 
interface types subtyping type equality module operators require complete type information arguments polymorphic 
table 
informal type rules module combination 
operator typing merge module combine interfaces 
conflicting attributes definitions disallowed definition subtype declaration declarations replace greatest common subtype 
override module merge conflicting definitions allowed incoming definition subtype conflicting definition 
restrict label attribute defined 
freeze label attribute defined 
hide label attribute defined 
rename label label argument attribute exist declared defined second 
copy label label argument attribute defined second exist 
modules merge interface resultant module combination interfaces incoming modules 
types nonconflicting attributes modules included resultant 
conflicting attributes cases follows 
conflicting defined attributes altogether disallowed 
defined declared defined attribute included resultant subtype declared 
declared attribute type resultant module greatest common subtype conflicting types 
type rule override operator merge case conflicting defined attributes 
case right operand subtype left attribute resultant module specific type subtype 
type rules restrict freeze hide require attribute defined module 
rename operator requires argument attribute defined declared module second argument defined declared 
copy operator hand requires argument defined second exist 
summary chapter explained background motivational concepts necessary understand compositional modularity 
model placed context progressions flexibility reuse name space abstraction module systems 
classical module systems support decomposition encapsulation static type checking lexical nesting support module manipulation achieve reuse 
oo programming systems support manipulable modules usually inflexible fully support nested modules 
furthermore concise description goals salient features compositional modularity 
primary goal compositional modularity support flexible mechanism composing highly decomposed programs achieve high degree implementation reuse 
supports enhanced reuse existing models new notion compositional nesting 
summarized formal generator semantics static type system module manipulation language jigsaw constitutes starting point research 
chapter compositionally modular scheme purpose chapter twofold 
introduce concepts compositional modularity concrete context programming language 
language called compositionally modular scheme cms short programming language scheme extended support compositional modularity 
purpose demonstrate notions general emulate idioms advanced modularity oo inheritance 
particular idioms classes super prefix single inheritance mixin multiple inheritance wrapping method definitions calls emulated 
scheme dialect lisp programming language 
statically scoped properly tail recursive dynamically typed incorporates class procedures continuations 
simple semantics supports imperative functional styles programming 
spirit cms module system supports modules class entities dynamic interactive 
primitives cms gradually introduced section 
primitives create modules combine adapt inspect instantiate access attributes 
sections show primitives applied individually combination achieve various idioms oo inheritance 
concepts illustrated examples 
modules instances cms module consists list attributes order significance 
attributes kinds 
mutable attributes similar scheme variables store scheme value 
immutable attributes symbols bound scheme values read manner accessed assigned 
module scheme value created mk module primitive 
modules may manipulated attributes accessed evaluated instantiated mk instance primitive 
syntax primitives mk module attribute attribute mk instance hmodule expri expressions create modules mk module expression denoted hmodule expri 
similarly expressions create instances denoted expri 
attributes instance accessed attr ref primitive assigned attr set 
primitive 
procedures module access sibling attributes self ref primitive assign self set 
primitive 
primitives explained detail section shows basic module operations 
shows module bound scheme variable fueled vehicle 
module mutable attribute fuel immutable attributes empty bound procedure checks see fuel tank empty fill bound procedure fills fuel tank vehicle capacity 
fill method refers attribute capacity defined module expected fuel capacity vehicle 
vocabulary traditional module systems module exports symbols fuel empty 
fill implicitly imports symbol capacity 
alternative language design support explicit importation explicit interfaces 
define fueled vehicle mk module fuel empty 
lambda self ref fuel fill lambda self set 
fuel self ref capacity define fueled vehicle hide fueled vehicle fuel describe fueled vehicle empty 
lambda self ref priv attr 
fill define capacity module mk module capacity greater capacity 
lambda 
self ref capacity attr ref capacity define vehicle merge fueled vehicle capacity module define new capacity mk module capacity define new vehicle override vehicle new capacity define mk instance vehicle 
basic module operations 
definition mk module encapsulation hide combination merge rebinding override instantiation mk instance 
encapsulation mentioned earlier important requirements module systems encapsulation 
supported primitive hide returns new module encapsulates attributes 
hide hmodule expri name list expri hide expression creates new module encapsulated fuel attribute internal inaccessible name 
shown describe primitive simply prints attributes module priv attr 
hiding results known object level encapsulation hidden attributes particular instance module accessible self primitives self ref individual instance 
accessible externally attr ref incoming parameter binary method parameter greater capacity 
method module capacity module shown 
style encapsulation contrast class level encapsulation supported adts language 
important note retroactive encapsulation shrinks interface module 
result functions expecting instance particular module may necessarily operate correctly instance module subjected hide operation 
represents widely accepted notion inherited module necessarily result subtype parent effect separating inheritance subtyping 
combination module capacity module exports symbols capacity represents fuel capacity vehicle greater capacity bound procedure determines current instance greater fuel capacity incoming argument 
module fueled vehicle combined capacity module satisfy import requirements 
accomplished primitive merge syntax merge hmodule expr hmodule expr new merged module vehicle exports symbols imports 
check import requirements individual modules satisfied introspection primitives described section primitive merge permit combining modules conflicting defined attributes attributes defined name 
name conflicts operator override override hmodule expr hmodule expr presence conflicting attributes override creates new module choosing hmodule expr binding hmodule expr resulting module 
example module new capacity merged vehicle modules conflicting attribute capacity 
new capacity override vehicle shown 
way immutable attributes re bound mutable attributes associated new initial values 
instance vehicle module represents exactly kind module interconnectivity specified import export operations traditional module systems 
attributes access immutable attributes correspond fixed behavior abstraction represented module mutable attributes correspond state 
immutable attributes bound procedures referred methods borrowing oo programming 
immutable attributes bound modules called nested modules dealt chapter 
immutable attributes potential shared instances module 
mutable attributes hand bound fresh locations module instantiation initialized value associated attribute 
mutable attributes re bound re initialized override 
structured values lists shallow copied staying consistent semantics values lisp languages 
values stored initialized mutable attributes really bound attribute scheme procedure stored mutable attribute access attributes module self ref 
allowed procedure effectively class closure passed cms provides means creating closure attr 
similarly module stored mutable attribute access attributes outer module env ref described 
attributes instance accessed primitives attr ref expri namei expr attr expri namei attr set 
expri namei values mutable immutable attributes accessed primitive attr ref 
referenced attribute method applied argument value returned 
syntactically accessing value attribute attr ref exactly applying method arguments 
method accessed class closure applying primitive attr 
attributes attr semantically equivalent attr ref 
mutable attributes assigned primitive attr set 
method access instance executing expression self 
method access sibling attribute instance attr ref self namei 
encapsulated attributes accessed manner 
method uses analogous primitives self ref self access values attributes self set 
assign mutable attributes instance executing 
self ref namei expr self namei self set 
namei accesses primitives called self accesses attr ref attr set 
called external 
shows examples primitives 
modules attribute called undefined self referenced referenced nested module specified module 
specified called defined 
module attribute left undefined 
keeping dynamic typing scheme module instantiated possible methods run completion refer undefined attributes 
checked run time error refer undefined attribute 
noted goes normal compilation oriented policy stated section 
adaptation far shown cms supports notions traditional module systems 
point go traditional module systems 
section operators adapt particular characteristics modules described 
section ways find information class modules instances 
show primitives introduced simulate composite idioms oo programming 
hide primitives see create new modules adapting aspect attributes existing modules 
restrict hmodule expri name list expri rename hmodule expri name list expri name list expri copy hmodule expri name list expri name list expri freeze hmodule expri name list expri primitive restrict simply removes definitions defined attributes module undefined 
example shown 
describe restrict vehicle capacity empty 
fill greater capacity 
describe rename vehicle capacity fuel capacity fuel capacity fill self ref fuel capacity describe copy vehicle capacity default capacity capacity default capacity fill self ref capacity describe freeze vehicle capacity capacity fill self ref priv attr 
module adaptation operations 
removing attribute restrict renaming attribute self rename copying attribute copy statically binding self attribute freeze 
primitive rename changes names definitions self attributes argument name list expri corresponding ones name list expri 
example shown 
undefined attributes attributes defined self referenced renamed 
primitive copy copies definitions attributes name list expri attributes corresponding names name list expri 
argument attributes defined 
example shown 
primitive freeze statically binds self attributes provided defined module 
freezing attribute capacity module vehicle causes self capacity statically bound attribute capacity available public interface manipulation rebinding combination 
effect similar converting accesses virtual method accesses method 
difference allows methods public interface class general philosophy public attributes virtual smalltalk 
shown frozen self capacity transformed refer private version attribute 
operationally binding private version shared public version long public version re bound new value overriding 
implies frozen mutable attributes shared mutable attributes rebound just initialized new values 
module adaptation operators shown pictorially 
top left box representing module inner box representing method meth 
self meth rest module shown bundled line pointing meth 
top center inner shaded box labeled meth 
indicates encapsulated meth attribute 
top right undefined method meth shown bundled line pointing module 
module manipulation primitives applicative sense return new modules destructively modifying arguments 
de restrict meth freeze meth rename meth meth hide meth copy meth meth meth meth meth meth meth meth 
pictorial representation adaptation 
module method meth self shows effect various adaptation operators 
shaded boxes meth 
indicate encapsulated meth attributes 
versions operators permit express composite module operations compromising efficiency making unnecessary copies 
operations result disastrous behavior 
example instance queries module module described section obtain different module instantiated 
result destructive module operations supported 
introspection primitives available determining various kinds information modules instances 
attrs hmodule expri mutable attrs hmodule expri module expri defined 
hmodule expri name list expri self refs hmodule expri name list expri conflicts hmodule expri name list expri examples shown 
names publicly accessible attributes module accessible attrs primitives 
example mutable attributes module encapsulated expression 
hide vehicle mutable attrs vehicle defined 
vehicle self refs vehicle greater capacity conflicts conflicts mod attrs mod rename mod conflicts prepend super conflicts 
introspection operations 
hiding mutable attributes mutable attrs checking method run completion defined 
self refs renaming conflicting attributes conflicts 
primitive defined 
determine attribute defined module 
returns attribute names undefined module 
defined returns incoming list attribute names 
primitive defined 
implemented terms attrs 
module instance created obtained primitive module 
module self similar self class smalltalk current eiffel myclass canning 
useful know names public attributes method 
primitive self refs returns flat list comprising set self referenced public attributes bindings attribute names 
argument attribute names nonexistent bound values ignored 
example determine method execute run time errors relating locally undefined public attributes private attributes defined evaluate expression 
primitive conflicts returns list attribute names defined module exist list 
example attributes module conflict module renamed expression 
renaming adaptation operator described section 
primitives enumerated module 
instance 
predicates tell argument value module instance respectively 
introspective operations permit access aspect private attributes modules 
meta level primitives permit exposing details method implementations self 
argued literature self dependencies methods aspect inheritance interface implementation 
single inheritance programmer point view necessary know available constructs language intent usefulness constructs 
necessary show cms emulate composite notions advanced modular programming oo programming 
section show cms supports styles single inheritance 
section styles multiple inheritance illustrated 
super single inheritance super single inheritance illustrated 
single inheritance systems smalltalk notion class consisting methods encapsulated instance variables 
systems possible specify class declaration similar shown 
define class construct explained 
example attribute fuel intended encapsulated instance variable scheme constant false indicates class superclasses 
class declaration equivalent writing mk module expression hiding fuel attribute resultant module 
vehicle module land vehicle subsequently defined systems specifying way land vehicles incrementally differ vehicles 
subclass land vehicle vehicle specified manner similar 
definition new immutable attribute wheels added display binding overridden method accesses shadowed method self ref super display 
crucial effect inheritance appropriate rebinding self superclass redefined attributes subclass 
question achieve cms 
vehicle example new module captures define class vehicle fuel capacity fill lambda self set 
fuel self ref capacity self ref display display lambda format fuel capacity self ref fuel self ref capacity define class land vehicle vehicle wheels display lambda self ref super display format wheels self ref wheels define land vehicle hide override copy vehicle display super display mk module wheels display lambda self ref super display format self ref wheels super display 
super single inheritance 
superclass vehicle subclass land vehicle module expression macro box expands 
characteristics land vehicle created combined vehicle module 
consider cases 
simply override 
subclass simply override superclass case superclass display wiped 

rename override 
superclass display renamed super display self display renamed 
self display fill method execute subclass display 

copy override 
superclass display copied super display overridden self display superclass execute subclass display desired 
resultant module extra method super display public interface 

copy override hide 
correct solution shown 
write macro cms translate define class expressions vehicle land vehicle module expressions 
fact library useful macros accompanies cms 
macro single inheritance accepts syntax define class var macro automatically finds conflicting attributes modules introspective primitive conflicts uses expression achieve single inheritance 
general form module expression shown turns useful idiom cms 
expressing effects prefix inheritance wrapping mixin combination described 
shall refer form copy override hide idiom 
prefixing programming language beta supports form single inheritance called prefixing quite different single inheritance section 
prefixing superclass method expects re bound subclass definition uses construct called inner body 
instances superclass calls inner amount null statements ops 
subclasses redefine method turn call inner 
subclass instances superclass method executed subclass redefinition executed encountering inner statement 
easy see mechanism ensures method redefinition extension original method replacement 
effect achieved cms macro define prefix illustrated vehicle example 
focuses display method vehicle class 
expression self ref inner display corresponds inner construct 
class definition expands module expression shown dummy inner display attribute merged 
fact define prefix macro adds dummy attribute prepended inner immutable attribute definition 
subclass land vehicle vehicle defined expands expression similar 
expression assume module subclass characteristics merged dummy inner display produce module land veh chars 
module display method copied sub display overridden superclass dummy inner display attribute removed renamed sub display 
lastly hidden away display method resultant 
define prefix vehicle display lambda self ref inner display define vehicle mk module display lambda self ref inner display inner display define prefix land vehicle vehicle display lambda self ref inner display define land vehicle hide override copy land veh chars display sub display rename restrict vehicle inner display inner display sub display sub display 
prefix inheritance 
vehicle prefix expansion inner construct land vehicle subclass module expression combine prefixes 
example uses copy override hide idiom introduced section 
difference adapted superclass overrides subclass opposed reverse section 
difference prefix super forms single inheritance 
contrasted side side pictorially diagramming conventions 
wrapping notion wrapping enables interpose piece code wrapper method callers 
wrapping similar clos notion methods useful contexts 
fact wrapping method definitions meth meth meth meth meth meth inner meth inner inner meth meth super sub delta sub super delta 
pictorial representation single inheritance 
super hide override copy super meth meth delta meth prefix hide override copy delta meth meth rename super inner meth meth simulate methods clos new code interposed call old code 
easy wrap method definitions copy override hide idiom shown earlier 
cms provides macro called wrap method achieve effect shall omit description conserve space 
interesting explored effect wrap self referenced calls particular methods illustrated 
say module veh sim shown intended combined vehicle module 
method sim fill calls undefined method fill condition fill condition 
say want count number calls fill sim fill 
want wrap method fill vehicle want count calls sim fill 
wrap sim fill method call necessarily result call fill due fill condition test 
need wrap calls fill veh sim module wrap call define veh sim mk module sim fill lambda fill condition self ref fill define counted veh sim count sim merge veh sim mk module count wrap call count sim fill lambda self set 
count self ref count self ref fill hide merge rename count sim fill wrap fill mk module wrap fill lambda self set 
count self ref count self ref fill wrap fill 
wrapping calls methods 
vehicle simulation module veh sim wrapping calls fill veh sim wrap call macro module expression wrap call expands 
macro shown box 
add mutable attribute count veh sim wrap calls fill increment counter 
module expression wrap call expands box 
expression rename undefined attribute fill wrap fill changing self correspondingly 
merge wrap fill method increments count calls old fill method resulting module 
idioms cms general form expression useful idiom cms referred rename merge hide idiom 
distinction copy override hide idiom rename merge hide idiom worth exploring 
pictorially shows idioms method definitions row method calls second 
shaded boxes represent hidden methods 
method definitions idioms method meth meth meth meth meth meth meth wrap calls meth meth meth meth wrap copy override hide rename merge hide idiom copy 
idioms cms 
redefined old definition method referred redefinition meth 
difference copy override hide meth refer new meth combined module 
rename merge hide refer old definition renamed meth refer redefinition 
example scenario rename merge hide appropriate achieve right effect single inheritance 
example renaming vehicle display method copying case self display vehicle renamed want self superclass refer new rebound display method 
method calls rename merge hide idiom applies undefined attributes copied 
module call meth wrapped produce shown 
example section 
multiple inheritance seen section express creation subclass single superclass 
multiple inheritance mi additional problem compose superclasses resolving conflicts sharing attributes 
typically language supporting multiple inheritance available programmer small number choices attribute sharing conflict resolution 
advantage oo programming operator inheritance programmer numerous options fine grained control decisions taken combining multiple modules 
important advantage operator inheritance programmer explicit control various aspects combination modules 
contrast existing languages provide default language behavior aspects multiple inheritance 
examples default linearization ancestors sharing ancestors common multiple paths 
depending default rules cause unexpected consequences inheritance relationship classes implementation detail changed 
explicit fine grained control aspects multiple inheritance supported compositional modularity inheritance relationships changed desired long interface inherited module changed 
approach compositional 
mixins linearized mi consider case linearized multiple inheritance flavors loops graph ancestor classes class linearized single inheritance hierarchy 
languages specifies different default rule linearization ancestor classes 
example languages depth left right traversal ancestor classes join classes classes encountered get traversed visit flavors visit loops 
argued currently linearizations ensure inheritance mechanism behaves naturally relative incremental design inheritance hierarchy 
changing inherited superclass class implementation detail change computed linearization superclasses producing completely different behavior 
better programmer select precedence order superclasses dictated individual applications 
case clos programmer considerable expertise meta object protocol language adapt default rule 
contrast programming operator inheritance gives programmer direct control combination shown 
say want create modules land vehicles sea vehicles subclasses vehicle 
define modules characteristics land vehicles number wheels sea vehicles surface vessel submarine shown box 
modules think expression self ref super display equivalent call method clos 
modules called mixins reusable abstractions require abstractions order usefully applied 
abstractions characterized functions classes classes 
approach operator define land veh chars mk module wheels display lambda self ref super display format wheels self ref wheels define sea veh chars mk module surface display lambda self ref super display format surface self ref surface define subclass land vehicle land veh chars vehicle define subclass sea vehicle sea veh chars vehicle define subclass amphibian land veh chars sea veh chars vehicle define amphibian hide override copy vehicle display super display hide override copy sea veh chars display super display land veh chars super display super display 
linearized multiple inheritance 
inheritance uniformly treats aspects inheritance operations modules developed 
definitions box create land vehicle sea vehicle subclasses vehicle shown box 
achieved copy override hide idiom macro define subclass accepts slightly different syntax 
similarly chain creation subclasses call super display class calls display method lower precedence superclass 
create amphibian class inherits characteristics land sea vehicles 
define subclass macro amphibian expands module expression shown box note cascaded copy override hide idiom extends arbitrary number superclasses desired 
mi common ancestors consider case multiple superclasses linearized common ancestor 
say module color defined 
combine color module land vehicle shown earlier car class shown 
expression uses rename merge hide idiom introduced section 
method display conflicts superclasses vehicle color renamed superclasses merged 
new module defines display method calls renamed display methods merged create desired car class 
example extended superclasses automated macro uses introspective primitive conflicts rename attributes 
rename merge hide idiom works fine example self renamed attribute superclasses 
right effect inheritance obtained copy self superclasses changed followed merge accidental conflicts superclasses get quietly re bound 
problem copying conflicting attributes merging conflicts persist 
remedied restrict ing section copying merging hiding 
define color mk module color white set color lambda new color self set 
color new color display lambda format color self ref color define car class hide merge merge rename color display color display rename land vehicle display vehicle display mk module display lambda self ref vehicle display self ref color display color display vehicle display 
multiple inheritance common ancestors 
similarity copy restrict merge hide operation copy override hide idiom 
mi common ancestors case superclasses common ancestor diamond problem multiple inheritance situation gets complex 
case attributes common ancestor clearly conflicting direct superclasses inheriting class 
furthermore choice inheriting single copy multiple copies mutable attributes common ancestor 
consider case language providing default rule sharing attributes common ancestor 
inheritance structure changed say inheriting separate classes common ancestor potential attribute clashes 
approach compositional modularity require explicit specification aspect combination modules 
illustrate consider previously modules land vehicle inherited vehicle module 
say want create amphibian module inherits modules needs copies fuel attribute model different kinds fuels 
achieved expression 
example fuel attribute renamed type module 
modules overridden conflicting attributes capacity fill known identical method display overridden final module 
new display method displays attributes appropriate way included final composition get desired module 
override override rename land vehicle fuel land fuel rename sea vehicle fuel sea fuel mk module display lambda format self ref land fuel self ref sea fuel 
multiple inheritance common ancestors 
distinction programming class modules operational style oo languages illustrated example 
problems conflicts sharing clearly manifest compel programmer resolve particular situation demands introspection inheritance operators 
example conflicts superclasses inspected conflicts superclasses overridden appropriate order resolve attribute conflicts 
multiple copies mutable attributes common ancestor desired renamed superclass shown example 
desired burden resolving conflicts individual case removed writing macros perform user chosen method composition 
related chapter shown relationship cms constructs inheritance mechanisms oo languages 
section relationship various module models 
classical module systems sml ada support class modules 
ml systems support higher order functors class run time values 
module systems closely associate static type system module system 
viewpoint compositionality reuse systems quite limited explained section 
early effort incorporate class modules language pebble 
uniformity expressive power obtained class modules recognized 
languages fx support class modules 
support explicit interfaces separate implementations frequent feature module systems 
known support large scale programming clients written compiled module interface 
module implementors associate possibly multiple im interface 
cms language explicitly support interfaces 
interfaces built dynamically specifying module public interface attributes providing dummy error methods 
subsequently implementations interface combined override private attributes encapsulated hide 
module systems developed scheme programming language 
curtis system supports explicit interfaces modules import export specifications 
tung system additionally supports notion renaming conflicting imports dynamic binding imported attributes 
systems support composition effect provide little functionality described sections 
lisp packages namespaces map strings symbols 
symbols exported package may imported 
scheme module system sophisticated namespace manipulation mechanism supports multiple instantiation modules packages explicit interfaces 
mechanisms composition adaptation systems 
scheme implementations support class environments 
systems class environments dynamically created extended expressions evaluated 
environment point captured special primitive environment 
useful operation defined environments eval 
reflective operations class environments proposed language 
language construct environment lexical public bindings reify environment data structure subsequently reflect data structure back environment 
public bindings visible environments reflected 
effect reification operation constrained desired barriers 
programmers unbind names environment restrict operation 
operations programmers achieve effects modularity 
goals cms similar approaches entirely different 
uses approach reflection cms uses notions generator manipulation 
specifically cms support reflection reification environments 
hand support wide array name conflict resolution mechanisms rename static binding freeze retroactive encapsulation hide 
significantly cms differs cms compositional modularity shown rest dissertation apply dynamic languages systems 
particular static typing explored 
compositional nesting chapter unique cms 
popular language family oo programming lisp clos family languages 
clos supports quite different model oo programming described multiple dispatch generic functions weaker encapsulation 
cms hand supports single dispatch 
clos supports protocol interact meta architecture 
dexterity multiple inheritance section primary practical consideration design clos mop 
cms compared approach open implementations 
metaobject protocols mops clos expose oo implementation language processor programmer controlled protocol 
aspects language implementation mechanisms inheritance object data layout method dispatch controllable mops 
far inheritance concerned cms provides programmer flexibility similar provided mops practical purposes 
cms provides flexibility supporting small set designed primitives effectively control desired aspects inheritance mops opening meta architecture implementation direct user programming 
result approach give user full power altering language behavior full blown mop 
clear completely opening implementation result complexity inadvertent abuse users 
inheritance class modules compared class programming prototypes delegation self 
class programming languages allow individual objects inherit delegate objects 
notion classes instantiable objects 
crucial characteristic delegation inherited objects shared parts inheriting objects ordinary inheritance inherited classes copied inheriting classes 
true instances nested classes ordinary inheritance share copy enclosing instance explained chapter manner delegation notion dispatching shared parent nesting 
pointed delegation languages self support sophisticated mechanisms inheritance prioritized multiple inheritance 
summary chapter realistic imperative language design embodies compositional modularity illustrated typical programming styles idioms language supporting compositional modularity 
language called compositionally modular scheme cms modules manipulated suite operators individually achieve effects encapsulation combination sharing introspection 
compositional module operators enable combine modules number ways enable reuse preserving encapsulation 
language expressive flexible model previously existing techniques oo programming 
shown examples language emulate broad array idioms single prefix mixin multiple inheritance classes wrapping method definitions calls 
language provides mechanisms support enforce inheritance policy 
effect language represents unification design space dynamic single dispatch oo programming languages 
model modularity smoothly integrated programming language scheme keeping original design philosophy small number rules forming expressions restrictions composed suffice form practical efficient programming language flexible support major programming paradigms today 
chapter module nesting software development decomposition naturally leads hierarchical nesting modules 
support nesting important requirement module systems 
chapter notion module nesting developed integrated notion compositionality 
previous module models support lexical nesting nested modules developed independent outer nesting modules 
compromises modularity reuse nested module 
compositional modularity separately developed modules may retroactively composed modules achieve hierarchical nesting 
nesting constructs language cms described section 
directly lexically nest modules retroactively nest composition operation 
effect direct nesting regarded syntactic sugar separately defining module retroactively nesting 
section illustrates applications nested modules namespace control sharing inheritance hierarchy combination notion manager modules context language cms 
semantic concept closed generators proposed section model retroactive nesting 
ways integrate concept earlier semantics generators static typing discussed 
goals benefits addition general requirements compositional modularity system supporting nested modules meet goals related specifically module nesting 
separate 
fundamental requirement modularity individual modules specifiable independent particular context 
module nested possible specify independent 
additionally desirable interface module surrounding context explicitly specified 
distinct specifying interface module respect siblings level 

composability 
independently developed module composable level hierarchical sense 
able retroactively nest separately developed module compatible interface 

static safety 
properties type compatibility module outer module statically checked safety 

namespace independence 
support accessing similarly named values local nonlocal environments 
explicit access benefit eliminates possibility accidental nonlocal names 
may modularity requirements lexical nesting separate odds develop nested module depends lexical environment separately environment 
solution modules entire lexical environment outlined section 
precise description idea section 
benefits compositional nested modules derives ability retroactively nest modules 
nested modules independently developed supporting team development presence hierarchical structure 
notion static typechecking retroactive nesting supports large scale software development 

retroactive nesting nested modules directly lexically nested modules imposing permanent nesting relationship restricting reuse nested module 
contrast compositional nested module embedded reused module generates conforming environment 
conformance statically checked 

control namespace modules 
groups interacting modules application retroactively bundled separate namespace global application namespace 
general approach compositional modularity provide facilities compose independently developed modules various possible desirable ways 
natural framework modules composed achieve hierarchical nesting 
sense support compositional nested modules analogous support mixin inheritance oo languages 
important languages support incremental programming inheritance support increments called mixins independent reusable abstractions 
similarly language supports compositional programming nested modules support nested modules independent composable abstractions 
section introduce concepts applications nesting language cms 
nesting cms cms module directly lexically nested section nested fact section 
case module bound immutable attribute module referred nested module 
argued section module stored mutable attribute properly called nested module 
methods modules refer bindings surrounding environment primitives refer name lexically surrounding scope binding name 
env ref namei expr env namei env set 
namei primitives serve functions analogous self primitives section 
names surrounding scopes accessed explicitly environment primitives 
checked run time error refer name binding surrounding scope 
lexical nesting modules follow static scoping rules just rest scheme 
environment module determined lexical placement mk module expression creates 
shows examples module nesting 
type type nested modules fill methods refer capacity attribute outer module 
individual vehicles represented instances nested modules 
define vehicle category mk module capacity type mk module fill lambda env ref capacity type mk module fill lambda env ref capacity define mk instance vehicle category define mk instance attr ref type define veh type mk module fill lambda env ref capacity define new vehicle category nest type veh type vehicle category 
examples nested modules 
lexical nesting retroactive nesting 
mk module expressions nested modules evaluated time vehicle category instantiated 
nested modules instance surrounding module environment bound environment time instantiation outer module described precisely section 
lexical scoping maintained regardless nested modules moved combined environments nested modules created environments 
analogous creation manipulation class closures procedures environment scheme 
static scoping module nested modules interact ways 
changes module attributes rename freeze static binding hide result modifications environment nested modules tracked environment 
example renaming attribute module cause renaming environment nested modules 
retroactive nesting module nesting done retroactively primitive nest 
nest namei module expri module expri primitive returns new module containing attribute namei bound module module expri outer module 
example shown 
interactive language cms modules contain env ref specified top level environment 
modules environments env ref modules automatically bound names occurring top level environment 
module instantiated mk instance environment bound scheme environment point instantiation 
semantics akin dynamic scoping 
obtain effect static scoping top level modules primitive bind env hmodule expri expression binds environment module produced hmodule expri optional argument default scheme environ ment point 
fixed manner env ref bindings module changed retroactive nesting effect environment 
applications nesting name space control sharing major block structure arises module providing local namespace nested modules 
helps control problems associated flat global name spaces name pollution accidental name conflicts 
furthermore module serve shared data repository nested modules 
attribute capacity shared instances type type modules 
similarly mutable attribute hold state shared instances modules 
interesting unexplored consequence nonlocal resolved top level environment considered shared persistent names 
addition module serve factory produces initialized instances nested modules 
method outer module instantiate possibly encapsulated nested module initialize instance possibly shared state returning caller 
generalization idea explored section 
modeling real world modeling problems nicely solved nested classes 
problem known prototype abstraction relation problem page 
problem model concept viewed instance general concept state changing time class models prototype similar entities 
example concept flight point point changing state carrier schedule 
particular flight delta am instances flight day 
solution problem model notion flight outer class contains nested class 
particular flight delta am instance outer class 
instance prototype individual flights delta am modeled instances class nested 
solution problem meta classes 
flight meta class instantiated class representing delta am instantiated individual flights 
important point necessary pay price complexity meta classes block structure solve problems cases 
explored detail section 
manager modules reflection means programs access manipulate 
cms supports form reflective programming modules introspective primitives earlier section conjunction manager modules 
manager module consists nested module methods manipulate extensible functionality supported nested module 
sense manager module simulate meta class conventional designs shown block structure programming language beta page 
example generic manager module specified follows define manager mk module new lambda mk instance self ref class ref lambda inst attr args apply attr ref inst attr args module specifies method new returns instance undefined attribute called class method ref accesses attribute attr inst 
basically new ref methods act surrogates mk instance attr ref modules bound attribute class 
new ref methods named mk module attr ref 
idea module bound attribute class new ref methods specialized appropriately module manipulation manager module 
instance car manager module counts number instances car class module created binding car class module class adding counter attribute wrapping new method code increments counter 
attribute instances car class specialized wrapping ref method convention accessing car class attributes specialized ref method policy enforced 
hierarchy combination inheritance hierarchy oo programming usually thought graph inheriting classes 
languages hierarchies represented internally graphs 
cms inheritance hierarchy represented simply collection module expressions mk module expressions adapt combine modules 
hierarchy modules nested module 
base class hierarchy nested module modules inherit computed module expressions methods outer module modules class 
examples hierarchy combination shown pictorially 
hierarchy veh consisting vehicle module subclass car written shown pictorially 
entire hierarchies combined hierarchies manipulating outer modules 
consider hierarchy cap module vehicle single attribute capacity shown figures 
suppose wish extend hierarchy veh hierarchy cap attribute capacity added vehicle module superclass automatically inherited car subclass 
results hierarchy veh cap shown produced expression shown 
expression considerable similarity section multiple inheritance section 
define veh mk module vehicle mk module fuel car lambda override self ref vehicle mk module color white define cap mk module vehicle mk module capacity define veh cap override override copy veh vehicle veh vehicle copy cap vehicle cap vehicle mk module vehicle lambda override self ref veh vehicle self ref cap vehicle define disp mk module vehicle mk module display lambda car mk module display lambda define veh disp override override copy veh vehicle car veh vehicle veh car copy disp vehicle draw disp vehicle disp car mk module vehicle lambda override self ref veh vehicle self ref disp vehicle car lambda override self ref veh car self ref disp car define cap disp merge merge rename cap vehicle cap vehicle rename disp vehicle disp vehicle mk module vehicle lambda merge self ref cap vehicle self ref disp vehicle 
example hierarchy combination 
veh hierarchy cap extension hierarchy combining veh cap disp extension hierarchy combining veh disp combining parallel extensions cap disp 
vehicle fuel color car capacity vehicle fuel capacity vehicle color car vehicle display car display cap disp vehicle display capacity car display car color display vehicle fuel display veh cap veh cap disp veh disp 
hierarchy combination example shown pictorially 
similarly disp hierarchy extend veh hierarchy 
disp modules shown provide display methods 
disp hierarchy combined veh hierarchy produce veh disp hierarchy expression shown 
examples hierarchies cap disp considered parallel extensions hierarchy veh 
interesting useful operation parallel extensions combined conflicts shown 
note merge expression opposed override want disallow conflicts 
effects similar ossher harrison 
hierarchy combination significant consistent extension oo programming supports development modifications entire hierarchies separated extensions integrated 
semantics section provide denotational description notion compositional nesting described earlier context cms 
reader interested formal underpinnings compositional nesting may safely skip section 
recall nested modules generator semantics section contain free implicitly refer names surrounding lexical scope module environment 
imperative language stores semantics modeled passing environment argument semantic function creates constructors 
constructor retains environment created 
instantiation applied store extends retained environment bindings arising attribute definitions module 
respect nested modules problems model generator semantics 
major problem modules free odds goal section 
free compromise important requirement modularity ability develop maintain module independent context 
second modules model priori designed nested nested fact 
odds goal section 
section attempt remedy problems notion importation section cleanly elegantly extended form generators called closed generators section 
importation attempt retrofit support nested modules original framework generators 
disallowing free modeling nonlocal existing mechanism self referencing 
nonlocal modeled self undefined attribute 
approach self referenced attributes really stand non local imported bindings environment import operator import hide fa ag operator takes module generator environment produces new module attribute bound value environment 
type rule sure defined incoming module 
import operation hides imported attribute resultant module 
multiple modules import attribute name environment mergeable conflicts arising importation 
see consider sibling nested modules import name surrounding environment generated module 
modules mergeable importation result merge conflict 
semantics satisfies goal independent development 
goal composability partially met 
semantics presumes module combination run time environments run time entities 
desirable possible 
furthermore goal local nonlocal access satisfied name spaces undesirably combined 
additional problem verbosity explicitly import instance surrounding module opposed specifying permanent nesting relationship module surrounding module 
closed generators section describe alternative formulation modules meets goals set section 
formulation module modeled closed generator generator abstracts environment 
domain equation closed generators example shown closed generator environment instance instance fa closed generators free 
self modeled explicit parameter environment modeled explicit parameter 
closed generator instantiated applying environment fixpoint 
instantiate framework nested module modeled closed generator applied environment self environment outer module 
generator obtained closed abstracting dummy environment example attribute bound nested module module environment bound time outer module instantiated 
subsequently nested module bound selected passed 
regardless environment supplied instantiation nonlocal refer lexically surrounding scope desired effect lexical scoping 
nested modules virtue part implementation outer module access encapsulated attributes outer module 
fact modeled accurately model self outer module supplied environment nested module 
closed generator nested fact operator nest 
operator creates new closed generator embedding incoming closed generator attribute named resultant shown nest cout fn cout closed generator semantics easily integrated ordinary generator semantics 
closed generator versions subscripted unary binary generator operators subscripted specified gc gc imperative closed generators section provides semantics mk module nest primitives cms closed generators stores 
notion closed generators previous section augmented notion constructors section 
imperative closed generator takes environment produces ordinary imperative generator section applied store returns instance updated store 
closed generator environment constructor constructor constructor store 
instance theta store semantic function takes syntactic module expression syn return imperative closed generator 
semantic function generates environment names bound values locations syntactic list attributes syn assumed 
syn environment store 
environment theta store syn closed generator mk module self create self self create self create nest self create self self create self self create fn static typing order satisfy static safety requirement section outline static typing closed generators nesting section 
note augmentation ordinary generators closed generators requires augmentation static type rules defined ordinary generators ref 
augmentations 
question treat imported names simply declared names distinguishing declared self nonlocal 
problem approach arises trying nest module determine declared names nested module imported names outer module correspond self referenced names imported 
modules corresponding closed generators type consisting declared defined imported attributes 
module defines unique attributes am bindings vm valid type signatures ff ff declares unique attributes valid type signatures ffi ffi imports unique names valid type signatures ffl ffl module type define ff am ff declare ffi ffi import ffl ffl operator nest imports attributes specified import inner module declared defined import attributes outer module 
import attributes inner module declared defined import outer module import attributes resultant module 
attributes imported outer module subtypes types specified import attributes inner module 
furthermore nested module resultant module remaining import attributes pushed outer module 
corresponds notion environment inner module fixed nest operation 
notions captured type rule omitting clauses uniqueness conditions 
concludes treatment semantics nested modules 
discussion related class nesting merely name space structuring mechanism 
nonlocal nested classes disallowed statics globally qualified names conventional semantics nonlocal access bindings names surrounding scope 
local binding essentially overrides binding gamma define ff am ff fi fi declare fl fl ffi ffi import oe oe gamma define fi fi declare ffi ffi import ff am ff fl fl oe oe ff ff fl fl oe oe gamma nest define ff am ff fi fi define fi fi declare ffi ffi import declare fl fl ffi ffi import oe oe 
type rule nest operator 
name surrounding scope 
equivalent conventional semantics nested functions languages 
examples ml substructures scheme modules beta subpatterns 
directly lexically nest modules systems notion compositional nesting 
experience nested modules date subpatterns supported beta language 
nested patterns beta obtaining effects mixin style programming 
example mixin virtual class class 
binding virtual class deriving extracting nested class mixed 
beta programming idiom useful permits bind virtual class class subtype declared type 
construct statically typed 
idioms obtainable means cms shown previous chapter 
pointed separate compilation nested modules performed conventional link editing techniques 
environmental stored relocation information compiled object file patched proper nonlocal access code combined outer module 
summary chapter showed achieve goal language supports compositional modularity support nested modules independent composable abstractions 
develop denotational semantic formulation nested modules closed generators meets goal 
important point chapter block structure orthogonal modularity 
madsen argued block structure mechanism programming large language contain facilities program smaller parts 
show nesting form composition nested modules programming large 
go illustrate applications nested modules sharing name space control modeling manager modules inheritance hierarchy combination 
show necessary pay price complexity meta class support compositional nested modules solve problems cases 
chapter etyma framework mon pl ma fr 
gk word morpheme words formed composition derivation 
webster dictionary earlier argued model compositional modularity expressed independent particular realizations 
chapter show notions fundamental compositional modularity formulated simple software architecture oo framework named etyma effectively reused build tools wide variety systems 
framework designed simple extensible reusable support introspective reflection 
concrete classes constitute framework section 
classes cover domain values interest compositional modularity types 
systems framework benefit power flexibility architecture offers significant design code reuse 
implementation architecture interpreter language cms extent benefits reuse section 
reuse characteristics framework design documentation evolution reuse iterations discussed section 
oo frameworks design patterns challenge broadly applying model compositional modularity realize practical coherent reasonably complete manner 
exploit idea generic linguistic notions module record instance organized taxonomy concepts relationships aggregates furthermore space concepts specified oo language constituting known oo framework 
essence oo framework oo model captures essential abstractions particular application domain 
expresses architecture applications domain terms objects interactions 
frameworks allow developers build applications effectively classes framework inheritance configuring connecting instances predefined concrete classes framework 
result framework thought parameterized completion provides call back code sort bidirectional function abstraction 
applications built completing framework specific purposes preserving architecture framework 
frameworks promote design code reuse oo concepts inheritance polymorphism 
notion design patterns describe parts etyma framework 
design patterns somewhat smaller architectural units frameworks general 
design patterns systematically name explain evaluate important recurring solutions specific problems oo software design 
pattern catalog gamma helps oo designer identify apply simple elegant solutions commonly occurring problems oo design achieve greater reuse flexibility 
table gives brief descriptions patterns describing etyma reader referred ref 
complete descriptions 
furthermore oo diagrams describe framework 
diagramming conventions diagramming conventions adapted describe framework realized language etyma 
table 
design patterns describe etyma 
name description bridge decouple abstraction implementation vary independently 
composite compose objects tree structures represent hierarchies 
composite lets clients treat individual objects compositions objects uniformly 
factory method define interface creating object subclasses decide class instantiate 
factory method lets class defer instantiation subclasses 
iterator provide way accessing elements aggregate object sequentially exposing underlying representation 
singleton ensure class instance provide global point access 
template method define skeleton algorithm operation deferring steps subclasses 
template method lets subclasses redefine certain steps algorithm changing algorithm structure 
class operation protected operation pseudo code private operation operation abstractclass object aggregation implementation 
oo diagramming conventions 
class interface divided parts public protected methods dashed line private methods solid line 
slanted font indicates classes methods regular font stands concrete ones 
lines triangles stand inheritance subtyping 
design etyma section design oo framework compositionally modular systems 
outline requirements issues governed design etyma 

scope 
framework encompass abstractions spanning module systems associated type systems 
focus etyma facilitate building processing engines tools module systems building front back ends systems 

simplicity 
framework consist small number orthogonal abstractions 

extensibility 
possible easily add new abstractions new features abstractions model entire design extension 
property strengthened reuse 

reusability 
framework designed documented facilitate design code reuse 
include functionality module systems possible committing specific base languages 
abstraction framework reused completions 
furthermore design decisions dependencies documented aid reuse clients 

reflection 
model support introspective reflection 
class support methods query modify significant aspects internal representation 
model model meta model software system usually referred meta level architecture meta architecture 
instance oo programming model supported smalltalk captured set interacting meta objects object class constitutes smalltalk meta architecture 
generic oo realization essential concepts compositional modularity etyma termed oo meta architecture compositional modularity 
introducing central notions etyma relationships section classes etyma section concrete classes section 
sections describe etyma 
concepts relationships compositional modularity deals modules instances attributes composed types 
primary concepts captured meta architecture modules instances methods variables corresponding types 
etyma linguistic framework framework programming languages designed 
modeling concepts inadvertently limit generality 
example method specialization general concept function 
similarly concept record closely related module instance precise relationship concepts may immediately obvious 
order business clarify relationships specifically relationships concepts 
concept records models classical notion finite functions labels values notion self 
records support operations merge override rename restrict copy similar ones refs 

addition select operation records models attribute selection 
modules support operations select plus operations freeze hide 
concept module clearly subtype concept record 
consider idea record module 
feasible regard operation freeze records identity function hide records restrict 
furthermore record module record viewed module 
restrict operation applied record viewing module attribute entirely removed interface record 
restrict semantics modules require type restrict ed attribute remain interface 
consequently record viewed module record subtype module 
formally modules modeled functions records record generators 
natural records modules related relationship 
hand instance record 
fixpoint record generator instance record self bound 
sections show model abstractions compositional modularity oo manner 
classes section give overview classes etyma framework shown 
classes conceptual sense represent concepts setting particular completion 
cases method pure virtual template method pattern concept see specified terms methods class class 
classes etyma subclasses root superclass simply consists support methods debugging shown 
classes type superclasses model linguistic domains types values respectively 
classes form roots parallel hierarchies 
hierarchies parallel exceptions noted 
hierarchies described subsections 
value classes subclasses class called value classes 
etyma models strong typing concrete subclasses expected return concrete type object object subclass class type see section queried type 
expr typecheck expr eval env setup environment eq undefined eq env record merge record record override record select label module module boolean typecheck apply args apply instance args self ref label void rename self refs label label fetch void store boolean le type type glb type type lub type boolean eq type expr select method apply self record instance method function location type type type module merge module module override module boolean typecheck void insert label attrvalue void remove label attrvalue find label instance create instance module instance instantiate msg send label args void insert priv label attrvalue void insert label attrvalue eval env boolean typecheck module self 
overview classes 
class module 
class module captures notion compositional module broadest conception 
public methods class module central model correspond module operators introduced chapters merge override hide copy rename restrict freeze nest 
additionally methods support instantiation typechecking 
class module concrete representation module attributes assumed 
set protected methods insert remove 
see defined manage module attributes 
public module operations implemented template method patterns terms methods 
concrete subclasses module expected provide implementations protected methods 
illustrate design technique shows pseudo code template method merge terms methods shown slanted font 
method create iter factory method pattern expected module merge module interfaces self mergeable fail self clone create iter label curr label attr curr self attr self find label self attr insert label clone attr clone self attr attr declared glb greatest common subtype types self attr attr replace label glb self attr declared attr defined replace label attr clone merge private attributes return 
pseudo code template method merge 
method completely specified terms methods shown slanted font 
provide instance concrete subclass iterator pattern class 
attribute iterator returned call create iter expected iterate label binding pairs individually extracted curr label curr respectively 
module objects public private hidden attributes 
concrete subclasses module expected maintain attribute lists corresponding public private attributes 
accordingly set protected methods class module manage private attributes insert priv shown 
method create instance factory method pattern generates instance objects module objects 
method expected return object concrete subclass class instance 
method instantiate module fills newly allocated instance attributes module sharing attributes allocating new location attributes 
classes record instance 
mentioned earlier class record supports operations merge restrict select label 
methods implemented template methods pattern terms protected methods similar class module 
class instance subclass record supports operations similar record 
addition class instance models traditional oo notion sending message dynamic dispatch object select ing function valued attribute followed invoking apply returned function object 
functionality encapsulated template method pattern msg send label args 
furthermore class instance access generating module module member 
classes function method 
function values modeled class function 
function body modeled object object 
class composite pattern concrete subclasses representing particular kinds expressions 
apply method class function sets environment current values arguments calls method eval environment parameter 
appropriate subclass access values environment needed 
concept method differs function method belongs object method notion self 
accordingly class method subclass function requires argument apply method object subclass class instance corresponding notion self 
apply method class method saves value argument self attribute method object access self ref method explained 
self body method access attributes public private instance method executing self ref method class method 
self ref method accesses previously saved self instance saved entry apply method 
consider happens method body applies method object different instance module 
apply method recursively called different instance 
entry saves self overwrites old value self solve apply method saves away old value self entry overwrites restores old value exiting 
additionally class method provides methods accessing shown renaming self body 
classes location 
mutable state instance variables modeled class location 
location objects store objects class exact definition depends particular completion 
example storable values typically include primitive values language include pointers modeled locations containing locations 
primitive values modeled class shown multiply inherits classes 
classes referred described class label implements notion program identifiers names class attrvalue represents label bindings class env represents environments class args aggregation values 
support classes iteration class iterator lists class list shown 
role abstractions clearer description concrete subclasses section framework completion section 
type classes type classes corresponding value classes previous section commonly types modular programming languages modeled subclasses class type see 
class type defines method eq expected check types equal concrete subclasses 
addition defines template method patterns le checks subtype defaults eq glb computes greatest lower bound greatest common subtype undefined type boolean eq type boolean le type type glb type type lub type boolean mergeable interface boolean interface create iter attrvalue find label interface argtypes eq eq 
overview type classes 
required merge override semantics 
order compute greatest common subtype function types necessary compute lowest common supertype input argument types due contravariance 
result class type defines method lub computes upper bound common supertype pair types 
concrete subclasses type expected appropriately redefine semantics 
classes 
class represents type contains single member 
implemented singleton pattern 
class models types identity 
named types equality determined string equality names 
subtyping type equality explicit assertion subtyping relationships named types 
class provides method explicit assertion subtyping relationships 
classes interface 
class interface subclass type models type modules 
class interface implements template methods typecheck individual module operations 
methods class module call methods class interface mergeable implement type rules merge override methods type rules section defined terms protected methods find type comparison predicates eq le inherited class type 
class interface supports structural typing names types attributes considered order significance 
example eq method checks attribute attribute name type exists incoming interface 
eq method relies eq method class label implements identifiers 
subtyping interfaces type equality see section 
applications document modules chapter may require structural typing interfaces order significance 
course implemented deriving concrete subclass interface implements attributes ordered collection label attrvalue pairs 
name typing interfaces supported creating concrete subclass inherits classes interface inheriting eq le methods 
interface referred interface 
le method may take account explicit specification subtyping relationships interfaces 
class represents type records type instances 
supports template methods typechecking individual record operations including select 
methods implemented manner similar class interface 
class implements structural typing subclassed implement ordered record types structs 
class 
class models function types standard notions equality subtyping account contravariance 
methods compare function types combination modules contain function valued attributes 
distinguished typechecking implementation function done calling typecheck method function object typechecks expressions comprising function body 
class 
type equality class type equality contained type subtyping type equality 
location bound attributes variables evaluators expressions return values acceptors expressions receive values different contexts 
expressions evaluators replaced expressions types subtypes original expressions acceptors replaced expressions types supertypes original 
result subtyping variables restricted type equivalence 
recursive types 
etyma supports recursive types shown 
constituent composite type may recursive type represented object class rectype 
class type requires subclasses provide separate methods finding equality eq rec subtyping le rec recursive types 
subclasses class type shown directly implement recursive subtyping algorithm amadio cardelli uses trail pairs known recursive subtypes avoid diverging cyclic structures 
see chapter examples recursive types 
concrete classes described far framework provides generic object model abstracting notions primitive values expressions potential language completions 
basic architecture constructing kinds modular systems explained chapter 
order directly useful constructing language interpreter compiler concrete subclasses generic notions provided part framework 
idea implementor compositionally modular system able find reusable design code framework possible 
consequently provide standard concrete subclasses module instance interface attribute iterator part etyma shown 
addition concrete subclasses composite pattern provided shown 
class concrete subclass module represents attributes attrs attrvalue find label interface void insert label attrvalue instance module module mk mod void insert label attrvalue create iter instance create instance label attrvalue attrs insert attrs return new return new attrs 
overview concrete classes 
map object class 
attribute map collection individual attributes maps object class label class attrvalue 
attrvalue object encapsulates object class 
design pattern variation bridge pattern possible completions reuse implementation class simply implementing classes corresponding attribute bindings subclasses 
attribute management functions implemented corresponding operation map 
factory method create iter returns object concrete subclass class class iterates attribute maps 
similarly factory method create instance returns object concrete subclass class instance class 
class implemented attribute maps 
concrete subclass class interface class represents type objects 
implemented attribute map 
attrvalue holds object concrete subclass definitions type declarations 
concludes description etyma framework proper 
etyma implemented language 
continually evolving see section currently consists reusable classes approximately lines code 
distinguishing feature etyma design guided mainly formal description denotational semantics type rules corresponding linguistic concepts 
reader noted correspondence framework abstraction design denotational models programming languages 
denotational semantics applies functional programming language functionality 
apply denotational description modularity language modularity 
furthermore framework approach intended provide language developer modular means design implement language value domain type system relatively independently 
basic elements language designed classes framework directly available incorporation language processor 
implementing cms completion mentioned earlier uses etyma framework writing concrete subclasses framework classes instantiating program 
give concrete example precise mechanics completing framework section presents detail design implementation interpreter language cms chapters 
cms interpreter consists parts basic scheme interpreter written language module system implemented completion etyma 
basic scheme interpreter derived publicly available windowing toolkit called stk 
interpreter implementation exports functions implementing scheme semantics making easy access internals 
furthermore interpreter originally designed extensible new scheme primitives implemented easily incorporated interpreter 
example say want implement new scheme primitive new prim takes input parameters implemented function new prim 
done including function call appropriate initialization routine interpreter recompiling add new primitive new prim tc subr new prim order implement cms scheme primitives implementing concepts compositional modularity mk module mk instance self ref merge implemented incorporated interpreter 
specifically new cms primitives identified subclasses etyma classes support primitives designed implemented 
furthermore glue functions extend basic interpreter calling appropriate methods new subclasses implemented 
architecture cms interpreter shown 
scheme library shown left includes macros oo programming define class define prefix chapter support functions written cms 
subclasses framework classes comprising completion shown described sections 
order extend scheme new datatype corresponding modules contain scheme values model scheme value type domains framework 
scheme consists uniform domain class values includes primitive values functions 
sufficient consider scheme values purposes discussion 
scheme variables identifiers interpreter library scm glue completion etyma basic 
architecture cms interpreter 
basic scheme interpreter written extended code consisting subclasses generic classes etyma framework 
scheme library left consists cms macros support functions 
location method etyma classes label completion subclasses 
subclasses framework classes implement cms 
bound locations turn contain scheme value 
scheme values typed variables 
extension scheme preserve scheme essential flavor pragmatics 
module attributes designed untyped names 
furthermore attributes bound values locations methods functions 
possible model notions names values locations functions framework 
untyped nature variables modeled singleton type represented class 
scheme identifiers modeled subclass framework class label notion equality implemented corresponding method scheme names exported interpreter 
location bindings modeled subclass class location method bindings subclass class method 
method subclass need store method body subclass simply store internal representation scheme expression exported interpreter implementation 
self environment managed searching modifying internal representation method body necessary 
described section concrete class implemented class maps label objects attrvalue objects 
attrvalue objects encapsulate objects 
implementation class completely reused implementing scheme modules simply creating scheme subclasses mentioned previous paragraph 
modification needs done subclass redefine create instance return object appropriate subclass class 
subclass needs implement code cms primitives self ref self set attr ref subclass needs redefine certain typechecking routines reflect fact attributes cms declared simply left undefined 
concludes description cms implementation 
reusability framework design conjunction extensibility basic scheme interpreter degree reuse high case cms designed implemented short period time 
table shows measures reuse completion 
rows represent module system implemented completion etyma row represents entire system 
percentages class method reuse give indication design reuse classes methods represent functional decomposition interface design framework 
similarly percentages lines code give measure code reuse 
reuse issues explored section 
reuse issues oo frameworks built reused 
traditional notion reuse code reuse design reuse generally acknowledged equally important 
peter deutsch interface design functional factoring constitutes key intellectual content software far difficult create recreate code 
fact wrong say primary benefit oo frameworks design reuse 
table 
reuse design code cms 
reuse parameter new reused reuse classes etyma methods lines code etyma stk lines code known oo programs reusable specifically designed reused 
designed reusable appropriate method protocol effectively reusing framework documented 
reuse techniques etyma 
designing reuse best known oo reuse mechanism base classes 
classes partially defined classes specify essential characteristics abstraction concrete subclasses provide incomplete parts 
example consider class module etyma 
way design simply specify public methods methods pure 
certainly enable design reuse code reuse 
alternatively public methods designed template methods increase code reuse 
class module public methods implemented terms simple protected attribute management methods specified methods factory methods 
technique results layered design subclass redefine inherited functionality fine level redefining protected methods coarse level redefining public methods 
designers reusable software take special care preclude efficient implementation 
case class module public methods implement applicative operators return copy module requested operation performed 
example concrete subclass desires compose inherited public methods undesirable copies compromising time space efficiency 
avoid public methods module implemented terms protected clone method conjunction protected imperative versions operators 
concrete subclass compose imperative versions operators making copies necessary 
documenting reuse contrast code library sufficient merely publish interface order clients reuse oo framework 
interfaces published usage interface external clients clients public interface extension interface internal clients clients complete framework inheritance 
furthermore order extension interface utilized effectively internal clients accompanied information structure dependencies abstractions modeled framework 
oo diagrams chapter useful 
diagrams greatly enhance client understanding architecture framework 
identification design patterns helpful patterns studied described extensively 
trying implement methods efficiently introducing dependencies methods needs explicitly documented 
example consider implementation project operation dual restrict operation subclass class module 
project simply restricts attributes module implemented terms restrict method 
done typechecking code implementation restrict executed times necessary 
avoid project method duplicate restrict code 
doing introduced dependency project restrict methods time subclass redefines restrict method project method appropriately redefined 
exposing dependencies dubbed consistent protocols literature 
framework evolution fundamental phenomenon oo framework construction evolution iterative reuse cycles 
commonly said reusability framework increases reuse iterations 
reuse reuse 
design cycle frameworks usually characterized follows start building application domain interest identify abstractions generalized 
build th application reusing generalized abstractions identified far simultaneously trying identify generalizable abstractions applications 
value produce truly reusable framework varies widely case case generally believed reusable value framework obtained 
realization etyma framework undergone iterations years 
outline major evolutionary stages 
version etyma fully concrete designed experiment module extension language 
consisted notions modules instances primitive values locations support classes 
programs instantiate classes program modules written appropriate front back constructed 
experiment provided glimpse modular completed judged project demand vastly effort front back considerations framework 
helped identify basic implementational characteristics framework 

incarnation etyma build typechecking mechanism language object modules described section 
experiment type classes etyma 
point etyma primarily set concrete classes 

third incarnation direct design programmable linker loader called omos described chapter 
iteration framework directly construction omos evolved parallel actual class hierarchy omos described section 
revisions continually etyma 
iteration classes etyma introduced template method pattern implementations classes written 
standard concrete classes section developed required new support classes implemented templates 

fourth iteration etyma construction cms described section 
time completion framework design essentially place 
changes framework class method 
code relating module nesting added 
cms interpreter constructed short period time resulted high degree reuse 

iteration design implement idl compiler front described chapter 
design developed iteration reused 
changes framework 
code relating recursive types added 

iteration etyma build document composition system described chapter 
changes framework 
seen iterations iterations essentially evolved framework set concrete classes reusable set concrete classes 
iterations reusable functionality framework 
fourth iteration onwards framework reused completions hardly changing structure framework 
observed reusability framework increased measurements taken record reuse achieved starting iteration 
reuse measurements iteration table similar measurements iterations 
iterations design code reuse significant 
related oo frameworks developed initially user interfaces subsequently domains 
etyma bears close relationship compiler frameworks comprise classes usually generating internal representation programs 
compiler frameworks fall categories represent programs syntactically sage represent programs semantically 
compiler frameworks designed various objectives representing syntax constructing tools programming environments structuring compiler objects representing phases compiler enabling compile time reflection meta object protocol 
etyma supporting unique intended reusable architecture constructing variety modular systems 
mentioned earlier etyma represents meta architecture modular systems 
oo meta architectures employed previously enable reflective flexible extensible language designs 
advantages stem fact reified concretely realized meta classes candidates systematic reflective access 
system designed meta architecture essentially provide users standard interface alternative interface side door internal architecture typically subset meta architecture interface 
information access refinement alternative interface enable applications fine tune language implementation suit particular needs 
meta classes specialized suit specific tasks standard oo techniques inheritance 
compilation setting meta classes specialized statically optimize run time data layout generate optimized code particular special cases 
important clarify relationship concepts meta architecture reflection metaobject protocol mop 
meta architecture models systematically implements documents fundamental concepts system 
meta architecture oo concepts modeled collaborating classes 
system reflective users introspective read modification access reified meta architecture system 
mop documents illustrates disciplined method reflective access carefully chosen subset system oo meta architecture 
etyma primarily application framework modular systems 
impor tant point dissertation design discipline encouraged objectoriented methods fruitfully applied design programming languages 
meta architecture etyma enables construction reflective systems design suitable mops potentially bring advantages mentioned 
points comparison briefly widely known language meta architectures smalltalk common lisp object system clos 
smalltalk smalltalk uniform model communicating objects 
small number concepts object class instance message method 
concept system modeled object instantiable class object instance object 
primitive low level operations system delegated virtual machine 
objects communicate messages semantics messages implemented receivers methods 
smalltalk notion objects captured class object provides basic semantics including message handling objects system 
semantics classes captured class class superclass behavior defines state required classes instance variables method dictionary 
class embodies notion class method class defines method evaluate 
smalltalk dual hierarchy language object oriented languages 
cleanly articulated class subclass hierarchy hierarchy 
languages class instance hierarchy interesting comprises levels classes instances 
smalltalk hierarchy deeper recursive described 
object smalltalk instance class 
classes objects class object instance class usually referred metaclass object 
example class foo instance metaclass expression foo class 
metaclass objects instances ordinary class called metaclass 
metaclass class metaclass metaclass class instance class metaclass just foo class recursion puts infinite regression metaclasses 
consider class subclass hierarchy metaclasses 
class smalltalk inherits class object subclass hierarchy singly rooted tree 
class metaclass mentioned subclass object 
instances class metaclass foo class metaclass class object class meta classes 
metaclasses subclasses class class subclass class object 
actual subclass hierarchy smalltalk slightly involved described due desirability symmetric class metaclass hierarchies description suffice discussion 
clos clos object system supports standard concept classes instantiated instances 
class attributes called slots 
distinguishing feature clos model notion generic functions defined independent class specialized methods applicable specific classes 
generic functions dispatched multiple arguments multimethods 
clos meta architecture specifies basic meta object classes corresponding basic concepts language class slot definition method 
user defined metaobjects designed subclasses meta object classes 
specified default semantics clos language embodied specializations classes names standard standard class standard method 
class subclass hierarchy clos meta architecture follows 
root class subclass standard object capturing semantics objects system 
class created system standard object superclass 
subclass standard object class metaobject basic meta object classes mentioned subclasses 
class instance hierarchy clos essentially levels 
individual clos classes instances class class subclasses 
class class instance subclass standard class meta object classes 
summary argued simplicity compositional modularity enables applied wide variety systems modular programming languages linkers interface definition processors document manipulation systems 
desirable build generic reusable realization model meta architecture abstracts particular characteristics system embedded 
defined scope meta architecture required simple general extensible reusable support reflection 
model compositional modularity expressed independent base languages 
expressed oo manner set interacting partially specified classes known oo framework 
chapter oo framework compositional modularity known etyma 
etyma reused build variety compositionally modular systems 
implementation system interpreter language cms described chapter 
systems described chapters 
etyma consists set highly intertwined classes model value type domains modular systems set generally useful concrete subclasses 
interfaces relationships etyma value type classes concrete classes explained 
framework reusable designed documented reusability mind 
furthermore framework reusable reuse 
etyma design considerations repeated reuse helped evolve reusable framework 
painter needs framework parchment musical group needs framework time 
miles davis presents frameworks simplicity contain necessary stimulate performance sure primary conception 
bill evans liner notes miles davis kind blue chapter composition object modules chapter develops second application compositional modularity composition object modules programmed linkage separately compiled files 
object module abstracted namespace 
set symbols represented symbol table set symbol self represented relocation information modeled abstracted namespace 
manipulation abstracted namespaces precisely province compositional modularity adapt combine link object files 
central idea chapter physical modularity application components separately compiled files essence viewed logical modularity class compositional modules turn support effective application development 
software architecture take advantage idea section 
section proceeds describe mechanics module management architecture 
shows viewpoint solves longstanding problems management binding components day application development environments 
possible perform type safe composition object modules architecture 
details facility section 
motivation application composition linkage traditional application development environment unix application components ultimately take form files various kinds source object executable library files 
entire applications typically built putting components inflexible ad hoc techniques preprocessor directives external linkage managed makefile directives 
natural developers generate components corresponding incremental changes existing application components especially subscribe software engineering principle known extension addition 
principle holds better extend software direct modification controlled addition incremental units software 
advantages extension addition include better tracking changes reliable semantic conformance software increments 
importantly increments potential reused similar settings 
model compositional modularity supports effective management kinds application components 
supports encapsulation helps enhance abstraction 
supports forms inheritance mechanism managing incremental changes software units 
supports various mechanisms adapting components enable reuse broad range situations 
gain supporting compositional modularity infrastructure application development environment support provided languages application components written 
chapter architecture applying compositional modularity oo application development 
architecture demonstrates principled flexible way construct applications components 
facility orthogonal makefiles impose new techniques building individual application components 
relies idea physical modularity traditional application components files endowed power flexibility logical modularity 
logical modules manipulated concepts compositional modularity class modules viewed building blocks transformed composed various ways construct entire application programs 
individual modules entire applications instantiated address spaces particular client processes 
approach advantages making application construction principled flexible 
enables form oo programming components written non oo languages fortran 
second enables adaptive composition system manages logical layer perform various composition time exec time possibly run time optimizing transformations components 
example system services libraries abstracted actual implementations adding level indirection service actual implementation 
permits optimizations service implementation clients disclosed behavioral characteristics 
system level support explored studies summarized section 
part chapter focuses application level support 
chapter performed douglas orr omos object meta object server 
omos primarily conceived object server server process generates implementations programs user system requirements 
omos originally constructed specific purpose illustrating concepts compositional modularity provides infrastructure perfectly suitable doing 
important clear compositional modularity supported logical layer conflict object orientation supported component level languages 
example programmers deal distinct notions modularity classes fundamental logical modularity source files deal physical modularity 
modularity dimensions share characteristics different senses composability inheritance classes linkage files 
orthogonal minds programmers class definitions source files bear relationships linkage performed class universal namespace flattened name 
essence manage programs levels classes semantic relationships files linkage relationships 
approach supports similar degree manageability physical artifacts files logical artifacts classes 
section application scenario motivates architecture chapter 
scenario consider scenario team developers building image processing application vendor supplied shrink wrapped library 
say team completes building initial version application large scale say greater lines code ready system testing 
imagine common problems deriving scenario call wrapping 
suppose team finds application malfunctions calls library function edge detect image data structure consistently incorrect storage format say pixels represented type float byte expected 
traditional tools problem rectified inserting library function call routine site application edge detect called 
approach requires extensive modification application source code expensive recompilation 
separate shrink wrapped libraries put manner sources available 
desirable wrap binding time calls edge detect adaptor calls recompiling large application 
facility usually supported conventional os environments 
ii library extension management 
suppose team decides application better image format slightly different format expected library easy convert old format 
new format supported projects best change library functions accept new format 
sources library available directly modified 
require developing integrating separate extension library 
furthermore independent extensions library need integrated supported applications 
developing incremental extensions subclassing oo programming usually support effectively managing incremental software units 
iii static constructors destructors 
imagine team wants sure statically defined images properly allocated initialized disk program starts flushed back disk program terminates 
currently available techniques doing difficult cumbersome 
iv flat namespace 
say ip library uses motif library turn implemented terms lower level library 
traditional scenario symbols imported motif libraries part interface exported ip library 
way prevent clients ip library obtaining access lower level library interface possibly suffer name collisions interface 
system architecture sections offers effective solution problems 
specific solutions problems section 
architecture conceptual layering step presenting architecture managing object modules clarify conceptual layering application components 
conceptually artifacts physical modularity files various kinds form physical layer 
modules may written components conventional languages notion objects 
example case support manipulating physical modules generating accessing instances run time files simply design time structuring mechanism 
physical layer managed help traditional programming language environments 
example language preprocessor compiler utility debugger library construction utilities help programmer develop application components various kinds 
architecture physical module manipulated class compositional module shall conceptualize logical layer 
layer construction entire applications directed scripts written application programmers describing composition logical modules 
scripts written module manipulation language supports simple merge modules manner conventional linking including attribute encapsulation overriding renaming 
importantly modules class entities language individual operations composed expression oriented fashion produce composite effects inheritance oo programming 
logical layer managed special tool design requirements laid 
tool provide language processing system module manipulation language 
second perform essential operating system services linking modules loading client address spaces 
third services critical path applications able perform optimizations caching 
continually available 
reasons logical module layer prototype described managed server process second generation implementation server named omos 
module manipulation language supported omos derived programming language scheme similar flavor cms 
important distinction course notion modules object files 
modules created reading physical object files 
conventional linking accomplished merge operator module language 
module manipulation operators language enables powerful flexible application composition subject section 
application construction section describe steps constructing application architecture shown graphically 
step build individual application components physical modules conventional programming language 
discussion shall consider language components ideas applied language fortran 
individual components designed traditional program files knowledge logical layer 
alternatively component designed reused suitable programming logical layer wrapper module described section 
application components may owned managed user omos 
printf read libc crt omos file system client client client user app ms banavar app user file system omos cache app 
architecture object file composition 
user application components composed described user module spec app ms printf system components composed module specs crt components composed omos possibly cached instantiated client address spaces 
user directly interact omos command line interface effect module composition instantiation 
user provided application components 
system provided components libraries owned managed omos server accessed service requests omos 
second step create module spec file describes creation composition logical modules application components 
written module language described section 
app ms user module spec describes put components application 
module specs modular refer module specs 
example app ms may refer libc system provided module spec describes put components standard system library client module 
final step request module server execute module spec instantiate load result client address space 
module specs may executed calling stand version omos makefile loading step performed interactively 
omos server important component architecture briefly described section 
system manages logical layer omos 
term meta object originally intended indicative intensional nature module specs fact module specs really programs generate programs 
name considered historical justified 
mentioned earlier omos continuously running process designed provide linking loading facility client programs module combination instantiation 
omos supports main functions execution module specs compose applications caching intermediate results program loading 
clients request omos construct map program providing module spec describes construct program 
module specs refer object files module specs user file system area system area 
system provided components standard library libc shown module specs 
application programs need libc load module spec combine library application components desired manner 
fact system provided libraries represented function abstractions receive application module parameter produce composed module 
example function body libc examine incoming module parameter set meta level primitives custom generate implementation libc best suited particular application hand 
mechanism effect provides level indirection system service actual implementation permitting optimizations service implementation clients disclosed behavioral characteristics 
details mechanism ref 

omos loads programs client address spaces basis system program execution shared libraries dynamic loading modules 
omos module specs implement program monitoring reordering 
omos active entity server capable performing sophisticated module manipulations instantiation module 
evaluation module expression produce results time 
result omos caches module results order avoid re doing unnecessary 
combining caching linker system object loader gives omos flexibility change implementations deems necessary reflect updated implementation shared module clients 
backward compatibility crucial issue addressed context architecture 
issues important support old style linking specs ld automatically translatable module language ii support old style system services libraries opposed module specs 
issues currently worked part ongoing related projects dealt 
interesting system issues related omos 
purpose explore omos explore application compositional modularity flexible application development infrastructure supported omos 
conclude general description architecture proceed describe functionality exported module language section 
object module management argued sections infrastructure aims support effective application development support flexible management application components 
argued management components extensions bindings essentially similar management classes subclasses inheritance oo programming 
argument demonstrate architecture support essential concepts oo programming viz 
classes inheritance shown sections respectively 
facilities described section fact possible consider doing oo programming non oo language 
possible full fledged oo programming manner reasons section 
desirable oo language support directly available 
facility described intended mainly enhancing application component management actual application programming 
classes instances modules object dot file generated compiling source file corresponds directly compositional module 
dot consists set attributes order significance 
attribute file level definition name data storage function binding file level declaration name associated type extern int 
type definitions struct definitions typedef considered attributes 
file treated just class consider file level functions methods class file level data storage definitions member data class declarations undefined attributes static file internal linkage data functions encapsulated attributes 
furthermore dot typically contains unresolved self attributes represented form relocation entries 
symbols defined merely declared physical modules interface logical modules 
simplicity presentation consider interfaces comprise symbol names programming language types see section study typed interfaces 
compiled code data actual object file represent module implementation 
physical dot brought purview logical layer module language primitive called open module syntax 
read logical module manipulated primitives compositional modularity 
encapsulation module attributes encapsulated operator hide see 
case language components encapsulation partly comes free supports internal linkage directive static 
attributes hidden fact attributes static retroactively hide 
useful operation demonstrated section 
oo systems support notion class consisting public private open module string expri fix hmodule expri hide hmodule expri name list expri merge hmodule expr hmodule expr 
override hmodule expr hmodule expr 
copy hmodule expri name list expri name list expri rename hmodule expri name list expri name list expri 
syntax module primitives 
encapsulated attributes 
system similar concept classes supported scheme macro define class syntax define class example dot vehicle contains attributes global integer named fuel global method display displays value fuel attribute write expression module spec create class named vehicle encapsulating attribute named fuel define class vehicle vehicle fuel macro expands simple module expression define vehicle hide open module vehicle fuel instances instantiating module amounts fixing self module allocating storage variables 
case instantiation dot modules fixing self involves fixing relocations dot storage allocation amounts binding addresses 
steps usually performed simultaneously 
object file instantiated executable bound fixed particular addresses ready mapped address space process 
dot instantiated multiple times bound different addresses 
fixed executables modeled instances dot 
module instantiated primitive fix see 
argument specifies constraints fixing module desired sections client address space 
concept closely associated class objects conventional oo languages message sending 
mentioned earlier notion class objects physical layer physical modules implemented component level languages 
message sending directly framework 
approach supporting form message sending inter process communication envisioned described section 
inheritance section introduce inheritance related primitives supported module language describe manner composed 
start introducing primitives syntax 
primitives essentially semantics cms computational sublanguage quite different 
primitive merge combines modules conflicting defined attributes attributes name 
semantics analogous traditional linking object files 
idea go traditional linking support operations basic inheritance oo programming 
primitive override produces new module combining arguments 
conflicting attributes chooses hmodule expr binding hmodule expr resulting module 
primitive copy copies name list expri attributes attributes corresponding names name list expri 
argument attributes defined 
primitive rename changes names definitions self attributes argument name list expri corresponding ones name list expri 
illustrate primitives section describes achieve variations facility generally referred wrapping 
wrapping shows service providing module lib function client module client calls 
varieties wrapping illustrated modules shown 
wrapper void old 
extern void old client client program void 
extern void wrapper void stub 
extern void lib service provider void 

examples wrapping omos 
version lib wrapped module accesses indirected produced expression hide override copy lib old old copy rename expression ensures self lib continue refer overridden resultant renamed old 
alternatively wrapped version lib definition renamed produced expression hide merge rename lib old old useful example want wrap lib wrapper counts number external calls lib count internal calls 
want wrap calls client mediated stub function module expression hide merge rename client stub stub note particular client module wrapped wrapping service provider 
example renaming client module calls produces desired effect declaration self renamed 
generalizing cases varieties wrapping possible model shown pictorially 
leftmost column shows modules wrappers 
top row shows technique referred method wrapping bottom row call wrapping 
corresponds example 
clos language supports technique known methods interpose calls code particular method proper 
calls copy meth meth wrap old meth meth meth method wrapping copy override hide rename merge hide old meth old meth modules call wrapping meth meth meth wrap 
wrapping scenarios 
leftmost column shows modules wrapped wrapped 
top row shows operations effects performing method wrapping bottom row shows call wrapping 
notions method wrapping call wrapping extended support calling precompiled routines generating wrapping appropriate adaptors 
example call method bef module method meth module generate wrapper module function meth calls bef calls old definition meth old meth 
modules combined manner similar method wrapping get effect method hide override copy meth old meth merge old meth single multiple inheritance idioms shown fact basis inheritance current day oo languages shown chapter 
section give brief idea idioms achieve notions inheritance 
recall section class defined macro define class expands module expression uses open module hide 
vehicle class defined 
macro class inherit existing class 
example suppose dot land chars created contains global constant integer called wheels function called display calls declared method called super display prints value wheels 
module land vehicle class created subclass previously defined vehicle module writing define class land vehicle land chars vehicle macro expands module expression define land vehicle hide override copy vehicle display super display open module land chars super display expression module attributes wheels display created override superclass vehicle display attribute copied super display 
new display method access shadowed method super display 
general conflicting attributes determined meta level primitive called conflicts copied name super prefix 
copied super display attribute hidden away get module exactly display method public interface desired 
important point calls display old vehicle module new land vehicle module rebound call display method land vehicle module 
idea single inheritance generalized multiple inheritance languages clos 
languages graph superclasses class linearized single inheritance hierarchy language provided mechanism 
similar effect achieved define class macro programmer explicitly specify order superclasses shown define class land chars land chars define class sea chars sea chars define class amphibian amphibian land chars sea chars vehicle fact explicit specification linearization useful implicit language provided mechanism 
module operations supported module language single multiple inheritance styles expressed shown chapter 
solving old problems operations defined modules possible conveniently solve longstanding problems software engineering encountered 
problems solutions previously ad hoc required changes source code 
module operations permit general solutions impose source code changes 
section delineate clean solutions problems enumerated section order 
wrapping calls 
solve problem section module spec image processing ip application written section call wrapping 
calls edge detect wrapped wrapper method calls function calls edge detect library function 
ii library extension management 
ip library thought oo class incremental changes thought subclasses modify behavior superclasses 
subclasses integrated superclass means module spec uses notions inheritance illustrated section 
iii static constructors destructors 
need generate calls set static constructors destructors program starts 
special code added front generate calls appropriate constructor destructor routines 
order static objects constructed poorly controlled leads vexing environment creation problems large systems 
variants unix language handled need destructors ad hoc fashion allowing programs dynamically specify names destructor routines passing routine 
variants destructors standard library hard coded standard exit routine 
case provision calling initialization routines constructors program startup 
cases module operations allow addressing problem generating calls initialization termination routines general facility special purpose mechanisms 
shown section methods module expressions easily programmed generate wrapper main routine calls initialization routines module call real main routine 
similarly exit routine wrapped exit routine calls destructors module calling real exit 
iv flat namespace 
longstanding naming problem extent language traditionally lack depth program namespace 
level namespace names private module known modules application 
result application uses library imports symbols library symbols imported known application part exported interface 
module operations problems avoided 
module implements low level functionality combined module implements higher level functionality functions interface subjected hide operation avoid conflicts accidental matches higher levels 
type safe composition section technique perform type checking object modules architecture earlier chapter 
type system specific languages incorporated omos type information extracted object modules ascertain type safety combining object modules 
describe detail realization steps ansi utilizing standard debugging information generated compilers 
motivation widely agreed strong typing increases reliability software 
compilers statically typed languages traditional programming environments guarantee type safety compilation unit units 
style name accomplish complete type safety compilation units see section longstanding widely available linkers compose separately compiled units matching symbols purely name equivalence regard types 
common denominator linkers accommodate object modules various source languages simply ignoring static semantics language 
commonly object file formats designed incorporate source language type information easily accessible manner 
programmable linkage facility omos enables incorporation automatic user defined type conversion routines encapsulated data 
automatic conversion postulate safe adaptability rules converting built data types language definition conjunction characteristics particular hardware platforms 
utilize rules automatically generate data conversion adapters link time 
importantly programmer defined conversion stubs easily incorporated link time 
opens possibility programmer controlled data evolution conversion heterogeneous data formats arising different languages hardware architectures link time type checking helps adapt utilize full expressive power language type systems better suit modern persistent distributed heterogeneous environments 
example structural typing applied languages ansi name typing 
pure name typing problem persistent distributed environments data types migrate outside program originally created lead matching names may may programmer intended meaning 
argues structural matching aggregate types similar modula member order type significance names 
scenario ansi program source object file considered module consisting set attributes order significance 
interface consists types attributes module information defined merely declared 
example shows module interface consists attribute define void struct module interface consists attributes define void void declare void int consider case programmer creates compiles module intention definition performing merge module module module struct int 
struct 
extern int void int struct int 
extern struct int stub return 
linkage adaptation 
modules composed expression rename stub merge merge incorrect presumption returns int 
merge untyped common linkage merge legal disastrous results 
typecheck interfaces type compatible merge operation return types related 
suppose programmer discovers linkage returns desired int value component returned structure 
traditional scenario order compatible programmer modify source code module extensively recompile 
possible precompiled libraries 
possible adversely affect combination modified module modules 
programmability supported module management facility crucial alleviate problem 
example adapted constructing adapter module 
consists declaration matches definition stub function stub extracts desired value structure returned modified version obtained module expression merge rename stub merge ed get originally desired effect 
effect similar call wrapping explained section type error corrected transformations object modules indicate serious error design modules involved 
furthermore process wrapping procedures enhanced availability module type information 
wrapper procedure automatically constructed signature identical wrapped procedure simple language constructs propagate caller arguments wrapped routine 
type information available cases printf routine defined take variable number arguments necessary machine dependent wrapper preserves passes call frame knowledge contents 
type system order ascertain type safety modules combined module type rules section built linker requires knowledge type system type domain type equivalence subtyping base language ansi attributes match name 
matching attributes single interface attributes match interfaces type compatible 
section describes relevant type system ansi type domain type equivalence enhancements type checking compilation units structural typing function subtyping 
type domain ansi consists basic types primitive types int float enumerated types ii derived types function types struct union types array pointer types iii typedef ed names 
specifiers types augmented type qualifiers const volatile storage class specifiers auto register static extern 
type qualifier volatile concerns optimization relevant 
type qualifier const significant typing distinguishes read variables read write variables explicitly dealt section 
storage class specifiers auto register relevant may functions interested file level declarations definitions 
storage specifier extern indicates attribute declaration attributes considered defined 
storage specifier static file level attribute gives internal linkage attribute viewed having subjected hide module operation 
similarly attributes subjected hide link time programming regarded having converted static storage class fact 
permits calls functions declared module 
call undeclared function module results implicit file level declaration extern int 
type equivalence type equivalence ansi single translation unit extensions type checking translation units table 
changes defaults 
mentioned earlier aggregate types struct union name equivalence weak applied outside single translation unit argued earlier 
adopt conservative structural typing regimen names order types members significant 
retain significance aggregate tags application specific semantic content 
second typedef ed names application specific semantic content adopt strict name equivalence 
furthermore type specifiers implied short implies short int types equivalent 
type qualifier const significant equivalence 
table 
type equivalence ansi type translation unit translation units primitive name equivalence function structural parameter types significant enum name equivalence struct union name tag equivalence tag types unique structural tag member order names significant pointer equivalence target types array equivalence element types equality array size typedef typedef ed type typedef name equivalence subtyping module operators merge override utilize subtyping rules type checking combination 
base language ansi notion subtypes subtyping considered restricted type equivalence 
module composition flexible retroactively formulate subtyping rules consistent ansi language definition 
ansi language specifies safe conversion rules certain primitive arithmetic data types float double 
conversion said safe values type represented values loss precision change numerical value 
compilers usually expected support safe conversions defined language governed hardware characteristics 
safe conversion rules thought subsumption rules turn provide basis formulating subtype rules primitive arithmetic types 
shows data type sizes partial order subtypes hp series machines 
instance value type short safely coerced value type float platform loss precision change numerical value 
ask rules exploited type checking attributes translation units 
consider file level variable declarations 
variables evaluators expressions return values acceptors expressions receive values different contexts 
expressions evaluators replaced expressions types subtypes original expressions acceptors replaced expressions types supertypes original 
result subtyping variables restricted type equivalence 
consider file level read const variables 
subtyping involving type qualifier const described follows non const type subtype non const type const subtype const subtype const const subtype example declaration extern const float translation unit considered subtype definition short bit field enum sizeof float signed char int short int long int unsigned int unsigned char long unsigned int short unsigned int float void double long double 
subtyping primitive data types 
safely combined 
unfortunately case size layout formats various primitive data types usually incompatible requiring active coercion 
certain cases enum types compilers usually optimize layout packing fact enum type really int utilized 
translation unit subsumption rules applied compiler complete knowledge layout usage generate appropriate conversion access code 
similar arguments hold subtyping constant user defined aggregate data types struct union translation units 
example struct shorts considered subtype const struct const floats short subtype const float 
furthermore unions discriminated member access type checked run time 
example union short component read accessed supertype union const short const float component translation unit way supertype accessor know run time union contains short value float value 
result subtyping file level read variables restricted type equivalence 
arguments formulated show subtyping pointer types restricted type equivalence 
consider subtyping function types 
subtyping function types contravariance 
function type subtype number arguments return type subtype input argument types supertypes corresponding ones 
rule pass function actual parameters subtypes formal parameters function definition 
subtyping function types unspecified variable number arguments require subtype number explicitly specified argument types supertype proper relationship 
rule translation units compiled function amount space allocated input parameters exactly size expected types format expected exactly specified 
surprisingly useful subtyping rules discovered existing language direct application type checking translation units 
crucial observation useful subsumption rules utilized data encapsulated functions adapters stubs perform appropriate coercion data types inserted combined modules link time 
feasible stub functions compiled utilize data format conversion knowledge compiler uses translation unit 
applying stub technique global data feasible involves initializing global variables nonconstant values illegal ansi function types lend particularly technique performance function calls affected indirection performance data access 
unreasonable impose requirement users encapsulate data foresee accessed supertypes 
architecture possible automatically generate coercion stubs functions primitive type conversions shown 
example type adaptation language defined subtypes consider 
mentioned earlier type short subtype float 
definition function module subtype contravariance declaration function module 
directly merged general calling sequence compatible definition expecting input floating point register integer register 
remedied combining automatically generated stub module incorporates safe coercions performing desired merge shown 
structural record subtyping member name type order significance possible example shown 
emphasized technique applies input output parameters functions coercion stubs automatically generated account function subtyping 
technique type conversion stubs generalized illustrated provide general facility incorporate user defined stubs link time arbitrary data format conversion 
module comprises user defined stubs 
module module module automatically generated short float 
extern float short void float extern short float float stub short return float float 
automatic data coercion language rules 
modules combined expression merge hide merge rename stub stub module module module automatically generated struct short float struct 
struct float extern struct void 
struct short float struct float extern struct struct stub struct struct struct struct ret ret float return ret 
automatic conversion structs structural subtyping 
modules combined expression merge hide merge rename stub stub module module module 
extern void value extern stub return 


programmer defined data conversion 
modules combined merge merge rename stub implementation omos just interpreter cms possible design implement omos completion etyma framework 
shall refer omos implementation parallel completion etyma reasons 
implementation omos described strictly speaking completion etyma way cms interpreter directly reuse code etyma 
design omos closely follows class design etyma 
concepts compositional modularity developed respect etyma cms directly reused context omos 
generation implementation omos existed etyma born 
lifecycle omos reengineered incorporate major design enhancements 
upper class hierarchy follow etyma class design 
designed direct completion etyma pieces software significantly diverged terms example conventions management infrastructure 
conceptually reason omos implemented class completion etyma 
omos class hierarchy consists classes corresponding etyma classes module instance 
notion object file implemented concrete subclass module 
methods class implemented code library provides relative independence particular object file formats binary file descriptor library cygnus 
mentioned earlier dot instantiated fixed executables modeled class subclass instance 
fixed executable internally represented address map 
address map collection entries specify address virtual memory process block object file mapped 
front omos scheme interpreter derived stk package similar cms 
new primitives added scheme interpreter instantiate appropriate classes invoke appropriate methods 
type safe linkage object module type checker section built reusing design code early version etyma framework 
ideally compilers generate object modules self describing format information source language machine architecture interface packaged object module readily accessible format 
far reality closest approximation object file compiled debugging option instructs compiler generate type information standard encoded format 
object files compiled debugging option contain type information compiled debugging option contain information necessary type checking linkage types local variables line numbers extracting type information generated debugging information involved steps prototype 
gnu compiler gcc generate debugging information extern symbols debugging normally performed executable files external resolved 
solve modified back gcc generate debugging information symbols 
accessing sections object file contain debugging information stab library parse format debug strings yacc lex generated parser 
parser instantiates appropriate subclasses etyma classes create interface object module 
instance subclass framework class implements partial order primitive types introduced 
subclass framework class implements concrete notion interfaces dot files 
similar subclasses exist representing function types struct types type checking facility source programs written ansi function declarations specified new style prototypes 
furthermore usage header files minimized explicit declarations external functions provided 
programs type checked link time re compiled modified compiler debug option 
legitimate concern size object files result inclusion debugging information 
size object files increase significantly due debugging information problem exacerbated inclusion huge library header files 
solution problem type checking link time necessary include header files traditional way 
programs explicitly declare prototypes external library functions called 
discussion disadvantages header files traditional manner section 
related essence general concrete realization vision due donn 
omos traditionally linkers support little control name conflicts semantics combination 
mentioned earlier traditional linking essentially amounts supported merge 
programmable linkers exist offer generality flexibility system 
typically notion hiding supported 
novel support expressive suite combination operators ability full featured programming language compose object modules 
systems point view user space loader omos considered longer unusual 
omos similarity utilities dld aid programmers dynamic loading code data 
apollo dsee system server system managed sources objects advantage caching avoid recompilation 
dsee primarily case tool take part execution phase program development 
module language omos somewhat similar architecture description languages rapide polylith module interconnection language mil omg interface definition language idl 
languages share characteristic support flexible specification high level components interconnections 
approach offers important advantage oo program adaptation reuse techniques inheritance meanings applied legacy components written non oo languages 
environment flexible application development pursued line research leading called subject oriented programming sop 
research subject essence oo component component built oo class hierarchy 
subjects separately compiled composed tools know similar omos 
various operators similar ones 
primary difference sop research sop broadly conceived oo nature individual components aims build toolset object file formats specifically tailored sop 
hand research focussed layered evolutionary support 
type safety integrated development environments ides strongly typed languages eiffel utilize mechanisms type checking separately compiled modules complete knowledge control source object modules 
differs ides provide systemwide linkage facility attempts typecheck combined modules independent language processors 
furthermore programmability linker enables fine tuning compatibility possibly heterogeneous object modules link time 
berkeley pascal compiler pc similar effort employs debugging information check type consistency separately compiled modules 
compiler routinely generates stab format type information object modules binding phase compiler check consistency delegating actual linking ld 
crucial advantage approach perform type checking controlled programmable link time activity 
header files longstanding attempt type safety separate compilation 
annotated manual page explains inadequacy header files follows 
tried ensure consistency separately compiled programs controlling information compiler header files 
approach works fine point involve extra linguistic mechanisms usually error prone costly need programs addition linker compiler know detailed structure program 
including header files clearly modular error prone explicitly declare expected external functionality library functions linker check consistency link time correct inconsistencies programming 
objective enabling type safe linkage constraints existing linkers stroustrup describes mechanism encoding functions types input arguments 
mechanism inadequate purposes certain classes type errors detected page variable types function return types encoded ii extended deal structural typing aggregate types scale arbitrarily large types large structs iii want type checking useful adaptation link time utilize sophisticated linker technology 
plethora literature related stub generation 
system representative automatic stub generation programming heterogeneous environment 
packages heterogeneous modules utilizing programmer defined specification interfaces execution environments specified common module language 
packaging process involves generation client server stubs handle module interconnection data type coercion dynamically 
technique differs enable combination precompiled object modules automatic extraction interfaces programming 
summary argued conventional application development environments lack support effective management application components 
illustrate problems faced application builders similar solved concepts oo programming 
conclude beneficial support oo functionality component manipulation binding environment 
show support oo development achieved elevating physical modularity separately compiled files application components level logical modularity managed systemwide server process 
server supports module language scheme class modules manipulated powerful suite operators 
expressions modules achieve various oo effects encapsulation inheritance directly supporting application development oo manner 
manner enable superior application development environment conventional infrastructure 
addition described programmable linkage facility separately compiled ansi object modules 
design type system ansi linker typecheck composition extracting interfaces object modules compiled debugging information 
furthermore automatically generate conversion stubs compatible encapsulated types permit easy incorporation arbitrary user defined type conversion stubs link time 
demonstrated powerful flexible type safe linkage facility 
chapter interface composition widely believed complexity modern distributed systems requires sophisticated language sublanguage explicitly specify interfaces application components interact 
service providing components said offer interfaces client components invoke possibly remotely 
requirements modern distributed systems necessitate support inheritance component implementations explicit specification adaptation combination interface specifications 
suggests interfaces regarded compositional entities making possible apply composition operators interface composition 
chapter explores third application compositional concepts 
section develops idea interfaces compositional entities presents idl compiler front completion etyma 
section sketches existing idls extended compositional concepts 
software architecture description developing large complex concurrent systems requires significant effort spent describing architecture iterative design activity documentation purposes 
informal architecture description pictures frequent practice system design 
formal machine processable descriptions necessary widespread especially context distributed systems 
architecture aims describe components system relationships communicates 
properties usually described architecture description languages adls varying degrees expressive power 
description conventional typed interfaces components simple example architecture description 
sophisticated description concomitant benefits complexities specify typed interfaces structural component behavioral invariant interaction event description relationships 
family languages known interface definition languages idls increasingly popular arena distributed systems described subsection 
wide variety idl designs idl typically provides subset functionality adl 
interface definition languages components modern distributed systems usually written conventional programming languages fortran shall call component programming languages 
languages usually support form weak specifying interfaces components header files distributed systems refs 
support separate idl distinct 
explicit interface descriptions useful various purposes specification 
specify contractual obligations service providing component clients ascertain met 
minimally idls employ conventional programming language types specification interfaces idls ref 
support stronger forms behavior specification 
interoperability 
intermediate language facilitate interoperability components heterogeneous hardware programming language environments 
usually language mappings idl individual vice versa see 
implementation 
source language automatic generation communication code components 
idl compiler usually reads idl specification generates stub code performs packaging marshal ing communication unmarshaling arguments remote procedures calls rpc 
power idl exceed conventional programming language type systems question arises need supporting separate idl human readable 
argued ref 
type systems individual augmented constructs specify interoperability requirements generate specifications purely machine readable idl 
beneficial burdening programmer programming language achieving high degree interoperability 
designing extensions existing cpl considerably harder introducing new cpl neutral idl 
eliciting acceptance new language extensions community users existing language usually problematic 
rest chapter consider aspect idls supports typed interfaces ignore interoperability adapter generation aspects 
compositional interfaces having established role purpose separate human processable idl consider expressive power desired language 
may useful specify interface reusing inheriting existing interfaces 
reuse facilitates evolution interfaces ascertaining inheriting interfaces evolve step inherited interfaces 
simplifies maintenance reducing redundant code 
importantly idl able express types components generated implementation inheritance 
fact shown inheritance interfaces generates exactly types known inherited types correspond types inherited objects 
inherited types distinct subtypes see 
reasons point need flexible interface inheritance mechanisms idls 
existing idls refs 
support form interface inheritance 
idls idl described section unnecessarily limit expressiveness interface inheritance mechanism 
support compositionality interfaces prove useful especially layered top existing idls including support inheritance 
order apply compositional concepts interfaces establish interface regarded abstracted namespace 
interface represents type component 
interface comprises set names associated types subcomponents 
particular domain base types non interface types idl course chosen idl designer 
furthermore interfaces may recursive type constituent may refer back entire interface 
example consider point module contains attributes corresponding rectangular coordinates method move changing position point equality predicate equal 
interface may expressed follows recursion expressed keyword 
interface float move float float boolean equal general idl may support interface type constituents refer sibling type constituents similar notion sibling member access self objects 
example point interface may specified follows interface float move boolean equal manner type move operation track changes constituents 
convenience may abbreviated inheritance operation recursive structures applied interfaces 
instance interface extended color attribute merge operation follows interface color type color interface merge inherits interface subtype due contravariance equal method 
order subtype incoming argument type equal supertype 

shares structure known inherited type 
important point note merge operation interfaces generates types correspond types inherited module implementations generated merge override operations 
override operation defined interfaces produce types directly corresponding override operation cpl module implementations 
interface override operation type constituents interfaces may arbitrarily rebound 
primary motivation including operator support high degree reuse existing interface specifications 
example constituents rebound complex type note automatically result proper type move constituent due self 
interface override interface complex type type constituents may rename results self get renamed 
useful resolving name conflicts performing operations equivalent multiple inheritance 
furthermore particular interface constituents may project ed 
operation analogous notion relational algebra dual restrict operator earlier 
operator copy useful context interfaces 
operators freeze hide apply interfaces definition represent public types modules 
section provide formal characterization interface inheritance order clarify notions 
type generators interface recursive structure corresponding shall call type generator 
type generators analogous ordinary generators section functions records labels bound types viewed values 
sense types class idls 
description type generators manipulation section independent particular type domains 
shall notate type generator fa attribute names bound types respectively 
note stands notion type constituent refer back entire interface 
interface previous section written ype fx real real move real theta real equal cpl may support type system type point module may directly recursive type 
case instances point module type fixpoint type generator 
case cpl support recursive types type modules may fixpoint type generators 
compositional inheritance adapt combine type generators 
merge operator combines type generators conflicting attributes described deduction rule gamma ff ff gamma fl fl gamma merge ff ff fl fl equality subtyping base types base language specified 
interfaces recursive types subtyping determined structurally described rule algorithms subtyping recursive types amadio cardelli gamma fa ff ff ff gamma fa ff ff gamma ff ff gamma gamma example merge operation merging type generator ype fc produces type generator fx real real move real theta real equal bool mentioned earlier type subtype ype due contravariance equal method 
inherited type 
important understand type inheritance necessarily produce subtypes 
main motivations merge operator able generate interfaces correspond inheritance module implementation language 
override operator type generators defined exactly object generators permits labels rebound arbitrary types gamma override rename restrict operators usual semantics specified entirely analogously 
mentioned operator project dual restrict quite useful context interface reuse copy freeze hide operators defined 
compositional nesting supported type generators developing closed type generators 
doubtful expressiveness useful context idls 
worth mentioning types applicative structures context idls 
say manipulation type generators viewed applicative operations copy semantics notion assignable type variables 
experimental idl section describe implementation experimental compositional idl concepts described previous sections 
base type domain language consists primitive types function types record types 
interfaces language follow structural type discipline 
furthermore interfaces recursive component type interface keyword refer interface 
interfaces composed operators merge override rename project semantics previous sections 
examples specifications section 
compiler front language designed completion etyma framework 
implementation architecture shown 
front parses idl source builds internal representation process interface description desired produce communication stubs 
briefly class design completion follows 
define class subclass class define methods merge rename label label return new interface objects performing appropriate operations 
type equality subtyping methods reused directly class 
implementing base types create subclass etyma completion idl source yacc lex parser 
architecture idl front 
model function valued attributes operations interfaces 
subtyping contravariance operations 
keep language design simple define subtyping type equality types 
subclass model primitive types idl 
struct types type identity idl subclass subclass 
design code reuse numbers completion table 
making idl compositional illustration existing idl enhanced compositional concepts extension idl specified part common object request broker architecture corba section 
corba idl specify interfaces comprising data attributes constant variable operations functions type definitions exceptions 
type domain consists basic data types short float char boolean constructed types struct union enum template types sequence string arrays functions 
interfaces constructed types name typing function declared accept interface type accept objects type named interface inherit inheritance operator case members inherited interface members inheriting interface provided conflicts 
quite rudimentary notion interface inheritance permit redefinition operation method types breaking larger interfaces smaller ones resolution name table 
reuse design code idl 
reuse parameter new reused reuse classes methods lines code conflicts case multiple inheritance 
motivated section beneficial support richer notion interfaces interface inheritance 
extend corba idl specific directions 
shall support operator merge lets generate interfaces result implementation inheritance 
requires support rebinding operations 
valid types merge rebind constituent name resultant interface inherited type original interface 
resultant interface share recursive structure original interface need necessarily subtype 
interface inheritance weaker notion subtyping 
integrating notion inherited types name typing deserves consideration 
idl interface names type 
consequently derived interface extension names inherited type subtype base type 

integrating inherited types name typing introduce structural typing interfaces 
pure name typing problem distributed environments data types migrate outside program originally created lead matching names may may programmer intended meaning 
structural typing names types individual constituents interfaces significant 

shall support arbitrary rebinding operations override operator 
naturally override result totally unrelated types 

currently name conflicts case multiple inheritance illegal 
support attribute renaming solve problem 

just desirable build larger interfaces smaller ones equally desirable break larger interfaces smaller ones 
introduce operator project interfaces support 
add features introducing notion described earlier 
consider example interfaces shown 
interfaces inherit redefining op operation return value case 
subtypes interfaces inherit need subtypes due recursion input argument op 
interface combines resolving conflicting name rename operator conflicting name op unrelated types combined renaming override operator expression case op resultant gets type right operand 
interface inherits interface derived subset project operator 
related language extensively treats foundations type systems relation inheritance 
notions inherited types taken 
type sublanguage rapide programming language framework supports functionality chapter 
supports interface op long op long arg interface merge op boolean op arg interface merge op long op inout long arg interface rename op op merge interface override interface project op op merge void op 
example specifications extended idl 
structurally typed interfaces subtyping recursion forms parameterized types interface inheritance renaming projection 
addition rapide supports notion private interfaces facilitates adt style implementation ary methods 
permit arbitrary overriding override operator 
notion self type constituents interfaces 
concert multilanguage distributed programming system interface specification responsibility individual programming languages separate idl 
machine readable idl define equivalence declarations different languages support single intermediate representation 
interface inheritance address variety problems evolution distributed systems explored nicely ref 
context spring distributed system 
summary argued chapter complex distributed systems need explicit notion interface specification expressive language support specifications 
expressiveness required language typically includes notion interface inheritance 
shown interfaces recursive namespaces compositional concepts support reuse interface specifications 
structure known type generators introduced describe notions interface composition 
experimental idl supports interface composition operators merge override rename project 
way extend corba idl concepts discussed 
chapter document composition large complex document broken composed smaller pieces 
example source thesis broken files corresponding chapters turn composed files corresponding sections 
documents developed purpose reused purposes 
example thesis regarded composition previously written technical reports papers modifications added material 
persuasive example report generation user manual composed design document fragments 
structured document modeled compositional module 
sections document correspond module attributes section comprising label associated section heading textual body 
cross text section labels correspond self 
document regarded abstracted namespace 
model compositional modularity enhance composability reusability documents 
chapter explores applications compositional document processing section presents system composing document modules section 
applications document composition general document reuse useful scenarios document fragments generated edited composed revised maintained delivered various ways 
envisioned applications described sections 
report generation environments numerous document fragments generated ultimate goal putting coherent reports human consumption 
example design documents generated application software development form basis producing user manual manual application 
concepts compositionality routine report generation activities automated 
consider example 
top shown set document fragments labeled mn 
fragments sections section lij jth section fragment mi 
section may contain cross defined undefined sections document fragment 
fragments considered compositional module ways usefully put described boxes scheme language 
examples function named cl project projects sections corresponding closure self lnp mn ln merge cl project merge cl project 
cl project mn mk module nest cl project 
nest mn mn cl project mn ln ln 
example report generation 
sections 
function written module primitive project introspective primitive self refs see chapter 
expression merges closures particular sections projected modules producing document containing sections level 
expression creates new document module nests subsection original module contains closures particular sections projected original modules 
document composition required routinely example document centered industrial manufacturing processes document fragments generated stages process 
imagine car manufacturing plant individual document fragments generated materials receiving parts warehouse inventory parts checkout various points assembly line product storage delivery 
compositionality fragments automatically composed various ways produce number extremely useful reports inventory statement parts catalog assembly reports process monitoring quality control documents architectural specifications tremendous amount document generation consumption activity building construction 
fact specialized document processing systems architectural activities devised 
typically building architect obtains large materials specifications shall call developer 
architect carefully extracts parts various pertinent project hand 
parts integrated various project related documents client specifications exist various document fragments 
process entail significant amount editing composition document composition system clearly useful 
integrated document delivered building contractor 
problems scenario potentially solved compositional module system 
generally delivered linear document richer structure modularity taken advantage architect 
second maintenance numerous documents generated architect cumbersome 
example usually multiple copies document fragments various projects making evolution hard 
document composition system supports document reuse single copy document module maintained composed necessary 
revision control revisions essentially incremental additions modifications need integrated base artifact 
compositional modularity useful integration revisions 
architectural scenario previous subsection developer periodically release new revisions architect 
architect faced problem integrating information new release existing document fragments architectural specifications provided contractors 
document composition system provide effective mechanisms revision control 
example composition script new revision extract updated sections new revision 
alternatively original document earlier revisions regarded inheritance hierarchy revisions revised specified new hierarchy 
hierarchies combined section 
relationship compositional modularity revision control section 
system document composition having motivated utility compositional document processing section presents system 
modular document processing system programmable facility helps document preparer adapt compose doc uments effectively 
section compositionally modular document processing system called mt described 
mentioned earlier model compositional modularity layered top variety computational sublanguages 
mt system chapter built top restricted version document preparation system 
typesetting program takes ascii text file annotated typesetting commands section ref produces high quality document device independent dvi file 
authors concentrate content document formatting details 
documents compositional modules mt module syntax specified grammar 
semantically mt module modeled generator ordered set sections label bound section body nested module 
section label symbolic name referenced sections 
section body tuple text corresponding section heading corresponds actual text body consists textual segments interspersed self labels 
example module semantic representation shown 
module attributes sec intro bound section body sec model bound nested module sec concl bound section body 
model document modules consider meaning operations compositional modularity 
binary operator merge produces new document module sections right module operand concatenated left module operand conflicting labels module operands 
order sections significant merge associative commutative 
binary operator override concatenates modules presence conflicting section labels 
conflicting sections right operand replace corresponding ones left operand 
nonconflicting sections right operand appended left operand order occur right operand 
module whitespace section list mt module section list empty section list section section def label section body def label section heading whitespace section heading label label symbolic section label section body empty section body segment list segments segment whitespace text arbitrary text ref label self 
mt module syntax 
section label sec intro propose 
section model label sec model subsection structure label sec struct 
ref sec intro 
subsection behavior label sec behav 
ref sec struct 
section label sec concl shown sec intro 
propose model sec model 
sec struct 
structure sec behav 
behavior sec concl 
shown 
example mt document module top semantic representation compositional module bottom 
restrict operator usual meaning removing sections 
dual operator project potentially useful context document composition 
operators rename copy usual meaning 
mt system chosen support encapsulation hide operator related concept static binding freeze operator 
encapsulation conceivably fairly natural meanings applications document processing 
example hidden sections appended special appendix suitably titled 
alternatively new document consisting hidden sections created citations new document inserted place hidden sections 
hierarchical nesting important useful notion document structuring 
nest operator supports retroactive nesting document modules described chapter 
issues arise 
system support nested namespaces labels nested modules conflict labels module 
checked type rule nest model interface document comprising flat set labels module 
second self environment indistinguishable mt modules 
nest operator considers unresolved self nested module argument stand environment 
due nature generator model stands self nested modules refer labels surrounding scopes labels nested modules 
naturally notion typing mt notion module interfaces consisting label names mentioned 
notion instantiation documents interesting 
thing instantiation involves binding self 
additionally instantiation results allocation space layout instances 
considering instantiation mt document modules conceptually equivalent running latex program document produce dvi file 
fact latex normally need run multiple times file order resolve iteration directly corresponds fixpoint document module 
mt architecture architecture mt document processing system tiered similar architecture chapter 
physical modules created syntax described previous section 
section bodies arbitrary text including arbitrary command source 
scheme derived module language transform physical files class compositional modules compose various ways 
example mk module primitive read physical document module 
operators project nest override adapt combine class modules written back files write module 
syntax sample primitives shown 
meta level introspective primitives self refs see section useful manipulating documents 
example project self refs write scheme function projects closure self set sections 
fact function called cl project included standard scheme library associated mt chapter mt script files contain arbitrary scheme code 
section order crucial documents user wish reorder sections primitive reorder 
mk module file namei write module hmodule expri namei merge hmodule expr hmodule expr override hmodule expr hmodule expr project hmodule expri list expri nest module expri module expri self refs hmodule expri list expri reorder hmodule expri list expri 
sample mt primitives 
simple example mt document composition shown 
say document shown stored file named body tex imagine file oo tex contains sections corresponding various concepts oo programming 
expression compose files override mk module body tex nest mk module sec model oo concepts mk module oo tex expression nests module oo tex section label sec model freshly created empty module overrides module 
resultant module section labeled sec model bound nested module consisting sections describing oo concepts 
module written file instantiated dvi file 
examples ones shown easily encoded mt implementation implementation architecture mt shown 
yacc lex parser reads document modules creates appropriate framework classes returns class mt module object class 
modules manipulated scheme primitives interpreter 
subclasses etyma created construct mt label section method 
new class segment created 
approximate design code reuse numbers mt implementation shown table 
etyma basic interpreter glue completion module text yacc lex parser expressions scheme 
architecture mt system 
table 
reuse design code mt reuse parameter new reused reuse classes etyma methods lines code etyma stk lines code summary chapter characterizes documents abstracted namespaces making possible apply notions compositional modularity 
module operators introduced previously shown sensible beneficial document reuse 
inheritance shown reap benefits context documents 
example document fragments generated purpose reused similar related unrelated purposes 
evolution maintenance easier 
document processing system called mt supports composition modules written variant introduced 
examples mt applications report generation architectural specification revision control discussed 
chapter shown model compositional modularity beneficial nontraditional computer applications document processing 
chapter having demonstrated expressive power broad applicability compositional modularity detail chapter recapitulate significant lessons learned research point unexplored directions 
summary contributions dissertation shown model compositional modularity facilitates high degree reuse supporting effective recomposition mechanisms highly decomposed software 
particular shown compositional modularity supports stronger flexible notion reuse traditional class inheritance object oriented programming 
compositional modularity defines comprehensive suite operations manipulate self referential namespaces 
owing pervasiveness namespace manipulation software systems compositional modularity applied unusually wide range systems 
demonstrate systems described shown derive significant benefits incorporating compositional modularity 
facilitate efficient construction tools systems reusable software architecture developed successfully reused 
specifically dissertation advances previous research 
programming style compositional modularity illustrated examples 
model shown unifying scope emulating important idioms object oriented programming including forms single multiple inheritance wrapping inheritance hierarchy combination 

hierarchical nesting characterized composition operation shown expressive feature demonstrating applications 

realistic imperative language called cms embodying major aspects model designed implemented 
cms augmentation programming language scheme 

compiled object files characterized compositional modules 
architecture managing modules building entire applications composing described 
primary component architecture programmable linker 
longstanding problems component management shown alleviated architecture 

interfaces virtue recursive structures shown benefit compositional concepts 
experimental compositional interface definition language 
ways augment existing idls suggested 

shown document fragments viewed compositional modules may reused applicable situations 
modular document processing system layered document preparation system applications described 

generic reusable object oriented framework known etyma constructing tools systems compositional modularity designed implemented 
current version etyma comprising classes lines evolved iterations documented design patterns 
etyma reused realize significantly differing tools completions direct completions fourth parallel 
reuse design code measured completions significant 
limitations model compositional modularity 
model entirely unifying previous models modularity 
example model benefit supporting slightly weaker notion encapsulation supported adt 
implementation binary generally ary methods facilitated 
particular framework compositionality specified strongly typed compositionally modular language 
possible currently due binary operations merge override 
additionally noted binary module operators merge override specified polymorphically require complete knowledge incoming parameters 
problem integrating notion adt inheritance presence static typing noted ref 

interesting useful directions connection compositional modularity unexplored 
sketched section 
directions framework enhancements design etyma enhanced encompass functionality 
specific areas come mind 
type system supported etyma improved 
typechecking method implementations input output parameters specified supported 
associating type tricky due hide operator 
hiding shrinks expands interface inheritance 
bound interfaces essentially specifies attributes hidden fact required support feature 
second support overloading ad hoc polymorphism may necessary attempting apply compositional modularity systems 
supported augmenting notion attribute matching modules having name type attributes significant 
mentioned earlier etyma support front back related abstractions tool construction 
supporting front ends modular parser associated abstraction parses calling parsers associated abstractions turn 
object oriented parser technology yacc utilized 
back compilation interesting 
say want support translation language 
usual front build internal representation program comprising instances specialized etyma classes 
class method support method translate translates body code 
method implemented terms calls translate methods abstractions specified completion classes 
furthermore occurrence module instantiation source class method translate call class module method gen instance generate code allocates instance module appropriate layout object layout mechanism suggested ref 

compilation presence class modules slightly involved code represent modules perform module operations run time generated 
completions processors programming languages built reusing etyma 
programming languages non oo languages similar scheme oo 
course oo harder reconcile semantics pragmatics preexisting oo model compositional modularity 
brief treatment extending modula incorporate compositional operators ref 

opinion gained layering compositional modularity top non oo languages systems examples 
general modularity layered ways class run time modules instances case namespaces manipulated prior run time ii class instances class modules similar conventional oo languages iii class modules instances similar cms 
instance programming language extended ways 
interesting consider potential applications compositional modularity conventional programming languages 
instance hypertext documents world wide web www correspond namespaces internal url self external nonlocal url 
documents statically composed shown chapter 
individual document fragments considered nested universal namespace urls nonlocal simply interpreted hypertext tool find remotely located documents 
application management visual entities windows buttons menus graphical user interface environment 
case container canvas considered namespace various individual elements buttons panel displays attributes associated name dimensional position 
furthermore attributes panel displays refer attributes slide bars 
notion namespaces adaptation operations renaming copying removing composition operations merging overriding nesting performed kind shell language 
idea corresponds existing characterizations gui entities objects oo programming 
third application file system directories viewed self referential namespaces 
directory consists file names bound file contents potentially refer back file names source code directory include directives 
desirable construct specialized compositional file system manage source code repositories 
version management general version management compositional modularity inverse relationship 
compositional modularity module old increment delta specification phi combine generate new module new 
old phi delta new hand version management new module new old module old generate difference delta specification inverse psi say phi obtain new old 
new psi old delta version management system stores old delta phi old version new version generated 
effect revision history module comprises incremental modifications delta composition history phi 
raises interesting question relation psi inverse phi compositional modules automatically computed 
traditional tools diff compute delta granularity text lines interesting study mechanisms compute delta granularity module attributes 
event analysis suggests albeit completely satisfactory way perform version management compositional modularity sketched section 
new revisions modules specified giving module new giving delta phi stored newly generated module new 
manner module carries composition history form meta level primitives extract older versions module 
distributed programming treatment far composed modules tightly bound centralized manner 
case program modules resultant composed module expected inhabit single program address space 
alternatively program modules composed loosely coupled manner reside geographically separated logically composed 
done composing program modules remote procedure calls rpc parts composed module regular procedure calls 
involves generating integrating rpc adapters composition 
architecture chapter notion class instances message sending base language compiled object files 
support limited form message sending 
basic idea module instance corresponds thread address space 
module instances address space 
message sending instances modeled interprocess communication ipc converting static calls ipc calls 
example expression msg send foo bar wraps static call foo ipc stub calls bar routine instance wrapped receiving ipc stub 
crucial question determining identity receiving instance notion class instances 
answer question msg send primitive generate constructor function establishes ipc environment 
example constructor routine registers instances name service invocations foo look identity instance ipc handle name 
particular instance name service returns constant duration program programmatically controlled base language modules 
mentioned compositional idl chapter distributed programming infrastructure chapter fruitfully integrated support similar view compositionality 
instance idl specify compose interfaces components generate adapters interactions actual components implemented conventional languages composed compositional module language 
allen garlan definition architectural interconnection 
proc 
workshop interface definition languages january wing ed pp 

available august issue acm sigplan notices 
amadio cardelli subtyping recursive types 
acm transactions programming languages systems september 
apollo computer domain software engineering environment dsee call 
ma 
auerbach russel concert signature representation idl intermediate language 
proc 
workshop interface definition languages january wing ed pp 

available august issue acm sigplan notices 
bershad anderson lazowska levy lightweight remote procedure call 
association computing machinery transactions computer systems february 
birrell nelson implementing remote procedure calls 
association computing machinery transactions computer systems february 
bracha programming language jigsaw mixins modularity multiple inheritance 
phd thesis university utah march 
technical report uucs pp 
bracha cook mixin inheritance 
proc 
oopsla conference ottawa october acm 
bracha lindstrom modularity meets inheritance 
proc 
international conference computer languages san francisco ca april ieee computer society pp 

available technical report uucs 
bruce paradigmatic object oriented programming language design static typing semantics 
tech 
rep cs williams college january 
burstall lampson kernel language data types modules 
proceedings international symposium semantics data types kahn macqueen plotkin eds vol 
lecture notes computer science 
springer verlag new york pp 

callahan packaging system heterogeneous execution environments 
ieee transactions software engineering june 
campbell islam johnson choices frameworks refinement 
object orientation operating systems palo alto ca october ieee computer society pp 

canning cook hill interfaces strongly typed object oriented programming 
proceedings acm conference object oriented programming systems languages applications meyrowitz ed pp 

cardelli donahue glassman jordan kalsow nelson modula report 
tech 
rep digital equipment systems research center aug 
cardelli mitchell operations records 
tech 
rep digital equipment systems research center aug 
cardelli wegner understanding types data abstraction polymorphism 
acm computing surveys december 
chamberlain 
free software foundation contributed cygnus support march 
chambers ungar chang holzle parents shared parts objects inheritance encapsulation self 
lisp symbolic computation international journal 
chiba masuda designing extensible distributed language meta level architecture 
proceedings th european conference object oriented programming new york springer verlag 
lncs 
clark oo compilation objects 
addendum proceedings oopsla portland oregon october wilkes ed oops messenger acm sigplan pp 

clinger rees revised report algorithmic language scheme 
acm lisp pointers 
cook hill canning inheritance subtyping 
theoretical aspects object oriented programming gunter mitchell eds 
mit press pp 

cook palsberg denotational semantics inheritance correctness 
proc 
acm conf 
object oriented programming systems languages applications pp 

curtis module system scheme 
conference record acm lisp functional programming acm 
deutsch design reuse frameworks smalltalk programming system 
software reusability biggerstaff perlis eds vol 

acm press pp 

mugnier proposal monotonic multiple inheritance linearization 
proceedings oopsla october pp 

ellis stroustrup annotated manual 
addison wesley reading ma 
stk manual 
version 
gamma helm johnson vlissides design patterns elements reusable object oriented software 
professional computing series 
addison wesley publishing reading massachusetts 
shared libraries 
unix review august 
goldberg robson smalltalk language implementation 
addison wesley reading massachusetts 
gordon denotational description programming languages 
springer verlag new york 
hamilton interface inheritance address problems system software evolution 
proc 
workshop interface definition languages january wing ed pp 

available august issue acm sigplan notices 
harper mitchell moggi higher order modules phase distinction 
conference record th acm symposium principles programming languages popl san francisco ca usa pp 

harper pierce record calculus symmetric concatenation 
proc 
acm symp 
principles programming languages jan pp 

harrison ossher subject oriented programming critique pure objects 
proceedings oopsla conference september acm press pp 

ho olsson approach genuine dynamic linking 
software practice experience april 
ada manual 
cambridge massachusetts 
ada mapping revision team effort 
jagannathan dynamic modules higher order languages 
proceedings international conference computer languages ieee 
jagannathan metalevel building blocks modular systems 
acm transactions programming languages systems may 
johnson russo reusing object oriented designs 
tech 
rep uiucdcs university illinois urbana may 
joy graham mckusick kessler berkeley pascal user manual 
unix programmer manual vol 
bsd 
usenix association csrg university california berkeley ca april 
luckham mitchell type system prototyping languages 
proc 
acm symp 
principles programming languages portland january acm pp 

keene object oriented programming common lisp 
addisonwesley reading ma 
kernighan ritchie programming language 
prentice hall englewood cliffs nj 
kiczales des rivi eres bobrow art metaobject protocol 
mit press cambridge ma 
kiczales lamping issues design specification class libraries 
oopsla proceedings acm 
kiczales lamping mendhekar metaobject protocol compiler lisp 
unpublished report 
modified version oopsla workshop compilation 
kiczales rodriguez efficient method dispatch pcl 
proceedings acm conference lisp functional programming acm pp 

kristensen madsen moller pedersen nygaard beta programming language 
research directions object oriented programming 
mit press pp 

lamping typing specialization interface 
proceedings oopsla acm sigplan notices october pp 

lamport document processing system 
addison wesley publishing reading ma 
luckham vera event concepts language system architecture 
available stanford program analysis verification group march 
madsen block structure object oriented languages 
research directions object oriented programming 
mit press pp 

mackenzie debug format 
free software foundation contributed cygnus support 
meyer object oriented software construction 
prentice hall 
meyer eiffel environment august 
nelson systems programming modula 
prentice hall englewood cliffs nj 
object management group 
common object request broker architecture specification december 
revision 
orr bonn lepreau mecklenburg fast flexible shared libraries 
proc 
usenix summer conference cincinnati june pp 

orr application meta protocols improve os services 
hotos fifth workshop hot topics operating systems may 
orr mecklenburg omos object server program execution 
proc 
international workshop object oriented operating systems paris september ieee computer society pp 

available technical report uucs 
orr mecklenburg lepreau dynamic program monitoring transformation omos object server 
interaction compilation technology computer architecture 
kluwer academic publishers february 
ossher harrison combination inheritance hierarchies 
oopsla proceedings october pp 

polylith software bus 
acm transactions programming languages systems january 
rees module system scheme 
included scheme distribution 
smith structured text system 
patent number august 
issues shared libraries design 
proc 
summer usenix conference anaheim ca june pp 

sankar hayes adl interface definition language specifying testing software 
proc 
workshop interface definition languages january wing ed pp 

available august issue acm sigplan notices 
shared libraries objects 
proc 
usenix summer conference anaheim ca june 
sheldon static dependent types class modules 
acm conference lisp functional programming june 
steele jr common lisp language 
digital press bedford ma 
stroustrup type safe linkage 
usenix conference 
thatte automated synthesis interface adapters reusable classes 
symposium principles programming languages january 
tofte lectures standard ml 
lfcs report series department computer science university edinburgh 
tung 
interactive modular programming scheme 
proceedings acm lisp functional programming conference acm pp 
pages 
vlissides linton framework building domain specific graphical editors 
proceedings acm user interface software technologies conference november pp 

gamma marty object oriented application framework 
proceedings oopsla november acm pp 

gannon objects representing manipulating program trees sage system 
compilation workshop oopsla october 
see 
