combinatorial algorithms dna sequence assembly john kececioglu eugene myers october revised january trend large dna sequencing projects undertaken part human genome initiative necessitates development efficient precise algorithms assembling long dna sequence fragments obtained shotgun sequencing methods 
sequence reconstruction problem take formulation dna sequence assembly variation shortest common superstring problem complicated presence sequencing errors reverse complements fragments 
simpler superstring problem np hard efficient reconstruction procedure resort heuristics 
phase approach rigorous design criteria accurate practice 
method robust sense accommodate high sequencing error rates list series alternate solutions event appear equally 
uses limited form multiple sequence alignment detect correct errors data 
combined algorithm successfully reconstructed non repetitive sequences length sampled error rates high percent 
keywords computational biology branch bound algorithms approximation algorithms fragment assembly sequence reconstruction dna sequences may viewed abstractly strings letter alphabet fa tg letter standing character chemical name nucleotide comprising polymer chain 
current gel technology permits directly determine sequence dna strand research supported national library medicine lm postdoctoral fellowship program mathematics molecular biology university california berkeley national science foundation dms fellowship centre de recherches math ematiques universit de montr eal 
computer science department university california davis davis california 
electronic mail cs ucdavis edu 
department computer science university arizona tucson arizona 
electronic mail gene cs arizona edu 
nucleotides length 
determining sequence longer strand say nucleotides requires indirect approach 
shotgun sequencing method randomly samples fragments length short determined 
fragments sampled regions intersect detected overlap sequences fragments 
sufficient sampling eventually reconstruct underlying sequence assembling fragments overlaps 
problem perform assembly current fragment set point project 
seemingly simple procedure difficult factors 
fragments may assemble single reconstruction due incomplete coverage original sequence 
second errors fragment sequences due experimental errors procedure 
current technology percent sequence fragment may incorrect 
third overlap may due fact fragment intervals intersect may simply due chance 
project involving fragments presence error spurious overlaps occur 
dna double stranded particular fragment may come strand 
fragment may represent sequence strand reverse complement sequence opposite strand 
case say orientation fragments known 
develops algorithm sequence assembly general setting incomplete coverage sequencing errors unknown fragment location unknown fragment orientation 
error fragments decreases speed algorithm increases 
accomodate information concerning fragment order orientation generate alternate solutions demand 
subproblems arise design exact algorithms find optimal solution may take exponential time approximation algorithms run fast find solution close optimal 
problems design 
formally define problem denote minimum number insertions deletions substitutions required edit sequence sequence edit distance denote reverse complement sequence sequence obtained reversing mapping character complement 
write complement character dna alphabet example 
principle parsimony natural formulation sequence assembly problem determine shortest sequence explains fragments 
formally 
definition dna sequence reconstruction problem reconstruct collection fragment sequences error rate ffl find shortest sequence fragment substring min related shortest common superstring problem superstring collection strings seeks shortest string called superstring string collection substring essence reconstruct shortest common superstring problem fragment considered match superstring fragment reverse complement aligned superstring length relative error threshold ffl 
fact superstring reduced sequence reconstruction problem ffl 
superstring np complete implies reconstruct np complete 
details may 
related prior related dna sequence assembly may classified categories 
class papers shapiro hutchinson gallant examine early model problem fragments contain errors partitioned classes concatenating fragments class order gives underlying sequence 
problem determine fragment data consistent sequence find sequence 
papers show problem solved polynomial time 
second category papers analyze approximation algorithms shortest common superstring problem indicated equivalent sequence reconstruction problem error fragment orientation known 
tarhio ukkonen turner ukkonen show simple greedy algorithm finds superstring amount compression factor maximum give efficient implementations 
blum avrim jiang li tromp prove greedy algorithm delivers superstring times longer shortest simple variant delivers superstring times longer shortest 
known bounds tight 
li examines sequence assembly viewpoint computational learning theory shows approximation algorithm superstring learn underlying sequence polynomial time pac model learning fragments error known orientation 
third category papers roberts ukkonen develop software sequence assembly 
tarhio ukkonen describes algorithms gives statement sequence reconstruction problem 
papers deal error orientation characterize quality reconstruction output 
addition papers come attention look subtask computing overlaps pairs fragments 
gusfield landau schieber show suffix tree data structure longest overlap suffix fragment prefix determined pairs fragments time linear size input output errors permitted overlaps 
cull holloway apply suffix array data structure manber myers find overlaps fragments assumed contain substitution errors suffix prefix fragment assumed match fragment overlap longer threshold 
huang applies local alignment algorithm smith waterman compute overlap maximizes linear function number exact matches errors alignment uses filtering technique chang lawler avoid considering pairs fragments alignment score fixed threshold 
may distinguished prior theoretical investigations address sequencing errors unknown orientation contrast earlier software phase defined problem 
claim algorithm solves reconstruct distinction phase solves approximates precise optimization problem 
case error known orientation say algorithm modification solves reconstruct equivalent superstring 
sense algorithm generalizes earlier theoretical 
overview algorithm proceeds phases consisting combinatorial problems constructing graph approximate overlaps pairs fragments assigning orientation fragments words choosing forward reverse complement sequence fragment selecting set overlaps induce consistent layout oriented fragments merging selected overlaps multiple sequence alignment voting consensus 
devote section phases 
phase compute overlaps error rate maximize likelihood function alignments 
edges overlap graph correspond alignments weighted likelihood 
fragments total length error rate ffl method computing graph modeling overlaps takes ffln time 
phase orient fragments maximize weight edges overlap graph consistent chosen orientation 
subproblem np complete 
exact algorithm computes optimal orientation time overlap graph fragments edges size branch bound search tree 
approximation algorithm computes orientation weight maximum log time 
phase place fragments overlapping layout selecting set edges maximum total weight form branching satisfying dovetail chain property 
finding branching np complete 
exact algorithm computes optimal layout finding maximum weight dovetail chain branching log time size search tree 
greedy approximation algorithm problem known contrast finds branching weight maximum log time 
show approach naturally lends producing alternate solutions desired 
phase take set overlaps graph agree fragment layout merge multiple sequence alignment follows 
alignments represented set overlaps match pairs characters fragments 
character pairs seek subset maximum total weight forms multiple alignment 
problem np complete solved time exponential maximum number fragments mutually overlap layout 
overlaps match pairs characters layout mutually overlapping fragments construct multiple sequence alignment length contains overlap name edge contains types overlaps 
consensus sequence time 
set matched pairs forms alignment weight maximum 
closes presentation preliminary experimental results combined algorithm conclude suggesting possible extensions 
overlap graph construction algorithm builds reconstruction overlapping fragments pairs 
represent set pairwise overlaps directed edge weighted graph called overlap graph 
section describes structure graph construct 
consider fragments intervals overlaps intersections intervals essentially ways pair fragments overlap shown 
type overlap alignment sequence fragment sequence fragment alignment proper suffix proper prefix call dovetail say alignment substring call containment say contains overlap denoted ordered pair sequences represents alignment contains overlap rate ffl number errors alignment error insertion deletion substitution character 
attribute overlap real valued weight score alignment probability overlap occurring chance 
possible alignments type overlap 
choose alignment maximum score 
overlap graph represents fragments vertex set overlaps edge set edge weight function gives weight overlaps 
unoriented overlap graph contains vertices fragment vertex represents sequence vertex represents reverse complement sequence overlap sequence sequence represented edge directed proper suffix delta delta delta substring delta delta delta proper prefix substring delta delta delta overlap graphs 
unoriented graph 
oriented subgraph 
vertex vertex edge corresponding dovetail denoted containment denoted note edge equivalent edge words alignment suffix prefix alignment suffix prefix similarly edge equivalent edge equivalence reflected representation accompanied accompanied pairing edges essentially possible overlaps fragments orientation unknown 
overlaps may dovetail containment 
algorithm overlap graph construction builds unoriented graph 
form oriented overlap graph unoriented graph specifying orientation fragments 
case restrict attention subgraph induced vertices specified orientation 
example shows unoriented overlap graph subgraph induced particular orientation 
section describes determine oriented subgraph submit fragment layout algorithm section 
random overlap problem fragments infer overlap underlying sequence overlap 
model inference problem finding type overlap alignment minimum probability 
alignment statistically rare due chance matching characters 
overlap poorly explained chance represent true overlap fragments 
determine probability alignment treat fragments random sequences character drawn uniformly independently alpha subgraph induced subset graph contains edges joining vertices course possibility sequence contains repeat 
bet fa tg 
exact probability alignment unknown model result chv atal sankoff random common subsequences gives upper bound 
alignments compute match pair characters equal 
matches give common subsequence fragments unmatched character considered insertion error deletion error 
substitution counted deletion error followed insertion error 
quantities measure alignment length common subsequence number errors 
sankoff chv atal show number sequences length alphabet size contain fixed subsequence length id gamma independent particular subsequence 
gives upper bound probability alignment matches errors id gamma say overlap minimizing random 
problem 
definition random overlap problem overlap ordered pair sequences alphabet size error rate ffl find overlap rate ffl minimizing number exact matches alignment number errors 
remarks problem 
sequences alphabet letters interested minimizing 
minimizing equivalent maximizing gamma log call likelihood alignment 
likelihood nice properties 
increasing decreasing bounded prove asymptotically gamma log 
likelihood balances matches greater error objective manner 
computing overlaps simple algorithm overlap compute containments edit distance overlapped substrings evaluate overlaps distance intuitively overlap greatest number matches matches achieved price error alignment 
packages rules thumb extend alignment matches done errors system tries minimize rough behavior discriminate longer shorter overlaps error density 
huang minimizes gamma approximates trades matches errors linearly objective point view arbitrary 
huang able accomodate substitution errors objective function 
overlapped substrings aj bj gamma output overlap maximum 
suffices consider alignment minimum distance possible overlap words algorithm correct monotone arguments 
pair sequences length mn containments edit distance dovetail containment may computed mn time standard dynamic programming algorithm gives time algorithm easy bring time combining subproblems 
assume myers shown possible solve mn subproblems ffin time ffi maximum edit distance allowed 
application ffi gives ffln time algorithm 
idea myers algorithm solve alignment problems incrementally represent solutions data structure efficiently updated 
delta delta delta denote substring delta delta delta denote suffix denote prefix sequences length myers solves series alignment problems compare increasingly longer suffixes suffix edit distance obtained ffi note includes containments 
distances computed represented implicitly sparse data structure encodes values 
particular distance needed recovered encoding 
encoding versus myers shows encoding versus obtained ffi time 
find random overlap distances need fixed possible roughly possible containments 
containments ffi distance ffi 
encoding versus hand ffi distances recovered ffi time 
distances evaluate likelihoods 
spends total ffi time problem problems gives ffin time algorithm 
description assumed likelihood function evaluated time 
computing directly equations involves sum terms 
fortunately possible precompute table bounded practice 
fragments nucleotides error rates percent suffices store table 
construct overlap graph fragments error rate ffl pair fragments solve overlap myers algorithm 
fragments total length takes time ffln 
overlap classified dovetail containment add appropriate edge graph attributed corresponding alignment weighted likelihood match 
alignments encoded edit scripts conserve space see section 
possible ffin subproblems distance ffi 
remarkable subproblem isolation requires ffin time solved effectively constant time 
myers assume edit distance measured terms insertions deletions 
table number matches achieve matches errors culling overlaps construction described gives complete overlap graph 
edges represent chance alignments true overlaps 
describe cull edges graph 
practice observe culling reduces number edges 
orientation layout algorithms take advantage sparsity 
match significance criteria culling edges match probability 
assume biologist match significance threshold minimum acceptable likelihood overlap 
overlap matches errors rejected edges weighted likelihood means edge graph weight implies overlap de matches 
table lists minimum number matches achieve threshold various values error distribution second criterion culling edges distribution errors overlap 
alignment edge fragments guaranteed errors expects overlap aligns substrings fflj aj fflj bj errors 
number errors far exceeds natural suspect edge true overlap reject 
edge inconsistent pr np culling overlap error distribution 
hypothesis errors roughly evenly distributed 
assume fragments total errors probability observing error overlap substrings aj je bj jaj jbj errors independent number errors overlap binomial random variable parameters probability observing errors dg din gamma gammai cull overlaps basis error distribution assume biologist willing reject small fraction alignments distribute errors evenly error count exceeding critical value 
call fraction error distribution threshold reject overlap errors dg illustrated 
probability dg equal gamma incomplete beta function 
fast numerical methods evaluating yield efficient test inequality 
see instance pages 
note match significance error distribution criteria needed 
match significance criterion time space wasted short overlaps align character 
error distribution criterion long poor overlaps permitted align characters error rate percent 
note extreme case permitted case overlaps rejected 
summarize fragments total length error rate ffl match significance threshold error distribution threshold phase algorithm constructs graph random overlaps weighted likelihood time ffln 
admittedly fragment sequences obtained reading errors occur frequently fragment ends 
conservatively treat errors evenly distributed maximum error rate fragment 
fragment orientation constructed overlap graph culled edges left collection significant overlaps 
high probability edges represent true overlaps fragments may align reverse complement sequences majority overlaps indicate consistent orientation 
section describes find oriented subgraph preparation fragment layout 
fragment orientation problem specify oriented subgraph determine fragment sequence reconstruction 
decide say fragment assigned forward orientation say assigned reverse orientation 
assigning orientations eliminates overlaps retains possibility 
example assigning forward orientation eliminates overlap allows 
overlap graph edge weight function max opp max understanding weight overlap zero weight best overlap fragments assigned orientation opp applies assigned opposite orientations 
note opp symmetric arguments 
view functions defining undirected graph vertices fragments edges pairs fa bg opp nonzero 
interpretation opp edge weight functions overlap graph fragments overlaps vertices edges 
orientation collection fragments represented partition gammao set fragments forward orientation gamma set reverse orientation 
write gamma context specify partition giving set edge fa bg partition notation indicate write overlaps remaining culling significant orientation minimizes weight overlaps eliminates equivalently maximizes weight overlaps retains 
problem 
definition fragment orientation problem orient fragments functions opp find orientation minimizing opp opp forward reversed weight orientation call weight orientation 
gives illustration 
orient np complete 
may suspected polynomial time equivalent maximum weight cut problem 
approximation algorithm finding optimal orientation hard easy find orientation close optimal 
ordering compute orientation follows 
initially set fg 
step consider adding currently partitions ff gamma ff ff set ff leave unchanged effectively adds steps output decision greedy algorithm involves edges incident current fragment ordering runs time space graph vertices edges 
greedy algorithm guarantees orientation weight optimal orientation 
note analysis virtually identical folklore heuristic maximum weight cut 
see note trivial upper bound total weight graph opp greedy algorithm adds step weight orientation increases opp add weight increases opp denote actual amount increase step deltaw 
greedy algorithm chooses greater deltaw opp summing steps deltaw opp worst case bound holds order fragments 
order difference weight large fragments appearing early order 
unrelated fragments appear early may get arbitrary orientation 
determine order follows 
opp form undirected graph vertex set edge weight function fi fi gamma opp fi fi fi graph compute maximum weight spanning tree tree clusters vertices edge weight 
select root greatest total distance vertices distance vertices number edges path connecting tends single path tends endpoint path 
order fragments depth intuition heuristic expect graph compute spanning tree interval graph correct layout fragments weak edges thrown 
graph fragment order heuristic tend fragment order underlying layout 
constructing graph takes time number fragments number pairs fragments nonzero opp 
tree log time 
locate time passes pass computes total distance vertex vertices subtree rooted bottom size subtree second pass uses information compute total distance vertex tree top keeping track vertex maximum total distance 
determining fragment order takes log time space dominates time space greedy algorithm 
exact algorithm idea processing fragments order design exact algorithm computes optimal orientation 
ordering fragments height height height 
branch bound search tree problem root leaf path assigns orientation gamma denote subset ff denote compute optimal orientation solutions smaller problems solve larger ones 
problem solved branch bound technique 
computation viewed binary tree height shown 
node height assigns orientation root leaf path assigns orientation fragments arbitrarily assign forward orientation pairs solutions opposite orientations equivalent 
exact algorithm explores tree root node height accumulates orientation descending height gamma extends orientation adding gamma takes left branch tree returning add gamma takes right branch 
considering move branches eliminated subproblems solved 
tackling instance solutions gamma hand 
allows quickly compute upper bound weight completion partition subsets write ja opp weight orientation restricted edges endpoint endpoint partition fi fi fi fi fi fi fi fi fi gamma choice upper bound term represents weight extension fragments gamma follows 
term ja weight optimal orientation gamma known 
second term exactly weight partial orientation 
third term ja max fag fi fi fi fag fag fi fi fi fag bound ja allows fragments gamma optimistically join independent partitioned term 
sum bounds terms upper bound call upper bound maintain lower bound weight solution initially may obtained greedily adding solution gamma search reaches leaf corresponding orientation greater weight raise discover height worth searching subtree backtrack 
way exact algorithm avoids exploring search tree 
evaluating upper bound node takes time 
bounds second terms looked constant time weights solutions subproblems saved weight accumulated descending tree 
bounding third term involves looking edges vertices 
nodes explored search trees total time space subproblems weights solutions need stored stack traverse tree height total space 
feature exact approximation algorithms lend hybrid algorithm enjoys advantages 
suppose biologist places bound maximum number nodes explore search tree 
run exact algorithm problems count number nodes explored current tree 
problem count exceeds bound exact algorithm take optimal orientation problem gamma extend greedy algorithm orientation argument previous section shows hybrid algorithm achieves factor attained greedy algorithm 
capacity compute optimal orientation prove running polynomial time 
solved problems fragments exact algorithm instances fragments proved difficult solve optimality 
bound say nodes transition exact algorithm approximation algorithm run time 
note algorithms accomodate orientation constraints 
example user may know fragments forward reversed pairs fragments orientation opposite orientations 
algorithms form orientation fragment time constraint applies fragment checked orientation decision 
constraints time linear number constrained fragments constrained pairs 
note storing orientations solutions take space 
fragment layout fragment orientation computed second phase algorithm induces oriented subgraph overlap graph 
third phase select edges subgraph consistent interpretation fragments intervals line 
intervals represent substrings underlying sequence call ensemble fragment intervals fragment layout 
section describes structure set edges overlap graph corresponds layout 
call set dovetail chain branching 
sections describe algorithm computing optimal dovetail chain branching section describes compute alternate branchings user desires alternate layouts 
dovetail chain branching problem consider sequence reconstruction fragments fragment matches substring say substring ith character jth character substring reconstruction associates interval fragment call collection intervals fragments fragment layout layout denote interval fragment length denoted jlj fi fi fi fi fi fi length total interval covered clearly shortest reconstruction shortest associated layout 
fragment layout associate set edges overlap graph 
fragments intervals identical form equivalence class select representative fragment class direct containment edge representative fragment class 
remove fragment representative consideration 
remaining fragments totally ordered increasing left endpoint second decreasing right endpoint 
fragment interval contained interval order contains direct containment edge fragment remove fragment interval contained 
remaining fragments increasing left right endpoints 
direct dovetail edge fragment successor order intervals overlap 
resulting set edges satisfies properties vertex incoming edge edges form cycles dovetail edges leave vertex containment edge followed dovetail edge set edges satisfies properties called branching 
branching may characterized collection vertex disjoint trees edges directed away roots vertices edge 
directed tree branching called arborescence 
set edges addition satisfies properties call dovetail chain branching 
dovetail edges form disjoint chains roots 
call maximal set fragments cover contiguous interval layout contig 
note contigs layout correspond arborescences branching 
just layout associate dovetail chain branching branching associate fragment layout 
overlap indent length prefix aligned branching overlaps construct contig arborescence follows 
fragment arborescence define left left jf left root left indent simplicity lays contig position zero 
understood fragments overlap resulting layout intervals intersect arborescence 
layout computed linear time evaluating top roots recall section edges overlap graph weighted likelihood function 
edge represents alignment maximum number matches alignment number errors 
perfect alignment ffl weight edge length longest prefix overlapped write total weight edges branching hard show case error length layout induced jlj jf gamma jf constant input branching maximum weight gives layout minimum length 
take problem 
definition maximum weight dovetail chain branching problem branching directed graph edge weight function edges classified containments find dovetail chain branching maximizing 
kececioglu generalizes correspondence dovetail chain branchings layouts case error reduces sequence reconstruction problem maximum weight dovetail chain branching problem 
reduction requires assumptions fragment error error evenly distributed approximate matching transitive input error rate 
particular shows assumptions algorithm branching yields reconstruction feasible error rate ffl gammaffl factor gammaffl longer shortest reconstruction feasible error rate ffl 
reduction way showing branching np complete reconstruct np complete ffl result states case branching solves reconstruct exactly 
polynomial time algorithm branching find maximum weight dovetail chain branching graph maximum weight dovetail chain branching exponential rank 
edges dovetail chain branching edge preceded omega gamma non dovetail chain branchings greater weight 
practice 
strategy relax dovetail chain constraint 
compute maximum weight branching may dovetail chain polynomial time 
branchings produced order decreasing weight 
generate branchings order weight finding satisfying dovetail chain constraint 
find guaranteed dovetail chain branching maximum weight 
premise fragments low error rate sequence repeats branchings generated 
emphasized approach requires exponential time worst case 
gives simple example maximum branching rank exponential number vertices see section techniques deal graphs 
users wait exponential number iterations place limit number branchings generated 
branching generated invoke procedure greedily repairs defects may 
branchings generated repaired branching maximum weight returned solution 
limit iterations constant greedy repair efficient dovetail chain branching necessarily maximum weight delivered polynomial time 
slight variant greedy repair known approximation algorithm branching 
biologists additional conditions solution length reconstruction difficult capture formally 
circumstances desirable see solution truly best may chosen 
show alternate layouts easily computed approach accomodate various constraints 
sections algorithm dovetail chain branchings fifth section describes procedure alternate layouts 
generating branchings efficient algorithms known maximum weight branchings generating branchings order decreasing weight 
maximum weight branching graph edges vertices computed log time space shown gabow galil spencer tarjan 
branchings greatest weight generated ke log time space shown fratta 
method generating branchings similar applies branchings algorithm tarjan differences 
differences due particular application generating branchings meet dovetail chain constraint allows apply algorithm gabow generate branchings log time 
forming constraints suppose computed maximum weight branching dovetail chain 
branching contains pair dovetail edges leave common vertex containment edge followed dovetail edge cases say conflicts dovetail chain branching contain contains expressed disjoint conditions gamma feg gamma ffg feg case continue searching maximum weight branching graph gamma feg 
second case part solution remove edges edges merge single vertex obtain graph continue searching gamma ffg retaining part solution 
solving problems recursively returning branching greater weight find solution original problem 
subproblems smaller size progress 
partition solution space give solution larger problem 
refining subproblems gives problems problems 
general point branching generation collection subproblems partition space dovetail chain branchings 
subproblem represented sets edges set contained dovetail chain branching set contained 
associated subproblem weight heaviest branching satisfying set constraints 
weight upper bound solution value subproblem 
iteration generator involves finding subproblem greatest associated weight computing maximum weight branching meeting constraints 
dovetail chain optimal solution original problem halt 
weight great solution subproblem 
dovetail chain pair conflicting edges fe fg located split subproblems 
sets subproblem receives constraints feg receives constraints feg ffg 
follows general method lawler generating best solutions combinatorial optimization problems 
resulting collection problems conveniently represented computation tree 
node tree contains list list consist edges sets weight heaviest branching meeting edge constraints 
internal nodes children refine parent subproblem 
leaves encode current partition solution space 
heap leaves prioritized weight allows find subproblem greatest upper bound extracting leaf maximum priority 
computing constrained branchings find branching maximum weight meeting set constraints transforming problem constraints 
transformation steps 
solving branchings problem solve rooted spanning arborescence problem 
rooted spanning arborescence branching vertex specified root edge 
maximum weight branching problem reduced maximum weight rooted spanning arborescence problem adding artificial root graph adding edges zero weight root vertex original graph 
choosing edge root vertex rooted spanning arborescence means edge chosen corresponding branching 
branchings algorithms gabow compute maximum weight rooted spanning arborescences 
second step transformation removes edge constraints 
edge set removed rooted graph edge set edges form removed distinct 
clearly set unconstrained arborescences new graph set constrained arborescences original graph 
time space method outlined essentially method simplified fact easily identify edges decompose subproblem implemented efficiently terms number iterations size original graph 
branching generated requires constrained branching computations heap insertions heap deletion 
branching computations recovering branching meets upper bound chosen subproblem bounding weight children inserted heap 
maximum weight branching computation involves reducing constrained branching problem unconstrained arborescence problem 
reduction takes time computing maximum weight rooted spanning arborescence takes log time 
time heap operations bounded follows 
heap contains leaves computation tree generating branching creates leaf 
heap size 
heap insertions deletions take time logarithmic size heap time iteration heap operations log 
combining time iteration log time generate branchings log 
space required constrained branchings algorithm computation tree heap 
computing branching takes space 
heap uses constant space leaf space 
computation tree appears require ke space nodes node list size reduced constant space node idea gabow 
sets left child computation tree may obtained parent adding edge set form set copying set 
sets right child may obtained parent left brother adding edge set form set adding edge set form set 
case storing edge lists node store pointers parent left brother edge adds parent set 
pointers back root recover sets node time constant space er node total space tree 
representation space generating branchings 
accelerating convergence optimizations accelerate convergence dovetail chain branching 
optimization addresses edge conflicts 
computing branching problem set set add edges graph conflict edge certainly correct dovetail chain branching problem contain edges 
edges conflicting set computed time 
example reduces number branchings generated 
second optimization addresses inherent redundancy branching generation 
generate branchings means generating layouts relation branchings layouts generated branchings result layout 
factoring redundancy requires modification computation tree data structure careful method identifying edge conflicts 
capture set edges branchings inducing layout branching closure informally set contains edges graph overlap fragments relative position formally closure branching inducing layout overlap graph set closure fi fi gamma left gamma left fi fi fi definition understood closure arborescence 
words measure difference placement layout overlap 
difference explained error rate closure 
branching compute closure time determining layout takes time testing edge membership takes time 
removing branching replacing closure gives essence layout 
exactly want avoid 
formally kin edge respect branching graph set kin fi fi fi closure form kin branching closure welldefined 
kin computed time determining layout closure takes time need examine edges enter agree layout kin follows 
computing branching problem inset set adds set parent augment kin 
know removed branching parent contained set created conflict 
adding kin prevents selection edge places position 
note obtaining involves recovering set parent requires computing kin set involves set tree 
computing kin sets take kv time 
retain time complexity recovering sets modify computation tree 
node stores edge adds parent set kin list list contains kin gamma set node set parent 
recover set node follow node pointers back root copy kin lists nodes visited 
recover sets 
recovering sets takes time 
creating node recover set parent set compute kin store kin gamma node time 
second optimization increase time complexity branching generation 
unfortunately space complexity increases kv worst case tree nodes kin list edges 
practice kin sets constant size degree vertices bounded constant see section 
call graphs sparse 
sparse graphs space kin lists space complexity branching generation increase 
resolving conflicts incorporating optimizations careful representative branching chosen layout 
consider branchings fa cg fa cg induce layout 
dovetail chain 
representative generated layout consistent layout rejected 
consequently longer suffices test generated branching dovetail chain 
ask dovetail chain branching graph induces layout exists say resolves conflicts return halt 
exists conflict generate subproblems resolved 
procedure identifying edge conflicts 
side effect find resolved branching exists 
branching conflicts compute layout closure general claim may maximum weight branching 
absence error overlaps long overlaps imply 
low error rates reasonable assume weight close weight situation far optimal certainly worth reporting 
section discusses generate alternates 
containment edges compute maximum weight branching fragment contained edge removed consideration 
remaining fragments roots sort contigs increasing left endpoint consecutive pairs fragments look dovetail call set dovetail exists pair fragments contains conflict 
resolved branching returned 
note dovetail chain 
procedure correct show contained fragment containment edge remaining fragments related chain chain unique distinct chains set fragments create dovetail cycle impossible layout 
dovetail chain branching graph yields layout procedure finds 
resolved branching unique containment edges 
containments maximum weight procedure finds optimal resolved branching 
dovetail chain pair edges forms conflict 
certainly consecutive pair dovetail source conflict depending fragment descendant cases 
suppose loss generality descendant path contained dovetail edge adjacent layout containment choose conflicting pair fe fg 
edge 
suppose descendant 
path common ancestor path ancestor contained dovetail edge 
final edges pair conflict 
cases conflicting pair located time walking determining layout takes time forming closure takes time 
sorting fragment intervals left endpoint takes log time 
verifying dovetail chain takes time 
find resolved branching conflict log time complexity branching generation 
moving section review closure optimizations conflict resolution incorporated generator 
iteration consists removing problem greatest upper bound heap recovering branching meeting bound splitting problem subproblems 
recover branching determine sets compute maximum weight branching meets constraints 
determine constraints walk computation tree collecting set set augment kin sets encountered walk edges conflicting recovered branching tested edge conflicts 
exist equivalent dovetail chain branching returned halt 
conflict identified subproblems placed heap iterate 
dovetail chain branching delivered log time number iterations 
space kv worst case sparse graphs 
repairing conflicts iteration fails produce dovetail chain branching conflicts generated branching repaired greedy procedure give dovetail chain branching repaired branchings maximum weight iterations retained 
event generator exceeds limit iterations return maximum weight repaired branching 
repair non dovetail chain branching locate forbidden subgraphs remove edges 
note resulting branching dovetail chain 
edges gamma ordered decreasing weight considered inclusion including edge preserves branching property dovetail chain property added edges considered returned 
locating removing forbidden subgraphs takes time 
sorting edges gamma takes log log time 
testing edge property done time maintaining boolean variables fragment 
variable records fragment containment edge records dovetail edge 
including containment preserves dovetail chain property dovetail edge including dovetail preserves dovetail chain property dovetail edge containment edge 
including edge preserves branching property edge create cycle 
forms cycle members arborescence test cycle creation essentially constant time maintaining partition fragments arborescences disjoint sets 
dominant step sorting edges 
short greedy repair performed log time worst case 
interestingly asymptotically expensive greedily repair branching compute maximum weight 
worst case 
sparse graphs practice time greedy repair log 
note greedy repair essentially greedy algorithm dovetail chain branchings started partial branching 
sense partially greedy initial branching obtained global optimization 
tarhio ukkonen turner analyze totally greedy algorithm overlap graphs ffl show finds solution weight maximum 
overlap graphs ffl tightest analysis know totally greedy algorithm gives factor fact graphs totally greedy performs better partially greedy vice versa 
conjecture partially greedy algorithm achieves factor weight branching generated upper bound weight optimal dovetail chain branching 
terminate finding optimal solution report far optimal solution possible purely greedy strategy 
producing alternates biologist additional criteria reconstruction difficult formalize incorporate algorithm 
biologist may rough idea length solution know section reconstruction containing repeats correct 
short biologist may demand alternate solution may wish specify additional constraints 
strongly independent alternates closure branching generate alternate solutions 
closures branchings differ layouts differ 
requiring addition ensures layout contained 
general suppose closures solutions say nth branching strongly independent gamma branchings guarantees branching induces configuration seen 
know generate strongly independent branchings line order weight afford generate sort 
generate alternate layout find heaviest edge graph union closures previous dovetail chain branchings 
invoke generator constraint chosen edge contained branching 
simply involves adding set root computation tree forcing greedy repair retain generating alternates takes log time top branching generation 
computing alternates form sorted list edges graph 
alternate produced compute closure remove closure edges list 
produce alternate seed branching generator edge head list 
sorting edges takes log time computing closure updating list takes time alternate 
producing alternates order weight requires additional log log sort take av additional space store branchings 
space reduced cost doubling time storing seed edges regenerating alternate seed order established 
summarize strongly independent alternates generated line order weight ak log log time space maximum number branchings examined alternate 
user constrained alternates produce alternates constraints provided user 
biologists know order subset fragments overlap say directed sequencing method restriction map 
may simply know configuration fragments incorrect wish prevent appearing 
express information sets edges 
order fragments known retain graph edges consistent ordering 
inconsistent edges placed set 
note fail enforce partial order fragments 
example fragment follow fragment known fragment rule individually form path placing total order fragments known fragments allowed enforce order placing dovetail chain set 
hand order layout may known biologist may know incorrect 
user select portion contig generated layout ask fragments selected completely rearranged 
case compute closure fragments place edges set 
note constraint severe 
user wishes freeze conflict resolution procedure section determine branching inducing just place edges set 
multiple sequence alignment stage branching specifies consistent layout fragments 
output algorithm reconstructed sequence 
phase obtain sequence branching forming closure branching consists overlaps agree layout merging overlaps multiple sequence alignment voting consensus sequence alignment 
procedure recover sequence error far fragment 
maximum weight trace problem section defined closure branching contains edges graph overlap fragments relative position induced layout 
multiple sequence alignment seek layout agree overlaps 
exact agreement possible 
settle multiple alignment close pairwise alignments formalize notion closeness follows 
edge closure aligns delta delta delta am delta delta delta represented list pairs positions delta delta delta delta delta delta pair matches characters treat pair constraint multiple alignment characters appear column alignment 
shows may possible satisfy constraints collection pairwise alignments 
may settle subset constraints 
discriminate subsets weight constraint similarity pair characters matched seek subset satisfiable maximum total weight 
formalize constraints satisfiable define alignment graph oe vertices correspond sequence characters edges correspond multiple sequence alignment sequences sk matrix gamma ij delta ik jn row delta delta delta delta ain gives entry ij may equal null character identity concatenation 
pairwise alignments may form multiple alignment 
pairwise alignments edges join matched characters 
induced connected components form cycle oe pairs characters matched alignments 
vertices define partial order oe 
order oe characters sequence character precedes essentially order characters columns legal alignment respect oe 
alignment graph oe subset induces collection connected components partition components oe oe relation oe may partial order possible oe oe relation oe components partial order constraints satisfiable component corresponds column alignment topological ordering components respects oe valid order columns 
topological order exists precisely oe contain cycle 
words constraints satisfiable oe components acyclic 
call satisfiable set multiple sequence trace 
generalizes standard notion trace sequence comparison page 
trace form multiple sequence alignment determining connected components topologically sorting 
trace edges graph vertices finding connected components takes time 
topological sort takes time linear size relation represented ordered pairs 
recover multiple alignment trace time 
simply reading input alignment requires omega gamma time concentrate finding traces computing alignments 
problem 
definition maximum weight trace problem trace alignment connected components induced maximal sets pair vertices connected path maximal means vertex outside connected vertex topological order set partial order oe total ordering elements respects oe 
graph oe edge weight function find trace maximizing 
trace np complete remains application edges sequences form alignment length sequence bounded constant 
fast heuristic maximum weight trace section adapt instances arise sequence reconstruction 
fast heuristic np completeness trace strategy design algorithm fast practice delivers near optimal traces 
heuristic wellknown observation tree pairwise alignments trace 
words alignment graph consider choosing pairwise trace sequences 
tree sequences pairwise traces gives multiple sequence trace note alignment graphs edges sequences form pairwise trace 
tree pairwise traces gives multiple sequence trace simple heuristic choose tree maximum total weight 
apply follows 
pairwise traces select tree correspond overlaps closure branching 
treat overlap undirected edge weight sum similarities characters matched overlap 
section defines similarity measure 
edges compute maximum weight spanning tree 
computing closure takes time overlap graph overlaps fragments 
overlaps total pairs matched characters weighting overlaps takes time 
closure overlaps computing maximum weight spanning tree takes log time 
delivers trace log time 
kececioglu shows resulting trace weight maximum 
bound tight pessimistic 
frequently alignment graphs arise partitioned subgraphs fragments maximum number fragments mutually overlap layout 
call coverage depth layout practice constant usually 
inputs factor optimal 
coverage depth means heuristic achieves factor instances meet coverage depth bound appear occur practice 
real data errors lends structure pairwise traces 
refine heuristic take advantage structure 
sliding window variation low error rates current practice alignment graphs regular underlying structure 
error sequences identical alignment observation expressed different language papers 
occurrence 
graph series columns column complete subgraph 
rare error effect structure displace delete edges local defect 
graphs edges pairwise trace coincide trace induced pairwise traces 
words structure pairwise traces tends transitive due high edge transitivity near complete subgraphs 
situation heuristic performs trees pairwise traces induce alignment near optimal weight 
improve alignments adapting local variation sequence similarity 
errors tend cluster fragment ends tree fragment allow tree adapt errors arise switching tree favors similar sequences 
start alignment produced heuristic 
window containing fixed number columns swept alignment 
width window parameter algorithm 
alignment subgraph defined characters window compute maximum weight spanning tree 
column alignment induced tree output 
characters removed window column right window added 
advances window process repeated 
window represented window graph 
graph consists represent sequences spanned window sequences character window represent pairwise traces spanned sequences 
restriction alignment graph window left right boundary 
boundaries position leftmost character window rightmost character window spanned sequence 
attributed left position character just inside left boundary right position character just outside right boundary 
assume pairwise trace list matches left right order 
attributed left match points match list inside left boundary right match points match outside right boundary 
store total weight matches left right boundaries 
sliding window variation window viewed generator columns 
sections describe steps column generation update window advancing left boundary advance right boundary compute spanning tree window graph incrementally 
details simply bookkeeping completeness 
final sections specify representation pairwise traces similarity function weighting trace edges voting function consensus characters column compression optimization 
advancing left boundary spanning tree window graph selects pairwise traces matches form multiple sequence trace characters window 
matches form connected components characters alignment graph 
column generated window initial component oe characters left boundary 
window representation find initial component depth search 
left boundary 
left matches cases distinguished match touches left boundary character window 
order children left right layout pick root leftmost fragment layout 
depth search traverses tree passing initial component alignment subtrees 
component represented list pointers sequences non null characters column left boundary characters sequences list 
spanned sequences list contribute null characters column 
search visits node component list subtree initialized sequence children examined order 
child left match examined 
identify cases illustrated 
cases handled 
case match touches left boundary character 
case boundary characters different components 
furthermore component containing precede component containing boundary character precedes character matched situation recursively search subtree rooted search returns passes component short circuit search children simply return case match touches boundary characters 
case component 
recursively search subtree rooted component returned search 
member append members list continue search child precedes component containing case short circuit search simply pass cases match touches boundary character 
components distinct precedes incomparable 
case retain component generated column searching subtree continue search remaining children 
component returned root gives column generated 
account time find initial component charging operations edges operations concatenating component lists testing child component passes 
doubly linked lists concatenation performed constant time 
node knows component passes 
passing information parent test performed constant time 
charging operations edge child parent edge charged constant amount time 
time compute column linear size layout coverage depth 
having determined column alignment window advance left boundary 
increment left position sequence character column effectively removes character window 
character sequence delete incident window graph 
retain update incident 
left match involves character column advance left match pointer match pairwise trace decrease weight match weight 
done time linear size window graph 
section describes determine tree advancing right boundary advancing right boundary involves adding column right 
determine column exactly determined column window traversing tree sequences depth tree fixed branching 
determined column examine characters 
character new sequence window create sequence 
overlaps closure incident sequence examined alignment sequence window graph created 
sequence inserted window graph total time insertion linear total number fragments overlaps closure 
created weight initialized zero left right match pointers set match pairwise trace 
creating new edges right position incremented sequence character new column 
examine incident sequences 
right match touches characters window increase weight weight match 
character right match window advance right match pointer match trace 
remove column left add right try maintain window roughly width 
add column window shrink 
happen example column removed contains character sequence column added contains character 
hand add column window may expand 
happens column removed contains characters column added contains 
maintain size window rule 
column added half spanned sequences extend right boundary characters window width 
rule adds columns adds 
ensures majority sequences window width tends maintain volume window 
checking rule takes time spanned sequences 
determining column right takes time increase time complexity 
computing spanning tree tree determine column window maximum weight spanning tree window graph 
noted section maximum weight spanning tree log time graph vertices edges 
layout coverage depth time 
practice recommend different spanning tree algorithm 
log time algorithm requires fibonacci heap practice pairing heap spanning tree computed column overhead data structures unappealing 
spanning tree problems vary slightly window window case unnecessary repeatedly compute tree scratch 
column emitted contains characters case insertion error occurred weight edges changed 
incremental spanning tree algorithms available quickly recompute optimal tree weight edge graph changed 
column emitted contains characters identical case deletion error occured weight nearly edge graph changed amount 
require invocations incremental algorithm arrive tree initial 
incremental algorithm avoids overhead pairing heap performing gracefully extremes preferable 
known algorithm properties kruskal 
recall algorithm starts empty tree sorts edges non increasing weight considering order adds edge tree create cycle 
accomplished time log complexity dominated sort step 
notice retain sorted edge list previous column list partially sorted current column 
insertion sort example element list elements pairs elements order takes kn time 
common case edge weights changed nearly weights changed uniformly fast 
time reduced log log balanced tree perform insertions pages unnecessary small window graphs 
representing pairwise traces list matches pairwise traces data structures linear size window graph 
fact sliding window algorithm constructs entire alignment graph multiple alignment matrix 
matches linear number fragments overlaps closure 
space matches kept small representing pairwise traces edit scripts 
script specifies insertions deletions substitutions edit sequence 
low error rates long sequences substantial savings list matched characters 
edit scripts change algorithm slightly basic operation alignment ask match position 
notice queries come left right sequence 
window boundary need deliver match right boundary update match boundary advanced 
represent edit script pair vectors giving ascending positions unmatched characters sequences 
maintain pair positions current match pointers edit script giving unmatched character sequence 
representation match boundary delivered updated increase time space complexity 
finding match may require skipping unmatched characters total time proportional number alignment columns length sequences 
weighting trace edges biologists denote nucleotides dna sequence fragment ambiguous base codes 
ambiguous base code subset fa tg represents set possible nucleotides sequence position resolved uniquely 
character sequence really set letters 
encode set bit vector bits needed dna alphabet vector fit byte 
computing pairwise alignments overlap graph construction consider characters match encoded sets intersect 
intersection tested constant time bitwise operation 
computing multiple sequence alignments favor precise matches giving trace edges weight 
weight edge characters sets jx jx denominator zero empty 
gives exact match unit weight ambiguous match somewhat complete mismatch zero weight 
compute weight time 
intersection union computed bitwise bitwise operations cardinality resulting set computed table look 
voting consensus reconstructed sequence determined consensus multiple sequence alignment 
character column places vote letter set null character equivalent empty set 
letter alphabet votes tallied 
consensus character set letters receive votes number sequences spanned column 
rule minimizes total number insertions deletions substitutions convert consensus character column 
layout coverage depth time determine character 
compressing columns detail column compression 
described section characters placed column path matches join trace spanning tree 
policy overlook matches outside tree join characters adjacent columns 
compute consensus multiple alignment voting want merge adjacent columns possible 
characters spread columns vote gets divided 
extreme vote may sufficiently divided prevent appearing consensus cause deletion error reconstruction 
prevent extent follows 
generated columns filtered press output 
simple data structure containing set sequences window graph 
sequence set press holds non null character characters form column output 
recall represent column generated window set sequences non null characters 
new column generated compare press 
sets disjoint form union effectively compressing columns 
sequence non null character press generated column 
case output column press replace window 
column compression takes time proportional number non null characters columns enter leave press increase time complexity multiple alignment 
summarize alignment graph vertices induced closure overlaps layout coverage depth sliding window algorithm computes multiple sequence alignment columns time ffln space 
experimental results explore viability approach sequence reconstruction implemented software package embodying preceding suite algorithms 
orientation layout phases exact algorithms run 
size search tree large example phases switch approximation algorithms produce solution 
section presents results tests implementation simulated sequencing data 
simulated data certain correct solution test 
experiments constitute exhaustive conclusive study 
goal simply get feel performance methods 
experiments conducted follows 
sequence sampled randomly chosen intervals form collection substrings 
substrings length reverse complemented probability error collection substrings constituted input fragments 
introduce error rate ffl substring length formed insertions deletions substitutions repeatedly selecting insertion deletion substitution random satisfying ffl gamma relationship error input error output interest wanted keep edit distance overlapping fragments close possible input error rate 
care taken ensure character edited generating input 
input parameters experiments sampled sequence error rate number fragments substring length call fragment length 
recorded positions substrings sampled knew true layout fragments correct reconstructed sequence compare output software 
software addition required match significance error distribution threshold overlap graph construction window width multiple sequence alignment 
experiments match significance threshold error distribution threshold percent window width 
twelve experiments performed parameters table 
group experiments numbered generated random sequence length characters drawn uniformly independently alphabet fa tg 
sampled sequence fragments length sample roughly characters 
sample size divided sequence length number genome equivalents experiments held 
values fragments length genome equivalents intended reflect laboratory practice 
error rates chose percent far encountered practice quoted percent 
intention explore robustness approach error data 
random sequence structure biological sequences contain repeats 
remaining experiments numbered human fi globin gene cluster sequence 
character sequence contains approximate repeats presents challenging reconstruction problem 
thirteen short interspersed alu repeats forward direction reverse long interspersed hs repeats forward reversed 
alu repeats separated roughly bases long 
hs repeats recursive structure contain bases 
addition sequence contains exact repeats fifteen bases 
understanding degree repetition unusual 
chose sequence instances difficulty apparently arise interested testing limits table experiment parameters 
sequence sequence fragment number genome error group experiment type length length fragments equivalents rate random human human human human approach 
experiments took characters human gene cluster sequence 
nucleotides contain alu repeats hs repeats 
point groups fragments formed collection substrings error rate varied 
second groups position substrings location errors underlying sequence varied 
difference output groups due structure sequence pattern sampling 
effect fragment length examined third fourth groups 
motivated results group decided perform experiment entire gene cluster sequence sampled genome equivalents fragments length 
synopsis results experiments may divided experiments random sequence experiments biological sequence 
point keep mind set experiments contains essentially repeats second set contains 
random sequence experiments exact algorithm layouts provably optimal maximum weight branchings dovetail chain 
biological sequence experiments exact algorithms solve optimality experiments 
greedy algorithms optimal solutions exact algorithms experiments solutions equivalent exact algorithms experiments 
light experiments ran greedy algorithms limiting search 
lesson draw experience exact algorithms absence repeats sequence repetitive human gene cluster sequence incapable finding optimal solution 
greedy algorithms appear just produce layouts acceptable quality 
table layout quality 
fragment number error number incorrect incorrect overlap experiment length fragments rate contigs adjacencies savings ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi number contigs expressed number computed layout followed number fragment correctly ordered followed number correct layout overlaps culled 
number incorrect adjacencies expressed maximum number pairs fragments adjacent computed layout order correct order followed total number pairs correct order 
detailed results respect various performance measures 
primary interest quality layout consensus sequence report 
layout statistics greedy algorithms just explained 
follow interesting parameters overlap graphs multiple sequence alignments report computation times describe software run 
layout quality measures layout quality summarized table 
measure number contigs expressed composite number number contigs computed layout number fragment correctly ordered number contigs correct layout edges erroneously culled overlap graph 
words number contigs perfect reconstruction restricted overlaps graph 
experiments number contigs true layout minus number incorrect 
incorrect second measure occurred score overlap overlap threshold 
give example incorrect cull experiments occurred substrings involved overlap true layout thirteen characters 
deletion errors score overlap threshold causing culled overlap graph construction 
true layout consisted contigs overlap broke 
permit fair comparison computed layout formed basis overlaps graph report number contigs correct layout experiments give separate column number incorrect 
correct layout means true layout incorrect 
third measure number incorrect adjacencies 
counting contigs completely correct coarse measurement quality 
instance contigs computed experiment completely correct seventh contig correct 
took measure degree correctness number pairs fragments adjacent layout order computed layout correct layout fragments ordered increasing left endpoint second decreasing right endpoint 
count number incorrect adjacencies tallied number pairs adjacent order took maximum tallies orders 
table incorrect adjacencies expressed count followed total number adjacencies correct layout 
example consider layout fragments contigs correctly ordered 
suppose take fragment move fragment breaking layout 
layout pair original order correct layout pairs incorrect order 
count incorrect adjacencies 
measure overlap savings 
weight branching inducing computed layout minus weight branching overlap graph inducing correct layout 
positive quantity means computed layout greater overlap sense shorter 
striking feature table random sequence experiments biological sequence experiments solved correctly 
suggests exact greedy algorithms absence repeats 
presence repeats greedy algorithm layout shorter correct experiment error rates percent correctly determined adjacencies 
methods section producing alternate layouts layout constraints biologist correct remaining 
general trend group compression rearrangement layouts increased higher error rates 
explained approximate repeats gene cluster sequence criterion minimizing layout length compress approximate repeats assuming long occur low error rate 
comparing second third fourth groups error rate number incorrect adjacencies increased number fragments absolute terms fraction total number adjacencies discernable relation 
probably due changes pattern repeats sampled fragment length varied groups 
statistic table number incorrect orientations 
twelve experiments relative orientation fragments correctly determined contigs contig contained incorrectly placed fragments 
somewhat surprising counting experiments group varying error rates orientations determine roughly half reverse complements 
internal reverse complementarity table consensus error 
output error input error sample coverage correction experiment rate tally rate tally rate tally rate ffi ffi ffi ffi ffi ffi ffi ffi ffi output error tally expressed number insertion deletion substitution errors computed consensus sequence correct sequence followed number characters consensus sequence sample output 
gene cluster sequence sufficiently simple reverse complement repeats fragment orientation easier fragment layout 
consensus error measures error reconstructed sequence table 
require explanation 
examined consensus sequence experiments contigs correctly laid experiments 
consensus sequences compared correct sequence counting number insertion deletion substitution errors 
raw error column sample tally error count followed number characters sample 
column expresses error rate example error characters 
errors consensus occurred fragments participated voting 
fragment votes presence absence error detected 
vote error detected correct 
consequently counting errors coverage fragments error rate users accept weak consensus 
column coverage gives error sample fragments participated voting 
seventeen errors coverage insertion errors caused configuration 
configuration characterized adjacent columns half rows contains middle row contains aa half contains 
course choice character arbitrary order columns order rows 
suppose halves contain dk gamma rows counts total number rows 
column contains dk characters voting procedure section interpret alignment result gamma deletions correct aa consensus 
consider sliding characters top half column right gives valid alignment 
alignment algorithm section approximates trace may distinguish configurations may prefer configuration second 
consensus algorithm hand interpret second configuration 
aa gamma 
aa 
delta delta delta aa delta delta delta delta delta delta delta delta delta typical configuration causing error consensus correction 
result insertion output single parsimonious explanation data experiments correct 
configuration hard recognize correct prior voting 
column correction gives error sample coverage account 
clear table error reconstructed sequence coverage input rates percent 
correction described 
course sampled little characters statistic may inaccurate 
dramatic improvement error 
experiments average coverage see section indicates rapid convergence underlying sequence 
coverage yield output sufficient accuracy conceivable applications 
coverage depth vertex degree sections claimed practice coverage depth layout vertex degree overlap graph small constants relative number fragments 
table presents statistics parameters 
average coverage depth computed summing number spanned sequences columns multiple sequence alignment dividing number columns 
average vertex degree computed dividing number edges overlap graph number vertices 
maximum vertex degree computed counting number edges edges vertex maximum 
sum yield compared twice average degree 
data supports assumption expected coverage depth vertex degree near number genome equivalents practice constant 
maximum values higher order magnitude number fragments 
table coverage depth vertex degree 
number error genome coverage depth vertex degree experiment fragments rate equivalents average maximum average maximum average coverage depth sum columns alignment number spanned sequences divided total number columns 
average vertex degree number edges overlap graph divided number vertices 
maximum vertex degree maximum number edges edges vertex 
computation time software took input fragments error rate additional parameters 
parameters overlap graph thresholds multiple alignment window width maximum search tree size 
mentioned earlier experiments match significance threshold error distribution threshold percent window width 
search trees initially tried unbounded number nodes fragment orientation unbounded number generated branchings fragment layout 
optimal solutions experiments random sequence group maximum weight branchings experiments dovetail chain 
unable find optimal orientation layout experiments overnight runs 
decided forego branch bound greedy extension fragment orientation greedy repair dovetail chain branchings experiments 
greedy orientation computed maximum weight branching generated 
fragments correctly oriented layouts experiment amount overlap exceeding correct solution appears greedy algorithms perform surprisingly 
table gives computation times 
overlap time time overlap graph construction layout time time fragment orientation layout greedy algorithms algorithms produced layouts table alignment time time multiple alignment consensus voting 
times units hours seconds minutes processor silicon graphics iris running megabytes ram 
code exploit parallelism machine 
table shows nearly running time taken overlap graph construc table computation time 
fragment number error overlap layout alignment experiment length fragments rate time time time hour sec min tion 
data supports linear growth overlap time function error rate agrees worst case time bound ffln fragments total length error rate ffl 
experiments roughly number input characters study necessary observe quadratic growth input length 
point overlap time order hours may amortized period data acquisition 
sequence fragment obtained overlap graph updated insertion vertex comparison new fragment currently graph 
divide time compute overlap graph number fragments amortized time seconds fragment fragments length percent error 
fragments length percent error time seconds response course degrade fragments inserted 
note time compute layout order seconds 
suggests problems current size possible deliver updated layout fragment obtained 
section indicates layout may acceptable quality problematic repetitive sequences 
phase algorithm sequence reconstruction 
problem involving fragments total length phase constructs graph overlaps error rate ffl time ffln 
generally length underlying sequence known approximately sample fragments 
ratio number genome equivalents sampled small constant 
case expected outdegree vertex overlap graph implying number edges expectation 
orientation layout phases take time kv log size search space 
conditions convergence quick formance practice basically log 
final multiple alignment phase time taken 
empirical conditions algorithm runs roughly ffln log time 
time consuming aspect computation practice comparison fragments overlap graph construction 
ironically phase np complete 
current focuses trying lever methods fast database searching produce sub quadratic algorithm phase 
weakness method artificially separates orientation layout 
see explanation necessary choice relaxation maximum weight branchings 
noted solving problems optimally guarantee optimal solution combined reconstruction problem 
desired algorithm solves simultaneously 
done graph theoretic formulation uses relaxation maximum weight matchings subject 
author wishes webb miller providing human gene cluster sequence david sankoff access machines universit de montr eal 
anonymous referees comments 
blum avrim tao jiang ming li john tromp yannakakis 
linear approximation shortest superstrings 
proceedings rd acm symposium theory computation 
fratta 
note finding optimum branchings 
networks 
fratta 
best spanning arborescences network 
networks 
chang william eugene lawler 
approximate string matching sublinear expected time 
proceedings st ieee symposium foundations computer science 
chv atal av david sankoff 
longest common subsequences random sequences 
journal applied probability 
cull paul jim holloway 
reconstructing sequences shotgun data 
manuscript 
david 
linear time algorithm dna sequencing 
technical report department computer science yale university new haven connecticut 
fredman michael robert sedgewick daniel sleator robert tarjan 
pairing heap new form self adjusting heap 
algorithmica 
fredman michael robert tarjan 
fibonacci heaps uses improved network optimization algorithms 
journal association computing machinery 
gabow harold 
algorithms generating weighted spanning trees order 
siam journal computing 
gabow harold zvi galil thomas spencer robert tarjan efficient algorithms finding minimum spanning trees undirected directed graphs 
combinatorica 
gallant john 
complexity overlap method sequencing biopolymers 
journal theoretical biology 
gallant john david maier james storer 
finding minimal length superstrings 
journal computer system sciences 
roberts 
computer programs assembly dna sequences 
nucleic acids research 
gusfield dan landau schieber 
efficient algorithm pairs suffix prefix problem 
information processing letters 
huang 
contig assembly program sensitive detection fragment overlaps 
genomics 
hutchinson george 
evaluation polymer sequence fragment data graph theory 
bulletin mathematical biophysics 
kececioglu john 
exact approximation algorithms dna sequence reconstruction 
phd dissertation technical report department computer science university arizona tucson arizona 
kececioglu john eugene myers 
procedural interface fragment assembly tool 
technical report department computer science university arizona tucson arizona 
lawler eugene 
procedure computing best solutions discrete optimization problems application shortest path problem 
management science 
li ming 
dna sequencing theory 
proceedings st ieee symposium foundations computer science 
manber udi gene myers 
suffix arrays new method line string searches 
proceedings st annual acm siam symposium discrete algorithms 
appear siam journal computing 
jean william demers ross 
complete nucleotide sequence rabbit fi globin gene cluster analysis intergenic sequences comparison human fi globin gene cluster 
journal molecular biology 
mehlhorn kurt 
data structures algorithms volume sorting searching 
springer verlag berlin 
myers eugene 
incremental alignment algorithms applications 
technical report department computer science university arizona tucson arizona 
hannu hans tarhio ukkonen 
algorithms string matching problems arising molecular genetics 
proceedings th ifip world computer congress 
hannu hans ukkonen 
dna sequence assembly program mathematical model 
nucleic acids research 
press william brian flannery saul teukolsky william vetterling 
numerical recipes art scientific computing 
cambridge university press new york 
sankoff david 
minimal mutation trees sequences 
siam journal applied mathematics 
sankoff david chv atal 
upper bound technique lengths common subsequences 
time warps string edits macromolecules theory practice sequence comparison david sankoff joseph kruskal editors addison wesley reading massachusetts 
sankoff david joseph kruskal editors 
time warps string edits macromolecules theory practice sequence comparison 
addison wesley reading massachusetts 
shapiro marvin 
algorithm reconstructing protein rna sequences 
journal association computing machinery 

algorithms determining primary structure biopolymers 
bulletin mathematical biology 
smith temple michael waterman 
identification common molecular subsequences 
journal molecular biology 
strategy dna sequencing employing computer programs 
nucleic acids research 
tarhio ukkonen 
greedy approximation algorithm constructing shortest common superstrings 
theoretical computer science 
tarjan robert 
finding optimum branchings 
networks 
turner jonathan 
approximation algorithms shortest common superstring problem 
information computation 
ukkonen 
linear time algorithm finding approximate shortest common superstrings 
algorithmica 
