categorical logic concurrency interaction 
synchronous processes du pavlovi department computing imperial college queen gate london sw bz united kingdom mail pavlovic doc ic ac uk report mathematician effort understand concurrency theory 
starting point logical interpretation nielsen winskel account basic models concurrency 
obtained logical structures build calculus relations yields cut bisimulations abramsky interaction category synchronous processes 
interaction categories arise way 
obtained presentation uncovers logical contents sheds light original idea processes relations extended time 
sequel address issues asynchrony preemption linear logic setting 
concurrency computation modelled different ways 
attempts unification 
abramsky proposed paradigm relations extended time foundation theory processes 
interaction categories meant capture paradigm formally 
structure fully axiomatized thoroughly motivated examples 
way standard models concurrency primal example interaction category category synchronous processes sproc sec 

section surveying basic notions categorical logic particularly regular fibrations induced calculi relations turn source structure process calculi 
section simplest models processes automata synchronisation shown form regular fibrations rich intrinsic logic 
structures spelled albeit different form analysed logically 
processes appear predicates corresponding alphabets 
subsection refine predicates safety specifications logic trees relativised logic specifications 
non logical sequent calculus capturing logic trees described section 
concurrency theorists recognize pre equational part sccs extended apparently new operations correspond implication universal quantification trees 
logical contents basic process operations appear clearly computational significance implication remains explored 
bicategory relations induced regular logic trees predicates specifications aligned abramsky interaction category synchronous processes sproc section 
formally appears abramsky paradigm processes relations time 
sproc just formal calculus relations proper quotient bicategory relations induced regular logic trees 
interesting part explaining quotient 
induced equational part sccs incorporated picture section 
representative process automaton tree may redundant geometry principle completely determined computational behaviour way properties computationally irrelevant 
processes defined classes computationally equivalent bisimilar representatives individual trees automata 
equations process calculi identify classes determine notion bisimilarity 
kernel process calculus obtained cutting logic trees modulo bisimilarity 
bisimilarity drives concurrency road universal logical operations area unexplored categorical logic 
order processes modulo bisimilarity consider formal bisimilarity quotient regular fibration synchronisation trees concrete representation developed 
main feature chosen representatives graph morphisms capture computationally sound simulations preserve bisimilarity 
sec 
called simulations sober argued natural choice computationally relevant morphisms 
obtained category processes uncovers remarkable phenomenon logical operations preserve bisimilarity representatives preserve bisimilarity sober simulations representatives 
upshot process operations extended functors acting processes morphisms 
strong bisimilarity congruence respect object part logical operations trees induce process operations bisimilarity classes place congruence respect arrow part bisimilarity preserving simulations see alternative 
straightforward solution problem built sproc collapse simulations similarity preorder oe recording simulate disregarding distinctions particular simulations 
sproc just quotient bicategory relations preorder collapse 
may need precise account dynamics simulations arise different solution sought refined notion bisimilarity congruence respect processes respect morphisms 
elements categorical logic book curry feys remarked striking analogy theory functionality theory implication section 
analogy developed paradigm types logical frameworks computation 
calculus provides means encoding constructive proofs functions 
categorically striking analogy explained adjunction function space constructor gamma implication ff gamma arise right adjoints functors theta gamma ff gamma respectively account arise analogous right adjoints 
ha bi gamma 
theta fl ff fl fi fl ff fi theta ff fi fl fi ff fl observation early sixties lawvere defined cartesian closed categories variable free alternative typed calculus 
pursuing idea logical operations adjunctions went introduce hyperdoctrines structure capturing higher order predicate logic 
hyperdoctrines hyperdoctrine basically contravariant functor category sets category cat categories 
category meant category predicates set arrows proofs arrows functions 
cartesian closed structures respectively represent basic propositional set theoretical operations 
determined entirely terms adjunctions 
structure functor op cat correspond main operations predicate logic 
arrow part yields substitution mechanism function functor maps predicate simple fundamental observation lawvere quantifiers implemented adjoints substitution functors represents read jy jy 
interpretation turns idea quantifiers adjoints substitution definitions sequent calculus summarized invertible rules 
jy jy hyperdoctrine functor op ccc cartesian closed category ccc category cartesian closed categories structure preserving functors having adjoints play role morphisms 
basis development higher order predicate logic 
just subtle point illustrated example iii 
examples 
simplest example hyperdoctrine ordinary powerset functor 
base category set set functor assigns boolean algebra subsets 
functors map term doctrine previously denote monad equational theory cat 
subsets inverse images maps subsets direct images 
hyperdoctrines related structures generally speak inverse image functors direct image functors left right respectively 
inverse image functors usually written standard alternative written calculations alternative notation convenient 
ii simple example hyperdoctrine languages 
language set sigma seen alphabet simply set finite sequences words sigma 
languages sigma form boolean algebra sigma sigma sigma free monoid generated sigma 
function sigma gamma induces monoid morphism sigma gamma induces inverse direct images sigma gamma 
fact shall consider prefix closed languages 
language prefix closed sigma st implies implies empty word contained usually considers nonempty prefix closed languages empty leads exceptions time 
hand nonempty prefix closed languages thought specifications 
course complement specification specification sublattices sigma sigma specifications boolean 
complete heyting algebras cartesian closed 
hyperdoctrine set op ccc 
iii category pos posets functor pos op ccc take poset induced complete heyting algebra lower sets 
inverse direct images obtained suitable lower closures 
structure needed predicate logic available 
sense logic unsound 
square fflffl fflffl pullback reasonable require equation jt implies jy jz 
follows predicate formula jt imply jz 
hyperdoctrine 
take instance arrows inclusions fg 
pullback 
jt 
jz empty 
imply 
preclude pathologies kind hyperdoctrine satisfy stability conditions 
definition 
lawvere functor op ccc hyperdoctrine canonical arrows 
derived adjunctions isomorphisms pullback arrow requirement known beck chevalley condition frobenius condition 
explained conditions interpretation variables goes wrong different variables interfere substitution quantification 
shall come back point 
indexed fibred categories full structure hyperdoctrine necessary 
concerned regular logic limited conjunction existential quantification sorts combined finite products theta 
course basic substitution mechanism provided reindexing predicates functions sets 
certain purposes convenient mechanism fibred indexed form 
distinction theme subsection 
regular logic explained subsection 
world sets indexed family ha function components recovered function fibres gamma 
equivalence categories set set topological space continuous indexed families sheaves 
sheaf induces morphism continuous function time function comes sheaf local homeomorphisms correspond sheaves 
embedding sh 
sp sheaves spaces passage trivial previous set set fact sense total view sheaf space sp offer essentially insight indexed form sh 
instance circle sheaf corresponding projection cylinder distinguished sheaf corresponding projection band global view 
similar convincing examples higher dimensions torus klein bottle various combinations 
phenomena occur level categories 
indexed category principle functor op cat 
idea category sets 
category thought category indexed families ordinary category theory viewed theory set indexed categories category functor delta set op cat delta delta reindexing sense categories tacitly form powers reindexing 
basic categorical concepts need modified expressed 
instance set indexed products delta right resp 
left direct images 
note indexed category form satisfies beck chevalley condition 
passing set base lifts ordinary category theory indexed theory instance products defined right resp 
left direct images satisfying beck chevalley condition 
concepts dealt similar fashion 
grothendieck construction 
transition indexed categories cat op fibred presentation cat simpler passage sheaves sh set op local homeomorphisms sp involve reconstruction points 
functor op cat form abusing notation category glueing 
fibration projects precisely objects pairs ha 
arrow ha hb qi pair hf 
composite hf ha hb qi hg fli hb qi hc ri pair fl fflffl fflffl fl fflffl fl obviously functor project pair component 
functor fibration induced op cat 
category fibred examples 
category indexed category delta set op cat viewed fibred category delta object set indexed families objects morphism pair hf function 
natural transformation fact just family 
ii powerset hyperdoctrine set op cat induces fibred category predicates objects pairs sets ha arrow ha hb qi function maps formally means equivalently inclusion formal morphism hf 
companion unique need mention explicitly 
iii fibred category specifications obtained glueing lattices 
objects pairs sigma sa sa prefix closed language alphabet sigma morphism function sigma sigma maps word sa word sb 
course monoid morphism sigma sigma takes string delta delta delta delta delta delta 
fibration 
recover indexed category op cat derived fibration clearly categories isomorphic fibres ca definition fibre ca subcategory identity 
say object arrow recover arrow part functor observe inverse image appears domain arrow hf idi ha qi hb qi arrow factorizes unique vertical arrow fibre 
ha hf fflffl hid ha qi hf idi hb qi words arrows functor recovered property object go domain arrow determines arrow part arrows called cartesian 
characterize fibrations functors obtained grothendieck construction equivalent functor strong sense 
functor fibration vertical cartesian arrows induced form factorisation system 
definition 
consider functor arrow cartesian respect unique vertical arrow 
say cartesian liftings arrow eb cartesian arrow codomain liftings generically denoted fibration cartesian liftings closed composition 
morphism fibrations functor fe preserving cartesian arrows 
explained reconstruction total fibred category indexed category may yield insights technical advantages 
having predicates category stratified corresponding sets may indispensable logical constructions 
important point crucial part structure indexed categories substitution functors get encoded fibrations property 
transformations kind distinguish categorical approach algebraic 
way back original structure recovered isomorphism 
arrow isomorphic cartesian liftings determining isomorphic inverse images order extract indexed category abstractly fibration choices isomorphic may possible choices way ensure strict equality functors choice yield canonically isomorphic 
principle fibrations induce functors op cat preserve composition family fg 
coherent natural isomorphisms 
fg identities just functors 
reader willing accept inconvenience allowing indexed categories 
indexed categories come naturally 
instance possible develop indexed category category sets 
set indexed category set course functor set delta set op cat set delta set set category may defined solution problem suggested equivalence set set slice defined put delta object part delta op cat 
looking example sets see reindexing delta choice pullbacks seldom possible choice globally way pullback functors come strictly equal 
time delta op cat choice pullbacks canonical isomorphisms 
hand corresponding fibration simply codomain functor cod category arrows commutative squares morphisms 
base fibration cartesian arrows cartesian pullback squares 
terminology 
ambiguity notation shall freely switch fibred indexed categories 
theory reader may wish consult sources 
suitable textbook exposition exists reason 
conceptually story fibred indexed categories contains little familiar notions ordinary categories 
technically notions tend demanding setting need carefully worked books things usually fun 
logic fibrations propositional set theoretical operations described fibred category manner indexed category base fibres preserved inverse images 
notions related quantification appear different light 
definition 
functor op op op fibration 
cartesian arrows respect op called opcartesian respect opcartesian lifting written oe functor bifibration fibration 
morphism preserve cartesian opcartesian arrows 
fibrations induce contravariant functors op cat induce covariant cat 
bifibration inverse image functors derived op left adjoint inverse image functors derived universal property oe property ensure 
induce op cat morphisms cat functors left adjoint 
start bifibration fibrewise dual fibration bifibration get op cat morphisms adjoints 
category constructed formally inverting vertical arrows 
objects arrows isomorphism classes spans form vertical cartesian 
note arrows isomorphism classes decompositions corresponding hyperdoctrine fibrewise cartesian closed fibration 
course beck chevalley frobenius conditions satisfied 
various ways express beck chevalley condition bifibration mere fibration 
instance induced bifibration satisfy beck chevalley condition opcartesian arrows stable pullbacks cartesian arrows prop 

induced satisfy frobenius condition opcartesian arrows stable pullbacks vertical projections prop 

reason refer beck chevalley frobenius conditions stability conditions 
regular fibrations definition 
functor regular fibration ffl finite products ffl finite fibrewise products ffl bifibration satisfying beck chevalley frobenius conditions 
words small coproducts distribute finite products 
morphisms regular fibrations bifibration morphisms preserving finite fibrewise products 
structure supports regular logic fragment sorted order logic equality 
structure regular fibration described logical notation variables equality predicate 
explain informally detail 
firstly recall function substituted theta inverse image id theta multiple variables manipulated projections diagonals 
variable needs repeated positions substituted diagonal theta id theta hid fi hand dummy variable type substituted projection theta theta theta conjunction corresponds fibrewise products denotes product theta theta 
direct images projections correspond quantification 
sense beck chevalley frobenius conditions satisfied 
writing quantifiers side formula substitution occurs assumption operations commute formula tell quantification substitution dummy occurred 
explained beck chevalley condition ensures order operations matter 
frobenius condition hand isomorphic predicates 
sense conditions take care different variables interfere 
direct images projections theta provide quantifiers direct images diagonals theta yield equality predicate jy 
stability conditions get things jy theta hid fi 
jy 
hid fi 

jy 
putting second formula yields jy sheds light idea definition equality 
substituting formula identity shows equality sound substitution xjx 
importantly formula allows express direct images logical form quantifiers equations 
interpret quantifiers equations need direct images projections diagonals 
derive direct images special class 
proposition 
consider fibration suppose finite products finite fibrewise products regular fibration soon stable opcartesian liftings projections diagonals 
regular logic calculus relations regular fibration induces bicategory relations rel 
objects cells hom categories ea thetab cells relations binary predicates theta cells proofs cell relation written 
composite 
standard notation projections theta theta theta theta theta theta theta theta theta construct clearly functorial 
arrow part tells cells composed 
stability conditions ensure associativity canonical isomorphism equality predicates 
play role identity cells 
examples 
applied powerset examples ii construction described yields ordinary bicategory sets relations 
generally calculus relations category arises regular fibration cod mon mon subcategory arrow category spanned 
fibration regular category regular 
relations form bicategory 
furthermore stable factorisation family induces regular fibration cod bicategory relations 
studied 
general regular fibrations induced sites triposes studied 
structure 
structural correspondence regular fibrations induced bicategories subtle 
book freyd scedrov thoroughly analyzed interval regular categories toposes 
correspond unitary tabular allegories op cit sec 

carboni walters cartesian bicategories accomodate similar analyses general 
bicategory rel product theta induces tensor product omega diagonals projections induce diagonals projections form natural families 
diagonals projections set natural respect relations ordinary bi category relations just respect total single valued ones 
general lax natural universal property 
coproducts sets bicategory relations ordinary 
structure cartesian bicategories idea tensor omega recognized cartesian structure distinctive property omega relational view cartesian product fact object carries canonical structure omega comonoid diagonal comultiplication terminal arrow augmentation 
structure cartesian bicategory consists tensor omega prescribes canonical omega comonoid structure object 
data pinned diagonals terminals old cartesian category requiring lax natural self adjoint means total single valued relations maps 
course structure disciplined natural tedious coherence conditions carboni walters avoided restricting attention case 
bicategories relations induced regular fibrations cartesian seldom 
fact special cartesian bicategories logical origin captured discreteness condition def 
echoing stability logical operations beck chevalley frobenius conditions 
rate described construction yields functor rel regular fibrations cartesian bicategories 
adjunction 
suitable sense rel construction right adjoint 
principle echoes reconstruction powerset ordinary bicategory relations 
technical details general reconstruction considerably complicated reaches far scope needs 
shall just outline main steps idea passage predicate logic calculus relations just change presentation preserving contents expressive power 
cartesian bicategory associated regular fibration derived follows 
base category consist omega comonoids discrete mentioned carboni walters sense op 
cit comonoid structure cells maps 
proved morphisms unit self adjoint relation says total counit single valued sec 

people call bicategory homomorphism am member club founded probably kelly tries functors adjunctions dimensions lift categories technical term lawvere 
comonoids maps 
right adjoint comonoid morphism 
relation defined composite fflffl omega omega omega omega fflffl omega omega omega omega omega oo omega arrow 

omega obtained comonoid structure omega 

derived adjoints comonoid structure cells maps iso sec 
isomorphism classes comonoid morphisms form ordinary category trivial cells 
hard see tensor omega cartesian product 
fibre ea predicates relations captured hom category 
course unit omega direct inverse images map 
right adjoint respectively 
eb fflffl fflffl gamma ea oo gamma frobenius condition resulting bifibration just modularity law derivable bicategory relations essentially discreteness condition thm 

hand get idea condition satisfied notice interpreted logically iii comes close saying square formed maps pullback cf 
appendix 
fibrewise product ea defined diagonals adjoints fflffl omega fflffl omega omega oo predicate logic models concurrency typical examples regular fibrations 
thought common generalisation sites triposes 
shall study concrete regular fibrations closely related examples automata synchronisation trees fibred alphabets 
synchronisation trees form implication universal quantifiers 
section refine specifications 
simplicity assumed base category set natural numbers 
automata transition systems nondeterministic automata viewed directed graphs labelled edges 
vertices states edges transitions 
vertex distinguished initial state 
starting automaton reads input symbol alphabet tries accordingly labelled transition 
nondeterminism comes may number transitions state case automaton deadlocked 
chooses suitable transition reads symbol input looks suitable transition 
runs exhausts input deadlocks 
case say accepted word 
run automaton directed path transitions 
trace run word accepted sequence labels 
accepted language automaton trace definition set traces runs 
structure automata includes distinguished set final states 
run described required terminate final states 
shall assume states final 
means automaton halt moment accepted language prefix closed 
formally automaton diagram sigma oo ffi oo operations ffi assign transition respectively label source target constant initial state 
morphism automata natural transformation diagrams 
sigma fflffl sigma fflffl oo ffi fflffl ee yy sigma tq oo ffi sq fact triple functions sigma 
form graph morphism preserving initial state labelling sense takes labelled transition sigma labelled 
morphisms automata form category fibred functor sigma projects automaton corresponding alphabet 
morphism cartesian left hand square pullback isomorphism 
morphism opcartesian isomorphisms 
clearly opcartesian liftings exist cartesian require pullbacks 
inverse image constructed putting set states sq exactly gamma copies labelled transition 
direct image obtained simply relabeling underlying graph just put place beck chevalley frobenius conditions immediate 
product fibre obtained product sq theta set pairs equally labelled transitions set obtained pullback tq functor sigma regular fibration 
predicate logic automata 
mention coproducts yield fibrewise coproducts calculated straightforward way 
automaton deterministic label determines exactly transition state 
means hffi gamma 
theta sigma isomorphism 
transition system hand automaton transition label states 
words hffi gamma 
theta sigma theta monic 
shall go deterministic automata just automaton induces transition system image hffi determines new set transitions 
words identifying transitions sources labels targets 
clearly operation changes computational behaviour automaton 
determines left adjoint functor inclusion 
transition systems automata 
inclusion reflection preserve inverse images codomain cartesian arrow transition system domain 
transition systems form fibred reflective subcategory category automata 
fibrewise products inherited 
direct images induced reflection 
regular fibration 
regular fibration spanned reachable automata state reached initial state 
inclusion 
right adjoint reachable automata span subcategory automata 
unreachable states just parallel transitions computationally irrelevant fibred categories conceptually equivalent far computation concerned calculating somewhat simpler 
fibred subcategory synchronisation trees offers significant advantages 
trees poset natural numbers delta delta delta tree understood presheaf diagram oo oo delta delta delta oo trees form presheaf topos op elements vertices th level function gamma projects predecessors 
edge gamma root left implicit 
synchronisation tree diagram fflffl fflffl oo fflffl oo delta delta delta oo sigma sigma sigma simply tree vertices root labelled sigma better understood edge labelling vertex root receives exactly edge 
synchronisation trees clearly presheaves 
form topos morphism natural family preserving labelling predecessors 
fl fl fl fl fl fl fl fl fl fl fl fl fl fl fl fflffl sigma sigma fl fl fl fl fl fl fl fl fl fl fl fl fl fl fl fflffl oo sigma sigma fl fl fl fl fl fl fl fl fl fl fl fl fl fl fl fflffl oo delta delta delta oo sigma sigma sigma oo oo delta delta delta oo synchronisation tree projected alphabet sigma get fibration sigma topos unlabelled trivially labelled trees appears fibre 
fact fibres toposes category sigma sigma labelled trees isomorphic slice category sigma right adjoint forgetful functor maps tree set vertices 
tree sigma cofree set sigma 
fairly easy describe starting root add vertex exactly sigma edges 
th level sigma sigma vertices 
function gamma sigma sigma gamma projects away th component 
standard topos theory shows sigma 
synchronisation trees support full higher order predicate logic 
shall calculate relevant operations try grasp meaning 
left direct image sigma tree sigma gamma just relabelling 
relabel inverse image gamma tree similar idea automata labelled edge replaced gamma edges coming vertex 
edges introduce new vertices tree 
subtree coming labelled edge started copied new vertices go replacing edges tree 
similarly product vertices course pairs vertices labelled letter 
predecessor pair 
come requirement paired vertices trace 
trace vertex sequence labels obtained climbing tree root vertex 
formalize construction order see yields product 
sets pairs vertices trace length obtained recurrent pullbacks 
gamma gamma oo fflffl fflffl gamma fflffl fflffl oo delta delta delta oo fflffl fflffl theta gamma theta gamma fflffl fflffl xx theta gamma fflffl fflffl xx zz theta fflffl fflffl theta fflffl oo fflffl theta fflffl oo fflffl gamma gamma gamma calculate equalizers pullbacks gamma gamma 
theta 
starting id pull back get directly check construction yields product gamma observe calculated pullback gamma product gamma 
inverse image described informally formalised lines 
construction follows tower pullbacks fflffl oo fflffl fflffl fflffl fflffl oo delta delta delta oo fflffl fflffl theta gamma sigma fflffl theta gamma sigma fflffl theta gamma sigma fflffl theta sigma fflffl fflffl theta sigma fflffl oo thetaid fflffl theta sigma fflffl oo thetaid fflffl gamma gamma gamma corresponds pulling back gf sigma gamma functor gamma sigma 
regular logic fibration sigma supports 
disjunction represented fibrewise coproducts trees calculated completely straightforward way implication exponent topos gamma gamma universal quantification dependent product gf sigma gamma topos spell detail noticed computational setting 
descriptions simplified fact topos gamma generated tree gamma words gamma represented branches trees vertex level 
fact generate means gamma tree colimit gamma branches need weaker fact gamma tree colimit word lim gamma 
gamma seen full subcategory gamma set gamma meet semilattice means prefix product hand subtree consisting vertices leave prefixes trace follows description products 
precisely gamma set qs consist vertices trace gamma prefix empty 
truncation derive useful representation hom sets gamma gamma gamma lim gamma 
ii lim gamma gamma iii lim gamma gamma iv lim gamma gamma step just step ii follows definition colimit step iii consequence fact branch subobject terminal object step iv fact elements labelled th letter label preservation automatic 
words gamma morphisms gamma 
viewed ordinary tree morphisms 
terms representation directly proves formulas define exponents gamma right direct image functor sigma gamma respectively gamma gamma meant internally topos statement generally true terminal object vertex generate 
recall trace vertex sequence labels predecessors plus 
gamma sigma elements sets form hs word length suitable morphism natural transformation components nontrivial 
cases operation assign hs element label 
predecessor operation gamma gamma 
gamma truncate hs hs gamma gamma holds course gamma gamma gamma string element gamma natural transformation component 
better understand describe vertex hs words 
suppose sequence extract labelled vertices successors extract labelled take successors labelled just tree morphism obtained trees 
begins ordinary function level assigning labelled vertex labelled vertex 
assign labelled successor labelled successor 

understand look tree subobject terminal object sigma sigma th element write sigma gamma sigma vertex level exactly sigma edges coming 
describe level labelled vertex choice labelled element sigma get labelled element successors previously chosen vertex select labelled vertex sigma elements various copies trees various gamma specifications mathematically processes usually languages synchronisation trees automata transition systems 
explained categories related adjunctions 
oo oo gamma comment briefly presentations different 
tree automaton augment root 
vertices predecessor operations induce obvious endomorphism edges graph run set transitions fhx yi jx full faithful functor bi fibred preserves inverse left direct images 
preserve products left adjoint 
right adjoint gamma obtained unfolding automaton tree runs directed paths starting 
vertices associated tree 
describe unfolding automaton formally consider functor gamma 
maps gamma 
fhx fi theta ffi 
domain arrow instance consists edges coming initial state 
projects target 
edges coming target states added apply 
domain consists step runs pairs composable transitions starting 
general set dom consist runs length vertices unfolding level dom sets form synchronisation tree dom comes obvious projection dom labelling inherited trace functor assigns tree language accepts 
right adjoint hand displays specification sigma si tree ja ja sigma set safe words length contained seen vertex word labelled symbol 
clearly full 
viewed process language tree automaton sense extensional collapse records performance neglects behaviour 
hand safety specification performance requirement represented prefix closed language 
process said satisfy specification accepted language contained 
sense sigma displays logic specifications predicates alphabets 
sigma synchronisation trees refers logic processes 
fibred adjunction displayed allows refine logic specifications 
achieved method applied model theory universe enlarged new sets definable theory case specifications logical operations relativized respect added sets new theory relativised operations built refined universe 
formalised categorically described procedure expand fibration trees regular fibrewise fibration fibration specifications words shall build regular fibration category regular fibrations ordinary category regular categories 
fortunately regular resp 
hyper fibrations category regular hyper fibrations just morphisms fibrewise components happen regular hyper fibrations ordinary sense prop 
ii ii ii 
expanding fibrewise regular fibration turns fairly simple 
functor happens fibration 
inverse image tree arrow obtained pullback fflffl fflffl ja jf js problem direct images 
needed construct free regular fibration generated principle free regular fibration induced fibration obtained comma construction provided finite limits finite fibrewise products 
lift construction ordinary fibrations category categories fibrewise fibrations category fibrations take fibrewise comma construction ordinary 
morphisms fibrations objects fibrewise comma category triples ha fa gb bi vertical arrow 
free fibrewise regular fibration generated functor sp fibred category obtained fibrewise comma construction 
adjunction yields alternative presentation isomorphic objects viewed triples sigma si synchronisation tree satisfies specification sigma equivalently js arrow unique js subobject terminal object sigma sigma point functors sigma sp projecting process respectively alphabet sigma specification sigma si 
morphism category fibrewise 
describe structure leave checking reader 
sigma gamma function sigma si gamma predicates inverse direct images respect sigma sigma gamma si structure appearing right hand side comes sigma sigma easy 
ditto gamma gamma sigma sigma want calculate inverse direct images respect sp recall morphism specifications sigma si gamma function sigma sigma safe string sigma holds gamma existential quantifiers gamma strict canonical obtained directly definition comma category tree right hand side precisely write sigma si just alphabet sigma fixed safely omitted 
direct image respect sigma relabelling traces surely contained traces implies inverse images right direct images universal quantifiers respect sigma general satisfaction specifications 
results restricted safe strings order yield corresponding structures sp restriction obtained fibrewise products described sigma sigma ja si gamma gamma jb rest structure right hand side 
note sigma ja subtree ja subobject terminal object jh sigma sigma sigma reason holds gamma jb propositional operations hand product gamma gamma arrow jb soon 
satisfy specification satisfies 
fibrewise product specification gamma gamma hand exponent sigma may satisfy specification restricted way gamma gamma gamma jb alternatively restriction formulas enforced presenting respectively form restricted indexing sums taken gamma gamma set safe strings length logic process calculus section described logical operations trees operations indexed sets extended time 
form correspondence sccs operations apparent 
algebra trees traditionally automata processes studied point view accepted languages 
finite ones completely reduced calculus regular expressions ch 

computational behaviour nondeterminism left picture 
automaton deterministic hffi theta sigma isomorphism accepting language 
issue computational behaviour addressed milner calculus communicating systems ccs 
idea observe automaton running get know words accepts lead deadlock deadlocks may occur due nondeterminism reading acceptable words 
instance milner pointed processes oe ae aeoe theta theta theta theta theta theta theta theta oe ae aeoe oe ae aeoe oe ae aeoe oe ae aeoe theta theta theta theta theta theta theta theta oe ae aeoe oe ae aeoe oe ae aeoe oe ae aeoe accept language fa ab acg behave observably different ways 
right hand side accepts element language deadlocks half times chooses go left reading ac chooses go right reading ab 
nondeterminism taken account processes identified 
depict respectively regular expressions ab ac milner concluded distributive law dropped algebra processes 
dropping distributivity brings realm trees 
finite sigma labelled trees viewed elements free algebra generators single constant sigma unary operations commutative associative binary operation unit 
distributivity 
constant represents trivial tree just vertex 
operation sigma maps tree tree ap obtained adding new root connecting old labelled edge 
called prefixing 
delays proces action executed 
tree single edge usually abbreviated sum corresponds tree obtained identifying roots computationally represents nondeterministic choice processes categorically coproduct category sigma logically disjunction predicates sigma 
interpreted trees sets operation correspond union just calculus regular expressions 
generated delays nondeterministic choices trees moral minimum process calculi 
trees sets time tree vertex represents set 
elements set represented successors edge means successors capture elements 
constructible set unfolded tree displays history came cumulative hierarchy 
tree depicting set extent time 
brings close abramsky idea processes relations extended time sec 

couched aczel view processes arising similarly constructible sets coinductive iteration power set operator 
course poetry trees time expressed categorically 
chain fixed point delay functor taken picture time endless discrete irreversible trees subsection just sets extended time 
tree morphisms appear functions extended time 
trees represent sets ordinary function just assigns element element elements vertices function function extended time having assigned goes assigns element element hereditary function 
represents set gamma represents gamma function displayed presentation trees restriction gamma exponents trees depicted just collect functions time 
product trees similarly extends product sets time sense collect just pairs elements hx yi actual hereditary products fx yjx qg formula form 
describing logical operations trees set theoretical idea get system similar sccs 
sequent calculus trees sequent form means tree aq contained tree set sequents write abbreviate set sequents writing operations subsection form ap pg xjp xg alternative presentation provided sequent calculus captures operations subsection 
notation 
fx denotes set labelled elements tuple labelled edges possibly repetitions 
delta pg fq gamma gamma remarks 
note sequents represent logical entailment edges trees 
logical meaning displayed operations simply comparing corresponding rules familiar gentzen style sequent calculi 
way avoiding logical analysis category trees subsection 
hand exception rules familiar milner calculus communicating systems 
nondeterministic sum sigma relabelling restriction appears special case 
corresponds synchronous product op cit sec 
modelling version synchronous calculus sccs 
derived calculus relations yield category synchronous processes 
new rules readily understood comparison 
process satisfying specification morphism rule says action chooses nondeterministically gamma process hand rule says action invokes gamma process executes parallel 
sense parallel relabelling pursues actions time ordinary relabelling nondeterministic pursues arbitrarily chosen 
rule bit difficult explain computationally 
computation corresponds choice way traced way simulate sproc put threads apply construction described calculus interpret result 
obtained bicategory relations rel sp turn closest logical relative category synchronous processes sproc 
synchronous processes relations objects categories clearly coincide just specifications 
compare hom categories pa thetab sproc fha omega bg summarising 
object pa thetab tree satisfying specification theta theta exactly abramsky writes omega tensor product omega sproc just cartesian product theta furthermore formulas identities composition sproc exactly correspond identity relations standard relational composition ccs style 
identity relation defined derived delta 
ha ai 
terminal object pa tree ja described 
specification alphabet safe strings fs sigma jas sa step derivation just form 
substituting get sigma jo clearly original definition identity sproc just expressed terms 
strictly speaking triple sigma ja sa abuse notation denote ja 
relational composition expanding formula ccs style derivation yields ha bi ha ci hb ci ha ci ha ci ha ci substituting derivation summarized composite rule ha bi hb ci ha ci just original formula composition sproc 

cockett proposed presentation sproc formal quotient bicategory spans course bicategory viewed bicategory relations induced basic regular fibration cod gamma 
derivation sproc explained terms cartesian functor gamma 
maps specification morphism direct image functor tacitly explanation sproc morphisms obtained spans surjective objects faithful apparently 
suffices reconstructing relations morphisms sproc 
difference spite clear structural conceptual parallelism sproc coincide bicategory relations fewer morphisms 
sproc morphisms canonical representatives processes exhaust labelled trees 
turns fairly essential point considerable conceptual weight significant structural repercussions 
understanding effect restriction difficult part purported analysis distorts described logical operations 
similar transformations change context frequent phenomenon pathology cf 
way standard tensor product category relations obtained cartesian product corresponding category sets 
tensor product vector spaces boils cartesian product chosen bases similar fashion 
irredundant trees 
mentioned trees automata processes observed computations turn indistinguishable represent process spite geometric differences 
processes individual trees automata classes computationally equivalent bisimilar representatives 
working bisimilarity classes usually chooses canonical representative irredundant sense carries computationally relevant data 
irredundant representatives processes obtained elements aczel terminal coalgebra ch 
small 
morphisms sproc defined class irredundant trees 
intrinsic characterisation trees worked bit effort lines section 
founded irredundant tree recognized fact trivial group automorphisms 
means viewed tree satisfies law fx fx represents set 
founded irredundant trees considered model set theory long time ago 
irredundant trees general obtained colimits towers founded ones 
words tree irredundant founded subtrees embedded founded tree trivial automorphism group 
different direction irredundant trees obtained unfolding irredundant automata 
way isomorphism category processes 
obtained 
objects canonical representatives processes 
graph morphisms preserving labels initial states capture sober bisimilarity preserving simulations 
restricting operations 
easy see class closed described operations prefixing 
tree represents process irredundant collapse 
words mapping jpj gamma 
pj left inverse object part inclusion 
morphisms sproc objects morphisms objects morphism part structure transferred sproc inclusion retraction 
way categorical structure sproc completely induced holds identities composition tensor cofree comonoid construction 
inherited relational calculus 
level cells parallelism pertain 
reason irredundant collapse construction jpj gamma 
pj extended functor tree morphisms 
defined sober ones get left adjoint inclusion 
sober relevant operations taken functors preserve morphisms restricts sober arrow part logical structure restrict sober transferred way sproc inherit dimensional structure induced arrow part 
dynamics preorder original definition sproc distinguish particular simulations processes enriched simulation preorder oe records exists simulation processes 
words sproc derived preorder collapse oe functor gamma oe gamma 
sproc leaves objects unchanged maps tree 
irredundant collapse 
oe implies oe enriched functor 
sproc appears reflective oe forms soft equivalence inclusion sproc 
oe note oe bicategory relations corresponding regular fibred preorder oe gamma 
obtained making functor gamma 
faithful collapses fibres preorders 
sproc obtained calculus relations induced oe gamma 
regular preorder 
assert sproc realize slogan relations strictly formal sense 
signalled sproc simply disappears passage simulations similarity relation 
categories processes abandoned reduced preorders 
hand dynamic laws ccs nondeterministic sum join processes enforce 
resulting notion bisimilarity creates described gap sproc 
hand seen basic process operations stem logical operations universal isomorphism just modulo similarity ways 
similarity preorder imposed dynamic laws loose capture contents 
precise setting nature process operations reflected process morphisms require refined notion bisimilarity 
samson abramsky patience interest lindsay greg meredith answering naive questions 
abramsky interaction categories communicating sequential processes roscoe ed classical mind essays honour hoare prentice hall abramsky interaction categories foundations typed concurrent programming proceedings marktoberdorf summer school springer abramsky gay nagarajan constructing verifying typed processes talk confer workshop edinburgh aczel non founded sets lecture notes csli barr terminal coalgebras founded set theory theoret 
comput 
sci 
fibrations acad 
sci 
paris er 
math 
carboni walters cartesian bicategories pure appl 
algebra cockett sproc categorically proceedings concur lecture notes computer science springer curry feys craig combinatory logic stud 
log 

math 
north holland fox coalgebras cartesian categories com 
algebra freyd scedrov categories allegories mathematical library north holland godel consistency hypothesis ann 
math 
studies princeton univ press gray fibred categories eilenberg ed proceedings conference categorical algebra la springer grothendieck cat egories ees expos vi groupe sga lecture notes mathematics springer hopcroft ullman automata theory languages computation addison wesley joyal nielsen winskel bisimulation open maps proceedings symposium logic computer science ieee lawvere adjointness foundations dialectica lawvere equality hyperdoctrines comprehension schema adjoint functor proc 
sympos 
pure math xvii milner calculus communicating systems lecture notes computer science springer milner communication concurrency internat 
ser 
comp 
sci 
prentice hall panangaden categorical view concurrent constraint programming de 
eds semantics foundations applications lecture notes computer science springer park concurrency automata infinite sequences lecture notes computer science springer par schumacher families adjoint functor theorems indexed categories applications lecture notes mathematics springer pavlovi predicates fibrations thesis rijksuniversiteit utrecht pavlovi categorical interpolation descent beck chevalley condition direct images carboni 
eds category theory lecture notes mathematics springer pavlovi maps relative factorisation system report mcgill university march pp appear pure appl 
algebra pavlovi maps ii chasing diagrams categorical proof theory report mcgill university may revised pp submitted pavlovi convenient categories processes simulations modulo strong bisimilarity pitt 
eds category theory computer science lecture notes computer science springer scott different kind model set theory unpublished lecture congress logic methodology philosophy science stanford winskel nielsen models concurrency em abramsky 
eds handbook logic computer science vol 
iv clarendon press appear 
