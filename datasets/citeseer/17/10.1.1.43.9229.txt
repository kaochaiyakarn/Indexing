generational stack collection profile driven pretenuring perry cheng robert harper peter lee school computer science carnegie mellon university forbes avenue pittsburgh pa presents techniques improving garbage collection performance generational stack collection profile driven pretenuring 
applicable implementations functional languages second useful generational collector 
implemented techniques generational collector til compiler tarditi morrisett cheng stone harper lee observed decreases garbage collection times respectively 
functional languages encourage recursion lead long chain activation records 
collection occurs activation records scanned roots 
show scanning activation records take long dominant cost garbage collection 
deep stacks unwind infrequently root information obtained stack remains unchanged successive garbage collections 
generational stack collection greatly reduces stack scan cost reusing information previous scans 
generational techniques successful reducing cost garbage collection ungar 
various complex heap arrangements policies proposed increase effectiveness generational techniques reducing cost frequency scanning copying 
contrast show profile information lifetime predictions pretenuring avoid copying data altogether 
essence technique uses refinement generational hypothesis data die young locality principle concerning age data allocations sites produce data immediately dies allocation sites consistently produce data survives collections 
primary author may contacted cs cmu edu 
research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 

views contained document author interpreted representing official policies expressed implied advanced research projects agency government 
garbage collection technique automatic memory management programmer freed explicit deallocation heap storage mccarthy knuth wilson 
copying garbage collectors reclaim space steps scanning stack roots copying data reachable roots unused area memory 
area live data known contain garbage may reclaimed 
simple kind copying garbage collector semispace collector fenichel cheney algorithm cheney 
unfortunately semispace collectors usually attain efficient memory usage performance ungar observation objects die quickly ungar generational collectors arrange heap areas schedule collections improve performance 
generational collection successfully reduces cost copying data 
programs deep call chains cost scanning stack roots high 
study observe root processing take total garbage collection cost 
deep stacks frequently unwound table old stack frames unchanged successive collections 
determine stack frames unchanged cost root scanning reduced reusing information previous collection 
technique called generational stack collection generational garbage collection old stack frames reduce processing frequency 
generational techniques dividing heap different regions called generations 
objects survive initial minor collections nursery generation survive collections 
objects promoted areas frequently collected 
advantage collections older areas sufficiently delayed large fraction objects died making collection worthwhile 
longlived objects typically copied times 
multiple generations prediction accurate cause copying data survives 
alternative approach runtime object predictions classify objects allocation site profile results predict lifetimes 
technique yield information concerning predicted lifetime objects final execution 
success relies information returned heap profiling 
show allocation site predictor age object policies effectively allocation sites 
empirical data shows significant reductions data copying 
section gives background material details implementation 
section presents initial empirical results standard techniques 
section describes generational stack scanning performance results 
section motivates describes pretenuring performance results 
section explores extensions improvements generational stack collection pretenuring 
section presents related section summarizes results points directions 
background order sensible empirical comparisons implemented baseline garbage collectors semispace collector generational collector 
background material baseline collectors section 
representation data stack arises til compiler discussed 
explanation tracing stack reinforce notion scanning stack relatively costly result optimizing technology 
hardware benchmarks measurement techniques 
semispace generational collection semispace collector fenichel uses cheney copy algorithm cheney 
resizing strategy parameterized target liveness ratio particular liveness ratio collection heap resized factor tests target ratio value 
generational collector similar ungar 
parameters explored generational collection 
simplicity collector generations nursery generation 
heap resizing policy generation deviations preset target liveness ratio 
nursery larger secondary cache setup advice researchers including diwan tarditi tarditi diwan 
benchmarking reasons nursery significantly smaller 
minor collection immediately promote live objects nursery generation 
large arrays allocated nursery promoted area reside region managed mark sweep algorithm 
simple write barrier technique sequential store buffer appel handle pointer updates may create intergenerational 
til til tarditi morrisett cheng stone harper lee optimizing compiler standard ml sml exploits key technologies intensional polymorphism older generation created younger generation pointer update simply collecting younger generation lead dangling pointer 
mutator store pointer updates table runtime system garbage collection 
non pointer updates special action needed 
nearly tag free garbage collection conventional functional language optimizations loop optimizations 
technologies usually possible determine type representation values 
traditional functional language compilers universal data representation implement polymorphism til tag integers box floating point values 
particular til performs sufficient type analysis provide tag free unboxed word sized integers aligned unboxed floating point arrays 
runtime heap allocated objects represented records pointer arrays non pointer arrays 
intensional polymorphism optimizations improve runtime performance monomorphic code expense slower polymorphic code passes types runtime 
garbage collector interaction program complex 
til uses stack manage activation records heap allocated frames 
trading performance benefits stack greater complexity garbage collector 
entire runtime system consists lines assembly code 
lines comprise garbage collector including techniques examined lines provide support code pretty printing heap profiling debugging 
rest code provides support signals internally data structures 
stack scanning execution point data live accessed program continues execute 
conservative estimate accessible data reachable data 
reachable data may unnecessary program completion 
collector needs retain data accessible pointers starting root values 
roots directly accessible values registers stack slots 
difficulty accurately determining root set stems presence callee save registers polymorphism tarditi morrisett cheng stone harper lee 
callee save registers contents register stack slot may come caller frames stack frames decoded isolation 
stack scan start initial frame maintain pointer status register set scan progresses 
second polymorphism introduces variable types compiler statically compute particular value pointer 
result compiler communicate collector correspondence values dynamic types 
garbage collector called mutator return address indicates current execution point mutator 
indexing table auxiliary information called trace table return address determine frame layout gc caller frame 
return address gc caller frame decode caller frame 
continuing way reach initial frame 
initial frame determining root set adding registers stack slots traverse stack downwards 
note stack scan result callee save registers 
complex scheme decoding stack frames runtime system relieves mutator having tag stack slots stack frames may survive garbage collection 
boxed object stored memory represented pointer 
program lines description checksum checksum fragment harper lee kb possibly unaligned arrays created iterators times fft fast fourier transform multiplying polynomials degree color brute force graph coloring grobner compute grobner basis set polynomials degree yan knuth bendix implementation knuth bendix completion algorithm lexgen lexical analyzer generator appel mattson tarditi processing lexical description standard ml life game life implemented lists peg solving peg jumping game output prolog ml translator hornof queens problem pia perspective inversion algorithm waugh michaelson deciding location object perspective video image simple spherical fluid dynamics program arvind run iterations grid size 
table benchmark programs program total max live records arrays max avg frames new frames number alloc data alloc alloc stack stack pointer updates checksum mb kb mb mb color mb kb mb mb fft mb kb mb mb grobner mb kb mb mb knuth bendix mb kb mb mb lexgen mb kb mb mb life mb kb mb mb mb kb mb mb peg mb kb mb mb pia mb kb mb mb simple mb kb mb mb table allocation characteristics benchmarks type information available trace table 
return address serves key trace table entry stack frame size necessary 
addition general purpose register stack slot record trace 
types traces pointer non pointer callee save register compute 
pointer trace indicates compiler statically determined value pointer needs traced 
non pointer trace indicates value root 
registers stack slots marked callee save additional information table indicates register value saved 
compute trace compiler statically determine pointer status value 
additional information indicates type value resides 
type runtime computes value included root set 
gives example stack frame 
left portion diagram gives stack frame described corresponding trace table entry right 
correspondence established return address stack slot indexes trace table 
second table entry see frame slots 
second slot described third table entry non pointer third fourth slots pointers 
note fourth slot contains runtime type describe contents fifth slot 
case type record collector know fifth slot traced 
sixth slot contains spilled value register 
slot needs traced depends state register previous stack frame 
table entry contains trace information register set 
hardware benchmarks measurement methods evaluate effectiveness generational stack markers pretenuring compare techniques semispace collection generational collection generational collection stack markers generational collection stack markers pretenuring 
validity comparison strengthened fact technique tested identical conditions language compiler hardware benchmarks 
empirical results gathered dec alpha workstation features microprocessor 
chip split instruction data caches 
caches direct mapped sized cache lines key int ra trace info registers 
pointer pointer non pointer compute callee frame size slot slot slot slot slot compute stack slot entry entry entry entry entry entry entry example stack frame left corresponding table entry right bytes 
uses write policy entry write buffer performs write write misses 
model second level chip cache write allocate policy dec dec 
particular machine mb main memory runs osf 
sampled data taken runs eleven sml milner tofte harper programs de facto standard benchmarks appel compiled til 
table describes benchmark programs range size lines lines code 
cover range application areas including scientific computing list processing systems programming compilers 
larger benchmarks included current version til support sml module system 
table describes allocation behaviors benchmarks 
new frames stack column refers stack frames encountered collector collection 
tables show time performances benchmarks various collection techniques 
configurations explored data runs collected arithmetic mean reported 
cases standard error 
times reported seconds measured unix virtual timers 
total gc client denote total execution time program time spent garbage collections time spent mutator respectively 
course total gc client 
copied respectively denote number garbage collections amount data bytes copied collections 
different garbage collection techniques different amounts memory unconstrained direct comparison techniques control unfair 
reasonable way render comparison fair limit technique fixed amount memory 
copying collectors absolute minimum amount memory min needed run twice maximum amount live data program execution garbage collection may occur moment 
choose various multiples designated minimal value program compare performance various techniques collector permitted min memory 
initial results consider initial result obtained baseline collector techniques 
table shows time space performance benchmarks semispace collection values 
programs little longlived data time spent garbage collection inversely proportional time spent garbage collection approximately constant 
particular fft checksum experienced improvements gc times times increases 
note ideal linear improvement cause speedup programs long lived data benefit greatly large values collection relatively expensive programs 
particular grobner knuth bendix experienced improvements 
numbers accordance observation fft generate longlived data grobner knuth bendix 
minor fluctuations client time relatively consequently changes total times directly reflect changes gc times 
table shows performance benchmarks generational collection 
programs gc times improved factor increased 
notable exception knuth bendix time worsened 
case knuth bendix data survives nursery remains alive program 
major collections extra amount memory unused 
plausible time slightly worsens runtime system overhead managing memory client benefit 
hand note pia gc time improved dramatically 
fold decrease indicates interesting behavior 
total number garbage collections remains approximately varies number major garbage collections severely affected significant amount data copied major collection 
particular pia exhibits allocation behavior amenable generational collection pia data tends die rapidly 
multiple generations ameliorate problem data die collection 
cursory glance tables show gen total time sec gc time sec client time sec program color fft grobner knuth bendix lexgen life peg pia simple number gcs data copied bytes program color fft grobner knuth bendix lexgen life peg pia simple table time space usage semispace collector collection wins 
special cases semispace collectors better generational collectors 
programs allocate data intensively long lived data relatively expensive root processing 
cases cost gc constant gc cost solely dependent collection frequency 
programs fixed memory constraints size semispace larger nursery area generational collector 
gc frequency decreases semispace collector cost gc lower 
aside special cases see generational collection generally improves gc time dramatically 
generational collector improved cache effects allocation area remains permanently secondary cache long lived data grouped 
programs experience client time improvement 
fft benefit relative lack garbage collections program possibility cache interactions resulting data movement 
consider individually performance benchmarks generational collection find opportunities improvement 
fft spends time gc optimization worthwhile 
spends time garbage collection collection average takes milliseconds 
cost overhead associated calling garbage collector 
case cost gc nearly constant way reduce cost tuning collector code increasing nursery size 
high gc time peg artifact high mutation rate program 
quite apparent column table shows peg having orders magnitude updates benchmark 
simple sequential store list records mutated site repeatedly causing great overhead root processing 
realistic approach card marking sobalvarro probably ameliorate problems 
knuth bendix color lexgen characterized deep stacks analyzed section 
section explores heap profiling pretenuring applicability remaining benchmarks 
generational stack collection breaking gc cost knuth bendix color lexgen left column table 
programs cost generational garbage collection usually dominated cost scanning copying heap gc copy cost root processing gc stack stack typically smaller heap 
functional programs knuth bendix color lexgen highly non tail recursive deep stack 
programs see column table cost scanning stack high cost garbage collection 
stack allocation pattern programs typically involve having rapid alternation stack growth shrinkage 
example table indicates knuth bendix stack frames collector traverses average changed collection 
stack deep ancestral frames tend remain activated garbage collections 
take advantage part stack total time sec gc time sec client time sec program color fft grobner knuth bendix lexgen life peg pia simple number gcs data copied bytes avg frame program depth color fft grobner knuth bendix lexgen life peg pia simple table time space usage generational collector change 
save information previous garbage collection reuse parts information corresponding unchanged part stack 
generational collector objects nursery promoted need consider roots residing frames previous collections 
collector designed recognize stack roots minor collection advantageous amortized cost decoding stack frames storing decoded results register state root list 
maintaining information matter bookkeeping 
tricky part knowing stack changed collection 
certainly maintain special slot stack frame containing initially unset flag indicates scanned collector 
collection flag set collector knows frame changed 
increases stack frame size requires extra instructions stack frame 
frames die collection technique penalizes programs deep stack behavior require frequent garbage collections 
achieve performance deep stacks penalizing average program technique significantly affect mutator place bulk cost garbage collection 
achieved addition collector time scan stack change return address th stack frame parameter best chosen balance gains information reuse cost bookkeeping special stub function recording original return address table 
function returns marked frame transfers stub function notes particular frame deactivated continues original return address recorded table 
tests value 
works 
unfortunately functions return normally 
exception raised exception handlers invoked stack order matching handler 
matching handler may correspond frame arbitrarily far stack 
particular control may jump past marked frames normal return 
consequently action taken collector know intervening frames stale 
fortunately suffices maintain value updated raised exception contains stack pointer value occurred result raised exceptions 
garbage collector simply takes shallower value value table obtain deepest stack frame safe reuse 
alternative implementation dealing exceptions consistent stack allocated activation records moves bookkeeping cost raising exception collector having collector walk chain exception handlers collection determine handlers raised collection jumped past marked frame 
deferring handling exceptions collection advantageous programs frequently raise exceptions 
compilers run stack markers stack markers gc program gc stack copy stack gc stack copy stack decreased color fft grobner kb lexgen life peg pia simple table breakdown gc cost generational collection stack markers 
times measured seconds 
time system responsible unwinding stack raised exceptions remembering stack frames longer active simple 
possible implementation strategies chose entail modifying compiler 
modifications tend performance comparisons questionable 
results displayed rightmost column table 
gc times drastically reduced target programs relative decreases ranging 
completeness show result benchmarks 
worth noting stack markers poses slight cost programs averaging 
heap profiling pretenuring stated previously generational collection takes advantage widely varying lifetimes different heap allocated objects 
traditional policy promotes object survives collections 
policy disadvantage object may copied times placed right generation 
discovering runtime objects survive promotion try profile data predict survival rate copying 
clearly infeasible uniquely identify object require data objects recur different program runs 
speculate objects allocated point program tend similar lifetimes 
test hypothesis heap profiles gathered study average lifetimes objects created different program allocation sites 
obtain heap profiles compiler modified emitting allocation code allocation site identifier prepended allocated object 
garbage collection copied object allocation site identifier inspected entry corresponding site updated 
gather information object deaths scan allocation area lower 
measurability artifact debugging code timing code 
calling unix perform time measurements stack markers technique distorts times increase attributable 
removal code result small uniform improvement benchmarks 
collection locate dead objects update allocation site entries 
information allows profiler compute number size average age objects emanating allocation site 
profiled programs typically run slower unprofiled versions 
concreteness abbreviated outputs heap profile generated knuth bendix benchmarks included 
allocation sites contribute allocated copied objects included 
alloc shows relative amount data allocated site copied shows relative amount data allocated site eventually copied 
old indicates percentage data generated site survives minor collection 
complementary trends obvious 
knuth bendix allocated data generated sites survival rate significant digits 
conversely data copied allocated sites survival rate 
sites marked table 
polarity striking benchmark copied data generated sites 
profiles identify allocation sites consistently produce long lived objects objects 
objects sites directly allocated older generation 
beneficial liveness ratio younger generation decreased lowering amount objects copied collection speeding collection process 
tests objects allocated sites old cutoff 
considering data pretenuring policy relatively insensitive particular cutoff chosen 
unfortunately simply allocating data older area breaks invariant 
object directly allocated older generation may object younger generation 
course pointer mutations break invariant deal new intergenerational way 
write barrier approach correct slow zorn 
suggest relaxing condition objects promoted minor collection 
unfortunately particularly young generations survival collection indicates long lived ness 
allocating young generation immediately promoting lead substantially knuth bendix alloc alloc alloc avg copied copied copied size site size count old age size alloc size heap profile short showing entries alloc copy entries displayed 
old cutoff targeted sites comprise copied allocated 
alloc alloc alloc avg copied copied copied size site size count old age size alloc size heap profile short showing entries alloc copy entries displayed 
old cutoff targeted sites comprise copied allocated 
alloc size number bytes allocated site alloc percentage bytes allocated site alloc count number objects allocated site old percentage objects survive collection creation avg age average age objects die copied size number bytes allocated site copied collections copied percentage bytes allocated site copied collections heap profiler output knuth bendix total time sec gc time sec client time sec decrease program gc client total knuth bendix lexgen simple number gcs data copied bytes program knuth bendix lexgen simple table time space usage generational collector pretenuring color grobner kb lexgen life pia simple relative gc time technique generational stack markers pretenuring stack markers table relative gc time copying pretenuring 
remember area older generation directly allocated scan region collector collection 
win copying copying objects slower scanning hopefully young generation pointers 
profiles clear optimization useful benchmarks knuth bendix lexgen simple 
optimization selective heap profile results remaining programs suffer optimization 
table contains performance figures generational collector generational stack collection pretenuring 
code sequence allocating objects region somewhat longer normal allocation code sequence possibility client time increase result pretenuring 
hand may improved cache effects surviving objects single memory region 
quite effects small greatly change client time 
fact client decrease column table shows average slight decrease client time 
importantly addition pretenuring reduces gc times benchmarks respectively 
final column indicates relative decrease total execution time 
gc relatively small percentage total execution time amdahl law restricts magnitude decrease total execution time 
benchmarks average decrease total time 
reduction gc time due pretenuring large expect reductions amount data copied 
data accurately scan data check younger generation 
cost collection proportional amount live data smaller constant 
unfortunate data younger generation 
different approaches take reduce cost heap scan associated pretenuring 
data allocated older generation directly time group allocation sites 
permits scan specialized omitted altogether lead reduction instruction count memory traffic 
interesting harder improvement perform control flow dataflow analysis objects allocated targeted sites 
abstractly set target sites allocation site determine set sites object reaches allocated site 
classify target site need scan objects arising objects 
possibility additionally pretenuring objects objects site scanned 
danger large objects live 
indicate preliminary results extension section 
discussion extensions generational stack collection generational stack collection collectors issue root processing heap copying orthogonal 
placement policy stack markers just possible choices 
dynamic policy marker placement may achieve better performance fewer markers 
activation records heap allocated benefit generational stack collection depends relative cost bookkeeping interpreting activation records heap allocated 
cost scanning deep stack ask heap allocated activation record advantageous stack generational collectors heap allocated record provide automatic frames 
call depth high records copied point stack implementation copies frames 
compiler supports callee save registers state registers determined frame 
generational technique added mutator bear runtime cost maintaining mask register appel 
system til types passed runtime polymorphic code maintaining mask register entail greater cost 
pretenuring til compiler currently data flow analysis allocated objects effectiveness reducing scans objects tested manually analyzing allocation pattern benchmark 
data flow analysis reveals dependence allocation sites objects divided groups 
group shown contain objects point objects group contains objects may point objects allocated nursery 
removing scans objects group gc time reduced reducing gc time 
result promising automated system detecting sites needed optimization useful 
useful techniques may help problem region inference tofte talpin tofte talpin aiken fahndrich levien birkedal tofte dataflow analysis allen cocke kennedy control flow analysis shivers 
remaining objects may point nursery optimization possible 
data different allocation sites separate areas 
areas may require scanning contain pointers 
areas may permit specialized scans 
example area contains records decoding tag word needed 
collector directly examine fields known contain pointer 
general effectiveness pretenuring dependent policy generational collector 
systems objects nursery immediately promoted copied compacted back nursery 
counter bits object record number minor collections object survived 
threshold reached object promoted generation 
objects copied times promoted pretenuring systems yield greater benefit system studied 
versions generational collectors support generations 
obtain maximum benefit pretenuring consider average age target sites column tables determine generation object 
correct generation lead extra data copying lead unnecessarily ties memory sufficiently major collection 
related fateman franz lisp programs spend time garbage collection fateman 
combinations lisp systems benchmarks report gc times average 
ungar ungar showed effectiveness generational garbage collection reducing pause times improving performance 
shaw analyzed extensively programs running commercial common lisp system generation checks cost total execution time shaw 
zorn investigated gc cost large programs commercial common lisp system simulated gc times zorn 
barrett zorn barrett zorn lifetime predictors improve memory overhead locality context explicit memory management 
studied mechanism allows effective reclamation garbage process barrett zorn 
diwan tarditi tarditi diwan cost automatic storage management sml nj 
allocation root processing significant fraction total cost 
runciman runciman heap profiling study lifetime behavior data context haskell 
wilson wilson pointed importance keeping root scanning costs low incremental garbage collection techniques 
generally simple generational collector outperforms semispace collector factor terms generated monomorphic code garbage collection time accompanied significant gain client time improved cache locality 
special cases semispace collector outperform generational collector restricted memory usage total amount memory fits inside cache monotonically growing set long lived data long lived data dies quickly 
advantageous collector alternate strategies testing conditions dynamically 
deeply non tail recursive programs runtime implementation uses stack allocated activation records caching results stack scans previous collections speed collections 
observe relative decreases gc times generational stack collection 
profiling heap gather lifetime data objects allocated certain program points provide highly accurate data programs studied 
simple pretenuring policy reduce collection time increasing client times 
incremental concurrent collectors reduce pause times performing collections frequent disruptive 
synchronize root set 
garbage heap may gradually removed stack scan performed atomically 
setting caching results stack scans helpful reducing synchronization costs 
usefulness heap pretenuring rests largely predictability object lifetimes allocation sites 
barrett zorn observed predictability substantial programs barrett zorn 
speculate condition hold languages allocate heavily haskell lisp java 
directions go exploration generations generation resizing policies policy control flow analysis automatically eliminate pretenuring scans opportunistic garbage collection tag free collection write barrier techniques 
interesting direction reexamine gc ideas attitude aggressively profile data type information generate specialized hybrid garbage collectors 
bigger programs need analyzed avoid having unrealistic datapoints 
chris stone deserves general discussions garbage collection advice benchmarking usual thorough review 
greg morrisett provided useful discussions idea stack markers implement generational stack collection 
david tarditi lars birkedal ken cline david eckhardt deserve careful reviews draft 
aiken fahndrich levien 
better static memory management improving region analysis higher order languages 
technical report csd university california berkeley 
allen cocke 
program data flow analysis procedure 
communications acm pp 

appel 
february 
simple generational garbage collection fast allocation 
software practice experience pp 

appel 

compiling continuations 
cambridge massachusetts cambridge university press 
appel mattson tarditi 
lexical analyzer generator standard ml 
distributed standard ml new jersey 
barrett zorn 
lifetime predictors improve memory allocation performance 
acm programming languages design implementation pldi pp 

barrett zorn 
garbage collection dynamic threatening boundary 
acm sigplan pp 

harper lee 
signatures network protocol stack systems application standard ml 
lfp pp 

birkedal tofte 
region inference von neumann machines region representation inference 
proc 
principles programming languages popl 
cheney 

nonrecursive list compacting algorithm 
communication acm pp 

dec 
dec axp models system programmer manual 
maynard massachusetts digital equipment 
dec 
alpha axp microprocessors 
maynard massachusetts digital equipment 
arvind 
simple exercise scientific programming 
technical report computation structures group memo mit cambridge ma july 
simultaneously published ibm watson research center research report yorktown heights ny 
fateman 
august 
garbage collection overhead 
communication 
cited ungar design evaluation high performance smalltalk system ph thesis uc cse march 
fenichel 
lisp garbage collector virtual memory computer systems 
communications acm pp 

hornof 
may 
compiling prolog standard ml optimizations 
undergraduate honors thesis carnegie mellon university 
available technical report cmu cs september 
jones lins 
garbage collection algorithms automatic dynamic memory management 
new york ny john wiley sons 
kennedy 

survey data flow analysis techniques 
jones eds program flow analysis theory applications pp 

prentice hall 
knuth 

art computer programming vol 
fundamental algorithms 
reading massachusetts addison wesley 
mccarthy 

recursive symbolic expressions computation machine 
communications acm pp 

milner tofte harper 
definition standard ml 
cambridge massachusetts mit press 


elements functional programming 
reading massachusetts addison wesley 
runciman 
lag drag void heap profiling space efficient compilation revisited 
acm sigplan international conference functional programming pp 

shaw 
february 
empirical analysis lisp system 
ph 
thesis stanford university 
shivers 
may 
control flow analysis higher order languages 
ph 
thesis carnegie mellon university 
sobalvarro 
february 
lifetime garbage collector lisp systems general purpose computers 
master thesis mit 
tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
acm programming languages design implementation pldi pp 

tarditi diwan 
measuring cost storage management 
technical report cmu cs carnegie mellon university 
tofte 
talpin july 
theory stack allocation polymorphically typed languages 
technical report computer science university copenhagen 
tofte 
talpin 
implementation typed call value calculus stack regions 
proc 
principles programming languages popl 
ungar 

generation scavenging high performance storage reclamation algorithm 
acm sigsoft sigplan pp 

waugh michaelson august 
parallel implementations function prototypes case study 
technical report computer science heriot watt university edinburgh 
wilson 

uniprocessor garbage collection techniques 
technical report university texas 
expanded version appear acm computing surveys 
yan 

grobner basis computation 
personal communications 
zorn 
december 
comparative performance evaluation garbage collection algorithms 
ph 
thesis university california berkeley 
