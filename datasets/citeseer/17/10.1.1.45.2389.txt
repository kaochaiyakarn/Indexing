order theory refinement stefan wrobel gmd fit ki birlinghoven sankt augustin germany stefan wrobel gmd de advances ilp de raedt editor ios press amsterdam appear 
ios frontier ai applications series 

summarizes current state art topics order theory revision theory restructuring 
various tasks involved order theory refinement revision vs restructuring defined discussed turn 
theory revision issue minimality discussed detail general outline algorithm identifies major places difference different algorithms 
describes various options explored different researchers 
theory restructuring approaches developed ilp project discussed devoted understandability devoted efficiency 
order methods inductive learning witnessed considerable interest years field inductive logic programming ilp developed rapidly 
original ilp learning task deals learning order clausal theories scratch examples background knowledge field focusing increasingly task theory refinement existing order theory departure point revising match set examples restructuring meet external criteria understandability efficiency 
goal document summarize current state art topics order theory revision theory restructuring 
final deliverable esprit basic research project inductive logic programming surveys state art worldwide special emphasis contributions ilp project partners lifetime project 
large number systems propositional knowledge base maintenance developed expert systems field see overview 
concentrating systems theory refined order nature usually consisting firstorder clauses 
organized follows 
detailed description various tasks involved theory refinement discuss broad subtasks revision restructuring turn 
theory revision give general outline algorithm clearly identifies major places difference different algorithms 
discuss describing various options explored different researchers 
theory restructuring discuss approaches developed ilp project devoted understandability devoted efficiency 
theory refinement terminology tasks theory revision restructuring subtasks general problem known theory refinement problem improving quality theory number different dimensions 
regard theory knowledge base expert system seen general knowledge base maintenance problem 
revision restructuring correspond fundamental dimensions quality theory improved 
task revision involves changing answer set theory improving inferential capabilities adding previously missing answers removing incorrect answers 
speak generalizing revisions second case specializing revisions 
task restructuring hand change answer set theory focuses improving answer derived 
distinguish broad groups oriented improving performance oriented improving user understandability theory 
shows overview taxonomy refinement tasks abbreviations bottom denote refinement operators explained rest document 
refinement revision changes answer set restructuring keeps answer set generalizing completing revisions specializing correcting revisions structure improving performance improving ebl pe lgg ir 
cb mbr cws ir red rem 
incorrect incomplete slow hard understand incorrect incomplete hard slow taxonomy theory refinement tasks key feature order theory refinement theories worked order normally contain clauses involving predicate 
theory revision restructuring system capable modifying individual clauses single predicates know deal problems arise learning multiple predicates simultaneously 
modifying predicate definition usually affects correctness predicates definitions revising done considering 
order theory refinement particular revision closely related general problem multiple predicate learning learning theories involving multiple predicates scratch examples background knowledge including multiple predicate learning systems survey revision systems accept initial theories start 
theory revision concentrate task theory revision refinements change answer set theory 
contrast standard ilp learning examples problem ilp prediction learning problem examples background knowledge theory revision problem start initial theory modify 
assuming background knowledge included theory system may modified problem definition formally define theory revision problem follows 
definition theory revision problem hypothesis theory language lh example language le entailment relationship called theory revision problem tr lh ffl initial theory gamma hypothesis theory language lh ffl sets positive negative examples gamma example language le find ffl revised theory gamma ffl derives positive examples completeness gamma ffl negative examples consistency gamma gamma gamma gamma ffl meets additional quality criteria minimality particular instance tr lh problem characterized gamma gamma written tr lh gamma gamma 
theory revision systems outside ilp project order definite horn clause theories theory language lh ground atoms facts example language le rest document usually implicitly assume languages standard choices simply write tr gamma gamma denote theory revision problem 
entailment relationship usually suitable decidable approximation full logical entailment realized depth bounded inference engine theorem prover 
revision learning examples task closely related background knowledge learning examples task input theory revision task revision system produce solution learning examples problem 
learning examples system non incremental expect see examples theory revision systems incremental learning accept new examples step step update theory example received 
general task definition allowing sets positive negative examples missing incorrect inferences means single example small set examples incorporated existing theory 
systems revisions certain parts theory prevented user leave background knowledge untouched 
important point close relation theory revision systems multiple predicate learning examples systems 
nature theories revised poses particular problems occur learning single predicates 
predicates definitions insufficient done single predicate learning systems ground atomic background knowledge extensionally check coverage clauses single clause subsumption mapping clause literals example background knowledge literals 
learned clauses predicate need applied learning predicates necessary inference engine resolution theorem prover usually depth bounded check coverage intensionally proof process 
words contrast single predicate learning systems theory revision multiple predicate learning systems single clause subsumption subsumption instantiate 
important difference theory revision learning examples lies additional criteria minimality imposed revised theory see 
generalized problem definition just ilp prediction learning problem reformulated allowing general clauses examples ilp project shown theory revision task extended similar way allow general integrity constraints positive negative examples 
integrity constraint general clause express positive negative examples complex constraints 
general setting need distinguish positive negative examples generalized revision task defined follows 
definition generalized theory revision problem hypothesis theory language lh constraint language lc entailment relationship called generalized theory revision problem tr lh ffl initial theory gamma hypothesis theory language lh ffl set integrity constraints lc find ffl revised theory gamma ffl satisfies constraints 
gamma gamma 
ffl meets additional quality criteria minimality particular instance tr lh problem characterized gamma written tr lh gamma standard problem lh lc usually clausal languages 
languages clear context simply write tr gamma denote generalized theory revision problem 
minimality theory revision important difference learning examples systems theory revision systems additional conditions required revised theory 
theory revision system additional criteria revision result evaluated terms accuracy completeness consistency 
systems initial theory background knowledge help reach desired accuracy better faster 
systems typically assume examples outset non incremental 
theory revision systems incorporate maintenance aspect require resulting theory minimal revision existing theory usually reasons user understandability revision result 
years progress understanding minimality revisions mean turning revision algorithms useful review results 
order maximally exploit structure knowledge contained initial theory reasonable require theory revision system minimally modify theory fit examples 
interactive minimal modifications help user easily understand revision result 
revision systems system operator dependent syntactic criteria define minimality research question ilp project shown intensional extensional minimality criteria offer precise algorithm independent definition minimality 
syntactic minimality criteria principle possible define operator independent syntactic distance measures theories practice date theory revision systems relied operator syntactic minimality criteria 
fewer applications system operators needed transform theory smaller change deemed 
minimal revision minimizes operator applications 
ilp project ruth system syntactic minimality criterion minimal number transactions 
outside project forte similar criteria 
successful minimizing system effort measures depend strongly available revision operators operators perform larger scale changes resulting theory may original theory syntactical level 
intensional minimality criteria research ilp project concentrated developing operator independent definitions minimal revision concentrating specializing revisions 
particular project examined notion minimal specialization carried individual clauses entire theories 
purpose defined notion maximally general correct specialization defined specialization original theory generalized incorrect specialization usual defined terms logical entailment special theory entailed general theory 
advantage definition totally independent syntactical form theory guarantees minimal loss inferential power intensional level known positive negative examples unknown examples 
research ilp project showed definition intensional minimality undesirable properties 
representation 
computing minimal specialization requires working inferential closure theory general case guarantee revision result finite axiomatization 
loss reason maintenance 
operation closure theory take account statements derived lose reason maintenance 

statement retracted replaced negation minimal specialization revision lead complete theory assigns statement truth value statements tr gamma tr gamma assuming gammaj full clausal language 
avoid problems definition minimality called minimal base revision proposed calls intensionally minimal revision allows specialization respect individual statements original theory 
specializations allowed definitions theories consist statements original theory specializations single statements original theory 
definition avoids problems ensures specializations locally respect individual statements facilitating understanding revised theory interactive 
definition need available operators syntactic form statements 
ilp project cws mbr operators perform minimal base revision albeit different selection heuristics see 
generalizing revisions corresponding notions examined detail 
cases hypothesis language includes example language maximally specific complete generalization trivially achieved adding examples initial theory 
individual clauses minimal generalization defined corresponding operators exist entire theories considered sense define notion minimal generalizing revisions 
correspondingly revision systems generalization heuristics bottomup learning examples system control generalization extensionally check negative examples avoid overgeneralization 
extensional minimality intensional minimality tries guarantee minimal loss inferential power respect current examples extensionally minimality specializing revisions weakens requirement requiring minimal loss inferences respect set current positive examples allowing revision system remove parts initial theory known examples 
guarantee intensional minimality example set representative extensional minimality requirement appears especially suitable nonincremental revision systems 
ilp project system example system guarantees extensionally minimal specializing revisions 
general revision algorithm having completed task definition theory revision discussion optional minimality requirements turn various methods proposed solve task 
list different algorithms discussion organized different choices algorithm developer address 
hopefully clearly identify issues various systems differ way 
introduce issues consider general theory revision algorithm shown table 
tr gamma gamma 
fe gamma fe gamma gammaj 
termination criterion search strategy ffl select subset subset search strategy chosen select generalization operator gen gen gamma gamma chosen select specialization operator spec spec gamma ffl select alternative results operator search strategy update gamma select gamma ffl fe gamma fe gamma gammaj 
return gamma table general theory revision algorithm algorithm table shows general control structure current ilp theory revision systems 
theory positive examples negative examples revision system repeatedly determines examples missing incorrect inferences step third step respectively 
incomplete incorrect examples selected system revision operators called fix problem 
missing positive example generalization operator missing negative example specialization operator 
kinds operators passed theory example handled 
generalization specialization operator entire set negative positive examples potentially check overgeneralization 
operator applied different ways returning alternative revision results additional criteria applied select alternatives produce revised theory 
revised theory selected system check positive negative examples chosen generalization specialization operator addition positive negative example called may cause negative positive examples handled incorrectly correct 
revision process continues examples handled correctly improvement possible 
generalized revision problem table shows general algorithm corresponds roughly approach chosen ruth system 
algorithm generalized revision problem includes additional step task choosing fix violated constraint removing premise literal instance adding literal instance theory 
additions tr gamma 
fc gamma violates cg 
gamma improves ffl select subset search strategy ffl select premise literal instance removed add literal instance added add search strategy ffl gamma tr gamma ffl fc gamma violates cg 
return gamma table algorithm generalized revision problem deletions taken positive negative examples handled revision operators example revision algorithm 
get algorithm schemata working theory revision systems number design issues addressed identified algorithms underlined words 
ffl set operators system equipped ffl selection strategies choosing operators choosing apply operators results 
ffl global search strategy system examples constraints treat sections discuss issues turn identifying different options different systems explored 
reader interested getting description particular system refer appendix short descriptions systems ilp project included 
revision operators positive negative example selected theory revision system uses generalization specialization operators produce revised theory 
section give brief overview kinds operators theory revision systems date 
principle specialization generalization operator algorithm developed order machine learning theory revision system emphasize list intended complete just indicative operators turned useful order theory revision systems date 
note learning normal programs clauses include failure literals semantics generalization specialization operators reverses 
order specialize generalize clause predicate failure literal generalize specialize clauses defining done mis clint ilp project 
specialization operators minimal specialization theories number operators developed ilp project ensure intensionally minimal revision minimal base revision paradigm extensionally minimal revision 
mbr 
mbr operator employs special exception set notation minimally specialize clauses 
usually choices clauses specialize operator produces set possible minimal base revisions 
ilp project mbr operator specializing revision system part 
closed world specialization ilp project investigated closed world specialization cws operator uses non monotonically interpreted exception predicates exception lists stays standard language logic programming 
representation allows immediate generalization exception predicates exception list representation requires explicit additional step turning list predicate 
clause level mbr cws syntactic variants choice depends external criteria 
theory level implemented version cws uses different selection strategy preferring top level resolving clauses easily selection strategy see 
ilp project cws operator cws revision systems 
unfolding 
final minimal operator examined ilp project unfolding guarantees extensional minimality works entirely horn clause representation 
idea operator unfolding operator known partial evaluation separate proof paths positive negative examples delete proof paths negative examples entirely 
contrast mbr cws unfolding operator extensionally minimal guarantees minimal loss coverage known examples respect unknown examples 
unfolding operator extended able deal recursive predicate definitions 
ilp project systems ii jigsaw unfolding operator 
note unfolding operator seen successor goal reduction operator learning systems specializes clause resolving literals body clause containing literal 
unfolding applies operator clauses 
operators covering vs divide conquer strategies empirically compared 
specialization operators non minimal minimal operators try preserve possible original theory intensionally minimal base revision extensionally known examples non minimal specialization operators specialize strongly necessitated negative example handled 
done order achieve simpler form revised theory needing exception lists predicates simplify revision operation 
able recover systems employ non minimal specialization operators generalization operators re add general versions overly special statements 
distinguish kinds non minimal specialization operators deletion antecedent addition existing predicates antecedent addition predicate invention 
deletion 
operator entirely removes statement deemed incorrect 
revision system relies generalization operators recreate special version deleted statement necessary 
ilp project deletion operator systems clint mpl ruth 
tracy system backtracks hypothesis space sense uses clause deletion 
outside ilp project forte included deletion operator 
antecedent addition existing predicates 
second non minimal specialization operator addition new premise employing existing predicate incorrect clause exclude negative examples 
depending definition predicate may may minimal revision 
usually current definition additional predicate check excludes negative examples leaving positive example derivations untouched 
ilp project system antecedent addition operator 
outside project forte system antecedent addition operators adding single antecedents adding chains antecedent literals relational pathfinding 
antecedent addition predicate invention 
third group non minimal specialization operators specializes known instances exceptions clause basis defining new predicate additional premise 
important idea new predicate allows generalization occur instances exceptions potentially leading better results achievable explicit exception lists 
ilp project antecedent addition predicate invention examined number systems 
predicate invention operators projects clause applications single variables introduces unary predicates second operator projects pairs variables introduce binary new predicates 
cws hand variables clause introduce new predicate 
outside ilp project dbc method proposed greedy strategy find appropriate set arguments new predicate 
ilp project task selecting arguments new predicate formalized general fashion looking task minimization problem 
generalizing revisions constrast specializing revisions existing clause modified generalizing revision need necessarily modify existing clause add completely new clauses 
order cover uncovered positive examples generalizing revisions basically ilp learning algorithm accepts positive examples input addition generalization operators proper generalize set clause 
consequently large number different generalization operators revision systems ranging simple addition complex inductive procedures 
addition 
simplest way cover uncovered example add example current theory add specific element hypothesis space covers example example language part theory language 
memorization approach completely lacks inductive power generalization course revision systems backup case operators fail 
ilp project ruth system addition operator fallback generalization 
outside project system addition operator adding specific starting clause example selected background knowledge premises 
step followed application minimal generalization operator see 
abduction 
contrast addition missing example added directly abduction operator looks clause able prove example premises verified current theory 
operator adds missing premises theory 
mis clint ilp project operator ruth system 
furthermore generalized framework abductive inductive logic programming 
outside ilp project system abduction operator followed starting clause construction application minimal generalization operator see 
single clause generalization antecedent deletion 
simple generalization operation failed antecedents deleted clauses useful prove positive examples 
operator outside ilp project forte system deleting single antecedents greedy heuristic strategy delete multiple antecedents optionally keeping original generalized rule 
clint similar operators 
multiple clause bottom generalization rlgg msg ir contrast antecedent deletion generalizes single clause clauses systems rely generalization operators bottom learning find minimal near minimal generalization clauses 
means starting clauses constructed uncovered examples starting clauses generalized existing clauses theory predicate 
ilp project approach taken system uses rlgg generalization operator similar golem 
outside ilp project system bottom approach minimal generalization operator msg style 
forte system identification absorption inverse resolution ir operators generalize multiple clauses operators necessarily applied example clauses general theory clauses places example proofs failed 
top search complementary approach top induction new clauses investigated number system ilp project 
top search employs refinement operator clause returns set specializations clause 
refinement operator specialization operator exclude negative examples 
systems top search generalization search started general clause specializes clause longer covers negative examples 
ilp project approach ruth system modified mis body refinement operator starting xn 
mpl system top approach head body refinement operator starting empty clause 
operators determines predicate search clause normally top search decide predicate learn specializing 
delaying decision helps avoid search problems 
claudien system operator extended able generate general clauses declarative bias language enumerative generation top bottom search clauses fixed search direction usually controlled heuristic criteria see ilp project investigated enumerative full search approach finding new clauses 
tracy system new clauses added current theory drawing fixed enumeration clauses theory hypothesis space simply backtracking clause incorrect 
backtracking entire space searched needed operator guaranteed ultimately find complete correct theory exists hypothesis space 
hand operator applied small hypothesis spaces restricted strong declarative bias 
controlling application revision operators having described array operators current revision systems turn second aspect systems unique decides practical success strategies selecting revise selecting operators apply circumstances selecting example treat point time selecting hypothesis hypotheses keep pursue point 
selecting revision points results multi clause multi predicate theory clauses usually involved incorrectly proving negative example clauses generalized failed proof positive example go 
quality revisions produced depends crucially clauses chosen revision point consequently large number different control strategies examined ilp project 
certain systems random choices certain places strategies fixed selection heuristic measures declarative bias interactive queries 
described measures applied operator application operator application decide results keep 
fixed selection 
fixed selection strategies treat clause selection problem limiting set choices consider priori fixed bias search strategy algorithm 
ilp project example approach cws systems specialization phase biased revising top resolvent clauses incorrect proof followed compression selection revised clauses keep see 
approach followed tracy system avoids clause selection problem backtracking strategy retracting clause added 
similarly generalization tracy adds clause fixed hypothesis space enumeration 
heuristic selection approximating accuracy 
approach chosen current revision system select revision points especially systems accuracy revised theory foremost concern 
consequently heuristics designed way measure expected improvement accuracy potential revision 
certain systems ad hoc approximate measures purpose 
system measures control application non minimal specializations operator essentially comparing number explicit exceptions left different possible results 
outside ilp project forte system considers clauses participating incorrect proofs possible revision points prefers revise participate derivation largest number negative examples 
similarly generalizing revisions premise fails proof premise premises left revision points forte prefers revision point participated largest number failed proofs 
revision performed forte increases accuracy 
strategy followed 
heuristic selection approximating simplicity alternative accuracy interactive systems interested simplicity theory 
ilp project example simple structural measure criteria decide accept result predicate invention specialization operator 
specialization accepted certain number sufficient necessary conditions rules induced invented predicate 
heuristic selection statistical criteria approximating accuracy criteria statistical measures purity entropy 
ilp project mpl system statistical heuristic laplace estimate control top search generalizing revisions 
heuristic computes weighted sum accuracy hypothesis respect examples predicate local accuracy respect examples global accuracy 
systems ii popular statistical criterion decision tree learners id maximal information gain minimal residual impurity select literal application unfolding specialization operator comparing possible unfoldings clause starting top clauses resolved negative examples 
outside ilp project forte system information gain criterion similar foil control specialization operators 
heuristic selection compression criteria statistical criteria try estimate accuracy resulting theory compression criteria principles put forth algorithmic complexity theory expressed minimum description length principle 
roughly speaking complexity object theory case measured length shortest program executed fixed reasonable computation mechanism turing machine outputs original object theory 
compression exploit regularity data compressed compressible theory better captures regularities data 
true complexity theory estimated compression heuristics differ way compute estimate 
usually encoding theory examples bitstrings chosen length example encoding compared encoding examples theory 
ilp project compression measure theory revision system 
generalizes positive examples corrects generalized clauses cover negative examples cws operator generalizing exception predicates 
compression decide keep generalized exception clauses explicit exception facts 
system contrast decision generalize exception lists produced mbr operator user declared criterion structural evaluation resulting exception generalization 
declarative bias constrast heuristic measure function knowledge particular domain application certain systems examined possibility letting user specify additional knowledge revision selection preferences declarative bias 
ilp project system called tiered confidence model purpose selecting clauses modify 
user specify general classes statements tier class continuous degrees confidence statement identified ration positive negative examples covered clause 
system selects modify clauses lowest confidence class minimal degree confidence 
miles confidence model extended third tier allows heuristic measures confidence number positive examples unprovable clause modified user interaction 
uses declarative bias control decision apply non minimal specialization operators 
interactive selection 
final class approaches selecting revisions user interaction various forms 
simple form revision point result selected simply asking user 
offered option system user select possible minimal base revisions computed heuristically ordered system revision module miles 
system includes procedures fixing violations integrity constraints generalized theory revision task 
procedures simply ask user premise instances delete instances add deletion may turn give rise theory revision 
important class interactive selection methods specializing revisions contradiction backtracing cb approach mis clint 
approach finds fault clause derivation querying user individual subgoals proof tree 
clever divide conquer strategy method identifies faulty subgoal provably minimal number queries 
ilp project cb approach extended improved reduce amount queries 
contradiction backtracing combined techniques software engineering known program slicing category partition testing 
method select clause revised unfolding operator 
global search strategies previous section discussed search controlled operator level just briefly mention global search selection different hypotheses carried different systems 
principle theory revision classical state space search problem input theory start state operators applied 
consequently classical search strategies developed kind problem applied 
practice theory revision systems hill climbing strategy iteration top level loop general revision algorithm select hypothesis continue 
systems differ way process examples 
positive negative examples system choose treat generalize positive examples specialize vice versa 
revision systems perform specialization miles usually negative examples time 
certain systems ruth heuristics select incorrectly handled treat point 
examples search strategies ruth uses iterative deepening control strategy tracy uses exhaustive depth search exploration 
theory restructuring evidenced preceding pages order theory revision intensively studied problem 
contrast theory restructuring subproblem theory refinement studied intensively order theories 
subtasks looked restructuring performance restructuring understandability restructuring maintenance 
restructuring performance theory restructuring performed goal performance improvement guaranteeing faster response time inference system maintaining answer set 
problem studied ilp project outside project number researchers explanation learning ebl techniques purpose 
explanation learning closely related partial evaluation pe programs uses unfolding operation mentioned specialization technique 
unfolding specialization goal remove clauses result unfolding achieving specialization explanation learning clauses result unfolding typically augment current theory 
contrast partial evaluation proof known positive example decide unfold user defined criteria decide far proof tree unfold 
ebl adds additional clauses theory care taken ensure matching overhead caused clauses larger performance gain obtained clause utility problem 
restructuring understandability goal restructuring performance improvement defined precisely goal restructuring understandability difficult define formally 
focus research problem ilp project examine possible definitions understandability 
defining understandability results studies psycholinguistics text comprehension word sentence recall examined assumption relationship difficulty understanding text difficulty understanding order logical theory 
lend support certain basic intuitions structured understandable theories essentially requiring theories sufficiently intermediate concepts ensure theory flat rules get long numerous variables clause 
intuitions give rise set formally defined criteria measuring quality theory semantic criteria measure quality theory respect known examples syntactic criteria measure quality respect structure theory 
point empirical studies human subjects performed see formally defined criteria match subjective understandability ratings 
restructuring predicate invention earliest system ml developed explicitly purpose interactive restructuring theory duce albeit propositional logic representation 
duce introduced fundamental set inverse resolution operators introduce new predicates theory 
little operators transferred order domain cigol focus accuracy express goal support restructuring 
ilp project concentrated control inverse resolution operators explicitly purpose producing understandable theories 
system process stratification performed structuring theory layers may overlap additional invented predicates 
purpose operator finding common partial premises defined inverse resolution operators augments control heuristics specifically adapted goal understandability 
case study heuristics successful improving understandability defined criteria derived psycholinguistics 
restructuring maintenance related notion maintenance manually modifying theories 
maintenance special interest database community integrity constraints define database schemata avoid redundancies easier understand maintain 
ilp project approaches supporting database re design process investigated 
index system induces database dependencies functional multivalued dependencies top search process similar mis allowing exceptions able reject dependencies support data 
second stage induced dependencies decompose relations predicates database theory elementary relations 
horizontal decompositions splitting argument tuple done automatically vertical decompositions splitting tuple set performed interactively control user 
addition index directly supports restructuring process different systems developed ilp project discover integrity constraints indirectly support process restructuring 
system claudien capable inducing integrity constraints form general firstorder clauses 
search process refinement operator refines head body literals search 
search space defined declarative bias language heuristically searched iterative deepening fashion 
claudien successfully discovered integrity constraints test applications 
index claudien alternative non monotonic semantics ilp result ilp project 
semantics individual clauses learned independently parallelize claudien 
similarly icdt system searching space general order clauses albeit restricted declarative bias language simpler search strategy 
system includes novel confirmation criterion evaluate degree confirmation clauses measuring degree applicability clause 
systems capable discovering data dependencies large databases particular value restrictions unary inclusion dependencies functional dependencies 
unique feature algorithms systems assume data examined core 
assumed data accessed standard set oriented relational database management system interface sql queries 
support algorithms optimized pose minimal number queries database search 
large problems treated core approaches potential greater scalability compared approaches discussed section 
final deliverable esprit basic research project ilp inductive logic programming preparation partially funded project 
author wishes partners support comments remaining errors omissions 
ade de raedt bruynooghe 
theory revision 
muggleton editor proceedings rd international workshop inductive logic programming pages 
ad henrik bostrom 
jigsaw puzzling ruth extended 
nada lavrac stefan wrobel editors machine learning ecml proc 
european conf 
machine learning lecture notes artificial intelligence pages berlin new york 
springer verlag 
ad marc denecker 
abductive inductive logic programming 
proc 
th international joint conference artificial intelligence san mateo ca 
morgan kaufman 
ad bart luc de raedt 
ruth ilp theory revision system 
proc 
th int 
symposium methodologies intelligent systems ismis berlin new york 
springer verlag 
zoltan henrik bostrom 
integrating algorithmic debugging unfolding transformation interactive learner 
advances ilp proc 
th int 
workshop ilp amsterdam 
ios press 
appear 
michael bain stephen muggleton 
non monotonic learning 
stephen muggleton editor inductive logic programming 
academic press london new york 
michael bain stephen muggleton 
learning optimal chess strategies 
furukawa michie muggleton editors machine intelligence chapter pages 
oxford university press oxford 
siegfried bell 
discovery maintenance functional dependencies independencies 
proc 
kdd 
siegfried bell peter 
discovery constraints data dependencies databases extended 
nada lavrac stefan wrobel editors machine learning ecml proc 
european conf 
machine learning lecture notes artificial intelligence pages berlin heidelberg new york 
springer verlag 
francesco bergadano daniele 
learning clauses tracing derivations 
stefan wrobel editor proc 
fourth int 
workshop inductive logic programming ilp pages birlinghoven sankt augustin germany 
gmd german natl 
research center computer science 
gmd studien nr 

henrik bostrom 
covering vs divide conquer top induction logic programs 
proc 
th international joint conference artificial intelligence 
henrik bostrom 
specialization recursive predicates 
nada lavrac stefan wrobel editors machine learning ecml proc 
european conf 
machine learning lecture notes artificial intelligence pages berlin heidelberg new york 
springer verlag 
henrik bostrom peter almquist 
specialization logic programs pruning sld trees 
stefan wrobel editor proc 
fourth int 
workshop inductive logic programming ilp pages gmd german natl 
research center computer science birlinghoven sankt augustin germany 
gmd studien nr 

bench capon 
maintenance knowledge systems theory techniques tools 
academic press london 
de raedt dzeroski 
order jk clausal theories pac learnable 
artificial intelligence 
dehaspe de raedt 
parallel inductive logic programming 
kodratoff taylor editors proceedings workshop statistics machine learning knowledge discovery databases 
luc maurice bruynooghe 
interactive concept learning constructive induction analogy 
machine learning 
dzeroski 
numerical constraints learnability inductive logic programming 
phd thesis faculty electrical engineering computer science university ljubljana ljubljana slovenia 
roman 
inducing integrity constraints knowledge bases 
ki proc 

deutsche fur kunstliche intelligenz berlin new york heidelberg 
springer verlag 
peter flach 
predicate invention inductive data engineering 
brazdil editor proc 
sixth european conference machine learning ecml pages berlin new york 
springer verlag 
peter flach 
model inductive reasoning 
editors knowledge representation reasoning uncertainty lecture notes artificial intelligence pages 
springer verlag berlin new york 
peter flach 
conjectures inquiry concerning logic induction 
institute language technology artificial intelligence tilburg netherlands 
ph thesis 

discrimination constructive induction logic programs 
aaai proc 
tenth natl 
conference artif 
intelligence pages 
aaai press mit press menlo park cambridge london 
ming li paul vitanyi 
kolmogorov complexity applications 
springer verlag berlin new york 
morik stefan wrobel 
kietz werner emde 
knowledge acquisition machine learning theory methods applications 
academic press london new york 
muggleton 
inductive logic programming 
new generation computing 
stephan muggleton cao feng 
efficient induction logic programs 
muggleton editor inductive logic programming 
academic press 
stephen muggleton 
structuring knowledge asking questions 
ivan bratko nada lavrac editors progress machine learning proc 
second european working session learning ewsl pages uk 
sigma press 
stephen muggleton wray buntine 
machine invention order predicates inverting resolution 
proc 
fifth intern 
conf 
machine learning san mateo ca 
morgan kaufman 
tam ath 
effective algorithmic debugging inductive logic programming 
stefan wrobel editor proc 
fourth international workshop inductive logic programming sankt augustin germany 
gmd technical report 
available ftp gmd de 
gordon plotkin 
note inductive generalization 
meltzer michie editors machine intelligence chapter pages 
edinburgh univ press edinburgh 
ross quinlan 
learning efficient classification procedures application chess games 
michalski carbonell mitchell editors machine learning artificial intelligence approach pages 
tioga palo alto ca 
quinlan 
learning logical definitions relations 
machine learning 
de raedt 
interactive theory revision inductive logic programming approach 
academic press london new york 
de raedt bruynooghe 
theory clausal discovery 
proceedings th international joint conference artificial intelligence 
morgan kaufmann 
de raedt lavrac dzeroski 
multiple predicate learning 
proceedings th international joint conference artificial intelligence 
morgan kaufmann 
bradley richards raymond mooney 
automated refinement order domain theories 
machine learning 
rissanen 
modeling shortest data description 
automatica 
rissanen 
universal prior integers estimation minimum description length 
annals statistics 
peter flach 
bottom induction functional dependencies relations 
piatetsky shapiro editor aaai workshop knowledge discovery databases pages 
ehud shapiro 
algorithmic program debugging 
acm distinguished doctoral dissertations 
mit press cambridge mass 
edgar sommer 
approach quantifying quality induced theories 
claire nedellec editor proc 
ijcai workshop machine learning comprehensibility 
edgar sommer 
approach theory restructuring extended 
nada lavrac stefan wrobel editors machine learning ecml berlin 
springer verlag 
full version available author 
email sommer gmd de 
edgar sommer 
induction evaluation restructuring data analysis machine learning loop 
george editor proc 
conference intelligent data analysis ida 
ashwin srinivasan stephen muggleton michael bain 
justification logical theories data compression 
furukawa michie muggleton editors machine intelligence chapter pages 
oxford university press oxford 
stahl weber 
arguments newly invented predicates ilp 
stefan wrobel editor proc 
fourth int 
workshop inductive logic programming ilp pages birlinghoven sankt augustin germany 
gmd german natl 
research center computer science 
order gmd de 
wim van laer luc dehaspe luc de raedt 
applications logical discovery engine 
proceedings aaai workshop knowledge discovery databases 
steven vere 
induction concepts predicate calculus 
proc 
th international joint conference artificial intelligence pages 
steven vere 
induction relational productions presence background information 
proc 
th international joint conference artificial intelligence pages 
weber 
tiered confidence model revising logical theories 
stefan wrobel editor proc 
fourth int 
workshop inductive logic programming ilp pages birlinghoven sankt augustin germany 
gmd german natl 
research center computer science 
order gmd de 
james 
revising relational domain theories 
proc 
eighth intern 
workshop machine learning pages san mateo ca 
morgan kaufman 
stefan wrobel 
automatic representation adjustment observational discovery system 
sleeman editor proc 
rd europ 
working session learning pages london 
pitman 
stefan wrobel 
demand driven concept formation 
morik editor knowledge representation organization machine learning pages 
springer verlag berlin new york 
stefan wrobel 
proper definition minimality specialization theory revision 
proc 
sixth european conference machine learning ecml pages 
der gmd 
stefan wrobel 
concept formation knowledge revision 
kluwer academic publishers dordrecht netherlands 
stefan wrobel 
concept formation interactive theory revision 
machine learning 
