imperial college science technology medicine university london department computing 
component interaction distributed systems nathaniel 
thesis submitted partial fulfilment requirements degree doctor philosophy faculty engineering university london diploma imperial college science technology medicine january component development seen way increase programmer productivity reduce software maintenance costs reuse shelf software components 
component development distin object orientation systems defined composition black box components interact defined protocols 
current component models define interaction protocols components object interfaces 
approach limited interface describe bundles synchronous request reply operations specify protocol operations invoked mul tiple interfaces concert 
simplest component models define interaction protocols involve multiple parties communication concurrency communicating parties 
introduce model component interaction addresses limitations object invocation 
interaction model basis language midas define interaction protocols components 
midas definitions annotated formal specifications properties protocol 
show notation define interaction protocol allows mechanically check behaviour interaction protocol different transports catching errors design stage 
models translated test code 
midas definitions compiled runtime support code transport framework 
framework hides platform specific transport api defines transport protocols compositions lightweight com ponents 
transport protocol allows designer select appropriate protocol binding insert additional functionality compression encryption existing protocols 
tests show effect latency throughput binding compared traditional implementation 
members distributed software engineering group advice support 
particular dulay supervisor morris sloman jeff kramer jeff magee ex members group steve crane kevin hal stimulating discussions 
research thesis funded british telecom management networks project 
ian marshall paul mckee rana british telecom laboratories valuable feedback midas regent run time frameworks 
thesis built research performed years distributed software engineering group especially darwin regis system project 
regis system originally developed jeff magee stephen crane kevin 
second version regis system developed stephen crane author 
runtime system thesis regent differs regis ways regis specify component interaction protocols separately implementation 
regis interaction protocols defined solely implementation endpoint classes 
regis separate concerns application presentation layer protocols endpoint classes responsible marshalling messages interfacing transport protocol stacks 
regis support ability plug application layer protocol filters binding 
regis generate marshalling code separate specification application layer protocol 
programmers writing endpoint classes implement marshalling 
practice means regis endpoints transmit flat data structures 
transport framework thesis similar regis 
model control event interfaces significantly different 
regis protocol layers pass control messages stack notify higher layers significant events request control operations lower layers 
regent protocols provide control interfaces events queried higher stack 
regent allows bindings specific control event interfaces bypass layers interest interfaces regis control messages pass intermediate layers stack 
regis transport framework support implementation composite layers layers defined solely compositions layers provide registry giving stack descriptions known human friendly names 
darwin language designed dulay jeff kramer jeff magee 
fsp notation model checker designed implemented jeff magee jeff kramer sing chi cheung 
dorothy cannon 
table contents table contents chapter motivation anon structure chapter rm odp corba com javabeans rmi polylith darwin regis unicon wright summary chapter binding chapter 
midas language specifying interaction styles 

modelling bindings fsp 

modelling components fsp 
table contents summary chapter overview chapter modules constants user 
marshalling support 
enums structures typedefs 
message interfaces 

support third party binding 

proxies service access points saps 
summary chapter overview addressing connection 
transport filters 
summary chapter results summary chapter contributions table contents qos bibliography types modules processes properties list figures list figures 











synchronisation concurrent components attribute interaction 
control interfaces allow management bindings 


endpoints interaction represented graphically fsp processes 



potential error caused binding address spaces 









model clients bound server address space 

modelling bindings transport protocol 

reliable ordered 
unreliable ordered 
reliable 
unreliable 
primitive component modelled fsp processes 







components stream audio data address spaces 



example system streams media address spaces 


model client endpoint bit sequence numbers 


placement corba objects servers 




list figures 
classes supporting generic types 

protocol layer interfaces 


session layers created multiplexor clients 






static structure classes 





effect transport layers throughput 

effect interaction style throughput 
list tables list tables 

midas modules mapped java packages 






message interfaces generated midas interaction 

type objects representing primitive types 

type object generated user defined type 


example transport filters 

protocol components 

corba rmi interfaces performance experiment 






example interaction definition 






motivation 
thing find making book know put 
blaise pascal demand distributed computer services rises need easily construct deploy maintain services heterogeneous environments multiple types network system hardware operating system programming language integrated 
led development standardisation middleware systems software environments hide platform language specific details provide runt ime support transparent distributed processing 
current middleware systems focus mainly supporting communication modules system 
object oriented paradigm widely accepted model middleware systems odp omg ee 
object oriented system composed objects services available objects system polymorphic interfaces comprised request reply operations clients request service receive reply 
object oriented systems provide support creating managing bindings objects bindings hidden object implementations usually established object uses binding searching name service trader band mechanisms 
bindings known party bindings complicate system hiding architectural details objects including code establish bindings handle binding errors functional code component 
component development sg refinement object orientation aims solve problems inherent party binding 
component object supports compositional approach system construction exposing interface services provides requires components providing operations allow required services bound provided 
component reuse facilitated defining standard inter component protocols application independent tasks serialisation database access example tasks specific application domain media processing healthcare management example 
systems constructed instantiating components binding interfaces 
binding components performed party usually composite component 
encapsulates components bound 
binding model known third party binding fried sepa rates algorithmic details system encapsulated components architecture system encapsulated code performing binding actions 
architecture system defined declaratively architecture description language adl compiled low level code performs binding actions elaborate architecture visualised graphically 
grow sophistication distributed systems require sophisticated varied styles intercomponent interaction synchronous request reply invocations provided object oriented middleware 
example financial systems event notification announce stock quotes brokers terminals 
compute intensive parallel processing tasks require components execute concurrently possible asynchronous message passing components 
rapid acceptance internet especially consumer medium led demands distributed multimedia services telephony video differ radically data processing traditional application domain distributed computing systems require different qualities service reliability timeliness 
major weakness current middleware platforms typically provide programmer single form interaction components 
difficult build system requires richer set interaction styles 
interaction styles implemented terms interaction style provided middleware platform lower level services losing advantages middleware 

example scenario line record shop example examine potential application receiving great deal interest consumers industry moment selling music network 
scenario multiple service providers main tain databases digital music tracks 
client wanting buy music browses tracks available line record store listen streamed samples tracks interested paying downloading high quality versions files local computer hi fi 
short description identify high level components system shown 
line record store accessed component maintains database information music store 
music stored media stores 
components instantiated media stores stream low resolution preview music download file client hi fi 
client program components allow user visually browse contents store receive 
play streams audio download purchased files client computer hi fi 
components major application components stream audio data disk audio devices process audio streams convert formats example 
client download music browse purchase record shop preview music download music 
overview line record shop application 
components interact different ways different interactions separate uses interaction type need different qualities service levels security 
client browses contents music store invoking request reply operations reliable connection 
requesting preview track client receive stream continuous media reliable requires guaranteed bandwidth maximum jitter 
requesting purchase files client uses request reply transaction reliable connection connection browsing connection requesting purchase secure 
music files transferred client pipe efficiently transfers large amounts data interaction requires reliable secure connection 
easy corba omg implement services allow clients browse purchase avail able music tracks request reply interaction style required browsing interaction style supported corba 
security required handle line payment complicates matters implemented corba security service standard defines secure interoperability protocols management interfaces implemented terms orb mechanisms 
security service standard component corba platform sure purchase orb implements standard 
streaming preview versions music client complex 
reliable request reply interaction abstraction corba objects appropriate streaming continuous media reliability mechanisms synchronisation client server reduce smooth delivery data disrupt playback 
interfaces controlling media streams defined corba telephony standard domain specific facility defined terms corba orb base services currently available imple 
programmer forced integrate corba orb middleware platform provides support media streams interaction styles require implement media streams non portable operating system mechanisms integrate mechanisms orb 
control media stores 
develop scenario detail chapter illustrate demands application met software environment tools resulting research 

example scenario see small example components distributed system communicate variety ways current middleware platforms adequately support requirements 
middleware allow programmers specify wider variety component interaction protocols currently possible 
supported current middleware programmers able compile specifications runtime support required construct system support binding distribution transparency monitoring management 
protocols complex sequences synchronous request reply pairs harder design correctly harder programmers protocol understand 
drawbacks come defining precise formal specifications interaction protocol unambiguously describe protocol implement allow design time error detection mechanical means 
thesis introduces model interaction distributed components language define interaction styles interaction model 
major advantage interaction model language supports design time analysis interaction styles construction components systems interaction styles 
design supported including specifications interaction protocol checked mechanically deadlock violation user defined constraints 
construction supported translating specifications implementation language constructs provide glue connect components interaction style address space distributed network 
approach links design construction phases translating interaction specifications objects inserted bindings check components interacting bindings conform specified interaction protocol 

structure rest thesis structured follows 
chapter examine current state art component interaction models distributed systems highlight advantages shortcomings various approach es 
concludes set requirements system meet support programmers defining system architecture terms communicating components 
chapter introduce model intercomponent interaction midas language specify intercomponent interaction protocols show model language meet requirements identified chapter 
show midas language integrates ex modelling case tools support design time mechanical analysis interaction protocols entire systems follow component model 
chapter elaborates scenario section showing media demand application designed built terms components communicating midas interaction styles 
chapter describes detail midas definitions translated java programming language chapter describes java component framework implementing transport protocols 
chapter examines 
effect approach performance system shows approach negligible effect cases improve performance 
chapter summarises contributions thesis examines taken 


component interaction distributed systems component interaction distributed systems may agree say ll defend death right say distributed systems constructed components interact perform common tasks 
architecture system viewed composition components bindings 
chapter examines current distributed programming environments support design system architecture component interaction styles mechanisms realise architectures interaction styles run time 

brief history distributed programming computers connected networks late 
time processing resources limited operating systems simple 
programmers writing distributed programs responsible implementing required communication code level driving link layer hardware 
early re searchers arpanet project recognised need pass messages different network architectures formulated internet problem get computers communicate multiple packet networks knowing underlying network technologies 
year published tcp protocol solve internet problem 
time tcp handled transport internetwork concerns 
separate concepts transport internetwork protocol developed tcp ip separated allow implementation udp ip 
transport protocols simplify distributed programming providing programmer higher level communication abstractions reli able byte streams hiding unreliable packet nature underlying internet protocols 

component interaction distributed systems early ip tcp typically implemented user level processes programs platform specific interfaces implementations 
operating systems sophisticated implementations link layer internet transport protocols integrated kernel provided application programmers standard apis sockets api introduced release berkley unix steve 
standard programming interfaces allow programmers easily port applications different architectures 
heterogeneous internet programmers handle communication programs running different architectures written different programming languages 
transport protocols provide data transmission services applications application translate data structures raw bytes convert data representations different architectures languages 
address requirement standard presentation layer protocols xdr rfc developed define standard format primitive structured types converted bit strings 
types defined spec ification language compiled type definitions marshalling code programming language 
separate specification language programs written different languages easily communicate structured data 
programmers familiar procedural structured programming building distributed programs presentation transport protocols complex 
abstraction local program modules procedure call different remote modules message passing 
remote procedure call rpc bn invented early extend procedure call abstraction address spaces providing mechanism invoking local remote services 
rpc server exposes services set procedures 
procedures defined definition language specifies names types server procedures 
definition compiled client side server side stubs 
client side stubs appear local procedures marshal send arguments remote server wait server reply 
server side stubs receive messages parameters invoke appropriate procedure server marshal send returned data client 
rpc provided programmers familiar programming model building distributed applications drawback hard build programs dynamic servers created removed services lifetime didn match object oriented style programming prevalent 
object oriented middleware systems developed late early form distributed programming environment procedural rpc rarely 
oo middleware corba dcom current programming language features polymorphism exception handling provide simpler programming model construction distributed programs 

requirements middleware platform 
component interaction distributed systems current object oriented middleware platforms provide programmer great deal support implementing communication modules system number drawbacks 
particular object oriented middleware provide support deploying components nodes network establishing communication paths bindings components 
objects defined provided services expose services require objects responsible connecting services provided objects 
increases object dependence context reducing scope reuse implementation irrelevant structural details 
furthermore objects limited forms interaction typically rpc object invocation asynchronous message passing 
middleware platforms include interaction mechanisms ad hoc extensions 
programmers implement interaction mechanisms terms predominant style terms lower level mechanisms platform specific networking apis complex error prone 
commercial distributed programming environments supports design time modelling analysis components forms interaction systems composed architectural parts 
requirements middleware platform component model 
middleware platform programmer coherent component model defines system composed individual components functionality 
component model defines component interface defined terms services provided required component 
define components packaged deployment instantiation instantiated components composed binding components require service compatible services provided components 
component model provide way managing complexity large systems hierarchical composition example 
component model support visual programming allowing designer specify compositions components graphical tools 
binding 
middleware platform support party third party binding establishment 
party binding involves client component locating establishing connection service requires 
third party binding involves third party client service provider establishes bindings components require service provide service 
middleware platform support static binding creating connections components change lifetime components dynamic binding allowing components dy constructed destroyed lifetime system dynamically start communicating services lifetime 
middleware able establish bindings different transport protocols allowing designer select appropriate transport binding 

component interaction distributed systems open interaction styles 
system constrain system designer single limited number interaction styles components 
designer able select design interaction styles appropriate needs choosing synchronous asynchronous communication communication 
interaction styles independent transport protocol allowing transport functionality quality service selected independently binding 
interaction style specification 
designer able specify new interaction styles 
specifications tied specific programming language 
specification language support requirements open interaction styles listed 
possible programmer com pile interaction specifications code supports implementation composition distribution components interaction styles 
formal modelling 
interaction styles complex synchronous request reply require unambiguous definition 
formal modelling interaction protocols allows interaction styles precisely defined supports design time analysis protocols check errors deadlock communicating parties buffer overflow 
transport protocols 
selecting appropriate transport protocols individual bindings mid platform allow individual transport capabilities encryption compression reliability fragmentation reassembly easily combined easy extend available transport protocols new functionality 
necessitates naming transport protocols terms components dynamic construction protocols compatible remote protocol stacks 
management adaption 
middleware platform support runtime management exposing interfaces middleware layers controlled announcing events state changes errors occur 
interfaces accessible application components allowing runtime adaption middleware platform external management agents 

object oriented middleware oo middleware platforms define systems terms objects main unit architectural structure 
object encapsulates state behaviour interface 
object interface usually specified interface definition language idl independently language implement behaviour 
idl defini tions generate runtime mechanisms allow object invocations performed address spaces 

rm odp rm odp odp joint iso itu standard defined early standardise architectural concepts distributed computing 
intended aid development standards distributed com puting platforms define standard platform 
rm odp presents distributed computing systems 
component interaction distributed systems viewpoints concepts higher level viewpoints mapped lower level concepts 
relevance thesis computational viewpoint defines functional abstractions distributed system distribution transparent manner engineering viewpoint describes system implements computational viewpoint 
computation viewpoint views distributed system set interacting objects 
object provides interfaces services available objects system 
rm odp defines types interface operational stream signal interfaces 
operational interface defines way request reply operations invoked object 
stream interface defines flows continuous media accepted object 
operational stream interfaces defined terms signals low level operations correspond local procedure calls operations streams interactions supported address spaces 
computational viewpoint objects interact bindings interfaces 
rm odp specify initiates binding allowing party third party binding supported model 
bindings primitive directly connecting interfaces compound supported binding objects bound interfaces 
engineering viewpoint binding object corre sponds channel concept represents communication mechanism distributed system 
channel composed stubs binders protocols 
stubs perform processing requires knowledge application semantics binders perform processing require application semantics performed raw bit streams protocols transmit bit streams address spaces 
rm odp defines concepts understandably vague exactly objects systems defined deployed 
prescribe interface definition language method constructing systems define model object behaviour interaction formality 
system constructed composing components architecture description language constructed party binding clients finding servers naming trading services 
considering generality strange standard limits components interaction styles treats stream bindings fundamentally different operation bindings engineering level infrastructure distributed system transport protocol framework fundamentally different interaction styles 
concepts rm odp realised ansa system apm 
ansa provided interface definition language compiler runtime support object interfaces defined idl implemented programming language 
developments corba standard specified features compatible concepts rm odp including naming trading services facilities controlling media streams rm odp adopted corba idl iso standard 
main aim rm odp provide conceptual models implementable standards build interoperable distributed systems 

corba 
component interaction distributed systems corba omg middleware standard defined object management group omg 
implementations corba standard available commercial vendors orbix iona iona visibroker free software list published web omg omg standard libraries java programming language ag 
corba build systems ranging modular graphical user interfaces large distributed secure fault tolerant applications 
interaction styles 
corba provides programmer object oriented model distribution 
servers export services clients objects conform interfaces 
object interfaces defined corba interface definition language corba idl merely idl standardised omg iso 
cor ba idl supports definition constants data structures object interfaces 
object interfaces defined terms named typed read write read attributes operations take multiple named typed parameters return multiple values throw exceptions 
corba standard defines mappings idl various programming languages allowing server clients written different languages 
mapping defines constants data types interfaces exceptions defined idl represented target language 
interface definitions usually compiled client side proxy server side skeleton marshalling code compiled statically linked application 
corba idl language defines interfaces sets synchronous request reply operations asynchronous way messages 
disadvantages 
clients forced synchronise servers take advantage concurrency operation client server improve performance 
oneway operations guaranteed issued asynchronously corba standard provides guarantee reliability relied portable program program implements reliability self 
clients bind objects invoke operations service 
binding performed object request broker orb fundamental component corba architecture 
orb identifies objects object 
binding involves passing object identifying service server client 
client uses initialise proxy object represents remote object client address space 
proxy implementations generated idl specifications compiled client program 
operations invoked proxy object routed orb implementation object 
proxy objects pro vide distribution transparency object proxy conform interface orb return direct pointer object code performing binding address space 
flexible method invoking object operations provided dynamic invocation interface dii allows object requests created issued dynamically 
requests represented objects operations setting name parameters request retrieving returned values exception 
ensure type safety dii idl compiler stores type information definitions compiling 
component interaction distributed systems system wide interface repository traversed client code ensure passes correct values parameters dynamic request 
dii allows greater control concurrency client issuing request object serving 
issuing requests efficient complex type unsafe compared making requests compiled proxies 
version corba standard client side interface orb standardised programs object requests orb portable orb implementations programs implemented corba objects 
corba introduced notion portable object adapter object implementations available orb 
encapsulates mechanisms orb identifies object routes operation requests object separately implementation object known servant 
server create multiple organised hierarchically manage namespace objects server 
orb interacts standard interfaces allowing custom implemented different implementation strategies 
example interfaces database identify objects key indexes record containing state load state database reception request object 
specification defines default implementations link servant delegation inheritance 
interceptors 
object encapsulates transport presentation protocols communicate object 
details encapsulated orb available programmer standard apis 
corba introduced concept interceptor extend replace protocols transfer operation requests 
forms interceptor supported corresponding inserted binding form processing perform 
request interceptors process re quests inserted client process requests issued server process requests invoked servant 
request interceptor processes dii request reply objects containing information request reply including target object operation name arguments 
message interceptors process 
component interaction distributed systems requests sent address spaces inserted client marshalling trans mission server reception unmarshalling 
message interceptors perform lowlevel transformations data compression encryption 

corba interceptors interceptors required communicate object recorded orb specific manner object object 
interceptors available orb application specific interceptor specification provide standard way querying loading interceptors required binding checking compatibility interceptors binding 
services 
addition low level binding communication services provided orb corba standard specifies number higher level interaction mechanisms services implemented terms corba objects 
services include naming trading lifetime management migration concurrency control transaction management event dissemination 
corba standard defines domain specific services known facilities provide object models services particular application domains financial services health care 
request client object reply request interceptors message interceptors orb core request reply request interceptors marshalling marshalling message interceptors evaluation 
major drawback corba environment standard component model system constructed compositional manner 
corba concept object required interfaces corba applications constructed party binding model clients get bind objects need communicate 
complicates code clients large amounts boiler plate code tedious error prone write increases amount testing required 
means way visualising analysing architecture corba system design time run time management tools 

component interaction distributed systems request proposals rfp issued component model standardised part corba 
proposal accepted completed 
component model similar enterprise java beans see section concentrates making easy components transaction monitors database systems implemented independent vendors 
corba component model extends idl declarations provided required interfaces uses term fac ets respectively event sources sinks allowing compositional approach software construction 
assemblies components described xml bps documents interpreted instantiate bind components compared adl xml document describing configuration excessively difficult read 
currently available implementation 
way specify interaction protocol set operations specify order operations called single interface 
way define protocols terms interfaces corba concept required interfaces object 
request proposals issued method formally specifying object behaviour standard 
support interceptors standard way select transport protocol modify qos binding 
interceptors useless omg admits concept interceptors corba underspecified portable 
largely useless mechanism third parties plug orb 
com component object model com ee microsoft object model middleware platform distributed object computing component development 
object oriented middleware platform similar corba concept operation differences 
interaction styles 
com object encapsulates state behaviour provides interfaces components environment 
interfaces strongly typed single inheritance extend existing interface definitions 
interface types defined microsoft interface definition language 
idl allows detailed type definitions corba data types contain pointers support aliasing structures 
object operations synchronous throw exceptions report errors 
coding convention success error indicators returned result operation returned values passed compiler parameters 
component model 
components architecture definition languages com object provide interface type 
interfaces derived base interface called supports garbage collection counting provides method requesting 
component interaction distributed systems interfaces provided component 
com multiple interfaces language independent mechanism implementing multiple interface inheritance corba detail left language mapping allowing language specific multiple inheritance mechanisms supported 
com objects instances particular class 
com runtime uses database map class identifier binary package dynamically linked library executable create instances class 
com functions allow instantiation objects address space different address space machine remote machine 
instantiating objects different address space com runtime transparently creates client side proxies server side stubs pass invocations processes 
com uses refer ence counting keep alive messages determine destroy object programmers careful increasing decreasing counts avoiding circular 
way com differs corba layers lifetime management orb leaves garbage collection application 
corba com supports different programming languages address space 
object interfaces implemented virtual function tables similar 
long language manipulate arrays function pointers invoke operations com object modifications compiler required com objects appear native objects language language generate code defines interface stubs proxies distribution transparency support languages meant generated parsing code generated 
language support low level interface model invoke operations calling object interface provides scripting languages access subset object operations 
com real equivalent corba dii dsi 
nearest equivalent automation framework msft part activex chap defines interface scripting languages invoke operations object 
interface originally designed support operation arguments passed automation interface structures internal implementation runtime 
idl define data types held structures meaning subset object interface available scripting 
disadvantage activex automation com pared corba dii objects implement conversion argument types dispatching operation requests object slightly differently 
corba generates automatic support dispatching operations idl definitions leaves run time scripting language convert language specific data types idl 
evaluation 
com number advantages disadvantages compared corba 
types available expressive corba idl allowing general graph structures declared 
operation definitions primitive define exceptions return types invoking operations com objects tedious 

component interaction distributed systems com defines object classes packaged deployment instantiate components address space clients written different language 
packaging reduces platform independence com tightly tied windows platform 
furthermore com ported platforms com component frameworks activex rely definitions win api public interfaces com develop commercial components component frameworks platform win 
corba com support specification interaction protocols defining individual interface set methods documenting interfaces conjunction natural language 

java beans rmi enterprise java beans java beans chap standard component model java programming language ag 
java beans precompiled java classes instantiated customised changing values exported properties composed application graphical development environment access source code component 
java bean java class allowing bean instances written files transmitted network connections bundled class provides development tools information bean wire application modify properties 
bean normal java object encapsulates state interface defined set methods 
bean framework provides developer higher level view interface operations invoked bean properties represent visible state bean events bean uses notify components changes state 
abstractions graphical tool bean default provided uses java reflection api clk query names bean methods determine names bean events properties operations methods names 
possible define ways beans interact 

graphical java bean development tool 
component interaction distributed systems java beans components gain lot advantages features java language 
platform inde pendent executed virtual machine dynamically loaded network reflective capabilities java language determine interface elements 
java beans number limitations provide limited number interaction styles implemented programmer terms individual java methods represented higher level abstraction 
example implement event bean programmer implement methods add remove event listeners maintain list registered listeners bean 
way specifying analysing protocols bean operations may invoked bean properties set 
bean interface defined terms methods programmer define new bean types purely compositions simpler beans 
write code expose features composite bean methods delegate method contained component 
java beans framework designed support composition components design time run time 
java beans tools usually generate source code component configurations compiled 
bean interface defined terms methods reflection dynamically instantiated components 
reflection api tedious invoking method reflection times slower invoking method polymorphically additional security checks performed 
java beans framework limited construction systems execute single address space 
distributed applications constructed technologies 
java supports number apis development distributed applications including low level networking communication apis provide access tcp ip udp ip transport protocols serial parallel ports machine corba see section java rmi java mechanism remote object invocation enterprise java beans component model writing multi tier client server applications 
java rmi wrw provides mechanism invoking operations java objects network 
tight integration java programming language virtual machine rmi provides simpler programming model corba rmi generates proxies stubs java interface definitions java marshal parameters return types exceptions need separate idl 
furthermore rmi uses java capabilities dynamic linking load classes parameters returned objects network allowing clients servers receive objects classes known compile time 
compared corba rmi inefficient system resources example keeps tcp ip connections open separate binding remote server object provide services naming trading transactions required large distributed system 

component interaction distributed systems rmi provides limited support multiple transport protocols 
java object available rmi configured socket factory object creates sockets receives invocations 
default rmi objects tcp ip sockets socket factories implement security protocols compression tcp ip different transport protocol 
clients bind remote object rmi class socket factory object downloaded server allowing client construct compatible socket 
socket factories allows rmi objects configured monolithic protocols support construction protocols reusable components 
enterprise java beans ejb mh extends java beans component model support multi tier client server computing application logic separated concerns client side user interface back database executed servers 
ejb encapsulates part application logic executed ejb container manages concurrency transactions persistence security protocol invoke operations bean 
allows application components portable different transaction monitors databases security environments middleware platforms 
ejb support graphical tools compose ej beans allows developer configure proper ties bean runtime environment provided container 
ej beans self contained components purely reactive reacting operation requests clients making distributed requests 
simplifies programming model nar row range tasks severely limits application domain ejb components 
default protocol access ej beans java rmi 
ejb deployment tool tcp ip extensions base specification support access subset ejb functionality corba iiop omg allows clients written language 

reflective middleware reflection ability program examine implementation modify implementation order modify behaviour 
reflective object oriented languages krb implement language mechanisms polymorphic dispatch inheritance meta level objects conform predefined interfaces ta object protocols 
programs modify language behaviour specific application level objects replacing standard meta objects application objects application specific meta objects conform appropriate meta object protocol 
multimedia programming group department computing lancaster university extended corba middleware platform reflective interfaces provide facility distributed programs adapt behaviour react changing levels network system resources 
component interaction distributed systems bc cbc 
reflective middleware provides application objects object oriented model middleware environment executing 
object model live modifying model application modifies behaviour middleware 
component model 
application object executing reflective middleware platform provides service interface provides services application objects meta level interface meta level information object obtained 
meta level information object comprised meta models describing separate concerns provided middleware platform 
encapsulation meta model describes service interface object exposing methods attributes providing access interface inheritance graph 
composition meta model represents implementa tion object graph sub objects bindings 
bindings may local bindings objects address space distributed bindings objects different address spaces 
environment meta model represents execution environment provided object interface middleware platform 
distributed environment includes marshalling unmarshalling transport proto cols message queuing dispatching thread creation scheduling 
objects making meta model meta meta model 
example environment meta model composition meta meta model exposes composition objects perform marshalling provide transport functionality 
meta meta model modified change composition binding 
bindings objects reflected open bindings weh extension rm odp concept explicit bindings 
binding remote service returns interface binding object quality service qos binding controlled 
types binding supported operation bindings invoke object operations stream bindings transmit flows continuous media 
corba extended single additional interaction style programmer define new interaction styles 
binding objects composed hierarchically 
sub objects perform processing binding connected binding object local binding procedure calls equivalent mechanism 
processing objects include media codecs transport protocols network device network switches responsible routing traffic binding maintaining network qos reserved binding 
interface binding object monitor control qos provided binding alter configuration binding object qos degrades acceptable level 
component objects binding control interfaces operation modified 
control interfaces type specific 
component interaction distributed systems example control interfaces mpeg codecs different control interfaces udp ip atm transport protocols 
binding object implements control operations calling control operations component objects 
service interfaces application object binding object control interface sub objects 
structure hierarchical open binding application object evaluation 
reflection open bindings powerful tools support configuration distributed programs middleware design time run time 
reflecting manipulating implemen tation details program easily modify behaviour react dynamic changes environment 
open bindings model introduces scalability problems programs grow size complexity 
control interfaces sub objects type specific different binding object implementation required combination sub objects 
new codecs transport protocols introduced number binding object types required increases dramatically 
practically impossible reconfigure binding object binding object prior knowledge subobjects replace subobject achieve desired qos object object understood binding 
disadvantages avoided separating various concerns encapsulated meta objects binding codec marshalling transport network protocols defining standard interfaces particular concern controlled 
reflection disadvantages party binding functional aspects application intermixed code performs binding meta level manipulations 
attempting simplify code separating functional meta level concerns led development architecture description languages allow programmer describe bindings components declaratively aspect oriented programming see section uses multiple languages specify functional various meta level aspects program translates meta level descriptions operations performed reflective implementation 

component interaction distributed systems 
architecture description languages connectors object oriented systems provide programmers support encapsulation abstraction polymorphism 
provide little support system composition evolution system structure hidden implementations objects system 
component systems constructed compo nents encapsulate functional aspects system encapsulate structural aspects 
system structure explicit defining bindings components separately implementations components separate architecture description language adl 
explicit architecture definition simplifies implementation individual components allowing component developers algorithmic details implementation 
architecture description structure formal models system design analysis act representation structure deployed system acting framework management evolution system 
great adls component models designed research projects commercial products 
section review influential representative current state art 

polylith polylith middleware platform developed university maryland late support component development distributed systems 
polylith component known module services requires services modules 
polylith uses module interconnection language mil define interfaces modules terms named typed service provisions requirements 
mil define systems compositions components bindings interfaces 
service module procedure entry point 
modules directly invoke services modules 
invoke services making calls software bus layer software responsible transporting invocations components 
software bus encapsulates details way modules communicate separately functional aspects system encapsulated modules 
example bus may encapsulate modules written different languages communicate address space modules different nodes communicate network 
software bus analogous corba orb 
bus structural information mil description system optimise communication paths communicating modules 
functionality software bus tied closely respective encapsulates modules compiled linked 
generates information bus establish bindings 
example generate stubs flatten data structures network messages coerce data representations different languages 

component interaction distributed systems polylith advantage cleanly decomposing system components defining explicitly specifying architecture system terms instantiated components bindings interface elements 
components limited forms interaction synchronous remote procedure call asynchronous message passing interaction patterns built terms primitives 
adl allow bindings annotated required quality service transport protocol forcing bind ings transport protocol suitable 
support design time modelling analysis systems 

darwin regis darwin architecture description language define structure systems implemented regis distributed programming environment 
darwin language strictly separates structural concerns system computation communication independent runtime system 
darwin configure distributed components written corba platforms parallel programs objects single address space modules interacting procedure calls 
component model 
darwin defines program structure terms component instances bindings interfaces 
component interfaces comprised services provide require provided components context 
services typed darwin language define limit service types compiler interpret types check type safety bindings 
darwin manages structural complexity definition composite components implementation defined terms component instances bindings 
programs structured hierarchy components root composite component representing entire program leaf components representing primitive components encapsulate computational concerns program mid level composite components encapsulating structural concerns program 
semantics darwin defined composite components exist elaboration program structure elaboration primitive component interfaces bound directly communication routed composite components 
darwin support dynamic architectures 
components contain arrays subcomponents size defined function parameters component 
dynamism provided support lazy worker instantiation 
lazy instantiation component performed response invocation services 
worker instantiation provided special form service service type defined darwin language invoked create new component instances 
service implemented invoked left runtime environment 

component interaction distributed systems darwin textual graphical syntax 
graphical syntax case environments tools runtime configuration management fs 
case tools support simultaneous editing representations textual syntax easier defining complex architectures 
graphical syntax represents component instances rectangles component types rounded rectangles provided services filled circles required services hollow circles bindings lines joining required service provided service 
names types represented textual annotations 
see example 
component source require pipe string component filter provide pipe string require pipe string component sink provide pipe string component system inst source inst filter inst sink bind bind source filter sink system pipe string pipe string pipe string pipe string 
simple filter pipeline darwin graphical textual syntaxes modelling analysis 
darwin formal semantics defined calculus mpw precisely defines concurrent algorithm darwin elaborates configurations components 
darwin method modelling analysis gian gjs compose models systems models components bindings 
behaviour primitive components modelled labelled transition systems expressed fsp mk process calculus 
composition binding statements adl translated fsp relabelling hiding operations define components synchronise shared actions actions subcomponents composite hidden composite siblings 
approach models component interactions synchronous events shared processes processes perform shared transition lock step 
model appropriate procedure calls objects address space synchronous reliable method invocations distributed objects 
modelling various inter action transport protocols regis system left designer 
standard library protocol models tool support generating models 
runtime support 
regis framework building distributed programs configuration specified darwin 
primitive components active objects communicate interaction objects 
interaction objects correspond darwin provided required services code establish bindings 
component interaction distributed systems tween generated darwin specification 
middleware platforms regis allows pro grammer multiple types interaction components message ports request reply event dissemination define new interaction styles necessary 
version regis ct supported interaction styles template classes implement ing service side interaction implementing client side 
convention clientside interaction class named service side class suffix ref 
example objects access port services 
ref objects passed messages create dynamic binding structures doubled programming interface interaction protocol 
regis provided basic port interaction type implemented synchronous asynchronous message passing 
interaction abstractions implemented terms ports mixture inheritance aggregation 
implementation new interaction types way complex interaction objects inconsistent 
example client side ref objects interaction types contained local state message queues cast values transmitted messages 
furthermore regis supported single transport protocol allow selection different levels qos appropriate binding 
second version regis cmp pc crane crane developed overcome deficiencies original platform 
framework interaction objects redesigned simple define new interaction styles 
interaction classes separated transport protocol allowing programmers select appropriate transport service 
concept separated client side endpoint identified protocol communicate service 
transport protocol components dynamically loaded allowing client server programs evolved independently new protocol implementations available 
interaction styles 
new regis interaction framework defines interaction type set related classes implement service client endpoints distribution transparency format protocol 
classes inherit base classes defined regis framework define interfaces transport communication endpoints objects 
follow naming convention template functions perform binding instantiate manipulate appropriate classes full type safety 
new interaction framework easier programmer implement new interaction type 
regis number deficiencies 
details interaction protocol completely encapsulated implementations classes protocol 
interaction protocol specification code difficult reimplement protocol language 
lack interaction specifications marshalling code generated difficult transmit complex data structures regis supports transmission flat records contain pointers programmer implement functions translate fields record representations different architectures 

component interaction distributed systems evaluation 
darwin regis system advantages current middleware systems 
darwin explicitly define system architecture freeing programmer need write code deploy bind components 
set potential interaction styles completely open programmers define ex tending base classes provided regis system transport protocol communication selected binding binding basis composed primitive protocol components 
system provide support implementing new interaction styles programmer implement code marshal complex data structures convert representations different systems 
approach modelling component interactions synchronous events appropriate procedure calls objects address space synchronous reliable method invocations distributed objects 
modelling various interaction transport protocols regis system left designer 
standard library protocol models tool support generating models 

component programming environment development distributed systems 
aimed specifically building systems integrate heterogeneous legacy software components deploy distributed network processing nodes 
systems constructed components connectors components encapsulate algorithmic aspects system wrapping legacy software connectors manage communication components 
component model 
component object encapsulates state behaviour strict interface defined interface definition language oil 
darwin language component interface comprised services provided components required component provided 
darwin prescribe service types components services provided required component object operations operations bun higher level abstractions 
component interface exposes information component implements operations interface provided required operations marked synchronous asynchronous indicating threads expect wait reply operation complete 
system defined configuration language ocl hierarchy components root component defines entire system intermediate components composed components leaf components primitive wrapping legacy code 
ocl implementation declaration define composite components terms instantiated sub components bindings interfaces connectors 
darwin composite component expose provided required services subcomponents interface 
darwin ocl requires connectors specified interface element subcomponent interface composite component 
composite component deployed connectors remain system communication components 
component interaction distributed systems bindings routed tree connectors 
compared darwin flattens composite com ponent structures runtime creates direct bindings interfaces subcomponents different composite components composite components results unavoidable communication overheads increase greater hierarchical composition 
ocl ensures bindings components type safe bindings established provided required services compatible synchronisation constraints 
synchronisation constraints constrain connection patterns bindings synchronous requirements bound synchronous service synchronous requirement bound service conversely asynchronous require ment bound multiple asynchronous services asynchronous service target single binding 
type synchronisation constraints overridden specific connector types 
primitive components implemented legacy software wrapped packaging code data struc tures implement component model route invocations component interface programming interface legacy software 
packaging generated ocl primitive implementation declarations describe mapping component interface programming interface legacy software 
descriptions programming language specific primitive compo nents constructed legacy software written java python 
connectors 
connectors responsible transporting invocations components 
connectors perform computation data passed including coercing parameter types allow binding incompatible services converting different presentation layer formats calculating new argu ment values routing invocations argument values 
important connectors mediate interaction components application layer protocol floor passing mechanism groupware application 
manner primitive components adapt legacy code component model connectors adapt legacy communication mechanisms shared memory tcp ip connections rpc calls components 
connector separated adapter object sender receiver objects 
adapter interfaces component packaging generated ocl defini tions performs data type control flow translations execute arbitrary user defined computation data flowing 
connector bind components address space adapter connected directly components 
connector components different 
component interaction distributed systems address spaces adapter instantiated component bound sender receiver objects act proxies remote adapters routing calls adapter communication mechanism connector 
component adapter connector code adapter component component connector code colocated components sender receiver communication mechanism distributed components 
connector objects collocated distributed components ocl system descriptions include management declarations describe components deployed set name value pairs 
management attributes include host execute component oper ating system required user name component run 
control deployment provided distribution policies specify constraints execution components components collocated executed machines domain 
evaluation 
main drawbacks system poorly delineated conceptual model components vs connectors inflexible connector model inefficient implementation 
simple model components encapsulating algorithmic concerns connectors mediating communication components confused ability encapsulate arbitrarily complex computation connectors longer obvious computation performed system 
concerns adapters proxies separated implementation connectors reasons efficiency separation visible components connector type instantiated different transport protocol example order select appropriate qos 
parameters controlling communication mechanism connector controlled application 
adapter component component packaging connectors implemented python rossum interpreted scripting language reduces performance 
way bindings subcomponents routed con back component hierarchy reduces performance communication subcomponents different composites 

unicon 
component interaction distributed systems unicon architecture description language focuses building systems existing architectural parts components connectors supporting architectural styles 
uni con components pieces software encapsulated strict interfaces connectors define protocols components interact procedure calls shared variables unix pipes rpc invocations 
archi style defined potential set components connectors may instantiated part system constraints topology may connected 
component interface comprised component type library unix process properties specialise component type players points component interacts connectors 
connector defines protocol specified connector type properties specialise type points known roles components may interact protocol 
component players connector roles typed may properties specialise types 
component may primitive composite 
primitive component implemented element software defined outside unicon language source code programming language object code library file file system process 
composite components defined terms components connectors connections component players connector roles define internal components interact bindings specify interface composite component mapped elements internal configuration 
unicon designed build systems existing parts define component model run time environment 
component connector types provided operating system system execute unix processes binary object files pipes shared files 
noteworthy aspect unicon set connectors include addition concerned explicit intercom ponent communication indirect interactions caused components competing resources example connector scheduler real time operating system 
unicon compiler analyses architecture description ensure correct players connected roles fulfil configuration implementation composite component fully implements interface 
checks successful unicon compiler generates code components connectors glue code attach component players connector roles scripts compile link components connectors glue executable system 
darwin unicon textual graphical representation graphical representation tools provide user simple interface specify system architectures 

component interaction distributed systems specifications attached architectural parts name value pairs 
unicon tools interpret spec pass external analysis tools 
unicon language modified support credentials shaw component specifications incrementally evolved lifetime component order better support real world usage components new specifications required component created created analysis synthesis existing specifications 
important part compo nent credential credibility specification asserted meaning specification designer taken faith verified meaning component mechanically verified meet specification 
application domain unicon building systems existing platform specific parts main drawback 
unicon compiler graphical tools support fixed set built connector types 
adding new connectors requires extending unicon compiler designers admit trivial task involves adding new icons representing connector graphical tools 
implementing new connector formed writing connector expert toolset 
connector expert comprised data files source code specify syntactic representation connector type perform semantic checks specific connector generate code build rules integrate connector final system 
specialised compiler generator tool integrate connector expert components unicon compiler raising question unicon wasn task 
unicon limited construction systems execute single machine 
support distribution connectors cross address spaces treated different single address space ignoring issues distribution transparency 
example player type procedure call connected player type remote procedure call 
lack distribution support evident way connectors mix concerns transport presentation application layer issues 
pipe connector specifies unix pipe ipc mechanism transport protocol players pipe parameterised regular expression defining format data passed pipe presentation layer issue impossible specify procedure call rpc routed pipe possible generate presentation layer code marshal procedure call textual format understood pipe player 
evaluation 
unicon provides designers rich component model components interact variety ways allows annotate component definitions formal specifications provides tool support analysing specifications generating executable code architecture descriptions 
set connector types available designer limited ipc mechanisms provided platform system execute supported unicon compiler 
unicon provide designer support implementing new connector component types connector types hard coded unicon compiler 
flexible way specifying new interaction styles useful 
inability build deploy distributed systems disadvantage 

wright aesop acme 
component interaction distributed systems wright aesop acme set languages tools specifying analysing constructing system architectures developed able project carnegie mellon university 
wright allen ag adg unicon architecture description language structures system terms components connectors components interacting connectors 
unicon wright purely descriptive modelling analysing software systems build deploy system described 
wright defines semantics component connector behaviour csp 
syntax adl acts structure organise csp specifications 
wright characterises component ports interface interacts components connectors 
port represents role component play interaction components 
protocol followed role expressed csp 
behaviour component expressed csp terms component interactions ports 
wright characterises connector roles played components csp specification protocol roles communicate 
wright open set connector types supports 
system specifications built declaring named component connector instances bindings ports components roles connectors 
system description wright generate csp model system pass external theorem prover analysis 
system properties checked manner system deadlock free component implementation corre sponds port protocols component port protocol compatible connector role bound unbound ports component required bound component correctly 
aesop gao toolkit support construction graphical tools design analysis architectures conform architectural style 
architectural style set component connector types rules composed systems 
aesop represents architecture system objects stored object oriented database 
classes provided part system represent generic components connectors ports roles 
objects representing architectural parts annotated specifications represented objects interpreted tools 
style defined extending base classes represent architectural parts implement constraints parts connected 
example pipe filters style defined constraints components interact pipes output port component connected input role pipe vice versa 
styles defined extending classes existing style 
example pipeline architectural style defined extending pipe filters style constraint filters input port output port 
inheritance inflexible example component pipe 
component interaction distributed systems line style pipes filters style component pipe filters style happens single input output port pipeline style 
styles better described predicates constraints configuration components 
aesop tools interact making reads writes architecture database announcing events software bus notify tools database modified 
aesop provides generic graphical editor draw representations architectures style 
tools style specific depending style aesop tools perform analysis model generate code particular environment 
example tools filters style generate unix filter programs 
architectures described aesop wright directly interchangeable aesop toolset read write wright architecture descriptions analysed wright toolset 
architecture descriptions translated intermediate language acme gao designed lingua franca adl sup port interchange architecture information 
acme defines syntax architectural elements adls common component types connector types configurations component connector instances 
syntax structure models included 
acme interpret specifications acme parser extract processing external tools 
evaluation 
wright specify analyse architectures components interact extensible variety ways drawback purely descriptive generate boilerplate code required instantiate deploy system defined adls 
limitation benefits unicon example trivial integrate new connector types wright architecture 
designer completely comes implementing 
aesop tools generate code required instantiate deploy system read architectural description defined wright 
acme pass information wright aesop tools superfluous 
better single adl toolsets 

transport protocol frameworks sophisticated distributed systems require control transport protocols bindings components may select appropriate reliability security compression auditing management properties 
allow flexible combination different transport layer properties transport protocols binding composed primitive components 
allows example encryption algorithms reliable unreliable transport 
protocol components dynamically loadable systems hard coded limited set protocols 
current object oriented component middleware systems provide limited control transport layer concerns bindings allowing transport protocol service available selected limited set service initialised 
allow creation new transport protocols 
component interaction distributed systems services dynamic loading compatible transports clients 
transport protocols supported typically provide reliable order delivery messages suitable rpc object invocation forms intercomponent interaction streaming media 
systems connectors allow connector encapsulate different transport protocols connector monolithic constructing systems application layer protocol connector reused different transport pro 
number object oriented frameworks defined support implementation transport protocol software lightweight components 
influential early system streams ritchie initially designed provide greater modularity design unix device drivers 
drivers structured linear chain modules encapsulate protocol processing 
module provides uniform interface messages passed stack execute concurrently lightweight threads 
streams functionality accessed standard unix file api 
user processes open device perform control operations push streams modules top stack modify behaviour device 
unix originally support dynamic loading code kernel set available modules fixed 
versions streams system supported construction multiplexor trees dynamic loading streams modules kernel 
performance streams limited execution layer separate thread 
kernel op library building protocol software developed university arizona osf unix kernel 
protocols implemented terms layers sessions layer encapsulates protocol functionality creates session encapsulate state needed user layer 
layers sessions data structures provide uniform interfaces threads deliver messages containing application data control information 
uniform interfaces allows layers composed arbitrary directed graphs kernel encourages fine grained composition lightweight protocol components encapsulate individual algorithms composed implement transports rich semantics 
protocol graphs defined statically modified run time 
kernel introduced concept virtual protocol protocol layer add headers messages flowing serves route messages local protocol graph 
research kernel added concept micro protocol layers sessions 
micro protocol component layer encapsulates part layer functionality processes messages delivered layer 
micro protocols composed explicit structure added layer plug ins communicate manipulating data structures layer 
semantics layer depends selection micro protocols plugged 
tools pro vided help programmer select appropriate micro protocols achieve semantics required layer 
tools help programmer constructing protocol graph 

component interaction distributed systems horus rbm communication system supporting group communication 
multicast semantics reliability stability ordering selected composing protocol layers stack 
horus defines common interface protocol layers threads carry messages enriches interface operations specifically supporting group communication 
protocol structures constructed horus limited trees multiplexors horus support concept virtual protocols responsible routing messages protocol graph 
horus protocol software executes user space available user programs variety apis including unix sockets api message passing interface mpi rpc library commands tcl scripting language 
lp implementation corba specification cambridge research laboratories 
extends corba support multiple transport protocols 
transport framework designed support corba giop higher layer protocol provide compositional approach construction new transport protocols support dynamic loading protocols 
flexinet configurable middleware platform produced apm 
flexinet java distributed services available java objects interaction remote objects follows semantics java object invocation closely possible distributed system 
bindings remote objects implemented stacks protocol components 
flexinet supports linear stacks protocols protocol components responsible presentation layer marshalling 
base stack responsible sending messages transport protocol transport constructed components 
softw commercial middleware platform building java publish subscribe applications includes communication subsystem similar horus 
applications comprised groups components communicate sending asynchronous messages shared multicast channels message serialised java object 
components connected channel receive messages chan nel 
interaction protocols members channel implemented terms individual messages defined separately implementation 
channels point point udp ip multicast tcp ip transport protocol 
protocols layered extend semantics transport provide reliable multicast security example 
protocols stacks constructed dynamically infor mation urls identifying channels limited linear chains layers 
conduits object oriented framework construction network communication software 
protocol software composed conduits perform protocol processing information chunks conduits uniform interface pass information chunks connected arbitrary configurations 
protocol components kernel horus conduits directional top bottom connected orientation 
multiplexing im plemented conduit types mux protocol factory 
mux performs de multiplexing routing information chunks conduit depending content chunk 
protocol factory creates new conduit receives information chunk 
mux configured pass chunks protocol factory 
component interaction distributed systems determine destination chunk causing instantiation conduit process chunk 
de multiplexing message routing implemented instantiating mux upside protocol graph 
kernel conduits compose fine grained components example entire tcp protocol implemented single conduit conduits encapsulating individual reliability flow control multiplexing algorithms 
conduit graphs constructed dynamically set conduit types fixed application constructed 
conduits ported java nk conduit components implemented java beans 
allows dynamic loading configuration conduit graphs design time dynamic loading conduit classes supported runtime 

mpi api construction parallel message passing programs 
originally designed message passing multiprocessors ported networked clusters workstations 
mpi program structured set tasks execute parallel communicate message passing 
maximise concurrency tasks executing different processors minimise overhead due context switching tasks processor message passing asynchronous 
higher level interaction syn patterns tasks implemented terms low level message passing api calls 
compared mpi object oriented middleware forces programmer increase concurrency spawning mul tiple threads control components objects communicate synchronous object invocation 
approach concurrency complicates implementation objects explicit synchronisation code 
metaobject protocols open languages implement connectors distribution transparency cm alp 
open language program mapping lower level mechanisms compilation runtime support controlled objects conform defined protocols 
objects termed metaobjects model implementation program program application domain 
programmers replace metaobjects control implementation specific parts program 
define connectors metaobjects implement method calls replaced specific application objects metaobjects implement connectors mechanisms 
example connectors metaobjects filter redirect method call marshal transmit method invocation remote object 
main disadvantages defining connectors metaobject protocols connectors limited communication com ponents written single language connectors implemented manipulating lowest levels language implementation complex introduce subtle errors 
aspect oriented programming aop lk aims provide power metaobject programming drawbacks implement connectors distributed programs 
aop separates program components functionality object classes definitions non functional aspects system data flows distributed components concurrency constraints 
traditional object oriented languages code implementing aspect scattered code classes affects 
component interaction distributed systems making difficult specify understand modify 
details aspect single place easier define modify aspect easier adapt programs new distribution concurrency strategies 
aop components written traditional object oriented language java definitions aspect written distinct aspect languages 
aspect weaver compiles functional components aspects building runtime support aspect integrates components runtime support connecting components aspect runtimes defined join points code invokes methods passes parameters returns values allocates new objects 
aop aims component programming interface architecture definition languages increasing clarity system clean separation concerns 
aop limited single language aspect languages refer constructs component implementation language hook metaobject protocol language 
providing flexibility aop removes main drawbacks metaobject programming longer necessary explicitly manipulate implementation details language programmer uses high level declarative notation translated metaobjects program transformations 
direct metaobject protocols intercomponent interaction protocols defined implementation component 
toolset aims support systematic customisation middleware application non functional requirements 
programs defined adl configuration components provide require services 
interfaces component define non functional services component reliability transactional properties 
non functional requirements specified names refer definitions property specified order predicate logic 
base middleware layer provided meet basic non functional requirements currently supports corba 
func tionality layer extended middleware components 
non functional properties provided middleware components defined order predicate logic 
toolkit uses theorem prover determine middleware components meet non functional requirements application generates glue code instantiate deploy application 
components interact synchronous object invocation formal models select components mediate bindings services order meet non functional requirements specify check interaction protocols compatibility bindings 
rapide lv adl set specification languages describing simulating distributed computer systems rapide architectures translated executable code 
rapide models system set interacting components generate react events 
simulation rapide architecture generates par tially ordered set events poset poset represents causal relationships events partially ordered events poset causally related 
poset generated simulation run 
component interaction distributed systems checked validity set behavioural constraints defined system designer 
rapide exhaustively check system model required properties designer design simulation traces provide adequate test coverage 
finesse bk coordination language specifying interaction protocols multiple objects 
proto col defines number roles events may emitted received roles causal temporal relationships events 
events parameterised finesse allows designer specify parameters received events related parameters earlier emitted events 
notable features finesse include ability define generic protocols parameterised role types define protocols terms sequential iterations messages parallel message sends support multiparty communication 
finesse currently defined semantics unimplemented 

summary current object oriented middleware platforms provide little support composing systems components 
components system typically objects defined provided services 
forces clients party binding connect required services increases components dependence context reducing scope reuse implementation irrelevant structural details 
components limited forms interaction typically rpc object invocation chronous message passing 
interaction mechanisms added ad hoc extensions implemented terms predominant style implemented lower level mechanisms complex error prone 
example open bindings add media stream interactions extension corba standard java beans components interact method calls properties change notification event nation interaction styles implemented terms corba allows asynchronous invocations dii api complex slow type safe 
commercial distributed programming environments supports design time modelling analysis components interaction styles systems composed architectural parts 
architecture description language adl easier construct systems parts 
non adl approaches interface component adl includes specification services required component implemented components system 
systems built composi tion components instantiated required services bound provided 
components typically multiple interaction styles encapsulated connectors 
component models connectors treat connectors monolithic entities encapsulating application transport layer issues 
highlighted garlan connectors difficult implement modify reuse garlan 
little tool support definition new connector types 
current adls support modelling analysis system construction deployment darwin regis notable exception 
adl supports system construction supports modelling analysis connectors constructed systems 

component interaction distributed systems introduces requirements met research thesis develop language tool support definition component interaction styles 
tools need support modelling analysis interactions design time generate run time support required interaction style executable system 
interaction model monolithic separation application presentation transport layer concerns allow difficulties identified chapter addressed 

model component interaction 
model component interaction communication secondary 
people assume matter course reality second communication 
raymond williams discussed chapter current interface architecture description languages provide support required designing building large distributed systems 
languages allow programmer define new interaction styles aid programmer generating runtime support interactions limit types interaction defined allow complex interaction styles modelled leave implementation completely programmer 
need approach allows programmers specify interaction style specification design time analyse system behaviour specification build time generate runtime support distribution binding 
transport protocol interaction style selected bindings established 
management monitoring functionality inserted bindings 
approach new model component interaction pc pc language named midas realisation 
advantages interaction model language described chapter supports design time analysis interaction styles construction components systems interaction styles 
design supported including specifications interaction protocol checked mechanically deadlock violation user defined constraints 
construction supported translating midas definitions implementation language constructs provide glue connect compo nents interaction style address space network 
runtime support interaction model overcomes problems inherent current middleware platforms strict separation concerns programmers select combinations mechanisms binding achieve behav 
model component interaction required particular context 
midas language links design construction phases generating objects inserted bindings check components interacting bindings conform interaction protocol specified midas definition 
model component interaction fully compatible adl system structuring 
darwin available languages meets requirements adl describes structural information independently runtime environment system modelling system construction formal semantics defines required output compiler supported set software engineering tools 
specifically compared systems described chapter midas model language combines properties open ended 
components multiple styles interaction 
programmers select appropriate interaction style libraries predefined styles define new styles specifically applica tion 
tools generate run time support interface new styles binding communication subsystems 

formal models interaction protocols allow developer analyse new protocols design time quickly finding errors protocol design need time consuming costly code test cycles 
separating concerns interaction transport protocols model behaviour interaction analysed different transport semantics 
models interaction transport protocols model application accurately model final system interaction styles 
flexible 
interaction model defined high level abstraction mapped concepts way separates concerns api synchronisation presentation layer marshalling binding transport protocol 
furthermore transport protocol binding cally loaded composed protocol components accessible generic interfaces giving applications control low level communication aspects loss generality 
distribution transparent 
distribution transparency provided component programmer interaction styles developer new interaction styles 
regis system complex data structures transmitted interaction endpoints 
language independent 
interaction styles defined specification language compiled implementation language constructs 
distribution transparency provided converting data types implementation language wire format 
components written different languages communicate common representation 
efficient 
model component interaction translated efficient implementation con structs 
separation concerns lets system instantiate minimal mechanisms necessary binding 
ability select compose transport protocols allows designer select efficient transport protocol binding principle avoiding unnecessary transport pro tocol mechanisms required 

view component interaction 
model component interaction model component reusable element distributed program encapsulates state behaviour strict interface comprised roles component may take various interaction protocols 
component act service provider service client interactions plays role 
roles represented named typed interaction endpoints 
interaction endpoints provide distribution ency component implementation programming interface interaction protocol identical far binding address space machine remote machine 
course performance local remote interactions differ reliability depending transport protocol selected binding 
interaction communication endpoints service client defined terms asynchronous messages 
detail interaction consists 
set asynchronous messages accepted service server side message interface 

set asynchronous messages service requires client accept client side message interface 

protocol defines specific messages may transmitted 
approach model protocol behaviour communicating finite state machines endpoint interaction 

programming abstractions client service view protocol client serv ice side programming interfaces including synchronisation component threads endpoints 
client thread service thread client side programming interface synchronisation client side message interface asynchronous messages service side message interface synchronisation 
view interaction model service side programming interface 
model component interaction model messages define application layer protocol components communicate bind ing pair message interfaces constitutes contract meyer endpoints 
service guarantees react meaningfully messages received client long messages set messages accepted service point time long client reacts meaningfully service sends messages back client 

binding define bindings endpoints solely terms message interfaces defined midas specification 
client endpoint bound service passing pointer message interface service 
due polymorphic nature message interfaces implementation client side message interface bound implementation service side message interface 
language level strong typing ensure endpoints bound play opposite roles interaction 
local bindings 
client endpoint includes pointer message interface message sends service endpoint 
back binding allows service endpoint send reply message stored service order send messages client 
pointers perform binding means interactions endpoints address space efficient 
overhead dynamically dispatched method call extra pointer argument messages sent client service overhead may introduced synchronisation side endpoint 
binding client thread service thread back binding 
binding client endpoint service service client proxies 
model binding interaction single address space extended address spaces proxy objects ghjv 
proxy objects provide distribution transparency endpoint implementations components endpoints 
messages sent direction time dependent current state sending endpoint proxy required binding 
cor ba parlance midas proxy performs role proxy object marshalling transmitting invocations message interface object adaptor receiving unmarshalling messages performing invocations message interface associated endpoint 

model component interaction service proxy provides illusion service endpoint address space client point client proxy provides illusion client endpoint address space service endpoint 
proxies connected communication channel transmit raw data 
components different address spaces need interact service proxy created client address space client endpoint bound service proxy service proxy connected transport protocol client proxy service address space 
service proxy implements service side message interface interaction client indistinguishable true service endpoint 
client address space 
client service proxies provide distribution transparency service address space client thread service thread transport connection service proxy client proxy remote endpoints interact connection established proxies 
client side endpoint invokes operations message interface service proxy service proxy marshals message parameters data buffer transmits channel 
address space service endpoint system thread receives data buffer carries protocol stack client proxy 
client proxy message data buffer invokes appropriate operation service endpoint message interface 
similarly client proxy marshals invocations operations message interface data buffers transmits service proxy client address space message invokes operations client message interface 
service 
service endpoint accessible remote clients able accept connections remote nodes unique identity network clients request connection 
service identified service tuple comprised identifier transport protocol access service transport level address establish connection protocol 
mechanisms allow client dynamically load transport protocols described detail chapter 
service access points 
service identity connection establishment managed interaction specific service access point sap objects 
saps provide uniform interface code acquire service 
possible write code manipulate establish bindings needing know full types endpoints binding compiled architecture definition instantiate system name service service trader 
untyped nature 
model component interaction sap interfaces assumes binding service uses higher level mechanisms enforce type compatibility bindings 
example compiler architecture description language performs type checking generating code perform binding actions construct system 
interaction sap layered transport protocol endpoint accept transport level connections instance tcp ip server socket exposes address transport endpoint service 
binding framework uses transport sap address initialise remote service proxy objects create transport level connections transport sap 
service transport sap passes connection requests interaction sap creates client proxy object manage new connection 
definition sap proxy classes generated automatically midas compiler interaction type independent underlying protocol long protocol connection provides reliable order delivery 
multiple interaction saps created single service endpoint making service accessible simultaneously different protocols 

saps identify service endpoints 
synchronisation components binding midas specifies protocols components may interact concern components interact protocols implement functional behaviour 
component may active object thread control may concurrent implementation multiple threads control completely reactive internal threads 
interaction model support threading models 
client address space service address space client endpoint service proxy transport session connection service endpoint client proxy transport session transport creates creates interaction sap transport sap developers free implement operations message interfaces way long implementation conforming protocol interaction style supports asynchronous message passing potential concurrent reactive execution components 

model component interaction constraints mean endpoint implementation prepared case sends message receives response call outgoing message interface completed 
constrains threads synchronised endpoint thread hold lock endpoint sending message binding cause deadlock 
concurrency requirement supports communication active threaded components purely reactive components 
reactive component thread carrying mes sage component deliver reply back calling component returning original message call 
constraints support distributed bindings implemented upcall protocol architecture endpoints conform constraints guaranteed block device threads responsible receiving delivering network messages 
client thread client thread scheduled setvalue client endpoint 
synchronisation concurrent components attribute interaction asynchrony message passing constrains implementation endpoint block threads call operations message interface short durations waiting mutual exclusion 
synchronisation threads side binding implemented terms asynchronous messages passed binding 
illustrates synchronisation implemented model 
endpoint object calling thread threads binding encapsulated synchronisation objects semaphores 
caller invoke operation bound message interface wait semaphore encapsulates 
thread delivers message endpoint wake blocked thread signalling semaphore 

control bindings setvalue wait semaphore setack signal semaphore service endpoint component binding access control interfaces may monitor manage operation binding 
example component may need request particular quality service parameters notified quality service drops minimum threshold 
control interfaces exist points binding presentation layer transport stack forms control interface acquired way 
manner transport protocols provide control interfaces described time accept service thread 
model component interaction detail chapter 
monitoring control binding added presentation layer inserting filters binding 
interaction filter implements client service message interfaces interaction type optionally control interfaces operation managed 
chained client service message interfaces binding client endpoint service proxy client endpoint service endpoint 
interaction filter implements operations message interfaces performing processing forwarding request interface binding 
objects composing binding handle requests control interfaces chain responsibility ghjv endpoint filter support requested interface request passed filter binding request reaches endpoint binding proxy 
request reaches endpoint caller informed requested control interface supported binding 
request reaches proxy proxy passes request transport protocol transfer messages address spaces 
client address space client thread 
control interfaces allow management bindings implementation define standard control interfaces defined common tasks performed interaction filters transport protocols 
tasks include checking endpoints conform interaction protocol managing state transport connection reserving qos parameters 
control interfaces defined transport framework discussed chapter 
adl runtime system full information implementation bindings components including filters transport protocols able non standard interfaces configure parameters binding established 
remote control monitoring bindings implemented instantiating adaptor objects collocated control interfaces provide midas service endpoints operations events control interface available network 

transport protocols transport connection implementation intercomponent bindings described terms connections concept binding necessitate connection protocols tcp ip 
connection abstractions implemented light weight adaptor objects layered datagram protocols 
model component interaction udp ip shared memory host 
separation concerns interaction ar chitecture provides flexibility take advantage protocols connection oriented result significant performance improvements 
take event dissemination service example 
services event service provided connection protocol 
configuration event sink connected event source separate transport connection source owns proxy remote sink 
source announces events proxy individually causing message transmitted separately connection 
inefficient performance improved multicast protocol ip multicast deer rbm sin gle event message need transmitted multiple event sinks 
event interaction multicast protocol deriving custom proxy sap classes base classes generated interaction type midas compiler 
multicast client proxy initialised multicast group transmits event messages 
multicast service proxy initialised address multicast group 
client endpoint registers event service multicast service proxy joins group starts receiving event messages 
client endpoint disables reception events multicast service proxy leaves group stops receiving event messages 
event source service available multicast protocol multicast interaction sap object 
connections multicast sap listen connection request events transport protocol layer 
multicast interaction sap acquires group name service creates multicast client proxy endpoint attaches endpoint multicast client proxy 
multicast sap exposes address multicast group service binding framework passes remote multicast client proxies allowing join group receive events 
note service optimisation alongside efficient connection oriented saps allowing clients multicast capable receive events 
client address space harness 
create 
bind 
event param client 
enable 
join 
receive param multicast group 
transmit param server address space 
event param service 
multicast event interaction protocol 
enable 

create harness sap 
create 

model component interaction chapter introduced model component interaction permits components communicate open ended set interaction styles 
shown interaction style separated transport protocol carry application layer messages interaction protocol bindings aug mented monitoring management functionality 
interaction model supports efficient interactions address space allows transport protocol selected run time transport interactions address spaces 
chapter introduces midas language specify interaction styles follow model 
chapter describes language mapped implementation language java 
chapter describes framework implement transport protocols mechanisms dynamically load compose protocol components 

midas language specifying interaction styles midas language specifying interaction styles get habit analysis analysis time enable synthesis habit mind 
frank lloyd wright defined language named midas specify interaction styles interaction model introduced chapter 
midas specifications compiled implementation language con structs java classes define message interfaces implement distribution transparency 
midas allows interactions defined independently implementation language simplifies task programmer generating support distribution transparency 
take advantage programmer familiarity midas syntax corba idl omg 
syntax constant module definitions virtually identical idl 
type definitions extended allow definition generic types 
interface definitions replaced interaction definitions follow model described 
corba idl midas support type allow untyped data held data structures passed messages 
data structures interaction definitions generic parameterised type 
generic interactions allow type checking performed design time midas adl compilers 
components implemented language direct support genericity generic definitions mapped language constructs support compile time type checking component implementations 
midas compiler generates code supports genericity 
midas interaction definitions annotated specifications interaction protocol 
points software lifecycle formal model component interaction useful 
de designing new interaction style faster cheaper designer detect errors protocol exhaustively checking model behaviour interaction protocol performing multiple code test debug cycles 
useful check behaviour protocol layered different types transport protocol 
model checker advantage synchronisation errors detected model checker go unobserved real code due vagaries scheduling timing testing 

midas language specifying interaction styles different systems require different kinds analysis 
concurrent systems checked deadlock progress violations designs real time systems include timing constraints 
midas language allows interaction declarations annotated arbitrary specifications 
midas language identifies specification string type name ignores contents specification body 
specification extracted compiler back passes specification external analysis tools 
specification follow type specific mapping elements interaction name message interfaces message names compiler back associate elements specification elements midas definition 
interaction protocol designed programmer implement interface interaction points internal implementation component owns endpoint 
programmer formal model gain accurate understanding protocol visualisation tools animate state machines representing behaviour role protocol aiding understanding 
formal models generate test code verify endpoint implementations conform protocol specification 
application architect building systems components existing interaction styles similarly benefits mechanical checks behaviour entire system safety progress relevant properties 
introduce midas language number example interaction styles incrementally introduce language features rationale 
styles described features introduced 
introduces basic midas syntax modelling midas endpoints fsp implemen tation java 
slot 
motivates introduces generic interaction types 

describes specify queuing messages delivery 
func 
introduces synchronisation clients service 
event 
introduces communication 
shows clients selectively enable disable messages service 
shows messages sent service client service response client cause synchronisation errors errors detected model checker 
attribute 
shows service endpoint interaction style choose subset clients send messages introduces interaction specific properties defined designer 

interaction style 
midas language specifying interaction styles simplest interaction specified midas asynchronous message sending slot buffer 
interaction clients send message containing data value assume bit long integer service 
service holds single value consumption component 
value received service previous value consumed component previous value overwritten new value 
define interaction give name say slot holds long integer values define message interfaces service client 
interaction service accepts single message put sends messages back client 
midas definition message interfaces shown provide statement defines message interface service require statement clients 
body message interface consists message definitions 
messages named take number named typed parameters 
operation parameters corba idl pass values back server client message parameters read 
values re turned midas interactions explicitly defining reply messages 
interaction provide put unsigned long data require 
message sets interaction message interfaces fully define interaction formal behaviour protocol messages exchanged defined 
augment interaction definition specification protocol spec statement 
different systems require different kinds analysis 
concurrent systems checked deadlock user defined property violations designs real time systems include timing constraints 
midas allows interaction declarations annotated arbitrary specifications identifying specification string type name ignoring contents body 
specification extracted compiler back parse specification process pass external tools 
specification follow type specific mapping elements interaction name message interfaces message names compiler back associate elements specification elements midas definition 
fsp mk process calculus developed imperial college model interaction protocols 
fsp specifications type string fsp 
fsp allows designer analyse interaction protocol meets desired safety properties 
example protocol checked ensure free deadlock caused messages lost transmitted expected receiver 
designer define interaction specific properties properties check finite buffer space endpoints exceeded 
midas defines intercomponent interaction protocols separate transport protocols 
allows de 
midas language specifying interaction styles signer select appropriate transport protocol binding 
separation concerns reflected model allow designer analyse aspects system deployed 
interaction protocols transport protocols modelled separately composed form models actual bindings 
observable behaviour interaction protocol modelled fsp constraint properties specify valid sequences messages transmitted received binding 
names constraints name interaction characters separating words underscores case adding suffix provide require client side service side constraints re spectively 
incoming outgoing message sets endpoint represented interfaces named actions named messages corresponding message set 
constraints interaction trivial client repeatedly sends put messages service re receives put messages shown 
property long slot provide put long slot provide 
property long slot require put long slot require 
long slot provide put long slot require 
constraint properties interaction put constraint property defines valid sequences messages observable single binding models required define behaviour endpoints including messages buffered service endpoint sends messages single client clients subset clients way component implementation interaction endpoints 
may ask bother specify constraint properties case 
constraints useful combined endpoint models double check correctness model 
furthermore constraint properties translated filters inserted binding check correctness endpoint implementations 
reason ranges message parameters limited property specifications single value easier translate properties executable code implements state machines 
endpoint behaviour interaction modelled fsp processes defining behaviour client service endpoints 
process names name interaction client service 
example interaction described fsp processes named long slot client long slot service 
models service endpoints take number clients parameter array interfaces client 

midas language specifying interaction styles constraint properties interaction incoming outgoing message sets endpoint model represented interfaces named actions named messages corresponding message set 
actions process assumed represent programming interface components interaction protocol 
client endpoints bound single service service endpoint array interfaces client bound model de multiplexing strategy interaction protocol 
service endpoint models take number clients parameter 
api actions svc service 
endpoints interaction represented graphically fsp processes interaction model service endpoint comprising single slot 
slot initially empty message received slot contains value read component endpoint api causing slot empty 
message received slot full slot contains value delivered message 
model client endpoint simpler component puts value slot service client endpoint endpoint sends put message service endpoint 
models included complete midas definition interaction shown 
graphically depicts behaviour client service endpoints slot hold integer value 
clt client interaction provide put unsigned long data require spec fsp property long slot provide put long slot provide 
property long slot require put long slot require 
long slot service empty empty put full full get empty 
long slot client put put long slot client 

complete definition interaction api actions put 
behaviour endpoints 
midas language specifying interaction styles definition implement endpoint abstractions programming language java 
step compile midas source code java packages classes 
mapping midas java described detail chapter 
know midas interaction translated java package named interaction contains classes supporting binding distribution transparency 
points classes implemented deriving base classes generated midas compiler 
fsp models provide exact specification behaviour implemented 
shows java implementation client endpoint components implemented single threaded active objects 
implementation follows fsp model closely put action specification implemented put method takes int argument transmits service calling put method service message interface 
binding service managed base class available derived classes protected binding method 
client passes back binding message interface final parameter put method service 
call message interface may fail due network node errors failures reported throwing exception derived caught handled component endpoint 
public class extends public void put int throws binding put 
java implementation client endpoint shows java implementation service endpoint single threaded components 
implementation follows fsp model closely 
synchronisation implemented java monitors thread calling get method waits service endpoint slot empty 
values delivered endpoint calls put method stores value slot wakes notifies thread waiting endpoint 
put put put long slot client put put put put get put get long slot service put 
midas language specifying interaction styles public class extends private int slot private boolean empty true public synchronized int get throws empty wait empty true return slot public synchronized void put int client slot empty false notify 
slot interaction style 
java implementation service endpoint slot buffer useful interaction style definition limited transmission long values 
concept slot buffer independent type values stored slot better define implement generic slot buffer instantiate hold long values parameterising long type 
midas supports generic definitions data structures interaction types 
generic slot buffer interaction call slot defined similarly interaction parameterised type values held slot 
interaction defined instantiation slot interaction 
interaction slot type provide put data require spec fsp property slot provide put slot provide 
property slot require put slot require 
slot service empty empty put full full get empty 
slot client put put slot client 
typedef slot unsigned long 
generic slot interaction 
midas language specifying interaction styles fsp models slot interactions identical convention cardinal values typ ically bits represent values generic types fsp models generic interactions 
allows model represent values changing needing model types 
java values parameter types generic interaction represented untyped object 
full type objects represented type objects encapsulate marshal values type represent 
generic interaction endpoints handed type objects representing type parameters constructed 
type objects defined primitive midas types generated midas compiler user defined types 
generic interaction styles instantiated types known written midas 
implementations generic slot client service shown 
seen implementation virtually identical interaction slot untyped object type parameter representing type slot passed constructor endpoint 
public class extends private object slot null private boolean empty true public type super public synchronized object get throws empty wait empty true return slot public synchronized void put object client slot empty false notifyall public class extends public type super public void put object throws binding put 
java implementation generic slot interaction 
interaction style 
midas language specifying interaction styles slot interaction buffers single value service endpoint 
service lose values component owns service reads values slot slower rate delivered clients 
avoid losing values queuing service 
interaction style usually known asynchronous message port name interaction type 
thing notice message interfaces slot identical 
difference fsp model implementation service endpoint 
fsp specification model queue messages 
modelled chain slot buffers buf hold single value time 
service endpoint defined terms queue process 
relabelling statements line specify messages delivered port put queue messages received port removed head queue 
buf put get buf 
queue buf buf queue put put mid get mid put get get put get 
service queue put put get get 
service put put get get put put put put put put get get get 
fsp model service endpoint put put put put get 
midas language specifying interaction styles implementation service endpoint follows specification closely main difference queue fixed maximum size 
public class extends private queue queue new queue public type super public synchronized object get throws queue isempty wait return queue public synchronized void put object client queue enqueue notify 
func interaction style interaction main shortcomings 
java implementation service endpoint client know messages received component owning service 
clients exhaust available memory server sending messages higher rate component owning service process 
overcome shortcomings need provide form synchronisation client service 
simplest form request reply interaction client sends request message service wait reply message sending request reply message acts service received request 
limiting maximum queue size service number clients request reply interaction allows service send value back client function call 
call interaction func 
increase reusability interaction define generic parameterised types request reply 
message interfaces shown 
interaction func type request type reply provide request request data require reply reply data 
message interfaces func 
midas language specifying interaction styles specify protocol define constraints single binding 
worth defining constraints func interaction compared slot mbuf interactions interaction multiple messages messages sent received specific order 
useful check fsp models endpoints design time implementations runtime order catch errors quickly possible 
properties automates checks 
property func provide request reply func provide 
property func require request reply func require 
model func client shown 

constraint properties func interaction func client request request reply reply func client 

model func client endpoint model func service complex 
clients block waiting reply requests requests queued dropping request cause deadlock client receive reply request 
pulling request queue service needs know client sent request send reply correct client 
queue store value client request identifier client sent request 
client identifier corresponds back binding midas binding model described section 
service endpoint composed queue process func service imp defines component removes requests queue sends replies back client sent request 
api represented actions request reply hide details back binding component 
relabelling statement line specifies requests received client placed back queue interface statement line hides actions queue process making ac tions request reply observable behaviour func service process 

midas language specifying interaction styles func service func service imp func queue request put request reply 
func service imp get request reply reply func service imp 
func queue func buf func buf func queue put put mid get mid put get get put get 
func buf put get func buf 

model func service endpoint constraint properties check endpoint models building model binding client service endpoints service endpoints address space combining properties model 
shown 
checking func binding process model checker verify endpoint models match constraints 
func binding svc func service forall clt func client forall clt func require forall chk func provide clt svc chk svc clt chk 

model binding incorporating constraint properties implementation endpoints func interaction closely follows fsp specifications 
points take note client identifier held queue service endpoint implemented client message interface passed service request message 
simple structure defined queue hold request object request ing client 
synchronisation client service implemented message passing described section 
calling thread blocked waiting monitor client endpoint request message received service endpoint 
additionally service class implements actions request reply methods order follow java programming conventions 

midas language specifying interaction styles public class extends private static class object data client object data client private queue queue new queue public type type super public synchronized object throws queue isempty wait return queue peek data public void object throws rq synchronized rq queue rq client reply public synchronized void request object queue enqueue new notify 
java implementation func service endpoint 
midas language specifying interaction styles public class extends private object reply private boolean waiting public type type super public object call object rq throws waiting false binding request rq synchronized try waiting wait object result reply reply null return reply catch ex throw new ex public synchronized void reply object reply waiting false notify 
java implementation func client endpoint 
event interaction style far considered communication clients send request service may respond back single client time 
event dissemination example communication service announces typed events multiple clients 
client receive events register service sending enable message service store client send event messages 
client wants receiving events sends disable message service responds 
client re enable events 
interaction event type provide enable disable require event data 
message interfaces event interaction constraint properties event interaction shown define protocol property event provide disabled disabled enable enabled enabled event enabled disable disabling disabling event disabling disabled 
property event require disabled disabled enable enabled enabled event enabled disable disabling disabling event disabling disabled 
event disable enable enable event provide event require 
constraint properties event interaction 
midas language specifying interaction styles disable event disable enable enable disable enable event disable enable disable event event event shows behaviour event service endpoint 
typically implement event service endpoint maintain list back bindings clients enabled event reception 
reception enable message service append sender list reception disable message service remove sender list 
fsp allow modelling processes change dynamically service behaviour modelled multiple event announcer processes manages dynamic enabling disabling event transmission single client 

midas language specifying interaction styles event announcer processes share announce api action event service 
start disabled state accept announce action response 
receive enable message client enter enabled state 
state react announce actions sending event state receive disable message point return disabled state 
note service side constraint properties composed model service endpoint model binding 
reduces intermediate state space models event interactions constraint properties 
event service forall event announcer forall chk event provide chk chk 
event announcer disabled disabled enable enabled announce disabled enabled announce event enabled disable disabled 

fsp model event service endpoint shows model event client endpoint 
events received client queued consumption component owning client endpoint 
queue defined similarly func endpoints 
event client io process models behaviour client endpoint showing state chang es response api actions received event messages placed event queue client enabled state 
event client event io event queue event require receive get receive enable disable 
event io disabled disabled enable enable enabled enabled event put enabled disable disable disable disable disable ack event disable disable ack disabled event disable ack 
event queue event buf event buf event queue put put mid get put get get mid 

midas language specifying interaction styles event buf put get event buf 

fsp model event client endpoint notable feature model disabling endpoint modelled explicit intermediate states disable disable ack simple transition enabled disabled state 
avoid synchronisation problems caused service able send messages client time needing initial request client 
common synchronisation problem caused endpoints blocking reception messages sent party classic deadlock situation 
model code table illustrate hap pen endpoints directly bound address space client allow event message delivered disable disable actions service allow disable action announce event actions 
form deadlock avoided synchronisation rules described section 
disable state allows client point receive ignore event messages reacting disable action explicitly highlights synchronisation errors occur implementation programmer careful follow intercomponent synchronisation rules 
event io disabled disabled enable enable enabled enabled event put enabled disable disable disabled 
event announcer disabled disabled enable enabled announce disabled enabled announce event enabled disable disabled 
public class extends 
public synchronized void disable throws 
binding disable public synchronized void event object ev 

public class extends 
public synchronized void announce object ev throws 
client event ev 
table 
common synchronisation error detected static analysis 
midas language specifying interaction styles message avoid problem caused transport connections delaying messages sent address spaces interaction request reply 
explicit included protocol possible client send disable request enter disabled state event message service transit transport connection 
result event message received client state message invalid shown 
message allows client wait disable ack state informed events sent 
enters disabled state error 

potential error caused binding address spaces 
attribute interaction style disable event attribute interaction demonstrates interaction style service decide send messages subset clients 
attribute interaction defines typed attributes exposed component interface known properties 
attribute service maintains value owner service exposes value clients 
clients query current value component attribute 
component changes value attribute new value transmitted clients 
clients try set value tribute component owns attribute accept refuse new value 
client changes value attribute accept refuse notification sent back client requesting change update sent clients change accepted 

midas language specifying interaction styles uml sequence diagram shows potential collaborations attribute service clients 
solid arrow heads signify procedure calls dashed arrows signify threads returning procedure calls half arrow heads indicate asynchronous messages 
client component getvalue getvalue setvalue 
example executions attribute interaction shown step client endpoint initialises time component requests attribute value sending getvalue request service service responds update message containing current value attribute 
queries client endpoint attribute values return cached copy attribute value 
endpoint getvalue update update setvalue setack endpoint setvalue server component update update endpoints component owning attribute service change value attribute 
shown step service endpoint notifies clients sending update messages containing new value attribute 
client endpoints react message updating cached value informing owning component value changed 
clients request new value attribute 
shown step sending setvalue message containing proposed new value attribute 
server component accept refuse proposed values 
accept value shown step service sends setack message back client proposed value notifies components new value sending update message containing 
midas language specifying interaction styles value 
server component refuses proposed value service sends message back client proposed value 
shows midas definition message interfaces protocol constraints protocol graphically depicts protocol constraints 
interaction attribute type provide getvalue setvalue value require update value setack spec fsp property attribute provide ready ready getvalue update ready update ready setvalue reply reply update reply setack ready 
property attribute require ready ready getvalue update ready update ready setvalue reply reply update reply setack ready 

message sets constraint properties attribute interaction attribute require attribute provide 
midas language specifying interaction styles setvalue getvalue update update setack getvalue setvalue setack getvalue setvalue setack getvalue update update setack getvalue setvalue setvalue setack getvalue setvalue setack update update 
constraint properties attribute interaction attribute client process modelling client side attribute interaction shown composition model implementation client endpoint attribute client imp attribute require property checks model conformance interaction protocol 
attribute client imp process actual model client endpoint behaviour 
line states client endpoint starts unset state know value attribute service bound 
unset state defined lines client acquire value unsolicited update message transmitted component updates attribute value may request value sending getvalue message receiving update message reply 
trace result 
midas language specifying interaction styles client entering state value current value attribute 
definition allows eager lazy initialisation client constraint client endpoint value states component getvalue api action 
programmer point view component calls getvalue client request receive value getvalue action returns 
attribute client attribute client imp attribute require 
attribute client imp unset unset update value getvalue update value value getvalue value setvalue sending update changed changed value getvalue value setvalue sending update changed sending setvalue waiting update sending waiting update waiting setack value value 

fsp model client endpoint attribute interaction 
value states defined lines define behaviour client endpoint informed attribute value component processing current value 
call getvalue return current value 
update message received service component notified change value event client enters value state new value 
call component setvalue api action causes endpoint enter sending state sends setvalue message service enters waiting state waits setack reply 
service send update messages client time client willing receive update messages performing request reply transaction accordance midas model asynchronous concurrent communication described section 
sending waiting states accept incoming update messages keep track current value attribute setack message received 
setack message handled updating local value requested client message handled resetting local value current value remote service 
attribute service model shown figures complex specify service interacts multiple clients queues requests handled service owner 
necessity handle incoming outgoing messages concurrently reception queuing messages storing 
midas language specifying interaction styles updates attribute value specified separate processes attribute queue attribute value provide property composed verify binding client service line relabelling statements lines 
attribute service attribute value attribute queue forall check attribute provide setvalue setvalue check check proposal accept refuse setvalue getvalue 

fsp model service endpoint attribute interaction attribute value process shown models attribute service stores value attribute handles local remote updates value 
process starts value state 
getvalue request received update reply sent back client current value 
component owning service calls setvalue api action set attribute new value process sends update message containing new value clients 
setvalue request queued processing process notifies component proposed value enters proposed state indexed requesting client current value old value 
component refuse new value case reply sent back client process returns value value case process enters update ack loop sends setack message requesting client update new value returning value state new value 
attribute value value value setvalue value update getvalue value getvalue update value setvalue proposal proposed update update value update proposed accept update ack refuse value update ack setack update cnt update update cnt update cnt value update ack 

fsp model value held attribute service 

midas language specifying interaction styles queuing setvalue requests modelled attribute queue process shown 
queue defined recursively terms slot buffers hold setvalue requests particular value identified client 
client identifier corresponds back binding client described section queued service send replies client update clients 
attribute queue attribute buf attribute buf attribute queue mid 
attribute buf setvalue setvalue attribute buf 

fsp model client requests queued attribute service 
practice service know clients bound queue size limited available memory 
fsp able model unbounded queue 
luckily maximum size queue guar number clients bound service interaction protocol allow client send request reply previous request pending 
verify constraint defining property composed attribute service definition checks queue overflow 
property shown 
property attribute queue overflow queue queue setvalue queue setvalue queue 
setvalue setvalue 
property check queue attribute service overflow 

modelling bindings fsp setvalue setvalue setvalue attribute queue overflow setvalue local binding endpoints modelled fsp relabelling operator associate interface client endpoint service interfaces index 

midas language specifying interaction styles attribute local binding attribute service forall attribute client 

model clients bound server address space 
remote binding implemented connecting endpoints ends process representing duplex transport connection 
process modelling transport connection array endpoint interfaces named sub interfaces named send recv messages sent received 
send recv interfaces arrays indexed elements interface identifiers messages sent received interface 
definition process mod connection parameterised number messages buffers direction 
example remote binding attribute interaction shown 
transport connection 
attribute remote binding forall attribute client attribute service forall transport connection getvalue send setvalue send update recv setack recv recv update send setack send send getvalue recv setvalue recv 

modelling bindings transport protocol glance appear fsp suited model distributed interactions follow midas model 
midas model interaction protocol endpoints communicate sending asynchronous messages fsp processes synchronise shared actions equivalent synchronous procedure call finite number states making impossible model completely asynchronous communication 
practice reliable transport protocols provide finite amount asynchrony sender receiver perform buffering flow control part mechanisms ensure reliability order deliv ery networks queue finite number messages congested discarding messages 
message buffering modelled single slot buffers shown repeatedly send receive messages sender shares send actions receiver shares recv actions 
buffer hold different message types 
transport connection modelled composing buffers maximum number messages transit connection time 
buf send recv buf 

slot buffer modelled fsp 

midas language specifying interaction styles ordered reliable simplex connections buffer multiple messages modelled chains buf processes subsequent buffers receive messages buffer front 
duplex connections modelled simplex connections carrying messages direction 
connections hidden interfaces exposed represent ends duplex connection messages sent received 
send send buf recv buf buf recv recv send buf buf mid recv mid send send recv 
send send recv recv send send recv recv 

reliable ordered simplex duplex connections unreliable ordered connections modelled reliable connections buffer replaced may discard messages 
connections model streaming protocols atm 

midas language specifying interaction styles send send recv buf buf recv send discard recv 
mid recv mid send send recv 

unreliable ordered simplex connection 
unordered reliable simplex connections modelled slot buffers parallel 
input process non deterministically selects empty buffer pass transmitted message output processes non deterministically selects full buffer message deliver 
messages transit time delivered order 
unordered reliable connections useful modelling reliable multicast protocols 
buf send send fan buf fan recv recv buf fan send buf send fan 
fan buf recv recv fan 
fan forall buf buf fan send recv 

reliable unordered simplex connection unreliable unordered simplex connections reliable unordered connections fan process replaced discard messages 
model represent communication datagram protocols udp ip 

midas language specifying interaction styles send discard buf send 
forall buf buf fan send recv discard 

unreliable unordered simplex connection reliable ordered connections duplex unreliable unordered connections composed simplex connections carrying messages opposite directions 

modelling components fsp primitive application component modelled composite process composed processes representing objects uses primitive process shares api actions interaction processes 
interaction objects exposed interface composite object 
models generated automatically darwin adl compiler 
comp comp getvalue setvalue proposal accept refuse write attribute service pipe client 
primitive component modelled fsp processes primitive components models composed form models composite components 
internal bindings endpoints subcomponents may modelled process representing transport connection direct local binding described section 
semantics darwin defined bindings expose provided required endpoints subcomponent interface composite component modelled transport connections 

supporting endpoint implementation 
guiding implementation 
midas language specifying interaction styles midas compiler translates interaction declarations endpoint stubs glue supports communication interaction endpoints implementation endpoints 
programmer extend endpoint stubs interface endpoint internal implementation components 
fsp specification endpoint behaviour included midas definition provides exact specification protocol implemented 
programmers enjoy deciphering formal specifications determine behaviour implement 
important support programmers helping understand protocols 
powerful aid understanding visualisation tools particularly animation allow interactive exploration model 
formal models midas interaction definition allows models passed animation tools allow user explore state machines hand manually selecting events get triggered graphically highlight transitions executed response events 
plug ins provided visualise message passing client service endpoints natural manner 

animator allowing interactive exploration midas interaction protocol support programmer implementing endpoints provided generating test code fsp properties specify observable behaviour endpoints described section 

runtime verification 
midas language specifying interaction styles midas interaction declarations include formal specifications interaction protocol programmers follow implementing endpoints 
programmers test implementation order confident conforms protocol 
writing tests tedious error prone 
back midas compiler automatically generate code formal specification protocol 
advantage providing tangible benefit programmer help ensure design information included midas declarations kept date 
test code verifies endpoints conformance interaction protocol implemented interaction filters described section 
test filters generated fsp properties specify observable behaviour binding 
filters execute state machines defined properties reacting incoming outgoing messages performing state transitions 
transitions error state reported application notifying monitoring agents error event events announced midas services allowing monitoring agents remote components tested 
erroneous transmissions reported throwing exception handled component owns endpoint behaviour turned runtime test filter control interface 
error state binding deactivated test filter discards transmitted received messages including caused transition error state 
binding reset valid state control interface test filter 
client address space 
summary 
test filters monitored remote management agents service address space client component service thread transport connection transport connection agent address space monitoring agent chapter introduced midas language define interaction styles follow interaction model introduced chapter 
advantage midas supports design time analysis interaction styles construction components systems interaction styles 
design supported including specifications interaction protocol midas declarations 
construction 
midas language specifying interaction styles supported translating midas definitions implementation language constructs provide glue con components interaction style design java runtime support midas interactions described detail chapter 
midas links design construction phases generating objects inserted bindings check components interacting bindings conform interaction protocol specified midas definition 
midas interactions independent transport carry interaction messages endpoints 
midas runtime model supports efficient interactions address space allows transport protocol selected run time transport interactions address spaces 
framework implementing transport protocols mechanisms dynamically load compose protocol components run time described chapter 


case study line music shop case study line music shop aristotle main emphasis man language identification objects relationships objects 
th floor elevators chapter illustrates benefits darwin midas design distributed application line record shop server client 
design highlights need multiple forms interaction system components different transport protocols individual bindings 
chapter show midas design analyse interaction types shows generic interaction styles capture common forms interaction reuse 

overview selling digital music tracks public computer networks application receiving great deal interest consumers industry 
scenario multiple service providers maintain databases digital music tracks 
client wanting buy music browses tracks available line record store listen streamed samples tracks interested paying downloading high quality versions files local computer hi fi 
client download music browse purchase record shop preview music download music control media stores 
overview line record store application 

case study line music shop informal overview system shown 
line record store accessed compo nent maintains database information music store 
music stored media stores 
components instantiated media stores stream low resolution preview track client upload track client hi fi 
client program components allow user visually browse contents store receive play streams audio download purchased files client computer hi fi 
components major application components stream audio data disk audio devices process audio streams convert formats example 
components interact different ways different interactions separate uses interaction type need different qualities service levels security 
client browses contents music store invoking request reply operations reliable connection 
requesting preview track client receive stream continuous media reliable requires guaranteed band width maximum jitter 
requesting purchase files client uses request reply transaction reliable connection connection browsing connection requesting purchase secure 
music files transferred client pipe efficiently transfers large amounts data interaction requires reliable secure connection 
rest section demonstrate architecture system described components darwin adl interactions components defined midas bindings implemented regent runtime environment 

system architecture 
case study line music shop record shop client server application 
record shop implemented server exports services name service 
clients record shop import services shop name service 
architecture server shown client 
name string int store host dyn dyn src str protocol order cod udp upload pipe pipe block contents contents preview preview upload dir directory 
architecture record shop server 
browse browse name browse name preview name purchase server composed multiple components manage storage music tracks single physical host single directory component maintains hierarchical listing tracks 
directory acts facade ghjv hiding individual clients directing preview download requests individual tracks appropriate 
directory component provides request reply services browse clients query tracks shop purchase preview shoppers request stream low resolution audio transmitted local client pur chase clients purchase music track credit card arrange high resolution version track downloaded local machine 
bank name bank preview purchase protocol secure tcp 
case study line music shop architecture client simpler server 
functionality implemented browser component provides graphical user interface customer may interactively browse tracks record shop server select tracks preview enter purchase details 
browser requires services exported server imports name service 
browser dynamically instantiate components receive streamed previews music tracks download track data local filestore 
server string dyn dyn src download str pipe pipe block protocol secure tcp preview download browser 
architecture record shop client browse browse server browse server preview server purchase client request streamed preview track invoking directory preview service passing name track request receiving service transmitting preview reply 
directory reacts preview request mapping track name contains track invoking preview service 
preview service component server worker service type indicated darwin dyn keyword invocations service create new component return control interface new component obtain provided services bind required services 
case directory obtains source str service returns client client bind start receiving audio stream 
continuous media data transmitted real time human consumption need reliable delivery 
reliable delivery degrade quality presentation reliable protocols delay frames retransmitting earlier frames lost 
str service provided transport protocol order cod udp composite protocol implements unreliable order delivery messages order light weight connection protocol cod udp ip 
client wants arrange purchase track instantiates download component receives blocks raw data pipe service named input writes file 
pipe interaction downloading large amounts data preference port entry interactions uses windowed flow control protocol allows concurrency sender receiver avoids overflowing buffers receiver 
download component input pipe sent server field purchase re quest name track required payment details 
server communicates bank preview purchase 
case study line music shop verify purchase details instantiates upload component appropriate media store host binds pipe client endpoint input service download component 
purchase service directory component input service download component provided transport protocol secure tcp secures tcp ip connection binding encryption authentication 
bindings configured parameters specific secure protocol name prin identity binding authenticated 
configuration parameters shown graphical view system architecture represented architectural description language 
apart worker services generated automatically darwin compiler media stream interaction previews interactions components record shop application follow styles request reply typed attributes change notification 
cases need define new midas interaction type 
regent runtime libraries include generic request reply attributes set standard interaction styles provided component programmers 
programmer parameterise generic styles application specific data structures defined midas 
definitions browse interactions shown 
module record shop typedef string typedef sequence typedef sequence struct name boolean directory typedef sequence typedef regent interact attribute typedef regent interact entry browse 
instantiations generic interaction types 
generic interaction types greatly reduces effort required design component interactions 
easier declare data structures new interaction styles 
preferable existing interactions possible verified correctness implementations typically available library programmers 
application programmer need design single new interaction type streaming media 
described section media streaming components common interaction styles monitor control media flow 

media processing components streaming reception presentation streamed media audio video easily broken separate tasks implemented individual components 
line record store media data read mp file converted low resolution format streamed network connection received 
case study line music shop client converted low resolution format expected client audio hardware buffered remove jitter caused queuing delays network passed client audio hardware playback 
source address space sink address space file buffer 
components stream audio data address spaces 
media processing components need communicate ways control media flow 
format data provided component reading data file component converting low resolution format component component converting format sound card 
source audio stream needs notify components stream media started paused stopped flush internal buffers correctly inform user graphical interface 
audio output component inform buffer component audio data drained card request data 
components want announce events process frames allowing components synchronise processing maintain lip sync audio video stream example 
existing component frameworks processing streamed media microsoft latest windows api processing presenting continuous media java media framework 
drawback frameworks combine distinct interactions described complex interfaces media data format information control messages events passed 
effectively limits component model single address space interface bound different interactions require different qualities service transmitted tween address spaces 
example media data transmitted unreliable connection timeliness delivery important reliability control messages transmitted reliably 
combining different interactions single interface definition forces media data control information trans qos 
result media transmitted reliable connection adversely affecting presentation control messages transmitted unreliable connection resulting lost messages cause system enter inconsistent state 
method media frameworks solve binding problem encapsulate transmission reception media specific components connectors 
negates benefits component framework developing distributed application component framework compose components different address spaces complicates resulting system hiding structural infor mation bindings distributed media processing components communicating network implementation components making visible architectural level 
defining interactions media processing midas developer take full advantage capabilities midas 
case study line music shop regent component model 
components interact interaction styles collocated distrib appropriate transport protocol selected binding address spaces allowing bindings different quality service reliability characteristics 
shows architecture component acts source audio stream defined midas interactions 
constituent components collocated 
component named reader streams audio data local file service named stream 
provides format audio data attribute generic interaction type announces flow events start stream flow event service 
component named convert converts frames media mat stored low resolution format streaming network 
requires format incoming media provides format outgoing media components 
string file reader file flow event stream format attribute stream fmt convert 
source component streaming audio 
shows architecture sink audio stream 
media data received component named convert converts low resolution format playback audio hard ware 
attribute holding format incoming media required convert component provided source stream 
convert component passes media frames smooth component buffers frames remove jitter resulting network transmission 
draining buffer performed response messages sent port named pump messages sent buffer frames sent component stream service 
buffer requires notification stream detect different stream buffer underflow provides notification stream media buffering 
playback component receives media frames passed audio hardware 
requires output format convert component initialise hardware receives notification stream release audio hardware programs stream complete 
audio data consumed card playback component announces requirement fmt flow stream stream format 
case study line music shop data sending notifications drain event 
events routed smooth component push component converts events messages sent buffer pump port 
buffer reacts messages sending media frames stream service 
flow stream format stream fmt convert fmt smooth buffer 
sink component streaming audio 
playback stream communication exposed interaction endpoints owned components binding components different address spaces performed darwin runtime information architectural description system 
shows simple system streams component node component showing media stream bindings explicitly declared components just form interaction 
src node stream flow stream format stream src flow flow flow 
example system streams media address spaces advantage midas apart media stream interaction interactions media processing components instantiations common generic interactions event dissemination typed attributes message ports 
cases need define new midas interaction type programmer parameterise existing generic interactions application specific midas types 
greatly reduces effort required design component interactions 
easier declare data structure new interaction style preferable existing interactions possible verified correctness implementations typically available library programmers 
pump protocol order frag cod udp flow stream format stream push ev port stream drain snk node format 
case study line music shop media stream interaction defined midas simple stream service transmits frame media clients 
clients send connection request stream service start transmission media 
stream interaction designed operate unreliable protocol client endpoints repeat connection requests frame received timeout period 
midas code state machines protocol constraints shown 
state machines parameterised size range sequence numbers identify frames media seq parameter frame message 
seq parameter frame message represented index frame frame events constraint properties 
typedef long long timestamp typedef unsigned long long typedef sequence octet frame interaction provide connect require frame seq timestamp start frame data spec fsp property media stream provide ready ready connect streaming streaming frame streaming connect streaming 
property media stream require connect waiting waiting connect waiting timeout frame streaming streaming frame streaming 
connect media stream provide connect frame connect 
interaction type frame frame media stream require connect shows fsp model client endpoint interaction 
model composed client side protocol constraint model endpoint implementation media stream client imp 
process defines connection protocol works frames buffered endpoint processed component implementation 

case study line music shop client endpoint initially sends connect message starts waiting receive media waiting state 
waiting state client waits frame delivered case frame buffered timeout occurs 
timeout occurs client enters timed state receive frame media send timeout return waiting state 
extra state required model concurrency inherent midas communication model message transmitted received different threads forcing timeout followed transmission connect message cause deadlock service concurrently trying deliver frame media 
frame received client endpoint enters frame state indexed sequence number frame received 
represents buffering single frame media 
component receive frame api action case endpoint waits frame frame state 
frame delivered endpoint frame state enters frame state indexed latest frame received discarding buffered frame 
media stream client media stream client imp media stream require 
media stream client imp connect waiting waiting frame seq frame seq timeout timed timed connect waiting frame seq frame seq frame seq seq frame frame seq frame seq frame frame seq frame seq 
connect timeout connect frame frame frame frame frame frame frame frame frame media stream client frame 
model client endpoint bit sequence numbers shows fsp model service endpoint 
model composed mod el api component sends frames media models representing clients connect stream 
media stream service api process represents component sends frames action synchronised component results internal broadcast frame action indexed 
case study line music shop current sequence number sequence numbers incremented frame modulo range sequence numbers stream xmit processes define client connects stream 
unconnected client receive media transmitted service broadcast frame event ignored 
connect message received frame broadcast transmitted client 
line hides broadcast action internal endpoint 
combined state machine media stream service process large display graphically 
media stream service media stream service api forall media stream service xmit forall check media stream provide check check broadcast 
media stream service api seq seq broadcast frame seq 
media stream service xmit unconnected unconnected connect connected broadcast frame unconnected connected connect connected broadcast frame frame connected 

model service endpoint bit sequence numbers combining media stream service media stream client models model unreliable order transport connection described section check protocol performs required connection setup eventually succeeds frames lost causing deadlock 

comparison corba shown line record shopping application structured darwin adl interactions components defined midas 
application implemented existing object oriented middleware platform 
firstly define object model application terms classes objects relationships classes shown 
clients access record shop shop keeper object browse music tracks shop purchase tracks 
music tracks organised category annotated information artist track publisher 
client request preview track low quality version music streamed network 

case study line music shop client purchases track giving shop keeper object payment details 
shop keeper checks client payment details bank secure connection 
check succeeds client correct account number money account pay music shop keeper returns client stream track may downloaded secure connection 
download stream created track object track object encapsulates storage digital music data shop keeper asks track create stream private operation exposed clients 
purchase categories parent subcategory name string description string tracks track name string artist string copyright string copyright date date publisher string published date date description string price currency preview download client key publickey category track 
classes record shop application 
read bytes int sequence octet design corba system define music streamed client playback stating preview stream passed client value 
media streams defined corba idl interfaces idl operations synchronous reliable appropriate continuous media 
way operations appropriate corba standard provides guar implemented differently synchronous operations 
corba provides mechanisms selecting appropriate transport protocol quality service bindings making difficult smoothly transfer media corba interfaces 
implement mechanisms streaming audio data native apis provided operating system want support cross platform framework processing streamed media 
approach requires integrate event loops corba orb streaming framework non trivial task shelf frameworks orbs provide hooks event bank creates bank check details boolean 
case study line music shop loop 
similarly inefficient download music tracks multiple operation invocations op eration invocation involves round trip client server 
interface system interaction style better suited bulk transfer data example style relaxes synchronisation sender receiver windowed flow control protocol 
step decide placement objects nodes determine application objects exposed corba objects idl interfaces 
placement objects operating system processes machines shown uml notation 
note placement information translated executable code deploys system components system administrator place server executes corba objects physical node 
server register objects naming service components requiring remote objects look naming service 
duplicates binding information names objects distributes system components requiring changes multiple components system architecture changed 
tracks tracks bank server second tier server front server 
placement corba objects servers 
example demonstrates corba provide appropriate mechanisms define interactions components simple application 
separation concerns provided midas language runtime libraries allows designer select appropriate combination interaction transport protocols binding 
compared uml placement diagram darwin architecture description provides clearer view components interact protocols interactions mediated 
clients 

case study line music shop chapter described design line record shop expressed darwin midas 
design highlights components need interact variety ways individual bindings require different transport protocols levels security qualities service 
midas allows different interaction styles described named names darwin architecture description 
clearly separating concerns interaction style transport protocol system select appropriate transport binding securing bindings secure unreliable transport transmission continuous media data suffer reliable transmission 
described chapter transport protocols implemented composing components allowing existing protocols augmented additional behaviour example binding secured including security protocol layer component transport 
shown design new interaction protocol complex task 
ability clients services communicate asynchronously ability create bindings different transport semantics result errors deadlock caused messages received endpoint invalid state lost unreliable connection delivered different order transmitted 
midas uses methods alleviate problems 
firstly interactions defined instantiations existing generic interaction styles 
allows designer reuse existing designs checked correctness implementations tested 
secondly midas interaction definitions include formal specifications behaviour combined models transport connections check behaviour protocol different transport protocols 
thirdly test code generated formal specifications perform runtime checks endpoint implementations conform interaction protocol 

mapping midas java 
mapping midas java worry theory long machinery supposed 
robert chapter introduced midas language specify component interaction styles follow interaction model introduced chapter 
midas purely specify interaction styles midas declarations translated constructs programming language programmer create components interaction styles 
translation performed automatically compilers process midas code optionally formal specifications code annotated 
chapter show midas definitions mapped particular implementation language java ag 
decisions involved applicable languages example 
scheme translates midas declarations programming language decide map primitive midas types primitive types programming language 
may correspondence types languages 
map midas types constructors sequences arrays user defined types enums structs programming language 
certainly mapping midas types programming language 
programming languages typically provide minimum data structuring facilities arrays records allow programmer build complex data structures sequences basic language facilities 
implement interaction endpoints programming language separate various concerns client service endpoints component developers integrators select appropriate presentation transport protocols insert management functionality bindings 
map instances interaction types programming language 
example type defined interaction statement parameter message field structure 
map generic type interaction declarations parameterised 
mapping midas java types features programming languages provide direct support genericity 
java strongly typed object oriented programming language features single inheritance state behaviour multiple inheritance interfaces 
mapping primitive types midas java java mapping corba idl omg 
user defined types mapped slightly differently provide conven interface programmer 
java support parameterised types design decisions involved mapping generic midas declarations java classes supporting genericity runtime support distribution transparency binding described detail uml notation 

modules midas allows names defined modules avoid name clash group related type interaction definitions 
declared body module statement midas definitions defined global module 
modules nested definitions modules referred scoped names 
scoped name preceded names modules containing name separated scoping operator 
initial indicates name resolved global module resolved module name usual name resolution rules block structured languages pascal 
modules mapped java packages 
global module mapped unnamed global java package nested modules mapped java sub packages 
module regent module interact 

constants midas syntax java mapping package regent interact 
table 
midas modules mapped java packages midas const statement define named typed constant 
constants values primitive types character strings 
numeric boolean constants calculated compile time literal values constants 
expressions follow syntax corba idl omg 

mapping midas java java support constant declarations outside class declarations midas const declaration mapped interface name constant contains constant static final variable name constant 
classes implement constant interface want midas name constant 
midas syntax java mapping const unsigned long timeout rtt public interface timeout public static int timeout rtt rtt 
basic types table 
midas constant declaration mapped java midas provides primitive types corba idl shown table 
mapping primitive midas types java types follows corba idl java mapping 
midas type data value java mapping boolean true false boolean octet bit cardinal byte short bit integer short unsigned short bit cardinal short long bit integer int unsigned long bit cardinal int long long bit cardinal long unsigned long long bit integer long float bit real float double bit real double char bit character char table 
primitive midas types midas provides number ways specify structured data 
simplest fixed size multidimensional arrays values 
variable sized sequences values supported sequence type constructor sequences optionally bounded 
string type similar sequence characters mapped appropriate type handling strings implementation language 

mapping midas java arrays translated directly java arrays 
midas sequences mapped instances class regent interact sequence maintains controlled sequence object 
class maintain sequences types mapped java classes inefficient way representing sequences primitive types element sequence stored java object 
regent interact package contains classes hold sequences primitive type 
midas type java mapping sequence boolean regent interact sequence octet regent interact sequence short regent interact sequence unsigned short regent interact sequence long regent interact sequence unsigned long regent interact sequence long long regent interact sequence unsigned long long regent interact sequence float regent interact sequence double regent interact sequence char regent interact string java lang string 
sequence classes hold primitive types sequence classes implement marshalling support described section run time support genericity described section 
basic sequence class regent interact sequence type marshalling functions run time type information parameterised type described section 

user defined types 
marshalling support user defined type midas compiler generates code marshals values type byte streams 
marshalling code implemented static functions class generated midas type 
write function writes instances class byte stream interface read function reads instance class byte stream interface 

mapping midas java public class 
public static void write java io data throws java io ioexception 
public static read java io throws java io ioexception 

marshalling functions generated class approach disadvantage standard java serialisation mechanism untyped data marshalling invoked polymorphic interfaces 
increase type safety midas allows specification generic interaction types doesn allow passing untyped data components 
receiving endpoint priori knowledge type data received type information included messages standard java serialisation mechanism 
reduces size messages sent address spaces 
interfaces read write data allows midas types byte stream pushing objects front stream 
usually marshalling code writes values passed transport subsystem reads values received transport subsystem 
classes implement efficient algorithms data management described detail section 
marshalling support elided example java code 

enums enum statement define new enumerated type values set symbolic constants 
java provide enumerated types midas enum declarations mapped java classes follow widely programming idiom emulate enumerations 
enum declaration mapped class private constructors making impossible client code instantiate new objects class 
objects class held constants scoped class name enumeration values 
alternative approach translate enums interface containing static integer constants symbolic constant 
approach type unsafe java program attempted invalid integer values enumerated type expected compile correctly cause runtime errors 
approach chosen catches errors compile time 

mapping midas java object stores index enumeration string representation enumeration value static mappings integers strings appropriate object instances set class initialised 
allows client code map enumerated values integers strings vice versa 
additionally iteration enumeration values supported prev methods object return previous enumeration value respectively 
midas syntax java mapping enum write method enum class marshals values writing integer representation stream bit integer 
read method enum class value reading bit integer stream passing fromint static method 
fromint throws interact thrown abort fur ther unmarshalling 
public class private int int value private string str value private static index new private static hashtable name new hashtable private int iv string sv int value iv str value sv index iv name put sv public static final new public static final new public static final new public int intvalue return int value public string tostring return str value public 
public prev 
public static string str return name get str public static fromint int return int value 
table 
midas enum mapped java class 
structures 
mapping midas java complex data types defined struct statements 
struct declaration defines record type containing zero named typed fields 
structures translated java classes contain fields structure public member variables 
structure class provides constructors arguments initialises fields safe initial values takes values fields arguments 
write method structure marshals values writing field stream order declaration midas source file 
read method reads values stream uses construct instance structure class 

typedefs midas allows definition type aliases typedef statement 
useful give convenient descriptive names type definitions long names different modules instantiations ge type 
midas syntax java mapping struct long string public class public int public string public public int string 
table 
midas struct mapped java class 
mapping midas java java support concept typedef names defined midas typedefs mapped java 
uses typedef midas declaration mapped uses type renamed typedef 
typedef alias typedef chain typedefs followed back root type definition 

interaction types interaction types generate java interfaces define provided required message interfaces base classes endpoint objects derived classes implement distribution transparency described section 
compiler back ends generate useful classes interaction types 
interaction type mapped java package contains generated interface class definitions 
name package derived name interaction converting characters name lower case inserting underscores upper case characters preceded lower case letter preceded upper case character followed lower case character 
algorithm transforms name words delimited upper case characters containing lower case characters words delimited underscores 
example interaction named attribute mapped package named attribute interaction named mapped package named media stream interaction named mapped package named rtp control 
classes interaction package prepended name interaction 
text rest section show name prepended class names keep names short clear shown corresponding uml diagrams specific interaction types 

message interfaces midas syntax java mapping typedef string typename typedef typename root type string typedef typename root type string struct major minor table 
midas typedefs mapped java public class public string major public string minor provided required message interfaces midas interaction translated java interfaces named respectively 
message message set translated method appropriate interface parameter message translated argument message 
meth ods interface take back binding client additional parameter 
method message interface throw exceptions type regent transport 

mapping midas java errors caused transmitting messages java io ioexception report errors caused marshalling mes sage allow threads sending message interrupted blocked waiting binding completed resources available 
java message interfaces include house keeping methods 
unbind method message called binding closed peer 
methods provide access control interfaces binding allowing components query configure parameters protocols implement binding 
midas syntax java mapping interaction attribute type provide messages get set value require messages update value setack 

endpoint stubs message interfaces implemented base classes provide support implementation interaction objects 
class base class programmers derive service side endpoints 
class implements interface interaction implement methods interface leaving implementation derived classes 
implements regent interact interface provides methods attaching service access points endpoint available network 
package attribute public interface void getvalue client throws void setvalue object value client throws void unbind client class public interface void update object value throws void setack throws void throws void unbind class table 
message interfaces generated midas interaction 
mapping midas java class acts base class programmers derive client side endpoints 
class implements interface interaction class leaves implementation methods interface derived classes 
class responsible maintaining interface service endpoint bound 
initially refers singleton member class named unbound im interface throwing exceptions methods called 
bound passing bind method 
interface binding available derived classes protected method named binding 
classes illustrated 
interface attribute interface get set value object get set value object binding interface update value object setack 
classes attribute interaction type bind binding interface object update value object setack classes provide implementation method message interface returns null 
control interfaces available direct binding address space 

support third party binding 
mapping midas java message interfaces implemented client side binder objects support third party binding shown 
binder implements interface holds binding interface 
threads calling operation interface binder blocked binder bound 
bound calls interface binder delegated binding 
allows components execute concurrently binding service performing binding operations components receiving errors endpoint bound 
binder implements interface delegating calls bound 
attribute binding interface get set value object interface object bind 
binder class generated attribute interaction 
proxies service access points saps interface update value object setack client interaction definition translated classes support distribution transparency 
inheritance separate concerns presentation layer translation messages represented octet sequences transport layer protocol messages transmitted proxies 
base classes encapsulate presentation layer marshalling 
proxy stub class implements message interface message interface peer interaction 
proxy stub implements method message interface marshalling identifier message arguments transport level buffer passing buffer protected method named transmit 
responsibility derived classes implement transmit method transmit buffer peer proxy transport mechanism 
proxy stub classes define protected method named receive takes transport level buffer argument message identifier arguments buffer invokes appropriate method peer message interface holds 

mapping midas java concrete classes gener ated provide bindings connection oriented transport protocols tcp ip 
connection proxy classes extend proxy stub classes interface regent transport framework described detail chapter 
connection proxy implements regent transport interface transport connection delivers messages holds regent transport connection protocol messages transmitted 
protected transmit method declared proxy stub base class implemented transmit message connection delivery messages connection handled passing protected receive method defined base class 
connection proxies implement unbind method closing connection react connection closed calling unbind method message interface hold 
implement method querying protocol stack requested control interface 
binding connection oriented transport protocols supported class 
created service endpoint order endpoint available specific connection oriented protocol 
constructor class takes endpoint textual description stack arguments 
elaborates stack description server side stack listen accept connection requests 
receives connection request accepts connection request getting stack new connection result creates new pushes new proxy stack 
object address available object 
encapsulates address protocol endpoint textual description protocol stack 
binding performed passing service client created 
class constructor takes arguments elaborates stack description create client side stack uses interface stack establish connection remote 
client endpoint bound service proxy complete binding 
attribute interface get set value object get set value object transmit receive 
objects 
generated classes implement distribution transparency 
mapping midas java midas interaction type corresponding class identifies service endpoint inter action multiple protocols list objects 
endpoint obtained calling endpoint method 
class supports marshalling genericity uses interaction type midas data structure definition translated interaction generated java data structures 
midas syntax java mapping struct attribute attr service endpoint saps transport interface transport creates transport public class public attribute attr table 
midas interaction instance mapped java 
client interface update value object setack update value object setack transmit receive 
additional mappings interaction types 
mapping midas java additional back ends midas compiler generate optional support classes interaction definitions 

reified messages endpoints synchronise threads component need queue messages receive handled component threads 
requires representing messages objects 
writing classes objects tedious backend midas compiler provided generate classes reified messages midas interaction definitions 
class generated message hold arguments message 
message class extends ab base class base class provided messages interaction required messages 
allows programmer take advantage java strong typing wish queuing processing messages endpoint implementation need pass untyped object 
message classes defined nested inner classes base class 
name message class de fined name midas message character capitalised 
public class public void dispatch subject throws 
public static class setvalue extends java lang object value client public setvalue java lang object value clt value value client clt public void dispatch subject throws subject setvalue value client 
reified message classes attribute service message interface message needs dispatched endpoint determine type message 
store identifier message base class force client code perform type cases value identifier message classes visitor pattern ghjv base class defines dispatch 
mapping midas java method takes client service message interface concrete message classes implement dispatch method calling corresponding operation message interface 
combined anonymous inner classes provides type safe equivalent java switch statement type message 
void msg 
dequeue message 
try msg dispatch new public void setvalue object val clt handle setvalue message 
public void getvalue clt handle getvalue message 
catch ex ignore regent exceptions know thrown 
example usage anonymous inner class dispatch reified messages 
datagram proxies saps default back midas compiler generates distribution support proxies saps uses connec tion oriented transport protocols 
allows greater control transport protocol individual bindings transport protocol provide control interfaces qos parameters configured binding binding basis 
connection oriented protocols disadvantage transport level connection established application level binding involving ad ditional round trip communication client server 
additional back midas compiler generates proxies saps datagram oriented connection oriented protocols 
useful bindings transport level control required 
datagram proxies saps usually reliable datagram protocol 
transport framework described chapter provides components composed create reliable datagram protocol bounds tcp protocol implements reliable connection oriented protocol maintains message boundaries 
reliable connections implemented layering appropriate components udp frag rel cod udp see section description protocol components 
doc protocol routes datagrams connections 
doc layer maintains table outgoing connections indexed address remote peer connection 
datagram transmit ted destination address look connection table 
connection datagram transmitted connection new connection created remote address added table datagram transmitted connection established 
ing connection period time removed table closed 

mapping midas java protocol multiplexes multiple datagram protocols single underlying datagram protocol 
reliable datagram protocol suitable datagram proxies saps implemented stack doc bounds tcp 
stack shares single tcp server socket endpoints protocol uses single outgoing single incoming tcp connection transmit messages address spaces 
tcp connections created demand torn idle 
behaviour method corba iiop omg uses tcp protocol transmit object requests address spaces implemented combining reusable transport components 

generic types midas allows definition generic types structures interaction types parameterised primitive user defined types 
java contrast support generic types class definitions parameterised 
possible ways map generic midas types java 
run time type identification midas compiler generate objects represent manipulate type information run time 
type objects parameterise instances java classes generated generic midas declarations 
message parameters fields user defined types generic parameter type represented object root java inheritance hierarchy type objects java run time type information enforce type compatibility values 

instantiate generics midas compiler backend midas compiler instantiate generic types generating java classes representing generic type parameterised set type arguments 
advantage option better performance achieved run time type information avoided type information available java compiler catching type errors earlier development process 
code generated java class generated instantiation generic midas type increase download times java applications served network 

different language strive compatibility java language achieve compatibility level java byte code 
midas compiler generate code variants java support genericity mbl gj 
option advantage code generated type information available compiler 
variants java widely java supported lagging versions latest java development kit 

mapping midas java third option language acceptable maintain source code com java 
reduces ability take advantage programmers familiarity java language existing tools manipulate java source code document generators integrated development environments 
third option instantiating generic types midas compiler acceptable complicates development process developers components increases download times great disadvantage considering ability download code main reasons java widely 
midas compiler generates run time type information support genericity 
midas types repre sented runtime objects extend class regent interact type shown 
run time type information points distributed system 
node safely downcast untyped values 

proxies marshal values network messages 

check compatibility bindings endpoints address space 
java supports safe downcasts instanceof cast operators detailed type information available reflection api clk 
type information generated midas need concerned marshalling unmarshalling checking compatibility bindings endpoint objects need type objects generated midas definitions 
java dynamic typing ensure user defined generic types correctly component implementations 
method type class check variable type assigned value described type object 
write method takes stream untyped object checks object correct type writes binary representation object output stream 
read method reads value type stream returns value untyped object 
public class type public boolean type public void write object data throws ioexception public object read throws ioexception 

type class definition 
mapping midas java type objects representing primitive midas types defined static constant members regent interact type class 
type objects marshal primitive types held standard wrapper classes defined java lang package 
convenience type objects numeric values expect exact type wrapper object write method accepts class derived java lang number class numeric wrapper classes derived 
read method instantiates objects ap java wrapper class java run time type checks 
primitive type type object type type boolean boolean java lang boolean java lang boolean octet octet java lang number java lang byte short short java lang number java lang short unsigned short java lang number java lang short long long java lang number java lang integer unsigned long java lang number java lang integer long long java lang number java lang long unsigned long long java lang number java lang long float float java lang number java lang float double double java lang number java lang double char char java lang character java lang character string string java lang string java lang string table 
type objects representing primitive types 
mapping midas java struct union interaction type defined midas specification midas compiler generates static final member holds type object anonymous nested class 
read write methods type objects delegate static read write functions generated class performing run time type checks ensure type compatibility 
struct class 
midas declaration generated java code public static read 
public static void write data 
static final type type new type public object read 
return read public void write object 
try write catch throw new regent interact table 
type object generated user defined type generic user defined types interaction types compiled java classes hold values type parameters untyped object 
responsibility code uses generic types ensure correctly typed data stored fields standard java mechanisms run time type identification 
instances generic data types contain untyped values type objects representing generic parameters data type needed marshal generic data values 
type objects passed extra parameters static read write functions generated midas compiler 
similarly type object representing instantiation generic data type hold type objects representing instantiation parameters 
generic user defined types define private nested class named type represents type instantiated user defined type 
instances type store type objects representing parameters generic type 
instances type class available client code factory function named type takes type parameters arguments constructs new instance type class 
anonymous singleton type objects generated non generic type 
mapping midas java definitions multiple instances type exist time type class defines equals hashcode methods allow comparison type objects java hash tables user defined generic data structures generic interaction objects store type parameters lifetime 
necessary interaction objects pass typed data address spaces call marshalling unmarshalling functions generated midas compiler passing type objects functions necessary 
type parameters interaction object provide information marshal data type argument message interaction 
marshalling code generated generic user defined type shown table 
generic interaction objects type parameters available objects interface regent interact generic 
allows proxy sap objects obtain type objects necessary marshalling values interaction object parameter types 
regent interact class implements generic interface storing type 
proxy sap objects extend class regent interact implements generic interface delegating calls generic object proxies saps delegate interaction object associated 
relationships illustrated uml diagram 
parameters interface type read write generated type equals object boolean hashcode int parameter int int type interface generic int int type 
classes supporting generic types master int int type endpoint struct type generic field class object generic field 
midas declaration generated java code public static read type 
public static void write data type 
private class type extends type private type type type public boolean regent interact type return instanceof type type public object read 
return read 
mapping midas java public void write object 
try write catch throw new regent interact public int hashcode return hashcode public boolean equals java lang object return instanceof type equals type public static type type type return new type table 
genericity support generated midas specification 
summary 
mapping midas java chapter described interaction model midas language features described chapter mapped features java language 
midas translated java classes support distribution transparency binding 
principle increasing flexibility separating concerns support generic interac tion protocols binding presentation layer marshalling transport layer communication separated replaced modified programmer required 
flexibility provided regent transport framework allows dynamic construction transport protocols allowing services take advantage new transport protocols available clients dynamically load protocols required service priori knowledge protocols 
regent transport framework described detail chapter 


transport protocol framework transport protocol framework particularly hard divide small jobs 
henry ford proxies saps application layer interaction protocols access transport protocol services regent transport framework 
framework distinguished main features platform independent hiding native networking apis host operating system cross platform object oriented abstractions component allowing transport functionality implemented composition lightweight protocol components dynamic allowing protocol components loaded composed runtime 

requirements transport subsystem transport subsystem flexible middleware platform meet requirements platform independence 
different operating systems transport protocols provide available different programming interfaces 
example microsoft windows provides qs netbios apis functions win api microsoft protocols unix variants provide socket apis steve 
different apis need encapsulated cross platform api allow code uses framework executed different platforms 
independence higher layer protocols 
transport framework designed support midas communication endpoints important separately need 
allows programmers components different presentation application layer protocols corba giop omg gain benefits provided transport framework allows transport framework integrated application specific apis java media framework 
composition 
typical transport protocol tcp implemented single monolithic component 
implementations provide guarantees required application implementation guarantees adverse effect performance 
exam 
transport protocol framework ple tcp provides multiplexing order reliable delivery 
reliable delivery required configure tcp provide multiplexing order delivery 
furthermore necessary compose functions compression security existing protocols 
necessary encapsulate individual protocol mechanisms components allow application compose achieve required functionality 
common interface 
allow maximum reuse protocol components components conform interface component layered 
allow creation invalid protocol stacks development strong typing avoid invalid stacks severely limited ability reuse generic layers resulted large amounts duplicated code 
higher level mechanisms help developers create valid protocols gs 
dynamicity 
protocols required binding depend relative location components binding 
located host shared memory efficient local ipc mech anism 
located physical network protocols internetworking avoided 
separated private internet stack contain layers provide fragmentation reassembly messages reliable delivery 
separated untrusted network additional layers providing encryption authentication may necessary 
location components decided run time components launched 
system able load compose protocol components stacks required binding depending run time information 
servers need describe composition stacks clients build com stacks binding 
manageability 
stack support management 
breaks requirements 
firstly possible examine modify parameters controlling operation stack invoke control operations stack 
secondly stack provide way management agents receive tion important events occurring stack 
example events notification connection failed qos available network fallen threshold 
discussed section transport protocol framework fully meets requirements 
chapter describes transport framework developed address issues 

overview fundamental abstractions transport framework protocol graph protocol layers services upcalls 
data routed network devices communication endpoints graph proto col layers 
layer object implements protocol functionality 
layer provides data transmission services higher layers require services lower layers 
service requirements represented upcall interfaces 
upcalls bound services bound data passed stack 
transport protocol framework service interface lower layer passed stack upcall interface higher layer 
component model matches darwin language darwin graphical notation represent configurations protocol layers 
control protocol layer provide control interfaces composed tributes control operations higher layers control operation protocol 
control interfaces export events higher layers 
notified events occurring beneath stack protocol layer implement compatible event listener interface register interface called back events occur 
model attributes events control interfaces java beans component framework chap 
stacks constructed instantiating layer objects binding required services higher layers services provided layers 
requirement layer bound layer queries layer providing bound service control interfaces requires registers event callbacks 
request control interface met layer directly request passed stack layer implements interface bottom stack reached 
chain responsibility ghjv fold benefit firstly increases reusability protocol implementations layer need know implementation details stack layered secondly improves performance allowing configuration requests event notifications bypass layers interested 
protocol configuration need linear protocol graphs structured tree 
graphs layers responsible multiplexing data transmitted multiple higher layers protocol provided single lower layer 
regent transport framework multiplexor normal protocol layer interface layer graph 
higher layer bound service multiplexor mul instantiates hidden session layer implements service provides service interface session higher layer 
session encapsulates addressing information protocol state client 
rate service upcall event 
protocol layer interfaces important classification protocol layer virtual protocol 

protocol layers composed stack showing control protocol layers modify messages passing 
event connections add headers outgoing messages remove headers incoming messages completely transform message contents compression encryption virtual protocols hand modify messages passing 
virtual protocols perform monitoring crypt rate cx 
transport protocol framework data flowing stack perform management actions response measured activity 
ex amples virtual protocols include layer measures qos levels available application layer performs leaky bucket traffic shaping 
stacks communicate non virtual protocols stack order stack 
presence absence virtual protocols stack affect stack compatibility 
virtual protocols may inserted stack individual nodes application order perform monitoring management affecting nodes communicate 
client session client session 
session layers created multiplexor clients 
implementation protocol layers protocol layer stack java object conforms regent transport interface shown 
public interface address class control class string string name object discriminator throws string string name object discriminator throws void address reader throws ioexception address input throws ioexception mux client session 
interface definition 
transport protocol framework interface provides methods enumerate services upcalls protocol layer 
method returns array containing names services provided layer 
services acquired method 
method takes name service parameter returns interface service name parameter null service returned considered default layer 
layer multiplexor new session layer instantiated default service session returned 
discriminator argument request session specific protocol discriminator left null multiplexor assigns unique discriminator new session 
similarly return names upcalls required layer interface named upcall respectively 
method returns address object uniquely identifies layer object address space protocol implements 
layer addresses externalised textual strings raw binary data method reads textual address stream characters reads binary address stream bytes 
methods throw indicate stream contains invalid representation address type layer 
run time representation addresses described section 
method query layer control interfaces 
method takes class object representing required control interface argument 
layer support requested control interface pass request layer return null bottom stack 
maximise ability reuse protocol layers number standard control event interfaces defined support common protocol types options active passive connection establishment quality service management error handling 
standard control event interfaces defined package regent transport controls 
user defined control interfaces extend tag interface regent transport 
allows class find layer control interfaces reflection 
similarly user defined event listener interfaces extend interface regent transport 
interfaces regent transport regent transport define interactions bound service upcall 
attach methods interface bind layers stack binding established upcall service passing upcall attach method service passing upcall attach method service 
data passed stack calling transmit method service passed stack calling receive method upcall 
transmit method throw exceptions report errors detected immediately receive method throw exceptions avoid disrupting system threads responsible receiving data devices 
incoming outgoing data passed layers buffer address objects encapsulate efficient memory management algorithms memory management issues addressed detail section 

transport protocol framework release method interface upcall bound service 
call release data transmitted service data delivered upcall detached 
multithreaded nature transport framework data passed receive method associated upcall processing release method concurrency issues addressed detail section 
services layer released layer longer needed destroyed 
typically involves releasing services layers beneath freeing resources threads device handles 
public interface void attach upcall throws void transmit data address throws void release 
interface definition public interface void attach service throws void receive data address sender 
interface definition described multiplexors require special processing protocol stacks constructed names virtual protocols removed stack descriptions passed nodes possible identify layer multiplexor virtual 
tag interfaces identify multiplexors virtual protocols multiplexors implement regent transport multiplexor virtual protocols implement regent transport 
interfaces empty provide operations java run time type identification reflection api inspect layer object class determine layer implements interfaces multiplexor virtual 
implementing component packaging defined interface new protocol layer tedious error prone 
implementation provided form class uses java reflection api clk determine services upcalls control interfaces derived layer simple coding conventions 
implementation interface examines class instantiated layer object 
public instance variables holding objects derived assumed upcalls layer 
layer multiplexor tagged multiplexor interface public instance variables layer hold objects derived assumed services provided layer 
layer multiplexor services assumed defined instance variables hold support interface shown 
service requested multiplexor implementation calls method appropriate 
transport protocol framework create new session layer returns default service session 
control inter faces querying class see derived interface class passed method layer returned 
public interface object discriminator throws 
interface definition protocol layer implement service upcall interfaces ways 
simplest restrictive layer object implement interfaces directly addition interface store public member variables accessible implementation 
restrictive layer service upcall 
alternatively layer uses auxiliary objects implement interface delegate calls interfaces non public methods layer object 
approach greatly simplified anonymous inner classes introduced java version 

memory management empirical studies shown major contributing factor latency middleware frameworks excessive data copying performing marshalling protocol processing gs 
highly layered protocols exacerbate problem passing data layers processing messages piecemeal protocol component adds header messages passed stack removes header messages passed stack 
applications stack know priori exact composition stack memory requirements individual layers allocate message buffers exactly right size 
transport framework passes data layers objects provide efficient mechanisms constructing processing messages piece piece 
framework basic unit memory management chunk 
contiguous read sequence bytes 
chunk read shared protocol layers threads 
allows message chunks buffered different layers stack delivered endpoints address space copying synchronisation overhead 
buffer object stores sequence chunks data structure allows chunks efficiently appended sequence 
vital presentation layer write data tail buffer marshalling messages transport layers add headers front buffer 
buffer objects hold sequence chunks provide support efficiently allocating memory headers message payload reading data chunks sequence 
presentation transport layers buffers pass data build access memory stored buffers wrapper objects act streams perform efficient memory allocation 

transport protocol framework buffers passed stack transmission objects 
objects support efficient allocation management memory message headers provide methods writing formatted data headers 
object maintains array bytes headers written 
new headers allocated calling method takes size header bytes returns stream write formatted data header 
header array full pushed head encapsulated buffer new header array twice size allocated 
transmitted encapsulated buffer acquired calling method 
flushes headers header array front encapsulated buffer returns raw data accessed 
method allows converted support efficient short circuited delivery data address space 
buffers passed stack delivery application objects 
objects support efficient removal message headers provide methods reading formatted data headers 
maintains index unread chunk byte chunk head encapsulated buffer 
derived inputstream bytes read connected formatted data read head buffer 
inputstream read hdr buffer buffer write buffer buffer size int head capacity int tail capacity int 
static structure memory management classes buffers usually created object conforms standard java outputstream interface streams data buffer 
respect class part standard java library 
streams data contiguous byte array 
creates single byte array periodically copy streamed data grow array 
copying causes considerable overhead especially array sized arith geometrically 
comparison copy streamed data 
new space needed new chunk allocated appended buffer 
array chunks chunks header offset int header length int write current header outputstream chunk offset int length int hdr data byte 
transport protocol framework buffer full new array constructed chunk copied 
chunks stored data copying overhead copying data 
additionally size chunk allocated array chunks buffer grown geometrically overhead grows logarithmically amount data written stream 
amount time taken write various sized arrays bytes shown constant overhead caused jvm loading stream classes instantiating stream objects performing garbage collection 
time msecs 
time taken write data 
addressing layer stack unique address identifies layer network 
address protocol layers communicate identified layer identified layer datagram protocol address destination messages transmitted connection oriented protocol address establish connections 
addresses created acquired ways 
protocol layers create address objects identify 

protocols layers construct address objects data received message headers identify sender message 
data size 
address objects internalised external form textual string octet sequence communicate address band medium mail address web page payload network message 
due composite dynamic nature protocol stacks impossible know priori structure address fixed size data structure hold address information berkeley sockets api steve 
addresses accessed address interface shown 
transport protocol framework addresses compared hash table serialised external form trans lated back address time 
internal implementation serialised representation address object known implementation protocol layers created 
public interface address extends java io serializable void write java io output throws java io ioexception string tostring boolean equals object int hashcode 
address interface atomic address object refer address objects identifies root tree protocols 
multiplexors create composite address objects identify sessions create composed protocol discriminator session address multiplexor typically address layer session stacked 
filter session address mux session address 
immutable address objects shared address objects immutable 
property allows address objects shared composed individual address objects modified impossible invalidate composite address object modifying components 
immutability removes need copy address data layer address object referred directly composite addresses layers protocol layers threads performing computation address danger interference 
furthermore addresses immutable shared threads synchronisation overhead 
addition creating address objects identify protocol layers create address objects identify source messages pass stack 
addresses initialised header fields messages received 
message transmitted stack multiplexor session stack adds header front 
transport protocol framework message contains information identifier session 
message received multiplexor removes header message uses session identifier field construct address object routing message session 
multiplexor root tree layers creates atomic address 
multiplexors higher stack receive message layer create composite address containing session identifier address passed layer 
headers message body address address address 
address objects constructed header fields received messages communication take place address receiver passed sender band mechanism 
requires externalisation internalisation address objects 
possible java serialisation java serialisation result unnecessary space overhead inhibit interoperation code written languages 
address objects protocols provide support serialisation address objects binary textual format reconstruction address objects serialised data 
address interface provides support externalisation address binary data textual string 
write method writes address octet sequence stream 
octet sequence serialised address protocol discriminators define address discriminators lower layers pre higher layers exact format individual discriminators defined layer 
tostring method converts address string 
address strings protocol discriminators separated colon characters discriminators lower layers preceding higher layers format discriminators defined layer 
internalisation address objects supported interfaces 
interface provides method address format stream method parse address character stream supports characters 
layer composite address format address object create create create 
transport protocol framework addresses calling layer beneath reading proto col discriminator constructing composite address object 
layers define address format filter protocols delegate calls layers beneath performing extra processing 
constructing protocol stack significant overhead layers stack allocate system resources threads operating system handles 
overhead wasted stack constructed solely address discarded 
interface provides methods addresses format protocol created factory need instantiate stack 
methods perform task method interface name 
protocol factory know layer creates going stacked delegate factory parts composite address 
methods interface take additional address parameter holds address internalised layers beneath factory layer 
factory creates composite address reads protocol discriminator protocol creates new composite address discriminator address parameter passed method 

connection oriented protocols interfaces provide adequate interface datagram oriented protocols 
data transmitted stack prior communication sender receiver 
connection oriented protocols establish connection data transmitted 
connection oriented protocols usually asymmetric server side stack passively waits connections re quests client side stacks send connection requests establish connection 
application interface roles provided control event interfaces 
control connection including initiating active connection establishment provided interface shown 
connect method establish connection server takes parameters address server optional buffer data sent connection request 
connection establishment asynchronous calling connect higher layer wait informed connection successfully established sending data 

transport protocol framework public interface extends boolean void connect address data throws void close data throws void listener void listener public interface extends void data void data void 
control event interfaces manage active connection setup tear state connection monitored registering interface method interface 
connection protocol inform listeners state connection changes calling methods listener interface 
method signal connection establishment successful data transmitted 
protocol pass optional parameter contains additional data passed endpoints connection setup time 
connection refused server method listener interface called optional buffer data 
server contacted method listener interface called 
connection actively closed calling close method takes optional data sent close request 
connection establishment closing connection happens 
successful active close passive close connection closed peer reported method interface 
passive connection establishment performed interfaces shown 
protocol performs passive connection establishment waits connection requests client announces requests higher layer 
higher layers register interface interface server side stack 
connection requests passed method interface objects implement interface 
interface provides methods request accepted refused address peer queried optional buffer connection setup data retrieved 

transport protocol framework public interface extends void throws java util void public interface extends void rq public interface accept reply throws getdata address void refuse data throws 
control event interfaces manage connection acceptance connection request accepted stack created new connection interface layer top stack returned acceptor 
stack connected state transmission immediately 
accepted stack provides control interface state accepted connection monitored controlled 

transport filters common form protocol acts filter monitoring transforming data flows 
filter protocols common worth providing special support implementation 
class extends single service upcall provides default implementations interfaces pass data filter unchanged derived classes need redefine methods transmit receive perform filter processing 
special handling required filters connection oriented protocols 
client side connection filters expected 
filters specified part server side stack get layered stack receiving connection requests stacks accepted connections 
handle situation class acts prototype ghjv part server side stacks cloning new connection accepted pushing clone top stack new connection 
attach method upcall interface queries service attached interface 
interface returned filter knows part server side stack registers receive connection requests layer provides interface layer 

transport protocol framework connection requests handled wrapping received request object passing registered filter interface 
accept method object invoked accepts wrapped connection request clones filter created pushes clone filter stack accepted wrapped request returns top resulting stack caller 
objects call method filters create clones 
method declared class defined derived classes 
cloning filter copy state filter queried modified control interfaces filter connections listener interfaces 
allows application elaborate server side stack containing transport filters configure filters meet application qos requirements 
stacks accepted connections contain filters required parameter settings 
interface attach receive interface attach transmit 
static structure classes number useful transport filters implemented part regent package including shown table 
name function interface interface frag transport filter fragments large messages smaller fragments 
expects layered reliable order connection oriented protocol 
rel transport filter provides reliable connection establishment sequenced inorder delivery messages 
expects layered unreliable protocol cod 
table 
example transport filters listener lower name function 
construction protocol layers 
transport protocol framework compression transport filter compresses transmitted messages deflate algorithm rfc reduce bandwidth requirements 
rate transport filter limits rate transmission leaky bucket algorithm 
packets transmitted rate discarded 
transport filter secures reliable order connection needham schroeder private key exchange protocol schneier 
transport filter uses pool threads deliver messages 
message delivered filter placed queue 
threads filter remove messages head queue deliver stack 
increase level concurrency stack improve performance endpoints share multiplexor 
local datagram protocol routes messages address space 
really useful debugging protocol layers 
log transport filter logs size messages sent received 
really useful debugging protocol layers 
error transport filter throws away messages configurable probability 
really useful debugging protocol layers 
table 
example transport filters possible directly instantiate java classes implement protocol layers useful decouple implementation protocol name protocol program 
allows different implementations different platforms trusted untrusted code 
decoupling achieved dynamic linking factories instantiate protocol layers 
public class public public class public address address addr throws ioexception public address address addr throws ioexception public static void register string name factory public static void remove string name public static get string protocol name throws public static string string protocol name throws public static enumeration 
class 
transport protocol framework protocol layers created factory objects derived class shown fig ure 
type protocol layer known system short textual name tcp udp 
class maintains static table mapping names factory objects 
factory name acquired get function 
application explicitly register factories name calling register function remove mappings calling remove function 
explicitly registering protocol implementations way little better directly instantiating protocol classes protocol namespace fixed program modified different protocols 
get function uses dynamic linking locate factory class named protocol load jvm 
get function maps name protocol package name loads class named factory package creates instance loaded class returned caller 
reduce time taken obtain factory protocol class maintains static table factories indexed protocol name 
dynamic loading factory required protocol table factories loaded dynamically added table returned caller 
protocol name mapped package name searching list root packages sub package name protocol contains class named factory 
list root packages obtained querying value transport protocol path property database properties configure regent system 
implementation protocol packages protocol path package regent transport protocols searched 
fails error reported caller throwing exception 
access mechanisms provided parts system static functions 
function returns java package contains implementation named protocol 
function returns enumeration root packages protocol implementations may 
java system properties specified command line modified run time allowing appli cation protocol search path specified started changed runs 
protocol factory classes loaded jvm normal java mechanisms protocols loaded local filestore network servers available protocols changed execution application installing packages removing packages locations searched class loader 

automatic stack elaboration large distributed system impractical applications statically define protocol configurations 
systems adapted lifetimes fix programming errors meet changing requirements take advantage changes environment 
large client server system clients 
transport protocol framework deployed changing server component new protocols invalidate clients configured old protocol stack 
servers able describe stack making services available clients able dynamically build compatible stack description 
regent transport framework supports dynamicity standard naming scheme protocol stacks naming conventions followed layers stacked automatically functions load com pose protocols match named stack 
protocol stacks named path notation commonly name internet protocols 
stack description list layer names separated backslash characters 
layers listed top bot tom stack 
example tcp ip describes stack consists tcp layer stacked ip layer 
class responsible elaborating stack description 
parses stack description locates instantiates layer composes layers stack connecting services upcalls adjacent layers 
uses naming conventions determine upcalls services attached pushing layer stack 
iterates upcalls layer pushed upcall name mapped naming convention possible service names attached 
tries potential service name turn finds service provided top stack 
attaches upcall service 
upcall supported naming convention services available attached upcall exception thrown report error 
different types stacks different naming conventions allow filter components stacked appropriate multiplexor sessions 
example client side connection oriented stack need stack filters sessions created connect service service side stack need stack filters ses sions created listen service 
naming conventions names stored regent properties database 
stack description elaborated naming convention attaching layers passed loads convention properties database caches 
standard naming conventions defined client building client side connection oriented stacks server building server side connection oriented stacks connectionless building datagram oriented stacks accepted building stacks connections accepted listening server 
uses algorithm elaborate stacks 
algorithm augments existing protocol graph stacks instantiated existing multiplexors possible keeping track multiplexors created reused stacks 

find highest multiplexor instantiated stack 

transport protocol framework maintains table multiplexors indexed stack name 
allows build requested stacks pushing layers sessions existing multiplexor instantiating new instance multiplexor class 
instantiating stack description iteratively looks multiplexor stack description removing name description trying multiplexor multiplexor names left stack description 
example instantiating stack compression bounds tcp tries find multiplexor named compression bounds tcp bounds tcp tcp 

multiplexor load base stack 
base stack loaded trying load protocol name stack description 
loaded tries load protocol implements compound protocol names iterates protocol loaded names stack case exception thrown 
base stack multiplexor added multiplexor table 
example instantiating stack compression bounds tcp tries load tcp bounds tcp compression bounds tcp 

remaining name instantiate named layer push stack 
remaining layer added stack instantiated attached top stack naming convention passed parameter 
layer multiplexor added multiplexor table 

protocol registry protocol layers support upwards downwards interfaces 
allows great flexibility constructing stacks layer stacked 
downside invalid stack configuration caught compile time 
invalid configurations caught stack constructed higher layer obtain control interface needs layer lower stack 
stack fail silently cause obscure errors communication 
designing valid stack requires knowledge behaviour components stack resultant combination 
rule thumb protocol components designed perform single medium grained element protocol functionality handling connection setup providing reliability unreliable connection protocol routing datagrams underlying connections compressing decompressing 
transport protocol framework messages 
design guideline easier predict behaviour combinations protocol components 
programmers find easy understand protocol components select achieve properties require binding 
alleviate problems transport framework provides protocol registry maps human readable names stack configurations 
allows experienced engineers design stacks provide specific properties assign meaningful names experienced programmers integrating components 
mappings protocol registry accessed static methods class regent transport 
name stack mappings registry stored file available web 
url file specified regent properties database configure regent installation 
program maps name stack description name description pairs protocol registry loaded web stored local cache 
scalability registry achieved existing web cache proxies replicate protocol registry various points enterprise network 
encapsulating registry lookup class implementation changed distributed relational database example needing modify recompile code uses registry 
stack descriptions obtained protocol registry elaborated algorithm described section 
endpoints stack named protocol registry contain description stack convenient name remains valid stack assigned name changed lifetime endpoint 

concurrency synchronisation 
transport protocol framework protocol framework uses multiple threads control 
system threads carry data timer notifications stack devices application threads carry data stack application components 

threads protocol stack access protocol state layer serialised avoid corrupted data lost updates inconsistent analysis 
threads may concurrently traverse graph layers opposite directions simply locking layer cause deadlock race conditions 
elaborate locking strategy layers stack 
layer needs protect state concurrent access implement locking strategy threads travelling stack release locks higher layers acquiring locks lower layers 
threads travelling stack release locks lower layers acquiring acquiring locks higher layers 
user layer releases layer layer release lower layers owns free ing resources allowing garbage collector destroy 
protocol layers block calling threads monitor condition variables call wait method object class 

available protocol components application protocol stack devices table describes protocol components implemented transport framework name function 
transport protocol framework tcp device layer provides interface tcp ip protocol implementation host operating system 
udp device layer provides interface udp ip protocol implementation host operating system 
versions udp layer provided interfaces standard java networking apis java net package uses native methods interface api windows 
implementation selected runtime protocol loader described section 
native implementation provided java net package provides poor support upcall driven style protocol implementation memory management buffers regent transport framework 
specifically java net class support scatter gather allow program query size datagram head socket receive queue 
multiplexor allows multiple higher layers single datagram oriented protocol 
cod simple connection oriented protocol implements connections datagram oriented protocol udp 
cod connections unreliable reliability layered cod protocol 
doc datagram oriented protocol uses underlying connection oriented protocol route datagrams address spaces establishing new connections necessary closing connections fall idle minimise resources 
layering cod layer doc layer multiple lightweight connections multiplexed individual heavyweight connections address space 
useful processes limited number operating system resources tcp ip sockets 
multiplexor multiplexes multiple lightweight connections multiplexed individual connections lower connection oriented protocol 
protocol implemented composite component composed cod layer doc layer 
frag transport filter fragments large messages smaller fragments 
expects layered reliable order connection oriented protocol 
rel transport filter provides reliable connection establishment sequenced inorder delivery messages 
expects layered unreliable protocol cod 
compression transport filter compresses transmitted messages deflate algorithm rfc reduce bandwidth requirements 
rate transport filter limits rate transmission leaky bucket algorithm 
packets transmitted rate discarded 
transport filter secures reliable order connection needham schroeder private key exchange protocol schneier 
table 
protocol components name function 
summary 
transport protocol framework transport filter uses pool threads deliver messages 
message delivered filter placed queue 
threads filter remove messages head queue deliver stack 
increase level concurrency stack improve performance endpoints share multiplexor 
local datagram protocol routes messages address space 
really useful debugging protocol layers 
log transport filter logs size messages sent received 
really useful debugging protocol layers 
error transport filter throws away messages configurable probability 
really useful debugging protocol layers 
chapter transport framework regent middleware platform shown meets requirements set section 
platform independence supported definition interfaces transport protocols acquired 
interfaces independent tation application layer protocols making transport 
transport framework supports compositional approach construction transport protocol software 
protocol components implement interfaces composed arbitrary directed graphs data flows 
address objects hide composite nature implementation interface supporting externalisation internalisation address information 
control interfaces allow configuration protocol parameters notification significant events manner hides exact configuration stack controlled definition generic control interfaces dif ferent protocols supports operation generic stack management agents 
factories dynamic linking load protocols jvm demand allows distributed system components evolve separately remain able communicate loading required protocols demand 
standard naming schemes protocols textual addresses allows composite protocols named stacks generated names demand 
protocol registry allows convenient names assigned useful stack configurations experienced programmers need know deal full complex ity transport framework 
table 
protocol components transport framework includes classes provide efficient memory management 
section compares performance classes memory management classes provided java standard library 
performance analysis transport framework midas interaction model described chapter 

performance analysis 
performance analysis promise perform 
previous chapters shown midas underlying runtime frameworks provides great deal flexibility system architect 
architect design system composed components different interaction styles specify transport protocols interactions carried compositions lightweight components 
binding model allows monitoring management functionality inserted bindings interaction filters formal models midas specifications automatically translated filters testing component endpoint implementations 
issue flexibility affects performance addressed 
chapter describes set experiments compare performance midas existing middleware platforms 
experiments demonstrate performance adversely affected additional flexibility provided component interaction model runtime system 
experiments show performance improved judicial selection interaction style transport protocol components 

comparing middleware platforms chapter compare latency throughput application written java different middleware solutions midas synchronous message passing protocol providing similar functionality tcp ip 
java rmi remote object invocation tcp ip protocol 
java corba remote object invocation corba iiop protocol 
application experiments consists single server provides file service clients open service send sequences octets close service 
single client open service time clients wishing open service blocked current client closed service 
ex 
performance analysis periment comprises multiple iterations client opens server transmits blocks data closes server 
client sends larger blocks data iteration octets long octets 
client times duration issuing open request receiving close request 
iterations performed starting record timing measurements order reduce variations timing caused dynamic class loading just time compilation memory allocation garbage collection 
experiment executed machines running red hat linux connected lightly loaded mbit switched ethernet 
server run machine mhz pentium pro processors mb memory client machine single mhz pentium pro processor mb memory 
service implemented object corba rmi implementations interfaces 
module perf module corba corba java rmi typedef sequence octet block interface void open void data block block void close midas version implements client server components single threaded active objects 
server provides synchronous message ports open close 
client requires message ports open close bound service shown 
message port interaction port generic interaction template supplied part runtime library instantiated client server components parameterised types message passed 
perf perf package perf rmi import java rmi public interface extends remote void open throws void data byte block throws void close throws table 
corba rmi interfaces performance experiment open client server close open port void port block close port void 
architecture midas experiment 
performance analysis transport protocol bindings frag rel cod udp 
frag layer implements fragmentation reassembly large messages rel implements reliable order delivery messages cod implements connection oriented protocol datagram protocol udp provides access udp ip protocol provided host operating system 
experiment implementation udp layer direct calls api functions native methods standard java networking apis java net package provide poor support upcall driven style protocol implementation memory management buffers transport framework 
specifically java net class support scatter gather allow program query size datagram head socket receive queue 

results graphs show times taken perform tests block size 
time secs block size octets rmi corba port 
comparison corba rmi midas performance 
graph shows initially performance midas version better corba version despite additional threads extra context switch synchronisation overhead implies 
indicates midas interaction model composite layered transport protocols significantly reduce performance 
performance corba midas significantly worse rmi 
probably caused overhead due memory allocation garbage collection 
midas corba greater memory allocation overhead marshalling marshal invocations memory buffers 
performance analysis sion 
rmi hand marshals invocations tcp ip stream fixed size buffer transmitting buffer full 
corba midas allocate memory message memory quickly causing garbage collector run 
furthermore jvm zeros allocated memory causing overhead allocating buffers 
performance advantage rmi gained price flexibility inefficient utilisation resources rmi allow programmer insert interaction transport filters binding establish separate tcp ip connections binding operating systems process open limited number tcp ip connections midas systems transport multiplexors share operating system sockets multiple endpoints 
midas platforms shows marked decrease throughput block sizes octets 
frag layer configured divide large messages byte fragments 
configuration inter faces frag layer allow system administrator tune binding fit size fragment mtu link layer protocol link layer protocol known priori 
udp ip expose information higher layers determined internet 
rmi corba tcp ip transport tcp information configuration link layer protocol uses optimum maximum segment size connection hosts physical segment 
throughput midas application decreases rapidly corba application amount data increases 

relative code sizes shows sizes test program 
seen programs written midas significantly smaller 
mainly application components include code perform binding interaction endpoints handled runtime system 
contributing factor predefined 
rmi uses connections rmi held remote object refer object different objects process 

performance analysis generic interaction abstractions instantiated particular application reduces need application specific interaction declarations 
worth noting difference sizes increase programs complex greater number distributed components 
size lines 
sizes test programs 
effect different interaction transport protocols latency throughput midas system affected selection interaction transport protocols binding 
shows additional protocol functionality affects throughput midas version test application transmitting html file octets length port endpoints host 
seen significant benefits obtained removing unnecessary functionality stack 
endpoints host fragmentation reassembly safely removed 
performance im 
reason strange choice number size author home page 
java rmi corba regent midas 
performance analysis achieved shared memory transport base stack udp ip 
sim bindings endpoints physical network safely remove fragmentation layer interaction protocol higher transport layers create messages larger mtu network 
time msecs 
effect transport layers throughput synchronisation policy interaction protocol significant effect throughput sender receiver produce consume messages variable rates 
shows difference throughput programs transmit messages sender receiver 
sender receiver sleep random cod udp rel cod udp frag cod udp frag rel cod udp protocol 
performance analysis duration milliseconds transmission 
programs identical ver sion transmits messages synchronously request reply interaction uses interaction style allows asynchronous messages sent window size 
time msecs 
summary 
effect interaction style throughput chapter results performance measurement experiments compare throughput application written corba rmi midas 
demonstrate midas interaction model composite transport stacks significant effect latency throughput 
furthermore selection appropriate transport stack interaction style binding result significant improvements performance 
synchronous asynchronous 

problems worthy attack prove worth hitting back 
hein described chapter current component models exclusively defined terms objects interaction protocols components specified interfaces 
approach severe limitations object interface describe bundles related synchronous request reply operations specify protocol operations may invoked 
furthermore approach way de protocols operations invoked multiple interfaces 
general simplest component models define interaction protocols require multiple interfaces 

contributions thesis model component interaction supports open variety interaction styles language programmer may define interaction styles follow model software frameworks providing run time support interaction style distributed components 
model interaction general interaction styles supported current middleware platforms rpc object invocation 
lifetime binding communication synchronous asynchronous initiated client service client service service client multicast service subset clients 
language midas define interaction styles follow model 
midas compiler translates definitions run time support binding distribution transparency base classes application layer filters support third party binding 
current interface definition languages midas lets designer annotate interaction definitions formal specifications application layer protocol 
specification exported midas source code combined models transport protocols analysed model checkers catch design errors implementation begins 
midas links design implementation phases 
system development translating formal specifications fsp format animations allow pro grammer interact model interaction protocol application layer monitors check component implementations conform specified protocol 
code generated midas definitions interfaces generic runtime frameworks support inter action model implement transport protocols 
runtime frameworks efficient interaction model runtime support impose additional overhead compared existing object oriented middleware platforms 
clean separation concerns allows designers select appropriate efficient mechanism concern application layer protocol marshalling transport protocol programming interface synchronisation binding binding basis allows filters implement management monitoring functionality added binding application layer transport layer 
transport protocols modelled fsp terms reliability ordering message delivery 
high level abstraction allows designer check correctness interaction protocols variety transports ensures model checking feasible 
practice selection transport protocol components influenced non functional decisions easily expressed modelling notation 
concerns latency throughput efficient operating system resources security reliability message ordering taken account selecting transport protocol 
selection individual transport components exposed designer allow decisions designer select components meet properties shown necessary design time analysis 

critical evaluation chapter described goals research properties required interactions distributed components 
section review midas language runtime system provide properties 
open ended 
midas language defines interaction protocols terms asynchronous messages tween components 
synchronisation implemented terms messages allowing interaction definition specify information flow synchronisation patterns 
messages transmitted time clients service allowing definition interactions interactions mixture 

midas language allows designer annotate interaction definitions arbitrary specifications 
chapter defined mapping midas fsp notation 
allows formal specification interaction protocols mechanical analysis deadlock protocol errors 
additional advantages formal specification include interactive animations help programmers understand interaction protocols automatic generation test code 
flexible 
midas defines interactions purely terms application layer messages 
described section 
run time support interaction separates concerns api synchronisation presentation layer marshalling binding transport protocol 
chapter described transport protocol binding dynamically loaded composed protocol components 
applications manage bindings querying standard control interfaces allowing low level control communication loss generality 
distribution transparent 
midas interaction declarations translated proxies provide distribution transparency marshalling invocations transmitting address spaces 
approach provides distribution transparency component implementations communicate interaction endpoints interfaces implementations endpoints 
language independent 
midas pure specification language include implementation details endpoints components implemented 
language mappings define midas interaction definitions translated programming language constructs 
chapter describes map ping midas java showed possible write compilers generate code programming languages 
efficient 
chapter analysed impact performance midas interaction model runtime support 
experiments demonstrate midas interaction model composite transport stacks significant effect latency throughput 
furthermore selection appropriate transport stack interaction style binding result significant improvements performance 
main drawback midas complexity language 
compared existing idl languages midas define richer complex interaction protocols provides programmer greater amount flexibility choice 
disadvantage compared idl harder define object oriented interfaces terms request reply invocations 
disadvantage overcome compiler translates corba idl midas definitions 
translation trivial perform type constant module syntax midas corba idl compiler easily generate fsp describing interaction protocol described idl 

results thesis extended ways 

general connector model midas supports darwin model component binding inherently client server client endpoints bound single service endpoint vice versa 
illustrated chapter midas specify types interaction constraints styles interaction easily fit model 
examples include group communication members group play role protocols tween different types participant 

alternative view darwin midas model components bound connectors define types roles service client 
complex communication patterns described extending midas define interaction protocols types role 
opens number issues current midas model allows multiple clients communicate single server 
role types define multiplicity role 
roles communicate 
determine roles connected specification interaction protocol designer explicitly define connections 
specification defined adl define connections components midas define roles message interfaces 
connector model map run time support classes 
communication roles connector transport protocol 
change necessitate changes darwin adl defines architectures terms components communicating connectors 

improved support dynamic composition transport layers number shortcomings current transport protocol framework 
multiplexors create hidden session layers higher layer requests protocol services 
necessary allow reusable layers stacked multiplexors non multiplexors 
difficult write layer allocates multiple sessions lower multiplexor layer bound service creates sessions service exists 
bound session query session layer interface multiplexor request service layer wants new session 
overly way doing simple 
components require control interfaces lower layers explicitly query bound protocol service 
logic layer pass request control interface lower layers satisfy request implemented component 
possible encapsulate logic reusable base class uses java reflection inefficient works classes derive reflective base class forces derived classes written specific coding conventions convenient 
stacks torn releasing upper layers release layers beneath 
releasing layers beneath released layer set higher layers null higher layer garbage collected communicate remote layers necessary remove event listeners lower layers release layers beneath 
logic encoded component 

problems alleviated moving logic dynamically composing transport components components 
rules components composed valid stacks stacks named multiplexor layer reused individually named stacks define architectural style transport subsystem 
architectural style described constraints possible components stack valid bindings components higher layers bound data transmission interfaces lower layers vice versa 
lower layers bound data reception interfaces higher layers vice versa 
layer requirement control interface met closest lower layer provides inter face 
layer events routed closest higher layer handle events 
binding requirement transmission service multiplexor instantiate new session pro vides transmission service 
binding requirement multiplexor multiplexor instantiate new session 
constraints need placed individual layer types 
example layer performs encryption placed low stack possible 
layer performs compression placed low stack possible layer performs encryption 
currently developing component model adl allow designers specify constraints externally functional implementation component 
allow binding logic error detection removed layer implementations making simpler write compose 
trans port framework case study ported new component model style defined protocol stacks 

qos directed transport construction runtime system currently requires programmer explicitly define structure transport stack binding 
programmer understand protocol component inter act 
better approach programmer define required qos binding runtime system construct stack meet qos 
open research topic 
tools guide developer selecting plug components plugged protocol layer implement required transport semantics 
tools help programmer build protocol stack graph 

runtime visualisation visualisation behaviour endpoints binding created generating interaction filters midas fsp drive animation tool 
useful aid debugging 

closing remarks task developing distributed computer systems complex 
current middleware platforms attempt hide complexity developer providing simple limited abstractions communication system structuring 
practice opposite intended effect 
sophistication demanded distributed applications increases applications require communication mechanisms varied sophisticated provided current middleware platforms 
developers implement mechanisms provided middleware lower level abstractions integrate implementations middleware platform 
thesis shown design new communication abstractions complex defining rpc interfaces aided formal modelling model checkers allowing developer catch errors early development cycle 
basing communication abstractions clear model communication cleanly separating implementation concerns model middleware platform offer component developers predefined communication abstractions flexibility simplicity 
bibliography bibliography adg robert allen douence david garlan specifying analyzing dynamic software architectures 
proceedings conference fundamental approaches software engineering fase march 
ag robert allen david garlan 
formal basis architectural connection 
acm transactions software engineering methodology july 
ag arnold gosling 
java programming language second edition 
addison wesley 
isbn 
allen robert allen 
formal approach software architecture 
ph thesis carnegie mellon university technical report number cmu cs may 
alp mann ludwig pfeifer 
programming connectors open language web published proceedings position papers working ifip conference software architecture ifip wg february 
ap abbott peterson 
language approach protocol implementation 
ieee transactions networking february 
apm apm 
editors 
application programming document rm 

apm house castle park cambridge uk 

balter boyer 
configuring distributed applications 
proc 
ifip int 
conf 
distributed systems platforms open distributed processing middleware lake district september 
boyer 
system services distributed application configuration 
proc 
th ieee intn conf 
configurable distributed systems annapolis md may 
bc blair coulson 
case reflective middleware 
proc 
rd workshop rennes france april 
blair coulson robin papathomas 
architecture generation middleware 
proc 
ifip international conference distributed systems platforms open distributed processing middleware lake district uk 
davies raymond seitz eds springer verlag 
booch jacobson rumbaugh 
unified modelling language 
rational software 
version 
bk berry kaplan 
open distributed coordination finesse 
acm symposium applied computing sac atlanta ga february 
bn birrell nelson 
implementing remote procedure calls 
acm transactions computer systems february 
bracha odersky stoutamire wadler 
making safe past adding genericity java programming language oopsla vancouver october 
bibliography bps tim bray jean paoli sperberg mcqueen 
recommendation rec xml extensible markup language xml 
published web site world wide web consortium www org xml february 
cbc costa blair coulson 
experiments reflective middleware 
ecoop workshop reflective object oriented programming systems brussels springer verlag 
cd crane dulay 
configurable protocol architecture corba environments 
proc 
third international symposium autonomous decentralised systems berlin germany april 
crane dulay foss kramer magee sloman 
configuration management distributed software services 
raynaud sethi faure vincent editors integrated network management iv pps 
chapman hall 
chap chappell 
understanding activex ole 
microsoft press 

isbn 
cl chan lee 
java class libraries second edition volume java applet java awt java beans 
addison wesley 
isbn 
clk chan lee kramer 
java class libraries second edition volume java io java lang java math java net java text java util 
addison wesley 
isbn 
cm chiba masuda 
designing extensible distributed language meta level architecture 
proceedings th european conference object oriented programming ecoop july lncs pp 
cmp crane magee 
design patterns binding distributed systems 
workshop design patterns concurrent parallel distributed object oriented systems oopsla 
crane crane 
framework distributed interaction 
international workshop development evolution software architectures product families madrid november 
crane crane 
dynamic binding distributed systems 
phd thesis imperial college university london march 
ct crane 
constructing distributed unix utilities regis 
proc 
international workshop configurable distributed systems pittsburgh march 
deer deering 
multicast routing datagram internetwork 
phd thesis stanford university december 
ee 
inside distributed com 
microsoft press 
isbn 
bibliography tom fitzpatrick gordon blair geoff coulson nigel davies philippe robin 
supporting adaptive multimedia applications open bindings international conference configurable distributed systems annapolis maryland usa may 
foster kesselman tuecke 
nexus runtime support task parallel programming languages 
technical report mathematics computer science division argonne national laboratory argonne il 
august 
fried friedberg 
transparent reconfiguration requires third party connect 
technical report department computer science university rochester november 
fs sloman 
interactive configuration management distributed object systems 
proceedings enterprise distributed object computing workshop edoc coast australia october 
gao david garlan robert allen john 
exploiting style architectural design environments 
proceedings sigsoft symposium foundations software december 
garlan garlan 
higher order connectors 
workshop compositional software architectures monterey ca january 
ghjv gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 

gian giannakopoulou 
approach behaviour analysis concurrent systems 
department computing imperial college science technology medicine doc september 
gjs gosling joy steele 
java language specification 
addison wesley 
isbn 
giannakopoulou kramer cheung 
analysing behaviour distributed systems 
journal automated software engineering special issue automated analysis software vol 
pp 
january 
cleaveland jackson eds 
gmw david garlan robert monroe david 
acme architecture description interchange language 
proceedings cascon november 
gs gokhale schmidt 
managing optimizing corba latency scalability high speed networks 
ieee transactions computers vol 
april 
bibliography hayton herbert donaldson 
flexinet flexible component oriented middleware system 
acm sigops european workshop lisbon september 

configuration management highly customizable services 
proceedings fourth international conference configurable distributed systems annapolis maryland may 
johnson angel 
framework network protocol software 
object oriented programming systems languages applications conference proceedings oopsla acm press 

achieving middleware customization configuration development environment experience prototype 
proceedings th international conference configurable distributed systems pages may annapolis maryland usa 
visibroker corba technology 
published web site www com visibroker 
iona iona technologies 
orbix product information 
published web site iona technologies www iona com products orbix 
gregor kiczales john lamping anurag mendhekar chris maeda cristina lopes jean marc loingtier john irwin 
aspect oriented programming 
proceedings european conference object oriented programming ecoop finland 
springer verlag lncs 
june 
krb kiczales des rivi res bobrow 
art metaobject protocol 
mit press 

lk lopes kiczales 
language framework distributed programming 
report spl xerox palo alto research center february 
luckham augustin vera bryan mann 
specification analysis system architecture rapide 
ieee transactions software engineering special issue software architecture vol 
pp 
april 
lp lo pope 
implementation high performance orb multiple transport protocols 
technical report laboratories cambridge street cambridge cb qa england 
ln lauer needham 
duality operating system structures 
operating systems review april 
lv luckham vera 
event architecture definition language 
ieee transactions software engineering vol pp 

september 
ly lindholm yellin 
java virtual machine specification 
addison wesley 
isbn 
bibliography mbl myers bank liskov 
parameterized types java 
proc 
th acm symposium principles programming languages paris france january 

connectors key feature building distributed component architectures 
proc 
nd european research seminar advances distributed systems march pp 

magee dulay eisenbach kramer 
specifying distributed software architectures 
proc 
th european software engineering conference esec september lncs springer verlag magee dulay kramer 
constructive development environment parallel distributed programs 
iee iop bcs distributed systems engineering sept 
meyer meyer 
object oriented software construction 
prentice hall international series computer science 
mh 
enterprise javabeans version 
sun microsystems san antonio road palo alto ca 
march 
mk magee kramer 
concurrency state models java programs 
john wiley sons 
mkg magee kramer giannakopoulou 
analysing behaviour distributed software architectures case study 
th ieee workshop trends distributed computing systems october 
robert monroe 
capturing design expertise customized software architecture design environments 
proc 
second international software architecture workshop october 
message passing interface forum 
document standard message passing interface 
message passing interface forum university tennessee knoxville tennessee 
mpw milner parrow walker 
calculus mobile processes parts ii 
journal information computation vol pp pp 
msft microsoft 
editor 
automation programmer activex technology create programmable applications 
microsoft press 

isbn 
nk 
java beans component architecture cryptographic protocols 
proceedings th usenix security symposium january san antonio texas 
keng ng jeff kramer jeff magee case tool software architecture design 
journal automated software engineering special issue case odp secretariat iso iec jtc sc wg 
model open distributed processing part architecture 
document itu iso iec 
standards association australia po box nsw australia may 
bibliography omg object management group 
common object request broker architecture specification version 
object management group omg headquarters old connecticut path ma usa 
july 
omg object management group 
corba free downloads 
published web site omg www omg org corba html 
op malley peterson 
dynamic network architecture 
acm transactions computer systems may 
ow odersky wadler 
pizza java translating theory practice 
proc 
th acm symposium principles programming languages paris france january 
pc crane 
uniform approach communication configuration distributed systems 
proc 
third international conference configurable distributed systems annapolis may 
pc crane 
model interaction concurrent distributed systems 
proc 
second international workshop development evolution software architectures product families las palmas de gran spain february 
pc crane 
component interaction concurrent distributed systems proc 
fourth international conference configurable distributed systems md usa 
may 
ieee computer society 
isbn 

type safe session 
published pattern languages program design volume 
addison wesley longman 


acm transactions programming languages systems january pp 
qs quinn 
windows sockets network programming 
addison wesley 
isbn 
van renesse birman friedman hayden karr 
framework protocol composition horus 
proceedings principles distributed computing august 
rbm van renesse birman maffeis 
horus flexible group communication system 
communications acm april 
rfc deering 
extensions ip multicasting 
rfc ietf august 
rfc srinivasan 
xdr external data representation 
rfc ietf august 
rfc deutsch 
deflate compressed data format specification version 
rfc ietf may 
ritchie ritchie 
stream input output system 
bell laboratories technical journal october 
roger rogerson 
inside com microsoft component object model 
microsoft press 
rossum van rossum 
python manual release 
national research initiatives cnri preston white drive reston va usa january 
available online www python org 
schneier schneier 
applied cryptography second edition 
protocols algorithms source code john wiley sons 

isbn 
shaw deline klein ross young 
abstractions software architecture tools support 
ieee transactions software engineering april 
shaw deline 
abstractions implementations architectural connections 
third international conference configurable distributed systems may 
sg shaw garlan 
software architecture perspectives emerging discipline 
prentice hall 

isbn 
shaw shaw 
truth vs knowledge difference component know 
proc 
th international workshop software specification design march 
softw 
editor 
technical white 
published web site www com steve richard stevens 
unix network programming networking apis sockets volume 
addison wesley 
isbn 
sullivan brown 
programming java media framework 
john wiley sons 

isbn 
weh waddington edwards hutchison 
resource management distributed multimedia applications 
proceedings second european conference multimedia applications services techniques lncs milan italy may 
wrw waldo 
distributed object model java system 
computing systems pp 

midas syntax appendix describes syntax midas language 

comments preprocessing midas syntax language services functions 
communicate ideas 
second conceal ideas 
third conceal absence ideas 
otto midas code preprocessed preprocessor parsing 
allows inclusion midas files macros conditional compilation 
midas definitions include comments 
comment syntax corba idl 
parser ignores text symbols symbol line 
comments nested 

types midas provides primitive types corba idl shown table 
boolean true false octet bit cardinal short bit integer unsigned short bit cardinal long bit integer unsigned long bit cardinal long long bit cardinal unsigned long long bit integer float bit real double bit real char bit character table 
primitive midas types midas syntax enum statement define new enumerated type values set symbolic con enum direction north south east west midas provides number ways specify structured data 
simplest fixed size multidimensional arrays values 
variable sized sequences values supported sequence type constructor sequences optionally bounded 
string type similar sequence characters mapped appro priate type handling strings implementation language 
enumerated type named direction value north south east west 
table 
example midas enumerated type 
fixed size array elements type sequence unbounded sequence zero elements type sequence bounded sequence zero elements type string unbounded character string string bounded character string containing characters 
complex data types defined struct union statements 
struct declaration defines record type containing zero named typed fields 
union declaration defines discriminated union type run time hold values different types current value type depends discriminator value checked ensure type safe usage union 
struct string string second union switch short case string string default double double table 
basic structured midas types record containing strings named second 
union holds string named string discriminator zero double named double 
table 
data structure definitions addition type definitions supported corba idl midas allows generic type definitions type definitions parameterised types 
allows definition generic data structures sacrificing type safety allows definition generic interaction protocols dis midas syntax cussed section 
generics defined specifying type parameters angled brackets type name shown table 
generic definitions parameterised primitive midas types types defined midas 
midas allows definition type aliases typedef statement 
useful give convenient descriptive names type definitions long names different modules instantiations generic type 

interaction definitions interaction statement define interaction style 
interaction statement followed name interaction style optional formal parameters interaction style generic body interaction statement containing definitions message interfaces specifications interaction protocol 
struct pair type type second generic struct holds values named second types parameters struct 
table 
generic structure declaration typedef string typeid typedef pair typeid typeid table 
type aliases typedefs give descriptive names existing type instantiation generic type 
body interaction statement contain provide statement defines message interface service endpoint require statement defines message interface client endpoints 
body message interface consists message definitions 
messages named take number named typed parameters 
operation parameters corba idl pass values back server client message parameters read 
values returned midas interactions explicitly defining reply messages 
body contain zero spec statements annotate interaction definition specifications interaction protocol 
specification string type name arbitrary contents 
specification processed type specific compiler parse specification pass external tools 
specification follow type specific mapping specification notation elements interaction name message interfaces message names compiler back associate elements specification elements midas definition 
midas syntax structures unions interaction styles generic instantiated primitive user defined type type parameters types message arguments 
interaction statement defines new type type fields user defined data type type message parameters interaction types arguments instantiate generic type 
interaction func type request type reply provide request request data require reply reply data spec fsp 

constant definitions const statement define named typed constant 
constants values primitive types character strings 
numeric boolean constants calculated compile time literal values constants 
expressions follow syntax corba idl omg 
const string name nat const long max size num elements max element size 
modules table 
example interaction definition table 
constant definitions definition generic interaction named func parameterised types request reply 
service endpoint receives request messages single argument type request sends reply messages clients single argument type reply 
protocol request reply messages sent defined fsp specification defined spec block contents elided brevity 
interaction definition described detail section 
definitions string constant named name value nat long constant named max size calculated constant values 
modules allow names defined packages avoid name clash group related type interaction definitions 
declared body module statement midas definitions defined global module 
modules nested definitions modules referred scoped names 
scoped name preceded names modules containing name separated scoping operator 
midas syntax initial indicates name resolved global module resolved module name usual name resolution rules block structured languages pascal 
module regent module media typedef string typeid struct typeid major type typeid minor type 
modules group definitions modules group definitions related media processing defined part regent set libraries 
third definition declares typedef interaction type different submodule regent module 
fsp syntax chapter describes fsp notation taken permission mk 

processes fsp syntax theory difference theory practice 
practice jan van de process defined local processes separated commas 
definition terminated full 
error primitive local processes 
example process local local 
action prefix choice guarded action alphabet extension action process describes process initially engages action behaves exactly described actions describes process initially engages actions action occurred subsequent behaviour described action action abbreviation written 
choice means guard true actions eligible chosen false action chosen 
alphabet process set actions engage 
alphabet process actions set table 
process operators 
composite processes fsp syntax composite process parallel composition processes 
definition composite process preceded 
example composite 
parallel composition replicator forall process labelling process sharing priority high priority low 
common operators processes represents concurrent execution processes composition actions common actions said shared 
unshared actions arbitrarily interleaved shared actions executed time processes share action 
forall parallel composition 
prefixes label alphabet ax replaces label alphabet labels ax transition definition replaced transitions ax 
specifies composition actions higher priority action alphabet including silent action tau 
choice system actions labeling transition transitions labeled lower priority actions discarded 
specifies composition actions lower priority action alphabet including silent action tau 
choice system transitions labeled transitions labeled discarded 
table 
composite process operators operators table may definition processes composite processes 
conditional relabelling hiding interface process behaves process condition true behaves omitted false process behaves 
re labelling applied process change names action labels 
general form re labelling newlabel newlabel 
hiding operator ax removes action names ax alphabet concealed actions silent 
silent actions labelled tau 
silent actions different processes shared 
applied process interface operator ax hides actions alphabet ax 
table 
common process operators 
properties safety property progress progress 
safety property defines deterministic process asserts trace including actions alphabet accepted progress defines progress property asserts infinite execution target system actions executed infinitely 
table 
safety progress properties 
