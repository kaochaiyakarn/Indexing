degrees separation multi dimensional separation concerns peri tarr harold ossher william harrison ibm watson research center box yorktown heights ny ossher watson ibm com stanley sutton jr ec cubed river road suite ct com done separation concerns provide software engineering benefits including reduced complexity improved reusability simpler evolution 
choice boundaries separate concerns depends requirements system kind decomposition composition formalism supports 
predominant methodologies formalisms available support orthogonal separations concerns single dimensions composition decomposition 
characteristics lead number known difficult problems 
describes new paradigm modeling implementing software artifacts permits separation overlapping concerns multiple dimensions composition decomposition 
approach addresses numerous problems software lifecycle achieving evolvable flexible software artifacts traceability artifacts 
keywords hyperslices software decomposition composition multi dimensional separation concerns primary goals software engineering improve software quality reduce costs software production facilitate maintenance evolution 
pursuit goals software engineers constantly seek development technologies methodologies reduce software complexity improve comprehensibility promote reuse facilitate evolution 
properties turn induce specific requirements stanley sutton performed university massachusetts amherst 
supported part air force materiel command rome laboratory advanced research projects agency contract 
formalisms develop software artifacts 
reduced complexity improved comprehensibility require decomposition mechanisms carve software meaningful manageable pieces 
require composition mechanisms put pieces usefully 
reuse requires development large scale reusable components low coupling powerful non invasive adaptation customization capabilities 
ease evolution depends low coupling requires traceability software lifecycle mechanisms minimizing impact changes substitutability 
despite research software engineering domain problems complicate software engineering remain 
software comprehensibility tends degrade time 
common maintenance evolution activities result high impact invasive modifications 
artifacts limited reusability reusable difficulty 
traceability various software artifacts limited complicates evolution 
somewhat diverse problems due large part limitations unfulfilled requirements related separation concerns 
ability achieve goals software engineering depends fundamentally ability keep separate concerns importance software systems 
modern software formalisms support separation concerns extent mechanisms decomposition composition 
existing formalisms lifecycle phases provide small restricted sets decomposition composition mechanisms typically support single dominant dimension separation time 
call tyranny dominant decomposition 
believe achieving primary goals software engineering requires support simultaneous separation overlapping concerns multiple dimensions 
illustrate limitations current mechanisms prevent lead directly failure achieve goals 
propose model software artifacts decomposition composition overcome limitations 
model allows simultaneous multi dimensional decomposition composition 
universal artifact modeling formalism complements existing formalisms giving developers additional modularization flexibility continuing formalisms choice 
model particular phase software lifecycle 
extra flexibility represent alternative decompositions artifacts development phase enables relate artifacts multiple ways phases structure artifacts permit different artifacts developed different phases software lifecycle structured way corresponding elements align clearly 
show increased flexibility help address problems software complexity comprehensibility difficulties reuse facilitate software evolution enhance traceability artifacts development phases 
rest organized follows 
section motivates need multiple dimensions decomposition rich mechanisms composition 
section describes model software artifacts 
shows model address issues raised section 
section describes issues involved instantiating model particular artifact development formalisms uml java 
section describes related shows approach partially realized existing 
section presents 
motivation illustrate pervasive serious problems software engineering help motivate running example involving construction evolution simple software engineering environment see programs consisting expressions 
assume simplified software development process consisting informal requirements specification natural language design uml implementation java 
go round initial set requirements see simple see supports specification expression programs 
contains set tools share common representation expressions 
initial toolset include evaluation capability determines result evaluating expression display capability depicts expression textually check capability checks expression syntactic semantic correctness 
requirements design system uml 
shows subset design expression number plus minus create get set methods eval display check process create get set methods eval display check process create get set methods eval display check process create get set methods eval display check process create get set methods eval display check process create get set methods eval display check process create get set methods eval display check process create get set methods eval display check process key class name top methods inside subclass initial partial design artifact see 
represents expressions syntax trees asts defines class kind ast node 
class contains accessor modifier methods plus methods eval display check realize required tools standard object oriented manner 
code implements design similar structure separates interfaces ast nodes implementation classes resulting hierarchies 
simple example raises noteworthy issues occur commonly software 
despite representations system kinds artifacts decomposes system differently 
requirements decompose tool feature design code decompose object 
code separates interface implementation parts 
difference decomposition models leads directly scattering single requirement affects multiple design code modules tangling material pertaining multiple requirements interleaved single module 
problems compromise comprehension evolution see shortly 
evolving see environmental hazard see time clients request changes system ffl expressions optionally persistent 
ffl style checking supported syntax semantic checking 
possible check expressions multiple styles 
meaningful combination checks syntax syntax plus style permitted 
unfortunately seemingly straightforward enhancements significant impact design code 
shows impact java implementation class hierarchy 
simple implementation persistence requires adding save retrieve methods ast classes inserting additional code accessor modifier methods retrieve persistent objects access flush modifications back database 
represents nontrivial invasive change ast design classes interfaces implementation classes code serious case scattering 
code support retrieval update persistent objects tangled code accessor modifier methods impeding comprehensibility evolution 
persistence code impact new style checkers 
persistence option style checkers include state information persistent representation expressions 
kind context dependent feature extremely difficult represent modern formalisms 
ability permit arbitrary combinations checks problematic 
requires special infrastructure support design implementation 
infrastructure comes high cost terms conceptual complexity run time overhead included originally necessary 
choose address problem retrofitting visitor design pattern permits optional combinations features design code 
visitor requires replace ast check methods accept visitor methods define separate visitor class type check 
modifications check feature needed support capability invasive affecting module design code complicating artifacts interrelationships 
presence arbitrary checks complicates persistence capability information persistent depends particular combination syntax style checkers 
modifications significantly impede evolution artifacts 
introduce higher degree coupling ast classes visitor classes evident presence visitors design necessitate extensive changes accommodate modifications ast hierarchy 
example demonstrates microcosm subclassing non invasive mechanism change reasonable option 
produces combinatorial explosions classes requires invasive changes client creates instances original classes 
problems plague software engineers suggests fall short goals 
impact change goal low impact change requires additive invasive change 
conceptually simple changes expression see widespread invasive effects modified artifact related pieces artifacts 
primarily units change match units abstraction encapsulation artifacts 
additive changes artifact requirements may translate additive changes artifacts design code 
modern extensibility features subclassing design patterns help sufficient require significant pre planning 
feasible pre enable artifacts possible extensions possible anticipate 
reuse despite wide recognition benefits reuse limited occurs code requirements designs 
part impediment large scale reuse larger artifacts entail design implementation decisions result tangling concerns coupling features reducing reusability 
large complex artifacts plus weak set adaptation customization capabilities available formalisms developers face significant amount invasive adapt component context 
traceability different artifacts written different purposes include different levels abstraction 
specified different formalisms decomposed structured differently 
case point requirements scattering tangling problem illustrated earlier 
clear correspondence abstraction structure artifacts exists general aid traceability 
developers create connections related artifacts explicitly 
connections complex invalidated readily importantly reduce scattering tangling 
help developers assess impact change localize reduce impact 
developers invasive time consuming changes multiple artifacts propagate effects change 
time constraints tight choose changes code letting artifacts obsolete 
believe major cause impact change reusability traceability problems tyranny dominant decomposition 
existing modularization mechanisms typically support small set decompositions usually single dominant time 
dominant decomposition satisfies important needs usually expense 
example decomposition may chosen limit note classes ast hierarchy dependency relationships hierarchy vice versa 
persistence style checker style checker impl impl visit ast class visit ast class visit ast class save save save accept visitor save save save save save save save save accept visitor accept visitor accept visitor accept visitor accept visitor accept visitor accept visitor key method member class implementation affected new feature color code color coding method new member class necessitated addition color code method method java implementation classes post evolution 
impact changes traceability may sacrificed ability limit impact changes data decomposition designed match application domain concepts code feature may scattered multiple application modules tangled code features 
matters worse different formalisms typically support different dominant decompositions reducing traceability artifacts 
different kinds concern important software system designating dominant context expense significantly problems identified 
breaking tyranny achieve full potential separation concerns need break tyranny dominant decomposition 
example related discussion kinds concerns identified ffl feature include display basic check evaluate persistence style check 
features may required optional ffl unit change additions due user requests ffl customization additions changes needed customize component particular purpose ffl data object classes involved system 
system modularized concerns kinds simultaneously problems described greatly ameliorated 
traceability improved encapsulating features separately clear correspondence representation particular feature different artifacts structuring 
impact change reduced ability encapsulate unit change separately 
reuse enhanced improved traceability separating customization details base component provided composition rich apply effectively 
just dimensions concern separation may desirable 
include match conceptual abstractions conform modeling paradigm object oriented functional take advantage special purpose formalisms separate optional required pieces separate variants different host systems classes users permit distribution parallel processing facilitate concurrent cooperative development possibilities limitless vary context 
different dimensions concern seldom orthogonal overlap affect 
truly flexible approach modularization allow needed apply simultaneously able handle overlap interactions 
multi dimensional separation concerns section introduces model decomposition composition believe satisfies needs 
model conjunction developers artifact formalism choice giving developers additional power requiring changes formalisms 
model conventional software set context introduce terminology describe model show addresses issues raised earlier 
model conventional software particular software system written address problem provide service problem domain 
model implement variety concepts importance domain 
concepts include objects expression example functionality evaluation properties persistence 
concepts derived directly domain internal software concepts data structures important 
software system consists set artifacts requirements specifications designs code 
artifact consists descriptive material formalism purpose model needed concepts manner appropriate artifact 
formalisms differ different projects different phases different artifacts artifact 
different artifacts share concepts concept potentially described different way different details different artifacts 
example word expression requirements class expression design code describe concept expression different ways different levels detail 
convenient think descriptive material artifact units 
constitutes unit depends formalism context 
example object oriented design formalisms programming languages classes kind unit 
looks class level individual methods may considered units 
illustrates important point formalisms typically consist basic elements call primitive units grouping construct call compound units modules 
treat primitive units indivisible model works looks inside 
single concept typically modeled collection units primitive compound 
surprisingly single unit participates modeling concept 
example eval method plus class participates modeling plus expression concept evaluation concept 
purpose modules accomplish separation concerns 
software systems moderate size contain primitive units held mind 
performing development task developer able focus units pertinent task ignore 
accomplish software engineers identify concerns importance seek localize units representing concepts pertain concern module 
ideally need look inside module interested concern 
example class module containing units describing methods instance variables model particular kind object internal details objects representation described class 
kinds concerns important software lifecycle 
dimensions concern help organize space concepts units 
common dimensions concern data object leading data abstraction function leading functional decomposition 
include feature functional evaluation cross cutting persistence role configuration 
illustrated examples dimensions concern derive domain aligning important domain concepts come system requirements development process internal details system 
short number dimensions concern importance different purposes comprehension traceability reusability evolvability different systems different phases lifecycle 
modern artifact formalisms typically allow decomposition grouping units modules single dimension concern term dominant dimension 
formalism dictates specifically dominant dimension 
example object oriented formalisms support decomposition object data dimension procedural functional programming languages permit decomposition function 
formalisms impose specific dominant dimension typically support simultaneous decomposition multiple dimensions developer ultimately chooses dominant dimension 
case modular structure artifact achieves separation concerns dominant dimension 
model conventional software system set artifacts model domain concepts appropriate formalisms 
artifacts contain modules contain units 
modular structure reflects decomposition dominant dimension concern 
multi dimensional decomposition hyperslices discussed section decomposition concerns single dominant dimension valuable usually inadequate 
units pertaining concerns dimensions scattered modules tangled 
separation concerns achieved 
alleviate problem introduce hyperslices additional flexible means decomposition 
hyperslice set conventional modules written formalism 
hyperslices intended encapsulate concerns dimensions dominant 
modules contain units pertain address concern 
hyperslices overlap unit may occur possibly different forms multiple hyperslices 
supports simultaneous decomposition multiple dimensions concern 
system written collection hyperslices separating concerns importance system dimensions needed 
hyperslices composed form complete system discussed 
choice term hyperslice intended reflect relationships program slicing hyperplane 
hyperslices similar program slices involve cuts system align standard modules 
differ program slices code level generally consist specifically statements affect particular variables extracted existing programs analysis build systems composition 
hyperslices hyperplanes encapsulate concerns cut multiple dimensions space defined dimensions concern 
demonstrate utility hyperslices consider initial version expression see described section 
identified separate dimensions concern applicable initial design object different kinds expressions feature display evaluation basic checking 
object oriented formalisms design code object dimension dominant separation concerns dimension effective 
separation feature accomplished leading scattering tangling feature specific units 
introduce hyperslices encapsulate concerns features shown 
hyperslice encapsulates basic kernel expression ast capabilities node creation accessor modifier methods modularized uml classes design java classes interfaces code 
hyperslices encapsulate respectively display evaluation syntax semantic checking features 
note hyperslices contain class modules kernel hyperslice concerns overlap modules hyperslices contain units pertain particular concern encapsulate 
display hyperslice defines display methods instance variables units ast node classes modules evaluation hyperslice defines eval methods instance variables 
note hyperslices introduced requiring definition new artifact formalisms 
deliberately modify artifact formalisms preferring allow developers familiar formalisms lifecycle 
modules hyperslice standard modules desired formalism contain units pertinent hyperslice concern 
means modules satisfy completeness constraints formalism normally requires 
example implementation code display hyperslice refer accessor methods define expectation kernel hyperslice provide 
legal java requires modules define methods 
fine model hyperslices eventually composed form complete hyperslice satisfy formalism constraints 
definition hyperslice sufficiently broad possible concern form hyperslice consisting exactly units pertaining concern 
example hyperslices correspond features units change specific customizations components 
approach followed concerns interest system deal overlap unit different units describing concept involved multiple concerns 
saw expression example hyperslices includes expression concepts form class modules defines concepts way appropriate task 
overlap acceptable responsible power approach 
composition able resolve overlap discussed 
great flexibility raises question developers choose hyperslices decomposing system freedom lead error abuse 
simple uses major features units change provide great benefit little difficulty 
formulation guidelines complex hyperslices issue research 
outstanding guidelines hyperslices modularization mechanism requires judgement 
key structural decisions turn incorrect design error dramatic changes requirements system restructuring may necessary conventional technology 
support simultaneous separation concerns multiple dimensions opens possibility introducing new dimensions ignoring obsolete ones system 
needs research 
composing hyperslices hyperslices provide flexible means decomposing artifacts 
useful possible compose produce complete consistent artifacts unchanged artifact formalisms choice 
hypermodule set hyperslices composition rule specifies hyperslices composed form single new hyperslice synthesizes integrates units 
com number check check check minus check plus check expression check process number check check check check check minus check plus check expression check process check slices syntax check slice semantic check slice number create get set process create get set process create get set process create get set process create get set process minus create get set process plus create get set process expression create get set process kernel slice number display display display display display minus display plus display expression display process display slice number eval eval eval minus eval plus eval expression eval process evaluation slice defining see hyperslices 
position property hypermodule appropriate hyperslice may 
nested 
entire artifact modeled hypermodule artifact consists modules composed hyperslice satisfy consistency completeness constraints required artifact formalism 
system artifacts modeled hypermodule composition rule describes relationships artifacts 
simplification relationships possible hyperslices reification composition rule key advantage model 
shows hypermodule consisting hyperslices 
composition rule indicate units hyperslices describe concepts units integrated 
case asserts classes different hyperslices name model concept merged new composed class name combined details 
composition rule applied resulting hyperslice contains exactly modules shown 
notice syntax semantic checking hyperslices grouped optionally check hypermodule nested see hypermodule 
result optionally composing syntax semantic checking hyperslices check hypermodule check hyperslice composed see hyperslices 
ability nest manner promotes abstraction encapsulation 
details composition vary greatly depending formalism units written formalism constructs treated units modules 
details specified part instantiation model described detail section represents mapping particular formalism concepts embodied model 
dependent details particular units involved vary straightforward highly complex 
general properties worth discussing 
composition commonality concepts units different units describing concept usually necessarily differently composed single unit describing concept fully 
process involves steps matching units different hyperslices describe concept reconciliation differences descriptions integration units produce unified 
clearly composition fully automatic process 
task composition rule hypermodule specify details composition 
approach composition rules suggested subject oriented programming rule combination concise general rule detailed specific rules specify exceptions general rule handle cases handle 
general rule essentially names automatic approach apply starting point default matching unit name name denotes concept 
general rules applied entire composition selectively portions different automatic approaches applied different areas composition 
cases automatic rule suffices detailed rules needed developer says explicitly exactly 
detailed rules handle issues matching units different names describe concept matching units names describe concept reconciling different module structures matching units nested different depths different hyperslices describe concept 
degree mismatch module structure abstraction level handled effectively issue number check check check minus check plus check expression check process number check check check check check minus check plus check expression check process check hypermodule optional syntax check slice semantic check slice number create get set process create get set process create get set process create get set process create get set process minus create get set process plus create get set process expression create get set process kernel slice number display display display display display minus display plus display expression display process display slice number eval eval eval minus eval plus eval expression eval process evaluation slice merge modules different slices name composition rule hypermodule check check minus check plus check expression check process style check slice style check slices composing hyperslices 
research determining mismatch occurs practice composed hyperslices 
alternative split composition rule hyperslices allowing hyperslice specify composed 
rule hyperslice refer hyperslices increases coupling reduces reusability hyperslices limits flexibility overlap handled 
putting composition rule level higher hypermodule allows flexible overlap enhanced reuse 
model developers write artifact hypermodule 
concern importance encapsulated effectively artifact formalism write hyperslice consists modules artifact formalism 
write composition rule specifies hyperslices composed set legal modules artifact 
write enclosing hypermodule contains artifacts composition rule specifies relationships 
model begun see artifact model help address software lifecycle problems identified section 
explore impact problems detail revisiting expression see example 
apply software development evolution process time proposed artifact model 
evaluate resulting artifacts address problems earlier 
revised go round described section shows somewhat different decomposition design code artifacts produced initial design coding process depicted 
model allowed separate major non object concerns identified requirements gathering kernel encapsulates basic functionality pertaining expressions display evaluation checking features 
concerns encapsulated hyperslice 
chose decompose check feature represent nested hypermodule includes syntax semantic checkers 
decomposition significant benefits 
hyperslices permit decomposition multiple dimensions case object feature object oriented formalisms generally support object dimension 
second improved separation concerns eliminates scattering tangling problems saw earlier keeping units pertaining separate requirements features separate 
key benefit achieved encapsulation coherent concerns lifecycle 
improves traceability significantly simplify interrelationships different artifacts traditionally difficult maintain 
approach improves reusability considerably 
example entire expression ast concept requirements way code defined context independent manner reused readily context specific pieces encapsulated hyperslices 
composition assemble hyperslices final see provides substantial benefits 
observe composition hyperslices optional managed just separating concerns ensure able mix match syntax style checking 
create versions see contain different combinations checking evaluation display features ability original see 
notice choice define 
example define includes hyperslices pertaining particular artifact 
allows compose full requirements specification design code artifacts 
choose define hypermodule concern expression hypermodule contains requirements design code hyperslices encapsulate kernel display hypermodule encapsulates artifact hyperslices pertaining display kinds composition valid useful different purposes permits creation final artifacts facilitates reuse concerns permits certain forms inter artifact completeness consistency checking 
noted earlier developers may need decompose compose differently different reasons 
model permits just 
see evolution saving environment clients eventually requested support optional persistence expressions multiple forms style checking ability mix match types checks 
persistence new concern represents new feature unit change 
addition supported object oriented separation concerns saw section 
time choose model persistence independent concern hyperslice encapsulates provides opportunity asts persistence 
adding style checkers trivial checking hyperslice separates syntax semantic checking need define style checkers hyperslices compose set syntax semantic check hyperslices 
notice new capabilities require modifications existing hyperslices artifacts encapsulated separate concerns composed existing artifacts 
revisited revisit set software engineering problems discussed section 
impact change reason high impact change mismatch units change units abstraction encapsulation artifacts 
model units change separated encapsulated concern 
common cases significantly reduce eliminate impact change 
reuse noted model may significantly improve reuse artifacts 
permits separation generally useful capabilities special purpose ones provides composition powerful non invasive customization adaptation mechanism 
simpler create reusable components pick tailor component particular need 
traceability ability identify encapsulate structure similar concerns different artifacts greatly facilitates traceability propagation change lifecycle 
appropriate model directly result benefits described panacea bad design bad code poor modularization 
concerns bad leads large numbers hyperslices complex interrelationships may reduce comprehension increase complexity 
believe model valuable tool potentially high benefit properly 
instantiation artifact model instantiate particular artifact development formalisms 
instantiation entails determining notational constructs map units modules deciding represent hyperslices providing support composition hyperslices 
mapping units especially important significantly affects achieve various software engineering goals properties 
section briefly describes issues involved 
fuller discussion appears 
mapping units modules units choosing units set artifact formalism constructs requires decide level granularity appropriate formalism separate integrate concepts 
illustrate example java language 
java defines declarator constructs packages interfaces classes methods statements 
subset constructs treated units 
decision favor fine granularity include statements units 
potentially provides flexibility compose pieces java source concomitant problems determining match reconcile different statements trying analyze properties result 
coarser level granularity result treating subset classes members units simplifies composition understanding composed result cost generality 
selection units significant ramifications important software engineering properties artifacts including effects evolution modular development 
set units includes entities typically hidden method implementation code composition rules results sensitive hidden changes 
modular development relies important properties individual modules preserved composition 
composition occur fine grained level properties preserved re examined afresh context composition 
data functionality fundamental ubiquitous concepts software 
frequently concepts described artifacts concepts span hyperslices artifacts 
formalisms generally constructs declaring defining 
example uml boxes representing classes entries class boxes representing instance variable method declarations 
java classes interfaces instance variable declarations methods 
believe constructs related data functionality excellent candidates units hypothesize general best choices 
modules selection formalism constructs map modules somewhat simpler choice units 
essentially requires examining particular modularization constructs formalism provides light set units chosen 
example suppose choose java methods instance variable declarations classes interfaces units 
instance variable declarations methods grouped classes interfaces turn grouped packages 
choose map java classes interfaces packages modules model 
obvious choice uml map classes package diagrams modules 
representation hyperslices hyperslices sets modules 
need occur explicitly artifact formalisms formalisms may provide construct convenient map hyperslices 
example namespace construct represents arbitrary collections program units java package construct represents collections classes interfaces uml package diagram represents collections packages classes may model hyperslices 
formalisms constructs necessary enhance provide separate hyperslice specification mechanism named lists modules 
support composition provide support composing hyperslices necessary define means specifying composition rules language interactive tool build able apply rules hyperslices 
composition hand conceptually possible totally unrealistic actual development 
providing support large job 
powerful reason mapping decisions formalism content avoid need 
specialized understand particular semantic dimensions may useful circumstances demonstrated aspect oriented programming 
related discuss categories related approaches loosely considered instantiations model particular types artifacts different approaches similar problems 
subject oriented programming partially realizes model object oriented code artifacts 
units classes methods instance variables 
systems built compositions subjects hyperslices class hierarchy modeling domain particular point view 
built composition support corba idl prototype support smalltalk currently building support java 
composition rules specified textually interactive user interface systems provide considerable matching reconciliation flexibility support framework allowing addition new matchers 
small running examples demonstrate value decomposition subjects 
currently exploring manifestation subjects composition rules uml allow structuring subject oriented designs code 
aspect oriented programming aop expands concepts subject oriented programming identifying illustrating useful non functional concerns separated concurrency properties distribution properties persistence emergent entities 
initial different aspect languages represent different aspects 
appealing programming language necessarily best formalism expressing non functional requirements results need special purpose called 
aimed providing general purpose weaver hyperslices written java 
aop distinguishes notion core classes encapsulate system functional requirements aspects encapsulate non functional crosscutting requirements 
aspects written respect core classes essentially orthogonal 
relative model aspect hyperslice set aspects core classes approximate hypermodule 
core classes distinguished aspects refer fore share view class structure 
hypermodule central composition rule 
aspect contains part rule specifying aspect woven base classes 
approach subject disadvantages discussed section particularly handling overlapping concerns interaction aspects done standard default manner weaver 
holland discusses building systems compositions contracts 
contract specifies set participant objects interactions expressed obligations 
primary intent encapsulate particular interactions obligations clearly separated interactions involving objects 
single object participate multiple contracts case satisfy obligations 
holland describes variety combination rules contracts 
contract corresponds hyperslice model cutting classes describe objects 
combination rules provide alternative means combining specifications different contracts apply participant 
similarly role models essentially hyperslices 
model describes particular roles played objects roles interact 
role models composed usually manually produce object definitions satisfy needed roles 
notkin propose approach implementing roles templates 
template defines role instantiation expressions create classes satisfy required roles 
collections related templates defining similar interacting roles objects constitute hyperslices model instantiation expressions composition rules 
adaptive programming approach providing modules classes object oriented systems 
class graph describes classes relationships particular point view 
class graphs contain code code written separate propagation patterns 
propagation patterns collection concrete classes conform class graph defined 
adaptive programs transformed standard object oriented programs demeter tools 
respect generated program propagation pattern hyperslice contains method code cuts classes 
composition performed demeter tool matching specifications class graph conformance 
propagation patterns overlap defines method reconciliation issue 
collaboration decomposition discussed contracts example 
collaborations hyperslices cutting classes 
catalysis facilitates building reusable design frameworks uml 
incorporates simple notion composition union design models 
represents instantiation model uml 
catalysis matching reconciliation rules fairly simple limits dimensions design models decomposed composed reasoning properties composed design terms component design models tractable 
viewpoints project approach requirements engineering 
modules called viewpoints encapsulate developers views process pieces requirements artifact developed 
different viewpoints may describe requirements artifacts different notations may create conflicting definitions requirements 
viewpoints system defines mechanisms theorem proving identifying helping developers cope inconsistency 
viewpoints approach shares number points common corresponding differences 
approaches predicated belief concerns modularized orthogonally possible view systems potentially overlapping pieces 
similarity concern resolving semantic differences different aspects elements system views hyperslices 
viewpoints emphasizes detection characterization inconsistencies deferring resolution reconciliation encompassing requirements process 
focused activity composing concerns separated including identifying especially reconciling inconsistencies composition rule 
primarily concerned artifacts constructed viewpoints approach primarily concerned viewed 
problems addressed approach tackled differently 
attempts address problem traceability environment support capturing maintaining relationships artifacts 
disparate structures artifacts particularly tough problem 
problem limiting impact change addressed various architectures mechanisms implicit invocation mediators event integration design patterns 
valuable suffer drawback kinds changes permit open points anticipated 
retrofitting mechanisms originally planned requires invasive change 
great deal done promote reuse researchers developers recognized importance large component reuse 
effective reuse requires powerful adaptation customization mechanisms current customization technology usually restricted interface adaptation sort adapter transformation layer substituting alternative modules predetermined points object oriented frameworks 
interesting builds adaptive programming support adaptive plug play components 
number important problems software engineering resisted general solution including problems related software understanding maintenance evolution reuse 
believe problems share common cause failure modern artifact formalisms satisfy separation concerns requirement adequately 
numerous reasons exist separate integrate software artifacts reasons may result different artifact structures 
concerns may relevant simultaneously entire set concerns may evolve time 
despite observation artifact formalisms include weak decomposition composition mechanisms permit small dominant set concerns separated 
leads directly inability achieve goals software engineering discipline 
model multi dimensional software decomposition helps overcome limitations 
permits encapsulation particular concerns software system artifacts allows kinds separation concerns may separable artifact formalisms units change features overlapping concerns 
improves traceability lifecycle 
model provides powerful composition mechanism facilitates integration adaptation plug play 
doing promotes reuse improves comprehension eases maintenance evolution 
approach addresses fundamental limitations software engineering 
reasons believe support multi dimensional decomposition composition represents key advances broad front software engineering challenges 
clearly early stage largely unproven 
considerable body experience related research exists support claim multidimensional separation concerns key software engineering issues today 
model just starting point 
refined stretched modified instantiated variety formalisms explore issues arise different methodologies different phases software lifecycle 
instantiations real development evaluate create new development methods exploit strengths explore issues intra inter artifact matching reconciliation explore impact multi dimensional separation concerns areas development methodology software process analysis testing reverse engineering reengineering software architecture 
joyce mark wegman reviewers provided valuable feedback earlier versions 
clarke produced see design uml 
andersen 
system design composing structures interacting objects 
madsen editor ecoop european conference object oriented programming pages utrecht june july 
springer verlag 
lecture notes computer science 
boehm scherlis 

proceedings darpa software technology conference pages april 
souza wills 
objects components frameworks uml catalysis approach 
addison wesley 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 
gosling joy steele 
java language specification 
addison wesley 
group 
online material adaptive programming demeter java 
www ccs neu edu research demeter 
harrison ossher 
subject oriented programming critique pure objects 
proceedings conference object oriented programming systems languages applications pages washington september 
acm 
holland 
specifying reusable components contracts 
madsen editor ecoop european conference object oriented programming pages utrecht june july 
springerverlag 
lecture notes computer science 

issues encountered building flexible software development environment lessons arcadia project 
proceedings fifth acm sigsoft symposium software development environments sde pages december 
kiczales 
aspect oriented programming 
proceedings european conference object oriented programming 
invited presentation 
kiczales lopes 
aspect oriented programming tutorial notes july 
ecoop 
lopes kiczales 
language framework distributed programming 
technical report spl xerox palo alto research center february 
mezini lieberherr 
adaptive plug play components evolutionary software development 
proceedings oopsla 
notkin garlan griswold sullivan 
adding implicit languages approaches 
nishio editors object technologies advanced software proceedings international symposium japan pages 
springer verlag november 
nuseibeh kramer finkelstein 
framework expressing relationships multiple views requirements specifications 
transactions software engineering oct 
ossher harrison simmonds 
subject oriented programming supporting decentralized development objects 
proceedings th ibm conference object oriented technology santa clara ca july 
ibm 
ossher kaplan katz harrison kruskal 
specifying subject oriented composition 

ossher tarr 
operation level composition case join point 
proceedings third workshop aspect oriented programming 
parnas 
criteria decomposing systems modules 
communications acm december 
reiss 
connecting tools message passing field environment 
ieee software july 
rumbaugh jacobson booch 
unified modeling language manual 
addison wesley 
appear 
sullivan 
mediators easing design evolution integrated systems 
phd thesis university washington aug 
turner fuggetta wolf 
feature engineering 
proceedings th international workshop software specification design pages april 
notkin 
roles components implement collaboration designs 
proceedings conference object oriented programming systems languages applications pages san jose california october 
acm 
weiser 
program slicing 
ieee transactions software engineering se july 
