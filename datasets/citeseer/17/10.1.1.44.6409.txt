disk scheduling dynamic request priorities li see tan chen roy campbell department computer science university illinois urbana champaign digital computer laboratory springfield urbana il stan cs uiuc edu high performance servers client server distributed systems manage multiplex disk resources efficiently fairly multiple clients 
digital multimedia systems clients may requests varying 
traditional approach problem assigns priorities disk requests 
high priority requests scheduled low priority requests served high priority queue empty 
approach permits priority optimization ignores seek optimization 
length high priority queue short compared low priority queue disk utilization low 
priority inversion disk scheduling algorithm priority seek optimization considered 
algorithm evaluated detailed simulation performance compared traditional scheduling algorithms 
identified conditions algorithm performs better 
simulation results show conditions achieve close reduction total system response time 
adaptive disk scheduling algorithm constructed outperforms traditional approach 
high performance servers client server distributed systems manage multiplex disk resources efficiently fairly multiple clients 
high number requests large scale distributed information systems world wide web servers popular sites digital library systems impose heavy load storage subsystems 
load condition varies considerably time 
addition busy multimedia servers handle requests different priorities 
file requests need disk access require appropriate disk scheduling algorithms order maximize system performance 
existing algorithms efficient disk scheduling include 
goals disk scheduling minimize ffl seek time system oriented ffl response time individual request oriented ffl variance response time 
scheduling algorithms proposed include come served fcfs shortest seek time sstf scan look 
algorithms operate requested track number 
emerging applications involving multimedia data impose additional constraints disk requests finish deadlines relative priorities 
example temporal constraints isochronous multimedia data necessitate deadlines data fetched 
careful consideration factors required consistent efficient management disk resources 
class new disk scheduling algorithms developed deal additional constraints 
common feature new scheduling algorithms additional constraints satisfied 
seek optimization considered secondary performed possible 
scheduling algorithms cases disk utilization low seek optimization secondary 
disk scheduling algorithm dynamic request priorities disk request increases priority served long time 
satisfying priority order disk requests consider seek optimization 
algorithm may serve low priority requests high priority requests 
priority inversions may occur cases 
system performance improved 
simulations done test performance algorithm different load conditions different parameter settings show total system response time reduced half original value 
remainder organized follows section discusses related disk scheduling 
section describes scheduling algorithm 
section presents simulation model 
detailed simulation results discussed section 
lastly summarize section 
related group traditional disk scheduling algorithms 
additional information making disk request scheduling decisions 
seek optimization done track information 
second group new algorithms additional information request deadline priority 
traditional disk scheduling algorithms fcfs policy random seek pattern 
take advantage positional relationships requests current queue current cylinder position read write heads 
general fcfs acceptable disk load light 
fcfs heavy load gives poor throughput 
sstf shortest seek time policy improves throughput servicing request results shortest seek distance 
sstf fast mean response algorithm gives rise large variances response time 
scan scan disk arm acts shuttle sweeps back forth cylinders servicing requests 
scan proposed alternative sstf discriminate individual requests 
scan reduces variance response time sacrificing terms increasing mean response time 
step scan variant scan step scan offers performance throughput mean response time 
step scan behaves scan services requests waiting particular sweep begins 
requests arriving sweep grouped ordered optimum service return sweep 
look variant scan disk arm reach inner outer track 
arm switches direction long outstanding requests direction 
look performs better scan low load conditions nearly equivalent scan load high 
scan scheduling strategy may tuned sstf scan adjustable parameter permitting dynamic adaptation algorithm changing system conditions 
heavy load tends scan light sstf 
simulation results scan superior scan sstf 
new disk scheduling algorithms additional requirements introduced applications digital multimedia database systems traditional disk scheduling algorithms described inappropriate 
new scheduling algorithms developed 
multimedia specific algorithms edf earliest deadline algorithm analog fcfs 
disk requests ordered deadlines request earliest deadline serviced 
edf similar expected seek time fcfs positional information scheduling decisions 
scan edf strategy combination scan edf mechanisms 
request earliest deadline serviced requests deadline specific scan direction served 
seek optimization applied requests deadline efficiency depends applied 
database specific algorithms priority schemes proposed managing dbms resources efficiently include processor scheduling disk scheduling buffer management 
scan algorithm modified support prioritized requests 
disk requests grouped basis priority group scan algorithm 
highest priority group serviced 
lower priority groups serviced higher priority groups empty 
new scheduling policies situations 
algorithms treat deadlines priorities seek optimization separately 
seek optimization considered additional requirement satisfied 
system performance may suffer cases 
give examples 
deadline track distance current head position request example considering seek time secondary may provide best system service 
example goal soft real time disk scheduling satisfy deadline disk requests possible 
edf edf scan service disk request earliest deadline 
illustrates example schedule algorithms inappropriate 
edf edf scan disk request deadline serviced 
service disk head needs move long distance 
served longer serviced deadline due large seek time required disk arm move backwards seek path 
service misses deadline 
considering seek time deadline improve system performance 
example example disk scheduling priorities higher priority queue non empty short 
situation lower priority requests get serviced system busy servicing high priority requests 
disk utilization low especially higher priority requests spaced far apart 
disk utilization increased promoting priority level low priority requests interval 
disk scheduling policy dynamic request priorities 
show benefit algorithm conditions applies 
priority inversion disk scheduling algorithm model problem disk requests kinds high priority low priority requests 
algorithm easily generalized multiple priority levels 
interested waiting time high priority requests 
concerned waiting time low priority requests 
low priority request low priority queue promoted high priority queue get serviced certain amount time 
example problem 
naive algorithm naive solution problem schedule high priority requests expense low priority requests 
low priority requests serviced high priority queue empty 
total waiting time sum waiting time high priority requests 
look scheduling algorithm service requests queue 
naive algorithm shown 
priority inversion algorithm described earlier problem naive algorithm high priority queue non empty short disk utilization low 
way improve disk performance case serve low priority requests high priority queue short 
disadvantage policy priority inversions may occur low priority requests serviced high priority requests high priority queue empty schedule high priority queue schedule low priority queue loop naive disk scheduling algorithm 
waiting queue 
higher disk utilization possible 
high priority queue empty schedule high priority queue schedule low priority queue length high priority queue select oldest request low priority queue put high priority queue loop greedy priority inversion disk scheduling algorithm 
shows greedy priority inversion disk scheduling algorithm 
algorithm high priority queue served 
high priority queue empty low priority queue serviced 
length high priority queue checked 
length high priority queue equal threshold move disk request low priority queue high priority queue 
disk utilization increased incur amount priority inversion 
low high promotion policy earliest request chosen change priority 
call previous priority inversion algorithm greedy algorithm 
length high priority queue threshold request low priority queue moved high priority queue 
algorithm may perform high priority requests 
high priority queue empty schedule high priority queue schedule low priority queue length high priority queue loop number high priority requests low limit select oldest request low priority queue put high priority queue conservative priority inversion disk scheduling algorithm 
situation low priority requests put high priority queue priority inversion may adversely impact improvement gained higher disk utilization 
order handle situation conservative priority inversion algorithm shown 
conservative algorithm length high priority queue threshold number high priority requests high priority queue tested 
number greater low limit move request low priority queue high priority queue 
algorithms fit situations 
intuitively clear ffl naive algorithm works disk load low ffl greedy priority inversion algorithm outperform disk load high high priority requests ffl conservative priority inversion algorithm suits situation state 
performed simulations test algorithms results discussed sections 
parameter meaning value number tracks disk actor seek time scaling factor ms rotational latency transfer time ms table parameters disk device 
parameter meaning request interval request arrival interval hp ercentage percentage high priority request change duration priority change duration table parameters disk workload 
simulation model disk model simulation built model requests system single data disk 
program models single head disk device track level 
model sectors tracks algorithms study perform rotational optimization 
parameters control system configuration shown table 
access time disk request tracks away current head position expressed equation access seek rotational latency time model rotational latency transfer time grouped single parameter 
seek time non linear respect seek distance current disk technology function calculate access time access actor theta workload model parameters control workload characteristics shown table 
requests service arrive exponentially distributed inter arrival times arrival interval denoted request 
number high priority requests controlled parameter hp ercentage 
percentage dictated mix high low priority requests 
hp ercentage indicates mix high priority low priority requests 
request accesses single track chosen uniformly range 
low priority request waits low priority queue change duration seconds moved high priority queue 
performance metrics sections discuss results experiments performed 
experiment ran simulation different random seeds obtain confidence interval 
run lasted seconds approximately requests processed request interval ms 
primary metric measure performance total response time 
recall waiting time collected high priority requests 
goal schedule requests order achieve lowest possible total response time 
interesting metrics average seek time total number priority inversions 
metrics helpful analyzing characteristics different algorithms 
experimental results experiments done test performance different algorithms different workload parameter settings 
chose request interval ms change duration 
performance greedy priority inversion algorithm collected different threshold hp ercentage 
second ran experiments different workloads 
effect request interval tested 
experimental results adaptive disk scheduling algorithm deal different situations 
experiment request interval ms change duration discussed previous section greedy priority inversion algorithm outperform naive algorithm disk load high 
experiment heavy workload chosen 
request interval selected ms corresponds arrivals second 
change duration set seconds 
threshold greedy threshold greedy naive threshold greedy naive total waiting time priority inversion number average seeking time request interval ms change duration hp ercentage 
threshold greedy naive threshold greedy naive threshold greedy naive total waiting time priority inversion number average seeking time request interval ms change duration hp ercentage 
compare algorithms hp ercentage equal 
requests high priority low priority 
experimental results plotted 
see greedy priority inversion algorithm small total waiting time threshold greater reaches maximum reduction total waiting time naive algorithm value threshold near 
greedy algorithm serves low priority requests high priority requests waiting large priority inversion number priority inversion number increases threshold large expected 
average seek time greedy algorithm decreases threshold increases 
high priority queue short filled low priority requests resulting increase disk utilization 
performance greedy algorithm worse naive algorithm threshold small 
reason threshold small high priority requests low priority requests promoted high priority queue 
length high priority queue kept threshold small value disk utilization low 
threshold increases effect greedy algorithm smaller 
large number priority inversions reduce potential benefit gained greedy algorithm 
experiment changed parameter hp ercentage order study situation high priority requests 
experimental results shown 
similar curves 
figures see greedy algorithm performs best threshold near 
reasonable requests high priority queue disk utilization low hand priority inversions 
experiments chose threshold greedy algorithm 
probability high priority request threshold threshold naive probability high priority request threshold threshold naive probability high priority request threshold threshold naive total waiting time priority inversion number average seeking time request interval ms change duration 
greedy algorithm naive algorithm compared different hp 
results shown 
greedy algorithm outperforms naive algorithm hp ercentage greater 
greedy algorithm reaches maximum total waiting time reduction hp ercentage 
hp ercentage small low priority requests served time 
naive algorithm low priority queue serviced queue length large 
performs better greedy algorithm high priority queue filled low priority requests serviced length 
hp ercentage large high priority queue long causing greedy algorithm chance take effect 
greedy algorithm performs best hp ercentage 
case greedy algorithm outperforms naive algorithm hp ercentage larger 
experiment vary workload experiment compare naive algorithm greedy algorithm different load conditions 
vary disk request arrival intervals ms ms 
results shown hp ercentage respectively 
due range difference partitioned parts performance difference shown clearly 
average arrival interval ms threshold naive average arrival interval ms threshold naive request interval ms ms request interval ms ms hp ercentage change duration 
observed greedy algorithm performs better load high request arrival interval ms ms 
naive algorithm smaller total waiting time arrival interval larger ms 
arrival interval ms ms better algorithm depends percentage high priority requests 
high priority requests better performance greedy algorithm 
observes naive algorithm sensitive load condition arrival interval ms ms call sensitive zone 
performance changes dramatically compared greedy algorithm points sensitive zone 
load condition predicted precisely average arrival interval ms threshold naive average arrival interval ms threshold naive request interval ms ms request interval ms ms hp ercentage change duration 
average arrival interval ms threshold naive average arrival interval ms threshold naive request interval ms ms request interval ms ms hp ercentage change duration 
difficult decide algorithm sensitive zone 
situation greedy algorithm greedy 
greedy algorithm performs poorly case moves low priority requests high priority queue aggressively 
candidate algorithm sensitive zone conservative algorithm 
discussed earlier low limit important parameter conservative algorithm 
shows result conservative algorithm compared naive greedy algorithms sensitive zone 
conservative algorithm performance greedy algorithm naive algorithm 
arrival interval near ms conservative algorithm performs better naive algorithm performance improvement greedy algorithm 
conservative algorithm performs better comparably naive algorithm load average arrival interval ms naive greedy low limit average arrival interval ms naive greedy low limit low limit average arrival interval ms naive greedy low limit low limit hp ercentage hp ercentage hp ercentage change duration 
light sensitive zone 
scheduling algorithm adaptive composition algorithms customizes changing load 
simulation results adaptive disk scheduling algorithm greedy algorithm threshold conservative algorithm naive algorithm greedy algorithm threshold conservative algorithm conservative algorithm naive algorithm adaptive algorithm performs better naive algorithm 
adaptive algorithm robust 
mean algorithm stable presence errors load condition measurement sensitive zone 
example load condition ms measurement ms adaptive algorithm performs better comparably naive algorithm 
accurately load condition measured better adaptive algorithm performs 
easy find performance crossover point greedy naive algorithms 
disk serves faster request arrival rate priority inversion caused greedy algorithm degrade system performance 
hand disk overloaded low priority requests rarely chance serviced 
increasing disk utilization servicing low priority requests helps improve system performance 
experiment know average seek time ms ms 
total disk access time ms 
sensitive zone formed request interval ms ms 
adaptive algorithm useful situations disk load low naive algorithm works fine clients rewarded small waiting times situations server overloaded overloaded applying greedy algorithm results reduction total waiting time 
clients served compared naive algorithm 
experiment vary change duration important parameter tested far change duration specifies long low priority request waits promoted 
compares greedy naive algorithms request interval ms 
hp ercentage experiments 
vary change duration seconds 
greedy algorithm performs better change duration small 
hp ercentage small naive algorithm works better change duration large 
high priority requests better greedy algorithm performs 
note total time run previous experiment seconds greedy algorithm take effect change duration seconds experiment 
change duration large greater seconds effective time greedy algorithm short compared running time 
longer experiment run results shown 
see greedy algorithm outperforms naive algorithm change duration values ranging seconds 
larger hp ercentage benefit achieved greedy algorithm 
priority changing duration threshold naive priority changing duration threshold naive priority changing duration threshold naive hp ercentage hp ercentage hp ercentage request interval ms run time 
priority changing duration threshold naive priority changing duration threshold naive priority changing duration threshold naive hp ercentage hp ercentage hp ercentage request interval ms run time 
high performance servers manage resources efficiently consistently 
heavily loaded systems world wide web servers digital library systems place large loads systems storage subsystems 
digital multimedia systems disk requests assigned priorities corresponding varying client requests 
disk scheduling algorithms fundamentally determine fast requests processed consistent low response times may achieved 
new greedy priority inversion disk scheduling algorithm detailed simulations done evaluate compare new algorithm naive algorithm 
experimental results show disk load light naive algorithm performs 
disk load high high priority requests new algorithm outperforms naive algorithm maximum total response time reduction 
situations demands placed server subsystems heavy new algorithm appropriate 
conservative algorithm reduces sensitivity load changes crossover point naive greedy vice versa 
adaptive disk scheduling algorithm subsystem select proper scheduling algorithm different load conditions percentage high priority requests 
adaptive algorithm performs consistently better single scheduling algorithm 
adaptive system relatively insensitive changes load sensitive zone arrivals disk requests just match service capacity disk 

optimizing performance drum storage 
ieee trans 
comput november 
abbott garcia molina 
scheduling real time transactions disk resident data 
proc 
th international conference large data bases amsterdam 
abbott garcia molina 
scheduling requests deadlines performance evaluation 
proc 
th real time systems symposium pages 
bitton 
arm scheduling shadowed disks 
digest papers compcon spring fourth ieee computer society international conference intellectual leverage pages 
bitton gray 
disk shadowing 
proc 
th vldb conference pages 
carey livny 
priority dbms resource scheduling 
proc 
th international conference large data bases amsterdam 
chen kandlur yu 
optimization group sweeping scheduling gss heterogeneous multimedia streams 
proc 
acm international conference multimedia pages anaheim ca 
coffman 
expected performance scanning disks 
siam comput february 
daniel geist 
scan adaptive disk scheduling algorithm 
proc 
ieee international symposium computer system organization 
denning 
effects scheduling file memory operations 
proc 
afips 
frank 
analysis optimization disk storage devices time sharing systems 
acm october 
geist daniel 
continuum disk scheduling algorithms 
acm transactions computer systems february 
jain 
art computer systems performance analysis techniques experiment design measurement simulation modeling 
john wiley songs new york 
kim srivastava 
enhancing real time dbms performance multiversion data priority disk scheduling 
proc 
th real time systems symposium pages 
li campbell 
dynamic priority scheduling method distributed systems 
proceedings international conference parallel distributed processing techniques applications pdpta pages november 
li campbell 
dynamic retrieval remote digital object 
proc 
acm fourth international conference information knowledge management cikm pages maryland november 
lin 
scheduling periodic aperiodic tasks hard real time computing systems 
proc 
sigmetrics acm press new york pages 
shepherd 
design storage services continuous media 
computer journal 
rowe 
interactive music system 
mit press cambridge ma 
salem el 
computers operating systems sstf dynamic disk scheduling technique 
proc 
third international conference software engineering real time system pages london uk 
steinmetz nahrstedt 
multimedia computing communications applications 
prentice hall ptr 
pinkerton 
comparative analysis disk scheduling policies 
communications acm march 
thomas kwan robert mcgrath daniel reed 
ncsa world wide web server design performance 
ieee computer pages november 
wilhelm 
anomaly disk scheduling comparison fcfs sstf seek scheduling empirical model disk accesses 
communications acm january 
yee 
disk scheduling policies real time multimedia applications 
technical report university california berkeley ca august 
