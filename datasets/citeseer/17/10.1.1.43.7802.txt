expressiveness linda coordination primitives nadia busi roberto gorrieri zavattaro dipartimento di scienze dell informazione universit di bologna zamboni bologna italy mail gorrieri cs unibo introduce process algebra containing coordination primitives linda asynchronous communication shared data space read operation non blocking test operators shared space 
compare possible semantics output operation call ordered defines output operation returns message reached shared data space call unordered returns just sending message tuple space 
process algebra ordered semantics turing powerful able program random access machine 
main result process algebra unordered semantics turing powerful 
result achieved resorting net semantics terms contextual nets nets inhibitor read arcs showing exists deadlock preserving simulation nets finite nets formalism termination decidable 
linda cg prominent representative family coordination languages principle generative communication gel gc sender communicates receiver shared data space called tuple space ts short emitted messages collected receiver read message remove ts message generated process independent existence tuple space explicitly withdrawn receiver fact insertion ts message equally accessible processes bound 
non blocking output operation sends message tuple space blocking read operation rd succeeds ts blocking input operation removes message ts linda offers conditional input read predicates called inp rdp cg cg car sca 
predicates check current status ts required message absent value false returned contrary message behavior rd operation value true returned 
process algebra containing coordination primitives linda parallel composition limited form recursion replication operator mil full version bgz 
consider eval operator linda process algebraic approach simply correspond spawn operation 
guarded inputs 
primitives rd represented prefix operators predicates modeled means constructs inp rdp conditional instructions direct flow control depending presence absence message ts message inp removes rdp 
test tuple removal message performed atomic step 
problem defining formal semantics linda attracted researchers see bgz overview 
interesting aspect related semantics output operation exist natural interpretations depending fact execution output primitive seen composed phases emission message sending ts rendering actual presence message ts denote hai 
different semantics suggested ffl ordered emission rendering message form single autonomous atomic action internal step agent parallel composition operator 
way order emission respected rendering order 
semantics processes synchronous respect ts emit messages hand shake protocol order implement sender sends message waits ts 
ffl unordered emission rendering message distinct autonomous actions 
emits message agent internal step free proceed ts hhaii takes internal step hai 
case processes behave asynchronously respect ts implementation consist send operation message ts waiting 
way order emission may respected rendering order instance process executes sequence may rendered emission rendering illustrative example consider inp 
assume ordered semantics input possible hbi ts execution inp enable differently assume unordered semantics guarantee hbi ts possible executed 
sca linda user guide sca supports unordered view see comment program reported page papers describing implementations car formal semantics linda jag cjy adopt ordered 
worthwhile investigate impact different interpretations operator expressive power process algebra 
aim provide ordered unordered semantics compare expressive power variations called respectively turing equivalence yardstick 
quite amazingly possess radically different expressive power ordered semantics get turing powerful language case unordered semantics 
turing completeness proved showing possible encode random access machine ram ss 
contrary proof turing complete elaborate constitutes main achievement 
proof consists showing problem termination decidable proceed follows ffl net semantics define net semantics terms contextual nets nets inhibitor read arcs see bp bus 
semantics defined style bg bgz preserves interleaving behaviour possibility deadlock 
ffl deadlock preserving simulation contextual net semantics mapping finite standard nets preserves deadlock 
deadlock decidable finite nets conclude termination problem decidable unordered semantics turing powerful 
organized follows 
section introduce syntax language report operational semantics primitive 
section presents ram implementation section presents proof non turing equivalence basic definitions nets contextual nets recalled distributed semantics mapping finite nets preserves deadlock shown 
language operational semantics messages denumerable set message names ranged 
syntax language defined grammar hai jp rd inp rdp agents ranged consist parallel composition messages ts denoted agent hai concurrent programs denoted share tuples 
program terminated program usually omitted sake simplicity prefix form form parallel composition programs 
prefix forms called sequential programs sequential subprograms appear subterms 
prefix linda primitives rd indicating withdrawing reading consumption emission message respectively 
consider bang operator form replication guarded input operations term ready consume message ts activate copy program forms model inp rdp primitives inp rdp program requires message consumed simply read program executed chosen 
agent denotes set containing possible agents 
different operational semantics terms labeled transition systems language ordered interpretation operator unordered interpretation previous section 
variations called respectively 
labeled transition systems kind agent label gamma 
label fa ranged ff fi set possible labels 
hai gamma 
gamma 
rd gamma 
gamma 
inp gamma 
rdp gamma 
inp gamma 
rdp gamma 
ff gamma 
jq ff gamma 
jq ff gamma 
gamma jq gamma 
jq gamma 
gamma 
jq gamma 
jq gamma 
gamma 
jq gamma 
jq table operational semantics symmetric rules omitted 
labeled transition relation gamma 
ordered semantics smallest satisfying axioms rules gamma table axiom table gamma 
unordered semantics considers axioms rules gamma 
sake simplicity omit symmetric rules gamma 
indexes distinguishing variations language transition relations omitted confusion arises 
axiom shows tuple hai able give contents environment performing action labeled axioms describe action performed prefixes rd labels respectively 
term able activate new copy program performing derivation labeled requires tuple hai consumed axiom 
axioms gamma describe semantics forms inp rdp required message consumed means derivation labeled read means derivation labeled 
cases required tuple hai absence guessed performing action labeled axioms 
usual rule parallel operator applied labels different fact agent willing perform derivation labeled composed parallel agent executability jq depends inability offer tuple hai 
guess wrong derivation labeled executed rule 
rule usual synchronization complementary actions rule represents new form synchronization labels agent performing derivation labeled left unchanged 
fact reading operation change state ts remove read tuple 
rules differentiate ordered unordered semantics table 
ordered approach output operation consists internal move creates tuple hai 
way sequence outputs executed tuples rendered order emitted 
unordered approach execution output operation emitting tuple ordered gamma 
unordered gamma 
hhaii gamma 
hai table semantics primitive 
contents directly generate corresponding term hai creates agent tuple hai available non predictable delay 
agent denoted hhaii term added syntax language case unordered semantics represents fact message sent ts received 
behaviour obtained allowing hhaii perform internal step hai 
note rule uses negative premise operational semantics defined described proposition transition system specification strictly gro condition ensures proved gro existence unique transition system agreeing 
proposition transition system specification table strictly 
proof consider function defined way ff gamma 
number parallel composition operators appearing function strict stratification transition system specification table ff gamma 
rule table number parallel composition operators strictly greater occurrences parallel operators ff gamma 
fi gamma appearing premises rule 
consider computations consisting reduction steps internal derivations stand agent able perform independently context 
language consider reductions usual derivations labeled labeled fact derivation gamma 
indicates tuples hai available external environment 
stand external environment considered able label introduced helping sos formulation semantics conceptually internal step 
formally gamma 
iff gamma 
gamma 
gamma 
state reached means reduction steps gamma 
reflexive transitive closure gamma 
agent dead gamma process algebra explicit notion state reasonable form termination agent absence outgoing transitions 
presence bang operator distinguish properly terminated consisting parallel composition agents deadlocked agents 
nontrivial containing bang agent outgoing transitions properly terminated 
order deal encoding recursive functions nondeterministic setting process algebra specify mean agent terminate 
approach formalisms calculus nondeterministic turing machines phrase structure grammars say agent terminates exists computation leading dead agent 
formally agent terminates deadlock exists dead agent gamma 
turing powerful show ordered semantics language turing powerful expressive model random access machine ram ss 
ram computational model composed finite set registers hold arbitrary large natural numbers program sequence simple numbered instructions arithmetical operations contents registers conditional jumps 
perform computation inputs provided registers registers program supposed contain value computation 
execution program begins instruction continues executing instructions sequence jump instruction encountered 
execution stops instruction number higher length program reached happens program executing instruction program instruction require jump current instruction requires jump instruction number appearing program 
program terminates result computation contents registers specified outputs 
min shown instructions sufficient model recursive function ffl succ adds contents register ffl contents register zero decreases go instruction jumps instruction example program computes sum registers putting result register note third instruction corresponds unconditional jump register contains value computation contents modified program succ state computation represented means configurations indicates instruction execute th contents register program configuration notation gamma 
state execution th instruction program contents registers program counter points th instruction registers contain model ram language encoding configurations programs 
program counter configuration represented program counter tuple hp contents register modeled occurrences tuple hr def hp ij hr ij times hr ij cn times model program composed sequence instructions consider parallel composition agents modeling instruction 
succ instruction register position represented agent consumes program counter tuple adds tuple updates program counter adding tuple instruction position modeled agent consuming program counter tuple performs inp message operation succeeds tuple hr withdrawn tuple space agent updates program counter adding hp jump th instruction performed adding hp def succ def def inp bang operator representation instructions permits reuse 
interesting note ram instruction realized implementation means internal steps consumes program counter second updates tests contents registers third introduces new program counter tuple 
agent modeling program starts computation configuration 
theorem ram program ffl soundness gamma 
exists unique configuration gamma 
ffl completeness gamma 
gamma 
proof cases possible instructions activated 
proof soundness fact program counter tuple hp term ensures agent corresponding th instruction move 
turing powerful implementation ram satisfy soundness property theorem unordered semantics 
consider execution program succ starting register empty 
implementation succ instruction creates tuples hr new program counter tuple hp tuple hp available hr instruction execute jump tuple hr available 
computation gives rise loop exited tuple hr available ts 
expected behaviour ram program terminates register empty incremented decremented 
assert implementation sound unordered semantics prove implementation ram exists 
fact remainder section show turing powerful 
order prove give contextual net semantics exists deadlock preserving mapping finite standard nets 
deadlock decidable nets conclude termination decidable sections recall definitions contextual nets net semantics provide obtained class nets deadlock preserving simulation finite nets 
contextual nets recall simple place transition nets capacity constraints places see gol 
extend contextual arcs see bp 
provide characterization model convenient aims 
definition set finite multiset function set dom fs finite 
multiplicity element natural number 
set finite multisets denoted fin ranged multiset dom called empty set finite sets denoted fin 
multiset write phi denotes multiset union phi 
operator denotes multiset difference gamma 
scalar product delta number delta delta 
notation abbreviation 
multiset containing occurrence element dom fsg denote multiset union represented comma phi multiset multiset abuse notation place vice versa 
definition system triple set places fin theta fin set transitions finite multiset set places 
finite multisets set places called markings called initial marking 
marking place say place contains tokens 
system finite finite 
transition usually written form gamma 
marking usually denoted ffl called preset represents tokens consumed marking usually denoted ffl called postset represents tokens produced 
transition enabled ffl execution transition enabled produces marking ffl phi ffl written gamma 
simply gamma 
transition relevant 
oe range sequences transitions empty sequence denoted oe write oe gamma 
mean firing sequence gamma 
delta delta delta gamma 
say reachable exists oe oe gamma 
place transition dom ffl dom ffl say self loop marking dead gamma net deadlock exists dead marking reachable deadlock problem net consists deciding deadlock 
transition live marking reachable exists marking reachable enabled net live transitions live 
liveness problem net consists deciding live 
deadlock problem finite system decidable proved reducing liveness problem known decidable see reu 
theorem slight generalization result proved cep nets preset postset transitions sets 
theorem deadlock reducible liveness 
proof system 
construct net 
ffl gamma 
ffl ffl gamma 
ok live ok gamma 
ffl phi ok ft tg show reachable dead marking iff live 
suppose reachable dead marking reach marking firing corresponding transitions 
ok transition live enabled transitions preset corresponding transition transitions enabled dead marking live 
suppose reachable dead markings 
reachable marking cases happen ffl ok transition live enabled firing live transition enabled ffl ok note produce token place ok remain marked transitions fired reach reachable reachable dead markings exists gamma 
gamma 
ok leading previous case 
definition contextual system triple set places fin theta fin theta fin theta fin set transitions initial marking 
transition usually written form gamma 
omitted empty 
set denoted called contextual set represents tokens tested presence set denoted ffi called inhibitor set represents tokens tested absence markings 
changes definition enabling transition enabled ffl phi dom ffi 
execution transition enabled producing marking written gamma 
defined 
net semantics basic idea underlying definition operational net semantics process algebra decompose process multiset sequential components thought dec dec hai dec hhaii dec fj pg dec qg dec jq dec dec table decomposition function 
hai gamma 
dec rd hai rd gamma 
dec gamma 
hhaii dec rend hhaii gamma 
hai inp inp hai gamma 
dec rdp hai rdp gamma 
dec inp hai inp gamma 
dec rdp hai rdp gamma 
dec hai gamma 
dec table net semantics 
running parallel 
sequential component corresponding place net represented token place 
reductions represented transitions consume produce multisets sequential components contextual conditions satisfied 
extend approach language representing tuples tokens corresponding places net way faithfully model rd operation tuple transition contextual arc tests presence token tuple place 
representation inp rdp predicates inhibitor arcs test tuple place absence tokens transitions representing selection branch 
agent define corresponding contextual system net 
order need notations 
ffl set fp sequential hhaii message 
ffl function dec agent fin decomposition agents markings reported table 
ffl contain transitions obtained instances axiom schemata table 
axioms table describing decomposition agents state agent generates tokens decomposition terms hai hhaii sequential programs produces token corresponding place parallel composition interpreted multiset union decomposition jq dec dec 
axioms table deal possible transitions 
axioms rd deal execution primitives rd case token place hai consumed second case tested presence 
axiom describes new token place hhaii generated output prefix new token consumed axiom rend generate new place hai 
axioms inp rdp similar corresponding axioms rd 
axioms inp rdp tuple hai tested absence agent selected 
axiom deals bang operator token place token consumed place hai new copy dec produced 
name transition parameters denote instance transition mean instance 
definition agent 
define triple net fq sequential subprogram hhaii message name pg fr gamma 
sequential subprogram dom rg message name pg dec proposition states net defined sense contextual system finite 
proposition agent net finite contextual system 
proof show net contextual system observe finite 
domain initial marking multiset set places dom dec finite 
transition legal net gamma 
easy see dom dom finiteness ensured facts ffl sets message names sequential subprograms finite due finite syntax ffl place corresponds sequential subterm message name ffl transition rend corresponds message name hand transition rend corresponds sequential subprogram dom ffl sequential subprogram set transitions dom ffl finite 
soundness completeness net semantics proof appropriateness contextual net semantics sos consists showing sequence sos reductions agent matched sequence transitions corresponding net vice versa 
kernel proof formed theorems show reduction derivable sos specification matched transition net show transition net corresponds reduction step transition system 
order prove need auxiliary results relating labelled sos transitions tokens corresponding places net 
propositions show ability agent perform output transition labelled corresponds presence token place hai marking corresponding agent 
proposition agent 
gamma 
exists marking dec hai phi dec proof proceed induction proof transition gamma 
base case trivial hai 
induction case jp restrictive suppose jp gamma 
induction hypothesis exists marking dec hai phi dec sufficient take phi dec dec jp hai phi phi dec dec jp phi dec 
proposition agent 
dec hai phi exists agent gamma 
dec proof structural induction agent perform input resp 
read transition labelled resp 
token place corresponding sequential subprocess starting input resp 
read message proposition agent 
gamma 
holds 
dec fin qg phi dec dec phi 
dec qg phi dec dec phi dec 
dec phi dec dec phi proof induction proof transition gamma 
proposition gamma 
holds 
dec qg phi dec dec phi 
dec phi dec dec phi proof induction proof transition gamma 
need show reduction agent reachable sequence reductions matched firing corresponding transition net 
prove general result considering agents reachable examine agents decomposition turns legal marking net 
theorem net 
agent dom dec 
gamma 
exists dec gamma 
dec ffi 
gamma 
exists dec gamma 
dec ffi 
proof order prove item proceed induction proof transitions gamma 
base case consists possible axioms table hhaii gamma 
hai gamma 

case dec hhaii 
thesis follows rend gamma 
dec hai 
second case dec fout qg 
thesis ensured derivation fout qg gamma 
phi dec phi dec dec 
induction case possible rules derive transition treatment symmetric rules similar 
rule 
case jr jr gamma 
inductive hypothesis applied dom dec dom dec dec gamma 
dec ffi 
dec jr dec phi dec gamma 
dec phi dec dec ffi 

rule 
case jr jr gamma 
gamma 
inductive hypothesis applied dom dec dom dec 
propositions possible cases consider 
analysis treated similarly 
dec fin qg phi dec dec phi proposition dec phi dec dec jr dec phi dec fin qg phim phim fin qg phim phim gamma 
dec phi phi dec phi dec dec jr ffi 

rule 
similar case 
order prove second item theorem proceed induction proof transitions gamma 
base cases consist axioms table 
consider axiom inp dec inp inp gamma 
dec ffi inp 
induction case rule table order derive transition jr jr gamma 
gamma inductive hypothesis dec gamma 
dec ffi 
proposition gamma ensures hai dec 
dec jr gamma 
dec jr 
decomposition agent contains sequential subprocess starting input resp 
read message agent perform input resp 
read transition labelled resp 

proposition agent 

dec fin qg phi exists agent gamma 
dec dec phi 
dec qg phi exists agent gamma 
dec dec phi dec 
dec phi exists agent gamma 
dec dec phi proof structural induction proposition agent 

dec qg phi exists agent gamma 
dec dec phi 
dec phi exists agent gamma 
dec dec phi proof structural induction show transition net corresponding agent matched corresponding reduction agent reachable sequence reductions 
theorem prove result general setting 
transition net note ffi ffi message theorem net 
agent dom dec dec gamma 
exists dec 
ffi gamma 

ffi gamma 
proof case analysis transitions structural induction show significative cases 
ffl transition rd 
ffi rd dec phi dec phi phi dec contains elements jr cases happen dec qg phi dec phi phi proposition exists gamma 
dec dec phi proposition exists gamma 
dec rule table jr gamma 
jr holds 
dec jr dec dec phim phim dec phim dec phi dec qg phi phi symmetric rule 
dec phi phi dec 
transition rd enabled dec dec rd gamma 
phi dom dec dom dec inductive hypothesis gamma 
dec phi rule table get jr gamma 
jr dec jr dec phi dec dec phi phi phi dec ffl transition inp 
ffi inp dec phi hai dec phi cases happen inp case rule gamma 
jr dec phi phi dec 
hai implies hai inp enabled dec dec inp gamma 
dec phi dom dec dom dec inductive hypothesis gamma 
dec dec phi dec hai dec hai 
proposition gamma rule table obtain jr gamma 
jr holds dec jr dec phi phi dec dec phi jr dec phi phi dec 
symmetric rules 
able state contextual net translation sound complete respect reduction semantics introduced previous section 
corollary agent 
ffl soundness dec gamma 
gamma 
net exist gamma 
gamma 
dec ffl completeness gamma 
gamma 
dec gamma 
dec gamma 
dec net 
proof induction soundness directly follows theorem completeness corollary theorem 
respect deadlock theorem ensures net semantics preserves sense process deadlock iff net deadlock 
deadlock decidable show process exists finite system dnet equivalent net deadlock providing net transformation removes contextual arcs price adding new places normal transitions 
describe transformation informally presenting formal definition dnet 
self loop inhibitor arc read arc flow arc hai rd dec hai rd dec eliminating read arcs net 
hhaii rend inp dec inp hhaii rend dec inp inp inp dec dec hai hai eliminating inhibitor arcs net 
dec div hai hai hai bea inp div inp div inp div dec div dec div transforming net div deadlock equivalent system 
read arcs read arcs replaced self loops way test presence token changed consumption followed emission token place 
transformation preserves firing sequences deadlock behaviour 
instance transformation 
graphical representations different kinds arc shown 
inhibitor arcs regarding inhibitor arcs attempt remove replacing transition inp inp gamma 
dec 
approach structure net studying places tested absence hai transition producing tokens hai rend 
transition rend performs smooth transformations marking leaving unchanged places corresponding sequential subprograms 
reason possible change position rend transitions firing sequence compromising reaching marking 
example consider system obtained applying transformation contextual system net represented 
permits firing sequence oe rend rend 
corresponding firing sequence oe rend rend inp due inhibitor arc connecting place hai transition inp 
obtain legal firing sequence oe inp rend rend leading marking delaying rend transitions produce tokens inhibiting place mentioned 
problems arise 
ffl initially messages problem due presence messages initial state 
div divergent agent div 
consider agent div 
net reported transition inp div leading marking dec div easy see dead marking reachable 
substituting self loop read arc eliminating inhibitor arcs obtain net div fire leading dead marking containing token hai behaviour deadlock preserved 
due fact place hai contains tokens initial marking tokens produced occurrence transition rend apply trick described obtain legal firing sequence previously reached markings contain tokens hai 
apply trick wait tokens hai initial marking consumed point current marking contains tokens place hai transitions rend occurred 
solve problem way see add auxiliary place contents equals number tokens consumed place hai 
place transitions inhibited hai sure tokens initial marking consumed 
place empty initial marking filled token transition consuming message hai 
denoting number tuples hai initial ts add self loop arc weights transitions inhibited hai net representation agent ffl messages tested presence problem arises transitions testing presence messages 
consider agent jin inp div represents net system obtained application transformations described 
net dead markings start firing sequence oe rend rd rend inp div 
firing token contained hai transition fired inp div leading marking dec div dead marking reachable 
net firing oe div fire leading dead marking example indicates trick delaying rend transitions applicable general 
particular rend delayed rd token tested presence transition token produced 
detail problem messages tested presence due fact transition testing consuming token hai happens sure token contained hai reached marking fire transition token consumed transition 
consider firing sequence leading marking place hai contains single token suppose transition rend producing occurs rd turn followed transition removing tokens hai 
token tested presence exactly produced sequence obtained removing 
solve problem adding auxiliary places ab pr message name token pr denotes fact sure token contained hai 
place ab complementary pr contains token iff pr dec div dec div bea inp div hhaii hai hhaii hai rd rd hbi hbi inp div inp div inp div transforming net jin inp div 
pr hai pr gamma 
dec ab ab hai ab gamma 
dec ab rd pr rd hai pr gamma 
dec hai pr rd ab rd hai ab gamma 
dec hai pr gamma 
hhaii dec rend hhaii gamma 
hai inp pr inp hai pr gamma 
dec ab inp ab inp hai ab gamma 
dec ab rdp pr rdp hai pr gamma 
dec hai pr rdp ab rdp hai ab gamma 
dec hai pr inp inp delta ab gamma 
dec delta ab rdp rdp delta ab gamma 
dec delta ab pr hai pr gamma 
dec ab ab hai ab gamma 
dec ab table net semantics preserves deadlock parametric agent 
empty enable transition net corresponding transition inhibited place hai net 
sum tokens pr ab equal reached marking 
correct information places maintained transitions testing consuming tokens hai 
testing consuming transition sure token hai consuming transition longer sure fact hai empty 
split transitions transitions possible contents auxiliary places 
pr version consuming transition removes token pr puts token ab ab version self loop place ab pr version testing transition self loop place pr ab version removes token ab puts token pr putting mechanisms listed obtain transformation net system dnet turns equivalent net deadlock 
illustrates complete transformation net 
observe marking place inp div contains token place ab empty ensures dead marking reached 
formally defining dnet need auxiliary notation 
ffl denote number tuples hai available term rd dec div dec div hai pra hhaii aba hbi pr ab bea inp div inp div dnet jin inp div 
sequential program hai hhaii jp ffl contains transitions obtained instances axiom schemata parametric agent table 
definition parametric transitions inp rdp number occurrences hai initially available agent definition agent 
define triple dnet fq sequential subprogram hhaii pr ab message name pg fc gamma 
sequential subprogram dom message name pg dec phi fab message name pg case dnet defined system finite 
proposition agent dnet finite system 
proof similar proof proposition 
ready show net dnet behaviour deadlock 
proof proceeds follows show dead marking net exists dead marking dnet markings coincide common places prove vice versa holds 
proofs results relating firing sequences net firing sequences dnet 
function parametric fpr abg maps transitions net transitions dnet pr rend ab rend rend pr ab pr inp ab inp inp pr rdp ab rdp rdp pr pr ab ab pr rd rd pr ab rd rd ab pr inp inp pr ab inp inp ab pr rdp rdp pr ab rdp rdp ab pr pr ab ab reverse mapping defined iff pr ab 
observe defined exists pr ab function extended sequences transitions elementwise application 
define sets transitions useful rd sets transitions net net consuming resp 
testing presence tokens place hai rd corresponding sets net dnet 
fin inp sequential rd rdp sequential ff pr ab rd ff pr ab rd transitions called transitions ones rd rd rd transitions 
agent proposition provides relation transitions related 
changes produced firing related transitions respective markings common auxiliary places 
second item relate related transitions markings agreeing common places 
proposition agent equivalently ab pr 
ffl ffl ffl ffl 
ffl ffl phi instance inp rdp ffi proof case analysis axioms table 
proposition general properties reachable markings dnet telling places ab pr behave expected 
number tokens place corresponds number occurred transitions 
sum tokens places ab pr equal 
place ab contains token iff rd transition followed transition 
proposition agent dnet 
gamma 
gamma 

jfk gj 
pr ab 
ab iff rd proof induction lemma relates firing sequences net ones dnet firing sequence net exists firing sequence dnet obtained replacing transition image ab pr reached markings coincide common places 
lemma agent net dnet 
gamma 
gamma 
gamma 
gamma 


pr rd gamma pr ab proof induction nonempty property easily follows definitions net dnet 
suppose gamma 
gamma gamma 
gamma gamma 
inductive hypothesis gamma 
gamma gamma 
gamma gamma gamma condition lemma satisfied gamma 
show exists satisfying condition lemma enabled gamma cases happen ffl inp rdp transition 
cases happen rd transition 
rend message name gamma gamma item proposition pr ab enabled gamma exists rd pr 
gamma gamma item proposition pr enabled gamma exists rd pr 
item proposition pr implies ab 
proceeding obtain ab enabled gamma ffl inp 
take inp inp ab inp condition lemma satisfied 
show enabled gamma show gamma inp 
enabled gamma gamma inp 
gamma gamma coincide common places gamma inp 
show gamma 
enabled gamma gamma hai 
definition net hai 
observing transitions able remove tokens place hai remove exactly token follows transitions occurred jfi gamma gj 
definition ab resp 
pr iff ab resp 
pr 
condition lemma holding inductive hypothesis gamma ensures iff gamma jfi gamma gj jfi gamma gj 
item proposition gamma jfi gamma gj gamma 
show gamma ab 
start showing transition rd followed transition 
suppose exists gamma rd gamma 
rd gamma hai hai 
subsequent transition consuming tokens hai gamma hai contradicting fact enabled gamma observed inductive hypothesis definition ab pr iff gamma 
easy see holds sets rd rd 
firing sequence gamma transition rd followed transition 
item proposition gamma ab 
ffl rdp 
similar case 
marking produced firing inductive hypothesis gamma gamma item proposition markings coincide common places 
theorem states dead marking net corresponds dead marking dnet reached firing sequence obtained firing sequence leading replacing transition image ab pr show reached marking dnet dead difficult case instance inp rdp fire solved showing places inp rdp empty dead markings net 
theorem agent net dnet 
net deadlock dnet deadlock 
proof suppose oe gamma 
gamma lemma oe gamma 
show gamma suppose gamma 
cases happen ffl instance inp rdp 
item proposition transition net fire contradiction 
ffl inp 
inp markings coincide common places inp 
hai transition inp fire transition inp fire contradiction 
ffl rdp 
managed previous case 
need auxiliary partial functions sequences transitions net removes occurrences transition rend removes transitions rend 
definition oet oe rend oe oe oe oet oe rend oe 
note oe defined oe contains occurrences transition rend 
lemma important property firing sequences net 
reached marking contains tokens place hai 
tokens hai initial marking consumed transitions number occurrences transitions greater equal number tokens hai initial marking 
rd transition followed transition firing sequence obtained dropping occurrences rend initial marking 
lemma agent net message name 

gamma 
gamma 
phi delta hai 
jfi gj hai 
rd oe gamma 
phi delta hhaii oe 
proof induction case trivial 
gamma 
delta delta delta gamma 
phi hai phi gamma delta hai 
inductive hypothesis gamma 
delta delta delta gammak gamma 
gammak gammak gamma gammak phi hai phi gamma delta hhaii 
start showing transition sequence gammak contains rend transition 
gamma removes rend transitions easy see properties lemma imply conditions dealing transition sequence gammak jfi gamma gj hai gamma rd property saying number transitions greater equal initial marking place hai observing gammak hai transition rend occurs gammak occurrence rend show sequence gamma gammak take hai phi hhaii 
want show gamma 
gamma gamma 
gamma gamma 
gammak gamma 
gammak part gamma 
gamma gamma 
gamma valid inductive hypothesis 
rend gamma gamma 
gamma hhaii phi hai definition gamma remains show gamma 
gammak gamma 
gammak prove enabled gamma 
jfj gamma gj number transitions occurring fact transition producing tokens hai gammak hai hai consider gammak cases happen ffl 
hai 
definition hai 
coincide places different hai hhaii transition needs exactly token hai tokens hhaii enabled ffl rd 
exists gamma 
proceeding hai 
reasoning show enabled ffl rd 
obtained removing token hai adding token hhaii seeing hai pre test set hhaii inhibitor set enabled show firing reach ffl phi ffl need auxiliary result hai gamma 
definition transition producing tokens hai implies hai hai gammak hai 
gammak hai hai hai gamma 
hai phi hhaii showing ffl phi ffl proving hai phi hhaii ffl phi ffl definition hai phi hhaii gamma 
ffl phi ffl ffl phi ffl hai phi hhaii 
remains show hai phi hhaii ffl phi ffl ffl phi ffl hai phi hhaii 
equality easily derived facts hai hai ffl ffl statements true enabled 
gammak gamma rend transition occurring gammak gamma gammak 
gammak gammak hai phi hhaii gammak phi hai phi gamma delta hhaii get gammak phi delta hhaii 
lemma relates firing sequences dnet firing sequences net correspondence markings preserved close correspondence transitions lemma may happen transition inp fires dnet place hai empty forbidding firing corresponding transition inp net 
enabledness inp ensures hypothesis lemma satisfied defining number tokens hai obtain firing sequence net dropping rend transitions fire inp enabled fire dropped rend transitions 
lemma agent net dnet 
oe gamma 
exist marking permutation oe 
oe 
gamma 

proof induction oej 
oej theorem trivially follows definitions net dnet 
take oe oe exists oe gamma 
gamma 
inductive hypothesis exists permutation oe 
oe 
gamma 

show exists permutation oe satisfying conditions lemma 
distinguish cases ffl instance inp rdp 
take transition sequence permutation oe permutation oe 
show requirements lemma satisfied sequence 
item inductive hypothesis definition oe 

gamma 
item inductive hypothesis item proposition enabled denoting marking resulting firing gamma 
item inductive hypothesis get gamma 

item inductive hypothesis item proposition follows ffl inp 
enabledness ensures inp item inductive hypothesis inp 
cases happen hai inp enabled reasoning show case properties lemma satisfied 
hai take phi delta hai hai 
show firing sequence gamma 
satisfies conditions lemma 
gamma 
phi delta hai 

enabled item proposition occurrences transitions sequence oe belong set transitions 
seeing definition iff transitions dnet sequence oe contains occurrences transitions 
permutation oe holds second condition lemma satisfied hai definition net 

enabled ab item proposition transition oe belonging rd followed transition 
iff holds replacing rd rd oe transition belonging rd followed transition 
oe property holds condition lemma satisfied 
applying lemma ae gamma 
phi delta hhaii ae 
take ae rend remembering removes occurrences transition rend permutation oe easy see permutation oe 
show requirements lemma satisfied 
inductive hypothesis oe definition obtain oe 

show observed prefix ae fired remains show rend reached marking delta hhaii 
inp observing differ place hai inp hai definition transition inp fired phi delta hhaii 
firing change marking place hhaii tokens hhaii firing firing sequence fired place 

observed permutation oe 
permutation ordering transitions influence reached marking lines previous case show property lemma satisfied ffl rdp 
similar previous case 
dead marking net corresponds dead marking dnet 
theorem agent net dnet 
dnet deadlock net deadlock 
proof suppose oe gamma 
gamma lemma exists permutation oe oe gamma 
show gamma suppose gamma 
cases happen ffl instance inp rdp 
easy see item proposition item proposition transitions ab pr fire ffl inp 
show inp enabled enabled inp 
coincide common places inp 
enabled hai tokens hai initial marking consumed occurrences transitions oe permutation property holds oe 
noting iff transitions dnet occurrences transitions oe 
item proposition get 
suppose transition rd occurs followed transition hai contradicting fact enabled oe property holds oe 
noting iff holds replacing rd rd property continues hold oe item proposition ab 
inp ab transition inp enabled contradiction 
ffl rdp 
analogous previous 
theorems allow conclude termination problem decidable shown presence deadlock finite systems decidable 
corollary turing powerful 
proof contradiction turing powerful allows program computable functions 
possible encoding function input problem termination decidable 
comes pair bgz studied operational observational semantics different interpretations output operation containing rd rdp 
ordered unordered semantics studied called instantaneous semantics structural equivalent adopted asynchronous calculus ht bou 
behavioural semantics operational semantics defined widely accepted approach ms 
main results bgz variant asynchronous bisimulation acs correct semantics instantaneous interpretation correct semantics cases variant classic synchronous bisimulation mil inputs outputs treated symmetrically 
bgz claimed non turing completeness unordered semantics result strengthened holds presence rd rdp proved full detail 
authors anonymous referees helpful comments 
acs amadio castellani sangiorgi 
bisimulations asynchronous calculus 
theoretical computer science 
bou boudol 
asynchrony calculus 
technical report inria sophia antipolis 
bc brogi ciancarini 
concurrent language shared prolog 
acm transactions programming languages systems 
bus busi 
petri nets inhibitor read arcs semantics analysis application process calculi ph thesis department mathematics university siena italy 
bg busi gorrieri 
petri net semantics calculus concur volume lncs 
bgz busi gorrieri zavattaro 
truly concurrent view linda interprocess communication 
technical report ublcs department computer science university bologna february 
bgz busi gorrieri zavattaro 
semantics output operation generative communication 
coordination volume lncs 
bgz busi gorrieri zavattaro 
process algebraic view linda coordination primitives 
theoretical computer science 
bgz busi gorrieri zavattaro 
turing equivalence linda coordination primitives 
express volume electronic notes theoretical computer science 
bp busi 
causal semantics contextual nets 
proc 
world scientific 
car carriero 
implementation tuple space machines 
research report yaleu dcs rr 
cg carriero gelernter 
write parallel programs guide 
acm computing surveys volume 
cg carriero gelernter 
write parallel programs course 
mit press 
carriero gelernter zuck 
bauhaus linda 
object models languages concurrent systems volume lncs pages 
springer verlag 
cep cheng esparza palsberg 
complexity results safe nets 
theoretical computer science 
cjy ciancarini jensen 
operational semantics coordination language 
object models languages concurrent systems volume lncs pages springer 
douglas wood rowstron 
linda implementation revisited 
transputer occam developments pages ios press 
gel gelernter 
generative communication linda 
acm transactions programming languages systems 
gc gelernter carriero 
coordination languages significance 
communications acm 
gol goltz 
ccs petri nets 
lncs springer verlag 
gro groote 
transition system specifications negative premises 
theoretical computer science 
ht honda tokoro 
object calculus asynchronous communication 
ecoop volume lncs pages 
springer verlag 
jag jagannathan 
semantics analysis class tuple spaces 
technical report yaleu dcs tr department computer science yale university april 
mil milner 
communication concurrency 
prentice hall 
mil milner 
polyadic calculus tutorial technical report department computer science university edinburgh ecs lfcs october 
ms milner sangiorgi 
barbed bisimulation 
icalp volume lncs pages springer verlag 
min minsky 
computation finite infinite machines 
prentice hall englewood cliffs 
montanari rossi 
contextual nets 
acta informatica 
nar 
informal operational semantics linda 
technical report department computer science yale university yaleu dcs tr december 
reu reutenauer 
mathematics petri nets 
masson 
sca scientific computing associates 
linda user guide manual 
scientific computing associates 
ss shepherdson sturgis 
computability recursive functions 
journal acm 
