branch prediction free thomas ball james larus tom cs wisc edu larus cs wisc edu computer sciences department university wisconsin madison dayton st madison wi usa technical report february abridged version appear sigplan conference programming language design implementation june 
branch prediction free thomas ball james larus tom cs wisc edu larus cs wisc edu computer sciences department university wisconsin madison dayton st madison wi usa compilers rely branch prediction improve program performance identifying frequently executed regions aiding scheduling instructions 
profile predictors require time consuming inconvenient compile profile compile cycle order predictions 
program branch predictor performs large diverse set programs written fortran 
addition natural loop analysis predict branches control iteration loops focus heuristics predicting non loop branches dominate dynamic branch count programs 
heuristics simple require little program analysis effective terms coverage rate 
program prediction equal accuracy profile prediction believe reaches sufficiently high level useful 
additional type semantic information available compiler enhance heuristics 

study behavior branches programs show simple static program heuristics predict branch directions surprisingly high accuracy 
heuristics go simply identifying loop branches programs non loop branches occur frequently loop branches 
heuristics inexpensive employ simple implement accurately predict high percentage loop branches large diverse set programs including programs complex conditional control flow 
measurements show perfect static predictor potential predict dynamic loop non loop branches rate approximately 
naive strategies predict target fall successor non loop branch rate approximately 
heuristic average rate supported national science foundation ccr ccr 
copyright thomas ball james larus 
abridged version appear acm sigplan conference programming language design implementation 
non loop branches performance benchmarks appear difficult predict 
account loop branches employ accurate heuristic common technique simply identifying backwards branches heuristics average rate 
compiler optimizations rely branch prediction identify heavily executed paths 
addition introduced architectures dec alpha mips exact heavy pipeline penalty branch cycles 
help alleviate problem architectures predict forward conditional branches taken backward conditional branches taken relying compiler arrange code conform expectations 
run time profile information program execution typically statically predict branch directions 
fisher freudenberger observed profiled static branch prediction works branches take direction high probability highly probable direction different program executions 
profile branch prediction quite accurate inconvenient time consuming 
program compiled 
profiled program instrumented counting code may done compiler tool 
instrumented program executes possibly times produces profile 
program recompiled aid profile 
process requires compilations execution 
furthermore program changes entire process repeated 
hand program prediction employed original compilation branch predictions 
program prediction factor worse average profile prediction believe reaches sufficiently high level useful 
organized follows 
section contains background material describes benchmark programs 
section classifies loop non loop branches compares behavior 
section presents simple heuristics non loop branches measures effectiveness isolation 
section considers combining simple heuristics complete heuristic contains results heuristic 
section presents results heuristic performs finding sequences instructions mispredicted branch 
compare profile methods measuring quantity trace methods show trace methods preferable 
section examines performance heuristic different datasets 
section reviews related section concludes 

background restrict heuristics predicting way conditional branches fixed targets 
word branch refers branches 
consider branches target dynamically determined lookup jump table example 
associated conditional branch instruction target successor instruction control passes branch condition evaluates true fall successor instruction control passes branch condition evaluates false 
profiling tracing tool qpt platform studying branch behavior making branch predictions 
qpt takes input mips executable file produces instrumented program generates branch profile branch count times control passes target successor fall successor run 
qpt instrument program produce instruction address trace 
qpt operates executable file program procedures analyzed 
numbers include dec ultrix library procedures application procedures 
order instrument executable file qpt builds control flow graph procedure executable file 
vertex control flow graph represents basic block instructions 
basic block conditional branch corresponds vertex control flow graph outgoing edges 
root vertex control flow graph entry point procedure 
basic block containing return procedure exit successors control flow graph 
heuristics control flow graph domination relations 
vertex dominates path entry point procedure includes vertex postdominates path exit vertex includes successor branch postdominates branch matter direction branch takes successor eventually executes 
analyzed programs spec benchmark suite number programs 
benchmarks listed table description function 
broken benchmarks major groups programs perform little floating point computation programs perform floating point operations 
group programs sorted size object code 
benchmarks compiled analyzed decstation mips processor optimization 
results sections single execution benchmark 
previous shown branches behave similarly different executions 
branch takes direction high probability execution program takes direction high probability executions 
goal show static prediction accurately determine branch directions confirm previous results 
tested predictor multiple datasets benchmark similar results 
section summarizes results experiments 
concerned static branch prediction 
branch target successor fall successor predicted prediction change execution program 
predicting branch corresponds choosing outgoing edges vertex containing branch control flow graph 
standard static branch prediction potentially performs perfect static predictor predicts frequently executed outgoing edge branch program 
perfect predictor low rate branches follow direction high probability 
branches take directions approximately equal probability perfect static predictor better rate 
code size program description language bytes congress interpreter prolog language postscript gcc gnu compiler lcc fraser hanson compiler rn net news reader espresso pla minimization qpt profiling tracing tool awk pattern scanning processing xlisp lisp interpreter eqntott boolean equations truth table integer program solver compress file compression utility grep search file regular expressions poly game spice circuit simulation doduc monte carlo simulation fpppp electron integral derivative dnasa floating point kernels tomcatv vectorized mesh generation matrix matrix multiply solve minimum cost flow dcg conjugate gradient gaussian elimination table 
benchmarks sorted code size 
spec benchmarks marked 
fortran benchmarks marked perfect predictor provides upper bound performance static predictor 
branches perfect predictor performs poorly predicted static predictor 
measure predictor performs set branches percentages notated percentage dynamic branches mispredicted rate rate perfect predictor 

loop branches non loop branches section show predicting non loop branches key branch prediction programs 
addition show static predictor potentially predicting non loop branches 
precisely classify branches loop non loop 
backwards branches code backwards branch passes control address address branch instruction usually control iteration loops 
non backwards branches control iteration loops exiting loop continuing iteration 
benchmarks loop branches backwards branches account high percentage loop branches example dynamic loop branches xlisp backwards branches loop branches doduc backwards branches 
branches easily identified natural loop analysis control flow graph review 
vertex target loop backedges identified depth search control flow graph root vertex loop head 
removing backedges control flow graph eliminates directed cycles 
natural loop loop head nat loop exists backedge free path edge vw exit edge loop nat loop nat loop nat loop 
clear definition natural loop vertex nat loop successors 
vertex outgoing edges exit edges exactly outgoing edges exit edge 
classify branches follows branch loop branch outgoing edges exit edge loop backedge 
branch non loop branch outgoing edges exit edge backedge 
loop branches accurately predicted follows outgoing edges backedge predicted 
non exit edge predicted 
intuition loops iterate times exit 
loop prediction chooses iterating exiting 
illustrates loop non loop branches 
edges db eb backedges 
natural loop loop head contains vertices exit edges cf ef 
vertices non loop branches loop branches 
predictions loop branches cd db eb respectively 
table shows breakdown dynamic branches benchmark loop classification scheme 
group programs ordered percentage dynamic branches non loop branches branches 
programs executions dominated non loop branches 
consider loop branch predictor performs 
loop branches column pred perf contains rates loop predictor perfect predictor applied loop branches 
results surprising 
control flow graph loop 
bold edges backedges dashed edges exit edges 
vertices loop branches 
theoretically possible outgoing edges branch loop backedges occurred analysis benchmarks 
occur predict edge leads innermost loop 
loop predictor cases approaches perfect predictor compress eqntott 
mean rate loop predictor 
consider non loop branches 
perfect predictor perf performs benchmarks implying non loop branches take direction high probability 
benchmarks non loop branches better behaved loop branches 
instance gcc xlisp perfect static predictor better non loop branches loop branches 
target shows performance simple strategy predicts target successor 
surprisingly heuristic fare 
pays choose target grep fall compress qpt rn 
mean rate 
fact benchmarks random prediction random performs better predicting target mean 
numbers show simply predicting target fall produces results varying quality mediocre loop branches non loop branches program pred perf 
target perf 
random perf 
big branches num gcc lcc qpt compress xlisp eqntott rn grep congress espresso awk poly fpppp doduc tomcatv dcg spice dnasa matrix mean std dev 
table 
dynamic breakdown loop branches vs non loop branches 
class branch perf rate perfect predictor 
pred shows rate loop predictor loop branches 
branches percentage branches non loop branches 
target shows results predicting target successor non loop branch random shows results predicting non loop branch randomly 
big shows non loop branches program contributed percent dynamic non loop branches percentage big branches account 
performance 
compiler predict non loop branches architecture dec alpha sophisticated strategy necessary 
correctly predicting frequently executed branch high payoff 
column big shows distinct non loop branches program generate percent dynamic non loop branch executions percentage dynamic non loop branches accounted branches 
benchmarks eqntott grep tomcatv matrix handful non loop branches program produce dynamic non loop branches 
programs performance predictor depends crucially predicting branches correctly 
programs gcc lcc qpt xlisp congress doduc execute different branches contributes small percentage dynamic non loop branches 
summarize main points section branches control iteration loops identified predicted accurately aid natural loop analysis 
branch identified loop branch natural loop analysis directly control iteration loop 
programs non loop branches dominate loop branches predicted accurately get branch prediction 
naively predicting target fall successor non loop branches produces results 
static prediction potential accurately predict non loop branches non loop branches choose direction high probability 

simple heuristics predicting non loop branches section examines number heuristics predicting non loop branches 
heuristics completely automatic information available executable file 
heuristics clearly refined accurate source level information available compiler 
section examines performance heuristic isolation 
section discusses combined simple heuristics 
table summarizes results benchmark heuristic 
entry table presents percentage dynamic non loop branches heuristic applies bold number rates heuristic perfect predictors 
table entry left blank percentage branches covered percent 
second column table nl repeats percentage branches non loop branches 
useful keep percentage mind examining effectiveness heuristics 

opcode heuristic predict branches branch instruction opcode 
mips integer branch instructions branch operand register equal greater greater equal zero 
programs negative integers denote error values heuristic predicts taken taken 
heuristic identifies floating point comparisons check floating point numbers equal predicting tests usually evaluate false 
table shows opcode heuristic performs benchmarks coverage varies widely 
heuristic performs poorly spice high number integer branches compare negative value 

loop call return guard store heuristics heuristics properties basic block successors branch 
heuristic consists pieces fixed information selection property predictor 
successor block containing conditional branch selection property property prediction 
exactly successor property predictor chooses successor property successor property depending heuristic 
program nl opcode loop call return guard store point gcc lcc qpt compress xlisp eqntott rn grep congress espresso awk poly fpppp doduc tomcatv dcg spice dnasa matrix mean std dev 
table 
effectiveness heuristic predicting non loop branches applied individually 
heuristic table shows percentage dynamic non loop branches heuristic applies bold rates branches 
table entry left blank coverage percent non loop branches 
blank entries counted mean standard deviation 
loop heuristic successor postdominate branch loop head loop passes control unconditionally loop head dominates 
heuristic applies predict successor property 
loop heuristic determines branch chooses executing avoiding loop predicts loops executed avoided 
compilers generate code loops loops generating loop replicating loop test condition strategy avoids generating extra unconditional branch 
heuristic catches cases branches loops explicitly specified program 
performance heuristic quite compress matrix 
excellent coverage performance xlisp espresso doduc 
call heuristic successor block contains call unconditionally passes control block call dominates successor block postdominate branch 
heuristic applies predict successor property 
heuristic surprised 
initially believed branch decided executing avoiding call execute call programs typically calls perform useful 
numbers strongly show exact opposite especially set programs 
examining programs conditional calls handle exceptional situations 
just example printing 
programs printing exceptional occurrence 
applications print standard output file printing done unconditionally conditionally 
return heuristic successor block contains return unconditionally passes control block contains return 
heuristic applies predict successor property 
justifications predictor compelling recursion 
programs loop recurse useful expect loops iterate recursive procedures recurse 
return base case exception recursion just loop exit exception iteration 
addition returns procedures handle cases occur infrequently error boundary conditions 
performance return heuristic benchmarks 
guard heuristic register operand branch instruction register successor block defined successor block postdominate branch 
heuristic applies predict successor property 
heuristic analyzes integer floating point branches 
attempts find instances branch value guards value 
intuition function guards catch exceptional conditions common case guard allow value flow 
coverage heuristic quite high benchmarks remind reader heuristic applies exactly successors property 
performance fairly benchmarks stronger performance second set programs 
heuristic performs pointer chasing programs gcc lcc qpt xlisp congress common case null pointer test guarding pointer pointer null 
heuristic performs poorly tomcatv branches account non loop branches 
branches inside loop determines maximum value array values max max fi 
program common case avoid updating maximum guard heuristic predicts opposite 
note global register allocation greatly affect coverage heuristic 
performing global register allocation benchmarks coverage heuristic lower due reloads values heuristic detect 
store heuristic successor block contains store instruction postdominate branch 
heuristic applies predict successor property 
tried heuristic curiosity intuition perform 
set benchmarks store heuristic poor performance coverage high 
performance improves floating point intensive benchmarks 
tomcatv heuristic performs perfectly correctly predicting branches guard heuristic mispredicted 

pointer comparisons pointer comparisons compare pointer null compare pointers 
mentioned programs pointers non null 
furthermore expect equality comparison pointers rarely true 
distinguish pointer comparisons comparisons requires type information 
mips risc architecture possible code sequences pointer heuristic analyze past calls blocks interprocedural register definition information computed 
comparisons 
code sequences shown load rm 
beq rm load rm load rn 
beq rm rn 
pointer heuristic looks cases basic block containing branch predicts fall taken 
looks patterns bne branch predicts branch taken 
course similar code sequences may generated comparisons involve pointers 
heuristic distinguish cases involving pointers 
compiler easily distinction 
small optimization heuristics noting pointers local variables addressed sp register stack pointer heap addressed register sp gp pointer global storage 
load instruction loads gp branch considered 
local pointer variable allocated register heuristic comparisons involving pointer 
results pointer chasing programs lcc xlisp qpt congress fairly 
pointer manipulating programs gcc heuristic perform 
heuristic picks comparisons variables pointer types 
heuristic certainly improved incorporating type information 
expected pointer heuristics performs poorly floating point benchmarks contain little pointer manipulation 

discussion unsuccessful heuristics tried heuristics unsuccessful 
included heuristics number instructions branch target domination relations branch successors 
generalizations heuristics discussed local nature 
excluding information available natural loop domination analysis examine information basic block containing conditional branch successors block steps away 
heuristics clearly generalized consider basic blocks 
example guard heuristic look farther away branch see branch value reused instruction execution controlled branch 
heuristics similarly generalized 
remains seen generalizations affect coverage performance heuristics 
cases heuristic apply call instruction load branch 

branch prediction heuristic effectiveness section describes combined heuristics previous section single heuristic procedure predicting non loop branches 
clear heuristic apply branch 
chose combine heuristics totally ordering 
predict branch combined heuristic simply heuristics applies uses predict branch 
discuss branches heuristic applies 
approaches combining heuristics possible voting protocol weightings 
approach central problem prioritizing heuristics 
graph shows see appendix graphs ordering heuristics quite impact rate 
graph shows average rate benchmarks matrix non loop branches possible order 
possible orderings orders sorted rate 
choose order heuristics 
best analysis available benchmarks select order hope order works additional benchmarks encountered 
performed experiment see reasonable expect orders picked subset benchmarks perform benchmarks 
get number benchmarks eliminated matrix interesting benchmarks terms non loop branch prediction 
subset cardinality remaining benchmarks computed order minimized average rate branches benchmarks subset 
benchmarks represent known benchmarks 
chosen order computed average rate benchmarks 
experiment consisted trials subset 
possible orders appeared trials 
graph shows frequently occurring orders ordered frequency versus cumulative percentage trials orders appeared 
seen trials accounted trials rate order opcode call return store point loop guard call opcode return store point loop guard point call opcode return store loop guard point loop call opcode return store guard opcode call return store point guard loop point opcode call return store loop guard call opcode return store point guard loop loop call opcode return store point guard call opcode return point store loop guard opcode call return point store loop guard table 
common orders experiment 
shown order percent trials order appeared average rate benchmarks order 
benchmark gets equal weight average 
interesting weighted average accounts percentage dynamic non loop branches number predictions benchmark 
frequently occurring orders 
graph shows average rate benchmarks frequently occurring orders 
results analysis encouraging 
common orders account approximately trials average rate orders 
order occurred third frequently order minimized average rate benchmarks 
table shows common orders experiment percentage trials accounts 
opcode call return heuristics consistently top heuristics orders 
computing order minimizes rate set benchmarks inexpensive proposition especially number heuristics grows 
expensive approach explored pair wise analysis examined pairs heuristics set branches intersection compared performance heuristics determine pair wise ordering 
orders analysis generally inferior previous experiment top quarter performers 
program point call opcode return store loop guard default gcc lcc qpt compress xlisp eqntott rn grep congress espresso awk poly fpppp doduc tomcatv dcg spice dnasa matrix mean std dev 
table 
performance simple heuristics applied prioritized ordering left right 
heuristic applies branch covered default heuristic predicts randomly prediction table 
table entry left blank coverage percent non loop branches 
blank entries counted mean standard deviation 
table presents results simple heuristics applied order 
recall soon heuristic applies prediction branch considered 
heuristic applies branch default prediction simply random prediction 
branches prediction random prediction table 
table presents results combined heuristic non loop branches 
column heuristics shows percentage dynamic non loop branches covered heuristics excluding default rates branches 
column shows combined heuristic effective terms coverage rate programs conditional control flow gcc xlisp doduc 
column default adds program heuristics default loop rand gcc lcc qpt compress xlisp eqntott rn grep congress espresso awk poly fpppp doduc tomcatv dcg spice dnasa matrix table 
final results 
heuristics shows percent non loop branches covered heuristics bold rates 
default adds predictions non loop branches covered adds predictions loop branches 
comparison loop rand rate loop prediction loop branches random prediction non loop branches 
heuristics default target random loop rand mean std dev 
mean std dev 
table 
means standard deviations results table sets programs 
benchmarks 
excludes programs eqntott grep tomcatv matrix 
results target random prediction non loop branches included comparison 
predictions branches covered default prediction 
adds predictions loop branches discussed section 
comparison column loop rand shows rate loop prediction loop branches random prediction non loop branches 
table contains means standard deviations results benchmarks set benchmarks excluding eqntott grep tomcatv matrix programs non loop branches accounted branch instructions 
include results target random prediction non loop branches table comparison 
average heuristics provide rate non loop branches 

instructions mispredicted branch previous sections measured performance branch prediction rate 
metric useful modern architectures exact performance penalty branch 
metric identify performance benefit realized percent mispredicted branches decreases 
example branch prediction instruction level parallel architectures find data independent threads execute parallel compilers globally schedule code improve program performance 
section measures performance branch prediction ability find sequences instructions mispredicted branch 
fisher freudenberger proposed metric instructions executed break control break control mispredicted branch instruction indirect jump procedure return indirect call correctly predicted branch instructions breaks control 
argue ability branch prediction find long sequences instructions break control depends just branch predictor rate density mispredicted branches program instruction stream 
fisher freudenberger computed instructions break control ipbc execution profiles total number instructions executed number breaks control execution 
instruction traces program executions collect detailed data ipbc available execution profile 
instruction traces able measure number instructions executed pair consecutive breaks control 
information simply available execution profile 
data shows profile ipbc average underestimates length available sequences fails accurately distinguish different branch prediction strategies 
collected instruction traces benchmarks compress gcc lcc qpt xlisp doduc fpppp spice 
part chose benchmarks contain complex control flow hard predict 
instruction traces generated datasets previous sections 
branch predictors experiment perfect predictor perfect loop prediction loop branches ordering non loop branches heuristic 
loop prediction loop branches random prediction non loop branches loop rand 
branch predictor defines set breaks control program execution 
break control defines sequence instructions including break control preceding including sequences partition instruction trace execution 
predictor recorded information number sequences length interval 
bucket records sequences length greater equal 
bucket recorded sum length sequences associated bucket 
graph distribution sequence lengths plotting sequence length versus percentage execution accounted sequences length graphs appendix 
branch predictor contributes plot graph 
slower growth rate plot better 
predictor graph shows rate branches ipbc average 
cases heuristic plot closer loop rand perfect high accuracy necessary obtain long sequences especially programs conditional control flow loops basic block size small compress gcc lcc qpt xlisp doduc 
programs non loop branches distributed fairly regularly entire execution rate non loop branches low get long sequences 
simple model captures behavior 
model assumes basic block unit length ends conditional branch branches independent branch rate sequence length function represents percentage execution accounted sequences length equal graph shows plots function rates increments 
payoff sequence length comes moving reducing rate 
similar behavior gcc graph lcc graph qpt graph 
growth rates plots accompanying absolute rates different model due simplifying assumptions model relationship rate plot roughly follows model 
turn attention ipbc average profile metric defined previously 
ipbc average evenly distributes mispredicted branches entire execution tends underestimate available sequence length 
lead underestimation overestimation difference predictors depending control flow complexity program 
benchmark spice illustrate points 
graph shows ipbc average perfect predictor instructions break control 
perfect predictor sequences length equal account approximately execution 
examine graph reason disparity clear 
graph shows sequence length versus percentage breaks control accounted sequences length sequences length equal account approximately breaks control 
profile ipbc average distributes breaks control evenly entire execution highly skewed distribution sequence lengths causes average underestimate available sequence length 
skew occurred varying degrees benchmarks 
benchmarks examined informative look sequence length execution accounted refer length dividing length 
perfect predictor spice dividing length approximately instructions 
high percentage sequences breaks control account low percentage execution substantial differences ipbc average may accurately reflect differences predictors 
case spice ipbc average overestimates difference perfect predictor predictors 
graph shows ipbc averages dividing lengths approximately instructions loop rand heuristic perfect predictors respectively 
reason disparity control flow complexity benchmark 
spice predicting loop branches gives big payoff 
correctly predicting non loop branches crucial finding sequences long length 
differences rates non loop branches large impact ipbc average average distributes mispredicted branches evenly entire execution 
ipbc average underestimate difference predictors 
especially true benchmarks conditional control flow inside loops 
cases non loop branches truly evenly distributed execution ipbc average tends underestimate dividing length perfect predictor 
example lcc benchmark perfect predictor ipbc average dividing length heuristic predictor ipbc average dividing length 
summarize results section high accuracy non loop branches crucial getting long sequences programs conditional control flow loops 
instruction traces provide accurate view execution profiles impact branch prediction instructions executed mispredicted branch 
skewed distribution sequence lengths causes profile ipbc average underestimate length available sequences 
depending control flow complexity program may cause ipbc average overestimate underestimate difference predictors 

datasets program predictor useful performance different executions program executions different programs 
ran number benchmarks different datasets examine heuristic predictor performs 
graph presents results 
benchmark dataset graph shows rate perfect predictor heuristic predictor 
emphasize heuristic predictor predictions matter dataset perfect predictor dataset dependent making best possible static prediction dataset 
benchmarks gcc lcc qpt compress xlisp grep espresso doduc rates vary widely 
consistent results benchmarks large amounts conditional control flow encouraging 
case difference rates heuristic predictor accompanied similar difference rates perfect predictor 
example datasets spice rate heuristic perfect predictor approximately double 

related related static branch prediction falls categories profile program 
mcfarling hennessy reported profile static prediction yields results comparable dynamic hardware methods 
mentioned fisher freudenberger examined profile static prediction detail showing branches behave similarly different executions program profiles effectively predict branch directions executions 
smith discusses static prediction strategies instruction opcodes applied fortran programs success 
program static prediction bandyopadhyay compiler crisp microprocessor 
identified loop tests boolean expression associated loop construct 
branch prediction tests associated statements accomplished table lookup comparison operator operand types 
authors reported extremely high success rate gave numbers details table lookup strategy 
wall program heuristics estimate various program profiles number times particular program component executes predict individual branches 
reported poor results estimator compared randomly generated profile 
lee smith branch prediction strategies reported workloads considered ibm dec pdp cdc branches taken twice fell 
lee smith considered branch prediction instruction opcodes dynamic branch history 
rates opcode prediction ranged average 

simple set program heuristics statically predicting branches combined single branch prediction heuristic performs large diverse set programs 
addition natural loop analysis predict branches control iteration loops focus heuristics predicting non loop branches dominate dynamic branch count programs 
heuristics local nature requiring little program analysis effective terms coverage rate 
believe heuristics generalized refined information available compiler produce better results 
susan horwitz support 
paul adams providing congress benchmark stefan freudenberger extra spec datasets steve help benchmarks 
josh fisher mark hill sohi provided helpful comments earlier drafts 
todd austin input 

aho sethi ullman compilers principles techniques tools addison wesley reading ma 

ball larus optimally profiling tracing programs conference record nineteenth acm symposium principles programming languages albuquerque nm january pp 
acm 

bandyopadhyay murray compiling crisp microprocessor spring compcon pp 
ieee computer society february 

systems performance evaluation cooperative spec newsletter editor 

fisher trace scheduling technique global microcode compaction ieee transactions computers pp 
july 

fisher ellis nicolau parallel processing smart compiler dumb machine proc 
acm sigplan symposium compiler construction sigplan notices pp 
june 

fisher freudenberger predicting conditional branch directions previous runs program proceedings th international conference architectural support languages operating systems acm sigplan notices pp 
october 

graham kessler mckusick execution profiler modular programs software practice experience pp 


kane heinrich mips risc architecture prentice hall 

lee smith branch prediction strategies branch target buffer design computer pp 
january 

mcfarling hennessy reducing cost branches proceedings th annual international symposium computer architecture pp 
acm ieee computer society june 

morris ccg prototype code generator proceedings sigplan conference programming language design implementation toronto june acm sigplan notices pp 
june 

patterson hennessy computer architecture quantitative approach morgan kaufmann publishers 


pettis hanson profile guided code positioning proceedings acm sigplan conference programming language design implementation sigplan notices pp 
acm june 

sites alpha architecture manual digital press burlington ma 

smith study branch prediction strategies proceedings th annual international symposium computer architecture sigarch newsletter pp 
acm ieee computer society may 

wall predicting program behavior real estimated profiles proceedings sigplan conference programming language design implementation toronto june acm sigplan notices pp 
june 
appendix graphs orders graph 
average rates 
possible orderings sorted rate 
common orders graph 
common orders experiment cumulative distribution trials 
common orders graph 
average rates benchmarks common orders experiment 
sequence length percent executed instructions spice loop rand ipbc heuristic ipbc perfect ipbc graph 
spice cumulative distribution sequence lengths 
sequence length spice loop rand heuristic perfect graph 
spice cumulative distribution breaks 
sequence length percent executed instructions compress loop rand ipbc heuristic ipbc perfect ipbc graph 
compress cumulative distribution sequence lengths 
sequence length gcc loop rand ipbc heuristic ipbc perfect ipbc graph 
gcc cumulative distribution sequence lengths 
sequence length percent executed instructions lcc loop rand ipbc heuristic ipbc perfect ipbc graph 
lcc cumulative distribution sequence lengths 
sequence length qpt loop rand ipbc heuristic ipbc perfect ipbc graph 
qpt cumulative distribution sequence lengths 
sequence length percent executed instructions xlisp loop rand ipbc heuristic ipbc perfect ipbc graph 
xlisp cumulative distribution sequence lengths 
sequence length percent executed instructions doduc loop rand ipbc heuristic ipbc perfect ipbc graph 
doduc cumulative distribution sequence lengths 
sequence length percent executed instructions fpppp loop rand ipbc heuristic ipbc perfect ipbc graph 
fpppp cumulative distribution sequence lengths 
sequence length graph 
simple model cumulative distribution sequence lengths 
function plotted rates increments 
gcc lcc qpt compress xlisp eqntott grep espresso doduc spice rate perfect heuristic graph 
rates different runs various benchmarks 

