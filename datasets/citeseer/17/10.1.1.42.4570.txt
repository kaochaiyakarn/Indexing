general game playing reinforcement learning robert levinson ucsc crl supersedes ucsc crl ucsc crl partially supported nsf iri may department computer science university california santa cruz ca mail levinson cse ucsc edu phone gives blueprint development fully domain independent single agent multi agent heuristic search system 
gives graph theoretic representation search problems conceptual graphs outlines different learning systems 
informed learner graphtheoretic definition search problem game playing adapting game environment 
blind learner access rules domain discover exploit underlying mathematical structure domain 
relevant referenced context blueprint 
illustrate go creating general game playing agents show generalize understanding obtained morph chess system games involving interactions mathematical relations 
example monitor domains implementation blind informed learning system known 
performance results preliminary encouraging provide data points understand evaluate blueprint 
keywords games mathematical structure heuristic search machine learning hypergraphs neural networks analogical reasoning rete relational patterns hierarchical reinforcement learning contents contents previous general game playing generic representation games search problems generic game taxonomy popular games generic games operators evaluation graph theoretic representation scheme extending tic tac toe games hypergraphs 
reductions basic tic tac toe hypergraph game basic hypergraph games review original morph model morph ii improving morph 
weaknesses morph glm reinforcement hierarchy generating reinforcement hierarchy rules domain 
blind learning blind learning exploiting analogous relationships blind learning domain independent games environment monitoring state space search incrementally happens operator selected performance results 
artificial intelligence research benefit unified view study past practical plan proceed 
objective mind suggest tenets guiding principles developing machine intelligence 
intelligence optimal problem solving pursuit specific goals resource constraints 
note mention human cognition consciousness 

definition domain independence adaptability fundamental aspects intelligence 
adapt economical sub optimal 
single multi agent state space search problems large important class problems develop study machine intelligence 

task develop fully domain independent methods working state space search domains 

knowledge required perform domains embodied definition domain mathematical structure state space reasons heuristic explainable framework mathematics space 

experience state space reveals mathematical structure exploited optimal problem solver 
revealed need exploited 

practical problems experience reveals structure lead efficient problem solving 

underlying mathematical structure domains independent labels conditions operators state space definition 

mathematical structure embodied interactions conditions defined operators domain relationship interaction complex state relationship state goal state 

effects interaction complexes entirely domain independent governed regular laws just interactions matter energy governed laws necessarily known physics 

laws discovered exploited computers intelligent definition 

computers may important tool process discovering laws 
tenets mind ultimate goal discovering laws state space search suggest division research efforts separate absolutely complementary projects ffl generic representation mathematical probably graph theory group theory representation definition single agent multi agent state space search problem independent domain specific arbitrary labels program convert declarative definition state space generic equivalent mathematical representation 
ffl informed learner program performs state space search mathematical definition state space supplied domainindependent heuristics experience 

ffl blind learner program performs state space search problems definition state space pre supplied heuristics just rewards game experience legal states raw bit vectors choose choice point 
ffl monitor programming environment allows experiments easily designed carried topics 
projects designed directly produce laws state space search gradually give understanding lead laws empirical validation 
problems increases power machine 
addition summarizing previous research outline led system known 
hope understanding lead appreciation blueprint laid ai research efforts 
successor morph chess system ls gl achieved approximately novice strength despite just ply search human supplied heuristics 
fully domain independent version morph opposed original despite intentions carries human biases chess idiosyncrasies 
believe new learning mechanism described sections blind learning directly addresses limitations original morph model overly specific graph patterns insufficient freedom system respect class patterns formed combination weights 
previous general game playing fortunately projects directly indirectly place computer game playing community ai general 
popular approach date game playing research incorporation search coupled game specific evaluation 
search approaches kai typically meet objectives domain independence generality evaluation mechanisms generally 
addition domain solved perfect play achieved specified resource constraints choice search algorithm heuristic 
traditional domain dependent approach benefit thorough mathematical understanding state spaces 
minimax alpha beta search introduced john mccarthy rn samuel original checkers program large majority systems 
thorough analytic studies alpha beta done knuth moore km pearl pea 
addition alpha beta large amount research selective search pruning algorithms kai 
algorithms applied small number popular games chess checkers othello general applied perfect information game 
algorithms category include ber sss sto conspiracy number search mcc 
baum gave mathematically founded algorithm bau 
beal bea nau nau constructed hypothetical pathological games alpha beta search accurate deeply searches showed approach fully applicable despite fact popular games 
search strategies significantly effective games imperfect information games large branching factors 
go 
minimax search strategies maximize performance assuming worst case scenario opponent selects best moves 
number important research issues remain assumption relaxed trying play positions opponent find winning line jan 
case statistical mathematical models game opponent increase importance 
beal bs showed experimentally interesting result certain games chess random evaluations coupled minimax lead improved play increasing search depth maximizing minimizing favors nodes large branching factors roughly corresponds mobility coefficient 
apparently simple result important consequences adaptive game playing systems provides mechanism system bootstrap domain knowledge ability ply search domains mobility relevant 
single agent problems course approached search algorithms nil best search rk means ends analysis en 
discuss single agent search depth scope 
important thing note traditional search approach tends obviate need program programmer thorough mathematical understanding domain fast reasonably accurate heuristic evaluation function available 
approach positive practical consequences necessarily increase scientific understanding heuristics search algorithms perform 
existing search approaches important limitations horizon effects complex domains thorough understanding mathematics statespace problems undoubtedly lead effective search algorithms 
limitations search approaches suggested hierarchical planning algorithms attempt view game state collection subproblems solved wil pit min fd 
date approaches proved powerful general serious practical competitors brute force search 
researchers expect change mathematics planning understood wider variety games imperfect information considered sn 
number individual games mathematical computer aided analysis bcg 
believe general graph theoretic approach type analysis extended wider classes games problems 
example mathematical techniques applied successfully previously considered intractable go endgames bw 
reinforcement learning proved highly successful learning evaluation functions specific games checkers sam othello lm backgammon ts 
programs developed world class players respective domains 
successes provide important datapoints pursuing blueprint systems moderate amount human assistance defining feature training sets far ideal full domain independence 
reinforcement learning general increasingly popular sut minimize need human assistance 
neural networks rm genetic algorithms bet bgh gol hol viewed blind learners 
systems attempt learn functions pre classified input output pairs 
extent supplied classifications generated automatically temporal difference learning sut example learned functions coupled search produce general game playing system :10.1.1.132.7760
systems 
generic representation games search problems incorporate thorough graph theoretic understanding machine learning domains structure 
lost complex domains chess high level relationships analogies large amounts search currently done exploited handle large combinatorics sample space 
noted reinforcement learning systems neural nets derive structure directly declarative specification domain structure supplied human fixed structure hoped generally applicable 
date systems perform domains application anticipated tuned 
inductive learning algorithms qui mic tended suffer similar limitations despite showing strength controlled settings 
developments inductive logic programming mor may eventually inductive learning generally applicable 
achieve goal informed learning project structure learner may need dynamically adjusted system way specifically suited problem question 
illustrate method done 
generic representation games search problems section illustrate generic representation games may pursued graph theoretic terms 
claim large class state space games represented utilizing notion directed hypergraphs 
hypergraph set nodes coupled set hyperedges subsets hyperedge directed nodes ordered 
hypergraph nested nodes may hypergraphs 
call hypergraph basic nested 
define game call generic hypergraph game 
specifications alternatives may selected form games 
ffl player starts points 
ffl pn finite set primitive boolean conditions 
ffl states tuples pn representing truth values conditions 
ffl game starts specified initial state initial state selected randomly 
precisely initial state chosen randomly set states satisfying set conditions 
ffl operator ordered pair sets primitive boolean conditions 
represents preconditions second postconditions 
operator legal state preconditions satisfied 
operator selected minimal changes current state postconditions true 
alternatively operators probabilistic effects 
state agent asked select operator legal ones 
ffl set operators executed automatically state created 
reward operators usually standard bookkeeping operations assigning proper number points player 
ffl terminal conditions hyperedges conditions achieved game 
games terminate legal moves available player move possibly addition position repeats player move 
ffl players alternate turns selecting applicable operators 
player points game wins 

generic representation games search problems ffl knowledge limitations normally player perfect knowledge operators current state 
variants include restricting player knowledge certain set conditions current state certain definitions operators 
generic game taxonomy popular games outline popular games viewed variants generic hypergraph game previous section 
ffl single agent search problems tile puzzles fit naturally framework 
object moves possible primitive condition set unaltered rules decrements player score reward operators time occurs 
ffl tic tac toe games objects placed moved operators pre condition post condition terminal hyperedges produce positive rewards 
ffl hex game played grid hexagons 
players alternate possession hexagons player tries path hexagons top bottom player tries path left right 
hex fits tic format hexagons nodes various paths hyperedges rewards assigned correspondingly whichever player win path 
hex viewed complex tic tac toe game exponential number hyperedges nodes graph 
hypergraphs exhibit property including checkers go shown pspace hard arbitrarily large boards pspace complete restricted polynomial length games 
fact problem pspace complete stronger indication intractable np complete np equal space gj 
ffl chess games defined pel primitive operators complicated hex 
conditions true may false 
note natural bit representation games may explicit pieces squares boolean conditions representing piece square pairs 
ffl go games othello point accumulation richer reward structures tic tac toe 
related hex greater combinatorial explosion goal states primitive nodes involve goals essence sets hyperedges nested hyperedges 
ffl bridge games random initial states 
bridge represented conditions player owns card played played current trick 
communication aspect bridge defined simply making explicit reward structure encourages collaboration giving player access information player selected operators corresponding bids 
simplicity specification obscure fact rich complex research problems getting computers bid effectively learn 

generic games operators ffl chance games monopoly backgammon require stochastic conditions set move limit legal moves available player 
notion money monopoly may defined directly number points player 
note previously mentioned games having points may necessary precondition certain operators 
clearly representation fully adequate 
certain games stock market fall framework games expressed combinatorially intractable 
simply enumerating terminal sets conditions chess go daunting task example 
illuminating mathematical structure games accompanying individual domains deal holistically removed 
address intractability generic hypergraph language operators relations variables need considered 
excellent example generating generic chess games normal operator level 
barney pell general heuristics allow reasonable played domain knowledge rules 
heuristics confined chess games generally deal mathematics state space search generalizing larger class games possible 
eps domain independent game playing learning system deals operator level 
carries rich set advisors embody human supplied heuristics 
degree heuristics truly domain independent operate generic opposed specific game representation say informed learner certainly blind learner 
section show natural graph theoretic generic game structure may developed advantage concept variables operators way predicate calculus extends propositional logic 
generic games operators generic game representation previous section suffers potential combinatorial explosion frequently characteristic low level languages 
complexity low level obscures richer simpler structures higher levels description 
reach natural definition generic games add notions domain objects static relations dynamic relations variables bindings retain label free framework omitting arbitrary names assigned objects conditions operators 
framework incorporating state space search inspired peirce existential graphs rob modern version conceptual graphs developed john sowa sow experience planning lk 
state space search paradigm breaks problems initial conditions terminal conditions goals operators 
continues pervasive problem precisely defined accepted mathematical concepts general appropriate may obscure deeper relationships ham 
done conceptually names may retained mnemonic aids humans recognized arbitrary machine 

generic games operators solving models ai research 
show state space search problems normally formalized kor viewed relation transformations hypergraphs special case conceptual graphs 
relations form predicates functions basis formal order logic foundation declarative representations traditionally symbolic ai 
thesis logic graph theory state space representation tied tightly 
particular notion static dynamic relations original adds temporal dimension traditional model theory tar relating logic search 
description components search problem running examples taken tic tac toe towers hanoi disks ffl domain finite set domain objects 
tic tac toe objects squares fs pieces fx blank towers hanoi objects disks fd 
ffl unary binary higher relations may defined objects 
ary relation set tuples domain objects 
finite search domains defining types explicitly shall simply note implicitly defined set objects occur single field attribute relation 
implementation level relations symmetric transitive may abbreviated specifying kernel set tuples giving mathematical properties remaining tuples inferred 
abbreviations computation relations possible finding adjacent squares chessboard calculation cartesian coordinates 
divide relations classes static relations definitions tuples remain constant game dynamic relations content change state state 
frequent static relations defining board topology adjacency squares 
domains dynamic relation corresponding say pieces squares 
tic tac toe define row static relation corresponding winning sets squares dynamic relation initialized towers hanoi static relation smaller initialized towers hanoi dynamic relation initialized initial state towers hanoi viewed hypergraph nodes labeled binary directed hyperedges labeled connecting 
goal transform graph similar replaced role 
ffl operators define transformations states changing contents dynamic relations 
operators specified giving sets preconditions additions objective state space search problem find sequence operators transformations convert state satisfies initial conditions satisfies terminal conditions various optimality criteria resource constraints 
tic tac toe played board 
players alternate turns selecting cells goes 
player complete row column diagonal wins 
towers hanoi single agent game involving disks small medium large placed top order peg 
object move disks time time disk top disk smaller peg disks finish third peg 

generic games operators deletions 
sets viewed conceptual graph hypergraph combination nested hypergraph 
tic tac toe operator move piece square precondition add condition delete condition 
assumed board oriented move 
towers hanoi move operator move disk peg peg pre 
add del example swap operator switches bottom block top block blocks world nil vice versa tower blocks representation swap block block block pre clear add clear del clear representation equivalent operator graph involving variable nodes dynamic relation edges 
representation swap apply thousands domains involve type swapping 
moves tile puzzles instance variables replaced domain object blank tile 
ffl states hypergraphs domain objects 
tuples static relations necessary state dynamic relations representing state 
operators directly affect contents dynamic relations 
ffl operator applicable state iff mapping variables preconditions operator domain objects relations specified operator true false negated domain objects 
result applying operator remove current state tuples corresponding operator deletions add tuples associated operator additions contents dynamic relations 
static relations constant problem solving process bindings objects variables possibly constrained static relations satisfy operator definition principle computed ahead time leaving dynamic conditions checked 
effected implementation section 
ffl terminal conditions defined exactly way preconditions addition deletion conditions operators 
automatically assumed player having legal moves terminal 
tic tac toe row terminal 
towers hanoi terminal conditions 
ffl reward conditions conditions coupled reward player outcome game 
towers hanoi tic tac toe reward conditions 
generic games operators terminals assign win player just moved 
ffl flip static binary relation domain objects define symmetries game encoded player perspective 
tic tac toe flip towers hanoi single agent game require flip operator 
similar transformations introduced 
ffl summary game search problem defined finite set domain objects finite sets static relations dynamic relations operators terminal conditions reward conditions 
convenience encoding define symmetry condition known flip 
single multi agent search problems viewed games hyper graph graph transformation 
surprising conceptual graphs semantic network schemes shown carry expressive power order logic 
significant suggests potential graph theoretic analysis rules domain ensuing experience uncovering powerful heuristics decision making strategies lk ls 
suggests state space search monitored uniform manner topic discussed section 
evaluation graph theoretic representation scheme hypergraph representation scheme include facilities inference static dynamic relations 
facility available conceptual graph theory available shortly peirce conceptual graphs workbench el learning system implemented 
important step showing generality graph theoretic representation show games generated generator fit structure 
implications manipulating structure unknown initial results show great potential 
example macro operator executable search domain single agent domain carries operator structure 
domain independent graph theoretic representation able show entire tweak planning system reduced operators simple control structure roach robot problem sussman anomaly solved database domain abstracted operators macros lk 
variable free graph theoretic definition problems possible define hierarchy single agent problems easier sub hypergraph isomorphism 
informally problem easier problem mapping bits problem bits problem mapping necessarily operators ones operator restricted operator bit mapping iff state state transformation accomplished mapping knowing problem easier source heuristics 
solution path states solution path corresponding states optimal 
length path upperbound optimal solution length likewise length solution path lower bound length optimal solution path conforms traditional notion admissible heuristic nil 
hierarchy problems easier 
extending tic tac toe games hypergraphs 
conformance hierarchies generated dynamically planning kor sac 
extending tic tac toe games hypergraphs 
illustrate unifying power studying games mathematical structure take closer look tic tac toe games 
games reduce basic hypergraph game 
hypergraph players alternate selecting nodes player owns nodes hyperedge wins 
shall assume discussion agents 
example tic tac toe graph nodes hyperedges 
nodes hyperedges 
nodes hyperedges 
discussion builds directly previous forks eps hopefully putting proper perspective 
hypergraph representation symmetries fully realizable graph isomorphism 
mathematical representation lends reasonable heuristics 
example quality node choice proportional number live edges involved inversely proportional number nodes remaining edges 
subgraph analysis precise heuristics developed eps 
reductions basic tic tac toe hypergraph game useful familiar reductions preserve game theoretic value basic hypergraph games reductions may apparent traditional state representation 
move hypergraph may translated smaller equivalent representation calculate value state assuming optimal play 
owner edge nodes played edges nodes owned players may removed 
edges involving exactly nodes reduced single edge preserves ownership owners carries owner agents edge 
similarly ownership edges subsumed edges removed 
move 
remove edge incident move owned player 

remove node set ownership affected edges player moved 

edge zero nodes player moved wins 
edges remain game draw 

remove set duplicate edges update ownership described 
remove edge superset carries ownership 
basic hypergraph games shown game tic tac toe may played hypergraph popular games may generalized basic hypergraphs 
generalized games may require complex winning strategies smaller fixed size counterparts 
reductions tic tac toe possible hypergraph games lead efficient accurate reasoning 
hypergraphs section basic opposed nested ones previous sections 

extending tic tac toe games hypergraphs 
birthday table round table game described follows assume players call left right 
left seat boys right seat girls circular table seats 
assuming unlimited supply children players alternate moves 
preserve child may seated opposite sex 
unable seat child loses left cope angry parents 
generalized birthday game played hypergraph nodes edges edge node designated center 
move node player gains node ownership hyperedges node center 
player allowed move hyperedge owned player 
player legal moves loses 
specific seat birthday game played hypergraph nodes hyperedges node center node edge 
round table birthday games simple optimal strategy number seats second player guaranteed win moving seat exactly opposite move player 
number seats odd player wins moving invoking number seats strategy player went second 
popular single agent game known merlin magic square 
solitaire game played grid generalized hypergraph 
nodes start parity 
move changes parity nodes hyperedge 
goal design sequence moves changes nodes parity 
order moves matter moves legal step games solved directly linear programming gaussian elimination 
interesting contrast merlin games search problems move order matter applying linear programming expensive impossible 
nim extended play hypergraph 
players alternate sets nodes hypergraph set contained hyperedge 
player takes node wins 
nim games played hypergraphs edges disjoint 
disconnected versions simple winning strategy binary arithmetic exists 
strategy extend connected hypergraphs 
addition games np complete problems gj set covering formulated take place basic hypergraphs 
characteristics basic hypergraph games simpler generic nested hypergraphs previous section represent state space search problems analysis may lead better understanding general case 
instance desirable analyze chess games 
games additional features 
operators complex multiple preconditions postconditions 

conditions change non monotonically condition true false vice versa 
chess games examples perfect information agent search problems 
complexity games lack detailed analytic understanding led suggest informed learning blind learning 

review original morph model sections discuss group approach blind informed learning graph analysis reinforcement learning 
learning approaches may prove equally viable neural networks rm genetic algorithms hol constraint satisfaction rk inductive logic programming explanation generalization fd km rn 
methods extended general case single double agent search problems just generalizes morph 
review original morph model morph application aps adaptive predictive search method improving search experience 
aps knowledge stored pattern weight pairs pws lf patterns represented conceptual graphs boolean predicates states weights estimates expected distance states satisfying pattern goal state 
starting virtually empty database pws learned search experiences combination learning techniques temporal difference learning weight updating pattern creation deletion 
patterns stored partially ordered hierarchy facilitate efficient associative recall 
state evaluation formed function weights specific stored patterns apply state 
ideally aps system converge database serves reliable evaluation function ply lookahead 
practice aps learning agents couple guided search previous experience 
addition weights statistics number uses variance may stored patterns determining importance maintained system 
aps systems similar genetic classifier systems structural patterns fitness function available outcome search pattern representation creation mechanisms exploit domain dependent symbolic knowledge 
aps domain pattern language pattern addition strategies added domain 
aps applied chess morph supplying graph pattern language depicts attacking defending relationships pieces pieces squares 
nodes labeled pieces types white bishop black king full partial square designations rank file directed edges labeled direct discovered indirect 
evaluate position position translated directed graph pattern representation language matched database pws representing potential subgraphs graph 
typical position weighted average matched subpatterns evaluation 
starting empty database learning patterns type additional pattern type reflects material side ply search morph learns relative values chess pieces defeats human chess novices draws trainer regularly 
morph obviously benefits chosen pattern representation language 
continue blueprint objective domain independent learner responsibility pattern creation placed learning system 
desire generality deeper understanding led view chess instance game mathematical relations 
hoped understanding morph adapted game mathematical relations may lend insight systems may generalized 

morph ii improving morph 
morph ii improving morph 
understand search problems games graph graph transformations described section understand knowledge existence subgraph graph representing current state may carry predictive value outcome game 
inherent graph potentialities operators applied prevented relationship terminal conditions goals game 
current understanding state space search enable assess value expected outcome subgraph directly 
may learned statistically experience 
experiments morph limited searching ply ahead force focus issues associated heuristic construction development 
weaknesses morph weights subgraphs approximated accurately morph better chess player 

inappropriate mechanisms combining values recommended individual subgraphs 
original hypothesis pattern values combined numerically independent patterns produced values relationship patterns 
believe hypothesis false produce strong heuristic 
manhattan distance tile puzzles suffers similar shortcomings 
fact experiments conducted attempts combine values higher level patterns involving tiles puzzle knowledge underlying patterns having correct values expected distance goal states having pattern proved unpromising 
experiments done hand statistical methods form combination equation described demonstrate difficulty perfect knowledge subset patterns complex domain 

specificity graphs chess system 
graphs reasonable features system lacks ability information learned graph directly influence values similar graphs 
leads learning inefficiencies especially considering specific graphs may seen times system career may provide insufficient information give accurate values 
fortunately difficulties addressed 
original hypothesis underlying morph design knowledge relationships objects exploited 
hypothesis borne moderate success morph graphs 
hypothesis simply carried difficulties refer lack exploitation relationships graphs 
short scheme developed allows graphs influence benefit weights similar graphs 
proceed mathematical understanding required morph graphs equivalent collection dynamic binary relations may occur position direct attack relation indirect attack relation 
relations actuality restriction ply search degree kind 
testing morph patterns requires equivalent ply search 

morph ii improving morph 
describe rules domain monitor may basis learning domain 
glm reinforcement hierarchy morph general address learning limitations developed notion generic learning module glm properties ffl contains subsystems 
ffl estimates value state consulting subsystems generic learning modules get estimates value combines values numerically non linearly equation learned 
combining rule exploits past accuracy subsystems 
ffl module receives feedback predictions higher level system 
ffl module learns modifying combination equation 
ffl primitive glm glm subsystems simply attempts predict feedback value dynamic constant function 
focus discussion important high level learning issues defined may ignore learning method glm 
conceptually function learning method 
focus identification subsystems interaction 
notion hierarchy control modules consistent hierarchical general systems theory kli 
contributions include generation systems hierarchy declarative specifications domain exploiting isomorphism terms logical predicate mathematical relation formation higher order controllers combining relations connection standard ai concepts state space search machine learning algorithm graph theory systems theory 
richness connections achieved exploitation appropriate mathematical abstractions lends support emphasis mathematics blueprint 
individual learning modules form partially ordered hierarchy subsystem relation 
top level modules hierarchy receive feedback individual states state sequence temporal difference td learning sut mechanism morph :10.1.1.132.7760
modules turn send feedback subsystems primitive 
play higher level systems compose predictions combining recommendations lower level systems 
games complex complexity individual learning module hierarchy learning modules need increase 
simple games tic tac toe possible write evaluation function optimal play simply linear combination values objects individual squares 
corresponds level hierarchy modules lower level module top 
game chess evaluation function directly linear combination values objects squares perform relationship objects individual objects critical 
simply expect non linear evaluation function succeed begs question complex interactions needs consider come 
efficiently learn proper game completed td learning assign new evaluations states occurred game new information provided outcome game 

morph ii improving morph 
coefficients complex function knowledge transferred shared terms 
example instances black pawn attacking white queen learned separately generating reinforcement hierarchy rules domain 
rules dictate structure system hierarchy 
hypothesis domains relations initial description domain support patterns necessary learning 
glm created corresponding relation 
stored hierarchically dependencies 
example tic tac toe definition section hierarchy middle level module corresponding higher level modules corresponding move terminal 
towers hanoi similar hierarchy 
primitive low level hierarchies correspond weights individual tuples may stored individual modules 
tuple higher order module provides feedback tuples lower level modules depend 
example value move towers hanoi built combination values 
evaluate state monitor proceeds follows 
monitor calculates incrementally previous state current move tuples match match state 

weights lowest level tuples propagated hierarchy combined form values higher level tuples 

relation combines values tuples lower level relations produce recommendations higher level relations 

values highest level relations combined produce evaluation state 
weight combinations weights previous accuracy subsystems 
design deals directly weakness morph discussed 
module combination function weight combination localized specific patterns consideration 
new framework weights may combined differently problem solving system location glm hierarchy 
second weakness inability patterns share information addressed 
patterns structure occur relational table 
weights patterns may shared generalized contents table 
patterns added time pattern skeletons represented new relational tables may inserted hierarchy new patterns processed simultaneously 
exact nature relation table insertions topic 
higher level patterns influenced directly values low level patterns 
weights low level tuples learned primitive learning rule takes account average training values seen time training value accuracy previous predictions 

blind learning important improvement relational tables hierarchy 
search game domains represented small finite number domain objects 
relational tables may stored boolean matrices bit corresponds individual tuple 
expensive graph matching original morph system replaced simple bit matching operations see section 
boolean matrices potentially allow application mathematical analysis efficient learning schemes linear algebra glm 
blind learning clearly blind learning difficult informed learning 
example blind learning domain definition guide construction learning hierarchy 
learn question generic modules formed interrelationship critical issue 
recognizing redundancy exploited difficult matter 
informed learner start better place able classify experience accurately 
despite difficulties feel important ai researchers study blind learning reasons 
practical domains access declarative description rules 

additional difficulties blind learning give better appreciation information supplied rules 

blind learning forces learning system available information 
terms system develop relational structure domain works 
proposed environment blind learning systems agent information ffl current state board finite length vector boolean conditions 
bit description exactly information legal move generator need generate correct set legal moves state 
interpretation bits may placed order 
just informed learning may operate domains rule encodings ranging malicious benevolent blind learning operate state encodings varying quality 
ffl set rules legal moves rewards set conditions fixed player inversion symmetry board domain objects 
ffl states resulting legal moves point game 
ffl reinforcement game terms reward agent trying maximize 
tic tac toe appear blind learning agent 
board bits bits square empty unused code 
things obscure interpret consider board representing base number state represented bit binary number 
straightforward game tic tac toe quickly disguise resemblance standard board form rules play 
difficulties intended 
believe 
blind learning methods developed produce general learner capable adapting adequate experience game playing environment 
blind learning system exploit relations objects higher order analogous relations surpass performance learning systems currently existence 
systems exploit graph isomorphism higher order morphisms structures despite fact relationships core structure domains 
example implemented learners difficulty learning simple concept consecutive bits hun apparently simple adjacency relationship bits exploited ternary relations considered 
goal build blind learner constructs exploits reinforcement hierarchy just informed learning 
study blind learning leads insights informed hierarchy may dynamically modify adding new relations 
initially blind learner starts low level state glm 
module views state binary relation potentially matching tuples represented bits 
weights individual bits stored learned primitive 
system uses experience values bits cross correlation create higher order hopefully useful relations 
system learns stores information due pairing bits 
ffl frequency bit values occurring 
ffl performance weights associated pairs values 
ffl linear non linear function predicts squared error weight pair values weights individual values 
bit representation possibilities studied 
computational constraints pairing operations restricted bits extreme predictive weights 
system creates new relations ffl set bits occur bit time called variable 
example variables correspond pieces squares board games 
ffl pairs bits similar values similar weight combination rules 
ffl sets bits parity changes single operator application 
sets bits give topological information structure search space 
currently system uses fuzzy graph matching clustering wat form higherlevel relations associated 
example variables bit pairs bit variable similar combining rules combined form new binary relation 
believe thorough mathematical analysis may possible put forth probabilistic arguments relations created 
currently relation monitored determine reliable predictors best retained 
higher order relations may treat absence presence tuples analagous manner way bits treated lowest level blind learner create higher relations 

exploiting analogous relationships blind learning exploiting analogous relationships blind learning gain insight understanding blind learning method proposed previous section consider combinatorial explosion associated chess example hard learn place white queen black pawn capture including places placed 
assume knowledge piece square pawn queen 
supplied 
assume blind learning system observed instances pawn queen relationship relationships uninterpreted piece square conditions due relationship encounters new instance example state bit wq bit bp 
instance capture occurred specific tuple stored pattern 
instance encountered generalization similar instances required 
propose scenario chess generalization learned 
values individual bits learned sufficient experience 
equal value learned wq equal value learned bp 

variables discovered information bits occur 
variable corresponding white queen 

binary relations formed pairs variables pairs bits similar combining rules 
combining rule variables function values bits variables produces value conjunction 
binary relation includes tuples black piece attacks white piece discovered result value attack tuples worth white values components tuples 
substituting values rule give approximately correct result especially value combination inversely proportional value relations attacks relation collected form general attacks relation specialized form wp attacks relation 
concepts similar morph original human supplied edge types 
just edge labels morph learning new relations facilitates analogical reasoning process making precise combining rule components 
explicit combining rules matched find higher level patterns 
assumption games search problems interest regular underlying structure 
degree assumption regularity false learning task difficult false inferences proper structure learned learned 
connection squares noticed agent ignorant board topology rules find virtually impossible recognize interaction inferable indirectly patterns 
domain independent games environment blind informed learning testbeds described available part public domain software known peirce conceptual graphs workbench el 
learning system peirce known accepts rules single agent multiagent state space search domain translates conceptual graphs monitors 
domain independent games environment games learning super referee 
object oriented code domain independence maintained polymorphism domain objects independent modules coded tested modifications initial implementations blind learning informed learning algorithms 
declarative rule sets number games available including chess towers hanoi tic tac toe puzzle nim birthday party game 
possible test power different search algorithms human supplied heuristics domains 
section discusses implementation methodology summarizes performance results 
monitoring state space search incrementally primary discovery relational hierarchy efficiently monitor enforce rules domain serves basis hierarchical reinforcement learner described section 
call relational hierarchy algorithms operate universal data structure lev 
universal refers effective monitor executor specifications state space search domain 
due relation perspective ideas rete algorithm mir exploited little adjustment relational hierarchy defined 
ffl firing individual operator affect current state radically 
ffl operator match previous cycle match current cycle 
ffl cycle try operators affected previous operator application 
ffl different operators may share large amount structure 
separate conditions operators matched cycle 
ffl variable bindings cycle cycle remain relatively consistent 
monitors search problems follows 
hierarchy represent dynamic relations 
specific relations true stored beneath schema declarations relations specifications 
schema declaration tuples equivalent table traditional relational database called table 
preconditions operators stored graph hierarchy 
repeated parts operators represented relation hierarchy 
depicts initial network monitoring towers hanoi 
differs standard rete implementations exploits relation representation conceptual graphs extend types patterns matched speed matching 
naturally supports rete variety data manipulation methods appropriate relational databases conceptual graphs semantic networks 
dynamic relations depend relations definition known primitive dynamic relations 
post conditions operators directly primitive dynamic relations pointers add delete tuples contents 
static relations compiled away network generation time set tuples satisfy remains constant 
conceptual graphs representing preconditions operators re matched content composing relations changes 
part conceptual graph affected change need re matched 
primitive dynamic relations form low level sit directly primitive weights reinforcement hierarchy 

domain independent games environment smaller static disk disk terminal dynamic disk peg dynamic move dynamic disk peg peg delete add initial state network monitoring towers hanoi 
happens operator selected 
selected operator corresponds tuple operator tables example move towers hanoi 

tuple bound variable arguments operator schema lists add delete tuples built add delete conditions schema 
example deleted added 

lists tuples added deleted immediately appropriate primitive dynamic relation tables net new changes propagated net 

created tuples add delete lists iterated table net may directly affect changing truth values tuples table 
added deleted tuples matches pre condition table re join procedure called update tuples currently stored table 
tables affected new add delete tuples ignored 
example firing move removes move table adds move table 

domain independent games environment details implementation including join merge lev 
performance results scheme able monitor variety domains including tic towers hanoi puzzle level efficiency faster cases times previous programs written specifically domains incremental 
played various search depths monitored variety search domains compiled network rule definitions section 
implemented sun megabytes main memory 
domain independent results reasonable outperform domains high branching factors hard coded program exploit incrementality 
table presents results earlier implementation relation tables stored sparse matrices 
particular relation stored set tuples tuple identified arguments 
table random vs random means random agent competes random agent ply means agent searches deep evaluating leaf nodes random numbers minimax move selection agent plays randomly lookahead 
moves towers hanoi results game restarts move puzzle results game 
table presents results implementation multidimensional bit array method storing relation tables 
tuple individual bit cell matrix 
means tuple means tuple absent 
subscripts cell correspond arguments tuple 
main advantages bit matrix storage scheme processing uniform tuples row operations matrices exploit bit parallel concurrency provided logic operations workstation 
effect relational join reduced matrix multiplication 
compared table speedups factor typically 
towers hanoi shows greatest speedup 
exception speedups significantly greater higher ply lower ply 
tables summarize quality play blind learning 
towers hanoi starts randomly selected legal initial states 
tic tac toe draws counted wins second player 
statistics basic blind learner simply learns values individual bits gradient descent weight updating uninterpreted state representation randomly selected sets bits underlying representation 
towers hanoi bits represent disk peg 
tic tac toe bits represent state blank white pawn black pawn positions 
effort identify exploit generalized relationships row tic tac toe 
simple version chess played board 
player pawns 
starting configuration player pawns respective edge board middle rank unoccupied 
white moves players alternate moves 
pawns move square forward capture diagonally normal chess 
player get get pieces opposite side board capture opponent pieces wins 
game draw optimal play 
board player pawns 

domain independent games environment total average total average single agent games moves moves towers hanoi random vs random ply ply ply puzzle random vs random ply ply ply double agent games games games hex pawn random vs random ply ply ply tic tac toe random vs random ply ply ply table tuple list execution speeds seconds 
amount time moves play games depicted different search depths 
tables results generic learning module glm 
glm informed setting analyze rules uses form monitor reinforcement hierarchy 
add new relations patterns database experiments patterns necessary monitoring games stored 
table shows performance random agent grows early training hex pawn hex pawn tic tac toe 
percentages wins draws losses cumulative games played 
cases learning improve ply aps versus random hex pawn performance achieved games 
believe slight degradation probably due learning weaker opponent 
table shows performance grows longer term training pennies nim 
nim raw aps agent fare domains 
patterns required monitor nim include critical feature relationship stacks 
manually adding ary dynamic relation includes number pennies stack pennies 
players alternate pennies stack 
person takes penny wins 
nim stacks sticks respectively 
players alternate sticks stack player gets stick wins 
games wins player perfect play 

domain independent games environment total average total average single agent games moves moves towers hanoi random vs random ply ply ply puzzle random vs random ply ply ply double agent games games games hex pawn random vs random ply ply ply tic tac toe random vs random ply ply ply table bit matrix execution speeds seconds 
amount time moves play games depicted different search depths 
towers hanoi lowest highest average number moves games won moves table blind learner single agent games games number moves required blind learner solve towers hanoi depicted 
sticks stack improved performance nim achieved 
developments feature addition automatic 
table shows performance greedy opponent games learning games learning occurs games 
greedy agent random agent recognizes knows correct value winning loosing positions 
raps refers aps agent trained random agent aps aps agent trained greedy agent 
table presents conditions aps second agent move 
coming months extending results backgammon checkers othello chess building glm processes bit matrix relational tables images 

agent wins agent agent hex pawn random random random blind learner blind learner random tic tac toe random random random blind learner blind learner random table blind learner double agent games games blind learning versus random opponent 
percentage wins shown 
eric baum pointed bau inherent potential information mathematical structure inherent declaration rules domain computer science approach shannon basically regarded game defined game tree 
game interesting low complexity algorithmically efficient definition apart game tree 
procedure accesses underlying simplicity game form evaluation function inherently doing wrong thing 
main open question go evaluation function picture games 
agree strongly insight suggested projects believe lead practical exploitation underlying structure game domains agent agent games games games hex pawn random random ply aps random ply aps random hex pawn random random ply aps random ply aps random tic tac toe random random ply aps random ply aps random table glm double agent board games numbers percentages wins losses draws 
results glm playing random opponent various search depths depicted 

agent agent games games games pennies ply aps random nim ply aps random nim ply aps random table glm double agent stack games numbers percentages wins losses draws 
glm versus random opponent games 

generic representation design domain independent mathematical representation state space search domains 

informed learner design program performs state space search just mathematical definition domain domain independent heuristics experience 

blind learner design program performs state space search just experience rewards domain legal states raw bit vectors choose move 

monitor programming environment supports design execution experiments topics 
shown individual search game domains may viewed instances general graph theoretic game mathematical relations discussed relationship graphs relations order logic 
argue advantages perspective 
efficient domain independent monitor developed exploits matrix logic operations underlying hardware 

study relationship structure rules problem definition domain structure hierarchical reinforcement learner neural net learn value states domain 
particular outline algorithm convert relation representation domain reinforcement learning network domain 

problem definition monitor learner domain seen arising inherent structure domain separate processes 

result coherence domains similar structure give rise similar learners monitors 
fact illustrates network data structure monitors domain may basis reasonable learner domain 

relationships parts wholes domain definition may extracted identify placement generic learning modules reinforcement hierarchy 
learning research pursued higher perspective interaction learning modules choice methods 

agent agent hex pawn random greedy greedy greedy ply aps greedy ply aps greedy ply aps greedy ply aps greedy hex pawn random greedy greedy greedy ply aps greedy ply aps greedy pennies random greedy greedy greedy ply aps greedy ply aps greedy nim random greedy greedy greedy ply aps greedy ply aps greedy ply aps greedy ply aps greedy nim random greedy greedy greedy ply aps greedy ply aps greedy table glm double agent games learning numbers percentages wins losses draws 
results tournaments games greedy random aps agents trained games greedy random opponents depicted 
aps agents ply ply search included 
aps moves 
performance matrix monitor opposed learner lends credence practicality general graph theoretic view search domains 
results preliminary encouraging demonstrate reasonably strong reinforcement learners differing structure constructed automatically problem description 
research study reinforcement learner enhance adding new relational tables network 
self organization coupled parameterless requiring human tuning learning rules support theme giving computer maximum responsibility learning structure 

agent agent hex pawn greedy random greedy ply aps greedy ply aps hex pawn greedy random greedy ply aps greedy ply aps pennies greedy random greedy ply aps greedy ply aps nim greedy random greedy ply aps greedy ply aps nim greedy random greedy ply aps greedy ply aps table glm double agent games learning numbers percentages 
results tournaments games greedy random aps agents trained games greedy random opponents depicted 
aps agents ply ply search included 
aps moves second 
effort various research groups projects blueprint proceeds hope computer science artificial intelligence appreciated important branches mathematics dealing optimal problem solving resource constraints computer game playing played important role development 
acknowledgments barney pell anonymous reviewers provided useful criticism encouragement writing 
john amenta developed software obtained performance results 
zhang assisted developing declarative definition games implemented generic learning module 
james roberts helped figures late draft 
susan epstein provided exhaustive stylistic editorial corrections writing useful comments 
grover late draft 
allis 
solved 
herik allis editors heuristic programming artificial intelligence pages 
ellis horwood 
bau baum 
bayesian approaches games chess 
games planning learning proceedings aaai fall symposium menlo park ca october 
aaai press 
bcg berlekamp conway guy 
winning ways mathematical plays 
academic press new york 
bea beal 
analysis minimax 
clarke editor advances computer chess pages 
edinburgh university press edinburgh scotland 
ber hans berliner 
tree search algorithm best proof procedure 
artificial intelligence 
bet 
genetic algorithms function optimizers 
phd thesis university michigan dai 
bgh booker goldberg holland 
classifier systems genetic algorithms 
artificial intelligence 
bs beal smith 
random evaluations chess 
international computer chess association journal march 
bw berlekamp wolfe 
mathematical go endgames professional go player 
peters wellesley massachusetts 
el gerard ellis robert levinson editors 
proceedings international workshop peirce conceptual graphs workbench 
department computer science university queensland 
en ernst newell 
gps case study generality problem solving 
academic press new york 
eps epstein 
learning plans competitive domains 
proceedings th international conference machine learning pages austin tx 
morgan kaufmann 
eps epstein 
prior knowledge strengthens learning control search weak theory domains 
international journal intelligent systems 
fd flann dietterich 
study explanation methods inductive learning 
machine learning 
forgy 
rete fast algorithm pattern object patern match problem 
artificial intelligence 
gaines 
representation discourse logic truth situated knowledge technology 
conceptual graphs knowledge representation number lecture notes computer science pages 
springer verlag 
gj garey johnson 
computers intractability guide theory np completeness 
freeman murray hill 
gl gould levinson 
experience adaptive search 
michalski tecuci editors machine learning multi strategy approach volume pages 
morgan kauffman 
gol goldberg 
genetic algorithms search optimization machine learning 
addison reading ma 
ham hammer 
mathematics systems theory 
klir editor trends general systems theory pages 
wiley sons new york 
hol holland 
adaptation natural artificial systems 
university michigan press ann arbor 
hun hunter 
disjunctive concept learning 
december 
communication moderated electronic machine learning list 
jan jansen 
problematic positions speculative play 
marsland schaeffer editors computer chess cognition chapter pages 
springer verlag 
kai 
tree searching algorithms 
marsland schaeffer editors computers chess cognition pages 
springer verlag 
kli klir 
architecture systems problem solving 
plenum publishing new york 
km knuth moore 
analysis alpha beta pruning 
artificial intelligence 
km yves kodratoff michalski 
machine learning artificial intelligence approach volume chapter pages 
morgan kaufman 
see bibliography book extensive constructive induction 
kor korf 
planning search 
artificial intelligence 
kor korf 
optimal path finding algorithms 
kanal kumar editors search artificial intelligence pages 
springer verlag 
lev levinson 
universal data structure 
dick sowa editors conceptual structures theory practice number lecture notes ai pages 
springer verlag berlin 
lf robert levinson gil fuchs 
pattern weight formulation search knowledge 
technical report ucsc crl university california santa cruz 
revision appear computational intelligence 
lk levinson karplus 
graph isomorphism experience planning 
subramaniam editor proceedings workshop knowledge compilation speed learning amherst ma june 
lm lee mahajan 
pattern classification approach evaluation function learning 
artificial intelligence 
laird newell rosenbloom 
soar architecture general intelligence 
artificial intelligence 
ls levinson snyder 
adaptive pattern oriented chess 
proceedings aaai pages 
morgan kaufman 
ls levinson snyder 
distance unification chess knowledge 
international computer chess association journal september 
mcc 
conspiracy numbers minmax search 
artificial intelligence 
mic michalski 
theory methodology inductive learning 
michalski carbonell mitchell editors machine learning artificial intelligence approach 
tioga press 
min minton 
constraint generalization learning game playing plans single examples 
proceedings aaai pages 
aaai aaai press 
mir miranker 
treat better match algorithm ai production systems 
proceedings aaai pages 
aaai press 

theory hierarchical multi level systems 
academic press massachusetts 
mor morales 
learning patterns playing strategies 
international computer chess association journal march 
nau nau 
pathology game trees summary results 
proceedings national conference artificial intelligence aaai pages stanford calif 
aaai press 
nil nilsson 
principles artificial intelligence 
morgan kaufmann publishers 
pea pearl 
solution branching factor alpha beta pruning optimality 
communications acm 
pel barney pell 
new challenge games learning 
van den herik allis editors programming artificial third computer 
ellis horwood 
pit 
program learning play chess 
pattern recognition artificial intelligence 
academic press 
qui quinlan 
induction decision trees 
machine learning 
rk rich knight 
artificial intelligence 
mcgraw hill 
rm rumelhart mcclelland 
parallel distributed processing volume 
mit press 
rn russell norvig 
artificial intelligence modern approach 
prenticehall massachusetts 
rob roberts 
existential graphs 
semantic networks artificial intelligence pages 
roberts 
sac sacerdoti 
planning hierarchy abstraction spaces 
artificial intelligence 
sam samuel 
studies machine learning game checkers 
ibm journal research development 
sn smith nau 
strategic planning imperfect information games 
proceedings aaai fall symposium games planning learning menlo park 
aaai press 
sow sowa 
conceptual structures 
addison wesley 
sto 
minimax algorithm better alpha beta 
artificial intelligence 
sut sutton :10.1.1.132.7760
learning predict methods temporal differences 
machine learning august 
sut sutton 
special issue reinforcement learning 
machine learning 
tar tarski 
logic semantics metamathematics papers 
oxford university press oxford 
ts tesauro sejnowski 
parallel network learns play backgammon 
artificial intelligence 

mathematical games play 
ellis horwood great britain 
wat watanabe 
pattern recognition human mechanical 
wiley new york 
wil wilkins 
patterns plans chess 
artificial intelligence 
