type inference record concatenation multiple inheritance mitchell wand college computer science northeastern university huntington avenue cn boston ma usa material supported national science foundation numbered dcr ccr 
preliminary version appeared proc 
th ann 
symp 
logic computer science proposed running head type inference record concatenation show type inference problem lambda calculus records including record concatenation operator decidable 
show calculus principal types finite complete sets types term calculus exists effectively finite set type schemes typing instance schemes set 
show simple model object oriented programming including hidden instance variables multiple inheritance may coded calculus 
conclude type inference decidable object oriented programs multiple inheritance classes class values 

practical motivation type inference ensure operational safety property programs typed execute typed program guaranteed get error message bad function nil 
goal extend safety property programs involving records objects 
safety property get message find field attempt field extraction operation 
object oriented programming wish guarantee get messages find method 
reviewing section basic operations records 
section show objects classes modelled syntactic sugar record operations 
way typing results records object oriented programs 
consider type inference problem lambda calculus records 
properties differ dramatically depending record constructors considered 
section review emy solution type inference constructor extension single field record cons 
section show system extended record concatenation record append 
sections show approach extended handle unbounded sets labels 
sections discuss related 

records basic definitions records composite structures components indexed fixed set labels 
assume effectively determine label absent record 
model records total functions 
moment assume finite relax assumption section 
basic operations records selection null extension concatenation 
ffl selection label written gamma selects th component record ffl null record null fields absent 
ffl record extension standard extension function point write abbreviation 
ffl record concatenation standard union partial functions concatenation extension overwrite right rightmost field appears answer 
concatenation poses severe problems typing systems 
consider term xy ky applicable pair records integer field integer field absent field 
term principal type known system including emy cardelli 
shall show types generated type schemes 

objects main practical motivation considering records model objects classes operations 
model object record methods methods usually procedures 
share access set instance variables local object 
instance variables hidden rest program scoping 
furthermore methods may refer object identifier self 
class modelled procedure takes values instance variables object self produces object 
conventions think class definition instantiation syntactic sugar record operations class methods self null instance body class definition builds record methods starting empty record adding methods time 
instance operator uses fixed point operator guarantee self bound object 
add inheritance model relatively straightforward way 
introduce syntax class inherits methods signifies class inherit class expressions determine instantiate instance variables parent class 
pointed cook cook kamin reddy careful point sure instance class self methods parent class bound entire object just portion object corresponding parent class 
parent class acts virtual class simula 
easily achieved protocol class inherits methods self self class receives value self creates record methods setting instance variables values may refer self setting value self seen methods self entire record 
extends record adding methods daughter class time 
instance operator remains 
multiple inheritance records 
example interpret class inherits methods self self self way treat object oriented program syntactic sugar term lambda calculus records 
unusual feature language classes ordinary data values passed parameters 
write class transformer class inherits translation enables connection record concatenation multiple inheritance 
type system lambda calculus records decide typing programs object oriented language simply expanding syntactic sugar 
results subject reduction principal types semantics similarly inherited 
details worked wand 
proceed consider type inference problem lambda calculus records 

type inference records basic approach take type record record types components 
type record function 
type 
suggests type constructors form type theta type type pi type type emy emy observed may turned back ordinary algebraic signature introducing new kind called field signature type theta type type pi field type absent field pres type field scheme field absent signifies field absent record field pres indicates field value type schemas field may absent modelled field variable 
definition inductive semantics assigned types obvious way 
recursive types considered 
finite write pi ordinary type constructor arity card 
system write principal type schemes basic record operations null pi absent absent gamma pi pres gamma gamma pi pi pres set card field variables modified component pi constructors corresponding label instructive analyze schema 
says null builds record fields absent 
second says selection takes input record field returns value type field 
field variables allows type express proposition fields may absent 
says extension takes inputs record value returns record type input field guaranteed type types consistent semantics earlier 
finite conventional type system albeit slightly non standard kind system usual results polymorphic typing apply 
particular infer principal types reflexive infinitely deep types polymorphic values created standard construct ml 
conjecture extensions mitchell extension subtyping ground types mitchell toole gifford quantification schemes toole gifford easily incorporated 
gives solution case record extension see emy variants 
turn difficult case type inference concatenation 

dealing concatenation unfortunately system impossible assign principal type concatenation operator 
example show xy ky principal type system 
fag 
term type pi absent pi pres int int type pi pres int pi absent int principal type type general pi pi int reasonable type term 
concatenation principal type satisfies minimal expectations 
order analyze concatenation need look closely type assignment rules lambda calculus 
useful think ordinary type inference rules absence set constraints type expressions appear derivation 
view assign type variable subterm binding occurrence variable 
type inference rules may stated constraints types appear corresponding positions derivation 
write constraint node parse tree isomorphic course derivation tree ffl applied occurrence variable generate constraint type variable corresponding applied occurrence type variable corresponding relevant binding occurrence ffl occurrence application generate constraint type variable type variable corresponding occurrence indicated term 
ffl occurrence abstraction generate constraint type variable type variable corresponding indicated occurrence binding occurrence case 
easy see formulation equivalent usual inference rules solutions generated set equations correspond possible type derivations 
existence general unifiers implies existence principal types 
reduction cardelli cl ement implicit hindley milner 
possible state typing rule concatenation equation style concatenation principal type possible express sound typing rule concatenation disjunction equations ffl occurrence concatenation generate constraints pi pi kn pi pres absent constraints reflect analysis records determined composition 
field field case field result field absent case field result absent 
constraints determine type inference rule form acceptance criterion type derivation tree 
writing rule usual deduction rule form left tedious exercise reader 
constraints type reconstruction 
longer conjunction equations positive boolean combination equations 
expand disjunctive normal form getting disjunction conjunctions equations 
conjunction analyzed get general unifier yielding finite set types substitution instances precisely typings original term 
proves main theorem theorem 
closed term effectively determine type 
particular generate finite set type schemes types exactly substitution instances schemes 
convenience stated result closed terms result terms free variables slightly harder state difficult 
motivating example xy ky easy see complete set types pi pres int pi absent int pi pi pres int int usual expanded argument pi corresponding field 
easy see term principal type type types instances instances legitimate types term 
number types generated large course may large kn card number occurrences concatenation program 
practice attempt solve equations possible expanding disjunctions prune unsatisfiable disjunctions quickly possible 
reflection real difficulty object oriented programming systems systems multiple inheritance go great lengths determine ancestor particular method inherited 

dealing infinite label sets general typecheck programs finite checking small module large system may know advance labels may larger system 
similar problems arise incrementally checking piece program interactive system 
necessary provide infinite set labels possible language 
infinite need notation specifying functions field call rows assume loss generality labels appear program numbered ae ae new class variables called extension variables 
write pi product type pi absent absent pi ae product type pi ae ae ae fresh field variables 
refer labels explicit labels implicit think extension variable labelled ellipsis 
way reduce pi infinitary constructor finitary ary constructor kind structure type theta type type pi field theta extension type absent field pres type field empty extension note kind extension extension variables constant empty denoting ellipsis components absent 
observe constants principal types finitely representable scheme null pi absent absent empty gamma pi pres ae gamma gamma pi ae pi pres ae furthermore calculate general unifiers infinitary terms finitary representations theorem 
finitary terms unifier infinitary translations general unifier represent general unifier translations 
proof phi map finitary infinitary terms defined 
observe finitary term instance finitary term phi instance phi 
finitary terms unifiable phi phi unifiable phi mgu common instance 
get converse show phi phi unifiable infinitary mgu form phi 
show proceed induction size form pi empty general unifier phi phi form phi pi empty 
interesting case pi ae pi ae phi pi ae phi pi ae general unifier ae ae common instance 
field constant absent variable 
variable appears th position pi node unify th variables 
ae variable unifies empty variables unify absent unify variables 
case general representable phi finitary term furthermore observation general unifier qed deal unification principal types language concatenation simply calculating representations 
consider deal concatenation presence infinite directly extend version finite require generating infinitely disjunctions 
define extension constraint formula form ae ae ae extension constraint abbreviates infinite set disjunctions ae pres ae ae ae absent ae ae 
say substitution satisfies set extension constraints iff assigns types fields type field variables disjunctions true 
note set extension constraints satisfiable just set ae empty 
state rules generating constraints 
generate constraints ordinary terms 
rule concatenation ffl occurrence concatenation generate constraints pi ae pi ae kn pi ae pres absent ae ae ae expand disjunctive normal form get disjunction formulas form set equations set extension constraints 
unify disjunct individually get general unifier set row constraints 
doing unification substitutions extension variables course performed 
row constraints simplified rules empty ae ae ae ae necessary obtain result 
gives main theorem state just case closed terms theorem 
closed term effectively generate finite set consists pairs set extension constraints type scheme type iff pair substitution oe oe satisfies oe 
corollary 
closed term effectively determine type 
proof generate set pairs 
set empty type 
set non empty choose pair substitute empty extension variables 
gives type qed 
dealing better infinite label sets development adequate theoretically deal infinite label sets inadequate deal problem led consider infinite label sets place problem incrementally checking portion program knowing entire set labels needed 
order deal problem observe necessary pi types exactly set explicit labels 
write typical pi node pi ae indicate explicit labels language succinctly write types constants follows null pi empty gamma pi pres ae gamma gamma pi ae pi pres ae unification algorithm maintain invariants ffl pi nodes extension variable explicit labels extension variable defined domain 
ffl pi nodes unified explicit labels 
ffl extension variables appear extension constraint explicit labels domains 
invariant satisfied types constants written 
invariant consider unifying terms tm tn traverse trees may reach corresponding pi nodes different sets explicit labels 
order unify pad nodes give set explicit labels lm set labels explicit node ln set labels explicit second node 
label ln lm replace node tm form pi ae pi ae ae node form pi empty pi absent empty pad tn similarly 
global padding substituting construction ae ae ae ae fresh extension variable 
unify usual 
construction extension constraints start variables having explicit labels fact start set explicit variables empty substitution affects constraints pad extension constraints 
note creation new variables bounded number new nodes created done padding simply choosing labels program explicit unifying 
algorithm halts new variables introduced 
difficulty faced adapting usual type inference algorithms infinitary trees treatment 
usual treatment create quantifying type variables appearing type hypotheses create new variables quantified variable identifier cl ement 
system involve quantifying infinite number field variables 
problem abbreviate quantifying corresponding extension variables generating new extension variables needed 

related cardelli introduced record models objects including subtyping 
system deal records indefinite width system attempt type inference 
inability system powerful system bounded fun cardelli wegner deal record updating problem topic discussion types electronic mailing list meyer 
language capable dealing record overwriting kind introduced wand attempted type inference language unfortunately unification algorithm incorrect 
emy introduced notion fields gave obviously correct treatment records usual notion unification 
system focuses polymorphism procedures emy introduced system records polymorphic 
system record regarded polymorphic object field containing value may instantiated selection absent forgotten 
set terms typable system incomparable typable original system 
system preferable applications giving plausible semantics remains open problem 
jategaonkar mitchell give type system extendible records ml including ml patterns subtyping ground name equivalent types 
conjecture system replace cut restrictions system resulting systems fit nicely 
contributed treatment type inference records 
reddy gives semantics objects closures close spirit 
gives traditional denotational semantics give concrete semantics wand translation underlying lambda calculus 
looking type resulting terms obtain finer type information possible looking just denotational semantics 
derive typing rules source language saying source language phrase typed translation 

algorithm doing type inference lambda calculus records record concatenation 
treating object oriented programs syntactic sugar terms language system enables ml style type inference object oriented programs multiple inheritance including classes class data objects 
conversations patrick keefe denis kfoury peter wegner helpful understanding issues refining presentation 
cardelli cardelli basic polymorphic typechecking polymorphism newsletter jan 
appeared computing science tech 
rep bell laboratories murray hill nj 
cardelli cardelli semantics multiple inheritance information computation 
cl ement cl ement despeyroux despeyroux kahn simple applicative language mini ml proc 
acm symp 
lisp functional programming 
cardelli wegner cardelli wegner understanding types data abstraction polymorphism computing surveys 
cook cook self ish model inheritance manuscript 
hindley hindley principal type scheme object combinatory logic trans 
am 
math 
soc 

jategaonkar mitchell jategaonkar mitchell ml extended pattern matching subtypes proc 
acm conf 
lisp functional programming kamin kamin inheritance smalltalk denotational definition conf 
rec 
th ann 
acm symp 
principles programming languages 
meyer meyer 
moderator types electronic mailing list types theory lcs mit edu milner milner theory type polymorphism programming comp 
sys 
sci 

mitchell mitchell coercion type inference summary conf 
rec 
th ann 
acm symp 
principles programming languages 
toole gifford toole gifford type reconstruction class polymorphic values proc 
sigplan conf 
programming language design implementation sigplan notices july 
reddy reddy objects closures semantics object oriented languages proc 
acm conf 
lisp functional programming 
emy emy typechecking records variants natural extension ml conf 
rec 
th ann 
acm symp 
principles programming languages 
type inference subtypes conf 
rec 
th ann 
acm symp 
principles programming languages 
wand wand embedding type structure semantics conf 
rec 
th acm symp 
principles prog 
lang 

wand wand complete type inference simple objects proc 
nd ieee symposium logic computer science 
wand wand type inference objects instance variables inheritance northeastern university college computer science technical report nu ccs february 
