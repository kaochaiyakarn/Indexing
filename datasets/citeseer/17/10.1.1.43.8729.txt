diku report declarative continuations categorical duality andrzej filinski diku computer science department university copenhagen dk copenhagen denmark email andrzej diku dk august thesis presents formalism reasoning continuations categorical setting 
points values continuations seen categorically dual concepts symmetry extends data types control structures evaluation strategies higher order constructs 
central idea view continuations declarative concept imperative implications spine presentation 
symmetrical extension typed calculus introduced values continuations treated opposites permitting mirror image syntax dual categorical concepts products coproducts 
implementable semantic description static type system calculus 
purely categorical description language obtained correspondence system combinatory logic similar cartesian closed category completely symmetrical set axioms 
number possible practical applications directions research suggested 
address sept comp 
sci 
dept carnegie mellon university pittsburgh pa preface document author master thesis forming part credit cand 

degree computer science diku computer science dept university copenhagen 
aim bring important descriptive formalisms category theory continuation semantics 
mathematical framework discussing functions structured sets introduced mainly handling goto programming languages 
subjects little common 
shows continuations forced categorical setting fit strikingly modeling central categorical concept duality precise formulation 
thesis written supervision dr olivier danvy introduced strange fascinating world continuations 
constant encouragement feedback proved invaluable numerous occasions initial intuition subject turned absolutely correct lots hard part 
am deeply grateful support thesis probably 
special go prof neil jones course category theory see light simple powerful framework 
pointed number mathematical weaknesses early versions provided helpful suggestions stages 
greatly appreciate deep comments ideas hans austin melton torben mogensen philip wadler encouragement interest shown john hannan john hughes john launchbury david schmidt 
shorter version appear filinski 
covers material chapters evaluation orders somewhat abridged way 
copenhagen july contents background goals overview thesis category theory basic definitions categorical definitions continuation semantics problems direct semantics continuation semantics semantics escapes alternative evaluation orders symmetric calculus core slc functions values continuations basic syntax conversion rules denotational semantics structured types products coproducts terminal initial objects denotational semantics summary order language non local values continuations examples higher order constructs functions values continuations currying denotational semantics alternative evaluation strategies pure cbn evaluation cbv lazy products cbn eager coproducts comparison cbv cbn recursion iteration recursive functions values continuations fixpoints nontermination denotational semantics complete description slc type system denotational semantics symmetric combinatory logic categorical view slc functions values continuations structured types higher order features scl category axioms totality strictness core axioms higher order axioms summary morphisms axioms derived equalities translation scl slc translation slc scl scl slc conversion rules evaluation strategies cbv cbn scl lazy products cbv eager coproducts cbn iteration recursion repetition operators fixpoint morphisms back values continuations categorical denotational semantics applications examples symmetric programming language notation labelled datatypes binding primitives control primitives top level evaluation asymmetric extensions restrictions slc scl metalanguages goto jumps type system multiple returns label types exceptions persistent continuations programming slc non local exits tree search coroutines streams iteration recursion object oriented programming symmetry organizations specification inheritance implementation inheritance look object oriented languages interpretation directions research comparison related bibliography implementation slc scl concrete syntax pre parsing syntax parsing translation slc scl type inferencing evaluation top level interaction sample session chapter chapter presents background thesis 
start summarizing motivation purpose 
give overview organization main results obtained chapters 
order thesis reasonably selfcontained chapter contains brief introductions category theory continuation semantics 
background goals category theory proven useful formalism describing semantics programming languages common language constructs direct categorical counterparts 
descriptions concentrate data flow details control structure including conditionals evaluation strategies described adequately existing presentations 
particular applicative order reduction termination problems imperative features exceptions non local exits appear somewhat incompatible declarative categorical concepts 
hand continuation denotational semantics suitable describing precisely phenomena enables reason formally programs termination properties regardless evaluation order description language 
provides clean foundation handling run time errors concepts backtracking coroutines 
introduces additional level abstraction semantic description making somewhat harder automate reasoning programs purposes transformation correctness proofs 
thesis step building bridge methods language description particular show suitable framework class continuations sound declarative meaning opposed just powerful unstructured control primitive 
shall investigating semantics small expressive language calculus 
conventional programming languages main purpose provide convenience reasoning continuations values 
fact quite accurately characterized copies calculus connected back back 
main idea viewing values continuations dual concepts generalizing usual value constructs functional abstraction application encompass continuations 
symmetry language primitives mirrored symmetry types kinds operations acting categorically dual types products coproducts 
shall stress categorical view point developing combinator axiomatic presentation language 
concept evaluation order reduction strategy plays important role language definition 
easily formulated continuation framework usually harder express categorical terms 
view language semantics consisting set core axioms satisfied reduction strategy additional ones specifying particular evaluation order 
separation see applicative normal order reduction call value call name essentially dual strategies 
symmetry apparent traditional languages access continuations complicated non existent clearer symmetric language 
symmetries exposed thesis offer new somewhat unconventional ways understanding existing language constructs concepts 
importantly suggests entirely new fields enquiry language design implementation pointing dual versions useful operations program transformation techniques theoretical background practical implications worked 
descriptive framework familiar concepts distorted somewhat fit theory 
author believes small price pay compared benefits offered categorical duality melting pot programming language design benefit moderate 
language constructs deviate underlying categorical concepts historical reasons design 
instinctive aversion goto constructs inhibited development control primitives required achieve better symmetry data operations 
quite negative implications deviating established path fully understood 
considerable resources expended research theory practice programming language design ideas probably appear misguided plain wrong experienced researcher 
author hope problems concern investigation pruned dead branches central idea treating continuations categorically symmetric language 
thesis represents current state progress 
emphasis obtaining practically significant results precise mathematical structure 
course mean completely rigorous foundation considered important natural time constraints forced concentration investigating broader implications preliminary results 
constructing polished theory knowing real world considered big risk take 
fortunately results obtained far indicate fuller formalization possible desirable 
overview thesis section gives chapter chapter overview thesis 
structurally chapters depend material chapter read order 
ffl rest chapter consists category theory continuation semantics 
readers familiar topic safely skip corresponding part particularly careful reading warnings section 
absolute minimum required material covered 
reader completely new fields may find quite hard understand thesis purpose 
reader strongly advised consult standard textbook subject suitable section 
experience modern functional programming language scheme ml may considerable advantage essential 
ffl chapter introduces notation called symmetric calculus slc reason continuations 
introduce step step starting core idea gradually add structured data higher order constructs recursion 
main theme presentation duality values continuations slc syntax mirroring semantic symmetry 
central mode description denotational semantics mention categorical foundations concepts introduced 
ffl chapter covers symmetric combinatory logic scl categorical foundation slc 
introduce objects morphisms axioms scl needed express slc concepts 
main result chapter variable free representation slc flow data control expressed fixed set categorical combinators 
see factorizing semantics slc compiling away concept substitution 
formal reasoning slc simpler 
chapter category theory give residual denotational semantics language categorical terms 
ffl chapter consider possible applications slc scl give number substantive examples 
sketch design practical programming language symmetries previous chapters point existing language constructs expressed slc terms 
half baked ideas suggest directions research look promising pursued 
point similarities differences related 
ffl chapter summarizes current results experiences slc scl approach continuations symmetry 
point particular strengths weak points unsolved problems 
details probably benefit different organization certain basic ideas categorical treatment continuations sound provide solid framework area 
ffl appendix contains listings model implementation slc scl directly equations derived thesis 
main purpose implementation permit evaluation examples large compute hand enforce precision presentation questions efficiency totally ignored 
implementation consists modules parsing translating evaluating type inferencing slc scl terms 
written caml dialect ml uncommon facilities yacc interface pre parsing 
provided convenient way entering slc terms absolutely problems translating functional language standard ml scheme 
category theory section intended tutorial category theory 
number readable introductory books subject exist arbib manes rydeheard burstall 
mathematically inclined reader may prefer maclane hardly recommended average computer scientist 
higher order constructs main lambek scott 
branches mathematics category theory basically organizational framework may 
number non trivial theorems stated pure theory involving categories consists applications categorical mode description areas mathematics computer science 
thesis application deep theoretical results 
previous experience categories necessary 
main text basic categorical topics introduced play central role 
includes central concepts functors natural transformations adjunctions mono epimorphisms interested reader find details works mentioned 
basic definitions subsection presents innermost core category theory common virtually applications 
reader see category weak structure generalizes familiar mathematical concepts groups vector spaces 
give examples various seemingly unrelated topics fit naturally categorical framework 
definition category consists collection objects morphisms arrows 
morphism object object written morphisms composed morphisms exist morphism ffi composition associative morphisms case ffi ffi ffi ffi object exist identity morphism id morphisms ffi id id ffi notation suggests functions fact obvious example category example category set sets objects total functions morphisms 
morphism composition just function composition associative identity morphism set function sends element 
example extended various ways categories set pf sets partial functions dom domains continuous functions grp groups group homomorphisms reader misled thinking category theory just functions sets structure 
fact surprising number mathematical concepts fit framework mention just example partially ordered set poset viewed category individual elements objects single unnamed morphism objects iff morphisms composed transitivity associativity composition trivially fulfilled morphism objects 
existence identity morphisms ensured reflexivity object note antisymmetry condition captured 
common virtually practical category extra structure 
express antisymmetry categorical way stating morphism write mv category induced partial order just preorder necessarily antisymmetric example theory deductive system viewed category propositions formulae objects proofs morphisms 
write entails proven 
entailment confused formula strong relation known deduction theorem formal logic functional completeness category theory 
return subsection 
identity amounts rule proposition note axiom formal systems 
virtually proven 
composition means known transitivity rule permits build larger proof smaller ones 
course real deductive system axioms inference rules 
poset example different proofs essentially identical differing form content 
categorical framework deductive systems identifies proofs linear structure sequence non trivial inference steps 
precisely axioms identity associativity express 
may obvious reasons proofs considered identical 
example may differ ordering independent deductions 
theory additional axioms rules specify proofs equivalent 
examples consider classical propositional calculus usual rules de morgan laws framework encompasses systems restrictive axioms intuitionistic logic 
aim category theory describe objects terms arrow structure 
look inside objects way expressing equivalence definition morphism isomorphism exists morphism gamma gamma ffi id ffi gamma id objects said isomorphic exists isomorphism set isomorphisms precisely bijective maps sets 
sets isomorphic may appear undesirable 
remember allowed set theoretical functions morphisms 
sets isomorphic set category top topological spaces continuous functions 
mv elements isomorphic iff preorder fact partial order isomorphisms identities 
deductive system propositions isomorphic entail 
example system conjunctions formulas usually isomorphic 
introduce concept duality 
great direct importance applications category theory absolutely essential rest thesis 
unfortunately easy give intuitive explanation duality general case 
hopefully examples subsection prove illuminating 
definition category dual category op defined category objects direction morphisms reversed 
particular morphisms morphisms op composition ffi ffi op dual category poset op category induced reversed ordering set 
dual category deductive system original objects interpreted negated formulae op note negation part formula interpretation 
dual category set functional category dom hard imagine considered 
thesis precisely duality aspects set category return problem chapter 
concept category speak concept op arrows reversed 
concept referred dual original name derived adding prefix 
common cases names exhibit symmetry 
see lots examples dual concepts subsection 
categorical definitions consider categorical characterization familiar concept definition product objects category consists object theta projections theta theta object morphisms exists unique mediating morphism hf gi theta ffi hf gi ffi hf gi express graphically means commuting diagram theta oe gamma gamma gamma gamma gamma gamma hf gi note uniqueness condition expressed unconditional equation theorem morphism hf gi unique ffi ffi hf gi iff theta ffi ffi hi proof theta ffi ffi hypothesis ffi ffi hi hf gi 
theta 
set ffi ffi hf gi ffi ffi hi 
set define object theta cartesian product sets projections 

functions define hf gi 

easily checked satisfies conditions definition 
category induced poset product objects elements greatest lower bound projections correspond lower bound condition existence mediating morphism ensures uniqueness condition trivially fulfilled category arrow objects 
deductive system product objects propositions conjunction projections rules mediating morphism states proofs construct unique proof categories products 
example poset greatest lower bounds 
morphisms convenient define morphism theta hf ffi ffi theta theta reason notation having functors pursue 
consider dual definition definition product direction morphisms reversed definition coproduct objects category consists object injections object morphisms exists unique mediating morphism ffi ffi diagrammatically oe gamma gamma gamma gamma gamma gamma psi familiar theorem theorem morphism unique ffi ffi iff ffi ffi proof ffi ffi hypothesis ffi ffi 

set hffi hffi hffi hffi 
see proof virtually identical theorem 
stated simply theorem duality 
shows duality cuts half time prove categorical theorem proven dual 
careful premises theorem 
example say existence coproducts category existence products know category coproducts iff dual products 
set coproduct objects sets disjoint union ag bg 
injections functions 

mediating morphism function defined cases 
category poset coproduct objects upper bound atb 
element property injections object case mediating morphism 
propositional calculus coproduct formulae disjunction injections rules mediating morphism permits deduction morphisms define ffi ffi analogously products 
clear definitions binary products coproducts extended arbitrary finite products coproducts 
leads question empty case 
projections disappear existence uniqueness mediating morphism remain definition terminal object category property object exists unique morphism 
express uniqueness drastic looking equation course meaningful type 
set singleton set ftg terminal object unique morphism defined 
note theta isomorphic set mv terminal object property object element 
glb empty set element lower bound glb just greatest element set 
deductive system terminal object proposition truth proposition case conjunction zero formulae neutral element 
dualize definition terminal objects obtain definition initial object category property object exists unique morphism analogous equation set empty set initial object 
associated unique morphism function empty domain 
see disjoint union zero sets 
mv initial object property element lub zero elements upper bound property trivial 
deductive system initial object formula falsehood formula case disjunction zero formulae neutral element consider slightly advanced subject intuitively understandable 
elegant way terms adjunctions easily definition exponential objects consists object application morphism ap theta morphism theta exists unique morphism ap ffi theta id theta theta gamma gamma gamma gamma gamma gamma ap theta id note uniqueness expressed equationally ap ffi theta id proof similar uniqueness products 
fact instances general proof schema apparent various concepts expressed adjunctions 
set exponential object function space set functions ap function 

function 


deductive system exponential formulae formula application essentially modus ponens rule proof exists unique proof category poset exponential objects correspond simple concept may exist anyway 
consider example 
poset set subsets ordered inclusion 
glb subsets intersection exponential object sets set denotes complement easily checked definition category called cartesian binary products terminal object cartesian closed exponentials 
abbreviation ccc commonly cartesian closed category 
conclude section warning thinking functional categories terms structured sets functions big help cases may hinder understanding 
category chapters looks deceptively set set pf radically different 
thinking set terms definitely lead trouble fundamental properties appear violate causality 
plausible results existence isomorphism theta theta theta certainly taken granted 
continuation semantics main prerequisite thesis knowledge continuation semantics 
really deep results complicated constructs somewhat peculiar continuation passing style semantic equations may appear quite complicated seen time 
continuation semantics books denotational semantics stoy schmidt 
short see reynolds sethi tang 
section assumed reader familiarity general framework denotational semantics little experience continuations 
continuations commonly model goto constructs 
considering expression languages presentation concentrates expression continuations command continuations 
basic idea concept jumps declarative language may appear stranger imperative 
hopefully examples convince reader facility important useful 
problems direct semantics goal denotational semantics map syntactic constructs subject language semantic terms hopefully familiar calculus 
fundamental requirement description meaning term function homomorphism meaning subterms 
property known compositionality possible reason denotations simple precise way structural induction 
simplest languages meaning language construct depends context 
example meaning expression depends value variable expression evaluated 
handle variables compositional way meaning subterm function values free variables occurring 
collect variable values environment denotation expression function environments values 
semantics expressions called direct semantics 
consider direct semantics simple expression language syntax cst assume expressions evaluate integer values semantic domains int env ar int valuation function exp env letter ae environments 
give semantic equations 
simplicity identify syntactic semantic constants consider non zero value true cst ae cst ae ae ae ae ae ae ae theta ae ae 
ae ae ae ae ae ae simple readable description expression language valuation function somewhat extended course give meaning expressions real sized language 
complete specify initial environment looks ae init maps global variables 
natural way describing expression evaluation fundamental flaw 
really apparent language add seemingly innocent extension integer division 
may try add directly extending syntax giving semantic equation new case delta delta delta div div ae ae aec bxc denotes floor largest integer equal probably acceptable solution toy language simplistic describing expression evaluation real language 
problem course possibility division zero 
meaning div 
importantly valid optimize expression div just 
semantics answer conclusively questions fails assign mathematical meaning division zero 
patch problem somewhat exploiting special value flat domain div ae ae 
ae dc better quite solve problems 
example meaning div 
real problem possible answers defensible fact exist languages kinds 
problem calculus term give denotation expression inherently ambiguous reduced applicative order obtain normal order 
problem evaluation fail terminate infinite recursion 
limp specifying expression evaluated quite right augment precise mathematical definition vague extra information 
convey information domain definitions precise lifting different conventions regarding clear domain int includes bottom element add letting int 
problem worse want recover run time errors abandoning execution completely 
example assume want include expression form try semantics evaluated 
goes value result try expression evaluation encounters runtime error evaluated 
example expression try div evaluate xc zero 
naive attempt try ae ae 
ae mathematically defensible valuation function monotonic cause problems want introduce recursion language 
extend domain special error value distinct semantic equations arithmetic preserve error value try expressions detect substitute 
unworkable write entire semantics way tarlecki complexity result suggests formalism entire idea compositionality simply expressive handle effects properly 
fortunately case pointed strachey wadsworth 
problem simply codified start fact evaluation expression fail deal 
precise order evaluation leaving meta language 
problems solved continuation semantics 
continuation semantics key idea expression evaluated reason 
top level expression evaluated user wants know result 
subexpressions evaluated values needed compute final result 
seemingly trivial insight basis continuation semantics allows meaning expression depend function value 
leads characteristic way writing semantic equations dependency explicit 
evaluate top level expression order get answer 
needs immediate result expression 
example answer string representing result decimal number 
time evaluate subexpression step obtaining answer know exactly compute answer value subexpression 
function computes answer called continuation 
meaning expression function environment usual continuation domain answers 
example toy language ans string initial continuation function init ans generally letter continuations 
semantic equations look 
keep mind want compute final result program know obtain result subexpression 
constants identifiers solution simple just apply continuation result subexpression cst ae cst ae ae evaluating constant variable simple operation fail 
simply compute sum expressions ae ae init ae init denotation expression environment continuation string number 
ans init incorrect evaluating result final answer init implies need addition 
compute final answer compute pick 
result evaluate add 
apply continuation computes final result program result ae gg braces parentheses continuations 
multiplication analogous addition 
expression choice evaluate result consider case treat possibility section 
compute value evaluate environment variable bound value 
evaluated order evaluate continuation simply continuation expression ae 
ae consider conditional expressions 
evaluate original continuation ae ae aeg completed continuation semantics language 
equations somewhat complicated 
see handle problems direct semantics 
semantics escapes consider case recover runtime errors 
want behavior attempt divide zero program execution stopped answer string division zero 
express directly expression computing final value 
evaluate dividend divisor zero error message final result proceed usual div ae division zero bn semantics completely unambiguous 
example ae ae ft 
ae ae fn division zero 
bn dc ae gg division zero division zero division zero reduced way 
runtime errors just special case 
introduce general construct abandoning current path evaluation returning new final result 
add construct language delta delta delta expression evaluated context value argument final result program 
example consider expression div non zero evaluates xc 
result expression entire program subexpression 
semantic equation ae ae init original result continuation course evaluation encounters discard continuation restart initial 
note necessary modify semantic equations order handle division zero 
specify addition operand evaluated order disambiguate expressions 
consider harder problem recovery runtime errors 
treat errors special case generalized construct gives simplest presentation 
problem existing returns final answer program 
want limit scope specify directly result subexpression necessarily program 
example suppose multiplying list numbers 
encounter zero result entire multiplication zero ignoring possibility runtime errors simple result multiplication necessarily final result program 
obtain delimited version constructs block block name label 
intent expression block evaluated normally 
inside expression construct abandon execution block expression return alternate result 
example block evaluates 
list multiplication example block mul mul delta delta delta mul expression may occur context symbolized 
course real language multiplication typically performed kind repetition construct example block mul letrec ml hd mul hd ml tl ml block names identifiers just variables 
separate environment existing handles non local values 
identifiers denote ordinary values denote block names 
adopt usual syntactic scope rules expression possible escape outer block name variable 
environment map block name 
encounter want continue just finished evaluating expression part designated block 
want continuation block 
simplest way achieve simply block names denote continuations type environment env ar cnt course modify equations environment add remove injection tags 
immediately decidable identifier denotes block value processing done compilation need imply overhead execution 
meaning block construct expression evaluated normally continuation block accessible escaping block ae 
cnt ae discards current continuation installs denoted block identifier ae cnt ae ae handle try 
introduce special continuation identifier error activated runtime errors try ae ae error 
cnt ae denotes special continuation invoked runtime errors 
called final answer error message example discarded handling error 
initial error continuation denotation error initial environment return message final answer program 
note try expressions share identifier error return defined 
error handled enclosing try evaluated original environment ae 
meaning construct may cause runtime error div ae cnt ae error division zero bn alternative evaluation orders finish showing express evaluation order expressions 
specify semantically equivalent textual substitution modulo name clashes 
particular defined identifier occur body defining expression evaluated 
stipulating variables denote residual computations evaluating variable complex process 
may cause run time error escape evaluated continuation 
modify denotation value identifiers ignoring blocks simplicity env ar 
cnt ans equation variable evaluation ae ae expressions denotation ae 
aec ae equation explicit denotation div body evaluated contain denotation div concern 
fact shown plotkin meaning term continuation semantics independent evaluation order metalanguage presence recursive facilities nontermination 
intuitively property reduction step fi redex outside abstraction sequence reductions completely specified strategy weak head normal forms 
category theory section conclude warning user accessible continuations may look reader strong functional programming background 
sharp tool reason 
introduced imperative add declarative language 
chapter language explicit access continuations central declarative concept parenthesis language definition 
vital consider continuation manipulating operations way inferior imperative traditional value constructs 
simpler concepts twisted continuation free framework doing certainly impede understanding parts 
chapter symmetric calculus chapter introduces notation reasoning continuations 
takes form simple functional language similar principle typed calculus containing continuation part equal importance usual expression oriented half 
language contain traditional calculus subset called mirror image refer symmetric calculus slc 
full slc contains new ideas may appear overwhelming 
start core language gradually add new concepts structured types higher order constructs recursion trying times point familiar value concepts terms continuations 
section concluded conventional denotational semantics giving precise description new concepts 
complete semantics better suited section full type system language 
slc informally basically strategy independent way semantical description terms applicative order call value reduction 
may easier understand way essential section alternative call name semantics 
section point symmetry slc essentially dual properties evaluation strategies 
section reduction order fact appear discussion recursion iteration treatment topics closely tied evaluation strategy 
core slc section presents central idea slc basic syntax semantics core language 
functions values continuations functions traditionally viewed value transformers common notation 
syntactic variants thereof reinforce view 
different perspective functions data flow paradigm computation request transformers 
example function odd int bool usually thought transforming integer value boolean value seen transforming request boolean value request integer 
note roles values requests depend evaluation strategy 
eager data driven evaluation flow control determined values requests implicit 
hand lazy demand driven environment requests actively pull forward evaluation values passive existence 
extend view continuation semantics continuations sense act requests 
lazy language drive forward computation evaluated asks result 
eager language hand continuations just accept computed results 
cases continuation thought lack absence value just having negative amount money represents debt 
analogy extends debt transformation borrowing money 
fact economic situations easier understand terms changing debts deficits genuine flow money 
basic syntax conversion rules informal view values continuations dual concepts try construct language treated truly symmetrically 
temporarily abandon calculus amalgamation functions values distinguish sharply different syntactic classes functions values continuations 
function value transformer continuation transformer 
conversely function may defined terms effect input value result continuation 
write function application value explicit operator denotes result output transformed corresponds exactly juxtaposition calculus 
types familiar function expression type expression type symmetrically write continuation transformed denotes new continuation transform input note types reversed returns typed result type denote accepting continuation 
specify functions value abstractions continuation abstractions describes transform input value result value specifies request result transformed request input 
see symmetry types denotes typed variable typed expression function type hand function abstracts result continuation typed new continuation accepting 
note continuations treated functions explicitly apply continuation value substitute current continuation possibly defined terms original 
importance stressed slc continuations black holes return 
function continuation specify destination result processed function 
addition explicit abstractions include number primitive functions arithmetic operators corresponding ffi rules 
note value continuation transformers remarked section function odd 
simplicity assume primitive functions escape behavior expressed explicitly slc continuation abstractions 
justify name symmetric calculus include conversion rules ordinary calculus mirror images usual restrictions prevent capturing free variables ff ff fi fi free free furthermore want category theory organize slc suitable way 
natural choice consists types objects functions kinds 
morphisms 
note concept value flow definition category type function mode definition matters 
proper category define identity function composition symmetry conversion rules permits equally acceptable ways value continuation abstractions 
want favor equivalent giving rise rules occur free id ffi identities take side rules definition 
easily checked neutrality identity associativity composition follows conversion rules 
strictly speaking term denote function function template instances supplying type 
words distinct identity morphism object 
significant higher order constructs added language 
view single polymorphically typed function adds extra level complication 
unfortunately having fi fi rules general form leads inconsistent system totally unrelated terms interconvertible 
example function ffi continuation outer scope may reduced problem specific slc general manifestation weakness applied calculus partial functions ffi rules runtime errors disturb continuation 
example expression evaluate call name cbn language fail call value cbv 
virtually programming language definitions specify evaluation order set restrictions possible reductions 
assume cbv strategy fi conversion performed completely reduced arguments restrictions fi rule 
section alternative strategies considered 
significance composition rule apparent transform terms form restricted fi rule applied shifting nested function applications continuation 
exactly happens continuation interpreter denotational semantics subsection evaluation explicit continuation built functions applied simple values 
directly verified rules full fi reduction hold cbv semantics identity composition rules satisfy associated axioms neutrality associativity 
denotational semantics summarize syntax slc subset introduced far follows cst prim ide simplicity consider sets value continuation identifiers disjoint 
examples names values continuations general case kind identifier inferred context 
unfortunate asymmetry language proceed distinguish expressions values denoting term continuation covers uses 
fortunately big problem cbv evaluation syntactic continuation denotes semantic continuation expressions may denote values escape 
need semantic domains cnt representing values continuations respectively assigning meanings slc terms 
postpone precise definition moment consider types valuation functions classes 
note order model substitution denotationally meaning construct relative environment 
map value identifiers values continuation identifiers continuations 
strictly speaking represented pair functions just define single function mapping identifier value continuation env ide cnt cbv continuation semantics meaning expression environment relative continuation representing rest computation 
dually meaning syntactic continuation relative value representing result computed far 
slc function invoked input value output continuation explicit depending application type 
summarize types semantic functions strategy independent way env cnt ans env ans env cnt ans types curried form reduce clutter parentheses brought tupling 
semantic equations apply function subset parameters uncurried definitions equally 
consider particular evaluation strategy cbv give proper denotational semantics language 
valuation functions necessarily look somewhat asymmetrical translating symmetrical language asymmetrical fixing particular evaluation strategy 
course continuation semantics evaluation order defining language calculus affect meaning defined language slc 
semantic domain values unspecified domain basic values integers continuations mapping values answers basic cnt ans expressions cst ae cst ae val ae ae ae aet keep things simple identified syntactic semantic constants identifiers 
continuations constants just get aev cnt ae aev aev aet functions aev 
val ae aev 
cnt ae prim aev prim rule viewed specific equation primitive function 
structured types far considered type basic values 
virtually strongly typed programming languages provide support building new types existing ones 
goal subsection syntax doing slc 
see continuations play crucial role definition 
products coproducts basic schemas constructing new types old ones tuple record structure disjoint sum variant union 
relation categorical concepts products coproducts obvious syntax semantics associated seldom exhibit similarities mainly historical reasons 
products expressed naturally value view slc directly adopt simple traditional way write categorical projections theta theta projection transforms value type theta value type selection pair 
similarly functions write mediating morphism hf gi theta value reasoning notation clear function hf gi constructs pair values extracted projection 
consider coproducts terms continuations injection transforms request request request coproduct type really pair requests satisfied selection continuations 
slc selection aspect explicit syntax fa bg fa bg curly braces clarity emphasize fact definition expressed terms values continuations 
direction arrow sufficient determine meaning simple parentheses 
furthermore functions function transforms request request case function applied obtain result function fc gg terminal initial objects examine border cases products coproducts terminal initial objects 
unfortunately universally accepted way writing associated unique morphisms 
notation suggestive binary case writing empty product empty sum omitting type subscripts confusion possible 
terminal object important role programming 
languages associated explicit type usually called unit void represented empty absent argument list input procedure function output 
void misnomer type contain value may just directly expressible 
names unit synonymously 
considering empty product write unique value type unit 
type function unit ignores parameter 
important theoretical point view provides basis non strict functions 
practical languages functions type side effects value return contains information 
hand bijection typed expressions functions unit unit correspondence important higher order constructs added language pass functions 
parameterless functions called suspensions thunks obtain cbn behavior cbv language delaying evaluation 
initial object rarely manifests programming natural interpretation 
category set simply empty set type null values 
void better name taken 
unique morphism naturally written fg null interesting significance discards continuation model imperative constructs escapes jumps play central roles categorical definition slc 
correspondence accepting continuations functions null fg null fg null type function returns point call possible value return 
usually functions written purpose languages notably number control primitives standard functions exit longjmp 
return type conveniently declared null return section 
note constructs syntactic formalism products coproducts initial terminal objects associated morphisms defined cases satisfy axioms depends evaluation order language 
example slc cbv semantics true products morphisms restricted wellbehaved functions 
lisp terms mccarthy axiom car cons hold expressions evaluation may fail terminate 
fact empty products exist cbv ignoring side effects assignments may different functions type unit differing termination behavior escapes 
hand cbv slc true coproducts proper initial object presence continuation abstractions non termination 
precise problems existence uniqueness deferred chapter 
denotational semantics add structured types cbv semantics 
extend syntax permit structured expressions continuations 
introduce new syntactic domains denote structured value continuation parameters cst fg fc prim fg fy course variable may repeated pattern 
new classes valuation functions extend environment values continuations respectively env env cnt env env handle structured types need refined semantic domains 
cbv happens value part 
write domain large sum kept mind language strongly typed express definition number separate domains indexed type give semantic equations 
basic unit air theta unit denotes domain exactly proper element 
concise notation delta delta delta pair theta delta delta delta shorthand equations pair theta delta delta delta air delta delta delta 
give new valuation equations 
static typing check explicitly value correct type 
expressions get ae unit ae ae ae pair note particular pure cbv evaluate arguments tuple equation arbitrarily specifies evaluated 
example overspecification imposed continuation semantics 
fixing particular evaluation order tuple elements breaks symmetry second component prefer leave unspecified 
quite hard express properly precise way simply keep equation specify slc expressions may depend particular evaluation order tuple elements 
continuations get new equations fg aev case esac fc aev case aet aet esac note continuation denoted fg applied type correct program values type null semantic equation gives denotation case expression choices 
equations look different corresponding ones expressions 
particular problem evaluation order continuations equation 
explicitly specifying cbv strategy products coproducts expressed terms values appear quite different hood just cartesian products disjoint unions set 
symmetrical world slc think coproducts terms continuations 
equations functions unchanged 
difference parameter binding happen directly equations keep function updating notation multiple values aev 
ae aev 
ae consider parameter binding functions 
values 
ae 
val ae 
ae unit ae 
ae pair 

ae particular parameter single variable binding happens precisely 
continuation parameters obtain 
ae 
cnt ae fg 
ae ae fy 
ae 

ae structured continuations looks different value bindings cbv strategy 
summary order language proceeding higher order functions consider briefly expressive power subset slc seen 
non local values continuations language far functions syntactical abstractions passed 
body abstraction may refer values continuations abstracted outer lexical scope language block structure 
important theoretically may show subsection 
paragraphs consider general implications non locality 
non local values usually considered clear efficient way avoiding explicit function parameters just carried computation places 
example environment simple interpreter binding looking variables passively transmitted language structure access directly 
language interpreter block structured environment natural candidate 
hand non local exits commonly regarded quick dirty tricks acceptable special circumstances handling fatal errors 
programming problems naturally expressed terms continuations strong preference solutions 
consider example recursive function searches tree value returning 
clean implementation pass answer back nested recursive calls clearly redundant modified way 
searched tree non homogeneous syntax tree different parts searched different functions clarity suffers 
case non local exit answer fact natural just non local value specify element searched 
show write function section unfortunately non local exits strong connotations error languages performed powerful unstructured construct goto imperative languages call current continuation scheme 
notably ml ada exceptions essentially dynamic scope control returns statically determined point encountered handler 
practical language non local continuation considered just natural simple declarative non local value probably remains seen slc takes large step goal providing symmetrical structured statically scoped framework facility 
examples variable notation just syntactic sugar basic categorical constructs product coproduct true allowing nested function definitions possible define number morphisms expressed 
note having non local values permits define cbv semantics isomorphism ffi theta theta theta types traditional notation expressed bc case bc esac corresponds function slc arrow notation bc fab acg fab ac bc morphism defined order categorical constructs introduced far composition products 
interestingly inverse function expressed categorical term ffi gamma id theta id theta theta theta theta course expanded pure slc 
reversing arrows define morphism ffi theta theta slc function fa bcg bc ab ac fa bg ab fa cg ac ffi isomorphism different cbn evaluation strategy 
consequence general surprising property slc section 
higher order constructs removed higher order functions slc fundamentally asymmetric identification functions values calculus 
section see restore symmetrical way 
functions values continuations typed calculus distinguish conceptually functions values value values functional type applied 
slc accommodates model draws attention implicit change viewpoint permits function treated value vice versa 
symmetry dictates similar correspondence functions continuations surprisingly case 
correspondence technically simple add continuation semantics manifestation categorical interpretation slc gives rise number highly unusual sight counterintuitive properties 
important remember result obtained verified simple unambiguous way semantic equations section 
typed calculus foundation higher order functions provided fact objects types exists exponential function space object usually written correspondence values type functions slc dual relationship holds object ab correspondence functions continuations type 
computationally value type known functional closure 
continuation semantics denotes function map argument value result continuation environment final result program 
equivalently view function continuation accepting pair consisting typed value accepting continuation 
pair called context function application type written 
easiest way think context typed continuation view smalltalk object better actor hewitt 
object accepts requests messages compute function 
know request came 
want answer supply return address continuation 
slc explicit conversions syntactic classes necessary concrete syntax implied operators 
notation pf function typed value value function xf function typed continuation continuation function sense conversions coercions languages permitting integer value context real typed required 
slc coercing values entire syntactic classes permitting typed expression function type expected 
rely parsing algorithm insert coercions needed just expect real typed value real typed context coerced integer back losing precision process 
similarly unwarranted coercions change meaning slc term shall see moment 
writing slc terms parentheses need set disambiguating rules ones calculus 
extend usual syntactic conventions letting applications kinds bind stronger abstractions parsed 
abstractions kinds associate right means fc bg 
value applications associate left usual continuation applications associate right symmetry fc having coercions permits directly typed lambda term slc function 
example combinator fx gx written simply coercions explicit readable pg px qq write entirely new terms simple relation common concepts may helpful see py xf shows implicit coercions 
particular note treating continuation value passing function implies converting function value 
correspondence closure typed expressions context typed continuations expressions continuations general 
ideally coercions invertible quite case just integer real example 
functional values cbv setting problem known evaluation function part application may fail terminate number closure typed expressions strictly larger number functions corresponding type 
means convert function value back preserving meaning general reverse 
similar reason converting function context typed continuation back identity operation doing reverse order necessarily preserve meaning cbv 
treat problem rigorously chapter 
important note insisted separating functions values rule generally valid scheme adding removing redex change meaning program defining applicative order fixpoint combinator 
key point slc rule applies functions expressions 
insert coercions explicitly see reduction px xq stays suspended 
explicit coercions concrete syntax written redex specify intended meaning 
currying functional programming languages known correspondence functions product type theta curried forms 
naturally define terms higher order slc follows treat function value 
essence building functional closure value type account value free variable function body 
conversely value type apply value type morphism ap ap theta treat value parameter function applying definitions equality ap ap ffi hf ffi note purely order equation implicit coercions 
fact having single morphism ap handle functional values categorical framework see chapter 
definitions results hardly surprising symmetry slc permits define unfamiliar morphisms 
point function body contain free continuation variable 
dualize just reversing arrows definition 
coproduct returning function exists version fa bg fixed application morphism pa fg bg fa bg fa bg pa ffi ffi pa fact cbv evaluation morphism unique 
bijection functions quite striking 
particular set theoretical reasoning cardinalities look impossible singleton set working set unfamiliar category functions access continuations 
fact bijection aspect equation set theoretic intuition 
morphism id change injection tag case second inject value 
single morphism pa just shows usual element reasoning techniques indiscriminately categorical setting 
operationally equation explained fact context typed result pa includes continuation effect just case construct permits computation backtrack slightly applied 
pa return inject possible re enter case expression correct tag 
just example hood behavior invisible category 
proper way think mirror image exponentials strange noises machinery 
surprisingly central concept functions continuations return equation section 
consider simpler practical application functions analogy partial value application function add int theta int int define specialized version add add int int add argument 
dual case analogous function elog real unit real defined returning logarithm argument positive error 
continuation fail accepting unit typed value 
define function log fail elog real real return logarithm positive argument invoke continuation ail error 
denotational semantics add higher order constructs cbv language follows 
extend syntax 
pf 
xf 
stressed coercions inserted part parsing process normally appear concrete slc terms 
semantic domain add types closures contexts delta delta delta cnt ans theta cnt semantics treating functions values familiar calculus pf ae vc aev ae fv recall equation value application argument evaluated function 
significant function expression syntactic abstraction expression evaluated 
evaluation order tuple components behavior considered formally specified essential translation categorical combinators chapter 
coercions inverses 
pf ae vc ae ft suspended written redex 
similarly conversions functions continuations xf aev aev ae complete correspondence xf 
consequence cbv evaluation cbn situation reversed shall see section 
alternative evaluation strategies far considered semantics cbv evaluation 
slc equally considered cbn setting explore possibility section 
see cbv semantics mechanically inverted obtain cbn evaluation strategy change affects language 
important point moving cbn evaluation retain slc class continuations 
benefits having symmetrical syntax greater longer rely experience cbv languages 
pure cbn evaluation consider exact dual cbv evaluation call pure cbn 
subsections examine slightly modified version closer strategy lazy functional languages 
cbv values completely evaluated continuations represent rest computation 
pure cbn unevaluated part expression determines rest computation continuations contain residual code 
think values cbn functions cf 
parameterless procedures thunks algol terminology just continuations cbv conceptually functions 
continuations atomic entities values mapping continuations answers 
exchanging semantic domains cnt replacing products coproducts directly obtain cbn domains cnt ans cnt zero case cnt theta cnt pr cnt pr cnt cnt ans theta cnt domain represents basic continuation 
principle defined arbitrarily 
primitive functions semantic metalanguage calculus value transformers forced define basic ans basic domain basic values cbv 
giving denotation constants seen special kind primitive function accepts input 
note type initial top level continuation depends type expression evaluating 
problem slc expression statically typeable 
example evaluating top level expression coproduct type initial continuation case tagged pair continuations handling injects 
evaluating product typed top level expression sequentially evaluate print component pr tagged continuation second 
typical behavior lazy language infinite lists printed incrementally 
see role higher order types exchanged context typed continuation denotes function continuation accepting closure really context application 
consider semantic equations 
type environment valuation functions cbv new definitions cnt 
emphasize letters values continuations respectively 
special cases mentioned new equations exact mirror image cbv ones role expressions continuations interchanged 
surprising equations denotation coproduct accepting continuation fc just cbv want force particular consideration order alternatives restrict operation continuations interchanged 
example allow functions fy pure cbn branches case discard value just permit hy components tuple escape pure cbv 
cases result slc considered undefined 
note permit case elements misbehaves hid id legal 
usually accept cbv restriction products reasonable cbn restriction coproducts looks severe 
pure cbn coproduct quite different typical lazy programming languages 
example isomorphism just theta isomorphic cbv 
mean cnt ans cnt zero case cnt theta cnt pr cnt pr cnt cnt ans theta cnt env cnt ans cst aek cst aek val ae aek case pr aet pr aet esac aek case esac aek ae aec pf aek env ans ae cnt ae fc ae ae ae case fg ae zero ae ae aec xf ae ac env cnt ans aek aek 
ae aek 
ae aek ae aek ae fk env env 

val ae 
ae 

pr 
pr cnt env env 
ae 
cnt fg 
ae fy 
ae case 

pure cbn semantics slc pure cbn coproduct useless shall see chapter important properties crucial categorical definition slc 
fortunately define familiar coproduct strange restrictions terms subject subsections 
note cbn semantics fi conversion rule slc holds full generality fi restricted 
existence uniqueness properties products hold unconditionally 
price seen coproducts behave strangely 
get similar problems initial objects take weaknesses value counterparts cbv 
conclude noting semantics identity function composition cbn 
definitions obtain id aek ffi fy aek ae aec immediately verify identity neutral composition associative 
equation composition particularly illuminating evaluation order reversed cbv 
particular argument completely discarded 
summarize equations ffi cbv ffi cbn cbv lazy products seen pure cbn general coproducts 
define alternative coproduct operator guarantees existence uniqueness mediating morphism cases 
see price quite high 
surprisingly dual concept exists cbv consider intuition stronger 
give informal presentation rigorous treatment section 
problem pure cbv products equation hold evaluation escapes fails terminate want introduce cbn tuple cbv elements evaluated values requested projection 
lazy product friedman wise facility provided number eager programming languages form streams scheme lazy cons hope 
building concept functions values suspension effect introduce products extension changing core semantics language 
introducing new product constructs syntactic abbreviations macros expanded parsing process 
introduce suspension primitives 
scheme known delay force 
adopt names memoization effect introduces concept updateable store description 
return problem section 
recall expression function unit defined furthermore function genuine value passed argument restricted fi reduction 
call functional value kind promise explicit thunk 
correspondence motivates definition operators delay force strictly speaking need define delay special operator force defined just function application ev ev define lazy product terms original follows je ja bj second equation specifies free occurrences replaced 

respectively 
cbn lazy product fact isomorphic normal coercions functions values inverses 
having defined lazy products terms existing ones integrate directly semantics 
construct type lazy products existing semantic domains closures strict products value passed suspension carries information introduce special suspended value type define lazy pair follows sv cnt ans delta delta delta lp air sv theta sv denotation lazy tuple je ae aec aec projections slightly complicated 
want keep destructuring syntax left hand side deal syntactic classes value identifiers introduced normal abstractions denoting evaluated values representing components tuple 
distinguish syntax adding primes names get additional equation variable lookup modification environment env ide sv cnt ae sval ae particular meaning projection ja aev argued lazy products better foundation language strict ones 
variable free presentation slc chapter need old products represent strict value environment cbv able define terms lazy ones 
cbn eager coproducts return problem adding traditional coproducts pure cbn 
cbv lazy pair introduced delimited piece cbn evaluation 
delimited switch back cbv control reaches projection 
similarly cbn case construct want switch cbv evaluation argument injection tag known 
guided experience value operations introduce operators fg fg define eager coproducts cbn fja fa bg note syntax reversed cbv case prefix operator postfix 
meanings opposite sense initiates eager evaluation stops soon injection tag known 
integrate definition pure cbn semantics defining ans cnt delta delta delta theta recognize suspended continuation traditional definition function mapping values answers 
values suspensions 
semantic equation eager case ae aet aet examine continuations start evaluating value leaving choice 
special continuation variables introduced eager case abstractions get analogously value case ae ae denotation injection fja aek select continuations revert cbn evaluation 
noted new construct true coproduct 
missing uniqueness property manifests loss laziness seemingly innocent transformations involving coproducts coproduct types booleans 
usual true lazy languages just slc 
example equation holds standard eager ml general hold lazy ml fails terminate escapes result applying second projection left hand side equal second projection right hand side potentially useful optimization 
lazy languages attempt limit problems including escapes explicit constructs prevent runtime errors division zero non termination 
comparison cbv cbn tried demonstrate cbv cbn essentially dual properties 
usually seen complementary strategies 
cbn considered ideal referentially transparent maximally terminating strategy approximate cbv efficiency reasons 
special merits cbv proper coproducts seldom mentioned advantages semantic fitness unrestricted fi rule integrating continuations call cc scheme usually theoreticians 
asymmetry arises mainly usually comparing pure cbv strategy cbn eager coproducts 
furthermore calculus class continuations declarative concept dual properties appear unrelated counterexamples claims cbn unconditional superiority expressed directly manifest semantic pitfalls demonstrated example 
hand proponents cbn admit usually somewhat slower cbv risks evaluating thing twice 
note pure cbn inherently efficient cbv 
re evaluation may occur caused eager coproducts primitive functions ffi rules operating coproduct values arithmetic 
get problem add lazy products cbv 
sense particular strategy causes inefficiencies implicit changes 
cases actual implementations solution memoization prevent repeated traversals code 
introduces concept updateable store falls scope thesis 
fundamental problems adding store general side effects slc 
fact axiomatic description chapter wellsuited handling functions side effects 
technique applies interpretation notably strictness analysis determine strategy fact replaced changing meaning 
language discussed far recursive facilities computations terminate combinator expressed existing primitives type correct way 
possibly non terminating computations introduced chapter cbn necessarily terminate cbv 
consider simple scenario cbn superior cbv represents expression evaluation terminate constant expression containing 
cbn simply discard argument cbv loop forever trying evaluate anyway 
hopefully dual example obvious represents continuation terminate occur cbv proceed avoiding pit cbn evaluation needlessly attempt reduce atomic form continue 
ml terms expression raise 
loop 
standard ml avoid path prevent lazy ml exceptions similar facility terminating 
recursion iteration section consider adding general recursion fixpoints slc 
see duality values continuations recursion cbn iteration cbv 
area recursively defined types presentation somewhat informal clear best way integrate slc 
recursive functions values continuations slc typed need special operator write recursive definitions 
introduce possibility nontermination 
presents surprisingly new problems nontermination cbv viewed locally special case escaping point call difference called function looping forever jumped 
dual view holds cbn axioms chapter automatically cope 
see concept recursive function generalizes recursive values recursive continuations 
usual consider value concept cbn time 
introduce recursive values language means single operator rec intuitively want expression rec mean 
cbn definition sense evaluation proceeds inside encountered preceding evaluated reached 
form infinite structured values evaluated need 
example obtain infinite list rec type solution recursive domain equation int theta rec operator define recursive values function space recursive functions 
laziness cbn prevents excessive unfolding definition 
cbv intuitive explanation recursion terms infinite quite hold 
cbv evaluation proceeds outside require evaluating 
avoided infinite number expressions evaluated result 
general recursive values infinite lists possible pure cbv 
recursive functions course special case imposing artificial restriction rec expressions argument 
insights previous sections try express recursive function cbv continuations fact possible gives natural model 
write recursive continuations rec treat recursive function recursive context typed continuation 
implicit conversions continuations functions permit traditional recursive definitions rec theta gamma recursive functions special case recursive continuations 
fact write useful recursive continuations functions way recursive values lazy lists cbn 
continuations represent unbounded type iteration 
example consider cbn domain infinite lists integers int theta write function map integer infinite list integer rec int categorically represents morphism hid fi 
express result directly recursive value may write function rec int consider dual case 
domain solution int integer embedded finite series injection tags 
unit int isomorphic natural numbers 
write function int extract integer typed value rec fn gg int uses pure slc syntax writing case expression 
categorical terms id 
express directly recursive continuation rec fn dg int continuation accept element domain pass result continuation stripping injection tag 
essentially iterative computation shall treat formally chapter 
mutual recursion cbv works dual way cbn 
cbn define pair closure typed values project want rec 
cbv inject computational context coproduct expected recursive continuation ff gg gg ff gg object oriented view subsection think recursion sending messages oneself 
distinguish requests compute supply injection tag message constructor 
finish remarking defining recursive functions special case recursive values continuations irrelevant seen cbn values cbv continuations 
evaluation order matter definition factorial simply write rec interpreted rec cbn rec cbv 
fixpoints nontermination note cbn principal type defined section fixpoint combinator familiar normal order fix rec means having fix higher order functions equivalent rec operator 
consider definition cbv obtain general type applicative order fixpoint combinator fix rec implied coercions force functional type 
cbn fix find fixpoints functions cbv type incompatibility 
applied functions assigned functional type 
hand define cbv type fixpoint rec section show morphism equivalent power rec particular define recursive functions 
note having recursion language means type global value element poign defined follows rec values construct type correct right inverse projection categorical terms projections split epimorphisms 
define gamma theta gamma theta obtain equalities ffi gamma id ffi gamma id similarly cbv global continuation type rec injections split monomorphisms define left inverses gamma fa gamma bg properties gamma ffi id gamma ffi id operation fact common cbv languages called simply specific variant outside cases construct 
lists defined theta express head 
ffi gamma tail 
ffi gamma denotational semantics naturally denotations recursive values recursive continuations terms semantic fixpoint 
equations fact simple permit variable patterns rec 
add recursive continuations cbv follows rec aev fix 
ae recursive values cbn rec aek fix 
ae allow define recursive functions 
quite instructive see cbv works find denotation factorial function expressed terms recursive continuations 
simplicity assume available usual semantic equation 
section show defined continuation abstraction slc 
semantic equations directly obtain rec xn theta gamma aev delta delta delta fix gamma theta shows evaluation proceeds iteration contexts 
starts original input value result continuations treats recursive call pass loop denoted new context value part decremented multiplication added continuation 
implementational terms corresponds exactly adding activation frames stack close view recursion hewitt 
complete description slc type system mentioned earlier slc simple static type system encompasses values continuations 
concise notation obtained decorating syntax grammar type symbols 
subscripts represent output result types superscripts denote input entry types 
example ff fi denotes continuation accepting value type ff fi 
symmetry reasons emphasize distinction functions elements neutral notation oe function domain oe codomain reserve arrow notation closure typed expressions context typed continuations 
usual scope rules calculus apply abstraction body may contain variables kinds bound outer lexical level 
note variables occur left side abstraction formal parameters behave differently value variables denote inputs function continuation variables denote outputs 
rules describe simple system type variable rules instantiated concrete type ground term polymorphic type function identity contain free type variables ml 
fact results obtained damas milner carried directly concept general principal type 
example easily verified expression fc gg expressing coproduct morphism constructor constant principal type theta free 
simpler view definitions examples 
typing relation read semantic equations valid polymorphic types 
explicitly parameterized types considered functions natural transformations complicates concepts somewhat directly affecting evaluation aspects termination properties 
main problems type system concern recursive types adding extensions resolving aspect dangerous 
cst oe oe unit ff ff fi oe oe oe oe oe unit ff ff fi oe oe oe null fg ff fi fc ff fi oe oe oe oe oe oe oe null fg ff fi fy ff fi syntax type system slc denotational semantics gives semantic domains equations cbv version slc syntax 
basic unit air theta cnt ans theta cnt cnt ans env ide 
cnt env cnt ans cst ae cst ae val ae ae ae ae pair ae unit ae ae aev pf ae vc env ans aev cnt ae fc aev case aet aet esac fg aev case esac aev aev aet xf aev env cnt ans aev pv aev 
ae aev 
ae aev ae fv aev ae env env 
ae 
val ae 
ae unit ae 
ae pair 

ae cnt env env 
ae 
cnt ae fg 
ae ae fy 
ae 

ae cbv semantics slc chapter symmetric combinatory logic chapter concerns categorical aspects slc 
chapter referred purely categorical concepts products presentation slc fundamentally element categorical interpretation assigned fundamental concepts expressions continuations functions 
start pointing slc concepts integrated properly categorical interpretation structure imposes category 
defined number categorical constructs slc terms id ffi hf gi chapter show fact express entire slc terms combinators terms free variables 
principle analogous traditional combinatory logic combinators fx gx xy strictly necessary sufficient express calculus term 
ski system inherently higher order handle structured data 
immediate similarity provided categorical combinatory logic ccl curien builds equivalence calculus products cartesian closed categories precisely monoids 
closer spirit ccl handle coproducts escapes 
need additional combinators express call resulting system symmetric combinatory logic scl 
translation combinators eliminates somewhat complex concepts abstraction substitution flow control data explicit scl 
permits give strategy independent axiomatic presentation language denotational chapter 
treat cbv restrictions products simple formal way precise concepts evaluation order lazy products 
consider categorical terms new programming language give traditional denotational semantics 
continuation environment compiled away 
fact view factorization original semantics passing intermediate code combinator language 
categorical view slc section demonstrate slc treated purely categorical terms 
informal presentation particular consider restrictions particular evaluation strategy may put existence uniqueness properties products exponentials treat aspects formally section give exact translations slc scl sections 
functions values continuations start recalling section treat slc types objects category functions morphisms 
values continuations assigned categorical interpretation treated intuitively elements requests elements various types 
approach chosen order explain slc terms traditional values programming language constructs concepts directly related denotational semantics 
section morphism view slc core concepts abstraction application applying values continuations 
usual start familiar value side 
natural view expressions degenerate functions information carrying inputs point application 
expression type thought morphism 
morphism 
view value application corresponds simply morphism composition function denotes morphism expression type morphism expression denotes morphism ffi dual case analogous 
continuation seen slc ended function accepts input return point application 
express viewing typed continuation morphism 
set morphisms type concept escaping 
continuation application corresponds composition accepting continuation denoting morphism function represents morphism accepting continuation denotes morphism ffi 
value continuation abstractions complicated adjoining indeterminate arrows denoted variable symbols category 
see expression morphism symbol occurs typed value determines unique free morphism xe xe similarly continuation morphism expressed terms continuation variable defines categorical morphism yc yc important property known functional completeness subject section 
structured types mentioned section structured types slc directly categorical concepts 
showed categorical constructs projections mediating morphisms expressed slc 
see reverse translations equally simple 
products expressions denote morphisms respectively expression theta denotes precisely morphism theta similarly continuations denoting morphisms accepting continuation fc corresponds exactly morphism 
variable pattern syntax destructuring abstractions simple categorical interpretation 
see simply shorthand explicit projections injections free occurrences replaced projections value parameter nested patterns correspond longer sequences projections 
similarly intuitively continuation patterns left side correspond explicit injections body abstraction fa bg fy fy destructuring syntax slc avoid need predefined functions 
emphasizes symmetry products coproducts dualizing common notation functions product functions coproduct 
treatment terminal initial objects simpler 
typed expression denotes morphism just id 
analogously typed continuation fg denotes morphism id 
empty variable patterns trivial 
fact expression function denote exactly morphism 
analogously typed continuation function fg equivalent 
note interpretations confused coercions mentioned section 
result coercing expression function different function 
remarked section having just products coproducts quite express order slc term categorical combinators 
handle non local variables appearing inside morphism constructors need additional combinators 
fact just distributive law morphisms ffi ffi section sufficient show section 
adopt ffi ffi primitive combinators defined terms higher order constructs introduce higher order features categorical view functions arrows objects clear handle higher order functions properly 
key provided coercions section views values continuations morphisms respectively 
naively want correspondence functions values type morphisms pf similarly correspondence functions typed continuations categorical interpretation coercions xf bijections describe closure context objects solely terms morphisms internal structure precisely want 
order handle free variables function body need slightly general versions 
functional values properties cartesian closed category bijection morphisms curried forms theta express existence right adjoint product functor 
special case gives original bijection isomorphisms theta idi theta general version dual case gives bijection morphisms coproduct versions equivalently require existence left adjoint coproduct functor 
bridge back original case isomorphisms id unfortunately slc higher order functions expressive category described possible non local continuations value abstractions vice versa 
handle need special morphisms similar distributive laws products coproducts defer details section 
scl category axioms section gives formal specification scl category objects morphisms axioms 
particular treat properly existence uniqueness problems ignored section 
need category fair amount structure number distinguished objects morphisms function products exponentials projections traditional names notation remembered associated axioms somewhat weaker usual ones quantify behaved morphisms 
fact category obeyed axioms full generality collapse boolean algebra recursion added inconsistent 
objects include basic types integers booleans 
addition designated initial object terminal object 
furthermore pair objects exist specific product theta coproduct exponential object 
morphisms consists primitive functions morphisms derived categorical constructs injections curried forms furthermore type category include denumerable set value continuation variables corresponding free variables slc terms 
slc constants thought primitive functions global value variables 
choice axioms delicate 
weak allow imperfections cbv products give problems recursion added 
hand strong prove possible particular functional completeness category 
motivate section summarized 
axioms look strange 
important question real scl category exists looks 
affirmative answer question possibility denotational semantics section 
totality strictness axioms formalize concept behaved morphisms 
basically precisely ones respect designated initial terminal objects category definition morphism called strict ffi total ffi names familiar terms slightly different meanings 
convey essence definition intuitively understandable way regarded precise technical terms 
total morphism essentially produces output strict consumes input 
note slightly stronger usual definition strictness morphism denoted necessarily strict definition precisely evaluate morphism total strict depends definition slc scl term evaluation strategy 
example cbv functions ones evaluate arguments strict 
direct consequence fi rule ffi ffi fg fg 
surprisingly functions considered total cbn ffi ffi 
precise key concepts slc definition value type total morphism semantic continuation type strict morphism 
core axioms course usual axioms category neutrality identity associativity composition satisfied morphisms badly behaved ones 
identity naturally total strict definition composition total strict morphisms total strict 
axioms specific scl 
restrictive 
key keep axiom system symmetrical axiom dual hold 
apart aesthetic considerations reduce proving subsequent theorems half result immediately 
continuation axioms somewhat counterintuitive cbn experience cbv develop 
value axioms remember duals hold 
consider terminal object 
require morphisms unique certainly unique total morphisms 
leads axiom id shall see section prove general case 
products complicated 
start requiring total strict hf gi 
cbv expect ffi hf gi behaved 
total able project away 
motivates axioms ffi hf gi total ffi hf gi total general uniqueness ffif ffif 
uniqueness total 
codify essence axiom similar terminal object id able compose hf gi morphisms 
want interleave evaluation total morphisms 
leads axioms hf gi ffi hf ffi ffi hi total theta ffi hf gi hh ffi ffi gi total see satisfactory handling products scl required axioms usual 
precisely weaker properties proven strong axioms asserted explicitly 
higher order axioms higher order facilities scl exponentials currying 
relevant value axioms subsection 
consider totality strictness properties involved morphisms 
total necessarily strict cbn function evaluate hand ap strict argument result ap needed evaluate input 
necessarily total applying closure escaping function 
values problem existence curried adopt ccc axiom full generality ap ffi theta id recall notation theta id abbreviation hf ffi hand uniqueness curried form guaranteed may different functions satisfying equation 
true cbv type language runtime errors escapes uncurried forms ml functions fn fn fn fn indistinguishable compute function oe behave differently fail applied zero second original form 
demand uniqueness functions total ones 
leads weakened axiom ap ffi hg ffi total ideally finished 
order express slc function need special morphism mediate values continuations 
express number equivalent ways take form simplifies presentations oe theta theta satisfy axioms oe ffi hf ffi idi pa ffi hf ffi idi ffi ffi oe ffi see similar require distributive law ffi plausible fact ffi oe instances general schema id ffi hf gi theta theta theta theta ap theta pa oe theta theta scl morphisms investigated 
just distributive law morphism direction expressed existing combinators oe gamma ffi pa ffi theta theta general inverse cbv evaluation 
summary morphisms axioms summarize morphisms scl specifies type system 
axioms collected section 
equations represents total morphism strict 
derived equalities section presents number derived laws 
state prove value part 
lemma total proof id ffi ffi lemma theta total ffi ffi proof id ffi ffi ffi ffi lemma ap ffi hf ffi hi ffi hg hi 
proof ap ffi hf ffi hi ap ffi theta id ffi hg hi ffi hg hi 
lemma total ffi ffi theta id total id ffi ht oe pa strict id ffi ht oe ap id ffi hf ti ffi ht gi id hf gi ffi hf ffi ffi ti theta ffi hf gi ht ffi ffi gi ap ffi theta id ap ffi theta id oe ffi hf ffi idi pa ffi hf ffi idi ffi ffi oe ffi id ffi ffi id ffi ffi ffi ffi ffi ffi id ffi pa id ffi pa ffi id ffi ffi id ffi ap ffi ffi ffi scl axioms proof ffi ap ffi ffi theta id ap ffi hh ffi ffi ffi hk ffi ffi theta id lemma total hf ffi gi hf ffi idi ffi equation holds trivially total 
proof depends centrally fact projections total hf ffi gi hf ffi ffi ffi hid gi hf ffi ffi ffi hid gi hf ffi idi ffi ffi hid gi hf ffi idi ffi lemma strict ffi ap ffi ffi ap ffi ffi ffi ffi proof ffi ap ffi ffi ap ffi ffi ap ffi ffi ffi ap ffi ffi ap ffi ffi ap ffi ffi ap ffi ffi ap ffi ffi ap ffi ffi ap ffi theta id ffi ap ffi theta id ffi ap ffi ffi ffi ffi id ffi hf gi ap oe fc id ffi fg fg fy fa bg fa bg fa bg pa fg bg fy pg fy cg translation scl slc translation scl slc chapter demonstrated categorical constructs products exponentials naturally expressed slc terms 
formalize idea giving translation scl morphism equivalent slc function 
naturally variables introduced rules capture free variables categorical term 
note identity composition exactly equivalent translations value continuation abstractions 
translations primitive functions demonstrate conversion rules slc 
complicated part consists translations oe 
idea oe adds value context extracts continuation closure 
translation slc scl result reasonably straightforward inverse translation somewhat complicated 
reasonably simple translation scheme demonstrate idea practice produces large scl terms usually simplified considerably just naive ski abstraction algorithm calculus 
main difference slc scl variable bindings 
able express value continuation abstractions scl combinators 
possible central theorem theorem functional completeness morphism expressed terms typed value variable exists unique morphism theta containing ffi hx ffi idi dually variable exists unique morphism ffi id ffi proof detailed verifications verbose simple principle 
fact ccc results lambek scott carried directly verifying weaker forms axioms 
scl axioms symmetrical results dualize immediately continuation abstractions 
define number auxiliary morphisms expressing associativity commutativity distributivity products coproducts ff ffi ffi ii theta theta theta theta ff ffi ffi 
fl theta theta fl ffi ap ffi ffi fl ffi fl theta id ffi fl theta 
theta theta ffi fl ffi fl ffi fl ffi id ffi pa theta theta isomorphisms scl category conceptually trivial 
ffi ffi hand require 
verify properties need ffi lemma ffi ffi hf ffi idi hf ffi idi hf ffi idi total 
proof ffi ffi hf ffi idi ap ffi ffi fl ffi fl ffi ffi fl ffi hf ffi idi ap ffi ffi fl ffi fl ffi ap ffi hid ffi ffi ffi fl ffi fl ap ffi hid ffi ffi ffi fl ap ffi hid ffi ffi ffi fl ap ffi ffi fl ffi ap ffi ffi fl ffi ffi fl ffi hid ffi ffi fl ffi hid ffi hf ffi idi hf ffi idi lemma ffi ffi proof ffi ffi ffi ap ffi ffi fl ffi fl ffi ffi fl ap ffi ffi ffi fl ffi ffi fl ffi ap ffi ffi ffi fl ffi ffi fl ffi ap ffi ffi ffi ffi ap ffi ffi ffi ffi ffi ffi ap ffi ffi ffi ffi ap ffi ffi ffi ap ffi ffi ffi define abstraction rules 
rules overlapping occur complex term equations applicable show really definition rules determine unique result 
structural induction 
base case trivial simple term contain ffi ffi ffi hf gi hf ffi ffi ffi ff ffi oe ffi ffi ffi hf gi ffi ffi hf ffi ff ffi abstraction rules rule applies 
possibility composite term get ffi ffi ffi ffi ffi ffi ffi ffi hf gi hf gi hf hf ffi ffi hf gi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ff ffi ffi ff ffi ffi ffi ffi oe ffi ffi oe ffi show ffi hx ffi idi structural induction ffi hx ffi idi ffi hx ffi idi ffi ffi id ffi hx ffi idi ffi ffi hx ffi idi ffi ffi hx ffi idi ffi ffi hx ffi idi ffi ffi hx ffi idi ffi hx ffi ffi hx ffi gi ffi hx ffi idi ffi ffi hf gi ffi hx ffi idi hf ffi hx ffi idi hf ffi hx ffi idi ffi hx ffi hf gi ffi hx ffi idi ffi ffi ffi hx ffi idi ffi ffi hx ffi idi ffi hx ffi idi ffi hx ffi idi ffi hx ffi idi ffi hx ffi idi ffi ff ffi hx ffi idi ffi ff ffi hhx ffi idi ffi ffi hx ffi ffi ii ffi hx ffi idi ffi hx ffi idi ffi oe ffi hx ffi idi ffi pa ffi hx ffi idi id ffi pa ffi hx ffi idi ffi hx ffi idi prove uniqueness free morphism ffi hx ffi idi show ffi hx ffi idi ffi hx ffi idi ffi ffi ffi id ii ffi hx ffi ffi ffi ffi ffi reap fruits ffi pf ffi ffi hid ap ffi ffi idi ffi ffi ff fg fc ffi xf ffi id ffi ffi id ffi pa fg ffi fy ff ffi translation slc scl corollary morphism containing value variable exists unique morphism xe free xe ffi similarly morphism continuation variable exists unique free yc ffi yc proof set xe ffi hid 
xe ffi ffi hid ffi ffi hx ffi id ffi hx ffi idi gave existence 
uniqueness assume ffi ffi ffi ffi hid ffi ffi hid ffi ffi hid ffi hid xe 
analogously yc id ffi result possible give full translation slc terms morphisms scl function expression continuation denotes unique respectively 
equations 
functional completeness theorem expressed terms single variable pattern variables time 
practice abstraction algorithm easily generalized handle variable patterns directly 
scl slc conversion rules see scl really models slc 
state definitions theorems value side continuation results analogous 
definition categorical term possibly containing value variable value total morphism 
define term occurrences replaced 
concept free occurrence scl explicit abstraction constructs 
lemma substitution preserves equality scl terms 
proof structural induction proof substituting total strict morphism restrictions axioms fulfilled proof goes unmodified 
see translation rules commute slc substitution definition slc term value variable expression define term free occurrences replaced implicit renaming captured variables 
lemma slc term value variable total expression 
denotes appropriate translation function proof assume bound variables renamed collide variables proceed structural induction non trivial cases directly involving value variables ffi hid ffi hid ffi hid ffi hid ffi hid definition categorical term variable pattern value define single variable inductively ffi ffi allows state general form functional completeness theorem theorem morphism variable pattern morphism theta unique morphism containing variable property ffi ffi idi 
translates scl term built variables 
proof structural induction base case precisely functional completeness theorem possibilities verify existence part theorem ffi ffi idi ffi ffi idi ffi ffi idi ffi ff ffi hhe ffi idi ffi ff ffi hhe ffi ffi idi ffi ffi idi ffi ffi idi ffi ffi idi uniqueness assume ffi ffi idi case analysis gives ffi ffi idi ffi ffi idi ffi ffi idi ffi ffi ffi ffi ffi idi ffi hhe ffi idi ffi ff ffi hhe ffi ffi idi ffi ff ffi ff gamma ffi ffi ffi ffi ff ffi ff gamma ffi ffi idi ffi ffi idi ffi ff ffi ff gamma ffi ffi idi ffi ff ffi ff gamma ffi ff define generalized substitution slc follows definition slc term value variable pattern expression structure define single variable inductively lemma slc term value variable pattern shaped total expression holds 
proof induction structure treated base case remaining possibilities check ffi ffi ffi ffi verify slc fi reduction modeled properly th scl theorem structured expression denotes value total 
proof ffi hid ffi ffi ffi check conversion preserved theorem slc function occur free 
proof ffi hid ffi ffi hid ffi ffi hid ffi ffi ffi hid ffi ffi hid identity composition rules preserved course follows directly equations 
things results justify casual mixing styles categorical morphisms morphism constructors slc functions value continuation abstractions scl morphisms 
instance mixed term theta seen abbreviating slc function scl morphism ap ffi ff evaluation strategies return subject evaluation strategies 
slc chapter saw parameterless value abstractions implement lazy products cbv parameterless continuation abstractions gave eager coproducts cbn 
treat rigorously 
cbv cbn scl definition cbv scl category satisfies scl axioms furthermore proper initial object fact morphism 
similarly cbn scl category scl category proper terminal object unique 
immediately note cbv strategy morphisms strict cbn strategy total definitions total strict definition 
means cbn scl category fact proper ccc axioms holding generally substitution theorem section applies unrestricted fi reduction 
addition usual ccc types cbn category weak coproduct bicartesian closed category lazy languages recursion 
hand probably surprising continuation axioms hold restriction cbv 
particular full existence uniqueness axioms 
demonstrates strategy ffi isomorphism radically different set 
fact called cartesian closed proper initial object binary coproducts true products exponentials 
strategy specification added axioms scl inherited slc translations 
consider example slc function ffi continuation constant variable outer scope 
definitions composition slc translation morphism ffi ffi ffi cbn strategy terminal object equivalent ffi cbv initial ffi see opposite strategy products eager coproducts section correspond scl lazy products cbv borrowing notation domain theory define lifted object 
natural morphism lifted object back original ev ap ffi hid 
cbn fact isomorphism 
cbv 
contains values corresponding non total morphisms furthermore morphism define lazy version ffi properties gamma total 
special case get inclusion 
id 
ev ffi ap ffi hid ffi ffi ap ffi ffi ffi ffi hid possible definition lazy products terms old 
objects define object omega 
theta 
unfortunate reversal notation omega usually smash product 
eager product theta fundamental cbv simpler symbol 
define morphisms ev ffi omega ev ffi omega hf gi hf omega see immediately ffi hf gi ev ffi ffi hf ev ffi ffi hf gi ev ffi ffi hf ev ffi unfortunately ffi ffi fi non total worse projections longer total 
functional completeness category relies heavily lemma abstracting variables function composition 
lazy products function ffi ffi total way evaluate result discarded 
omega isomorphic eager coproducts cbn consider cbn eager coproducts 
recall fact usual coproducts evaluate argument case construct tag known 
object define lowered evaluation morphism fg id ffi pa isomorphism cbv 
define fg ffi strict morphism ffi ffi ffi id ffi pa ffi ffi pa id ffi ffi immediately write definition eager coproducts phi ffi phi ffi phi phi desired properties ffi ffi expect new injections strict 
things means lose functional completeness isomorphism hand eager coproducts define number useful datatypes bool phi nat phi nat functions operating language external primitives 
iteration recursion consider iteration recursion categorical setting 
known poign adding fixpoints sufficiently powerful category ccc proper initial object inconsistent isomorphic trivial object category axioms scl weak problem 
example cbn scl full ccc restriction need unique strict morphisms prevents construction isomorphism 
repetition operators consider pure cbv cbn simplicity 
operator presentation similar poign notation slightly different 
particular subscript denote iteration consistency coproduct operators 
principal idea repeatable function determines recursive value cbn recursive continuation cbv 
functional continuations need general formulation handle free variables 
change consider coproduct case cbv morphism 
intuitively maps value type value type type result type apply obtain typed result 
call iterated function note returns second inject return 
point called just non total function 
formally morphism require existence morphism id ffi id ffi ffi note equation general solutions id satisfies 
second equation eliminate solutions ensuring terminates returns inject 
dually consider cbn morphism theta defines output terms seek morphism defining terms 
dualizing axioms obtain ffi hid ffi theta id ffi fixpoint morphisms operators previous subsection gave purely categorical view iteration recursion 
really want introduce new morphism constructors know value continuation variables 
fortunately necessary define single morphisms effect cartesian closedness category 
consider value cbn case time probably familiar 
assume recursion operator gamma start defining instance ap theta fix ap function theta curried version 
means define fix ffi immediately get cbn morphisms total fix ffi ap ffi ap ffi hid ap ffi ap ffi hf fix ffi ffi hid fix ffi ffi hid ffi theta id fix ffi ffi theta id fix ffi ffi ffi satisfies axioms expressed terms existing morphism constructors single morphism fix existing abstraction rules apply functional completeness theorem holds 
return coproduct iteration case cbv see permit write iterative definitions single morphism 
function unique version immediately suggests defining morphism pa iterated version ffi recursion immediately verify satisfies equations back values continuations usual interpret definitions slc function fix express recursive values recursive continuations 
slc define global values continuations type fixpoints strict total functions respectively fix id fix ffi id ffi note uniqueness arrows cbn cbv respectively get id cbn id fg cbv motivates definitions fg runtime errors cbn cbv respectively 
shows scl definition strictness conflict usual considering strict cbn 
extend equivalence slc scl recursive case giving translation rules 
consider definitions recursion scl instructive see translations 
translation scl slc fix rec rec rec rec fb ag direction get rec ffi fl fix ffi ffi rec fl ffi ffi ffi handles mutually recursive definitions 
mentioned second translation terms fix preferable know value continuation variables 
categorical denotational semantics section cbv denotational semantics categorical terms 
basically slightly modified version cbv slc semantics section environment eliminated 
equivalent translations section 
syntax type system semantic domains equations 
note valuation function morphisms 
see semantics model scl category objects types morphisms equivalence classes terms factored equations 
easily checked semantics satisfies axioms required scl category 
fact continuation axioms coproduct hold full generality morphisms strict 
close connection semantics kleisli category lambek scott moggi triple ans ans tc fa ac ca pc tc 
particular composition morphisms ffi ffi identity morphism kleisli category 
known kleisli category initial object category resolutions triple 
terminal object eilenberg moore category strongly connected cbn evaluation 
bas unit pair theta cnt ans theta cnt cnt ans cnt ans val ae init cnt ae init pv id ffi unit hf gi pair pair pair case esac case esac bc pair ap pair fa oe pair pair case cs esac pa ac fa case cs esac cbv semantics scl chapter applications examples chapter consider applications framework reasoning categorically continuations 
results fall classes 
number applications slc scl method expressing describing various programming constructs 
secondly importantly may consider broader implications value continuation symmetry suggesting entirely new concepts constructs duals existing ones 
section extending slc real programming language practical applications 
compare existing language concepts slc ones 
give number small programming examples 
come late notational conventions earlier sections 
compare similar programs languages introduce relevant facilities 
compare slc scl approach related suggest directions research 
symmetric programming language slc quite terse unfit larger programming task just program seriously pure calculus 
section consider extensions real programming language readable ml syntax keeping symmetrical features 
see notation introduced simply syntactic sugar underlying slc concepts 
building slc try extend scl practical combinator language similar apl iverson fp backus cpl hagino 
scl constructs concise clear corresponding slc terms better suited formal reasoning 
experience shown usually easier understand larger slc terms scl ones particularly higher order functions involved variable names easier follow long distances nested combinators 
extensions slc needed precisely handle larger programs completely variable free approach impractical 
certainly keep scl combinators introduce new ones common patterns goal eliminate uses slc value continuation abstractions remain part language core 
notation theoretically trivial practically important problem 
write slc scl terms normal ascii system need conventions 
considerations relate model implementation slc appendix slc characters commonly available 
symmetric characters left pick basically random model implementation uses 
better choice usually variable names readability 
symbols directly replaced 
may preferable concise notation abstractions ml fn 
simplify parsing 
scl terms special symbols situation worse 
pair case constructs common probably reasonable symbols express 
extends perfectly morphisms associated initial terminal morphisms 
respectively 
hand currying recursion relatively uncommon natural introduce keywords suitable names various greek letters projections labelled datatypes worst readability problems slc come having unlabelled products coproducts unrelated pieces data hard distinguish 
practical purposes having binary nullary products coproducts inconvenient 
easily introduce arbitrary labelled products records fields type rr 
variants type vv fv build types binary primitives slc probably natural add arbitrary finite products coproducts directly 
labels just notational convenience may influence type checking execution 
expressions type rr written continuations type vv fv syntax patterns 
fv furthermore allow field variant tags projections injections writing simply abbreviation value abstraction 

call functions constructors coproducts destructors products 
constructors injections total abbreviate unit typed variants treating constants unit accepting functions writing type color fred green fred unit green unit blue 
course definition sense eager coproducts 
similarly destructors projections strict abbreviate null typed fields records omitting null declarations 
note record null typed field isomorphic just null strict products different lazy products cbn 
labelled syntax extends naturally recursive types type defined appear defining term 
injections projections isomorphisms type defining type expression datatype ml hagino 
course mix labelled unlabelled types convenient 
example define type binary trees integer leaves follows type leaf int node theta possibility allow labelled types permit positional association ada type triple int bool int expressions denoting value true true true allow parameterized polymorphic types tree way analogous ml 
binding primitives obvious binding extension expression 
define follows handles destructuring respect polymorphic type inference system definition may restrictive cf peyton jones sect 
problem specific slc 
course provide analogous definition facility continuations simultaneous definitions problem similarly introduce recursive definitions rec rec implicit abstractions extensions apply 
common pattern consists applying continuation abstraction value vice versa 
syntax fa bg injects inject denotes continuation pass copies input matter taste readable slc arrows 
control primitives eager coproducts define familiar case expression case esac course labelled coproducts constructor selection expand scl notation gamma gamma slc express binding constructs previous section fr similarly lazy products define continuation pair fy fy hy dispatches element product wants evaluate 
extension labelled products immediate 
natural extend constructs general pattern matching ml probably require patterns exhaustive non overlapping order give direct translation slc 
top level evaluation symmetrical language may fundamental asymmetry evaluating top level expressions 
section consider practical extensions correspond slc concept probably essential practical language 
example include command def semantics evaluated initial environment variables bound result 
recursive top level definitions easily added def rec def rec note works cbv language recursive functions defined recursive continuations coercions 
permit pattern matching syntax function definitions express functions hf gi pure ascii syntax change def fx def pr gx pr asymmetric extensions include number conventional asymmetric constructs dualize nicely conditionals 
data types lists booleans commonly duals may worth defining special syntax 
define type bool semantically equivalent unit unit unit phi unit cbn 
labelling section write simply type bool ftrue falseg conditional expression special case case case true false esac define operator bool theta bool bool evaluate second argument true follows ft fg ft ft fg definition explicit flow control bool expecting result continuation captured ft fg 
operand evaluated success continuation true return immediately true failure continuation ft fg 
continuation discards unit typed false result evaluates original continuation ft fg result result give definition ft fg fft fg fg course dual definition slc sense 
recall duals category propositions 
slc bool returning operators get kind symmetry exhibited arrow reversal kind 
main reason introducing booleans place relation toposes subobject classifier omega plays role similar bool right conditions case omega 
toposes connections type theory appear related programming language design agree symmetrical world slc scl 
interesting see exists symmetrical approach fundamental concept equality comparison operator theta bool equalizers coequalizers 
restrictions despite goal symmetry obvious having full power slc really desirable practical language 
example lazy coproducts pure cbn theoretically analogous ordinary eager products cbv quite counterintuitive 
may reasonable eager coproducts subject language price losing functional completeness 
number concepts inverse fixpoint idea may weird include directly 
slc valuable starting point task pointing continuations play fundamental role language definition restrictions cut symmetrical pieces language 
language includes forms construct products coproducts symmetrical clearly related syntax concepts modularity inheritance apply 
slc scl metalanguages section see imperative constructs programming languages expressed slc conversely various slc primitive concepts latent existing languages 
oddly old languages appear symmetrical newer ones 
fact modern functional languages asymmetrical 
goto goto statement probably single criticized programming language construct dijkstra cause 
rush eliminate possible number innocent applications suffered 
subsection consider jumps related constructs slc viewpoint try separate imperative aspects basically declarative ones 
control flow languages command expression involving centrally concept store correspondence perfect 
mention slc view tail calls concept intuitively connected jumps 
note useful distinguish kinds goto forwards backwards 
basically forwards goto involve looping destination need appear textually jump sequential execution reach jumping instruction 
backwards goto adequately superseded structured constructs single construct capture full essence forwards goto 
shall consider forwards goto conceptually simpler return backwards goto subsection 
goto prototypical jumping construct languages include number semi structured escaping primitives usually names exit return break 
refer collectively simply jumps 
idea jump effect transfer control away sequence statements appears 
basically consists discarding current continuation substituting new operation expressed directly slc continuation abstraction 
important keep mind slc continuations embody concept discarding inherently sided just values usually treat values functions ignoring value passed 
want behavior write explicitly similarly really want discard continuation install write really imperative throwing away value 
implicit discarding old continuation imperative essence jumps installation new shall return subsection 
implicit merging operation jumps emphasized slc 
reach label normally executing sequence statements preceding textually exceptionally jumping 
similarly exit loop procedure simply reaching bottom sequentially fulfilling exit condition loop escaping construct 
destination jump usually apparent ways control reached 
slc expresses untagged duplication continuation fa ag explicitly discards information control reached point 
style 

corresponds precisely normal abnormal entry label 
note slc expression redex occur body 
redex mirrors eliminable sequence goto 

order slc fundamentally block oriented language 
referring non local continuations corresponds non local gotos block structured languages algol naur pascal jensen wirth ada ansi 
implementation non local gotos usually quite simple system handling non local values display static links exists 
true functions procedures downward formal parameters 
hand upward returned functions give problems values continuations stack allocated activation record context referred non local variable may longer exist name returned scope 
return section 
tail recursive calls referred goto value little misleading discarded traditional goto 
suppression adding identity operation representation continuation control stack tree 
may cause confusion assembly language declarative instruction sequence call return abbreviated imperative jump 
remember assembly language inherently higher order framework return addresses treated values 
cbv evaluation traditional architectures function fact naturally seen continuation accepting pairs argument value return address 
continuation return possibly executing halt instruction transfer control continuation designated context received 
framework tail calls correspond passing received context continuation part callee building new effect 
precisely model functions low level optimization completely declarative goto functional programming language 
serious problem original goto close connection repetition 
label declaration involves fixpoint may referred statement sequence appears preceding part 
encourages spaghetti code loops properly nested 
result sloppy programming basic structure algorithm really best expressed states automaton 
known pieces code rewritten single case original goto labels case selectors 
replaces intermixed fixpoints single coproduct construct case statement corresponds exactly mutually recursive continuations slc construct rec fc jumps type system traditionally jumping primitives considered part control structure programming language independent typing aspects 
close coupling continuations type system slc framework possible reason precisely type constructs 
discussion applies languages strongly typed scheme rees clinger way considerations types values meaningful language enforce statically 
finish subsection moderate compared class continuations suggestion new language designs 
slc computation patterns abstracted functions value continuation abstractions 
naturally jumping constructs defined continuation abstractions 
function types associated domain input codomain output 
consider input type jumping constructs simpler 
usually dealt properly typed languages 
input type jump information transfer source jump destination 
jumping constructs command languages algol pass data directly jump domain domain source type goto unit 
data transferred stored auxiliary variable 
reason labels appear statements expressions 
command languages information transferring jumps 
obvious example return statement ada transfers control innermost enclosing function body 
non void function takes argument returned point call result function 
setjmp longjmp facility transfer value 
remarkably enforces distinction normal exceptional returns setjmp returns zero non zero value 
hand jumps expression languages usually encourage transfer information operator 
examples ml exceptions scheme call cc return sections 
languages pseudo tail call calls function parameters body chain pop 
discards rest function body invoking called function return continuation calling may continuation point call 
output type jumping constructs problematic 
appear imperative languages type jumping behavior explicit 
apparent jumping construct function procedure 
example non local exits exit longjmp look just function calls 
pascal implementations avoid introducing new reserved words escapes return standard procedures 
type problems affects command jumps goto syntax sequential statements assignments procedure calls escaping ones discard current continuation 
look imperative behave differently 
example languages perfectly correct write sequence goto lab statement unreachable 
code usually represents mistake fact language style checker lint give warning 
slc formalism view usage goto type error 
note treat statement function unit unit acting function composition reverse order ffi 
applies procedure calls arguments arguments expressions functions unit application corresponds composition entire statement type unit unit components may 
fact lint complain call non void returning function printf appearing statement list 
explicitly discard returned status value called void printf 
see goto fits 
see function return type unit null 
different function expected return fails need provide return address 
type goto composable left goto function unit null goto type error feed null typed output goto unit expecting 
composition type correct insert function 
exist functions corresponds cast void terminology done implicitly languages goto appears normal statement 
solution expressed lint command changes unit accepting sequence zero accepting 
programming languages recognize concept null type values 
explicit distinction pascal function procedure acceptable function languages ml special named type natural 
functions return exec system call unix properly declared null returning inaccurate unit void 
apart aiding reader code specifying behavior help compiler detect problems unreachable statements longjmp 
propagation jumping behavior automatic function calls return type express 
null type implementational significance unit accepting functions input value passed carry information 
similarly null returning function needs return address entered jump 
apart efficient possible express type system group functions call tail recursively stack growth compiler detect violations pattern automatically 
multiple returns label types fundamental primitive slc continuation pattern syntax continuation abstractions definition injections fa bg selection construct number languages alternate returns function procedure 
example fortran ansi subroutine called list line labels extra arguments 
body called subroutine alternate return invoked return number alternate exit 
purpose course abbreviate call return patterns 
call goto normal return 
subroutine 
return simply 
call normal return 
subroutine 
return 
mechanism handle errors statements read err jump line file line errors 
similar feature algol labels appear explicitly named procedure parameters procedure 
label 
goto 
invoked 

lab lab 
lab 
goto body transfer control label lab 
value label type similar slc continuation labels unit typed 
languages label types dropped probably partly effect easily simulated procedural parameters procedure 
pl pl procedure pl pl 
pl 

procedure goto lab 


lab 
slc terms possible precisely treat unit typed continuations functions 
algol null type function declared proper procedure unit returning obscures nature call pl body looks just procedure call really goto disguise 
characteristic multiple exits existing languages singled normal return special 
slc express functions 
return ordinary non local exit cf 
elog example section 
distinction may natural circumstances nature exits different 
just function accepting coordinate pair usually curried functions exits closely related 
cases symmetric syntax fa bg 
preferable 
exceptions consider different approach escaping 
number programming languages ada sml include exceptions structured form goto 
accurate view shall see exceptions essentially dynamically scoped feature statically statically scoped language 
symmetry suggests language dynamic continuations dynamic values generally regarded problematical concept 
consider exceptions mechanism standard ml harper 
syntax changed new version old conceptually similar 
exceptions statically typed exception declared number exceptions corresponding run time errors 
declare exception syntax exception en exception exc int declares integer typed exception exc 
exception activated raise expression raise en raise exc activates exception exc value 
raise appear context legal write raise 
raise exception packet containing name associated value exception propagated outward nearest dynamically enclosing handler exception 
attach handler expression syntax en handle en 
ee new expression normally evaluate en execution en raises exception en value contain handler ee evaluated bound exception handled propagate top level execution program 
exceptions ada identical main difference expression transfer information 
sml declared explicitly activated raise statement handled exception part block 
lisp variants similar facility known catch throw 
exception raised throw en handled catch en ec semantics result catch value ec evaluation causes throw en case result value see exceptions typed statically exception declaration visible raise bound dynamically raise need occur textually en parameterless function called 
exactly continuation counterpart dynamic value bindings 
similarity extends implementation details deep binding originally lisp definition mccarthy current value variable going back list locating latest added binding 
side effect free implementation quite slow especially variable bound outside deeply nested recursive call 
baker introduced implementation technique known shallow binding symbol symbol declared fluid variable associated value cell accessed constant time 
variable bound new value old contents value cell saved away stack overwritten new 
control returns place binding old value restored 
current value variable immediately accessible 
technique applies exceptions 
exception name associate cell containing address encountered handler frame unhandled new exceptions 
time expression block ada evaluated executed new handler handle exc 
exception exc 
new handler address installed old saved stack restored exiting protected block 
raise executed instantaneously simply fetching current handler address going back activation frames dynamic links looking handler 
dynamic scoping may convenient occasions number languages 
old lisp apl 
semantic problems severe languages including scheme common lisp static scoping basic binding primitives things efficient compilation easier 
slc dynamically scoped variables 
extension replacement exceptions dynamic continuations exact dual fluid dynamic values 
interesting note resent change sml exceptions precisely order provide uniform treatment constructors coproduct injections exceptions 
accordance slc view concepts closely related dynamic binding aspect 
definitely possible create variant ml exceptions replaced statically scoped construct retaining new unification coproduct types escapes 
persistent continuations persistent continuations natural extension non local exits languages higher order functions scheme ml 
idea facility usual handling non local values returned functions extended non local continuations 
close slc view able give quite accurate definitions various constructs slc terms 
slightly different approaches providing persistent continuations language 
presents continuation normal function perform jump applied conceptually distinguishes continuations functions 
method introduces fewer new concepts semantically complex inherently higher order 
hand separated syntax block facility order directly integrated higher order framework 
way exemplified scheme provides access current continuation trough single procedure call current continuation call cc 
functional pass imperative functional abstraction current continuation argument apply result call cc result 
applies value evaluation body abandoned returned result call cc 
example call cc lambda call cc lambda call cc general exception mechanism call returns part functional value captured continuation may re invoked time restoring control expression embedding call cc 
means function activation records general stack allocated 
case language non local values 
adding class continuations higher order language general give serious implementability problems just runtime organization stack languages usually directly admits non local exits 
express call cc accurately slc call cc definition highlights key features call cc duplication continuation point call cc called discarding current continuation representing function argument applied 
type clear result call cc normal result argument type furthermore continuation representing function called context just ml raise 
give alternative definition clear function return place call 
discarding continuation explicitly specify meaningful continuation making return null typed result call cc fg slight syntactic variation call cc consists performing binding special form escape reynolds catch confused maclisp catch styles completely equivalent shown inter definability relations escape call cc call cc escape significant variation consists splitting duplication aspect discarding treating continuations special objects 
somewhat closer slc approach precisely primitives conceptually simpler 
example organization callcc facility newer versions standard ml new jersey appel jim 
insists treating continuations values slc definitions primitives slightly complicated scheme call cc 
gives access continuation functions callcc cont throw cont cont represents type accepting continuations treated values 
note callcc differs scheme call cc providing opaque representation continuation applied throw callcc fn throw represent type cont slc 
usual go functions gives equivalent possibilities 
corresponds viewing continuation function return seeing application context meaningful value part 
closure view get callcc fg throw fg context callcc throw recognize callcc identical call cc definition 
note implement scheme call cc primitives fun callcc fn throw particular type inferred call cc slc 
reverse definition possible sense concentrates define lambda call cc define lambda interesting note statically scoped primitive callcc expose fundamentally dynamic nature exceptions 
fact interchangeability values continuations functions define fluid values exceptions construct translation fluid dcl exception cont fluid handle throw fluid get callcc fn raise example fluid dcl int fun fluid get fluid fluid translated exception xe int cont fun callcc fn raise xe handle xe throw handle xe throw evaluates 
principle construct call cc powerful express slc function practice translation non obvious particularly higher order constructs involved semantic complexity call cc completely hides nature slc definition 
suggests may advantageous think problem slc terms translate scheme 
shall see situation section 
note facilities coroutines simula dahl tasking ada closely related persistent continuations activation records 
slc current form express true parallelism handle coroutines shall see section 
programming slc slc enforce special programming style 
typed program higherorder value language correct slc modulo syntactic differences 
typical slc program encapsulate continuation abstractions mode neutral injections function really best described explicit continuations see examples section 
assume cbv evaluation real problems going cbn eager coproducts 
notation introduced section proper language extensions 
examples directly translated back pure slc executed implementation slc derived directly semantic equations 
non local exits tree search mentioned section tree search natural candidate non local continuations 
optimizing goto call cc usually considered questionable idea slc expressed precise declarative specification imperative implementation 
define type binary trees type ta ta theta ta natural problem consists deciding tree contains element 
want function search theta ta bool returns true inject tree contains element false 
give direct solution search rec case esac uses operator bool theta bool bool section avoid traversing entire tree element quickly 
see recursive call argument 
take recursion non local value search rec case esac definition arguably better involve recursion common part true continuation 
comparison succeeds result search immediately known true answer passed back nested recursive calls 
eliminate copying third definition continuation outside recursion search rec case nf esac normal return recursive call mean search failed 
element failure continuation eventually activated 
returning answer order tree searched unimportant 
means parallel search branches unspecified way 
negative results combined returning 
note abstracting going search search probably improve efficiency 
reason lot means extra implementation complexity accessing non local variable display static links outweigh copying operation 
fact compilers optimize search back search lifting 
hand non local success continuation applied 
really expect speedup second transformation 
express definition search pieces scl 
particular function ff rg fact partial write equivalent definition search search ff nf rec ffi theta quite intuitive definition readable 
treat binary function infix operator eliminate writing take final step variables body recursive function interpret recursive continuation obtain large unreadable scl term pointing totally variable free notation really practical writing programs may suited implementation 
coroutines streams example basically order easily translated language algol pascal non local gotos 
section consider complicated problem involving higher order slc concepts 
example considered scheme language similar capabilities heap allocating activation records simula coroutines ada tasking 
fringe problem hewitt known example coroutines 
problem decide binary trees defined previous example sequence values leaves left right traversal 
problem lies fact trees completely different structure simultaneous recursion structure possible 
way solving simply flatten trees lists compare iteratively recursively 
potentially wastes lot time trees differ mention extra space lists 
better solution generate successive elements trees incrementally compare 
cbn language solves automatically rely laziness produce lists needed 
easily express lazy lists cbv language lifted types generation problematical 
example natural definition fringe flatten accumulator intended define fringe atom 
stream cons fringe car fringe cdr problem stream cons benefit delaying second argument 
delaying variable useless gain laziness definition 
course simply explicitly delay second parameter fringe may simple examining complicated tree 
language class continuations give alternative model streams coroutines delayed arguments 
access stream lazy list built incrementally capturing continuation generator suspension exploiting coercions continuation function value 
primitive operation streams appending substreams adding elements time 
fact stream appending modeled naturally associative function composition 
define lazy lists usual way type lla theta lla define operator stream cons 
introduce functions emit collect 
emit time returning value generator 
thought creating substream length 
collect transforms stream built generator lazy list accessed sequentially 
example fringe tree fringe collect rec emit ffi ta lla recursive function traverses tree 
leaf elements returns singleton substream obtained emit stream generated interior node consists substreams generated subtrees 
right left evaluation cbv function composition definition specify substream generated left subtree returned 
emit called value head lazy list cell 
tail part emit capture current continuation generator suspension value type lla 
coercions corresponds continuation type ll return type emit input type want combine unknown number successive emits function composition 
leads definition stream type sa lla lla define emit follows emit sa describes effect precisely emit accepts value continuation packages second inject lazy list type 
generator remain suspended lazy list consumer applying 
collect sense starts process supplying stream collect sa lla collect implicitly captures current continuation function continuation compare fringes trees lazy lists sf cll fringe fringe ta theta ta bool function cll compare lazy lists defined usual way cll rec case case true ll false esac ll case false ll esac esac need non local exits comparing lists function expressed tail recursively 
stream system just general scheme 
example stream representing infinite sequence integers written ints rec ffi emit converted lazy list collect ints 
iteration recursion iteration commonly thought special case recursion simple translate iterative function recursive 
known partial recursive function rewritten iterative fact loop conversion may far obvious recursion pattern complicated 
may somewhat surprising having class continuations language permits define traditional fixpoint combinator functions terms iteration 
start noting recursive values equation rec simply instance gamma gives typed morphism function type theta obtain typed value apply function 
similarly recursive continuations cg fg ffg yg simply rewrite definition fix cbv rec exploiting coercion functions values fix rec fg ffg ag fix works iteration contexts 
similar way traditional machine architecture executes recursive programs managing stack contexts application frames explicitly 
surprisingly translate definition language persistent continuations 
assume iterator datatype 
iter fun iter case iter written iter tail recursive function equally construct quite awkward express ml requiring updateable auxiliary variables explicit sequencing iterator easily define recursive functions accumulator fun fac iter fn obvious obtain general fixpoint combinator 
probably find operational reasoning terms stacks pleasing solution 
translate scl term obtain somewhat unreadable theoretically founded definition exception null fun fix callcc fn 
iter fn callcc fn na 
throw fn callcc fn throw na raise null represent context explicitly pair consisting value continuation coercions continuation abstractions slc turn tangle throws underlying execution pattern languages 
exception null raised just continuation fg slc version activated 
cases needed expression type correct 
possible give intuitive operational explanation fix works adding new activation frames control stack needed 
issue declarative content obtained directly dualizing simple value slc equation 
expected true fixpoint combinator expression fix fn fn evaluates 
course just write definition call cc scheme definition highlights fact expression typed 
object oriented programming object oriented programming oop thought radically different traditional programming 
distinction important characteristics oop languages object message paradigm computation concept inheritance 
section show categorical duality relates ideas 
treat particular oop language depth subsection points concepts constructs various languages affected symmetrical framework 
presentation adopts function view concentrating symmetry products coproducts values continuations directly 
introduce relevant slc scl concepts necessary demonstrate hidden symmetries 
familiarity basic ideas oop considerable advantage reading section strictly necessary 
avoid confusion point immediately objects object oriented programming related categorical objects kind categories concerned 
section term object refer oop meaning term type objects scl category 
symmetry organizations common conceptual structure problems data organization summarized choice representing dimensional table row major column major order 
purpose section show difference traditional objectoriented style essentially kind 
number input instance types 
want compute series output properties operations 
example take interpreter programming language consider type values language 
precisely set instances integers booleans strings functions similarly operations want perform values read print create destroy compare example typical oop scenario instances type vehicle bicycle bus truck properties weight maximum speed number passengers important properties necessarily explicit parts instance instance variables computed 
example instance index database outputs lookup operation 
assume instance number property number function method 
oversimplification consider case exist meaningful subsections 
want organize functions logical way grouping related code ease maintenance modifications 
precisely fundamental choice paths 
traditional style define explicitly variant type datatype union delta delta delta eager coproduct cbn fix set instances 
give functions 
definitions placed case construct 
implicitly define desired function computing property instance hf 
organization easy add new output operation property just supplying definition 

interpreter example may want compute size instance need specify find size integer string existing code needs modified 
adding new input type reals inconvenient add new cases existing functions values read print compare object oriented style group outputs class specification signature theta delta delta delta theta lazy product cbv 
define functions hf 
class definitions 
definitions member functions 
give implicit 

organization easy add new instance type need just add definition hf 
changes existing code 
hand adding new operation just problematic adding new input traditional organization go existing class definitions add descriptions perform new operation instance 
theoretical point view approaches completely equivalent equality 


hf 

hf 
follows directly general properties products coproducts distributive law morphism ffi requires axioms 
symmetry means alternatives inherently superior 
best choice organization clearly dependent nature problem set operations relatively stable new instances added oop organization preferable main extensions consist adding new operations fixed set instances new functions tree type traditional organization 
large program oop organization data code traditional 
language heavy bias formalism cause severe problems case 
somewhat surprisingly description oop style mention objects 
essence object oriented organization consist particular grouping methods object just value manifestation principle 
think object typed value obtained applying typed instance lazy tuple properties 
message selection components object 
note property need simple value function closure additional information may message 
similarly define object typed continuation obtained transforming typed continuation summands object context typed messages sent contain return addresses input data 
fact actors hewitt objects objects associated properties instances object oriented languages 
specification inheritance main characteristic oop concept inheritance 
fact say important property organizational difference mentioned 
benefits inheritance cited clarity potential code reuse 
shall see essentially independent dualize traditional programming 
call specification inheritance concerns concept subtyping implementation inheritance method sharing 
unfortunately oop languages explicit distinction kinds inheritance force implementational relationship express specification 
treat specification inheritance implementation inheritance subsection 
basically specification inheritance permits general function directly restricted expected 
oop means function computing properties necessary traditional programming function larger number instances 
concretely oop class said specification subclass class theta delta delta delta 
function viewed function letting ffi note ordering exclusively properties imply common instance variables algorithms 
fact instances subclass represented efficiently compactly precisely specialized 
example integer numbers thought specification subclass reals property real number integer inclusion integers reals 
rarely idea implement integer arithmetic terms floating point operations 
likewise container classes similar specifications imply similar implementations array seen special case lookup function usually implemented efficient way general association list 
subclass ordering properties induces reverse ordering inputs functions composed 
particular id viewed function function function just way stating result returning function typed value required 
traditional style equivalently view instance variant type specification supertype delta delta delta 
function function ffi similarly function function function id function coproduct inheritance relation avoid useless injection tags common ml programs making type inclusions implicit 
simple example tree possibly empty leafs supertype simple binary 
means existing binary tree directly general expected 
general class subclasses variant type supertypes represent single inheritance 
concept specification inheritance extends directly multiple inheritance class inherit properties 
case modify definition somewhat say subclass includes components isomorphic identical theta delta delta delta 
permits treat 
theta theta subclass theta theta case earlier definition subclassing 
inheritance coproduct types extended analogously variant type may supertype time 
implementational terms going identities isomorphisms types introduces extra level indirection method lookup 
theoretical problems overlap superclasses far specification concerned 
want inherit implementations conceptual problems arise 
implementation inheritance second aspect inheritance object oriented languages concerns code reuse 
principle independent specification inheritance concepts supplement nicely 
purpose subsection essence implementation inheritance isolation 
specification inheritance concentrates instance property types implementation inheritance concerns methods recall usually independent functions grouped instance property 
want reuse parts composite function physically duplicating code 
oop may case properties new instance computed way way existing instance define implementation subclass may additional properties question output specification inheritance code new operations inherited anyway 
instance need identical reuse methods specification subclass include instance variables 
input specification inheritance permits directly course methods inherited functions part visibility rules particular languages may limit access instance variables superclass 
new method replacing superclass conveniently expressed terms old 
traditional style analogous concept implementation inheritance new property computed similarly existing specification inheritance permits differences types new property may defined larger number instances old 
case supply new methods explicitly 
supertype variant cases 
specification inheritance ensures old methods directly 
surprisingly essence implementation inheritance traditional programming languages clause wildcard pattern case statement expression 
example interpreter example define function print ext print prints strings quotes permit output read 
define print ext terms print case construct singles strings special treatment defers value types listing explicitly original print function 
new printing method strings expressed terms old 
specification inheritance general imply implementation inheritance reverse true 
case inherited properties implementation superclass meaningless new class 
instance implement booleans terms integers false true 
number fundamental properties inherited comparison operations size creation destruction hand arithmetic operations booleans sense 
slightly larger example implement finite multisets bags unsorted lists 
large number operations lists apply multisets length cardinality map extension function multisets append union 
operation head element sense multiset 
language implementation subclassing implies specification subclassing problems solved overriding inapplicable inherited method error message 
implementation inheritance multiple new instance inherit methods 
somewhat problematical case overlaps single strategy dealing generally applicable 
want inherit multiply defined method particular superclass object finalization usually invoke cleanup methods superclasses 
similarly multiply inherited instance variables usually duplicated may certain cases 
important remember implementation inheritance precisely defined concept specification inheritance generic term language constructs method sharing simpler 
natural way handle overlaps correct solution decided case case basis 
look object oriented languages subsection see existing oop languages fit framework outlined 
mentioned concepts specification implementation inheritance tightly interwoven different languages group various ways 
try separate possible 
best known object oriented language smalltalk goldberg robson purely implementation class organization 
specification class object determined implicitly set messages accepts error 
classes languages simula dahl stroustrup common implementation pro forma implementation subclassing express specification conformance possibility different instance types properties expressed virtual member functions methods implementation superclass expected required redefined subclasses 
languages specifications form basis class definitions 
examples kind note trellis owl schaffert language cardelli 
behavior class set instance variables methods determines place type hierarchy 
specification subclassing relation may explicit implicit 
case class specification explicitly names superclass 
examples approach include trellis owl 
languages subclassing implicit relies consistent naming properties 
case smalltalk cardelli language 
name specification inheritance coproducts 
latest available version simula single inheritance languages trellis owl cardelli notation multiple 
somewhat surprisingly specification inheritance smalltalk multiple object member specification class simply virtue having required properties easily classes time 
fact message lookup smalltalk somewhat complicated languages 
important aspect possibility static typing 
independent characteristics implicit explicit subclassing 
smalltalk object may fail understand message runtime type systems languages mentioned prevent 
statically typed language include features breach type security 
possible cast pointer object class type derived subclass type 
cast defined ensure object pointed really indicated type additional properties derived class 
case effectively applied inverse projection gamma theta section result appears properties trying access typed constitutes runtime error 
unrestricted casting known unsafe feature 
cardelli language includes similar feature coproducts operation converts coproduct typed value fewer possibilities 
precisely inverse injection gamma know operator converted instance right variant operation safe 
theoretical point view class pointer casting just defensible 
practice important difference casting represents unchecked conversion illegal cast give unspecified results defined runtime error 
analogous lisp implementation checking argument car operations fact cons cell 
interpretation consider interpretations slc scl programs non standard domain inducing natural symmetry forward analysis interpretation values backward analysis interpretation continuation 
strongly connected view statements imperative language state predicate transformers gries 
typically dual analyses concern dual evaluation strategies 
example strictness analysis hughes cbv meaningless functions strict 
replaced totality analysis ensure transformations involving conditional axioms change meaning program 
simpler example duality consider reachability analysis cbv 
interpret program domain fr denoting reachable ur meaning definitely unreachable 
crude domain refine adding elements coproduct typed values denoting reachable inject analogously second 
elements arranged usual diamond lattice odd interpretation 
start interpretation ur assigned values input program propagate reachability information forwards fixpoint reached 
particular knowledge injection tags see iterations terminate 
nontrivial fixpoint may show parts program traversed eliminated changing meaning 
consider dual case analysis cbn 
goal find parts computation 
basic domain point fn ung denoting needed definitely unneeded respectively 
refine adding elements product types meaning second component needed 
start interpretation un output program needed 
propagate information backwards input 
iteration knowledge recursive result expressed terms need input propagated recursive definitions 
advanced analyses ones sketched possible 
particular higher order programs treated considering closures contexts 
number analyses suggested hughes fit slc scl framework 
directions research mentioned investigation deep 
suggested number subjects developed section topics explore 
concern slc scl directly involve general implications symmetries pointed thesis 
ffl categorical concepts scl fixed set combinators associated axioms 
interesting see framework hagino virtually structure defined adjunctions extended encompass continuations 
side value continuation duality categorical concepts pushouts pullbacks new light 
idea introducing symmetrical subset quotient types equalizers coequalizers looks promising computability may problem 
ffl mathematical applications applications category theory provide little feedback 
simple concept expressed left adjoint coproduct functor easily dismissed meaningless theoretical interest mathematician 
importance providing higher order framework generalization partial functions worth second look 
just usual ccc axioms flattened intuitionistic logic may reasonable deductive system corresponding category investigated 
ffl logic programming ideas concerning functional programming generalized category relations logic programming languages prolog 
course involve procedural interpretation logic programs just slc builds computational view functions set theoretical 
reasoning control aspects logic programming backtracking continuations natural tool 
fact slc scl contains elements backtracking witnessed functions pa continuations logic programming framework undertaken sato tamaki 
bidirectional data flow prolog predicates may strongly connected view functions value request transformers slc 
ffl parallelism slc scl inherently sequential way 
major obstacles extending framework parallel execution unspecified evaluation order eager cbv products lazy cbn coproducts suggests natural duality parallelism 
continuation abstractions language need impede parallelization precisely flow control explicit independent pieces computation may easier detect 
ffl scl machine refinements scl basis machine similar cam curien firm categorical foundation handling imperative aspects control flow run time errors escapes fact cbv version slc natural traditional architectures cam theoretical background imply availability proper products exponentials 
current machine architectures developed set operations expressing flow control machine deal operations desirable 
cbv slc view functions continuations accepting contexts activation frames appears suited implementation 
comparison related number authors worked designing symmetric languages category theory language design implementation taming continuations 
combined ideas 
section point compare approach 
ffl hagino uses category theory obtain symmetrical language 
starts primitive concepts builds virtually type structure programming constructs categorical adjoints 
dialgebra approach gives nice formulation recursive types primitive recursion 
programming language framework quite symmetrical 
left adjoint coproduct functor easily expressed general notation valid construct computable subset language 
restriction primitive recursion seldom problem excludes number applications interpreters 
hagino proposes symmetric extension ml similar discussed section 
concentrates exclusively values symmetry perfect 
example construct merge suggested dual case really mirror image syntactically semantically 
ffl curien builds equivalence cccs precisely result set categorical combinators leading efficient implementation categorical machine cam 
full axioms cccs require cbn evaluation semantic problems nontermination avoided versions cam cbv 
implications appear treated depth 
concentrating untyped calculus gives conceptual problems requirement surjective pairing basically value split components recombined 
furthermore consider side category theory coproducts equally important practical language 
ffl girard presents formalism called linear logic exhibits similarities scl 
form negation fundamental primitive induces question answer symmetry similar scl 
classical linear logic appears involve proof theory general computation 
particular impose structure different morphisms objects 
important difference scl consider type negation different objects category expresses duality morphism structure 
hand linear machine lafont builds intuitionistic linear logic essentially bicartesian closed category ccc coproducts 
gives traditional computational model terms values 
scl distinguishes strict products omega lazy ones lam loses symmetry classical linear logic 
example eager coproducts phi classical ll objects inverted correspond lazy coproducts pure cbn 
furthermore cam lam deal general recursion 
ffl cardelli investigates symmetry products coproducts related inheritance number ideas types subtyping influenced section 
type system subtyping relation presents fact completely symmetrical products coproducts 
actual language evaluation part basically syntactic variant ml symmetry data types extend properly symmetry constructs goes languages 
ffl felleisen danvy filinski approach continuations entirely different perspective 
emphasis formalizing declarative aspects abstracting control composable continuations essentially ended objects traditional scheme language 
number deep symmetries control data appear somewhat different slc scl kind possible unify slc view continuations fundamentally ended entities delimited context view 
chapter previous chapters framework reasoning continuations declarative concept 
class continuations language new idea 
best authors knowledge formalism integrated deeply core semantics type system operations concepts defined terms accurately said half language 
best way summarizing results obtained pointing number fundamental symmetries exposed slc scl ffl values continuations fundamental duality built 
leads view function act value transformer continuation transformer regardless mode definition 
slc perspective scheme slogan continuations class citizens appears somewhat misleading implicitly forces continuation look act value equal partner 
particular evaluation strategy may define values continuations differently slc syntax treats identically brings point ffl call value call name reduction strategies essentially dual properties problems 
basically asymmetric language calculus readily apparent class continuations duality clearer 
particular cbn strategy directly admits terminal object products exponentials cbv proper initial object coproducts 
exact dual ordinary cbv pure cbn problems coproducts cbv products 
hand eager coproducts traditional cbn strategy dualize directly lazy products cbv language 
ffl exponentials exponential objects provide categorical framework treating functions values solve problem free variables function body tying higher order functions products 
objects possible analogous treatment functions continuations non local continuations handled connection coproducts 
counter intuitive sight appear incompatible set theoretical concepts cardinality may fact offer accurate view higher order functions cbv languages exponentials 
constructs provide basis treating continuations values vice versa route functions explicit 
ffl totality strictness concepts play central role definition scl 
kept mind familiar names denote slightly unconventional definitions 
popular terms total function respects continuation passed strict function respects value 
note scl totality weaker condition imposed traditional definition strictness slightly stronger usual 
ways new symmetrical definitions accurate reasoning properties programs function evaluates argument 
ffl iteration recursion unbounded iteration traditionally seen special case general recursion slc scl view dual concepts 
theoretical assumes direct form slc iteration scl foundation self referential continuations recursion self referential values generic term recursive 
slc scl approach problem nontermination somewhat unconventional 
deal routinely functions return discard input axiomatic framework handle non termination just special case phenomena 
impose explicit information ordering relation terms represents non termination jump cbv input cbn special continuation value respectively 
may interest reader know order various parts thesis developed 
surprisingly entire denotational semantics type system slc including structured types higher order functions written early remained virtually unmodified entire duration 
symmetrical syntax fixed fact little choice semantic equations calculus conversion rules duals hold 
long time absolutely intuition attached terms virtually result involving higher order functions conjunction continuations derived handle semantics 
provoked strong requirement direct implementability slc interpreter scheme type inferencer prolog existed 
hand scl entire axiomatic presentation comparatively addition obtained result long search underlying category slc 
categorical concept duality guiding light initial development slc imperfections products exponentials cbv evaluation attempts formalization long time 
breakthrough idea strategy independent core strategy dependent specialization initial terminal objects took surprisingly long mature 
applications suggested chapter date back early days refined somewhat lately 
particular design efficient implementation symmetrical programming language possibly including inheritance original goal thesis 
slc intended notation try ideas moving important fundamental problems 
gradually deep semantic implications having directly accessible continuations language apparent thesis resulted 
author point number loose ends remain hoped problems solved way compatible framework may necessary backtrack slightly order obtain coherent presentation theory 
remaining task develop complete set strategy independent conversion rules slc 
denotational semantics completely unambiguous equality terms connected intimately particular evaluation order formal proof equivalence scl hard express 
axioms scl conversion reduction rules 
welldefined concept normal form deciding strategy independent equality non recursive terms amounts general theorem proving 
automated procedure knuth bendix completion obtain set directed rewrite rules axioms notably morphism composition inherently bidirectional general concept reduction may necessary 
anyway axiom set ad hoc nature desirable find underlying pattern 
area recursive types received proper treatment deserves 
particular implicit equality type recursive definition probably replaced named isomorphism 
existence recursive values continuations type closely connected existence initial final fixpoints type defining functor manes arbib chapt 
investigated 
points important may undermine basic theme thesis class continuations categorically sound seen powerful declarative tool exposing deep structure symmetry common language constructs suggesting new ones 
convinced reader beauty category theory truth beast 
continuation semantics reconciled served purpose 
bibliography ansi american national standard programming language fortran 
american national standards institute 
ansi std 

ansi programming language ada manual 
american national standards institute 
ansi mil std lncs 
appel jim andrew appel trevor jim continuation passing closure passing style 
proceedings sixteenth annual acm symposium principles programming languages pp 
austin texas january 
arbib manes michael arbib ernest manes arrows structures functors categorical imperative 
academic press london 
backus john backus programming liberated von neumann style 
communications acm 
baker henry baker jr shallow binding lisp 
artificial intelligence mit perspective vol 
pp 
mit press 
tarlecki andrzej andrzej tarlecki naive denotational semantics 
information processing mason ed pp 
ifip 
cardelli luca cardelli semantics multiple inheritance 
proceedings international symposium semantics data types pp 

lncs 
curien 
curien categorical combinators sequential algorithms functional programming 
research notes theoretical computer science vol 
pitman 
dahl ole johan dahl bj rn nygaard simula common base language 
norwegian computing center october 
damas milner damas robin milner principal type schemes functional languages 
proceedings ninth annual acm symposium principles programming languages pp 
january 
danvy filinski olivier danvy andrzej filinski functional abstraction typed contexts 
diku rapport computer science department university copenhagen copenhagen denmark july 
dijkstra dijkstra goto statement considered harmful 
communications acm march 
felleisen matthias felleisen theory practice class prompts 
proceedings fifteenth annual acm symposium principles programming languages pp 
san diego california january 
filinski andrzej filinski declarative continuations investigation duality programming language semantics 
proceedings summer conference category theory computer science manchester 
september 
appear lncs 
friedman wise daniel friedman david wise cons evaluate arguments 
automata languages programming michaelson milner eds pp 
edinburgh university press edinburgh scotland 
girard jean yves girard linear logic 
theoretical computer science 
goldberg robson adele goldberg david robson smalltalk language implementation 
addison wesley 
gries david gries science programming 
texts monographs computer science springer verlag 
hagino hagino categorical programming language 
phd thesis university edinburgh edinburgh scotland 
ecs lfcs 
hagino hagino typed lambda calculus categorical type constructors 
proc 
summer conference category theory computer science pp 
edinburgh 
lncs 
harper robert harper robin milner mads tofte definition standard ml version 
report ecs lfcs university edinburgh edinburgh scotland august 
hewitt carl hewitt control structure patterns passing messages 
artificial intelligence mit perspective vol 
pp 
mit press 
hewitt carl hewitt behavioral semantics nonrecursive control structures 
proceedings programming symposium robinet ed pp 
paris france april 
lncs 
hughes john hughes analysing strictness interpretation continuations 
interpretation declarative languages samson abramsky chris hankin eds chapter ellis horwood 
hughes john hughes backwards analysis functional programs 
partial evaluation mixed computation bj rner ershov jones eds pp 
north holland 
poign hagen axel poign note inconsistencies caused fixpoints cartesian closed category 
unpublished manuscript 
iverson iverson programming language 
john wiley sons 
jensen wirth kathleen jensen niklaus wirth pascal user manual report 
springer verlag 
lncs 
lafont yves lafont linear machine 
theoretical computer science 
lambek scott joachim lambek scott higher order categorical logic 
cambridge studies advanced mathematics vol 
cambridge university press 
maclane saunders maclane categories working mathematician 
graduate texts mathematics vol 
springer verlag 
manes arbib ernest manes michael arbib algebraic approaches program semantics 
texts monographs computer science springer verlag 
mccarthy john mccarthy lisp programmer manual 
mit press cambridge massachusetts 
moggi eugenio moggi computational lambda calculus monads 
proceedings th conference logic computer science pp 
ieee 
naur peter naur ed revised report algorithmic language algol 
communications acm 
peyton jones simon peyton jones implementation functional programming languages 
prentice hall 
plotkin gordon plotkin call name call value calculus 
theoretical computer science 
poign axel poign semantic algebras higher order structures 
unpublished manuscript 
rees clinger jonathan rees william clinger eds revised report algorithmic language scheme 
sigplan notices december 
reynolds john reynolds definitional interpreters higher order programming languages 
proceedings th acm national conference pp 
new york 
rydeheard burstall david rydeheard rod burstall computational category theory 
prentice hall international series computer science prentice hall 
sato tamaki sato hisao tamaki existential continuation 
new generation computing 
schaffert craig schaffert cooper bruce mike kilian carrie trellis owl 
proceedings oopsla pp 

schmidt david schmidt denotational semantics methodology language development 
allyn bacon 

sethi tang ravi sethi adrian tang constructing call value continuation semantics 
journal acm july 
stoy joseph stoy denotational semantics scott strachey approach programming language theory 
mit press 
strachey wadsworth christopher strachey christopher wadsworth continuations mathematical semantics handling full jumps 
technical monograph prg oxford university computing laboratory programming research group oxford england 
stroustrup bjarne stroustrup programming language 
addison wesley 
weis pierre weis mar ia virginia alain michel mauny asc ander su caml manual version 
inria ens paris france december 
appendix implementation slc scl chapter contains listings model implementation slc caml dialect weis ml 
note name letters cam stand categorical machine refers implementation language categorical features 
somewhat non standard facility interface yacc parser generator parsing done explicitly machine produced parser limited 
noted aim implementation simplicity efficiency 
support code parser unification algorithm implemented quick dirty way currently rewritten improve structure 
actual slc related code correspond directly equations thesis sparsely commented 
concrete syntax pre parsing major obstacle writing language processors ml syntax verbose 
parser kind essential entering terms larger lines 
caml system provides interface yacc parser generator permits concrete syntax entering programs 
unfortunately built non replaceable lexical analyzer distinguish different kinds identifiers value continuation variables 
distinction essential parsing slc program correct coercions inserted identifier function 
split parsing process phases yacc parser converts input string simple tree representation operator precedences associativity 
processed tree parser written directly caml 
concrete syntax parsed grammar 
rec token left right rec token num ident right left right left left left right form num form form form form form form form form sup form form form form forms forms left form right form rec form ide side forms spar forms forms empty flist flist form form flist num num ide ident syntactic domain form associated pre syntax form ml syntactic forms recognized yacc pre parser type form num side string form form form form form form sup form form form form form form form form form form form form spar form list form list form list form list syntax parsing concrete syntax slc scl 
parser slc exists 
slc syntax ml datatype slc ml syntax slc type var string type cst cint num type rec exp cst eide var exp exp eup fnc exp erec pax exp fnc cnt var cnt cnt cnt fnc pay cnt fnc fnc pax exp pay cnt var exp cnt pax var pax pax pay var pay pay tree parser converts pre syntax 
aspects transformation handled quite properly 
particular cbv view recursive functions continuations embedded parsing algorithm general approach preferable 
parse ml parser slc terms cbv recursion form slc type rec fun 
cint side 
case 
eide 

eup 
eup 
eup 
eup 
eup sup 
eup spar 
spar 
spar 






failwith bad syntax parsec fun side 
case 


parsec 

parsec 
parsec parsec 
py py parsec spar 


sup 

failwith bad syntax fun 
px px 
py py parsec spar 
side 
case 
eide 
sup 

parsec 
parsec 
failwith bad syntax fun side 
fun spar 
spar 
spar 

failwith bad syntax fun side 
fun 



failwith bad syntax translation slc scl syntax scl mirrors extended fixpoints section scl ml syntax scl type rec morph cst cst lval var var var lid id lcmp morph morph 
morph morph lpr pr lpr pr lcase morph morph lin lin morph lap ap phi morph lpa pa theta fix translator derived directly abstraction rules translation equations trans ml translator slc scl slc scl rec occurs fun lval 

lcmp 
occurs occurs 
occurs occurs lcase 
occurs occurs 
occurs 
occurs 
false lcmp lpr lpr lcmp lpr lpr lpr lcase lcmp lin lin lcase lcmp lin lin lin gammav lpr lpr gammac lcase lin lin deltav lcmp lap lcmp lcase lcmp lin gammav lcmp lin gammav lpr lpr deltac lcmp lcase lcmp lin lcmp gammac lpr lcmp gammac lpr lin lpa rec occurs case lval 
lpr lcmp 
lcmp lpr 
lcase 
lcmp lcase deltav 
lcmp 
lcmp 
failwith lcmp lpr occurs case 
lin lcmp 
lcmp lcase lin 
lcmp deltac lcase 
lcase 
lcmp 
lcmp 
failwith lcmp lin rec fun 
eide 
lval 
lid 
eup 
lcmp transf erec 
lcmp 
lcmp transf lpr fun 

lid 
lcase 
lcmp transf 
lcmp 
lcmp lin transf transf fun 

lcmp lid 
lcmp lcase lid 
lcmp lap lcmp lid 
lcmp lcase lcmp lid lpa fun 

lcmp lpr 
lcmp fun 

lcmp lin 
lcmp type inferencing slc examples thesis simply typed practical implementation probably support type polymorphism necessary define new identity function type 
type system model implementation polymorphic semantic consequences fully investigated 
allow recursively defined types 
slc programs involving types lists currently executed type checking 
actual type inferencer uses number auxiliary functions 
importantly function unify implements simple inefficient unification algorithm 
returns mgu terms fails unification possible 
building resolution theorem prover solve instantiates variables deterministically built proof tree 
term generalizer gen converts term possibly unbound variables normal form new instances renamed variables unify ml unification resolution theorem prover type rec term tvar num tfun string term list subst num term tvar rec unify tvar tvar case tvar 
bind tvar 
bind tfun tfun 
failwith functor fun 

sl unify substitute sl substitute sl substitute sl 
failwith arity bind occurs failwith occur fun tvar substitute fun tvar 
tfun 
tfun map substitute occurs fun tvar 
tfun 
occurs fun 
false 
instance substitute fun tvar tvar tfun tvar tvar tvar tvar tvar tvar type rec pt num term term list rec solve pt substitute unify instance substitute map fun instance case 
tr 
solve tr generalize term clause rec addl fun 

addl gen vl fun tvar 
vl addl vl vl tvar tfun 
vl vl vl tfun vl fun 
vl 
vl gen vl vl vl vl type system common slc scl 
functions converting types general terms type ml slc scl type system unify type rec type num string type type texp type type type type type type rec fun 
tvar 
tfun 
tfun unit 
tfun texp 
tfun 
tfun zero 
tfun 
tfun rec fun tvar 
tfun unit 
tfun 
tfun 
texp tfun zero 
tfun 
tfun 
tfun 
tfun 
failwith unknown type constructor slc type inferencer implements rules extended recursively defined expressions continuations 
principle quite simple explicit unifications somewhat harder read equivalent version prolog 
types written directly unifiable terms avoid extra conversions result harder read 
ml type inferencer slc terms slc unify bt pt tfun tvar map fun tfun tvar ext fun tfun tfun rec case cint 
bt int eide 
pt tfun 
bt unit 
bt tfun eup 
bt 
bt tfun erec 
pt tfun tfun tfun case 
pt tfun 
bt zero 
bt tfun 
bt 
bt tfun 
pt tfun pty pty tfun tfun case 
bt tfun int int int 
bt tfun int int int 
bt tfun int int int 
bt tfun tfun unit unit 
pt tfun tfun tfun 
pty pt tfun pty tfun tfun 
bt tfun 
bt tfun case 
ext pt tfun tfun 
pt tfun unit 
pt pt pt tfun tfun pt tfun pt tfun case 
ext pt tfun tfun 
pt tfun zero 
pt pt pt tfun tfun pt tfun pt tfun infer gr solve fun gr tfun gen length evaluation semantic domains cbv evaluation ml semantic domains cbv evaluation type type rec val vint num val val vin val vin val val cnt ans val cnt cnt val ans ans val type val cnt rerr env var 
var num type ir ref fun 
rerr err prim case 
vint vint vint 
vint vint vint 
vint vint vint 
vin vin 
vint vint 
failwith unknown primitive evaluator slc terms derived directly semantic equations cbv interpreter slc terms slc rec case cint 
vint eide 


fun fun eup 
fun erec 

fun case 


case vin vin 
fun 
rec 
case 
prim 


fun 
case 
fun 

case 
fun 
vin vin 
eval fun ir similarly scl interpreter mirrors cbv interpreter scl terms scl rec case cint 
vint lval 
ir 
ir 
prim lid 
lcmp 
fun 


fun fun lpr 
lpr 

lcase 
case vin vin lin 
vin lin 
vin 
fun lap 


fun case vin vin lpa 
vin fun vin 
vin fun 
fun case vin vin vin 

rec top level interaction implementation contains user interface printing slc types values traditional way 
unfortunately version caml allow user defined concrete syntax interaction existing top level evaluator auxiliary functions zd evaluating defining slc terms respectively 
similarly scl evaluator invoked functions md toplev ml top level interaction parse type trans case rerr 
failwith unknown identifier rec fun 
failwith polymorphic value int 
vint 
printstring bas 

printstring 
printstring printstring printstring texp 
printstring clsr 

failwith zero typed value 
case vin 
printstring printstring vin 
printstring printstring 
printstring rec fun 
printstring 
printstring 
printstring unit 
printstring printstring printstring texp 
printstring printstring printstring 
printstring null 
printstring printstring printstring 
printstring printstring printstring prep ir infer fun ir printstring def nt ir ir fun nt prep eval zd prep eval def printstring defined prep md prep def printstring defined sample session give example actual caml session model implementation 
zd md give identical results 
possible mix interpreters freely semantic domains cbv evaluation exactly 
caml sun inria fri jan false false load toplev home andrzej thesis caml lo loaded home andrzej thesis caml toplev lo loaded zd id defined id clsr 
zd prod fa gb defined prod clsr 
zd curry defined curry clsr 
zd ap gb defined ap clsr 
zd add defined add clsr 
int int int zd pp prod id defined pp clsr 
int int int pp clsr int int int ap pp int zd sum defined sum clsr 
zd defined clsr 
zd pa defined pa clsr 
zd defined clsr 
int unit unit zd ss sum id defined ss clsr 
unit int unit pa 
int ss pa unit unit ss pa unit unit zd callcc defined callcc clsr 
callcc int zd rec defined clsr 
zd pf defined pf clsr 
int int int int zd fac pf defined fac clsr 
int int fac int quit 
