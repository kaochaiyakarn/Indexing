functional programming appear 
printed united kingdom cambridge university press de bruijn notation nested datatype richard bird programming research group oxford university wolfson building parks road oxford ox qd uk ross paterson department computer science city university square london ec hb uk data 
capital mistake data 
sir arthur doyle adventures sherlock holmes de bruijn notation coding lambda terms occurrence bound variable replaced natural number indicating distance occurrence abstraction introduced suppose datatype representing de bruijn terms distance restriction numbers maintained explicit datatype invariant 
nested non regular datatype de ne representation terms formed invariant enforced automatically type system 
programming nested types little dicult programming regular types provided stick established structuring techniques 
involve expressing inductively de ned functions terms appropriate fold function type fusion laws establish properties 
particular de nition lambda abstraction beta reduction particularly simple proof associated properties entirely mechanical 
standard representation lambda terms variables type haskell involves essentially datatype data term var app term term lam term problem standard representation abstraction easy implement application 
application lambda term lam argument involves substituting free occurrences care taken avoid capture free variables bound variables overcome problem de bruijn de bruijn proposed notation lambda expressions bound variables occur 
notation variable appears bird paterson constructor lam bound variables appear natural numbers 
number assigned occurrence bound variable depth nesting lam terms occurrence closest binding occurrence example translates example taken paulson discusses de bruijn notation detail 
wants represent lambda terms involving bound free variables de bruijn style declaration term changed 
possibility paulson kinds variable free variables drawn bound variables drawn int possibility datatype declaration data term var app term term lam term incr data incr zero succ body lambda abstraction set variables augmented extra element variable bound lambda 
variable denoted zero free variable renamed succ inside lambda 
example terms represented lam var zero lam lam var succ zero term containing free variable may represented element term char lam lam app app var succ zero var zero var succ succ type term example nested datatype bird meertens de nition recursive di erent argument left hand side 
de nitions called non regular 
aim study novel representation lambda terms give implementations abstraction application 
useful interesting examples nested datatypes thin ground de bruijn notation gives excellent opportunity explore theory context speci example 
believe right way proceed largely territory nested types stick structuring principles provided established theory regular datatypes 
theory reviewed brie section 
section introduce type lambda terms set appropriate machinery de ning functions type 
implementations abstraction application section 
nal section generalise learnt cover extension de bruijn notation 
aim concerns proof 
view equational properties functions easily proved functions de ned combinations de bruijn notation functions functional composition application primary combining form 
consequence proof induction replaced appeal general equational laws standard theory 
material reviewed brie section 
proofs various equations generated simple automatic calculator described bird include selection 
programs typewriter font expressed hugs jones extension haskell provides exible typing discipline 
preliminaries term simpler inductive datatype binary trees equivalent term dicult lam case data bintree leaf fork pair bintree type pair default haskell allows leaf fork non strict functions declaration captures partial nite trees nite ones 
functions de ned legal haskell extended general typing discipline concerned datatypes sets functions total set theoretic sense 
functions considered strict ml 
enable state equational laws mentioning strictness conditions explicitly 
functors datatype constructor corresponding action functions preserves shape data structure replacing elements 
classic example map function lists functional programmers call actions mapping functions 
type constructor pair mapping function mapp pair pair mapp mapping function binary trees mapb bintree bintree mapb leaf leaf mapb fork fork mapp mapb slightly unusual form right hand sides intended suggest equations mapb 
leaf leaf 
mapb 
fork fork 
mapp mapb consider type constructors include function types 
bird paterson category theorists refer combination type constructor map function functor 
laws satis ed mapping function called functor laws mapb id id mapb 
mapb 
mapb property called naturality plays important role calculations 
polymorphic function type constructors may viewed collection functions instantiation type variable polymorphic de ned independently instances related naturality condition mapn 

mapm functions mapm mapn map functions type constructors respectively 
functions called natural transformations 
example function type flatten bintree natural transformation naturality property map 
atten atten 
mapb similarly naturality bintree constructors leaf bintree fork pair bintree bintree expressed equations de ne action mapb note action functions corresponding identity type constructor identity composition type constructors corresponds composition actions 
folds second general operator generalises foldr function lists 
binary trees operator pair bintree leaf fork mapp fold operator takes function argument constructor datatype 
action replace constructors input corresponding functions 
ect reduce data structure summary value rst examples size const uncurry height const maxp maxp max flatten wrap uncurry wrap de bruijn notation fundamental property fold operators produce unique function satisfying de ning equations 
follows trio useful calculational laws 
simplest identity law binary trees leaf fork id laws powerful heavily calculations 
fusion law states 



mapp map fusion law states 
mapb 
immediate consequence map fusion identity law alternative de nition mapb fold mapb leaf 
fork map operator regular datatype may de ned fold way hold nested datatypes 
fusion laws functor properties naturality conditions need powerful generic equational theory inductive datatypes 
details see bird de moor 
monads monad operations provide useful way structuring programs 
functional programmers introduced monads type constructor certain binding operation 
category theorists function level de nition convenient calculations 
monad de ned type constructor mapping function mapm operations unit join natural transformations required satisfy coherence laws join 
mapm unit id join 
unit id join 
mapm join join 
join total laws available reasoning monad coherence laws naturality laws unit join functor laws mapm mapping function associated standard example monad list type constructor unit returning singleton list concat join operation 
binary trees form monad unit leaf join function bird paterson bintree bintree bintree id fork see lambda terms form monad unit join operations lambda terms needed de nition lambda abstraction application 
see bird discussion monads monad laws di erent ways describe 
de bruijn notation follow steps type term lambda terms type data term var app pair term lam term incr data incr zero succ maps rst step identify map operators newly introduced types 
mapping function corresponding incr straightforward incr incr zero zero succ succ expect term interesting mapt term term mapt var var mapt app app mapp mapt mapt lam lam mapt note change argument mapt lam case required mapping function term incr mapt 
result mapt leaves bound variables unchanged replaces free variables 
nested de nition bound variables part shape term 
note argument mapt lam case di erent type incr incr instance declared signature 
de nition mapt polymorphic recursion rst function type signature omitted 
folds de nition fold function term follows principle replacing constructors functions foldt var foldt app mapp foldt foldt lam foldt de bruijn notation unfortunately line de nition pass standard haskell typechecker foldt applied term type term type foldt right side applied term type term incr 
argument functions applicable range di erent types effectively polymorphic 
haskell language types express extension called rank type signatures mccracken 
signatures implemented ghc hugs peyton jones jones 
syntax hugs foldt acceptable adding type signature foldt forall forall pair forall incr term variable denotes arbitrary type constructor 
consequence arguments natural transformations foldt natural transformation associated property mapn 
foldt foldt 
mapt naturality law foldt hold regular datatypes binary trees lists argument fold required natural 
naturality condition implies instance foldt manipulate values free variables 
result de ne functions terms instances foldt phenomenon motivates general de nition fold operator nested datatypes term call gfold generalised fold gfoldt forall forall pair forall incr forall incr incr term gfoldt var gfoldt app mapp gfoldt gfoldt lam gfoldt mapt additional ingredients de nition gfoldt rstly argument generalised arbitrary type constructor secondly extra argument provided fold 
explain role extra function observe lambda term variables drawn type term incr applying mapt lambda term produces element type term incr bird paterson applying gfoldt element produces element type incr correct type argument details generalised folds properties may companion bird paterson 
arguments gfoldt natural transformations result natural transformation 
gfoldt term mapn 
gfoldt gfoldt 
mapt mapm mapm mapn mapping functions associated type constructors advantage generalised fold resides extra degree freedom selecting type constructor theory take id identity type constructor obtain foldt gfoldt id special case 
gfoldt generalises foldt instance gfoldt takes constant type constructors delivering speci types arguments 
type constructor polymorphism haskell limited type constructor variables may instantiated datatype constructors possibly partially applied 
alternative expressing special cases installing id const new datatype constructors de ne specialised versions gfoldt example version corresponds constant type constructors case pair incr term var app mapp lam mapt note exactly de nition gfoldt di erent speci type 
example convert lambda term string term string string id zero succ particular convert element type term char string individual character variables printed quotes term char string mapt wrap wrap de bruijn notation example applying lam app var zero app var succ var succ produces string 
function gfoldt satis es similar fusion laws discussed binary trees 
laws proved fact gfoldt unique function satisfying de ning equation 
established induction terms 
particular identity law states gfoldt var app lam id id map fusion law states gfoldt 
mapt gfoldt 


fold fusion law suppose typing gfoldt term 
gfoldt gfoldt mapm 



mapp 


mapn proof consists simple calculations show 
gfoldt satis es de ning equations gfoldt mapm 

lam case longest 
gfoldt 
lam fde nition 

gfoldt 
mapt 

mapn 
gfoldt 
mapt 

gfoldt 
mapt mapm 
mapt 

gfoldt 
mapt mapm 
monad type constructor term monad var unit operator joint de ned joint term term term joint gfoldt id app lam distt distt incr term term incr distt zero var zero distt succ mapt succ bird paterson function distt replaces succs terms succs variables 
satis es easily established cases distt 
var var distt 
joint joint 
mapt distt 
distt equations fusion laws gfoldt prove coherence laws monad operations term joint 
var id joint 
mapt var id joint 
mapt joint joint 
joint example give proof equation joint 
mapt joint fde nition gfoldt id app lam distt 
mapt joint fmap fusion distribution law gfoldt id 
joint app lam mapt distt 
distt gfoldt joint 
id app lam mapt distt 
distt backwards joint 
lam lam 
joint 
mapt joint 
gfoldt id app lam distt fde nition joint 
joint abstraction application time return main problem hand give implementations abstraction application 
abstracting respect free variable easy occurrence term replaced zero occurrence variable replaced succ implemented eq term term lam mapt match match eq incr match zero succ de nition application quite short 
de ne application function takes term body lambda abstraction replaces occurrence zero nameless variable bound abstraction equations part statement distt distributive law barr wells monads term incr de bruijn notation apply term term incr term apply joint mapt subst var function mapt subst 
var returns element term term term terms 
function joint elements ordinary terms 
actual substitution done function subst left inverse match subst incr subst zero subst succ note type subst implies free theorem wadler 
subst subst 
check de nition apply prove substituting abstracted variable returns original term apply var 
mapt match fde joint 
mapt subst var 
var 
mapt match flaw joint 
mapt var 
subst 
mapt match joint 
mapt var 
subst 
match monad law mapt subst 
match fde nitions subst mapt id id extension de bruijn notation substitution de bruijn terms transforms arguments function bodies precluding sharing 
consider example term section variables rewritten unary notation ss term applied term result ss sss versions argument underlined 
generalisation de bruijn notation applied term just variable paterson 
ect escape scope matching 
looser representation terms avoid transforming arguments substituting 
example substitution yields ss bird paterson ect postponed pushing variables 
require matching lambda 
constraint captured de nition data terme vare pair terme lame terme incr terme note terme doubly nested 
similar de nition model quasiquotation literal data escape operator scheme clinger rees multi stage programming languages metaml taha sheard 
terme complex follow steps bintree term 
mapping function terme mape terme terme mape vare vare mape mapp mape mape lame lame mape mape generalised fold operator gfolde forall forall pair forall incr forall incr incr terme gfolde vare gfolde mapp gfolde gfolde lame gfolde mape gfolde note change type argument lambda abstraction extended terms variables type type terme incr terme applying mape gfolde value type produces element type terme incr applying mape element produces element type terme incr second recursive application gfolde produces element type required incr identity law extended terms gfolde vare lame id id de bruijn notation map fusion law gfolde 

mape gfolde 
fusion law gfolde terme 
gfolde gfolde mapm 



mapp 


mapn 
extended terms comprise monad unit vare join operator de ned terme terme terme gfolde id lame vare veri cation monad laws straightforward 
example prove 
mape 

mape fde nition gfolde id lame vare 
mape fde nition gfolde id lame 
vare 
vare 
mape fmap gfolde lame vare 
vare gfolde lame mape vare 
vare backwards 
gfolde id lame vare fde nition 
de nitions de ne abstraction application eq terme terme lame mape vare match terme terme incr terme terme mape subst see convert extended terms ordinary ones 
want function terme term de ne instance gfolde typing considerations dictate id term type assignment gfolde haskell forces de ne variant gfolde de nition gfolde specialised id de ne bird paterson gfolde var app lam joint mapt distt id check de nition show monad morphism satis es equations 
vare var 
joint 
mapt 
rst immediate de nition second appeal fusion 
fde nition 
gfolde id lame vare gfolde app lam 
joint 
mapt distt mape id 
vare gfolde app lam 
joint 
mapt distt vare fmap fusion backwards gfolde id app lam 
joint 
mapt distt 
vare 
mape fde nition gfolde id app lam 
joint 
mapt distt var 
mape gfolde id app lam 
joint 
mapt distt var 
id 
mape backwards joint 
gfolde var app lam 
joint 
mapt distt id 
mape fde nition joint 

mape joint 
mapt 
equation proof substitution extended terms correctly mirrors substitution de bruijn terms 
apply 
converts extended abstraction body simple terme incr terme term incr joint mapt distt mape proof lengthy routine omit 
representation de bruijn terms illustrates ability nested datatypes express constraints data structures enforced type checker 
served test case extension nested datatypes structuring principles developed regular datatypes maps folds monads 
case de bruijn terms operators including de bruijn notation handling bound variables de nition application abstraction particularly simple 
programs structured way proofs mechanical generated simple automatic calculator described bird 
programs manipulate nested types require number explored extensions hindley milner type system 
limited form type constructor polymorphism provided haskell occasional hindrance forcing de ne specialised versions polymorphic functions new datatypes equivalent existing types cases opportunity reuse lost 
reasonable design language restrictions lifted cost explicit abstraction instantiation respect type constructors types 
oege de moor suggested nested datatype lambda terms 
anonymous referee suggested number improvements 
barr michael wells charles 

toposes triples theories 
der mathematischen wissenschaften 
new york springer 
bird de moor 

algebra programming 
prentice hall 
bird richard 

functional programming haskell 
second edn 
prentice hall 
bird richard paterson ross 

generalised folds nested datatypes 
preparation 
bird richard meertens lambert 

nested datatypes 
pages mathematics program construction 
lecture notes computer science vol 

springer 
clinger rees 

revised report algorithmic language scheme 
acm lisp pointers iv july sept 
de bruijn 

lambda calculus notation nameless dummies 
mathematicae 
jones mark 

technical summary new features hugs 
unpublished 
mccracken 

typechecking programs implicit type structure 
pages semantics data types 
lecture notes computer science vol 

springer 
paterson 

non deterministic lambda calculus core integrated languages 
declarative programming 
springer 
paulson 

ml working programmer 
second edn 
cambridge university press 
peyton jones simon 

glasgow haskell compiler 
department computer science university glasgow 
taha walid sheard tim 

multi stage programming explicit annotations 
pages acm symposium partial evaluation semantics program manipulation 
wadler philip 

theorems free 
pages th conference functional programming languages computer architecture 
ifip 
