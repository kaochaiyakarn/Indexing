higher order concurrency john hamilton reppy ph thesis tr june department computer science cornell university ithaca ny higher order concurrency dissertation faculty graduate school cornell university partial fulfillment requirements degree doctor philosophy john hamilton reppy january copyright fl john hamilton reppy rights reserved higher order concurrency john hamilton reppy ph cornell university concurrent programming useful technique structuring important classes applications interactive systems 
dissertation presents approach concurrent language design provides new form linguistic support constructing concurrent applications 
new approach treats synchronous operations class values way analogous treatment functions class values languages ml 
mechanism set framework language concurrent ml cml concurrent extension standard ml 
cml domain class values called events represent synchronous operations 
synchronous message passing operations provided base event values combinators provided constructing complex events event values 
mechanism allows programmers define new synchronization communication abstractions class citizens gives programmers flexibility tailor concurrency abstractions applications 
dissertation organized technical parts 
part describes design rationale cml shows class synchronous operations implement communication mechanisms concurrent languages 
second part presents formal operational semantics class synchronous operations proves polymorphic type system cml sound 
third part addresses practical issues 
describes cml non trivial applications describes implementation performance cml single processor computer discusses issues related implementation cml shared memory multiprocessor 
memory david reppy foremost parents support love education 
committee members tim teitelbaum bard bloom anil nerode provided feedback research 
especially tim committee chairman teaching cs years ago experience set road computer scientist 
robert cooper committee name provided useful technical criticism 
emden gansner lal george tim griffin dave macqueen cynthia helped proof reading dissertation 
benefited long collaboration members advanced software department bell laboratories 
dave chandra david korn provided support projects emden gansner steve north principal collaborators 
ideas dissertation born bell 
spent hours discussing ideas andrew appel dave macqueen chet murthy prakash panangaden 
sml implementation benefited discussions bill aitken 
people helped way 
pam cliff provided encouragement home away home 
chandra hospitality working bell labs 
liz maxwell helping difficult task tracking advisor jan runs interference cornell bureaucracy computer science graduate students 
research dissertation supported part nsf onr nsf ccr nsf nsf ccr 
iii iv contents case concurrency interactive systems distributed systems overview dissertation design theory practice history sml basics basic values expressions tuples records functions polymorphism datatypes pattern matching datatypes pattern matching lists types imperative features exceptions continuations example functional queues ii design concurrent programming languages processes threads shared memory languages low level synchronization mechanisms monitors shared memory concurrency ml distributed memory languages asynchronous message passing synchronous message passing asynchronous vs synchronous message passing request reply message passing futures message passing ml summary class synchronous operations basic concurrency primitives selective communication vs abstraction class synchronous operations synchronous operations extending pml events guards abort actions cml summary thread garbage collection stream building concurrency abstractions buffered channels multicast channels vi condition variables ada style rendezvous futures iii theory theory preliminaries notation formal semantics syntax dynamic semantics typing properties typed operational semantics cv syntax syntactic sugar dynamic semantics sequential evaluation event matching concurrent evaluation traces fairness extending cv recursion exceptions process join polling typing cv static semantics expression typing rules process typings vii type soundness substitution replacement lemmas subject reduction stuck expressions soundness iv practice applications exene multi threaded window system toolkit overview exene window system overview architecture exene promises exene menus interactive applications distributed systems programming distributed ml applications cml implementation implementation sml nj class continuations compiler run time system implementing threads threads preemptive scheduling implementing channels implementing events event value representation synchronization base event constructors viii event combinators implementing low level support stream implementation improvements performance benchmarks timing results instruction counts analysis garbage collection overhead comparison system multiprocessors parallel programming cml pipelining data flow controlling parallelism speculative parallelism structures structures multiprocessor implementation concurrency control generalized selective communication thread scheduling memory management outlook multiprocessor cml design theory practice ix bibliography appendix proofs chapter proofs chapter proof lemma proof lemma proof lemma list tables sml ground types relating class functions events benchmark machines cml benchmarks mips instruction counts cost abstraction system benchmarks xi list figures queue implementation 
asynchronous message passing rendezvous request reply rendezvous basic concurrency primitives basic event operations primitive synchronous operations cml concurrency operations cml implementation buffered channels cml implementation multicast channels cml implementation condition variables cml implementation ada rendezvous lock manager conditional accept cml implementation conditional entry abstraction cml implementation futures type inference rules grammar cv rules event matching implementing implementing recursion rules matching events process sets core type inference rules cv xii type inference rules cv display message passing architecture screen message passing architecture top level window message passing architecture operation synchronous text scrolling implementation asynchronous text scrolling graph screen dump representation channels implementation send representation event values representation event status event logging implementation implementation transmit low level support crew job decomposition cml implementation structure variables xiii xiv part chapter abstraction important tool programmers managing complexity software design implementation 
various language mechanisms promoting abstraction procedures hiding details computation data types hiding representation information modules grouping related types operations interface 
dissertation describes new language mechanism supporting abstraction communication synchronization concurrent programs 
approach treat synchronous operations class values way analogous treatment functions class values languages ml 
doing small collection primitive operations combinators support wide range different concurrency paradigms 
call style programming higher order concurrent programming analogy higher order programming languages ml 
set context standard ml sml mth 
developed language called concurrent ml cml extends sml multiple threads control class synchronous operations 
cml implemented top standard ml new jersey sml nj system am am 
discussion dissertation uses cml archetype language design principles easily applied higher order languages quest car applicable object oriented languages modula 
case concurrency concurrency touted source improved performance rightly dissertation concurrency important programming tool independent performance benefits multiprocessing 
certain classes applications notably interactive applications naturally structured concurrent programs 
language design dissertation motivated need support programming applications 
going useful define nomenclature 
distinguish parallel concurrent languages provide implicit explicit concurrency 
example futures dialects lisp parallel language feature specify possibility concurrent computation 
am interested programming systems explicit concurrency focus dissertation providing support concurrent programming parallel programming 
remainder section examine important classes applications benefit concurrent programming 
applications share property flexibility scheduling computation required 
sequential languages force total order computation concurrent languages permit partial order provides needed flexibility 
interactive systems providing better foundation programming interactive systems programming environments original motivation line research rg 
naturally concurrent structure interactive systems important application areas cml 
concurrency arises ways interactive systems user interaction 
handling user input complex aspect interactive program 
interactive systems event loop call back functions 
receives input events mouse clicks passes appropriate event handler 
structure poor man concurrency event handlers coroutines event loop scheduler 
multiple services 
example consider document preparation system provides editing formatting 
services independent naturally organized separate threads 
threads provide easy replication services user opens new document editing system just spawns new edit thread 
multiple views document supported replicating threads 
interleaving computation 
user document preparation system may want edit part document part formatted 
formatting may examine issues related multiprocessor implementation cml chapter 
take significant amount time providing responsive interface requires interleaving formatting editing 
editor formatter separate threads interleaving comes free 
output driven applications 
windowing toolkits xlib provide input driven model application code occasionally called response external event 
applications output driven 
consider example computationally intensive simulation maintains graphical display current state 
application monitor window events refresh resize notifications redraw necessary 
sequential implementation handling events postponed simulation ready update displayed information 
separating display code simulation code separate threads handling asynchronous easy 
root cause forms concurrency computer human interaction humans asynchronous slow 
heavy weight operating system processes provides support multiple services interleaved computation address sources concurrency 
likewise event loops call back functions provide flexibility reacting user input bias application input driven model provide support interleaved computation 
concurrent language hand addresses concerns 
distributed systems application area concurrent programming useful distributed systems 
fact existing distributed programming languages toolkits provide support concurrent programming argus ls isis sr 
concurrency needed interaction remote processes slow naturally asynchronous 
threads provide useful abstraction managing outstanding interactions reacting new requests dynamically 
overview dissertation believe important aspects language design 
real problem needs solving design solves 
second firm theoretical foundation design 
third feasibility usefulness design demonstrated practice 
organization dissertation reflects philosophy 
divided parts design theory practice middle parts addressing aspects 
design part presents rationale design concurrency mechanism theory part provides formal understanding mechanism practice part addresses issues feasibility usefulness mechanism 
parts technical part includes chapter sml may skipped reader familiar ml notation part describes areas research summarizes results research 
design design part starts chapter surveys existing approaches concurrent language design 
chapter heart dissertation provides rationale class synchronous operations introduces context cml 
chapter provides substantial examples class synchronizations build communication synchronization abstractions including concurrent languages 
part dissertation fairly self contained familiarity sml syntax useful 
theory sml set precedent practical language real implementations having detailed formal semantics 
developed dynamic semantics small language called cv models concurrency features cml rep 
dissertation extends rep presenting static semantics cv proving sound respect dynamic semantics 
brief summary basic notation chapter illustrates style formal semantics familiar sequential language sequential subset cv chapter presents syntax operational semantics cv main results part chapter polymorphic type system cv show sound respect dynamic semantics chapter 
result important implementation cml uses features sml nj type safe 
knowledge proof soundness polymorphic typing concurrency primitives 
practice final analysis true worth language design determined 
questions usefulness practicality language features answered actual experience 
developed distributed implementation cml single processor computers rep implement non trivial applications 
experience demonstrates cml useful programming language efficient implementations 
chapter describes cml construct multi threaded window system toolkit called exene gr build interactive applications top exene 
briefly discuss application cml programming distributed systems applications cml researchers 
chapter describe implementation cml detail describe possible implementation improvements 
chapter presents results micro benchmarks demonstrate efficiency cml including head head comparison thread library 
data support cml competitive thread libraries implemented lower level languages 
chapter discusses cml parallel programming possible extensions better support parallel programming sketches design shared memory multiprocessor implementation cml 
history ideas dissertation evolving years instantiations language designs 
developed approach context pml rep ml language pegasus system bell laboratories rg gr 
reimplemented concurrency primitives pml top sml nj cornell university rep 
implementation evolved current version cml rep described dissertation 
version released november 
chapter sml ideas dissertation largely language independent developed context standard ml sml 
sml sequential core language design implementation language 
chapter provides sml allow reader follow examples complete see har pau 
formal definition sml mth mt 
remainder chapter introduce basic features sml describe datatype pattern matching mechanisms follow discussion imperative features sml complete example 
basics sml expression language traditional statement constructs blocks conditionals case statements assignment packaged expressions 
expression statically determined type evaluate values type called type soundness 
computation sml value oriented 
central role values larger range values conventional languages 
basic values expressions sml provides fairly standard collection ground types values summarized table 
type unit exactly value written result type functions executed side effects 
negative numbers denoted leading tilde unary negation operator 
imperative languages assignment principal mechanism table sml ground types type sample literal values unit bool true false int string abc hello world real values variables 
sml provide updatable cells see section uses binding principal mechanism associating values variables 
sml variables name values immutable called single assignment example binding val string establishes bindings static environment produced binding assigns type int string type information inferred compiler 
static environment summarized specification val int val string notation specifications comes signatures module system natural concise way describe set bindings 
tuples records addition ground types values sml provides tuples records 
example expression true pair value true product type int bool 
records labeled tuples 
example defined point val case type int int 
note order labeled fields appear insignificant val defines point 
field labeled record selected notation example section illustrates labeled records 
functions polymorphism functions play key role sml 
functions declared leading keyword fun example factorial function defined fun fact fact specification val fact int 
int tail recursion plays role looping sml 
example iterative form factorial function written tail recursive function fun fact fun loop result result loop result loop example introduces expression defining local variables function loop case 
note destructive updates loop variables new values passed invocation iteration copies result 
sml compiler uses type inference determine types expressions 
case functions family types 
example consider identity function fun identity meaning function independent argument type 
viewed function integers strings reals pairs integers polymorphic type ff ff ff ff type variable ranging types 
sml type variables denoted leading 
example value identity specification val identity 
expression just syntactic sugar application tail recursive function 
implicit 
sml compiler infers general type expression 
sml higher order language means functions class values passed arguments embedded data structures returned results 
simple example infix function composition defined sml fun fn 
infix form fn 
way function values written sml familiar calculus fn read 
second line declares infix operator 
infix operator normal identifier prefixing keyword op op 
function composition defined curried form fun declarations composition equivalent specification val 



example expression fn 
fn 
evaluates function computes gamma datatypes pattern matching addition basic values sml provides recursive data structures types 
structured values decomposed powerful pattern matching notation 
datatypes datatype declaration introduces new possibly recursive type 
example representation integer binary trees defined datatype empty leaf int node int declaration says tree empty leaf consisting integer value node consisting integer sub trees 
identifiers empty leaf node called constructors construct tree values 
datatype declarations parameterized define type constructors 
example define family binary tree types definition datatype tree empty leaf node tree tree addition user defined datatypes sml predefined datatypes 
type bool defined datatype bool true false important datatype predefined sml nj polymorphic option type datatype option list type discussed 
pattern matching power datatype declaration mechanism enhanced pattern matching 
pattern matching mechanism control flow value decomposition binding 
example boolean negation function defined clauses fun true false true clause says argument true return false 
second clause wildcard matches case false possibility 
pattern matching standard binding value decomposition mechanism sml seen examples 
example definition function composition fun tuple pattern argument binds element pair second 
interesting example function compute height binary tree fun height empty height leaf height node max height height third clause variables bound subtrees 
pattern matching prolog sml patterns linear variable occur pattern 
pattern matching extract values records 
example function swaps coordinates point datatype point pt int int fun swap pt pt pattern binds field field 
shorthand forms pattern matching records illustrated example fun xcoord pt 
field name shorthand lieu rest fields 
pattern matching literals 
example recursive factorial function coded follows fun fact fact fact addition equational definitions functions pattern matching general form case expression 
lists important recursive types polymorphic list type defined datatype list nil list infix datatype declaration defines list empty nil cons element list 
infix declaration specifies cons operator right associative infix operator precedence level 
importance lists sml provides special syntax list patterns expressions 
syntax syntactic sugar en nil likewise patterns 
function inserts delimiters adjacent list elements example notation fun fun insert insert insert insert insert second clause function illustrates pattern form case binds single element list matched 
number standard list functions provided sml nj dissertation 
val length list 
int val map 

list 
list val app 

list 
unit val rev list 
list function length returns length list map applies function list returning list results app applies function list discarding results rev reverses list 
types abstype declarative form variation datatype declaration limits visibility type representation 
time honored example datatype stack abstype stack stk list val empty stk fun push stk stk fun pop stk stk representation stack visible outside type stack 
abstype mechanism dissertation lieu sml module facility easier understand 
elaborate example types section 
addition abstype declaration local declaration limit scope declarations 
example stack declared local datatype stack stk list type stack stack val empty stk fun push stk stk fun pop stk stk technical differences declarations scope dissertation 
imperative features sml applicative small collection imperative features 
important exceptions addition sml nj provides class continuations 
mutable heap cells 
created function ref updated examined function 
example binds functions share common cell val get put val cell ref fn 
cell fn 
cell operations signature val ref 
ref val ref 
val ref 
unit ref function really constructor pattern matching feature dissertation 
notation type ref means imperative type polymorphic similar applicative non imperative type 
technical restriction required prevent type loopholes 
full technical details imperative types scope chapter discussion imperative types tofte describes great detail tof tof 
sml nj uses flexible scheme typing polymorphic called weak polymorphism 
idea assign rank strength type variables 
roughly rank type variable number abstractions protect value type normal type variables rank 
example type ref sml nj val ref 
ref integer type variable name denotes rank 
cml implemented top sml nj interfaces weak types 
details weak polymorphism important dissertation necessary recognize functions weak types fully polymorphic 
theoretical treatment part iii uses standard imperative type system 
exceptions sml exception mechanism signaling run time errors exceptional conditions 
aspects exception mechanism representation exception packets control flow raising handling exceptions 
built type exn type exception packets created special kind datatype constructors 
declaration exception foo bar int declares new exception constructors exception specifications syntax 
exception packets values datatype handling exceptions pattern matching mechanism match exceptions 
example implementation integer division returns divisor fun div handle div 
exception raised raise expression 
example function computes product list integers uses exception zero short circuit evaluation encountered fun product exception zero fun loop loop raise zero loop loop loop handle zero 
dissertation uses monomorphic exceptions possible declare polymorphic exception constructors 
fully polymorphic exceptions result type loopholes exceptions weakly polymorphic imperative types 
continuations sml nj provides class continuations extension heavily implementation cml see chapter 
continuation function represents rest program gor 
programming language scheme rc continuations accessible programmer class values 
scheme function current continuation call cc short calls function current continuation argument 
class continuations supported sml nj type primitive functions type cont val callcc cont 

val throw cont 

implement loops back tracking exceptions various concurrency mechanisms wan engines dh 
example continuation version product function previous section fun product callcc fn exit 
fun loop loop throw exit loop loop loop function uses continuation exit short circuit evaluation encountered 
idea dates back landin operator lan fel 
example functional queues wrap sml consider implementation fifo queue type 
signature abstraction type queue val empty queue val isempty queue 
bool val insert queue 
queue exception val remove queue 
queue value empty empty queue isempty returns true argument empty queue insert adds item queue remove removes head queue 
exception raised remove applied empty queue 
abstraction functional mutating shared queue object operations insert remove return new queue values results 
implementation abstraction 
internally queue abstype queue front list rear list val empty front rear fun isempty front rear true isempty false fun insert front rear front front rear rear exception fun remove front rear raise remove front rear remove front rev rear rear remove front rear front rear rear abstype queue implementation 
represented constructor applied record fields front rear stacks represented lists 
insert operation pushes value rear stack remove operation pops value front stack 
case front empty remove pushes elements rear stack front reverse order 
part ii design chapter concurrent programming languages order understand trade offs language design necessary know alternatives 
chapter survey representative collection concurrency features languages 
purpose dissertation important language characteristics synchronization communication primitives 
divided main classes shared memory primitives distributed memory message passing primitives 
chapter brief discussion process creation mechanisms focus different classes concurrent languages discuss appropriateness various design alternatives adding concurrency sml 
number surveys concurrent language design 
comparison different concurrency mechanisms example problems bd 
andrews schneider survey broad range concurrency mechanisms wegner smolka compare csp ada monitors ws andrews covers concurrent programming various different languages 
collection significant reprints papers concurrent languages programming including ws gm 
discussed chapter dissertation concurrent language design survey parallel implementations lazy languages mar parallel languages id nik distributed languages argus ls sr 
discuss concurrent logic programming concurrent constraint languages sr 
literally hundreds different concurrent programming languages complete survey impossible 
processes threads specification creation processes concurrent programming language usually see section orthogonal communication synchronization mechanisms 
process creation static set processes fixed text program dynamic mechanism provided creating new processes fly 
process concurrent program independent thread control term thread process 
added advantage avoiding confusion meanings word process 
favor term thread context formal semantics process conventional term 
example static process creation cobegin statement form cobegin stmt stmt stmt coend statement proceeds executing statements parallel synchronizing completion statements 
language recursion statement create dynamic tree parallelism limited lifetimes processes tied children lifetimes 
dynamic process creation usually involves fork operation called spawn takes statement procedure argument creates new process execute 
fork operation accompanied join operation allows parent synchronize child termination 
fork join cobegin construct implemented fork stmt fork stmt delta delta delta pn fork stmt join join delta delta delta join pn dynamic process creation allows flexible processes 
example server want create new thread handle request 
language static set processes requires pool server threads reusing 
awkward limits number simultaneous requests handled chapter algol style notation languages discuss roots algol family languages 
lead unnecessary delays handling requests 
writing concurrent programs language static process creation similar problem writing programs dynamic data structures language provides static memory allocation 
strong reason static process creation reasons favor dynamic creation 
shared memory languages shared memory languages mutable shared state shared variables implement process communication 
key problem languages preventing processes interfering 
problem characterized classic example cobegin coend guarantee atomicity resulting value undefined 
assignments examples critical regions regions code potential sources interference proper concurrency control 
shared memory languages distinguished mechanisms provide synchronization concurrency control 
illustrate unique id service running example 
low level synchronization mechanisms basic synchronization mechanism semaphore special integer variable operations semaphore execution process forces delay point executes gamma proceeds test update done atomically 
execution results atomic execution 
semaphores unique id service implemented var integer semaphore delta delta delta procedure integer var result integer result return result semaphore guarantee mutual exclusion accesses problem semaphores linguistic support correct 
example programmer easily forget apply operators forget protect shared state 
furthermore implementing patterns synchronization complicated mutual exclusion tricky 
restricted form semaphore mutex lock called binary semaphore variable states locked unlocked 
advantages mutex locks naturally supported test set instruction multiprocessors 
language modula nel supports mutex locks special syntax 
lock statements statement executed acquiring mutex lock executing statements body releasing lock 
exception occurs execution body lock released 
modula unique id service implemented var integer mutex new mutex delta delta delta procedure integer var result integer lock result return result call acquires mutex lock executes critical section releases lock returning 
mutex locks sufficient insuring mutual exclusion critical regions provide general synchronization mechanism 
example consider producer consumer processes share fixed size buffer 
buffer empty consumer wait producer add likewise buffer full producer wait consumer remove 
mutex locks requires polling buffer inefficient 
alleviate problem modula provides condition variables allow processes wait specific conditions buffer non empty 
mutex contraction mutual exclusion 
modula inherits primitives modula 
condition variables effect reintroduce counting power general semaphores lost moving mutex locks 
threads package built top mach operating system provides style concurrency support cd 
monitors monitor module encapsulates shared state providing set exported procedures controlled access state hoa 
monitors provide structured form mutual exclusion mutex locks 
monitor implicit mutex lock acquired entry released exit monitor procedure 
guarantees monitor procedure call mutually exclusive call 
monitor unique id server coded follows monitor uid var integer procedure integer var result integer result return result extra syntactic support provided monitors leaves room programmer error case semaphores mutex locks 
mutex locks condition variables avoid polling 
number languages concurrent pascal bri concurrent euclid hol mesa mms lr provide monitors condition variables 
interesting note trend concurrent language design away syntactic sugar monitors explicit mutex locks mesa modula modula 
trend represents simplification language design separates orthogonal language features modules mutual exclusion 
shared memory concurrency ml shared memory concurrent languages rely mutable state inter process communication 
leads imperative programming style goes traditional applicative style ml programs 
reason shared memory primitives notationally unsuitable general purpose concurrency extension ml useful low level implementation 
contrast show message passing fits quite naturally ml programming style 
cooper morrisett carnegie mellon university developed concurrency package called ml threads provides threads mutex locks condition variables cm 
design ml threads owed threads package cd turn owes design 
goals approach significantly different research 
example principal applications construction low level operating system services requires heavy shared state chl 
ml threads implement subset cml primitives 
implementation ml threads sgi multiprocessor mor 
distributed memory languages major class concurrency primitives distributed memory called message passing 
basic operations message passing send message accept message communication synchronization 
message passing languages distinguished naming mechanism communication medium amount synchronization involved sending message 
naming mechanism specify ends communication sender receiver 
simplest naming convention uses process names designate communication partner 
slightly general scheme introduces multiple communication ports associated receiver 
generalized making port names independent values called channels 
process access channel may send accept messages variant scheme differentiates input output access 
process structure naming mechanism static dynamic 
static naming common number languages severe limitations 
example impossible write procedures parameterized sender receiver name 
adding message passing ml communication medium strongly typed 
requirement means process names name communications restrictive scheme process receive messages fixed type 
ports channels name communications avoids problem port channel message type 
dynamic nature ml values dynamic port channel creation mechanism suitable 
message accept operation usually blocking languages systems provide polling mechanism check incoming messages 
basic choices message sending semantics non blocking send asynchronous send blocking send synchronous send send reply 
unidirectional bidirectional 
discuss increasing order synchronization 
asynchronous message passing asynchronous message passing communication medium buffered send operation non blocking 
gives pictorial description asynchronous communication processes diagram process time line hj send accept phi phi phi phi phi phi phi phi phi phi send accept hj send accept asynchronous message passing running page communication represented arrow sender time line time line 
notice picture different views order events 
actor languages example programming languages asynchronous message passing agh 
message passing distributed systems usually asynchronous 
fact systems arbitrary message delays failure possible distinguish failure communication partner slow line synchronous communication impossible flp 
systems finite buffers case send operation block buffer full 
synchronous message passing hoare seminal hoa introduced notion set sequential processes running parallel communicating synchronous message passing 
hoare language called csp communicating sequential processes provides input operations read value process assign output operations send value expression process labeled cobegin statement process creation 
process communication structures csp programs static dynamic process creation process names name communications 
process executes block process executes vice versa 
matching communications called rendezvous illustrated 
dotted time lines delta delta delta delta delta delta delta delta delta waits delta delta delta delta delta delta delta delta delta waits rendezvous represent idle periods waiting matching communication 
key ideas csp notion selective communication called guarded communication 
hoa selective communication generalization dijkstra guarded commands dij input operations allowed guards 
input guard matched action may chosen input guard matched chosen nondeterministically 
mechanism provides ability process communicate multiple partners order communications unknown 
example server process multiple clients may know client send request 
languages provide polling alternative selective communication polling result busy waiting avoided gc 
natural generalization selective communication mechanism csp allow input output operations 
called generalized symmetric selective communication 
simple example useful consider system processes supposed send message generalized select priori choose process send message 
sends message accepting message waiting message accepting message send avoid deadlock 
words implementation depends communication patterns example illustrates lack generalized selective communication negative impact program modularity 
arguments usefulness selective communication hoa fy rep section 
significant argument generalized selective communication difficulty implementing multiprocessor machines ks section discusses problem detail 
language occam inm bur derived csp includes channels limited form dynamic process creation 
higher order language amber car provides generalized selective communication typed channels dynamic process channel creation 
languages owe intellectual debt csp include joyce bri pascal ab 
pared version csp called theoretical study concurrent systems hoa 
asynchronous vs synchronous message passing glance asynchronous communication may best choice concurrent language minimizes interprocess synchronization restrict parallelism wait 
language dynamic thread creation possible efficiently implement asynchronous channel thread buffer communication cf section 
big problem asynchronous communication sender way knowing message received introducing messages loses parallelism main benefit asynchronous communication 
synchronous message passing sender receiver common knowledge message transmission sender knows receiver knows sender knows message accepted 
property synchronous message passing easier reason 
reflected typical failure modes erroneous programs 
asynchronous systems typical failure mode overflow memory buffer messages far removed time possibly place source problem 
language dynamic thread creation example programmed forking threads send messages examples dynamic process creation sufficient 
synchronous systems typical failure mode deadlock immediate easily detected 
detecting fixing bugs easier synchronous system 
asynchronous message passing increases likelihood timing sensitivity race conditions 
producer consumer protocol example producer faster consumer number buffered messages grow arbitrarily 
buffer finite system eventually degrades synchronous system buffers unbounded memory overflow may occur 
means additional acknowledgment messages reduces efficiency gains asynchronous communication 
request reply message passing procedure call style interaction called remote procedure call nel implemented asynchronous synchronous message passing 
procedure entry corresponds request message client server procedure return corresponds reply message server client 
shows timing diagrams mechanism assuming synchronous message passing 
server handling call client call delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta server accept request oe reply client waits client call delta delta delta delta delta delta delta delta delta server accept delta delta delta delta delta delta delta delta delta request oe reply server waits request reply rendezvous accept requests calls necessarily mutually exclusive 
languages ada dod concurrent gr concurrency libraries system bs style bidirectional message passing communication author personal experience backs 
early version pegasus system rg asynchronous message passing great difficulty debugging programs 
experience implementation exene gr hand demonstrates large synchronous messagepassing programs debugged fairly easily debugging tools 
mechanism 
languages server thread plays role similar monitor see section 
ada example task ada term process exports collection transactions called entries ada clients invoke normal procedure calls 
server uses select statement enable multiple entries simultaneously similar csp selective communication input operations allowed select statement 
illustrate unique id server example section programmed ada follows task body integer loop select accept result integer result select loop example operation select statement really necessary server supported operations additional accept clauses added 
language concurrent provides richer form ada select mechanism 
syntax entry clause select statement accept entry suchthat pred phrases enclosed optional pred boolean expression integer expression 
optional suchthat clause requests satisfy pred accepted 
optional clause expression evaluated outstanding request request minimum value selected 
request reply paradigm quite useful concurrent programming believe heavy weight mechanism basis concurrent language 
example needs program unidirectional communication bidirectional mechanism unnatural 
course argue programming bidirectional communication unidirectional message passing unnecessarily complex show chapter possible support higher level abstractions rpc class citizens language unidirectional message passing 
key provide flexible mechanism building new communication synchronization abstractions 
futures various concurrent dialects lisp scheme mechanism called futures hal kh specifying parallel evaluation expressions 
futures combine thread creation communication synchronization single mechanism 
lisp expression exp body evaluates spawning thread evaluate exp binding placeholder body 
computation exp complete result put placeholder 
thread attempts access called touching synchronize availability value 
important aspect mechanism variable bound touches implicit run time check required variable access compiler optimization reduce cost 
futures designed support concurrent programming designed parallel programming mechanism 
main limitation concurrent programming notation provide chance communication synchronization parent child threads 
multilisp hal provides shared memory lowlevel locking mechanisms essentially test set supporting patterns communication synchronization 
communication synchronization mechanisms conjunction futures lead problems implementations consider optional new thread gets spawned example mul kh 
futures useful addition ml support parallel programming see chapter reasonable base concurrent language design 
message passing ml addition efforts integrate message passing ml hol mat ram 
supported csp style message passing synchronous 
message passing useful base concurrent programming support common styles concurrency pipelining threads arranged data flow network km server client interactions 
treating communication channels infinite streams individual threads written applicative style ab consistent ml style programming 
fact cml programs tend far fewer sequential sml programs point illustrated chapters 
common argument message passing compared shared memory primitives provides inferior performance 
true single processor systems empirical evidence suggests message passing programs provide better performance shared memory multiprocessors ls 
reason messagepassing programs typically better locality map better non uniform memory structure modern shared memory multiprocessors 
summary number design criteria drawn discussion 
concurrent extension ml characteristics ffl dynamic thread creation 
ffl synchronous communication typed channels ports 
channels general ports prefer 
ffl dynamic channel creation 
ffl support generalized selective communication 
way existing languages support mechanisms completely satisfactory 
problem support communication special operations special syntax providing mechanism building new communication synchronization abstractions 
chapter describe limitations detail approach concurrent language design addresses 
chapter class synchronous operations chapter describes central result dissertation new approach concurrent language design synchronous operations treated class values 
developed approach part design concurrent language pml rep 
pml provided collection concurrency features similar amber car typed channels dynamic thread channel creation rendezvous generalized selective communication 
design pml broke new ground providing class synchronous operations 
basic idea class synchronous operations introduce domain firstclass values called events representing synchronous operations 
constructor functions provided build base event values represent primitive operations channel combinators provided combine event values higher level synchronous operations 
design cml rep rep builds approach providing powerful version events 
addition cml provides number features pml garbage collection threads integrated support 
chapter organized chronologically historical evolution language design 
introduce basic set concurrency primitives similar amber 
motivate subset cml called pml events sufficient implement primitives csp style languages 
pml subset limitations motivate extensions developed part cml 
summarize features cml provide basis examples chapters 
leave presentation extended examples chapter series examples events build higher level synchronization communication abstractions 
basic concurrency primitives start discussion basic concurrency operations provided cml 
running cml program consists collection threads synchronous message passing typed channels communicate synchronize 
keeping flavor sml threads channels created dynamically initially program consists single thread 
signature basic thread channel operations 
function spawn takes function argument creates new thread val spawn unit 
unit 
threadid val channel unit 
chan val accept chan 
val send chan 
unit basic concurrency primitives evaluate application function unit value 
channels created dynamically function channel weakly polymorphic 
functions accept send synchronous communication operations 
thread wants communicate channel rendezvous thread wants complementary communication channel mechanism described section 
sml lexical scoping share channels threads hide channels threads note channels passed messages 
simple example primitives unique id service previous chapter 
cml implemented follows abstype uid int chan fun val ch channel fun loop send ch loop spawn fn 
loop uid ch fun uid ch accept ch abstraction provides function creating new source unique ids weak polymorphism necessary avoid loop holes type system see chapter details 
operation getting unique id source 
source unique ids represented channel function dynamically creates channel thread sends stream unique ids channel 
function reads id stream 
implementation example threads encapsulate state note side effects concurrency operations 
style programming applicative shared memory primitives cf section 
selective communication vs abstraction section discussed arguments providing generalized selective communication section describe significant limitation forms selective communication existing languages 
problem fundamental conflict selective communication abstraction 
example consider server thread provides service request reply rpc protocol 
server side protocol fun val request accept reqch send replych doit request function doit implements service 
note service available 
protocol requires clients obey rules 
client send request trying read reply 

request client read exactly reply issuing request 
clients obey rules guarantee request answered correct reply client breaks rules requests replies sync 
obvious way improve reliability programs service bundle client side protocol function hides details ensuring rules followed 
code implements abstraction fun send reqch accept replych insures protocol observed hides 
client blocks call server available respond communications 
avoiding situation requires selective communication client function abstraction hides synchronous aspect protocol 
fundamental conflict selective communication existing forms abstraction 
operation lose flexibility selective communication expose protocol allow selective communication lose safety ease maintenance provided abstraction 
resolve conflict requires introducing new abstraction mechanism preserves synchronous nature abstraction 
class synchronous operations provide new abstraction mechanism 
class synchronous operations traditional select construct facets individual operations actions associated operation nondeterministic choice synchronization 
approach dissertation facets introducing new type values called events represent synchronous operations 
starting base event values represent communication operations providing combinators associate actions events build nondeterministic choices events flexible mechanism building new synchronization communication abstractions realized 
event values provide mechanism building representation protocol obscuring synchronous aspect 
concrete consider loop amber style select construct car implements body accumulator accepts addition subtraction input commands offers contents fun accum sum select 
accum sum 
accum sum sum 
accum sum select construct consists operations sum 
operations associated action right hand side 
taken operation associated action define clause nondeterministic synchronous choice 
worth noting input clauses define scope input operation binds identifier incoming message action scope 
gives signature event operations corresponding facets generalized selective communication 
functions receive transmit build base val receive chan 
event val transmit chan 
unit event val choose event list 
event val wrap event 

event val sync event 
basic event operations event values represent channel operations 
wrap combinator binds action represented function event value 
choose combinator composes event values nondeterministic choice 
operation sync forces synchronization event value 
call set operations pml events constitute mechanism originally developed pml rep 
simplest example events implementation synchronous channel operations described previous section 
defined function composition sync channel event value constructors val accept sync receive val send sync transmit substantial example accumulator loop implemented fun accum sum sync choose wrap receive fn 
accum sum wrap receive fn 
accum sum wrap transmit sum fn 
accum sum notice wrap associate actions communications 
great benefit approach concurrency allows programmer create new class synchronization communication abstractions 
example define event valued function implements client side rpc protocol previous section follows fun wrap transmit reqch fn 
accept replych applying value send request server returns event value send server accept server reply 
event value choose expression communications case transmit base event value selecting event 
example shows class synchronous operations away details client server protocol hiding synchronous nature protocol 
approach synchronization communication leads new programming paradigm call higher order concurrent programming 
understand higherorder nature mechanism helpful draw analogy class function values 
table relates features higher order mechanisms 
values table relating class functions events property function values event values type constructor 
event abstraction receive transmit elimination application sync combinators op choose map wrap function type introduced abstraction event values created constructors 
function values eliminated application analogously event values eliminated sync operator 
types combinators building new values 
analogy hold completely various function combinators derived forms event value combinators primitive 
synchronous operations event type provides natural framework accommodating primitive synchronous operations 
examples cml synchronization thread termination called process join low level support time outs 
gives signature cml base event constructors synchronous operations 
function wait produces event synchronizing termination thread 
servers need release resources allocated client case client terminates unexpectedly 
support low level provided functions allow threads synchronize elimination type theoretic sense 
refer syntactic constructs introduce eliminate type constructor 
reason term event refer class synchronous operations communication val wait threadid 
unit event val int 
unit event val int 
unit event val time 
unit event val timeout time 
unit event primitive synchronous operations status file descriptors uni 
operations cml implement multi threaded stream library section 
functions synchronizing clock timeout 
function returns event synchronizes absolute time timeout implements relative delay 
function timeout implement timeout choice 
code example defines event waits second message channel choose wrap receive ch wrap timeout time sec usec fn 
having uniform mechanism combining synchronous operations cml provides great deal flexibility fairly terse mechanism 
comparison ada different timeout mechanisms time entry call clients delay statement servers include select 
extending pml events far described pml subset class synchronous operations 
section motivate describe significant extensions pml events provided cml 
consider protocol consisting sequence communications delta delta delta protocol packaged event value designated commit point communication event chosen selective communication message send operation abstraction 
pml events possible commit point wrap construct allows tack delta delta delta chosen way commit point 
asymmetry serious limitation original mechanism 
illustration problem server implements input stream abstraction 
abstraction smoothly integrated concurrency model input operations event valued 
example function val input 
string event read single character 
addition input operations 
assume implementation operations uses protocol successful input operation involves communication sequence send ch req accept ch reply packaging event section send communication commit point wrong semantics 
illustrate problem consider case client thread wants synchronize choice reading character second timeout sync choose wrap timeout time sec usec fn 
raise timeout input server accept request second limit wait input indefinite 
right semantics input operation requires making accept commit point possible pml subset events 
address limitation cml provides guard combinator 
guards guard combinator dual wrap bundles code executed commit point code include communications 
type val guard unit 
event 
event guard event essentially suspension forced sync applied 
simple example guard timeout function described implemented guard fun timeout guard fn 
currenttime currenttime returns current time 
languages support guarded clauses selective communication guards boolean expressions evaluate true order communication enabled 
cml guards purpose illustrated code skeleton sync choose delta delta delta guard fn 
pred evt choose delta delta delta evt part choice pred evaluates true 
note evaluation pred occurs time guard function evaluated 
returning rpc example build rpc operation reply commit point 
different versions fun wrap transmit reqch fn 
accept replych fun guard fn 
send reqch receive replych version commits server acceptance request version commits server reply request 
note duality guard wrap respect commit point 
guards generate requests raises couple problems 
server guarantee requests accepted promptly evaluating guard may cause delays 
solution spawn new thread issue request asynchronously fun guard fn 
spawn fn 
send reqch receive replych alternative server clearing house requests spawning new thread handle new request 
problem serious rpc event selective communication event chosen 
server avoid blocking forever sending reply 
idempotent services handled having client create dedicated channel reply having server spawn new thread send reply 
client side protocol fun guard fn 
val replych channel spawn fn 
send reqch replych receive replych server sends reply evaluates spawn fn 
send replych reply client chosen different event thread blocks garbage collected 
services idempotent scheme sufficient server needs way abort transaction 
combinator provides mechanism described section 
abort actions combinator associates abort action event value 
semantics event chosen sync operation new thread spawned evaluate abort action 
type combinator val event unit 
unit 
unit second argument abort action 
combinator complement wrap sense view base event choice having wrapper abort action sync applied wrapper chosen event called threads spawned abort actions base events 
implement rpc protocol non idempotent services 
client code rpc abort allocate channels reply abort message fun guard fn 
val replych channel val channel fun send spawn fn 
send reqch replych receive replych server ready reply commit transaction synchronizes event value choose wrap receive fn 
abort transaction wrap transmit replych reply fn 
commit transaction mechanism implement concurrent stream library cml see section 
cml summary far touched highlights cml concurrency mechanisms 
section give summary features cml 
provides background rest dissertation 
section language tutorial discussion see rep 
gives signature cml concurrency operations including described 
val spawn unit 
unit 
threadid val channel unit 
chan val threadid threadid 
bool val channel channel 
bool val accept chan 
val send chan 
unit val choose event list 
event val guard unit 
event 
event val wrap event 

event val event exn 

event val event unit 
unit 
event val sync event 
val select event list 
val poll event 
option val 
event val receive chan 
event val transmit chan 
unit event val time 
unit event val timeout time 
unit event val int 
unit event val int 
unit event cml concurrency operations functions test equality thread ids channels 
addition wrap combinator combinator wraps exception handler event 
example raises exception file specified argument closed 
robust version defined fun fd wrap fd fn 
true fn 
false synchronization returns true input available false file closed 
operation select short hand common idiom applying sync choice events val select sync choose operation poll non blocking form sync returns case sync blocked 
form polling different rep rep rep 
earlier versions polling handled constructing polling event values 
semantics approaches difficult specify implementation complicated furthermore practice rare uses polling combination immediate application sync 
reasons adopted simpler polling operation 
base event constructor takes argument builds event available argument synchronization result 
example infinite stream implemented 
useful compare function fun poll evt select wrap evt poll supplied function fun fun loop case 
loop 
loop applying poll result infinite execution sequences applying poll terminate 
section describes semantics poll function 
specifically rep rep done special base event value called lower priority events 
rep done special event value constructor 
thread garbage collection important property cml programs automatic reclamation concurrency objects threads channels 
general thread communicates infinitely block garbage collected disconnected active part system 
property benefits 
allows threads implement objects unique id source having worry termination protocols 
object representation channels connecting discarded channels thread reclaimed garbage collector 
second allows speculative message passing complex protocols spawning thread send message may accepted 
channel local instance protocol guaranteed garbage collected section 
stream cml provides concurrent version sml stream primitives 
input operations version event valued allows selective communication 
example application may give user seconds supply password 
programmed fun sync choose wrap timeout time sec usec fn 
wrap stdin return user fails respond seconds wraps user response 
streams implemented top primitives described chapter section describes implementation detail 
chapter building concurrency abstractions different applications require different abstractions programming styles 
modern programming languages provide mechanisms allow programmers design implement appropriate data procedural abstractions applications comes concurrency operations programmers stuck decisions language designer 
class synchronous operations allow programmers flexibility design implement right concurrency abstractions applications 
chapter demonstrate utility class synchronous operations showing various useful abstractions implemented 
abstractions include mechanisms languages asynchronous channels ada style rendezvous futures 
addition abstractions proven useful real applications 
examples provide illustration cml programming notation 
chapter includes additional examples applications implemented cml 
buffered channels buffered channels provide mechanism asynchronous communication similar actor mailbox agh 
source code abstraction 
function buffer creates new buffered channel consists buffer thread input channel output channel function asynchronous send operation function event valued receive operation 
buffer represented queue messages implemented pair stacks lists 
example illustrates key points abstype bc inch chan chan fun buffer val inch channel channel fun loop loop accept inch loop front rear select wrap receive inch fn 
loop front rear wrap transmit fn 
loop rear loop rear loop rev rear spawn fn 
loop bc inch inch fun bc inch send inch fun bc 
receive abstype cml implementation buffered channels ffl buffered channels new communication abstraction class citizenship 
thread function context built function receive selective communication 
ffl buffer loop uses input output operations selective communication 
example necessity generalized selective communication 
multiplexed input construct occam alt request reply protocol implement server side operation see pp 
bur example 
request reply protocol operation selective communication client 
ffl buffer thread example common cml programming idiom threads encapsulate state 
style additional benefit hiding state system concurrency operations sequential code cleaner 
threads serve role monitors shared memory concurrent languages 
ffl implementation exploits fact unreachable blocked threads garbage collected 
clients buffer discard buffer thread channels reclaimed garbage collector 
improves modularity abstraction clients worry explicit termination buffer thread 
complete version abstraction included cml distribution number applications 
multicast channels useful abstraction buffered multicast channel builds buffered channels providing fan 
multicast channel number output ports 
thread sends message multicast channel replicated output port 
addition standard channel operations create send accept operation create new ports 
signature gives multicast channel interface type val unit 
val newport 
event val multicast 
unit new multicast channels created new ports newport 
multicast operation asynchronously broadcasts message ports multicast channel 
port represented event value synchronizing port event return multicast message 
multicast channel consists server thread initiates broadcast creates new ports chain ports 
port consists buffer tee thread inserts incoming message buffer propagates port 
port buffer implemented buffered channel 
picture gives schematic view multicast channel ports multicast server multicast newport buffer port port buffer port buffer port implementation multicast abstraction 
function interesting includes code server thread 
multicast channel value represented request reply channel pair provides interface server thread 
request message broadcast request new port 
interface server thread port chain interface tee thread port output function 
output function chain sink 
condition variables simple new abstraction condition variable write variable 
condition variable initially empty thread writes value full 
reading empty condition variable blocking operation writing full error 
cml condition variables interface type condvar val condvar unit 
condvar val condvar 
event val readvar condvar 
val writevar condvar 
unit exception name motivated conditions shared memory concurrent languages 
abstype request chan event chan request message newport fun val reqch channel channel fun val buf buffer val inch channel fun tee val accept inch buf tee spawn tee fn 
send inch buf fun server fun newport val port send port message server sync wrap receive reqch spawn fn 
server fn 
reqch fun newport reqch send reqch newport accept fun multicast ch send ch message cml implementation multicast channels reading condition variable synchronous operation event valued form operation provided 
exception raised thread attempts write full variable 
condition variables example called structures parallel language id anp nik regarded weak form logic variable 
condition variable implemented cml thread hold state variable shown 
versions cml provide condition variables datatype condvar cv chan chan fun condvar val channel channel fun cell val accept fun loop send loop loop spawn cell cv exception fun writevar cv select wrap receive fn 
raise transmit fun cv 
receive fun readvar cv 
accept cml implementation condition variables primitive concurrency object 
part internally implement provide significant performance boost see chapter case exactly message sent abort messages see section 
ada style rendezvous section describe implementation communication mechanisms ada concurrent described section basic operation extended rendezvous consists entry call client server thread 
ada concurrent call asymmetric server nondeterministically select choice accept clauses client entry call involved selective communication 
problem supporting entry calls selective communication cml question synchronous operations sending request accepting reply commit point 
various alternatives discussed detail section example arbitrarily choose sending request commit point 
gives cml code abstraction basic ada communication mechanism 
implementation general abstype entry entry chan chan fun entry entry channel fun entry reqch guard fn 
val replych channel wrap transmit reqch replych fn 
accept replych fun entry reqch wrap receive reqch fn replych 
fn 
send replych cml implementation ada rendezvous ada mechanism ways 
allows nested transactions reply channels dynamically allocated permits selective entry calls function 
allows multiple servers entry 
interface abstraction type entry val entry unit 
entry val entry 

event val entry 

unit event note function returns entry call argument reply function 
example abstraction cml version implementation unique id server section fun val entry fun loop val reply sync reply loop spawn fn 
loop systems programming necessary deal possibility expected event occur 
ada supports variations basic rendezvous mechanism delay clause server select statement timed entry call conditional entry call 
easily implemented cml 
timeout event implement delay clause choice entry call timeout event implements timed entry call applying poll entry call implements conditional entry call 
language concurrent provides couple additional twists ada rendezvous mechanism 
recall section concurrent entry clauses may include predicate requests priority ordering requests 
possible implement operations cml reasons discussed possible supporting entry calls generalized selective communication 
illustration describe implementation entry abstraction supports conditional acceptance entry calls argument value 
signature abstraction type entry val entry unit 
entry val entry 

bool 

unit event val call entry 

function entry builds new entry object function take entry object predicate returns entry event function call clients call entry 
lock manager example conditional accept taken gr 
request acquire lock accepted lock currently held 
status locks represented list lock ids currently held locks 
implementation conditional accept abstraction 
entry object realized buffer thread matches calls conditional accept offers 
fun val entry val fun locks fun id id locks 
fun unlock id remove id locks 
select wrap fn id reply 
reply id locks wrap receive fn id 
unlock id spawn fn 
call fn id 
send id lock manager conditional accept channels communicate buffer thread clients request entry call servers offer conditional acceptance 
call consists argument reply operation curried application send reply channel acceptance offer consists predicate channel sending call server abort event notifying buffer offer withdrawn 
acceptance offer matches call predicate contained offer returns true applied argument call 
buffer keeps list outstanding calls outstanding offers invariant buffered calls offers match 
new call comes attempt match outstanding offer likewise new offer comes attempt match outstanding call 
match buffer check see offer withdrawn 
done function synchronizes choice offer abort event transmitting call server 
semantics abort actions guarantee exactly choices available selection 
point interest buffer thread main loop synchronizes choice receiving new call receiving new offer notified withdrawal offer 
implementation easily extended order requests priority function 
timed entry call supported allowing clients request call abstraction allows multiple servers share entry object 
local datatype offer pred 
bool reqch 
unit chan unit event abstype entry entry chan 
unit chan fun entry val channel channel exception fun buffer calls offers fun call offer reqch 
select wrap fn 
false wrap transmit reqch call fn 
true fun offer offer pred 
fun raise call pred call offer call val arg calls offers handle 
calls offers offer buffer arg fun call fun raise offer offer pred pred call offer offer val arg calls offers handle 
calls call offers buffer arg continued 
cml implementation conditional entry abstraction continued fun withdraw offer reqch reqch 
fun remove offer reqch 
reqch reqch rest remove remove offers fun offer offer 
wrap fn 
buffer calls withdraw offer select wrap receive wrap receive choose map offers entry fun entry 
pred guard fn 
val reqch channel channel send offer pred pred reqch reqch receive receive reqch fn 
send fun call entry 
val replych channel send fn 
send replych accept replych abstype local withdrawn timeout 
buffer receives request matched call offer discard outstanding call 
lock manager example cited gr example need suchthat clause 
claim mechanism lock manager requires separate thread transactions lock unlock request 
real problem concurrent ada rendezvous mechanism allow server thread accept entry call time 
cml problem lock server keep list pending lock requests lock 
conditional entry abstraction particularly useful example illustrates interesting points including serious limitation cml primitives 
basic ada rendezvous possible implement event valued function nice richer abstraction 
unfortunately requires way insure threads client buffer server simultaneously reach agreement rendezvous acceptance particular call 
client server involved selective communication back minute selecting choice 
limitation inherent mechanism class synchronous operations synchronous channel communication provides way rendezvous 
primitive synchronous operation supplied multiway rendezvous cha abstractions conditional accept supported generalized communication 
argued conditional accept useful abstraction examples problem arises 
typically involve thread implement synchronous channel richer semantics 
example nice version channels logged messages debugging purposes 
natural way thread implement logging channel abstraction way rendezvous logging channels support generalized selective communication 
problem topic research 
futures final example chapter mechanism multilisp see section 
touching synchronous operation represent futures directly event values 
operation type val 


event multiway rendezvous instance committee coordination problem cm 
sync touch operator 
implementation see straightforward spawn new thread evaluate application create condition variable reporting result 
evaluation result raised exception fun datatype result exn exn val condvar spawn fn 
writevar result handle ex 
exn ex wrap fn result 
exn ex 
raise ex cml implementation futures result condition variable holds result exception 
part iii theory chapter theory preliminaries part dissertation focuses small concurrent calculus called cv models significant concurrency mechanisms cml 
dynamic static semantics cv prove static semantics polymorphic type discipline sound respect dynamic semantics 
diving semantics cv necessary review notation 
chapter describes basic notation part mix notations tof wf introduces style semantic specification defining semantics sequential subset cv notation sets union intersection difference 
notation fin gamma 
denotes set finite maps partial functions finite domains 
map domain range defined dom fx rng ff dom notation fa 

denotes finite map domain fa mapped write fg map empty domain 
maps ffi composition sigma called modified map domain dom dom sigma dom symbol sigma added dom dom taken away tof 
useful view maps sets ordered pairs write dom dom dom 
case called extension set write fxg 
map defined dom 
operator associates left read notation fin denotes set finite subsets finite power set 
ae binary relation ae reflexive transitive closure ae 
formal semantics introduce notation chapters survey important concepts results related style semantics rest chapter presents syntax semantics simple call value calculus 
calculus essentially polymorphically typed version plotkin calculus plo forms core concurrent language chapters 
style semantics developed wright felleisen wf versions presentation places dm tof 
presentation proceeds defining syntax dynamic semantics untyped calculus defining standard hindley milner polymorphic type inference system dm 
state proof standard theorems relate static dynamic semantics 
syntax ground terms variables base constants function constants var variables const constants true false base constants function constants syntactic classes terms expressions exp values val ae exp defined grammar value application constant variable abstraction values irreducible canonical terms dynamic semantics 
free variables term defined inductively fv fv fxg fv fv fv fv fv fv fxg fv fv fxg term closed fv 
variable bound term appears variable identify terms ff conversion bound identifiers example ff substitution term variable term bound written 
defined inductively 










note assumption bound cases 
reasonable assumption bound variables renamed 
general avoid problems free variable capture adopt barendregt variable convention occur certain mathematical context definition proof terms bound variables chosen different free variables 
bar dynamic semantics number different ways specify dynamic semantics programming languages 
style operational semantics developed felleisen friedman ff provides framework proving type soundness results wf 
approach objects dynamic semantics syntactic terms exp meaning function constants defined partial function ffi theta const example assuming fnot ffi true false ffi ffi special function constant represents partial application 
evaluation context single hole context hole marks redex top term irreducible evaluation contexts defined grammar evaluation relation defined terms contexts 
definition gamma 
evaluation relation smallest relation satisfying rules gamma 
ffi ffi gamma 

fi gamma 

easily shown expression unique evaluation context rules results left right call value evaluation function application evaluated evaluating function position argument position lastly applying function similarly expressions 
example expression evaluation context redex example evaluation consider evaluation delta delta delta mark context redex boundary 
gamma 
gamma 
gamma 
typing section describes standard polymorphic type system purpose type system provide static characterization possible results computation expression evaluates integer 
type system deductive proof system assigns types terms 
interesting aspect system rule source polymorphism 
start defining set types type system discuss rule 
describe standard soundness results hold system 
type terms built type constants type variables ff tyvar type variables tycon int type constants set types ty defined type constant ff type variable function type set type schemes oe defined oe ff oe type schema oe ff ff delta delta delta ff abbreviated ff ff delta delta delta ff type variables ff ff said bound oe 
type variable occurs bound said free oe 
write ftv oe free type variables oe 
ftv said monotype 
type environment finite map variables type schemes te var fin gamma 
useful view type environment finite set assumptions types variables 
set free type variables type environment te defined ftv te oe rng te ftv oe closure respect type environment te type defined ff delta delta delta ff fff ff ftv ftv te 
substitution map type variables types 
substitution naturally extended map types types follows sff ff application substitution type schema respects bound variables avoids capture 
defined ff delta delta delta ff fi fi ff 
fi fi dom ftv rng 
application substitution type environment te defined te ffi te 
type instance type scheme oe ff delta delta delta ff written oe exists finite substitution dom fff ff oe say oe generalization examples ff ff ty ff fi ff fi ff ff ff fi ff fi ff int typing system set rules sentences form te inferred 
sentence read type set typing assumptions te 
write fg associate types constants assume existence function typeof const contains typing rules rule called milner rule plays important role system 
rule introduces polymorphism closure operation reason including construct example operational semantics equates untypable typing fg int reason rule assigns type schema ff ff ff instantiated int int int int 
int int body 
typeof te const dom te te te var te te te app te sigma fx 
te abs te te sigma fx 
te type inference rules type system sense respect set constants place restriction definition ffi typeof ffi defined ffi restriction insures typed application function constant ffi reduction 
unfortunately restriction rules useful function constants integer division total 
calculus exceptions restriction unnecessary see section wf 
worth noting exactly typing rule syntactic form proof te form uniquely specifies typing rule applied deduction 
formulation tof differs system dm judgements infer type schemas expressions rules instantiating generalizing type schemas 
proof equivalence systems 
type inference system decidable exists algorithm called algorithm dm infers principal type general relation expression 
algorithm sound complete respect inference system 
see dm tof details proofs 
properties typed purpose static typechecking provide compile time guarantees runtime behavior program 
important property typing system type soundness typed programs run time type errors 
dynamic semantics follow wright felleisen approach wf purely syntactic treatment recall objects dynamic semantics section syntactic terms 
approaches problem dm dam tof 
key result approach wf proving evaluation preserves types 
stated type preservation lemma lemma type preservation te gamma 
te lemma known subject reduction 
expression val said stuck gamma 
notion stuck expressions semantic wright felleisen define syntactic notion conservative approximation potentially stuck expressions 
expression faulty contains subexpression form ffi defined 
expression example faulty expression stuck true faulty expressions shown untypable wf 
say expression diverges written gamma 
exists gamma 
expression converges value written gamma 
definitions behavior evaluation characterized lemma lemma uniform evaluation closed expression gamma 
faulty 
subject reduction uniform evaluation lemmas give theorem theorem syntactic soundness state soundness type system traditional way define partial function eval eval wrong gamma 
faulty examining evaluation relation definition evaluation contexts clear way expression stuck form ffi undefined 
note eval undefined 
definition state strong weak soundness results corollaries theorem 
theorem soundness hold strong soundness eval weak soundness eval wrong theorem means typed programs produce results right type terminate run time type errors 
see wf proof details 
chapter operational semantics cv chapter syntax dynamic semantics small concurrent language class synchronous operations 
language call cv previous chapter extended pairs concurrency primitives cml 
cv lacks number features sml cml embodies essential concurrency mechanisms cml 
particular includes events channels channel event constructors choose wrap guard combinators 
discuss cv extended model additional features cml exceptions polling 
chapter static semantics cv syntax ground terms consist variables base constants function constants addition channel names 
ground terms var variables const constants true false base constants fst snd function constants ch channel names sets var const ch assumed pairwise disjoint 
set includes event valued combinators constructors choose guard receive transmit wrap addition syntactic classes expressions exp values val cv syntactic class event values ev event ae val 
terms cv defined grammar 
pairs included handling argument value application pair chan channel creation spawn process creation sync synchronization constant variable pair value abstraction channel name ev event value guarded event function ev channel output channel input ev wrapper ev phi ev choice ev abort wrapper grammar cv functions easier 
note syntactic class term exp val ambiguity resolved favor val 
binding forms term language binding abstraction channel creation 
cml new channels introduced special binding form channel creation 
done simplify presentation chapter channel function cml defined terms cv see section 
set val ffi set closed value terms free variables note closed values may contain free channel names 
free channel names expression denoted fcn 
note channel name binding forms fcn exactly set channel names appear channel names event values part concrete syntax language appear intermediate results evaluation 
program closed term contain guarded event functions terms subterms syntactic classes event ch 
words programs contain intermediate values 
syntactic sugar syntax cv differs cml ways cases cml syntax viewed syntactic sugar cv terms 
cml uses function channel allocate new channels provides traditional synchronous operations send accept 
functions embedding cv term context channel chan send sync transmit accept sync receive choose select functions cml lists events just pairs 
cv sml recursive datatypes event lists implemented translation nil ev choose ev term sequencing syntactic sugar term snd 
cv uses left right call value evaluation order desired semantics 
dynamic semantics dynamic semantics cv defined evaluation relations sequential evaluation relation gamma concurrent evaluation relation 
relation gamma gamma richer ffi function reduction rule pairs 
concurrent evaluation extension sequential evaluation finite sets processes 
sequential evaluation meaning function constants partial function ffi theta val ffi val ffi closed value val ffi free channel names require ffi defined fcn ffi fcn words ffi allowed introduce new channel names 
standard built function constants meaning ffi expected 
example ffi ffi ffi fst ffi snd meaning ffi straightforward event valued combinators constructors ffi ffi transmit ffi receive ffi wrap ev ev ffi choose ev ev ev phi ev ffi ev ev complication arises case guarded event values ffi guard ffi wrap ge wrap ffi choose ge choose ffi choose ev choose ev ffi choose ev choose ev ffi ge rules reflect guard role delay operator event constructor applied guarded event value guard operator pulled delay event construction 
evaluation cv call value additional constraint pairs evaluated left right 
leads grammar evaluation contexts cv spawn sync fact terms contexts useful chapter lemma closed term closed term 
proof 
examining definition clear free free 
fv fv 
xi definition gamma 
sequential evaluation relation smallest relation gamma satisfying rules algol terminology thunk 
gamma 
ffi cv ffi gamma 

cv fi gamma 

cv sync gamma 
sync cv guard note rule cv guard forces expression delayed guard 
usual gamma 
transitive closure gamma 
evaluation new forms spawn defined part concurrent evaluation relation section 
event matching key concept semantics concurrent evaluation notion event matching captures semantics rendezvous communication 
informally processes synchronize matching events exchange values continue evaluation 
formal need auxiliary definition definition abort action event value ev expression evaluated spawns abort wrappers ev map event exp maps event value abort action defined inductively follows 
ev ev ev phi ev ev ev ev ev spawn definition formally define matching event values definition event matching matching event values defined family binary symmetric relations indexed ch 
ch define ev ev pronounced ev matches ev channel respective results smallest relation satisfying inference rules 
relation abbreviated ev ev results unimportant 
example event matching 
phi 
ev ev ev ev ev ev ev ev ev ev ev ev phi ev ev ev ev ev ev phi ev ev ev ev ev ev rules event matching informally processes attempt synchronize matching event values replace applications sync respective results 
precise section concurrent evaluation relation defined 
note event matching nondeterministic example phi phi worth noting wrappers event value nonterminating necessary abort actions event executed assuming fair evaluation 
property important common cml idiom calls wrappers buffered channel abstraction section 
concurrent evaluation concurrent evaluation defined transition system finite sets process states 
similar style chemical machine bb cooling heating transitions process sets semantics thought perpetually hot solutions 
concurrent evaluation relation extends gamma finite sets terms processes adds additional rules process creation channel creation communication 
assume set process identifiers define set processes process sets procid process ids ei proc procid theta exp processes fin proc process sets write process evaluation context serves role program counter marking current state evaluation 
definition process set formed ei hold ffl fv closed ffl occasionally useful view formed process sets finite maps procid exp finite set process states finite set channel names configuration 
definition configuration formed fcn formed 
concurrent evaluation relation extends gamma configurations additional rules concurrency operations 
defined inference rules define single step evaluations 
concurrent evaluation step affects processes called selected processes 
describe rules independently state formal definition 
rule extends sequential evaluation relation gamma 
configurations gamma 
ei cv 
selected process 
creation channels requires picking new channel name substituting variable bound chan 
cv chan selected process 
process creation requires picking new process identifier dom spawn cv spawn rule selected processes interesting rule describes synchronization 
processes attempting synchronization matching events may rendezvous exchange message continue evaluation ev ev sync ev sync ev cv sync selected processes rule say transition 
formally concurrent evaluation defined follows definition concurrent evaluation relation smallest relation satisfying rules cv cv chan cv spawn cv sync 
rules processes live forever process evaluates value selected remains process set 
add rule similar evaporation rule bb rule included certain results easier state prove process set increasing 
traces sequential semantics section program infinitely different evaluations 
furthermore interesting programs terminate 
new terminology notation describing evaluation sequences required 
describe reasonable fairness constraints see section state type soundness results cv see chapter 
note properties lemma formed hold 
formed 

dom dom proof 
examination rules 
xi corollary properties lemma hold proof 
induction length evaluation sequence 
xi note property implies evaluation preserves closed terms 
definition trace possibly infinite sequence formed configurations ii finite length 
head note configuration formed sequence evaluation steps starting trace corollary 
possible states process respect configuration definition 
definition formed process set ei 
state zombie blocked ready depending form ffl zombie ffl sync ev exist sync ev fpg ev ev blocked ffl ready define set ready processes rdy ready pg configuration terminal rdy 
terminal configuration blocked processes said deadlocked 
definition trace computation maximal infinite finite ends terminal configuration 
program define computations comp ft jt computation head eig note follow convention process identifier initial process computation program 
definition set processes trace defined procs dom program evaluate different ways sequential notions convergence divergence inadequate 
define convergence divergence relative particular computation program 
definition process procs converges value written vi say diverges written dom ready blocked divergence includes deadlocked processes terminating processes evaluated reach termination infinite loops 
include processes run time type errors called stuck see section 
fairness semantics admits unfair traces adequate specification cml implementations 
necessary distinguish acceptable traces 
informally require ready processes progress communication single channel fair see survey fairness issues 
couple definitions required formalizing notions fairness 
defined notion process ready configuration similar definition required channels 
definition channel enabled configuration distinct processes sync ev sync ev ev ev acceptable computations program defined terms fairness restrictions 
definition computation acceptable ends terminal configuration satisfies fairness constraints process enabled infinitely selected infinitely 
channel enabled infinitely infinitely 
taxonomy restriction strong process fairness second strong event fairness 
implementation cml prohibit possibility unacceptable computations 
practice requires implementation satisfy stronger property finite traces 
example consider property 
definition finite trace length bounded fair fixed positive integer intermediate configuration satisfies ffl ffl rdy selected process evaluation subsequence delta delta delta km pm infinite trace bounded fair finite prefix bounded fair 
bounded fair trace obviously satisfies restriction necessarily 
bounded fairness restriction realizable fairly standard implementation techniques 
example implementation uses fair preemptive scheduling fifo queues process ready queue channel waiting queues produce bounded fair sequences determined length time slice speed processor 
similar notions defined event fairness 
extending cv language cv lacks number features cml section show cv extended model features 
meant complete development formal semantics complicated language illustrate formal treatment full cml possible 
fair mean thread guaranteed progress preempted 
recursion dynamic process channel creation powerful implement call value combinator 
combinator evaluation rule gamma 
cml code implements features cv adopted gmp val fn 
val channel val fn 
val accept spawn fn 
send spawn fn 
send val accept spawn fn 
send code somewhat mysterious fairly simple 
channel cache function iteration time renamed read new thread spawned send copy iteration 
cml statically typed see chapter definition implements recursion imperative types 
alternative add combinator built term constructor done wf provide recursion types 
known processes channels mimic updatable 
standard technique process thread hold state cell messages implement reading writing cell 
gives cml code 
define formal translation programs programs scheme 
done translation shown faithful expected semantics 
implementation described section similar imperative combinator defined felleisen fel 
suggests implementation datatype ref ref chan chan fun val inch channel channel fun cell sync choose wrap transmit fn 
cell wrap receive inch fn 
cell spawn fn 
cell ref inch fun assign ref inch send inch fun deref ref accept implementing uses channels represent directly require explicit recursion 
gives alternative representation 
note version directly coded cv fun val ch channel spawn fn 
send ch ch fun assign ch accept ch spawn fn 
send ch fun deref ch val accept ch spawn fn 
send ch implementing recursion exceptions important features sml cml exception mechanism 
cml adds support exceptions event value combinator handles exceptions raised evaluation event wrappers 
exceptions feature requires imperative types achieve sound typing 
wright felleisen provide semantics sml exception mechanism wf applying technique cv requires care 
problem soundness semantics relies limiting scope exception identifiers scope binding site rewrite rules allow binding sites migrate top term expanding scope binding 
processes include exceptions messages send scope different approach needed 
best approach bind exception identifiers implicit global environment done channel names 
remainder section sketch changes syntax semantics cv required support exceptions 
adding exceptions cv requires set exception names ex syntax cv extended support declaration raising handling exceptions 
raised exception represented exception packet exn ae exp 
exception packets irreducible terms technical reasons values 
syntactic extensions exception exception binding raise raise exception handle exception handler exn exception packet exn ex exception packet ex exception name ev ev wrapped handler terms exception packets exception names wrapped handlers intermediate forms appear programs 
sequential evaluation extended ways 
pattern matching cv exception matching explicitly coded semantics 
means wrapper pair exception name handler 
reflected ffi rule ffi ev ex ev ex presence exception mechanism means function constants div supported 
assuming existence exception name div integer division defined ffi div div ffi div additional evaluation contexts new syntactic terms required raise raise ex handle ex handle ex note handler handle term evaluated body 
sequential evaluation relation definition extended 
new clauses gamma short circuiting evaluation exception raised propagating resulting packet handler 
sampling exn gamma 
exn exn gamma 
exn handle ex exn gamma 
exn similar rules pairs sync raise 
new clauses raising catching exception packets raise ex gamma 
ex ex handle ex gamma 
ex handle ex gamma 
ex ex ex case channel names binding new exception names left concurrent evaluation relation 
event matching relation definition extended clause wrapped handlers ev ev ev ev ex handle ex configurations include set bound exception names 
form ae finite set exception names 
configuration formed fcn formed exception name occurs inference rules concurrent evaluation relation definition modified light new form configurations 
addition concurrent evaluation relation extended allow declaration exceptions ex exception ex 
ex process join cml provides event constructor creates event synchronizing termination thread 
couple ways extend cv model 
approach define distinguished set channel names represent process ids dynamic semantics 
approach rule process creation wraps body process code repeatedly send channel dom spawn fork fork send waiting process termination implemented scheme waiting message process channel implemented directly receive 
reasonable implementation technique disadvantage hard distinguish zombie processes 
better approach support directly 
side effect approach event constructor directly supported 
direct approach requires adding procid domain values adding new event value terms delta delta delta ev delta delta delta implementation function defined ffi rule ffi matching base event created differs rendezvous process selected 
requires new relation event set processes 
definition define ternary relation ev pronounced ev matched result smallest relation satisfying inference rules 
concurrent evaluation relation changed slightly case spawn returns identifier new process dom spawn ev ev ev ev phi ev ev ev ev phi ev ev ev ev rules matching events process sets additional concurrent evaluation rule sync handles matching events ev sync evi ei polling noted section cml supports polling mechanism 
recall poll operation non blocking form sync returns sync blocked wrapped synchronization result 
fairly straightforward add poll cv start syntax expressions definition evaluation contexts extended new form poll delta delta delta poll delta delta delta cv option datatype need way encode result polling event value 
poll operation takes arguments event value poll pair functions 
informally evaluation poll ev apply result matching ev apply 
polling supposed non blocking need formal notion synchronizing event block 
definitions 
definition event value ev offered configuration form sync ev poll ev 
set offered events defined offered fev dom offers ev pg definition set matched events set processes defined match fev ev offered ev ev need additional concurrent evaluation rules 
handle transition event matched process third handles transition sync blocked ev ev poll ev sync ev ev ev poll ev poll ev ev match poll ev rules sensible requires fairness constraint poll ev transition acceptable ffl ev match ev match ffl ev match ev match 
constraint captures notion poll non blocking forcing polling operation complete state polled event change 
chapter typing cv chapter polymorphic type discipline cv prove sound respect operational semantics previous chapter 
proofs main results provided chapter additional proof details appendix 
cml uses sml polymorphic type inference system extension section long known naive extension system polymorphic unsound gmw dam tof 
example assumptions ref 
ff ff ff ref 
ff ff theta ff ref unit 
ff ff ref ff erroneous program type bool val ref fn 
fn 

true tofte tof tof shows source problem rule bindings 
recall rule te te sigma fx 
te tofte points closure operation generalizes type variables 
particular type variables free implicit typing store generalized rule 
example code closure causes assigned type scheme ff ff ff ref body instantiated int int ref bool bool ref 
typing store undecidable compile time conservative scheme necessary avoid generalization variables free store typing 
tofte proposed system distinguishes applicative imperative type variables bindings expansive may introduce new store objects 
syntactic property conservatively approximates expressions introduce new store objects 
basically irreducible terms abstractions constants non expansive terms expansive 
example sml notation val ref val expansive bindings val fn 
ref non expansive binding 
typing rules binding expansive applicative type variables generalized binding non expansive variable generalized 
sml nj uses scheme developed dave macqueen called weak types deal imperative features 
basic idea assign rank type variable approximation number levels abstraction protecting variable 
rank variable gets zero instantiated monotype 
applicative type variables rank infinity weak 
conjectured proven macqueen scheme sound strictly polymorphic tofte 
cml inherits typing scheme sml nj tofte scheme chapter defined inference system type system definition sml mth 
channels processes implement shown section clear typing problems polymorphic exist polymorphic channels 
naively view implementation cml proof soundness polymorphic channels written sml plus callcc typechecks discovered typing rules callcc sml nj sound bob harper personal communication july 
simple counter example owed harper lillibridge expression val callcc fn 
fn 
fn 
throw fn 
print hello fn 
typing callcc changed sml nj fix problem correct typing section 
implementation cml uses unsound typing means soundness polymorphic channels serious concern 
remainder chapter presents type system cv proves sound 
static semantics type terms cv richer tycon fint bool designate type constants 
type variables partitioned sets imperative type variables applicative type variables ff fi tyvar type variables set types ty defined type constants ff type variables function types theta pair types chan channel types event event types set type schemes oe defined oe ff oe write ff delta delta delta ff type scheme oe ff delta delta delta ff write ftv oe free type variables oe 
define set imperative types ftv ae note free type variables imperative type imperative 
type environments assign type schemes variables terms 
interested assigning types intermediate stages evaluation channel names need reasons discussed section 
assigned types 
typing environment pair finite maps variable typing channel typing vt varty var fin gamma 
ct ch fin gamma 
te vt ct varty theta ftv vt ftv ct denote sets free type variables variable channel typings ftv te ftv vt ftv ct te vt ct 
note bound type variables channel typing ftv ct ae 
shorthand useful type environment modification te sigma fx 
oeg def vt sigma fx 
oeg ct te sigma 
def vt ct sigma 
var ch te vt ct 
need preserve imperative types require substitutions map imperative type variables imperative types 
allow substitutions applied types type environments 
definition type instance type scheme oe ff delta delta delta ff written oe exists finite substitution dom fff ff oe say oe generalization say oe oe oe oe definition closure type respect type environment te defined ff delta delta delta ff fff ff ftv ftv te applicative closure defined ff delta delta delta ff fff ff ftv ftv te important facts type closure generalization lemma properties hold te oe oe ffl oe oe clos te oeg clos te oe 
ffl dom te clos te oeg 
proof 
follow observation ftv te ftv te clos te xi expression typing rules function typeof assigns types constants 
concurrency related constants typeof assigns type schemes ff unit ff event receive ff ff chan ff event transmit ff ff chan theta ff unit event wrap fffi ff event theta ff fi fi event choose ff ff event theta ff event ff event guard ff unit ff event ff event ff ff event theta unit unit ff event assume event valued constants 
formally require exist typeof event type typing rules cv divided groups 
core rules 
modification rules 
rules rule app applies non expansive case syntax cv bound expression val rule imp applies expression expansive value 
rules typing channel names pair expressions 
rule chan restricts type introduced channel imperative 
addition core typing rules rules syntactic forms see 
appropriate environment rules derived rule app rule const case 
useful include explicitly 
worth noting syntactic form term uniquely determines typing rule applies 
order typing constants sensible impose typability restriction definitions ffi typeof typeof te ffi defined te ffi worth noting ffi rules defined concurrency constants respect restriction 
lemma defines derived typing rule sequencing syntax lemma typing rule sequencing te te te typeof te const dom vt vt vt ct var ct vt ct te te te app te sigma fx 
te abs te te te theta pair te te sigma fx 
te app te te sigma fx 
te imp te sigma fx 
chang te chan chan core type inference rules cv te unit te spawn unit spawn te event te sync sync te event te event guard ff ff event te te chan te te unit event output te chan te event input te ev event te te ev event wrap te ev event te ev event te ev phi ev event choice te ev event te unit unit te ev event abort type inference rules cv proof 
follows definition sequencing type rules typeof snd theta te snd theta te te te theta te snd xi process typings process typing finite map process identifiers types pt procid fin gamma 
ty typing judgements extended process configurations definition 
definition formed configuration type pt channel typing ct written ct pt hold ffl dom ct ffl dom dom pt ffl ei fg ct pt 
cml spawn requires unit unit argument process typing pt unit dom 
type soundness section presents proof soundness type system section respect dynamic semantics section 
discussed section approach wf 
basic idea show evaluation preserves types called subject reduction characterize run time type errors called stuck states show stuck states untypable 
allows conclude typed programs go wrong 
substitution replacement lemmas prove main results need important lemmas 
lemma states variable channel name domain typing environment free expression ignored typing lemma fv te iff te sigma fx 
oeg likewise fcn te iff te sigma 
proof 
proof straightforward induction height typing deduction 
xi note variable convention insures fv lemma applies 
lemma important allows replace subexpression expression type affecting type term 
lemma replacement single hole context 
hold 
type deduction concluding te 
concludes te 
occurs position corresponding hole 
te te proof 
basic idea term type deduction isomorphic structure replacement paralleled replacement deduction te deduction te giving deduction te proven induction structure deduction 
see hs wf detailed proofs 
xi lemma essentially says fi reduction preserves types 
lemma substitution fv te te sigma fx 
ff delta delta delta ff fff ff ftv te te 
proof 
proof induction height typing deduction detailed proof appendix 
xi lemma useful showing spawn preserves types 
lemma vt ct fv fg ct proof 
specific version lemma follows immediately 
xi subject reduction ready state prove subject reduction theorem says sequential evaluation preserves types 
theorem sequential type preservation type environment te expression type te gamma 
te proof 
assume te te vt ct 
replacement lemma sufficient show te done case analysis definition gamma 
structure 
case gamma 
ffi 
rules app const apply typeof te te te typability restriction ffi te ffi case gamma 


rules app abs apply te sigma fx 
te te te applying substitution lemma gives te 
case gamma 


rule app applies te te sigma fx 
clos te te clos te ff delta delta delta ff definition fff ff ftv te substitution lemma get te 
case sync gamma 
sync 
rules sync guard apply te event te event te sync rule sync te event te sync xi lemma ev ev te ev event te 
proof 
proved induction definition event matching details appendix 
xi ready prove second subject reduction theorem says concurrent evaluation preserves process typing 
theorem concurrent type preservation configuration formed channel typing ct ct pt channel typing ct process typing pt hold ffl ct ct ffl pt pt ffl ct pt ffl ct pt proof 
fourth property follows proof properties proceeds case analysis left hand side relation 
case ct ei pt 
gamma 
sequential type preservation theorem fg ct pt ct pt letting ct ct pt pt satisfies theorem 
case ct chan pt 
type environment te vt ct types 
te sigma fx 
chang te chan 
fg ct chan pt name new channel define ct ct sigma 
chang obviously ct ct 
lemma fg ct chan pt replacement substitution lemmas fg ct 
pt ct 
pt 
letting pt pt satisfies theorem 
case ct spawn pt 
variable typing vt type 
vt ct unit vt ct spawn unit 
fg ct spawn pt lemma know fv lemma fg ct unit applying rule app get fg ct process identifier new process dom ct pt sigma 
letting pt pt sigma 
ct ct satisfies theorem 
case ct sync ev sync ev pt 
type environment te type 
te ev event te sync ev 
fg ct sync ev pt ev ev lemma te replacement lemma fg ct pt ct pt letting ct ct pt pt satisfies theorem 
xi theorem leads immediately fact traces corollary ii finite trace ct pt channel typing ct process typing pt ffl ct ct ffl pt pt ffl ng ct pt proof 
follows simple induction xi stuck expressions order show typed programs run time type errors need characterize errors 
definition process ei stuck value exist wellformed configurations selected process 
formed configuration stuck processes stuck 
notion stuck semantic section wf conservatively approximated syntactic notion faulty expressions 
cv take somewhat different approach focuses stuck expressions 
lemma uniform evaluation program comp procs stuck proof 
follows immediately definitions 
xi remains show stuck expressions untypable 
lemma stuck configurations stuck formed configuration exist ct pt fg ct pt words untypable 
proof 
proof appendix 
xi soundness position state main result chapter typed programs go wrong 
result stated terms computations program 
recall section computation maximal trace 
theorem syntactic soundness program comp procs occurrence exists ct pt ct pt pt ffl ffl exists extension ct ct fg ct pt 
proof 
existence ct pt follows concurrent type preservation theorem 
uniform evaluation lemma know stuck assume stuck lemma formed lemma untypable 
configuration fg fh eig typable concurrent type preservation theorem ct pt ct pt means fg ct pt stuck done 
assume concurrent type preservation means exists extension ct ct extension pt pt ct pt pt extension pt pt pt fg ct pt 
xi state traditional soundness results need define notion evaluation distinguishes processes run time type errors 
definition computation define evaluation process eval wrong stuck note sequential programs essentially definition page 
definition state weak strong soundness results cv theorem soundness program comp procs hold strong soundness eval occurrence ct pt ct pt pt extension ct ct fg ct pt 
weak soundness eval wrong proof 
follows immediately syntactic soundness theorem definition eval 
xi words typed cml program run time type error 
worth noting sequential subset cv theorem reduces soundness theorem section theorem 
part iv practice chapter applications part dissertation addresses question usefulness practicality proposed language mechanisms 
chapter describes number abstractions implemented cml fully address question useful cml real applications efficiently implemented 
address questions implemented cml top sml nj 
implementation number people including various different applications 
practical experience demonstrates validity usefulness design efficiency implementation 
chapter describe applications 
describe implementation chapter performance chapter 
final chapter part chapter describes research related implementation cml multiprocessors 
exene multi threaded window system toolkit argued section concurrency useful tool structuring interactive applications 
emden gansner bell laboratories developing multi threaded window system toolkit sg called exene gr implemented cml 
implementation serves roles provides test performance cml real world setting serves platform interactive applications discussed section 
window system distributed system implementation exene involves distributed systems programming discussed section 
section describes architecture exene gives couple examples cml primitives implementation 
overview exene exene provides similar level function xlib substantially different model user interaction 
windows exene environment consisting streams input window parent mouse keyboard control output stream requesting services window parent 
child window corresponding output streams input stream 
input streams represented event values output streams event valued functions 
window responsible routing messages children done generic router function provided exene 
typically window separate thread input stream thread managing state coordinating threads 
breaking code way individual thread quite simple 
event handling model similar pik haa 
differences exene traditional toolkits 
example exene uses immutable pens specify semantics drawing operations mutable graphics contexts provided protocol 
pens immutable concurrency control issues avoided threads share pen 
window system overview window system distributed system application clients communicating server process 
core protocol consists different messages divided request messages replies event messages error messages 
request server implicit sequence number message sent number 
messages server client tagged sequence number request processed server match replies requests 
architecture exene non language bindings exene implemented directly top protocol 
non cml code involved run time system support socket communication 
implementation approach advantage avoiding language bias xlib 
furthermore provides demonstration cml implement low level systems programs significant loss performance 
connection server called display 
exene display consists threads gives message passing architecture threads 
input output threads provide buffering communication server 
sequencer server socket sequencer error handler output buffer input buffer font server event buffer top level window registry server display window event streams translations request reply font requests display message passing architecture thread generates sequence numbers matches replies requests 
error messages logged error handler addition errors requests expect reply forwarded requesting thread 
sequencer sends events event buffer decodes buffers 
top level window registry thread keeps track top level windows application descendants 
manages stream events top level window application 
display threads manage global resources server provides translations font server keeps track open fonts application 
display screens support different visuals depths black white bit color 
visual depth combination screen supported threads shows message architecture 
draw display request reply font requests draw master gc server screen oe draw requests gc requests screen message passing architecture master thread encodes batches drawing requests particular visual depth combination draw masters screen level operations screen rectangles pixels 
gc server handles mapping exene immutable pens mutable graphics contexts 
windows displayed particular visual depth screen 
internally windows organized tree hierarchy top level window root 
gives message passing architecture top level window threads 
described window tree hierarchy top level window router draw master screen gc requests display event stream translations request reply oe oe ae ae ae ae ae ae ae ae ae ae oe ae ae ae window tree top level window message passing architecture top level window application dedicated stream events display 
stream monitored top level window router thread 
thread provides transition view events exene view window environment 
draw master thread window tree 
unpleasant artifact graphics contexts associated particular screen visual depth 
promises exene operation protocol copy rectangle pixels place screen 
complication arises portion source rectangle obscured window 
example shows translate rectangle screen cross hatched region destination corresponds obscured region source 
window system maintain obscuring window destination rectangle source rectangle gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma operation backing store virtual bitmap handle situations standard policy notify client operation able completely fill destination 
policy called damage control client repair damage 
typical inserting line text 
case client thread issue sequence operations create space new text followed erase old text lastly insert new line 
picture illustrates steps servers support backing store option applications designed function correctly available 
text text text text text important user system see sequence single smooth transition 
implications implementation operations 
treated normal rpc returns list damaged rectangles user subjected screen flicker 
understand reasons examine shows timing information client doing text scrolling thread handling buffering communication server server 
client buffer server xz oe xz display transition synchronous text scrolling drawing operations postponed received period time display transition quite lengthy 
performance concerns protocol standard reply mechanism 
special events notify client result request 
single purposes discussion collapsed buffer sequencer threads single thread 
things little complicated multiple events generated single threaded clients vast majority clients means code operation scan event stream 
exene concurrency events handle operation elegant way 
solution implement asynchronous rpc operation known promise ls 
exene provides event valued function type val arg type 
list event arg type type arguments specify actual operation 
event returned promise result 
gives implementation sketch operation request sends operation buffer thread flush tells buffer thread flush buffered messages server 
guard optimized check fun arg val replych channel spawn fn 
request replych arg guard fn 
case poll receive replych 

flush receive replych case implementation see available 
buffer code complicated match outstanding requests 
advantage approach seen comparing timing diagram 
menus example way concurrency exene way popup menus attached windows 
done interposing thread window mouse stream 
thread sees transition appropriate mouse button creates menu window starts tracking mouse semantics cause mouse events transition directed window 
mouse events passed action 
form delegation window wrapped menu thread viewed sub class window 
request 
client buffer server flush xz oe display transition asynchronous text scrolling interactive applications combination exene cml provides foundation building interactive applications spirit pegasus rg gr 
section describe application exene uses features cml 
currently sophisticated application built top exene graph interactive tool viewing analyzing directed graphs 
originally implemented top pegasus emden gansner steve north bell laboratories emden gansner ported exene 
graph provides user kinds windows command windows provide terminal style language interface command shell viewers provide view layout graph 
time user multiple command windows multiple viewers 
viewer associated particular layout particular graph 
different graphs different layouts layout multiple views 
screen dump sample session graph 
bottom window command window windows provide views single layout graph 
viewer allows user pan zoom menus lin university sussex built interactive theorem prover top exene know details implementation 
graph screen dump scrollbars particular layout 
user manually change layout editing operations moving node elision subgraph 
implementation graph exploits features cml ways 
graph edited information needs propagated layouts views graph 
multicast channel abstraction described section manage propagation update notifications layouts layouts views 
simplifies implementation graph object need know multiple layouts 
layout objects decide change affects query graph object detailed information 
command shell thread communicates virtual terminal widget 
widget example need communication abstraction selective communication 
time able handle input user output client command shell 
exene provides interface input stream event valued selective communication 
concurrency structuring application code 
layout algorithms example run separate threads allowing user continue activities waiting new layout 
distributed systems programming distributed programming languages concurrent languages core sr distributed programming toolkits include thread packages isis 
threads provide needed flexibility dealing asynchronous nature distributed systems 
flexibility provided cml base distributed programming 
support low level sufficient build structured synchronous interface network communication done exene 
higher level linguistic support distributed programming promise mechanism described section built events define new abstractions 
example chet murthy reimplementation nuprl environment con cml 
implementation structured collection proof servers running different workstations 
expensive operation proof tree required decomposed run parallel different workstations 
system uses cml manage interactions different workstations 
distributed ml project involving cml development distributed programming toolkit ml done cornell university kru 
builds mechanisms prototyped murthy distributed nuprl protocols developed isis 
new abstraction called port group developed model distributed communication 
communication operations provided port groups represented event value constructors 
details see kru 
applications cml cml various people number purposes 
andrew appel teach concurrent programming undergraduates princeton university appel personal communication january 
gary lindstrom lal george experiment functional control imperative programs parallel programming gl 
cl ement implemented compiler concurrent constraint language cml 
chapter implementation implementations class synchronous operations 
wrote implementation part pegasus pml run time system rep 
implemented concurrency mechanisms pml top sml nj coroutine library rep norman ramsey implemented similar system princeton ram 
implemented cml top sml nj rep 
implementations cml provides richest programming notation best performance 
written entirely sml non standard extensions provided sml nj firstclass continuations asynchronous signals rep minor compiler modification 
chapter describes implementation cml detail brief sketch rep discusses implementation techniques improve performance 
specific performance measurements implementation reported chapter 
implementation runs single processor computers issues related multiprocessor implementation cml discussed chapter 
implementation sml nj sml nj high performance implementation sml am am uses combination sophisticated compiler techniques clever run time system support provide level performance competitive large examples 
section describe aspects sml direct bearing implementation cml 
coroutine mean system preemptive thread scheduling 
class continuations discussed section sml nj provides continuations class values 
type callcc fully polymorphic val callcc cont 

discussed chapter discovered typing class continuations unsound 
type callcc sml nj val callcc cont 

corrects soundness problem wf 
unfortunately weakly polymorphic type effect reducing polymorphism cml primitives 
example type sync val sync event 
weakly polymorphic version callcc 
reason unsafe fully polymorphic version callcc implementation 
typing resulting primitives proven sound chapter 
compiler sml nj compiler multi pass compiler 
front fairly conventional scanning parsing type checking back optimization code generation interests 
back uses representation called continuation passing style cps short ste kkr aj app 
cps representation specialized form calculus uniform representation transfers control conditional branches loops function calls function returns 
representation goto arguments better known tail recursive call 
function return represented tail recursive call functions parameterized return continuation 
explicit passing continuations cps gets name 
advantage approach compiler concentrate making function calls fast possible keys performance languages sml scheme 
continuation passing style compilers ste kkr code generated sml nj compiler run time stack return continuations heap allocated 
means code generated callcc throw essentially function calls 
difference current continuation created callcc restore current enclosing exception handler 
unfortunately means callcc breaks tail recursion way exception handlers implications implementation sync see section 
run time system sml nj run time system provides automatic memory management interface underlying operating system unix mechanism building stand ml worlds 
older version run time system described app revised times 
run time system logically divided coroutines ml program program provides run time support 
actual implementation uses procedure call return implement coroutine switches global struct hold ml state run time system 
assembly routines respectively call return ml program 
ml program needs service run time system loads global variable request name needed service jumps 
memory management object word descriptor contains object length bit tag 
kinds objects tuples arrays strings mutable strings 
code objects heap represented strings 
single code object hold code compilation unit ml structure functor requires mechanism supporting pointers middle strings 
accomplished embedded string descriptor mark substrings code object preceding embedded string descriptor back pointer descriptor tells garbage collector find code object 
details run time representations see app 
memory allocation dominating cost ml execution cheap possible 
sml nj uses inline allocation minimal overhead allocation tuple requires instructions cost object initialization 
run time system uses dedicated registers support allocation allocation pointer points start object allocated heap limit pointer test need garbage collection 
testing heap limit allocation compiler tests extended basic block 
compiler computes releases sml nj ml state longer global 
run time routine takes argument allows multiple ml states exist multiprocessor 
extended basic block acyclic graph basic blocks single entry point multiple exit maximum possible allocation extended basic block generates heap limit test root insure execution block run allocation space allocation dynamic sized objects arrays done hand coded assembly routines run time system 
simplify test heap limit set bytes actual top allocation space test block allocates bytes involves pointer comparison 
machines cleverly coded register register instruction blocks allocate bytes expensive test involving pointer arithmetic required 
heap limit overflow detected trap generated operating system maps unix signal uni caught handler run time system 
signal handler saves program counter ml program replaces address returns operating system causes program execution resume 
technique unix signal handler vector assembly routine saves register state owed cormack cor 
compiler generates embedded string descriptor prior entry point extended basic block program counter heap limit test treated normal ml value garbage collector 
signals sml nj provides asynchronous signal mechanism rep semantics similar unix signals uni 
signal occurs current continuation grabbed passed appropriate ml signal handler 
signal handler executes atomically respect signals returns continuation resume execution 
signal handlers provide natural mechanism implementing preemptive thread scheduling see 
actual translation unix signal ml signal complicated described 
principal difficulty constructing continuation pass signal handler arbitrary point execution feasible 
solution problem delay capturing continuation safe point state execution easily captured 
heap limit checks trigger garbage collection conveniently provide safe points 
unix signal occurs unix signal handler run time system records modifies heap limit pointer insure heap limit check trigger garbage collection 
garbage collector recognizes request garbage collection pending signal builds continuation closure ml state passes signal continuation ml routine points ros 
recall heap limit check preceded descriptor garbage collector able deal code address continuation built run time system 
dispatches appropriate ml signal handler 
heap limit checks safe points similar preemption technique argus 
complete description sml nj signal mechanism see rep 
implementing threads implementation threads exploits fact class continuations exactly thread state needs saved restored context switches wan 
section describes implementation threads preemptive scheduling 
threads internally thread represented pieces information thread id continuation 
thread id serves unique identifier thread providing handle implementing operation continuation represents suspended state thread computation 
threads ready able execute blocked waiting synchronize event 
time ready threads designated currently running thread ids current continuations ready threads kept ready queue 
global variable refer currently running thread id switching thread contexts involves putting current thread continuation id ready queue dispatching thread queue 
code illustrates mechanics context switch fun val val newid newid throw bound running thread current continuation 
variations scheme implementation 
sml nj compiler knows threads concurrency fact callcc throw implement threads means implementation gets benefits specialized compiler support free 
particular compiler knows exactly registers live point context switch minimum amount thread state required saved restored 
furthermore version cml switched register refer current thread id register dedicated processor register provided compiler 
fact continuations heap allocated means thread creation fast constant time operation 
mips processor thread context switch instructions thread creation instructions hope numbers substantially reduced see section details 
preemptive scheduling order prevent thread executing long infinite computation processor cml uses preemptive thread scheduling 
done straightforward manner unix interval timer uni signal mechanism described 
interval timer set generate milliseconds typically range signal handler forces context switch installed 
complication possible interference running thread signal handler 
avoid problem global flag mark execution critical region datatype nonatomic atomic val ref val unit 
unit val unit 
unit function sets flag atomic called just prior entering critical region function resets flag nonatomic called exit 
signal occurs atomic signal handler force context switch 
sets returns 
function checks flag resetting context switch performed 
note mechanism internal implementation cml user programmers access operations 
implementing channels channels represented pair queues threads waiting input threads waiting output see 
item channel queue triple constant time callcc possible stack implementations hdb clear techniques fast implement true light weight threads today hardware 
example reports number scheme implementations unsatisfactory prototypes multi threaded window system haa 
reader may recognize potential race exiting critical region time test pending signal resetting flag 
delaying signals heap limit check points means race occur practice test resetting flag done intervening heap limit checks 
type bool ref threadid queue datatype chan chan inq cont unit cont representation channels consisting dirty flag described thread id offered communication 
input queue inq offered communication represented continuation accept message output queue offered communication consists message sent continuation resume thread message accepted 
example implementation send 
code fun send chan inq msg callcc fn 
case inq rid 
rid throw msg 
insert ref false msg case implementation send works capturing rendezvous point continuation callcc 
channel queue ready queue going manipulated called mark start critical region 
call returns id communication clean item input queue available returns 
offered communication available matching accept receive sending thread added ready queue message thrown receiving thread continuation 
matching communication available sender added output waiting queue thread dispatched dispatches thread exiting critical region 
implementation accept essentially mirror image send 
notion related dirty flag explained 
implementing events implementation events moderately complex useful consider simple subset events choice guards abort actions 
particular consider operation binary semaphores simplest synchronous operation 
implementation binary semaphores ignoring issues atomic regions thread ids quite simple datatype semaphore semaphore flg bool ref unit cont list ref fun semaphore flg case 
flg true 
enqueue fun semaphore flg fun flg flg false dispatch callcc body operation factored pedagogical reasons 
thing notice code resumption continuation calling process free variable body operation 
observation holds synchronous operations key implementation events 
simple setting means event values represented type event cont 
representation event valued implementation fun semaphore flg fun flg flg false dispatch follows sync implemented directly callcc 
implementation wrap feed value produced synchronizing argument second argument done follows fun wrap evt fn 
throw callcc evt continuation applies argument passed event value wrapped result evaluating thrown continuation argument event value constructed wrap 
astute reader recognize convoluted form function composition 
event value representation unfortunately simple representation events unable support choice guards abort actions 
general setting cml events distinct aspects thread synchronizing event values forcing 
event guard event forced guard function applied 
polling 
non guard event step poll base events see immediately satisfiable 
selection 
base events immediately satisfiable selected executed 
logging 
immediately satisfiable events synchronizing thread added waiting queues base events 

base events satisfied thread removed base events waiting queues abort actions spawned 
gives representation event values reflects aspects described 
event value guard function list base event descriptors 
descriptor record fields function test base event immediately satisfied function execute base event selected function log base event value field abort action 
rep informal semantics pml events defined terms rewriting system converts events canonical form form essentially representation rewrite rules implementation various combinators 
synchronization described aspects applying sync event value 
divided phases 
phase forcing guards corresponds datatype abort unit 
unit datatype unit 
bool 
bool ref unit 
unit 
datatype event evt list guard unit 
event representation event values sequential evaluation rule sync chapter 
second phase corresponds notion event matching definition consists polling selection logging done part selection step 
involves accessing shared data structures done inside atomic region 
fact second phase done atomic operation greatly simplifies implementation sync cf section 
actual implementation second phase tuned various common special cases singleton events events abort actions simplify discussion describe general case 
forcing guards recursive forcing guards done function fun guard evt guards forced returns list base event descriptors 
polling polling base events involves traversing base event list calling element extracting abort action 
polling step produces status value base event list 
base event status ready blocked abort action see 
base events ready blocked base events irrelevant 
polling loop sees ready base type bool ref unit 
unit 
datatype blk unit 
unit rdy 

unit 
unit representation event status event discard status blocked base events 
polling individual base event status done function fun case false 
blk false abort 
true 
rdy true abort 
selection resulting list base event statuses includes ready base events selected 
implementation uses pseudo random selection policy gives probabilistic guarantee fairness 
global counter maintained value modulo number ready events select events 
counter incremented selection preemptive scheduler introduces random element helps avoid kind resonance selection patterns 
ready base event selected abort actions base events spawned selected base event executed 
order done tricky executed leaving atomic region guarantee return tail recursive wrapper involved 
solution pass abort actions argument invokes immediately leaving atomic region 
actual argument single abort action spawns required abort actions 
section describes internals base event constructors 
logging base event ready base events logged 
logging base event requires capturing continuation thrown spawn abort actions base events apply base event wrapper functions 
base event thread id continuation constitute base event instance 
order understand logging process necessary see blocking function works 
gives code logging loop skeleton typical blocking function 
logging loop logging loop system unsafe capture fn 
val escape system unsafe escape val ref false fun log log blk escape fn 
log error log log escape fn 
log error log log error log log sts delta delta delta typical blocking function fun dirty abort fun block add thread waiting list case abort 
callcc block abort 
callcc block event logging implemented continuation passing style third argument block function called skeleton version function continues logging loop 
function error reports internal error raising exception principal purpose types 
functions capture escape unsafe versions callcc save restore exception handler continuation 
required order logging base events break tail recursion important wrapper functions contain tail recursive calls buffered channel section 
particular base event instance event selected base event instances event 
support boolean called dirty flag event instance shared base event instances 
base event instances chosen flag set true marks instances dirty 
channel operations marking flag done functions remove items waiting queues 
trick shared mark dirty instances invented norman ramsey ram 
reason technique explicit loop simple constant time cleaning dirty items charged insertion operation 
unfortunately certain situations trick result unbounded heap growth 
example thread continuously selecting communication channels channels unused channel waiting queue filled dirty requests removed 
avoid problem channel cleaned items inserted destroys constant time bound cleaning overhead 
dirty flag technique advantage simplicity 
base event constructors simplest example base event constructor builds event ready synchronization 
implementation 
expected fun fun case abort 

evt fn 
true fn 
error implementation returns true 
minimal leaves atomic region spawns abort action returns argument event value created 
returns true called base event abort action 
complicated base event constructor transmit code 
implementation transmit compared implementation fun transmit chan inq msg fun clean inq isempty inq fun val rid remove inq fun doit rid throw msg case 
callcc doit abort 
callcc doit fun flg fun block insert flg msg error transmit case 
callcc block abort 
callcc block evt implementation transmit send 
plays role case send cleans head channel inq returns true outstanding input request 
corresponds case send clean item queue sending thread enqueued ready queue request removed queue note remove takes care marking dirty flag message thrown 
abort actions spawned sending thread continuation 
corresponds case send pending input requests 
inserts continuation embodies wrappers channel continues logging loop 
abort actions spawned sender continuation 
event combinators terms implementation simplest combinator guard implementation val guard guard implementations various event combinators deal guarded event values 
discussed sections guard function essentially delay operation 
event combinator applied guard event guard lifted top level 
example implementation wrap combinator handles guard case follows fun wrap guard guard fn 
wrap wrap guarded wrapper forced evaluated event value wrapped implementations handle guard similar fashion 
implementation choose little complicated discussed 
actual implementation wrap combinator semantically similar described previously implementation details quite different 
wrapper function composed fields base event descriptor 
done mapping function list base event descriptors fun wrapper function 
combinator compose wrapper fields base event composition involves exception handler 
function wrapping handler fun fn 
handle 
fn 
handle 
handler function wrapped 
choose combinator fairly straightforward implement 
essentially takes list lists flattens single list 
events argument list passed choose guard event guard lifted top level 
care taken preserve left right order evaluation guards 
fun choose fun el evt el el gl val fn 
guard fn 
choose evt el gl evt el el gl el el gl guard el gl el gl implementation interesting combinators 
applied singleton event event consisting exactly base event implementation simply adds abort action base event done function fun case 
abort 
fn 
spawn complicated case applied event value consisting base events 
semantics require abort action spawned case base events chosen 
implemented terms individual base event abort actions spawned base event chosen 
words abort functions base events coordinate implement abort action wrapped event 
way works abort actions partitioned single leader action gamma follower actions 
special channel allocated threads communicate 
follower sends am message leader leader attempts read gamma messages executes abort action 
base event actions spawned corresponding base event selected abort action get executed 
channel threads allocated anew synchronization attempt creation abort actions protected guard 
actual implementation resulting event value guard fn 
val channel fun fn 
send val length followers fun abort accept evt leader fn 
map followers leader followers respectively base event descriptors leader follower abort actions 
implementing operations pose problems concurrent programming systems devices file descriptors unix systems form shared state require concurrency control second input operations cases output operations potential block 
described sections implementation cml supports levels synchronization unix file descriptor conditions concurrent version sml stream interface 
low level support low level base event constructors provide mechanism similar unix system call select uni fact implemented system call 
global waiting list maintained implementation entry corresponding particular instance base event value 
time preemptive scheduler called dispatches continuation checks status file descriptors waiting list 
done projecting file descriptors non dirty event instances waiting list building corresponding file descriptor sets 
call select system call poll file descriptors returns set ready descriptors 
threads waiting ready descriptors added ready queue 
complication scheme handling errors files closed 
case system call select returns error code specification file descriptor source error 
situation relatively rare moderately expensive simple linear search bad file descriptors 
file descriptor tested call ftype system call returns error file descriptor source error 
error mapped back blocked thread raising exception context 
requires saving continuations block function successful synchronization error condition 
concrete waiting list data structure event constructor block function 
waiting list corresponds pending base event instance contains file descriptor type operation waiting thread id possible continuations 
stream cml includes structure cio implements concurrent version sml streams see rep complete description 
types streams streams streams provide buffered input output operations 
open stream represented thread implements buffering 
streams protocol straightforward uninteresting 
stream protocols example advanced events build complex communication abstractions 
input operations block indefinitely waiting user enter line text necessary provide event valued interface streams 
cio structure includes operations val int 
string event val 
string event val 
string event implementation simplifying assumption write operations non blocking 
datatype type fd int file descriptor kind operation id threadid waiting thread id unit cont successful continuation unit cont error continuation dirty bool ref dirty bit val ref list delta delta delta fun flg abort callcc fn 
callcc fn 
fd fd dirty flg id continue error abort raise fd continue success abort low level support function builds event value reading specified number characters builds event value reading line input builds event value examining character read buffer 
illustration function reads line input times fun select wrap stdin wrap timeout fn 
order code sort properly implementation stream event constructors satisfy requirements commit point event correspond availability input satisfies request 
input lost discarded 
implementation uses request reply protocol simple version described section 
order meet requirement commit point server reply means request generated guard 
meeting requirement means server thread informed request aborted 
scenario discussed section client side code similar 
example client side implementation fun reqch 
guard fn 
val channel replych channel spawn fn 
send reqch receive replych receive replych fn 
send event value constructed function guard sends request server consisting operation abort event reply channel 
commit point event receiving reply server 
client synchronizes event abort action sends abort message server 
server side request comes server attempts satisfy input buffer requesting input operating system 
server satisfy request synchronizes choice sending input reply receiving abort message abort channel 
case input reinserted buffer 
implementation improvements current implementation cml uses practically specialized run time compiler support 
number techniques run time system compiler improve performance 
simple modification requires little introduce dedicated register referring thread ready queue 
benefits reduce memory traffic eliminate store list allocations associated ready queue updates 
register refer current thread id global ref variable improved speed thread context switching 
suggests thread context switching improve dedicated ready queue register 
clock speed risc processors increases potential savings larger 
pml compiler event value constructors channel operations explicitly represented 
pml compiler aggressive intermodule inlining actual implementation uses condition variable abort message see section 
able recognize applications sync static event values optimized efficient operations 
example sync receive ch replaced accept ch faster 
modest improvement achieved inline expansion sync transmit receive 
possible compilers recognize complex communication patterns 
common example thread encapsulate state rpc interface 
case time server thread dispatched handle operation client thread suspended waiting reply 
efficient implementation pattern monitor see section encapsulate state 
contention monitors avoid necessity context switches entry exit comparison costs context ada 
providing monitors language level may possible compiler detect monitor suitable translate rpc operations monitor calls done ada rendezvous hn 
ada cml syntactic mark rpc style interactions derived operations 
automatically recognizing rpc operation single threaded difficult problem 
communication patterns recognized compiler include channels exactly channels point point communication 
example consider rpc protocol reply channel dynamically allocated request implementation input streams described section 
reply channel exactly replaced condition variable reduces communication overhead 
may case non uniform memory access multiprocessors client encapsulated data different processors see chapter 
chapter performance previous chapter described implementation cml detail chapter report various performance measurements implementation 
measurements include timing results collection small benchmarks different workstations instruction counts benchmarks mips processor 
addition compare performance cml system thread package 
measurements show cml provides high level notation competitive price 
benchmarks conducted series benchmarks different machines representing different processor architectures 
table summarizes features computers 
benchmarks measure cost low level concurrency operations sending table benchmark machines sparc dec full name cube sparcstation decstation processor mhz mhz sparc mhz memory mb mb mb operating system nextstep sunos ultrix message get accurate numbers measured time perform operations 
benchmark measured cpu time spent executing program user system time spent garbage collector 
times micro seconds 
benchmarks run version sml nj released november version cml released october 
iterations loop operations 
benchmarks logically divided groups measure basic concurrency primitives thread switch 
measures cost explicit context switch 
thread spawn exit 
measures time takes spawn run null thread 
includes cost context switches spawn operation switches control newly spawned thread terminating thread dispatch new thread 
rendezvous 
measures cost send accept rendezvous threads 
event rendezvous 
implementation rendezvous benchmark sync composed transmit receive send accept 
second group measures cost different versions rpc implementation simple service 
service essentially memory cell transaction sets new value returns old value 
rpc 
uses send accept implement protocol 
client side code fun call send reqch accept replych event rpc 
implements protocol event value 
client side code fun call sync wrap transmit reqch fn 
accept replych fast rpc 
uses condition variable see section implement fast asynchronous reply 
client side code call fun call val condvar send reqch readvar replych timing results measured times benchmarks table 
entry form combined user system time operation amortized garbage collection overhead 
entry average test runs little deviation runs 
real time measurements slightly higher cpu time measurements 
table cml benchmarks time operation program garbage collection operation sparc dec thread switch thread spawn exit rendezvous event rendezvous rpc event rpc fast rpc instruction counts andrew appel modified mips code generator generate instrumentation counts number executed instructions 
mechanism measured instruction counts various benchmarks 
table gives results measurements 
numbers include loop garbage collection overhead 
table mips instruction counts operation instructions operation thread switch thread spawn exit rendezvous event rendezvous rpc event rpc fast rpc numbers higher expect particularly thread switch creation operations 
rep reported thread switch required instructions sparc processor half measured mips 
mips sparc risc processors difference instruction sets changes sml nj compiler appel personal communication december 
hope improvements compiler reduce instruction counts reasonable values example thread context switch require instructions 
analysis measurements show penalty interfaces hiding channel communication event values acceptable 
table gives ratio time event version non event version communication protocols benchmarked 
simple rendezvous performance cost events table cost abstraction protocol rendezvous rpc machine cost ratio cost ratio sparc dec rpc 
reason lower impact rpc protocol cost communications represented event value 
general communication commit point needs implemented event value communications guard wrapper implemented send accept 
garbage collection overhead high garbage collection overhead benchmarks result way current sml nj collector simple generational collector keeps track intergenerational app 
time mutable object updated record update added store list 
store list examined potential roots garbage collection 
implementation cml uses small number frequently updated objects thread ready queue current thread pointer channel waiting queues 
hot spot behavior worst case scenario sml nj collector destroying normally expected copying collection 
collector suffers problem poor real time responsiveness 
comparison system put measurements perspective implemented similar set benchmarks version system light weight process library bs 
system provides threads request reply communication primitive shared memory primitives selective communication 
runs sparcstation decstation 
table reports results sparcstation table system benchmarks sparc dec operation time ratio time ratio task switch task create send receive send receive reply decstation 
times micro seconds represent sum user system cpu times obviously garbage collection overhead 
column labeled ratio gives ratio system cml times including garbage collection overhead ratio greater means cml faster 
sparcstation cml uniformly faster system 
principal reason sml nj sparc register windows flush thread switch 
comparison decstation favorable cml competitive system provides lower level concurrency model selective communication example 
shows advantages higher level language sacrificing performance 
chapter multiprocessors main thrust dissertation study concurrency tool structuring programs worth considering issues associated possible multiprocessor implementation cml 
chapter survey various parallel language features parallel programming techniques discuss apply parallel programming cml 
discuss implementation issues addressed multiprocessor implementation cml summarize prospects multiprocessor cml 
purposes chapter assume multiple instruction multiple data mimd machine shared address space 
experimental commercial examples machines reasonable expect appear desks near 
machines provide shared memory model usually non uniform memory access numa processor may local memory cache 
numa maintaining locality important performance number processors increases numa effects pronounced 
programs written message passing language typically locality perform shared memory versions ls 
benefits obtained multiprocessor implementation cml 
existing applications exene fairly limited amounts parallelism typically ready threads time multiprocessor implementation result noticeable performance improvements existing applications 
owicki reports improvements kinds applications written modula running firefly multiprocessor 
particular mentions trestle window system exploits multiprocessor pipelining graphics operations 
exene designed pipelining running multiprocessor improve performance 
course programs including highly sequential ones benefit parallel garbage collection 
multiprocessor implementation available reasonable implement parallel algorithms 
examples parallel attribute grammar evaluation zar parallel theorem provers parallel graphics algorithms gre 
parallel programming cml section examines cml parallel programming language 
parts discussion discuss parallel programming techniques apply cml second describe possible extensions provide better support parallel programming 
proposed extensions represent changes semantics cml approach define new communication operations derived cml primitives amenable efficient implementation multiprocessors 
pipelining data flow class parallel programs naturally expressed cml programs structured data flow networks km 
data flow network consists graph computation nodes edges communication links landin streams lan precursor 
data flow graph static computation node replaced subgraph having interface 
data flow graphs provide parallelism ways 
computation nodes depend data compute parallel 
dependency operate sequence values form pipeline 
order data flow network efficient granularity operations individual nodes large compensate communication overhead 
threads computation nodes channels edges data flow network directly implemented cml 
example exene thread network essentially data flow network see section 
example rep describe pipelined implementation sieve eratosthenes cml 
nice illustration data flow networks mcilroy mci describes processes channels compute power series suggested km implementation details 
mcilroy represents power series stream rational coefficients 
example power series exponential function 
delta delta delta implemented cml follows fun val ch channel fun loop send ch num denom loop spawn fn 
loop ch representation operations addition multiplication power series coded networks threads see mci details 
controlling parallelism key problems writing parallel programs avoiding excessive parallelism 
basic technique parallel programs divide problem pieces spawn thread piece 
pieces processors technique leads excessive parallelism cost thread management dominate execution time 
premature limiting parallelism result starvation idle processors 
crews approach limiting excessive parallelism concurrent programs crew abstraction rv 
scheme fixed set threads called workers execute jobs taken queue job piece computation 
worker gets job computed parallel pieces chooses piece generates gamma help requests remainder 
worker finishes piece checks see help requests answered 
worker computes piece job job completed 
completing job worker looks help requests workers finds job 
sketches code job consisting pieces 
addition providing mechanism limiting parallelism crews important property breadthfirst parallel decomposition results coarse grain parallelism 
jobs rv term tasks refer jobs 
fun job job job job job job job job crew job decomposition decomposed eagerly worker starvation avoided 
extra workers available job execution reduces standard sequential order 
structuring job decomposition breadth manner probably important benefit crews provide cml 
thread creation space overhead low cml implementation crews thread job enable subset threads run time 
token mechanism job thread wait token executing pass token job completed 
scheme token holder corresponds worker 
futures semantics futures concurrent lisp systems provide opportunity limiting parallelism 
consider general form creation context call 
keyword viewed annotation tells compiler candidate parallel evaluation 
actual evaluation immediate called inline evaluation parallel demands value 
approach choose dynamically inline parallel evaluation current load called load inlining kh 
problem approach rate thread creation program may uniform decision inline point may lead starvation 
furthermore load inlining introduce deadlock 
alternative load inlining lazy task creation scheme inlines evaluation saves information spawn thread evaluate parallel number ready tasks falls number processors 
scheme quite similar crews effect requires effort programmer 
futures lazy task creation implemented cml fairly easily 
assuming global channel val continue unit chan new threads operation implemented follows fun val condvar spawn fn 
writevar select receive continue wrap fn 
idea idle processor sends message continue channel wake waiting thread 
channel communication fifo results desired breadth problem decomposition 
course efficient directly implement futures lazy task creation callcc techniques 
cml principal advantage lazy task creation doesn introduce deadlock case body attempts synchronize parent 
speculative parallelism certain classes parallel programs parallel search speculative parallelism improve performance 
example consider problem finding item balanced binary tree searching subtrees parallel running time search reduced log sufficient supply processors 
example trivial illustrative problems arising applications theorem provers 
addition problem controlling excessive parallelism discussed section problem terminating unnecessary computations thread item reason keep searching 
cml currently support asynchronous termination threads necessary add kill operation thread ids 
aspect thread termination recognizing threads need killed 
important note speculative threads referentially transparent killing changes semantics program 
note version simplified ignoring issue exceptions cf section 
attractive tricky approach garbage collect threads able run irrelevant execution program 
way give garbage collector special knowledge channel thread objects allows trace thread interconnections bh 
problem technique cml interact implementation threads ordinary sml values 
strategy suitable cml judicious weak pointers representations concurrency objects 
weak pointers supported sml nj way hold object allowing garbage collector option collecting 
garbage collection object weak pointers garbage collector collects object weak pointers refer 
weak pointers mechanism implemented gives parent thread strong pointer object gives child thread weak pointer 
parent discards object child weak pointer nullified object finalization rov child thread collected 
similar scheme described 
simple technique similar utility weak pointer scheme exploit guard combinators implement speculative fork operation fun fork guard fn 
val cv condvar val id spawn fn 
writevar cv cv fn 
kill id multiple instances select implements parallelism 
thread finish provides answer triggers abort actions choices kill threads 
example function sorts list testing see sorted parallel fun select fork fn 
sort fork fn 
isordered exit sort sorting function isordered tests list see sorted 
cml implementation collects unreachable blocked threads threads ready threads reachable ready queue 
structures parallel programming functional language id provides form mutable state called structures anp nik 
structures come various flavors including aggregate structures arrays 
condition variables essentially value return mechanism 
futures promoted useful mechanism parallel programming lisp community hal kh 
discussed section futures implemented channels implementation condition variables significant advantage avoiding context switch time value read 
condition variables example called structures parallel language id anp nik 
id provides structures various flavors including aggregate structures arrays 
discussion structures parallel programs small example programs anp 
structures form state supported id structure bna 
structures empty full 
basic operations structures put initializes cell structures raises exception cell value take removes returns contents cell making empty 
take operation forces synchronization thread may wait thread put value cell 
similar ports memory described ks 
structures viewed finitely buffered asynchronous channel slot 
cml structured variables interface type mstruct val mstruct unit 
mstruct val put mstruct 
unit exception put val mstruct 
event val take mstruct 
structures mutable allocation function weakly polymorphic 
mentioned take operation involves synchronization event valued form provided 
put attempted full cell exception put raised 
condition variables proved quite useful cml programs single shot communication required abort messages see section 
structures updated atomically threads update protocol put take computes new value previous value 
reason update atomic take operation locks variable take operations threads similar safety shared request reply channels discussed section 
paul barth mit developed number parallel algorithms id structures barth personal communication august examples bna 
structures defined derived feature cml gives implementation interface 
parallel implementation cml structures datatype mstruct unit chan chan chan fun mstruct val channel val channel channel fun undefined defined accept defined select wrap transmit fn 
undefined wrap transmit fn 
defined spawn undefined fun 
receive fun take 
accept exception put fun put select wrap receive fn 
raise put transmit cml implementation structure variables implemented directly top low level shared memory primitives making efficient 
operations id supports structures non destructive read operation directly supported 
multiprocessor implementation designing building high performance multiprocessor cml implementation major research project right leave 
possible identify discuss major implementation issues 
concurrency control uniprocessor implementation described section relies single global mutex lock guaranteeing atomic access channel thread data structures see section description mutex locks 
uniprocessor global lock efficient approach reduces locking overhead cause loss parallelism 
multiprocessors single global lock cause contention idle processors 
example processor machine thread able communicate thread parallel communication threads means channels locked independently 
different multiprocessors provide different kinds support locking 
common mechanism test set instruction atomically applies function word fun true true false operation implement spin lock busy waiting mutex lock fun fun false sophisticated implementation exponential back techniques improve performance see cs comparison locking techniques 
multiprocessors provide hardware support locking lamport developed algorithm cases optimal number memory reads writes lam 
machines provide test set limited number memory locations case software locks implemented top hardware supported spin locks 
generalized selective communication separate lock channel data structure implementation sync applied choice multiple communications significantly complicated 
example naive implementation select list communications grab locks channels operation 
fails situation 
assume threads running different processors attempting select receive transmit simultaneously attempts select receive receive result situation holds lock needs lock holds lock needs lock deadlock 
various known algorithms problem see bs bor bag 
basic strategy tentative offers communication tentative offers match thread freeze state thread commits rejects communication 
choice thread fix state order threads ids avoids possibility cyclic dependencies deadlock 
greg morrisett implemented protocol similar bor top ml threads greg morrisett personal communication july 
thread scheduling techniques data structures thread scheduling significant impact multiprocessor performance contention thread queues cache consistency effects 
single global scheduling queue significant source contention 
furthermore single queue provide mechanism keeping thread single processor important preserving cache consistency 
accordingly cut clear processor queue ready threads 
policy needed balance load 
possibility balance scheduling queues garbage collection time 
typical memory allocation rates ml programs high order megabytes second sparcstation processor runs wait long load balancing 
fall back allow idle processor force garbage collection idle milliseconds 
scheme advantage insuring scheduling queue accessed processor load balancing means light weight locking mechanism single processor implementation see section protect queue 
scheduling queue single heavily accessed shared data structure scheme provide performance 
question needs answered empirical tests processors run threads schedule 
implementation mul uses thread queues processor threads run called new thread queue threads suspended called suspended thread queue 
selecting new thread dispatch processor scheduler looks suspended thread queue new thread queue processors new thread queue lastly thread looks processors suspended thread queues 
selecting new threads suspended threads migrating threads impact cache consistency thread migration reduced 
memory management implementations heap languages sml cml live die performance memory allocation garbage collection techniques 
efficient multiprocessor implementation cml address memory management issues 
important avoiding contention memory allocation 
standard scheme address problem divide allocation space multiple chunks give processor allocation chunk ael kh mar 
processor fills allocation chunk grabs global list free chunks 
source allocation contention accesses global chunk list relatively rare 
allocation chunks exhausted necessary perform garbage collection 
world collector requires synchronizing processors collection state 
possible technique force synchronization processor notes need garbage collection unix signal notify processors kh 
approach wait processors exhaust allocation chunks mar 
avoid problems case infinite non allocating computation global flag set checked signal handler 
allocation rates sml nj high typically byte word instructions idle time processor initiated garbage collection costly overhead signals interrupt processors 
processors collection state garbage collection 
simplest technique run standard collection algorithm single processor 
clear disadvantage increasing cost garbage collection relative rest program 
sequential collector performance bottleneck desirable garbage collect parallel 
number systems parallel garbage collection kh mar 
techniques mar fit sml nj memory management system fairly 
scheme processor space 
collector process encounters space object sweeping space examines object descriptor 
descriptor forward pointer collector process updates space 
object forwarded collector process locks descriptor word allocates space space sets forward pointer unlocks descriptor copies object 
machines sgi limited number hardware locks hashing scheme object address multiplex hardware locks 
lock object descriptor held instructions contention rare 
techniques suffer problem world garbage collection 
generational techniques reduces frequency noticeable pauses ung providing uniform responsiveness real time applications user interfaces requires interleaving garbage collection activities mutator computation 
multiprocessor obvious approach dedicate processors task garbage collection 
principal technical problem interleaving mutator garbage collection activity synchronization 
synchronization overhead high performance benefits lost 
lieu special purpose hardware virtual memory system implement synchronization ael 
outlook multiprocessor cml chapter described number issues related implementation multiprocessor version cml 
done supporting cml multiprocessors 
greg morrisett implemented low level library multiprocessing primitives spin locks sml nj sgi mor 
provide suitable base implementing multiprocessor version cml 
multiprocessor implementation exists possible experiment different styles parallel programming 
flexibility provided class synchronous operations means cml accommodate different parallel programming paradigms serious disruption incompatibilities existing code 
condition variables form structures provide right primitives programming parallel algorithms semantically consistent cml primitives techniques crews lazy futures provide reasonable mechanisms controlling parallelism 
part chapter dissertation comprehensive treatment design semantics application implementation concurrent language room additional research implementation 
structure dissertation topics research divided design theory practice 
design design cml evolved number years practical experience fairly mature 
amount practical experience mechanisms cml change radical way 
couple areas exploration 
attractive aspects cml supports wide range concurrency mechanisms small set core primitives 
possible area exploration take reductionist approach choice primitives 
cml uses synchronous message passing basic synchronous operation primitive choices 
example variation low level shared memory primitives possible 
factor communication primitive synchronous operations 
exercise intellectually interesting suspect resulting language design low level 
synchronous message passing provide happy medium low level performance high level abstraction 
discussed section choosing synchronous message passing primitive synchronization mechanism limits rendezvous threads 
limitation interferes potentially useful class abstractions threads implement active channels 
example active channel channel logs message traffic debugging purposes 
approach supporting abstractions add multiway rendezvous primitive cha 
implementation details remain worked solutions problem discussed chapter cm called committee coordination problem 
original prototype class synchronous operations implemented included support events programs 
lack closures limited usefulness events adding events language modula prove satisfactory objects provide closure mechanism nel 
theory section described number ways enrich cv calculus fully model cml 
remains prove type soundness results extended calculus 
particular combination exceptions channels potential sources type system loopholes shown sound 
operational semantics chapter basis theory class synchronous operations 
number transformations event values shown semantics preserving 
example representation event values implementation described rewriting system event values 
showing rewriting event value preserves meaning significant step showing implementation correct 
section number optimizations suggested replacing channels condition variables 
theory events provide framework showing optimizations safe 
proving results requires notion event value equivalence obvious definition event values equivalent indistinguishable contexts 
definition requires turn notion process equivalence 
active area theoretical research blo different notions means processes equivalent 
various reasons think modified notion testing equivalence hen suitable developing results 
practice gain experience cml certain common abstractions may emerge 
supporting abstractions directly primitives performance improved substantially 
condition variables discussed section example fact closure modula object type apply method 
rpc abstraction reduces overhead see chapter 
possible candidate buffered channels interactions external processes server 
important note adding new primitive operations change semantics cml semantically derived operations 
glaring weakness cml lack debugging facilities 
short term solution provide version cml primitives allows monitoring communication thread scheduling ambitious scheme provide interactive debugger 
andrew tolmach responsible sml nj debugger ta working concurrent version safe version ml threads ta 
adapted cml fact cml may better target ml threads shared state clearly defined 
chapter discussed issues relating implementation cml multiprocessors 
view important direction implementation 
multiprocessor server machines common technology trickle single user workstations years 
cml provides natural migration path sml applications benefit parallel processing capabilities multiprocessor workstation 
number active ongoing projects cml 
emden gansner continuing develop exene plan part foundation interactive programming environments rg gr 
dml project cornell university exploring issues distributed systems cml starting point kru 
applications help guide evolution cml implementation 
chapter concurrent programming area growing importance little progress design concurrent languages 
example modula encompasses ideas sequential language design uses concurrency features date back nel 
dissertation new approach concurrent language design supports higher level concurrent programming 
key new idea treat synchronous operations class values composed new synchronous operations 
allows different styles communication supported linguistic framework 
call new style programming higher order concurrent programming analogy higher order programming languages ml 
dissertation broad look new approach concurrent language design exploring design theory practice class synchronous operations 
ideas thesis context language cml extension sml supports class synchronous operations 
cml illustrate usefulness practicality approach 
chapter show number synchronization communication abstractions languages implemented cml class citizens 
demonstrates cml support different concurrent paradigms single linguistic framework 
developed formal underpinnings class synchronous operations 
chapter give operational semantics simple untyped language called cv class synchronous operations 
language includes concurrency features cml substantial step formal definition cml 
chapter define polymorphic type discipline cv tradition ml type systems prove type system sound respect operational semantics cv knowledge proof type soundness polymorphic concurrent language 
cml implemented build non trivial applications 
significant exene multi threaded window system toolkit 
exene applications cml described chapter 
cml publically distributed november number researchers 
implementation cml described chapter performance measurements reported chapter 
cml implement substantial applications performance implementation competitive lower level concurrency packages demonstrates cml useful practical language systems programming 
respects cml system important result research expect provide solid basis research development years come 
plan implement cml shared memory multiprocessor chapter discusses issues related 
bibliography ab arvind brock 
streams managers 
operating systems engineering proceedings th ibm computer science symposium vol 
lecture notes computer science 
springer verlag october pp 

ab abramsky 
pascal language loosely coupled distributed systems 

eds distributed computing systems pp 

academic press new york 
ael appel ellis li 
real time concurrent collection stock multiprocessors 
proceedings sigplan conference programming language design implementation june pp 

agh agha actors model concurrent computation distributed systems 
mit press cambridge mass 
aj appel jim 
continuation passing closure passing style 
conference record th annual acm symposium principles programming languages january pp 

am appel macqueen 
standard ml compiler 
functional programming languages computer architecture vol 
lecture notes computer science 
springer verlag september pp 

am appel macqueen 
standard ml new jersey 
programming language implementation logic programming vol 
lecture notes computer science 
springer verlag august pp 

anderson performance spin lock alternatives shared memory multiprocessors 
technical report department computer science university washington august 
andrews concurrent programming principles practice 
benjamin cummings redwood city california 
anp arvind nikhil pingali 
structures data structures parallel computing 
acm transactions programming languages systems october pp 

andrews olsson 
overview sr language implementation 
acm transactions programming languages systems january pp 

app appel simple generational garbage collection fast allocation 
software practice experience february pp 

app appel runtime system 
lisp symbolic computation november pp 

app appel compiling continuations 
cambridge university press new york 
andrews schneider 
concepts notations concurrent programming 
acm computing surveys march pp 

bag bagrodia synchronization asynchronous processes csp 
acm transactions programming languages systems october pp 

bar barendregt lambda calculus vol 
studies logic foundations mathematics 
north holland revised edition 
bb berry boudol 
chemical machine 
conference record th annual acm symposium principles programming languages january pp 

birman cooper joseph marzullo kane schmuck wood 
isis system manual version 
computer science department cornell university ithaca march 
bose clarke long michaylov 
parallel theorem prover non horn clauses 
proceedings th annual symposium logic computer science june pp 

bd bryant dennis 
concurrent programming 
operating systems engineering proceedings th ibm computer science symposium vol 
lecture notes computer science 
springer verlag october pp 

bh baker jr hewitt 
incremental garbage collection processes 
proceedings symposium artificial intelligence programming languages august pp 

blo bloom ready simulation bisimulation semantics ccs languages 
ph dissertation massachusetts institute technology laboratory computer science october 
available mit lcs tr 
berry milner turner 
semantics ml concurrency primitives 
conference record th annual acm symposium principles programming languages january 
appear 
bna barth nikhil arvind 
structures extending parallel nonstrict functional language state 
functional programming languages computer architecture vol 
lecture notes computer science 
springer verlag august pp 

bor protocol generalized occam 
software practice experience september pp 

bri brinch hansen architecture concurrent programs 
prentice hall englewood cliffs 
bri brinch hansen joyce language report 
software practice experience june pp 

bs buckley silberschatz 
effective implementation generalized input output construct csp 
acm transactions programming languages systems april pp 

bs buhr 
system providing light weight concurrency shared memory multiprocessor computers running unix 
software practice experience september pp 

bur burns programming occam 
addison wesley reading mass 
car cardelli amber 
combinators functional programming languages vol 
lecture notes computer science 
springer verlag july pp 

car cardelli typeful programming 
technical report dec systems research center may 
cd cooper draves 
threads 
technical report cmu cs school computer science carnegie mellon university february 
cl ement despeyroux despeyroux kahn 
simple applicative language mini ml 
conference record acm conference lisp functional programming august pp 

cha multiway rendezvous 
acm transactions programming languages systems july pp 

chl cooper harper lee 
fox project advanced development system software 
technical report cmu cs school computer science carnegie mellon university august 
cm chandy misra 
parallel program design foundation 
addisonwesley reading mass 
cm cooper morrisett 
adding threads standard ml 
technical report cmu cs school computer science carnegie mellon university december 
con constable implementing mathematics nuprl development system 
prentice hall englewood cliffs 
cor cormack micro kernel concurrency software practice experience may pp 

short communication 
cs crummey scott 
algorithms scalable synchronization shared memory multiprocessors 
acm transactions computer systems february pp 

dam damas type assignment programming languages 
ph dissertation department computer science university edinburgh april 
dh dybvig hieb 
engines continuations 
computing languages pp 

duba harper macqueen 
type checking class continuations 
conference record th annual acm symposium principles programming languages january pp 

dij dijkstra guarded commands formal derivation programs 
communications acm august pp 

dm damas milner 
principal types functional programs 
conference record th annual acm symposium principles programming languages january pp 

dod manual ada programming language january 
harvey price 
rendezvous monitor concepts efficiency difference 
proceedings acm sigplan symposium ada programming language december pp 

fel felleisen calculi lambda cs conversion imperative higherorder programming languages 
ph dissertation computer science department indiana university 
available technical report nr 

fel felleisen reflections landin operator partly historical note 
computer languages pp 

ff felleisen friedman 
control operators secd machine calculus 
wirsing ed formal description programming concepts iii pp 

north holland new york 
flp fischer lynch paterson 
impossibility distributed consensus faulty process 
journal acm april pp 

fy francez yemini 
symmetric intertask communication 
acm transactions programming languages systems october pp 

gc gehani 
concurrent programming ada language polling bias 
software practice experience may pp 

gl george lindstrom 
functional language graph reduction program multiprocessor machines 
technical report uucs department computer science university utah october 
gm gehani eds 
concurrent programming 
addisonwesley reading mass 
gmp mishra prasad 
facile integration concurrent functional programming 
tapsoft vol 
vol 
lecture notes computer science 
springer verlag march pp 

gmw gordon milner wadsworth 
edinburgh lcf vol 
lecture notes computer science 
springer verlag new york 
gor gordon denotational description programming languages 
springer verlag new york 
gr gehani 
concurrent software practice experience september pp 

gr gansner reppy 
exene 
third international workshop standard ml carnegie mellon university september 
gr gansner reppy 
foundation user interface construction 
myers ed languages developing user interfaces pp 

jones bartlett boston mass 
gre green parallel processing computer graphics 
mit press cambridge mass 
haa montage breaking windows small pieces 
usenix summer conference june pp 

hal halstead jr multilisp language concurrent symbolic computation 
acm transactions programming languages systems october pp 

har harper standard ml 
technical report ecs lfcs laboratory foundations computer science computer science department edinburgh university august 
hdb hieb dybvig bruggeman 
representing control presence class continuations 
proceedings sigplan conference programming language design implementation june pp 

hen hennessy algebraic theory processes 
mit press cambridge mass 
hn habermann 
efficient implementation ada tasks 
technical report cmu cs computer science department carnegie mellon university january 
hoa hoare monitors operating system concept 
communications acm october pp 

hoa hoare communicating sequential processes 
communications acm august pp 

hoa hoare communicating sequential processes 
prentice hall englewood cliffs 
hol holmstrom functional language parallel programming 
declarative programming workshop april pp 

hol holt concurrent euclid unix system 
addison wesley reading mass 
hs hindley seldin 
combinators calculus 
cambridge university press new york 
inm inmos limited 
occam programming manual 
prentice hall englewood cliffs 
kh kranz halstead jr mul high performance parallel lisp 
proceedings sigplan conference programming language design implementation june pp 

kkr kranz kelsey rees hudak philbin adams 
orbit optimizing compiler scheme 
proceedings sigplan symposium compiler construction july pp 

km kahn macqueen 
coroutines networks parallel processes 
information processing august pp 

kafura nelson 
garbage actors 
oopsla ecoop proceedings october pp 

kru dml packaging high level distributed abstractions sml 
proceedings cmu workshop standard ml september 
ks kieburtz silberschatz 
comments communicating sequential processes 
acm transactions programming languages systems april pp 

kwiatkowska survey fairness notions 
information software technology september pp 

lam lamport fast mutual exclusion algorithm 
acm transactions computer systems february pp 

lan landin correspondence algol lambda notation part communications acm february pp 

liskov curtis johnson scheifler 
implementation argus 
proceedings th acm symposium operating system principles november pp 

liskov herlihy gilbert 
limitations synchronous communication static process structure distributed programming 
conference record th annual acm symposium principles programming languages january pp 

lr lampson redell 
experience processes monitors mesa 
communications acm february pp 

ls liskov scheifler 
guardians actions linguistic support robust distributed programs 
acm transactions programming languages systems july pp 

ls liskov shrira 
promises linguistic support efficient asynchronous procedure calls distributed systems 
proceedings sigplan conference programming language design implementation june pp 

ls lin snyder 
comparison programming models shared memory multiprocessors 
international conference parallel processing vol 
pp 

mar parallel implementation lazy ml 
functional programming languages computer architecture vol 
lecture notes computer science 
springer verlag august pp 

mat matthews processes poly ml 
papers poly ml technical report 
university cambridge february 
mci mcilroy power series 
software practice experience july pp 

miller epstein 
garbage collection preliminary version 
parallel lisp languages systems vol 
lecture notes computer science 
springer verlag june pp 

mohr kranz halstead jr lazy task creation technique increasing granularity parallel programs 
ieee transactions parallel distributed systems july pp 

longer version available dec crl report november 
mms mitchell maybury sweet 
mesa language manual version 
xerox parc april 
mor morrisett multi processor interface sml 
cmu technical report preparation 
mt milner tofte 
commentary standard ml 
mit press cambridge mass 
mth milner tofte harper 
definition standard ml 
mit press cambridge mass 
nel nelson remote procedure call 
ph dissertation computer science department carnegie mellon university may 
available xerox parc report csl 
nel nelson 
ed 
systems programming modula 
prentice hall englewood cliffs 
nik nikhil id language manual 
laboratory computer science mit cambridge mass july 
protocol manual vol 

reilly associates 
xlib programming manual vol 

reilly associates 
osborne speculative computation multilisp 
parallel lisp languages systems vol 
lecture notes computer science 
springerverlag june pp 

owicki experience firefly multiprocessor workstation 
technical report dec systems research center september 
pau paulson ml working programmer 
cambridge university press new york 
pik pike concurrent window system 
computing systems pp 

plo plotkin call name call value calculus 
theoretical computer science pp 

ram ramsey concurrent programming ml 
technical report cs tr department computer science princeton university april 
rc rees clinger eds 
revised report algorithmic language scheme 
sigplan notices december pp 

rep reppy synchronous operations class values 
proceedings sigplan conference programming language design implementation june pp 

rep reppy class synchronous operations standard ml 
technical report tr computer science department cornell university december 
rep reppy asynchronous signals standard ml 
technical report tr computer science department cornell university august 
rep reppy concurrent programming events concurrent ml manual 
computer science department cornell university ithaca november 
revised october 
rep reppy cml higher order concurrent language 
proceedings sigplan conference programming language design implementation june pp 

rep reppy operational semantics class synchronous operations 
technical report tr computer science department cornell university august 
rg reppy gansner 
foundation programming environments 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments december pp 

levin wick 
extending modula building large integrated systems 
technical report dec systems research center january 
ros rosen degrees availability general theory data flow analysis 
muchnick jones eds program flow analysis theory applications pp 

prentice hall englewood cliffs 
rov adding garbage collection runtime types strongly typed statically check concurrent language 
technical report csl xerox parc july 
rv roberts vandevoorde 
abstraction controlling parallelism 
technical report dec systems research center april 
sg scheifler gettys 
window system 
acm transactions graphics april pp 

sr saraswat rinard 
concurrent constraint programming 
conference record th annual acm symposium principles programming languages january pp 

ste steele jr rabbit compiler scheme 
master dissertation mit may 
ta tolmach appel 
debugging standard ml reverse engineering 
conference record acm conference lisp functional programming june pp 

ta tolmach appel 
concurrency extensions standard ml 
proceedings acm onr workshop parallel distributed debugging may pp 

tof tofte operational semantics polymorphic type inference 
ph dissertation department computer science university edinburgh may 
tof tofte type inference polymorphic 
information computation pp 

ung ungar generation scavenging non disruptive high performance storage reclamation algorithm 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments april pp 

uni university california berkeley 
unix programmer manual bsd 
wan wand continuation multiprocessing 
conference record lisp conference august pp 

wf wright felleisen 
corrigendum syntactic approach type soundness july 
wf wright felleisen 
syntactic approach type soundness 
technical report tr department computer science rice university april 
ws wegner smolka 
processes tasks monitors comparative study concurrent programming primitives 
ieee transactions software engineering july pp 

zar parallel evaluation attribute grammar systems 
ph dissertation computer science department cornell university august 
available technical report 
appendix appendix proofs chapter appendix contains detailed proofs lemmas chapter 
includes additional definitions lemmas needed proofs 
proof lemma proving substitution lemma need couple minor lemmas 
lemma extends substitution type judgements 
lemma substitution te te proof 
proofs similar system tof lemma tof lemma 
xi lemma says typing assumptions type environment type derivation generalized affecting result 
lemma te sigma fx 
oeg oe oe te sigma fx 
oe proof 
proof induction height deduction te sigma fx 
oeg case analysis step analysis shape 
interesting cases involving variable typing component te 
recall variable convention means bound case lemma means te applying lemma get te sigma fx 
oe oe oe oe oe te sigma fx 
oe rule var 
case 
rule abs applies te sigma fx 
oe 
te sigma fx 
oeg induction hypothesis te sigma fx 
oe 
applying rule abs get te sigma fx 
oe case rule app applies te sigma fx 
oeg te sigma fx 
oe 
clos te oeg te sigma fx 
oeg induction hypothesis te sigma fx 
oe te sigma fx 
oe 
clos te oeg oe oe lemma gives clos te oe clos te oeg apply induction hypothesis get te sigma fx 
oe 
clos te oe rule app get te sigma fx 
oe case follows argument previous case 
case chan case similar case 
xi lemma substitution fv te te sigma fx 
ff delta delta delta ff fff ff ftv te te 
proof 
proof wf proceeds induction height deduction te sigma fx 
ff delta delta delta ff case analysis step 
te vt ct vt vt sigma fx 
ff delta delta delta ff te vt ct discussion 
skip cases terms covered rules cases follow app const 
recall variable convention means bound case step rule const typeof applying rule const get te 
done 
case rule var vt 
vt te vt ff delta delta delta ff rule var ff delta delta delta ff means substitution dom fff ff lemma gives te implies te dom ftv te te te te case rule applies ct 
apply get te 
case rule app applies te te te induction hypothesis rule app te 
te 
te 

te 
case 
case similar previous case 
case 
rule abs applies te sigma fx 
te 
substitution fff 
fi ff 
fi ff fi ftv te distinct 
lemma te sigma fx 
note te te dom ftv te te sigma fx 
variable convention insures fv lemma gives te sigma fx 
choice means ftv te sigma fx 
fff ff facts coupled induction hypothesis gives te sigma fx 

substitution bijection gamma exists lemma gamma te sigma fx 

gamma simplifying get te sigma fx 

applying abs get te sigma fx 

te 
te 

case case non expansive step type deduction rule app te te sigma fx 
clos te te te lemma gives te sigma fx 
clos te recall fff ff ftv te fff ff ftv te sigma fx 
clos te fff ff ftv te ftv clos te fff ff ftv clos te fff ff ftv ftv ftv te fff ff ftv ftv te fff ff ftv ftv te ftv ff delta delta delta ff fff ff ftv ftv ff delta delta delta ff fff ff ftv ftv fff ff second premise app induction hypothesis give te sigma fx 
clos te 
note clos te apply lemma get te sigma fx 

induction hypothesis app te 
te sigma fx 

te 

te 
case case expansive rule imp applies te te sigma fx 
appclos te te choose substitution fff ff fu um um distinct imperative type variables bijection fu um ftv te ftv fff ff lemma tells te sigma fx 
appclos te dom ftv te dom ae te sigma fx 
appclos te fv te te sigma fx 
appclos te appclos te delta delta delta ft ftv ftv te fff ff ftv te sigma fx 
delta delta delta fff ff ftv te ftv delta delta delta fff ff ftv ft inductive hypothesis te sigma fx 
appclos te 
chosen bijection gamma exists lemma gamma te sigma fx 
appclos te 
gamma simplifying get te sigma fx 
appclos te 
appclos te lemma applies te sigma fx 

induction hypothesis te 
apply app te 
te sigma fx 
appclos te 
te 

te 
case chan rule chan applies te sigma fx 
chang te chan variable convention fv lemma gives te sigma fx 
chang induction hypothesis rule chan te sigma fx 
chang 
te chan 
vt ct chan 
xi proof lemma section show matching event values preserves parameter type events 
requires fact abort actions lemma te ev event te ev unit 
proof 
proof induction structure event values definition 
xi lemma ev ev te ev event te 
proof 
proved induction definition event matching 
te vt ct 
base case 
claim follows immediately type rule output 
examine type judgements te unit event te event rule input te chan deduction rule output requires te inductive cases 
inductive cases case follows immediately induction hypothesis 
case proven case analysis case ev ev 
case follows immediately 
case ev ev 
rule wrap applies te ev event te te ev event applying induction hypothesis rule app get te te te case ev ev phi ev ev 
rule choice applies te ev event te ev event te ev phi ev event induction hypothesis lemmas get te ev unit te te ev case ev ev phi ev ev 
previous case 
case ev ev 
case follows immediately induction hypothesis 
xi proof lemma section show stuck expressions untypable 
need characterize syntactic form stuck expressions 
definition set acceptable arguments sync defined event lemma process ei closed stuck iff forms ffi undefined 
form ev 
sync 
proof 
direction proceeds case analysis possible forms case stuck 
case case proceeds analysis form case ffi defined stuck stuck form 
case closed contradiction 
case 
case stuck 

cases stuck form 
case case stuck 
case sync case proceeds analysis form case ev stuck 
case 
stuck 

cases stuck form 
case spawn case stuck 
case chan case stuck 
possible form stuck contradiction lemma holds 
direction follows immediately definitions 
xi prove stuck configurations untypable need lemma characterizes values event types 
lemma te var event iff 
proof 
direction proceeds examination terms set val var terms inference rule derive judgement form te ev event 
var 
direction examination terms 
inference rules terms output input wrap choice abort guard derive judgements form te ev event event xi ready main proof 
lemma stuck configurations stuck formed configuration exist ct pt fg ct pt words untypable 
proof 
stuck assume exist ct pt fg ct pt 
suffices show untypable contradiction 
type te te note formed closed lemma gives possible forms proof proceeds case analysis showing untypable case 
case rule app applies te te te subcases depending structure case ffi undefined 
ffi typability restriction ffi defined contradicts stuck 
case 
rule pair requires te theta te contradicts premise untypable 
case ev lemma te ev event contradicts premise untypable 
case rule requires type chan contradicts premise untypable 
case 
lemma te event contradicts premise untypable 
case sync 
rule sync applies te event te sync lemma contradiction 
xi 
