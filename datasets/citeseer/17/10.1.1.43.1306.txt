echo distributed file system andrew birrell andy hisgen chuck timothy mann garret swart friday september digital tm systems research center lytton avenue palo alto california echo distributed file system andrew birrell andy hisgen chuck timothy mann garret swart echo ambitious distributed file system 
designed truly global name space 
uses coherent caching algorithm 
fault tolerant 
real primary file system large group researchers 
novel aspects include extensible junction mechanism global naming extensive write ordering semantics allow applications maintain invariants resorting synchronous writes fault tolerance mechanisms highly configurable tolerate network partitions 
designed intention performance local file system supporting large numbers clients server 
reliability designed higher distributed file systems higher centralized systems 
designed arbitrarily large networks 
contents 
global naming global access global security fault tolerance 
digital equipment may copied reproduced part commercial purpose 
permission copy part payment fee granted non profit educational research purposes provided partial copies include notice copying permission systems research center digital equipment palo alto california authors individual contributors applicable portions copyright notice 
copying reproducing republishing purpose shall require license payment fee systems research center 
rights reserved 
echo distributed file system 
holy operating systems research building system combines virtues centralized time sharing systems virtues distributed personal computer systems 
grail harder grasp researchers different views virtues respective systems environment best system operate 
started echo project capture file system portion grail 
thought echo file system crucial piece truly distributed system 
started echo particular view virtues centralized distributed systems trying capture 
world centralized systems wanted easy sharing data centralized administration simple failure model system works doesn 
worlds distributed personal systems wanted fault tolerance service user access manually automatically scalability proximity computing power user 
section outline properties file system achieve virtues 
remainder describes echo design implementation set realize properties experience resulting system 
distributed system just network computers computer networks low level technology allow programs transfer data control connected computers 
collection computers inter connected network constitute distributed system 
collection system component parts operate sufficiently collection behaves coherent entity 
appear coherent user system managers programmers 
believe achieve coherence qualify part distributed system network file system properties 
global naming possible user program computer utter name file assurance name meaning user program distributed system 
echo distributed file system alternative global naming context dependent naming 
means file names interpreted relative host root nfs 
actual naming hierarchy host dependent nfs remote volumes mounted host dependent way 
global naming users programs aware context name meaningful 
notion context removes coherence system 
program executing distributed algorithm file names communicate parts program file names communicate time users effectively pass file names 
global access files directories accessible system independently location operations available 
performance availability reliability operations vary depending location semantics 
way file system fail provide global access naming hierarchy differs host basis nfs files accessible hosts 
restricts location transparency distributed system paris able access files new york 
insidious failure provide global access occurs file system uses non coherent caching strategy nfs updates file host necessarily visible program host 
restricts ease build distributed algorithms application take explicit steps achieve coherence file system failed provide 
global security security file system worse built time sharing system 
system uses network especially network goes site system vulnerable manner attacks strangers 
network inside building system vulnerable allow owner workstation control installation configuration workstation system place trusted manager centralized time sharing system 
techniques countering threats understood currently available distributed file systems nfs apply techniques 
benefits distributed systems technology networked computer systems natural advantages centralized ones 
include ease growth start small grow wasting original investment autonomy growth small groups purchasing decisions relying centralized resources lifetime upgrade need examples discussion concrete re nfs bad guy 
choice primarily nfs known nfs worse competitors 
ways better 
nfs provides global naming poor global access little security 
despite various desirable properties notably simplicity pervasiveness nfs falls far short ideal distributed file system 
echo distributed file system incrementally new versions sub systems replacements existing subsystems benefits come naturally adopting network computer inter connect file system designer needs take care avoid losing 
benefits achievable distributed systems designer addresses explicitly fault tolerance designed distributed system provide service multiple computers way service remains available computers fails part network fails 
just opportunity doing better centralized systems essential 
multiple computers increases probability failing preventing getting done 
distributed file system offer fault tolerance 
configurable provide desired level reliability replicating data availability offering access data computer 
scale designed network grow large internet half registered names 
care distributed file system effectively unlimited scale 
done badly file system hit scale limits long network 
example design file system proprietary service global naming 
prevent inter connecting existing name services literally global internet domain name service iso global name space 
rely security system allow differing levels trust naming hierarchy requires manual intervention build truly large system kerberos version uses inter realm links achieve security untrusted internet links installed pairwise manually 
aspects file system design affected considerations scale 
particular scale mechanism described need scale explains design decisions described sections 
summary challenges addressed echo project echo project attempt learn build distributed file system meeting requirements outlined build system dominant file system daily large active group researchers 
fact echo project constructed distributed file system properties global naming retaining global access security fault tolerance scalability 
global access despite local caching face fault tolerance mechanisms 
global security time sharing system large scale geographic dispersion 
echo distributed file system fault tolerance local caches performance accepting possibility widely dispersed clients 
global scale global trust compromising performance availability dominant local area cases 
remainder describes echo achieves 
details topics echo papers 
assumptions assumptions project 
don agree assumptions probably won produced 
rpc rpc system provides performance milliseconds round trip simple calls mip processors powerful features modula type system plus additional support remote context handles bindings distributed garbage collection authentication 
communication echo servers uses rpc exclusively 
fail servers assume servers give correct answer give answer exception 
give wrong answer 
course simplification 
behavior violates assumption definition bug gets fixed 
correct server measure intervals time known error bound correct server arbitrary performance characteristics 
fail media storage disks return data stored give error error reported try read data 
assumption close true believe 
byzantine clients correctness service answers give clients unaffected incorrect clients incorrect operating systems client computers 
error client computer worst cause clients computer get incorrect results cause incorrect results echo clients computers 
words intend client client computer malfunctions clients computers just computer making strange valid operations 
malfunctioning client client computer cause denial service overloading server malicious behavior cache token algorithm 
liveness service correct independently liveness client computers servers network 
liveness performance system affected liveness components 
echo distributed file system global naming echo provides global hierarchic name space tree labelled arcs single common root 
file names paths naming tree 
file name path consists series arcs 
arcs looked sequentially directories yield directories final arc yields named object directory file 
addition symbolic links resolving arc lead specialized node contains name pre remainder original path 
just conventional centralized unix system 
centralized system echo name space implemented multiple computers dispersed network 
nfs echo name space single global root world wide 
nfs meaning arc echo name space independent node application name running see exceptions 
echo name space consists volumes glued junctions 
echo volume just sub tree name space 
volume resides single server set replicated servers server implement volumes 
junction leaf volume containing description location identity volume 
normal name resolution arc leads junction name resolution mechanism notices interprets junction data contacts new server identified volume continues name resolution root identified volume 
echo notions junctions volumes analogous mounting file systems centralized unix system nfs 
echo important difference 
junction static object giving identity child volume 
clients system see volumes places name space 
client programs operating systems take explicit mounting action volumes places 
afs version similar arrangement 
echo mechanism volumes junctions open ended 
different classes echo volumes slightly differing semantics properties 
glued junction mechanism transparently clients 
important volume classes echo echo name service echo filestore 
volume class providing access nfs file systems 
shows structure parts echo dealing name resolution 
client system wants perform name resolution client application calls open system presents name echo file system switch 
switch directs call clerk specialized class volume initially clerk global root volume 
clerk calls appropriate servers access volume 
server encounters junction returns junction data clerk gives data remainder path name switch 
switch examines junction determine volume class calls clerk continue name resolution 
echo distributed file system native programs unix programs local rpc kernel traps extensible switch client machine echo ns clerk echo fs clerk nfs clerk rpc calls echo name servers rpc calls echo file servers sun rpc calls nfs servers echo fs volumes nfs volumes echo ns volumes domain name service structure echo client computer global root volume echo provide world wide service 
chose world wide name service domain name service dns provided internet 
dns provides tree essentially properties just described 
resolve arcs get nodes 
sufficiently open ended represent junctions text resource records example 
echo clients don communicate dns servers 
echo name servers provide surrogate access data dns 
echo client wants access root dns volume uses echo name service clerk talk echo name server 
server returns cached data client talks real dns servers client behalf 
echo clients need understand locate talk dns servers rpc protocols talk echo name servers 
importantly echo name servers intermediaries allows provide better availability 
re relying entirely global naming availability limited availability root volume 
unacceptable failures high levels dns caused failures echo clients 
avoid echo name servers data dns stable storage 
client asks echo name server data root dns volume server cached data expired appropriate dns server available echo name server returns cached copy anyway 
long term persistent restarts 
echo distributed file system dec src domain name service com echo name service echo file service abc ens clerk efs clerk echo switch application workstation resolving echo global name echo name servers implement second class volumes 
name service volumes level name space immediately root volume 
maintain volumes traditional techniques provide high availability low consistency 
name service volumes replicated 
enquiry satisfied replica 
update replica committed returning client 
update propagates asynchronously replicas volume 
principle update propagation take long time practice updates reach replicas second 
files directories echo stored third class volumes echo filestore volumes 
behave conventional file service 
replicated provide fault tolerance provide tight consistency clients see data time 
volumes scheme involving elected primary 
section fault tolerance gives details 
enquiries primary updates 
primary propagates updates available replicas necessarily majority returning client 
see works consider 
client workstation wants resolve path name com dec src 
symbol means path starts global root 
arcs com dec src resolved dns resolve domain name src dec com 
described earlier step name resolution performed echo name server cached 
point name resolution encounters junction defined text resource record dns describes volume echo name service 
client system proceeds contacting appropriate echo name server storing volume presenting request resolve relative echo name service volume specified uid 
name server resolve returns junction data 
junction specifies echo filestore volume client system uses echo filestore clerk contact appropriate echo file server asks resolve echo distributed file system relative identified volume specified uid 
resolution succeeds echo file server performs operation client requesting 
preceding description ignores effects caching clerks 
clerk caches data servers names resolved entirely clerks caches contacting servers 
caching algorithms discussed detail section 
just dns echo name service se 
dns effective naming hosts widespread network rudimentary name service distributed system 
widely accepted update mechanism plausible security mechanism marginal support enumeration 
really doesn map unix file semantics 
dns world wide presence 
essential top level glue earliest opportunity junction name service map unix semantics 
just echo filestore echo name service se 
higher level parts name space quite different requirements lower level parts 
high level organization contents name space change quite rarely change significant event adding removing user re organizing department 
lower levels organization contents changing rapidly users create modify delete files 
availability higher levels important high level names unavailable descendant volumes unavailable 
known algorithms simultaneously provide tight consistency guarantees extremely high availability 
decided higher levels traditional name service algorithms maximize availability expense consistency low levels echo filestore provide tight consistency expense somewhat lower availability 
different consistency guarantees provided different classes volumes invisible clients users 
example user apply unix ls mkdir commands equally echo name service volume echo filestore volume 
program running single machine looser consistency name service completely invisible name server crashes 
distributed algorithm running multiple computers communicates different name service replicas looser consistency visible 
examples happening quite confusing 
case programmer agreed storing data filestore programmer remained occurrence 
names aren global names 
offer alternatives 
unix systems names resolved relative process working directory 
addition names relative process local root 
example path name bin gcc local root relative 
local root chosen user logs inherited forking child processes 
course maps node single global naming tree just choice point process dependent 
mechanism allows group decisions upgrade new version gcc 
process created group uses local root resolve bin gcc file 
processes belonging outsiders values get different compiler 
echo distributed file system deviated principles names global names don really want global naming time 
notice notion local roots quite different multi rooted name space offered systems nfs afs 
local root just pointer global name space systems truly multi rooted hierarchies 
echo junction mechanism quite open ended 
implementation name resolution algorithm uses object oriented registration mechanism additional volume classes added 
example volume class implements dev provides access specialized repository source control system 
possibilities explored include volume class naming processes jobs 
global access provide uniform global access ensure clients see data regardless network 
modification client immediately visible clients 
echo file servers replication scheme tight consistency described satisfies requirement 
file system perform cache information client computers 
provide uniform global access caches fully coherent 
caches 
reason provide better service client avoiding network delays 
notice avoid disk delays simply caching server 
reason probably important 
data cached extensively client computer load server reduced 
limit server encounters new data written client read 
benefit accrues client cache local disk afs client notice performance improvement compared uncached lightly loaded server effect server handle clients 
echo filestore cache implemented main memory client 
fundamental just experiment 
just place cache paged virtual memory explicit local disk file system affecting rest discussion 
important cache large 
ideally contain client entire medium term working set server reading writing new data 
practice today megabytes 
major issues echo filestore cache design achieve coherence guarantees write mechanism provide 
caching echo filestore coherence nfs uses simple coherence strategy client caches 
updates directories write go synchronously server disk 
updates files write propagated server file closed 
attractive engineering compromise simple quite efficient 
produce surprising results executing distributed algorithm involving shared files 
frequent complaints delays caused synchronous directory operations 
echo distributed file system ws ws fs echo file server client client token traffic clients server sprite system provides totally coherent cache 
updates files write sprite uses token scheme application computer wants access file dirty pages client cache pages written back server computer access 
sprite uses directory operations 
afs version uses similar scheme 
echo filestore uses caching scheme quite similar sprite extended deal directories cope replicated servers deal differently shared writing files 
simple outline scheme leave complex refinements separate 
echo filestore servers manage tokens associated file 
servers issue tokens clerks client computers 
hold clean copy data cache clerk hold read token hold dirty copy write token 
clerk holds file write token clerk may hold read write tokens file multiple clerks hold read tokens 
note tokens file locks clients file open needed client reads writes file data 
consider 
client ws wants read file clerk calls server fs obtains read token file 
clerk cache pages file 
ws wants read file get read token time 
ws wants write file server calls back ws revoking read token granting write token ws 
ws access file ws cache pages reads file hold dirty pages file implementing write 
ws wants read file server calls back ws revoking write token 
receiving call ws synchronously writes dirty pages back server returning revocation call 
call returns server returns read token ws 
scheme efficient usage behaves poorly single file updated frequently multiple computers 
shared write case sprite decides cache file 
approach proved satisfactory environment run unix style applications shared writable files 
notice choosing files granularity token quite arbitrary 
token page issued tokens byte ranges 
file tokens require data structure immediately attractive 
tokens matched typical unix usage patterns files file read written entirety 
systems access patterns different issuing tokens important 
experience systems planned afs 
echo distributed file system ws ws server primary server standby client client token traffic replicated server exactly scheme directories files 
case convinced file tokens right answer 
experience far leading consider adopt complex token scheme directories recognizing specific update patterns 
consider depicts similar situation file stored replicated server details replicated storage come 
echo filestore replication scheme replica elected primary 
token operations just described done clerks calling current primary 
primary fails new primary elected need recover state token algorithms 
enable dynamically replicate token state server volatile storage 
client acquires releases token primary tells standby millisecond rpc 
fail new primary immediately token state 
alternative algorithm recover token state calling clerks 
rejected vast load impose recovery time delays client unavailable recovery time 
final part token algorithm recovery clients crash inaccessible network partitions holding token 
timeouts handle 
tokens issued clients part session session clientserver pair 
token guaranteed remain valid long session 
session remains valid seconds explicitly refreshed client clerk 
client detached network partition seconds server clerk agree clerk tokens implicitly revoked 
combination tokens timeouts called lease 
server doesn revoke tokens conflict token requested clerk allows ride transient network partitions reporting errors 
clerk lost session clients wants access file clerk contact server re establish right appropriate token 
clerk contact server reports error client 
lost sessions interact write scheme described section 
notice scheme require synchronized clocks clocks agree known bounded error rate 
caching echo filestore write echo filestore cache uses write client application creates writes deletes file updates directory system call returns client echo distributed file system operation transferred server committed stable storage 
deliberately gone previous systems write experiment 
example nfs afs write directories write file data 
write mechanisms sufficient client application create file write re read delete entirely client cache 
write mechanism perform operations involving server 
elaborate write useful application programmers need give strong guarantees operations reach server order application understand control states encounter crash restart 
guarantee give specified partial order writes updates application programs 
guarantee updates filestore stable storage satisfy partial order merge eliminate operations reach stable storage re ordering violate partial order 
purposes defining order consider sequence writes single file don alter length file single item sequence echo filestore clerk server re order arbitrarily increase performance 
particular file directory update operations involving directory reach stable storage order issued applications 
operations involve multiple files directories defines partial order operations requested applications 
example rename operation affects objects named object old directory new directory old occupant new directory entry 
rename operation constrains write order operations involving objects 
cache entirely coherent see previous sub section offer ordering guarantee updates applications entire system world wide 
notice constraining order operations affect stable storage echo permitted merge multiple client operations single stable storage operation 
example group commit disk updates 
notice flexibility adjust order operations affect stable storage caches fully coherent clients see effects operations order clients requested 
give applications additional controls 
system call fsync blocks outstanding updates file updates ordering rules guarantee precede reached stable storage 
new nonblocking system call counts update arguments update alters contents 
effect constrain partial order 
far experience satisfactory 
applications ordering guarantees maintain quite elaborate invariants stable storage guarantees overly constrain update algorithms 
applications maintain invariants need resort efficient fsync 
part sure gain extensive write capability 
far performed minor optimizations stream example eliminated temporary files server traffic 
echo distributed file system observed interesting tension scheme 
queues updates haven reached stable storage get quite long minutes application issuing file system updates tight loop 
reducing server peak loads smoothing offered load bad users expect saved promptly disk 
added watchdog mechanism clerk reduce danger losing large amounts 
write queued particular volume minutes old clerk blocks applications request updates volume server catches 
watchdog goes normal trigger test programs 
problem designing cache write happens clerk loses session tokens network partition server failures masked fault tolerance mechanisms 
situation clerk queue operations accepted clients commit servers stable storage 
clerk decide operations report failure clients 
notice problem arise centralized systems clients crash time file system 
unsure best way report failures initial design proved entirely satisfactory 
clerk loses session volume clerk invalidates application open files working directories volume allows applications reopen files directories absolute pathnames 
scheme meant naive applications continuing modify volume false assumption previous modifications successful allow sophisticated applications recover 
practice applications fail confusing error messages recover interactive shells applications continue absolute pathnames quit 
result explored alternative designs discuss issue 
caching echo name service name service cache vastly simpler filestore cache reasons 
updates quite rare coherence important 
second servers provide tight consistency updates little inconsistency caches won matters worse 
name service clerk caches data servers seconds 
enquiry return cached data data seconds old ask server update cache 
update updates cache return updating server 
simple algorithm satisfactory terms answers clients terms reducing server load 
global security echo file system uses distributed security facility developed part separate project research center described detail 
gives highlights echo security emphasis address requirements 
echo distributed file system communication echo servers clerks authenticated 
words clerk server know identity principal making receiving rpc call 
principals identified global names name space file naming rooted domain name service sub trees implemented echo name servers file servers 
echo objects files directories volumes servers protected access control lists acl specify principals may perform operations objects 
acl set names access rights 
names acl principals names acl groups stored global name space 
authentication access control schemes world wide distributed system 
provide differing levels trust differing levels name space secure cross links pass untrusted levels name space 
servers enforce security objects contain 
trust clerks 
clerks responsible multiplexing correctly multiple principals computer 
design sounds wonderful may convinced implementable 
convinced need read papers security system cited 
fault tolerance important distinguish concepts reliability availability 
providing reliable system means lose corrupt data 
providing available system means get data 
basic technique providing reliability replicate data storage 
words write data disk 
times parameter selected value data probability disk errors cost disks 
modern disk storage 
extremely corrupt data reporting error fail 
highly store data correctly 
generally having copies data sufficient level re lose data operator error earthquake disk error 
basic technique providing availability replicate storage access paths 
extreme implies replicating disk drive disk part access path 
reality modern disk drives lot reliable computers vastly reliable computer software 
want high availability satisfied single disk reliability attractive replicate server replicating disks 
fault tolerance echo name service mentioned earlier echo name service achieves fault tolerance techniques traditional 
architecture described previous 
name service volume set replicas 
replica uses disk storage complete copy volume 
enquiry replica update 
updates propagate asynchronously replicas 
name echo distributed file system net net echo filestore configurations service volume available reliable long replica running 
new 
fault tolerance echo filestore configurations elections echo filestore quite flexible provision fault tolerance 
various parts filestore configured provide reliability replicating disk storage availability replicating servers 
challenge provide fault tolerance mechanisms retaining strong consistency guarantees update client immediately visible client update committed undone 
client point view committed defined write rules described earlier server interface update operation commits operation returns calling clerk 
volumes grouped boxes 
box contains entirety set volumes relationship required volumes 
allocation volumes boxes purely managerial decision 
box unit replication 
box stored replicas occupies number physical disks 
box replica accessed servers 
shows possible configurations 
configuration minimal data server replicated 
configuration offer higher availability dual ported disk hardware servers access disk 
servers election scheme described decide primary 
primary disk accesses crashes 
configuration provide high reliability enhancing availability storing data disks 
update server records update disks returning calling clerk client 
configuration combination provides high availability high reliability 
servers elect primary performs updates writing disks 
configurations provide level availability reliability echo distributed file system server server witness election face network partitions configuration different hardware 
dual ported disks primary communicate second disk network 
configuration second disk accessible second server remaining server provide service 
algorithm electing primary replicated servers basically straightforward details get quite complicated 
majority voting scheme disk replica gets vote whichever server gets straight majority votes primary 
votes belong disks accumulated servers 
server get vote disk various ways depending configuration 
dual ported configurations server gets vote hardware give ownership disk allows server get vote disconnecting disk 
configuration disks directly connected single servers directly connected server controls disk vote goes 
configuration disk servers network disk server hardware chooses vote goes 
typical configuration exactly servers exactly disk replicas 
connected running defer processor uid example 
network partitioned communication replicas running get majority 
avoid configure system votes cast disk replica cast called witness 
witness store files box practice witness file server box just casts vote 
single network partition witness accessible server server get votes majority 
multiple network partitions possible server get majority 
case service provided 
shows election face network partitions 
network partition point witness vote server network partition point witness give casting vote server network partitioned get majority service provided 
important improvement algorithm 
primary gets elected data copy token session data structures able echo distributed file system provide uninterrupted service clients 
clerks lost tokens report failures clients 
reality election algorithm biases result server data 
notice election just decides server primary 
need algorithm decide disk replicas contain truth data reconcile replicas 
outlined section 
fault tolerance echo filestore updates recovery echo filestore uses log journal recording updates box disk storage 
client clerk calls server update server verifies operation pre conditions updates server volatile data structures writes log record disks 
box replicated log record written replicas 
server returns rpc call clerk 
clerk control knows update committed disk 
asynchronously server applies updates home location disks removes update record log 
update large data write bytes write synchronously home location brief notation log 
optimization written servers absence crashes need read log 
ensuring server buffer pool contains data affected log entries 
requires substantial buffer pool servers megabytes shared function normal caching pages avoid disk reads gains seeking reading logging disk substantial requires substantial buffer pool servers megabytes shared function normal caching pages avoid disk reads 
file system designers explained attractions logging numerous server throughput increased log written sequentially seeks seeks happen asynchronously server writes updates home locations hopefully time lower load 
server availability increased restarting log faster 
need program fsck verify file system invariants log entry definition preserves invariants 
server performance increased server group commit write single log record disk operation describe multiple client operations 
atomicity improved giving stronger guarantees clients single log record written single disk operation describe update rename affects parts file system simultaneously 
mechanisms achieve atomicity logging far simplest 
advantages log attractive optimizes simplifies replication algorithms ways 
echo distributed file system information logging techniques echo 
configurations described earlier primary server direct access disks communicating secondary server 
primary write disks simultaneously performance penalty replicating data slight 
primary crashes secondary need read entire log order reconstruct dynamic state allows interpret rest disks 
take minutes service available 
log records accelerate 
primary written log record update returned clerk primary asynchronously forward log record secondary 
secondary apply forwarded log records dynamic state state tracks primary lagging log records 
crash primary subsequent fail new primary old secondary recover entire dynamic state reading applying just log records 
substantially reduces failover time 
second way logging helps replication log reconcile replicated disks 
basic idea simple 
recovery need propagate log records replica discard log records replica logs currently available replicas identical 
complexity deciding log records keep 
constraints 
keep log records corresponding updates clerk told update committed stable storage 
second replica recorded log record crashed subsequent updates considering log record replica available log record discarded 
complete description recovery scheme complicated 
description subset actual algorithm gets correct answer omits optimizations 
optimizations essential system perform availability characteristics 
want information read research reports recovery algorithm availability 
reports include optimizations rationale exploration related researchers 
recovery scheme driven epoch numbers algorithm ensures unique monotonic increasing entire set replicas box time 
description committed update means update clerk told update safely stored stable storage 
replica left set servers providing service box cold start replica crashes offering service take steps 
choose primary carry steps 
general requires election described earlier previous primary majority votes new election needed 
call set replicas voted primary active replicas time primary unable contact active replicas carry step active replica vote times immediately return step 
echo distributed file system 
choose new epoch number greater previously previous run step follows read possibly chosen epoch previously recorded stable storage active replicas greater largest value read 
write possibly chosen epoch active replicas 
complete steps failure chosen return step 
reconcile active replicas described 
step active replicas contain identical data apart optimizations described 
identical data contains committed updates 

write service epoch active replicas 

offer service primary active replicas determined step 
step primary determines latest service epoch recorded active replicas 
call epoch active replica possible states service epoch equal active replica epoch got step recovery common case 
reconciled step epoch committed updates performed prior epoch committed updates performed log records updates progress epoch ended 
reconciliation just matter applying additional log records active replicas epoch removing service epoch active epoch committed updates happens replicas providing service 
log records uncommitted updates progress time active discarded reconciliation participate discarded 
easy see active replica step state worst recover disk copy replica 
important optimization algorithm allow adding witness number replicas odd 
small changes steps replicas witnesses keep copy replicated files participate normal service need stable storage record epoch numbers recovery 
useful optimization affects replicas state recovery algorithm 
replica line long time amount updating needed echo distributed file system bring date substantial cause unacceptable delay offering service 
mark replicas temporarily date offer service active replicas 
effect date replica demoted status witness promoted brought date 
procedure reduce availability reliability replica fails replica updated return get faster recovery better availability failure 
third optimization complicated explain phase process moving new service epoch step 
change speeds recovery algorithm certain cases improving handling uncommon failure patterns needlessly move replicas state state basic algorithm 
full algorithm complicated possibility adding new replicas destroying old ones 
substantial literature replication recovery algorithms surprisingly results suitable replication distributed file system 
similar algorithm described kazar 
algorithms assume network partitions occur give incorrect results occur rely phase commit algorithms exploring failure behavior 
repeat simplified description recovery algorithm 
research reports provide details 

echo full service src november summer 
file system researchers daily mail programming entertainment 
contained gigabytes data gigabytes disk configured volumes replicas 
mechanism described data dns fully implemented didn calls dns didn store junctions 
manually information echo name service 
echo filestore included real backup system users stored real files echo 
backup systems 
integrated replication mechanism effectively worked replica line 
back algorithm just recovery algorithm 
meant information stored backup tapes formed instantaneous snapshot previous state volumes 
backup system tar tapes 
didn form snapshot insensitive bugs cropped echo implementation 
users willing believe get files back tar tape required lot faith believe get back line replica 
development echo stopped early project port taos operating system hosting echo modern hardware canceled 
functionally satisfied requirements laid 
remained done achieve appropriate levels availability performance 
required faster reliable hardware 
design assumptions echo computation cheap relative communication 
unfortunately computation cheap environment mips processors connected echo distributed file system megabit second switch network 
current prospective environments provide balanced picture workstations mips servers mips networks megabits second 
sort environment echo design 
echo performance comparable reasonable quality centralized unix implementation similar hardware 
performance better nfs implementations time support demanding users reading single volume 
echo availability reasonable improving went service 
frequent fail mechanisms install new server versions debug servers clients noticed 
active development availability limited introduced bugs 
times limited combination experimental hardware inadequate system management 
difficult availability problem experienced load control 
servers limited resources megabytes memory megabytes dma address space proved remarkably difficult avoid crashes deadlocks caused load 
got problems control little confidence additional doubling user community cause additional problems 
echo reliability 
period service disk failures caused lose data 
lost updates due software bug reconciliation code 
advent global naming satisfactory 
pleasant know log workstation building see files 
originally intended integrate remote site echo name space goal realized 
surely running wide area network caused changes timeouts caching protocols 
caching worked quite 
example users shared repository released code programs 
caching handled load single server client workstation processing power file servers 
guarantees write order easy applications maintain invariants resorting excessive fsync sync calls 
hand discussed earlier uncertain best design reporting write failures 
believe echo design addresses problems scale 
example probably attractive add form load sharing reads handle clients single volume 
scheme automatically updated read replicas included afs probably satisfactory 
believe place higher level replication techniques cover wide areas siphon mechanism described 
necessary design tightly synchronized data performs presence high latency low reliability connections 
technology trends continue favor systems assumptions echo 
echo implementation achieve planned think echo system embodies principles techniques pursued distributed file systems 
echo distributed file system 
birrell global authentication global trust 
proc 
ieee symposium security privacy oakland 

birrell grapevine exercise distributed computing 
comm 
acm apr 

birrell position rd european sigops workshop 
abstracted sigops review april 
page 

burrows efficient data sharing 
ph thesis churchill college cambridge sep 

gasser digital distributed system security architecture 
proc 
th national computer security conference baltimore 

gray cheriton leases efficient fault tolerant mechanism distributed file cache consistency 
proc 
th symp 
operating systems principles acm sigops dec 
hagmann reimplementing cedar file system logging group commit 
proc 
th symp 
operating system principles acm sigops nov 

hisgen availability consistency trade offs echo distributed file system 
proc 
nd workshop workstation operating systems ieee sep 
hisgen granularity semantic level replication echo distributed file system 
proc 
workshop management replicated data ieee nov 

hisgen new value logging echo replicated file system 
src research report digital equipment palo alto 

kazar replicated servers easy 
proc 
nd workshop workstation operating systems ieee sep 

lampson authentication distributed systems theory practice 
proc 
th symp 
operating system principles acm sigops nov 

lampson designing global name service 
proc 
fifth symposium principles distributed computing 
acm 

mann coherent distributed file cache directory write 
src research report digital equipment palo alto 

mann algorithm data replication 
src research report digital equipment palo alto 

mockapetris rfc domain names concepts facilities 
november 
osf osf dce application development dec 

ousterhout trace driven analysis unix bsd file system 
proc 
th symp 
operating system principles acm sigops dec 

ousterhout sprite network operating system 
computer feb 

wobber siphon managing distant replicated repositories 
prl research report digital equipment paris 

satyanarayanan itc distributed file system principles design 
proc 
th symp 
operating system principles acm sigops dec 

schroeder burrows performance firefly rpc 
acm trans 
comput 
syst 
february 

swart availability echo file system 
src research report digital equipment palo alto 
tanenbaum experiences amoeba distributed operating system 
comm 
acm december 
