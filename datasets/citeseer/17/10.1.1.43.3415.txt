machine adaptable dynamic binary translation david ung cristina cifuentes department computer science electrical engineering university queensland qld australia cristina csee uq edu au author support australian postgraduate award 
support australian research council 
sun microsystems sabbatical leave sun microsystems dynamic binary translation process translating optimizing executable code machine runtime program executing target machine 
dynamic translation techniques normally limited particular machines competitor machine hardware manufacturer machine 
research provides general framework dynamic translations providing framework specifications machines reused adapted new hardware architectures 
way developers techniques isolate design issues machine descriptions reuse components analyses 
describe dynamic translation framework provide initial results obtained system 
keywords dynamic compilation emulation interpretation dynamic execution binary translation 

binary translation migration technique allows software run machines achieving near native code performance 
binary translation grew emulation techniques late order provide migration path legacy cisc machines newer risc machines 
techniques developed hardware manufacturers interested marketing new risc platforms 
mid binary translation techniques translate competitors applications desired hardware platform 
near expect see techniques optimize programs family computers example optimizing sparc architecture binaries ultrasparc architecture binaries 
uqbt university queensland binary translator developed techniques specification languages complete framework performing static translations code 
static binary translation code translated line program run creating new program uses machine instructions target machine 
static translation limitations 
due nature von neumann machine code data represented way possible discover code program statically 
example target indirect transfers control jumps registers hard analyse statically 
fall back mechanism commonly statically translated program form interpreter 
interpreter processes code runtime returns translated code suitable path 
limitations static binary translation dynamic translation expense performance 
dynamic binary translator code gets translated fly runtime user perceives ordinary execution program target machine 
emulation dynamic translation generates native code performs ondemand optimizations code 
hot spots code optimized runtime increase performance execution code 
optimizations possible statically possible dynamically 
describe design machine adaptable dynamic binary translator static uqbt framework uqdbt 
tool said machine adaptable configured handle different source target machines 
way machine adaptable dynamic binary translator capable configured different source target machines specification properties machines instruction sets 
words translator bound particular machines existing translators capable supporting variety source target machines 
uqdbt differs dynamic translators provides clean separation concerns allowing machine dependent information specified performing machineindependent analyses support machine adaptability 
way uqdbt support variety cisc risc machines low cost 
support new machine specifications machine need written uqdbt framework reused 
new machine specific modules may need added particular feature machine supported uqdbt framework feature generic different architectures 
structured way 
section discusses static dynamic frameworks binary translation 
section outlines research problems machine adaptable binary translation addressed uqdbt 
section provides case study translation framework example program 
section shows preliminary results framework 
section discusses effects changing granularity translation section 
reported progress 
related attempt improve existing emulation techniques companies late began binary translation achieve native code performance 
known binary translators digital vest mx translate vax mips machine instructions bit alpha instructions 
translators apple mae digital express runtime environment reproduces old machine operating environments 
runtime environment offers fallback interpreter processing old machine code discovered translation time example due indirect transfers control 
years seen transition hybrid translators proving extremely successful 
process mixing translation emulation runtime profiling brought leading performers hybrid translation scene digital fx executor sun 
fx emulates program initially statically translates background information gathered profiling 
embra machine simulator built dynamic translation techniques developed shade fast instruction set simulator execution profiling 
le investigates order execution techniques dynamic binary translators results interpreter implementation 
optimization techniques dynamic translators derived dynamic compilers self tcc 
runtime optimizations compilers provide performance statically compiled programs 
techniques just time jit compilers java 
jits sun intel dynamically generate native machine code runtime 
date current binary translators generate code source target machine pair 
machinedependent aspects translation hard coded translator making hard reuse translator code set machines 
research differs previous research machine dependent issues separated machine independent translation concerns providing way specifying different machines source target machines supporting specifications reusable components implement machine independent analyses 
shows process feasible enhances reuse code creation dynamic binary translators 
machine adaptability translator comes cost performance discussed section 
binary translation frameworks binary translation process low level re engineering decoding higher level abstraction followed encoding lower level abstraction 
gives uqbt static translation framework 
reengineering process divided initial reverse engineering phase left hand side forward engineering phase right hand side 
reverse engineering steps recover semantic meaning machine instructions step process decoding binary file decoding machine instructions code segment mapping instructions semantic meaning form register transfer lists rtls 
high level analysis process lifts level representation code machine independent form performs binary translation specific optimizations code brings level abstraction rtls target machine 
followed forward engineering process optimizing code encoding instructions machine code storing code data program binary file 
forward engineering process standard optimizing compiler code generation technology 
rtl simple low level register transfer representation effects machine instructions 
single instruction corresponds register transfer list uqbt sequential composition effects 
effect assigns expression location 
side effects explicit top level expressions evaluated side effects purely function rtl operators 
rtl language collection locations operators 
machine sub language rtl defined rtls represent instructions machine single rtl 
previously mentioned problems static binary translation inability find code belongs program limitation optimizations static ones advantage dynamic optimization techniques 
hardest problems solve decoding semantic mapper optimizer instruction decoder instruction encoder high level analysis binary file decoder binary file encoder ms rtls mt rtls efficient mt assembly instructions mt binary instructions stream ms binary instructions stream ms assembly instructions ms binary file mt binary file 
static binary translation framework machine instructions separation code data binary manipulation tool faces problem 
unfortunately problem solvable general code data represented way von neumann machines 
static translation incomplete runtime support environment needed form interpreter example 
dynamic binary translation framework dynamic binary translation actual translation process takes place needed basis static binary translation attempts translate entire program 
illustrates typical framework dynamic translator uses basic block unit translation granularity 
left hand side similar static translator processing code done different level granularity typically basic block time 
right hand side little different static translation 
time basic block translated assembly code target machine emitted encoded binary form 
binary form run directly target machine memory kept cache 
mapping source target addresses entire program basic block stored map 
basic block executed times number executions reaches threshold optimizations code performed dynamically generate better code hot spot 
different levels optimization possible depending number times code executed 
optimized code replaces cached version basic block code 
processing basic blocks driven switch manager 
switch manager determines new translation needs performed determining entry corresponding source machine address map 
entry exists corresponding target machine address retrieved translation fetched cache 
match switch manager directs decoding basic block required source address 
machine adaptable dynamic binary translation framework extends enable dynamic translator easily adapt different source target machines 
effort achieved clean separation concerns machinedependent information machine independent analyses 
specifications developer able concentrate writing descriptions properties machines having re write tool 
specifications support machine dependent information generate parts system automatically provide skeleton user 
seen decoding binary file source basic block semantic mapper simple optimizations basic block instruction decoder basic block instruction encoder ms rtl rtl translator basic block binary file decoder rtl optimized rtl mt binary instructions stream ms binary instructions stream ms binary file ms rtl translation cache address mapping ms mt sparc sled alpha sled pentium sled pentium sled alpha sled sparc sled ms assembly instructions elf win pe dos exe bff rtl mt assembly encoder pentium sled alpha sled sparc ssl mt assembly instructions pentium sled alpha sled sparc ssl switch manager 
machine adaptable dynamic binary translation framework basic block semantic mapper simple optimizations basic block instruction decoder basic block instruction encoder basic block translator basic block binary file decoder mt assembly instructions efficient mt assembly instructions mt binary instructions stream ms binary instructions stream ms assembly instructions ms binary file ms rtls translation cache address mapping ms mt switch manager 
dynamic binary translation framework machine rtls ms rtls requires description format program syntax semantics machine instructions particular processor 
experimented different languages reusing sled language developing bff ssl languages bff binary file format language supports description binary file structure 
current formats supported dos exe solaris elf certain extent windows pe 
srl simple loader supports automatic generation code decode files specified bff language 
sled specification language encoding decoding supports description syntax machine instructions 
binary assembly mnemonic representation 
sled supported new jersey machine code toolkit 
toolkit provides partial support automatically generating instruction decoder particular sled specification 
current machines specified form include pentium sparc mips alpha 
ssl semantic specification language allows description semantics machine instructions 
ssl supported srd 
srd semantic mapper component supports parsing ssl files storing information form dictionary instantiated dynamically 
output stage ms rtls 
ms rtls converted machine independent rtls rtls analyses remove machine dependent concepts source machine 
process identifies source machine control transfers maps general forms rtl 
example sparc ms rtl call instruction pc pc npc npc associated high level call instruction rtl 
forms transfers control exist rtl jumps returns conditional unconditional branches 
rtl supports register transfers stack pushes pops high level control transfers condition code functions 
higherlevel instructions allow abstraction underlying machine 
rtls converted mt assembly instructions mapping functionality register transfers instructions available target machine assisted ssl specifications 
instruction encoding process supported sled specification language maps assembly instructions binary form 
code stored translator cache 
example shows various instruction transformations translation pentium machine instruction sparc machine instruction 
stage decodes pentium binary code produce pentium assembly code lifted pentium rtls abstracted rtl replacing machine dependent registers virtual registers 
forward engineering phase encodes rtl sparc assembly instructions sparc binary code 
specification requirements dynamic binary translation dynamic translation afford time consuming analyses lift level representation stage resembles highlevel language uqbt 
uqbt static analyses recover procedure call signatures including parameters return values allowing generated code native calling parameter conventions target machine 
analyses dynamic translation high performance degradation experienced translation 
alternative costly analyses remove properties underlying source machine go halfway high level representation 
support inexpensive analyses recover basic form high level instructions conditional branches calls parameters emulate away conventions hardware operating system source machine native conventions target machine 
steps possible specification features underlying hardware 
example emulate sparc architecture register windowing mechanism pentium machine specifying mechanism works 
sparc machine emulate pentium stack parameter passing convention 
emulate sparc processor delayed transfers control support higher level branching instructions 
clearly compromise performance impact translated code provides fast way translating code optimized runtime hotspot program 
order support translation ms rtls rtls ssl language extended machine instruction level semantics include hardware semantics 
example sparc architecture effects changing register windows register current window accessed specified pentium architecture properties stack movement specified 
information currently uqbt uqdbt 
uqbt relies costly analysis higher level information depending low level details underlying hardware 
addl ebx eax add 
pentium sparc example 
research problems dynamic binary translators written fixed set source destination machines mind uqdbt designed handle wide range cisc risc machine architectures 
translators directly map source machine specific idioms target machine translators bound source target pair 
extend translators support different machines extensive rewriting code needed direct idiom mapping machines different 
goal uqdbt provide framework modified extended ease support additional source target machines need rewrite new translator scratch 
process finding generalization existing machines non trivial fully predicted 
uqdbt uses uqbt approach specifying properties machine instruction sets widely available today machines allowing user extend specification language support new features machines reuse rest translation framework 
uqbt multi platform operating systems concentrate fundamental issues instruction translations 
uqdbt goal address types research problems dynamic machine adaptable binary translation 
best way supporting machine dependent machine independent rtl translation 
main criteria translation efficiency expensive analyses option 
translation needs supported underlying specification language order generate ms rtls contain information underlying ms machine 

state source machine needed dynamic translation effects specification properties machine 

best way automating transformation mt assembly code 
code selector automatically generated target machine specification 

possible efficiently specifications contain information operating system conventions calling parameter conventions os communicate program 
example order pentium stack parameter convention code translated sparc architecture binary passes parameters registers analysis determine parameters needs performed 
implementation uqdbt experimenting right level description required order support dynamic translation specifications 
experience low level high level description underlying machine unsuitable 
view uqbt semantic specifications machines high level description describe machine instruction semantics specify underlying hardware supports control transfer instructions register windows delayed instructions sparc architecture 
uqbt detailed level information needed specification calling conventions control transfer instruction 
semantic description languages describe low level details underlying machine languages suitable emulation purposes contain information dynamic translation 
problem addressed specifying hardware works relation control transfer instructions provides fast translation ms assembly instructions information rich ms rtls extended ones avoiding need recover information runtime 
types information described sparc pentium processors effects sparc register windowing mechanism stack properties memory alignment parameters return locations 
sparc machine allocates new set working registers time save instruction called 
words effectively provides infinite number registers program 
effect sparc register windows captured extending ssl specifying registers accessed register windows change save restore instruction providing different set working registers 
provides accurate simulation target machines limited amount usable registers 
effects stack pointer different different types machines 
pentium machines stack pointer change indefinitely procedure 
risc machines stack pointer normally constrained pre allocated stack frame fixed size includes space register spills procedure 
specifying stack changes original machine suggests ways code generator generate stack manipulation instruction target machine 
example simulating stack pushing popping sparc machine 
memory alignment places constraints machine state particular point program 
sparc frame pointer stack pointer need double word aligned 
code generator needs enforce conditions entry exit call 
differences machine calling conventions parameters passed return values stored play crucial part code generator constructs right setup calling native library functions 
sparc generally passes parameters registers pentium pushes stack 
information needed source target machines identify transformation parameters return values 
differences source target machines requires byte swapping performed loading storing data 
byte swapping expensive process 
pentium byte swapping quite easily takes sparc instructions bit swap 
expensive process avoided possible 
particular running pentium binary sparc push pop instruction appears quite pentium programs require byte swapping 
heuristics uqdbt avoid byte swapping pushing popping stack 
second problem related 
amount source machine state carried depends effectiveness translation problem 
areas easily specified unspecified carried apparent machine independent rtl 
uqdbt control transfer instructions contain tag indicating process delayed slot instruction architectures support delayed slots 
third problem current progress 
goal automatically construct code generator determine best performance heuristics selecting target machine instruction encountering similar patterns 
patterns may matched may nearly impossible match 
example trying pattern match sparc save instruction pentium rtls 
experiences fourth problem suggest performance gain native os conventions 
uqdbt currently simulates calling convention pentium programs sparc machine parameters passed stack registers 
remove simulated effect convert native conventions needs know improvement offer direct machine simulation 
level conversion occur 
worth doing analysis dynamic binary translation environment 

case study section show example small pentium program converted ps postfix indicates translations pentium sparc architectures run sparc machine 
programs solaris operating system 
main differences test machines 
sparc risc architecture pentium cisc 

sparc big endian pentium little endian 

sparc passes parameters registers stack pentium normally passes stack 
basic block translations address mappings disassembly hello world binary program compiled pentium machine running solaris 
column source address seen pentium processor 
second third columns actual pentium binaries corresponding assembly representation 
basic blocks save sp sp cc add sp sp add st sp mov sp dc mov sp mov fp st sp ec mov sp mov fp mov sp fc mov sp sethi hi add st sp ld sp mov fp mov sp sethi hi add sp sp fp fp sethi hi call nop mov sp mov fp sethi hi add sethi hi bfc call nop 
generated sparc assembly st bb main ebp ec movl esp ebp fe ff ff call addl esp eax eax eb jmp leave ret 
hello world disassembly push push pc call tmp tmp jump pop ret rtls hello world bbs program bb instructions second bb instructions third bb instructions shows intermediate representation rtls bbs 
note translation done incrementally bb decoded separately runtime 
works source machine address space translates basic block time 
data text source pentium program mapped actual machine source address space running sparc machine 
example pentium program data text sections located mapped exactly addresses typical sparc program expects text data addresses 
simulates pentium machine environment sparc generated code pushing popping temporaries parameters pentium machine preserved generated code 
tries generate code quickly possibly little optimization 
pentium stack simulation sparc code generated bb 
instructions simulate pentium main prologue setting stack storing return address obtained value 
bytes stack space reserved initial save sp sp 
space sparc processor store parameters return structures local variables register spills 
actual simulated pentium stack pointer esp starts sp see pentium ebp mapped sparc register fp 
pushing handled subtracting size value pushed sp storing result sp 
popping removes sp increments sp appropriate size 
function calls stack alignments pentium actual parameters function calls passed stack sparc parameters passed registers 
printf format string hello world address pushed instruction see 
successfully call native sparc printf function address stored register instruction 
equivalent printf sparc call function instruction 
calls library functions printf assumed exist source target machine 
assumption restrictive long mapping source library function equivalent function target machine libraries reproduced target machine translation rewriting produce mapping 
translators fx assumption 
sparc machines expect sp fp aligned double word bits boundaries 
calling native sparc library function sp fp need byte aligned 
current values restored function call returns instructions 
basic block control passed back switch manager indication basic block address processed case 
role switch manager decide start translation indicated fetch translated bb translation cache 
case bb starts address translation map translation starts new address 
shows generated sparc assembly bb pentium program 
register spill area parameters sp sp sp sp sp parameters simulated stack pointer 
sparc stack frame ff sethi hi ff add fe ff mov sp ff st ff mov sp ff ff mov sp ff sethi hi ff add ff rd ccr ff st ff sethi hi ff add ff sethi hi ff add ff ld ff sethi hi ff add ffa ld ffa ffa st sethi hi ffb add ffb rd ccr ffb st sethi hi ffc add ffc sethi hi bfc ffc call nop 
generated sparc assembly nd bb register mapping condition codes translation pentium registers mapped virtual registers memory locations 
access virtual register sparc machine sethi add instruction 
example instructions ff ff access virtual register representing register eax 
instructions sparc affect condition codes flags explicitly indicated instruction pentium instructions affect flags 
pentium instruction affects status flags simulated equivalent condition code version instruction sparc machine instructions ff ffa 
condition codes read instruction ff saved virtual flag register instruction ff instructions preserve current value retrieved required 
closer look example shows generated code efficient 
simple optimizations forward substitutions dead code elimination greatly reduce size generated code 
optimizations yield better code take longer generate trade code quality speed 
code generator back fast despite poor quality generated code 
currently implementing demand optimizations hotspots program performing register allocation 

preliminary results uqdbt uqbt framework front re uqbt changing granularity decoding procedure level basic block level 
front uses extended ssl specifications generates ms rtls 
machine instruction encoding routines back automatically generated sled specifications toolkit 
section shows preliminary results obtained dynamic translators instantiated uqdbt framework pentium sparc sparc sparc 
looks types optimizations need introduced order improve performance frequently executed code gives reader idea effort gone development framework amount reuse expected 
performance micro benchmark results obtained pentium mmx mhz machine ultrasparc ii mhz machine running solaris operating system 
results reported translation overhead currently dynamic optimizations register caching basic blocks 
clearly performance generated binaries uqdbt optimization inferior direct native compilation 
typical ratio source machine instruction target machine instructions expected typical emulator interpreter caching 
gives figures close ratio 
example pentium instructions sparc instructions generated 
ratio similar emulation speed gained uqdbt comes reusing translated bbs translation cache piece code executed 
form uqdbt early development provide preliminary results pentium sparc translator sparc sparc translator 
undoubtedly true little practical sparc sparc translation runtime optimizations significantly speed translated programs 
inclusion translation show effect machine adaptability uqdbt 
translation sparc binaries rtl removes machine dependencies rtl sparc code generation unaware fact source machine sparc 
true 
little analysis done decoded instructions processing concentrated decoding code generation requested switch manager better reflects performance impact demand techniques prior introducing optimizations 
test programs showed tables sieve prints prime numbers fibonacci prints banner elf string times 
sieve mainly contains register register manipulation fibonacci lot recursive calls lot stack operations accesses array data 
tables show times translation execution programs compared natively gcc compiled programs 
source programs compiled 
column shows preprocessing time needed actual translation takes place 
note takes longer start 
pentium larger instruction set larger ssl specification file takes longer process 
caused different page alignment sizes pentium sparc result extra steps taken ensure text data sections loaded correctly sparc machine 
column shows total time spent decoding source instructions transforming rtls generating final sparc code 
column shows execution time generated sparc code register caching register access done virtual registers 
column shows execution time generated sparc code register caching yields percent performance gain 
column natively compiled gcc version program sparc 
comparing columns gives relative performance translators 
figures suggest times slowdown running programs 
slow performance translated fibonacci program caused effects register windowing mechanism sparc carried forth rtls 
rtls unaware fact source target machines causes entire register windowing system simulated generated code 
demand optimizations performed quality generated code comparable optimization level traditional compiler 
tables show efficiency translators relative size original program 
column size program text area 
note bytes necessarily represent instructions code necessarily reachable executed runtime 
column shows actual bytes decoded translator runtime 
number varies column valid paths runtime translated re translation needed jump middle bb 
columns show number bytes code generated translator register caching 
register caching done basic block level cached registers copied back memory locations basic block 
comparing column column gives relative ratio bytes generated versus bytes decoded 
figures suggest average byte source machine translates bytes target sparc code 
column ratio machine cycles bytes source code 
gives rough indication performance translation 
ultrasparc ii mhz translators require machine cycles byte input source times cycles traditional compiler 
optimizations programs spend time small section code 
hotspots worthwhile dynamic binary translator spend time optimizing 
uqdbt currently perform optimizations 
revision uqdbt contain optimizations triggered counters 
counters inserted basic blocks indicate number times particular basic block executed runtime 
certain threshold reached indicating program spends significant time piece code optimizer invoked attempt produce efficient code 
levels optimization provided uqdbt progressively certain thresholds reached 
register liveness analysis forward substitution constant propagation improves quality generated code reduces number instructions executed 

register allocation rigorous process removing access virtual registers replacement allocation hardware registers target machine assisted liveness information just caching registers basic block level 

code movement moving joining frequently executed bbs closer reducing transition costs calls jumps 

customization create specialized versions bbs fixed range runtime values bb repeated entry bb register variable contains value time 
effort order give reader idea effort gone development uqdbt effort reusing system quantify effort follows 
uqdbt effort person period years experimenting amount specification required semantic level different machines 
effort performed person familiar uqbt framework having worked ssl past 
uqdbt current implementation size lines source code lines partially generated code lines sparc pentium test programs preprocessing translation time time reg caching execution time simple native gcc compiled test processing translation time time reg caching execution time simple reg caching native gcc sieve sieve fibonacci fibonacci test programs original program size source bytes decoded generated reg caching target bytes generated cycles source byte test program size source bytes decoded generated reg caching target bytes generated reg caching cycles sieve sieve fibonacci fibonacci table sparc sparc translation table pentium sparc translation second table sparc sparc translation seconds table pentium sparc translation specification files 
user uqdbt framework able reuse source code need write syntax semantics specification files new machines reuse existing ones 
figures final stage dynamic optimizations implemented 
gives indication amount reuse code system 

discussion preliminary results uqdbt point tradeoffs machine adaptability 
return writing code support particular machines performance penalty generated code seen stage 
binary translation writer expected write specifications new machines order lines code reuse part lines code benefits reuse time efficiency 
stage uqdbt generates code performs speed emulated code user seeing performance degradation translated programs 
register caching generated code brought factor 
expect demand optimizations hotspots program improve performance generated code bringing performance factor 
main questions dealt experiments area specified supported hand 
level detail specification translator faster slower 
full details machine specified specification suitable generating emulator supports machine 
provide means eliminating part emulation process different type specification needed 
tried achieve semantic specifications intermediate languages 
rtl language describes low level machine specific aspects machine uqdbt finds support specifications perform simple analyses lift level representation rtl 
aim perform simple transformations code expensive time generic suitable intermediate representations 
rtl different hrtl high level intermediate representation static uqbt framework 
hrtl expensive analyses recover parameters procedures return values allowing code generator native calling conventions target machine 
code generator specification stack example order pass parameters stack determining locations parameters procedure calls 
notion parameters needed order interface correctly native library functions pass parameters right locations 
experience modules may better written hand specifying complete semantics features machine unique 
example consider implementing sparc specific module supporting register windowing semantics better register allocation performed case 
specified register windowing mechanism generated code puts registers virtual memory locations 
register caching memory locations mirrored hardware registers target machine improving somewhat performance program 
large overhead copying registers virtual locations call return 
reduced dead code elimination hand written code achieved better code 
aspect take consideration granularity translation 
uqdbt granularity unit processing basic block bb time 
just code generation link switch manager exit bb flushing cached registers virtual registers performed 
needed keep data accurately stored consistent transitions bb 
transitions bb go switch manager bb translated 
bb unit translation restricts effectiveness register allocation 
bbs relatively small difficult determine register live ness information data collected bb boundaries 
unit granularity changed yield better code cases worse code 
example translation unit changed bb procedure time 
allow code generator reduce amount flushing cached registers reduce number instructions need executed runtime 
improve effectiveness allocating registers code generation live ness information collected 
larger unit translation procedure may involve decoding paths may taken runtime generating code executed 
obvious granularity unit types programs benefit particular granularity unit may suffer 
program lot small procedures benefit unit translation procedure suffer program lot conditional branches 

uqdbt machine adaptable dynamic binary translator framework capable configured different source target machines specifications properties machines 
uqdbt framework modified extended ease support additional source target machine architectures need write new translator scratch 
case study shows translation process different architectures complex challenging machine adaptable dynamic translation techniques 
preliminary results suggest performance implementing demand processing dynamic system done efficiently 
despite research problems remain building fully machine adaptable dynamic translation framework 
uqdbt appears promising model provide generic dynamic binary translation framework 

acknowledgments authors wish mike van emmerik helpful discussions implementation testing strategies members group sun microsystems self system motivated 
part university queensland binary translation uqbt project 
information obtained project visiting url www csee uq edu au csm uqbt html 


sites chernoff kirk marks robinson 
binary translation 
communications acm february 

apple 
macintosh application environment 
www mae apple com 

digital 
express 
www digital com amt 


digital fx combining emulation binary translation 
digital technical journal 


executor internals efficiently run mac programs pcs 
www com html 

sunsoft 

www sun com sunsoft products pc 

witchel mendel rosenblum embra fast flexible machine simulation 
proceedings acm sigmetrics conference measurement modeling computer systems philadelphia 

le 
order execution technique runtime binary translators 
proceedings th international conference architectural support programming languages operating systems pages san jose ca 
oct 

ungar smith 
self power simplicity 
conference object oriented programming systems languages applications pages 
acm press october 

massimiliano poletto dawson engler frans kaashoek 
tcc system fast flexible high level dynamic code generation 
pldi 
proceedings acm sigplan conference programming language design implementation pages las vegas nv june 

sun java jit compiler www sun com solaris jit 

ali reza adl tabatabai micha cierniak yuan parikh james 
fast effective code generation just intime java compiler pldi proceedings acm sigplan conference programming language design implementation pages montreal canada june 

norman ramsey mary 
new jersey machine code toolkit 
proceedings usenix technical conference pages new orleans la january 

cifuentes van emmerik ramsey design retargetable binary translator 
proceedings working conference reverse engineering pages atlanta usa oct 
ieee cs press 

ung cifuentes 
srl simple retargetable loader 
proceedings australia software engineering conference pages sydney australia sept 
ieee cs press 

cifuentes 
specifying semantics machine instructions 
proceedings international workshop program comprehension pages italy june ieee cs press 

cmelik keppel 
shade fast simulated execution profiling 
sigmetrics nashville tn 

norman ramsey mary 
specifying representation machine instructions 
acm transactions programming languages systems 

cifuentes van emmerik ung simon waddington preliminary experiences uqbt binary translation framework 
proceedings workshop binary translation newport beach usa oct 
published technical committee computer architecture news pages dec ieee cs press 
