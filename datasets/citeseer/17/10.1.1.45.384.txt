proximity matching fixed queries trees ricardo baeza yates 
walter udi manber 
sun wu 
de ciencias de la computaci universidad de chile blanco santiago chile ibm consulting group 

de computaci ia de la univ sim dept computer science university arizona tucson az usa dept computer science national chung cheng univ ming chia yi taiwan 
new data structure called fixed queries tree problem finding elements fixed set close distance function query element 
trees distance function necessarily metric long satisfies triangle inequality 
give analysis performance parameters fixed queries trees experimental results support analysis 
fixed queries trees particularly efficient applications comparing elements expensive 
search structures hashing trees basis efficient computer science applications 
usually support exact queries 
finding things approximately allowing errors query specifications harder 
question prominent biologist asked authors finding computer scientist possible adapt binary search allow approximate queries 
new data structure progress 
measure solve problem may improve efficiency approximate search applications 
assume fixed set preprocess store data structure 
problem find elements set close distance function study detail hamming levenshtein distance functions query element 
problem extensively studied distance functions lexicographical order closest neighbor closest point problem 
refer reader sw mur techniques assume linear orderings euclidean similar distance functions 
problem harder distance functions related linear ordering 
practical approach finding elements database close query element typically design quick algorithms approximate distance blast fasta lp biological sequences speech recognition 
approximated distance filter elements far away algorithms need applied elements database 
running time linear size database 
th symp 
combinatorial pattern matching springer verlag lncs edited crochemore gusfield asilomar ca june 
partially supported 
supported part nsf ccr ccr advanced research projects agency contract number dabt 
information contained necessarily reflect position policy government sponsors research 
official endorsement inferred 
approach arbitrary distance functions burkhard keller bk context database queries 
designed tree structure called bk trees making heavy triangle inequality 
idea improved shapiro sha set trees deriving stricter criteria filtering objects 
bk trees compared nk variation trees general slower running time closest neighbor searching 
comparison done hamming distance small data sets 
studied effect approximating levenshtein distance simpler distance functions easier compute bound original function 
reduction computation distance traded number extra comparisons needed 
shasha wang sw extended bk trees set precomputed distances optimal way 
compute approximate distance map database guide search floyd warshall style algorithm running time 
study empirically effect number precomputed distances distribution distances small sets hundreds objects compare algorithm bk trees obtaining better performance improves precomputed distances 
conjecture star precomputed graphs best topology explains multiple star topology bk tree leads performance 
different algorithmic approaches lead expected performance theoretically practice developed people 
quite different idea filtering large regions database large text expensive techniques small regions 
myers designed ff algorithm match biological sequences 
designed specifically dna protein matching approach applicable essentially distance function complexity depends 
ukkonen uk approach comparing grams 
gonnet byg developed techniques suffix arrays compare sequence database database 
ukkonen uk independently developed similar techniques suffix trees 
chang lawler cl gave algorithm suffix trees problem 
br monotonous bisector tree computational geometry plus grams uk strings profiles 
results show filtering achieved triangle inequality distance bound grams obtaining reasonable performance long keys close proximity 
approach similar bk trees achieves ff ff expected complexity finding close matches 
heavy triangle inequality 
tree structure handle proximity queries distance function satisfies triangle inequality 
main goal structure minimize number element comparisons opposed data structure operations tree traversal 
especially important applications computing distances elements expensive operation say pointers 
tree structure differs tree structures keys level tree just key level 
words comparisons depend results previous comparisons tree 
name fixed queries tree fq tree 
may poor strategy regular binary search trees yield linear search policy advantages intended applications 
minimizes element comparisons traversing different parts tree require comparisons 
second allows comparisons keys done batch enabling easy parallelism 
third simplifies data structure analysis 
major strength fq trees applies bk trees data structure search algorithms independent distance function long satisfies triangle inequality 
comes different distance measures different algorithms compute able scheme change filter data 
amount filtering may depend distance distribution algorithms 
scheme allows expensive exact algorithms dynamic programming able small distances search large database 
main contributions analysis fq trees 
analysis concentrates particular classical distance functions hamming mismatches levenshtein insertions deletions 
show fq trees provide logarithmic expected time exact search sublinear expected time proximity neighborhood search results 
particular study effect key length alphabet size maximal error allowed proximity search bucket size 
results corroborated experimental results 
fixed queries trees set possible elements defined problem 
rest assume ae large set elements large object larger analysis section concentrate strings elements arbitrary 
fq tree differs regular search tree major respects 
keys numbers ordered set members second internal nodes level associated key 
keys denote elements compared traversing tree elements denote members dist distance function satisfies triangle inequality assume set possible distances finite set fd 
set finite large discretize different ranges values 
fq tree set elements distance function dist tree satisfies properties 
ffl elements associated leaves 
ffl contains elements tree consists leaf node containing elements bucket size 
ffl internal nodes depth associated key keys selected random members selected especially optimize tree assume random 
ffl internal node root valid fq tree associated set ae internal node key subtree non empty set defined fx dist shows example fq tree 
search query element proceeds tree computing level distance key level 
search exact search level child corresponds distance selected leaf reached 
neighborhood proximity search complicated 
suppose want find elements distance triangle inequality filter nodes 
internal node associated key dist children associated distances gamma may contain elements distance search recursively 
advantage having key nodes level comes play 
may traverse children key comparison level 
main cost proximity search related sum height tree indicates key comparisons need content buckets reached search unfiltered elements distance gamma 
overhead traversing data structure finding right children secondary pointers expensive comparing complex objects 
analysis fq trees analysis simplifying assumptions analysis imprecise 
believe results reasonably approximate true behavior fq trees empirical results support belief 
fig 

example fq tree hamming distance 
assume elements strings finite alphabet sigma size sigma oe 
assume possible range valid distances level independent 
clearly true elements distance key apart triangle inequality 
discuss error analysis section 
probability strings distance distance function define probability distribution modeled distance functions hamming levenshtein 
start terminology ffl number elements tree ffl size bucket ffl expected height tree counting leaf level ffl expected number comparisons exact search ffl average internal path length leaf ffl nd expected number internal nodes traversed proximity query distance ffl bd expected number leaf elements compared proximity query distance ffl pd expected number comparisons proximity query distance assumptions max dp ne approximate expected number nodes th subtree dp ne 
expected height expected largest subtree 
exactly true exact analysis difficult 
distributions centered concentrated small range approximations shown experimental results 
assuming loss generality recurrence solution log log max log recurrence dp ne gives log log log recurrence similar boundary condition changed clearly complexity 
recurrence nd nd min max gammad nd dp ne nd triangle inequality prune subtrees searching subtrees distance gamma current distance equation rewritten nd fl nd dp ne fl min max gammad induction show fixed value constant nd ff ff 
value ff obtained transcendental equation fl ff specific values ff hamming levenshtein distances 
similarly recurrence bd bd min max gammad bd dp ne bd complexity nd different constant multiplicative factor 
total number comparisons done proximity query pd fq tree bounded bd pd bd logarithmic pd bd ff 
original bk tree terms similar replaced nd complexity change significant reduction constant factor fq trees 
analysis approximation facts ffl recurrences ceiling expected number elements branch 
may increase number elements subtree 
recurrences effect minimal 
nd effect error increases estimates real values 
formulas approximate 
fix error computing exact values small done nd results obtained similar 
ffl source error fact pair elements distance key distance bounded triangle inequality 
take account recurrences adding second parameter carries maximal possible distance words close strings common segments 
example get max dp ne min denotes maximal distance 
effect new parameter depends probability distribution significative 
case hamming distance oe levenshtein distance 
hamming distance oe probability distribution skewed results 
spite problems mentioned experimental results shown section close analytical results showing final error small 
hand exact analysis consider possible tree arrangements multinomial distributions trees ary trees mah 
distance functions study common distance functions strings hamming levenshtein distances 
cases sigma alphabet size oe 
fixed length keys hamming case hamming distance strings length defined number symbols identical positions different 
example ham string strong 
strings size ham string seen point dimensional space integer coordinates set sigma jg 
hamming metric computed time 
assume strings length key symbol drawn independently alphabet sigma gamma oe probability symbols differ 
probability distance elements binomial distribution oe kg gamma gammak maximum value oe mode gamma solving equations get mq gamma mq gamma 
close expected value distribution mq 
oe gamma oe obtain upper bound oe finite large log log similarly random ary tries 
difficult obtain closed expressions complexity analysis 
formula nd compute values ff gives complexity pd ff 
shows values ff proximity searching different values sigma 
include experimental values ff dotted lines obtained squares fit data 
probability distribution compute performance measures formulas previous section 
shows analytical experimental values proximity searching pd function different values oe 
experimental values dotted lines graphs agree reasonable analysis 
logarithmic axis able represent values graph occurs subsequent graphs 
figures shows effect key length alphabet size proximity searching 
increases number comparisons decrease 
happens fan tree increases 
hand oe increases number comparisons 
happens probability distribution possible distances concentrates near average approaching average fan decreases 
shows effect bucket size sigma 
shows effect bucket size pd solid lines sigma 
clearly optimal bucket size 
formulas bd nd compute saving respect bk trees having comparison internal node give bd nd pd 
shows quantity dashed lines improvement bk trees small experimental results finding closest match case number comparisons point decreases due fact larger probability finding close match increases prunes tree search rapidly 
experimental results obtained random keys running experiments depending complexity measure 
largest variation obtained height expected 
example experimental value oe average standard deviation 
measures deviation 
figures experimental results close approximated analytical values 
variable length keys levenshtein case levenshtein distance defined minimal number characters need change insert delete transform strings string 
example lev string song 
strings lev max jaj jbj levenshtein distance computed time jaj theta jbj dynamic programming 
model variable length key generating independently length key 
positive poisson distribution parameter length 
distribution models fact shorter strings probable long strings 
probability string having length ig gamma gamma 
gamma distance strings computed length difference elements common prefix length min jaj jbj strings random hamming distance 
losing generality lev gamma ham know probability distribution hamming distance 
probability lev max gammak gamma gammaj oe gamma gammai oe distance unbounded define gamma gamma probability distribution compute performance measures defined previous section hamming case 
example shows complexity proximity searching values average string length sigma simple model lower case text 
shows effect proximity searching oe 
results similar hamming case replacing main difference case probability distribution centered hamming case 
currently working experimental results distance function 
preliminary introduced fq trees showed potential data structure supports fast approximate queries 
novelty fq trees having fixed key level filter input 
idea obviously generally applicable leads traversal nodes 
showed number key comparisons decreased data structure 
necessary see fq trees compare data structures specific applications comparing elements major cost search 
exact analysis desirable 
mention briefly important variant fq trees takes tradeoff reducing number key comparisons vs increasing number traversed nodes 
building tree recursively stopping node contains elements insist leaf certain depth 
words may want replace leaves paths 
arrive leaf contains element guarantee element fits search criteria 
need compare element directly query adding key comparison 
add levels leaf increase probability triangle inequality filter element corresponding leaf 
traverse nodes left smaller set compare directly query 
insist key level total number key comparisons significantly reduced 
preliminary analysis shows expectation possible achieve logarithmic number key comparisons fixed small 
performance degrades significantly increased 
preliminary experimental data supports analysis 
early predict variant practical 
ways improve extend basic idea fq trees ffl key selection random adapted data 
example data known divided clusters key cluster choice 
ffl elements partitioned smaller objects allow local similarity 
example sequence comparisons divide sequence smaller sequences treat smaller part element 
query search part separately 
ffl study needed optimize secondary memory improve bucket utilization 
may possible partial split procedures improve storage utilization similarly multiway trees 
helpful comments referees 
altschul gish miller myers lipman basic local alignment search tool molecular biology 
baeza yates unbalanced multiway trees improved partial expansions acta informatica 
byg baeza yates gonnet sequence matching dept computer science universidad de chile 
bahl gopalakrishnan nahamoo fast admissible method identifying short list candidate words ibm tech report rc june 
br bugnion roos shi widmayer widmer spatial index approximate multiple string matching st south american workshop string processing sept 
bk burkhard keller approaches best match file searching communications acm april 
cl chang lawler approximate matching sublinear expected time proc 
st ieee symp 
foundations computer science 
friedman bentley finkel algorithm find best matches logarithmic expected time acm trans 
math 
software 
gonnet baeza yates handbook algorithms data structures addison wesley second edition 
gonnet cohen benner exhaustive matching entire protein sequence database science 
lp lipman pearson rapid sensitive protein similarity searches science 
mah evolution random search trees john wiley new york mur murtagh survey advances hierarchical clustering algorithms ieee computer 
myers algorithmic advances searching databases proceedings international symposium computational methods genome research heidelberg appear 
myers sublinear algorithm approximate keyword matching algorithmica press 
nk experiments closest point algorithm hamming space angewandte informatik 
diaz rodriguez increasing radius search schemes similar strings burkhard keller tree international workshop computer aided systems theory 
sha shapiro choice points best match file searching communications acm may 
sw shasha wang 
new techniques best match retrieval acm transactions information systems 
uk ukkonen approximate string matching grams maximal matches theoretical computer science 
uk ukkonen approximate string matching suffix trees th annual combinatorial pattern matching symp padova italy june 
article processed macro package llncs style key length ff fig 

complexity proximity searching depending hamming 
experimental results shown dotted lines symbols 
number elements pd fig 

effect proximity searching depending oe hamming 
experimental results shown dotted lines symbols 
key length pd fig 

effect key length proximity searching depending oe elements hamming 
experimental results shown dotted lines 
alphabet size oe pd fig 

effect alphabet size proximity searching depending elements hamming 
experimental results shown dotted lines 
bucket size fig 

height internal path depending elements hamming 
experimental results shown dotted lines symbols 
bucket size pd fig 

effect bucket size proximity searching elements hamming 
experimental results shown dotted lines bk trees shown dashed lines 
key length ff fig 

complexity proximity searching depending levenshtein 
number elements pd fig 

effect proximity searching depending oe levenshtein 
