automatic analysis loops exploit operator parallelism reconfigurable systems narasimhan ram subramanian santosh pande uc edu dept univ cincinnati cincinnati oh 
configurable arithmetic logic units alus offer opportunities adapting underlying hardware computation efficiency 
problem identifying optimal configurations different steps program complex issue allows power alus maximally solved 
focuses developing automatic compilation framework exploiting operator parallelism loop nests 
focus analysis identifying maximally configurations avoid costly reconfiguration overheads 
framework initially operator loop transformations carried expose opportunities configuration reuse 
pass solution 
pass attempts group statements similar configuration demands cutsets generates corresponding configurations 
second pass analyzes trade offs costs benefits reconfigurations different cutsets attempts eliminate reconfiguration overheads merging cutsets 
methodology implemented suif compilation system tested loops extracted perfect benchmarks livermore kernels 
speed ups obtained quite substantial showing usefulness method 
method scales loop sizes amount space available fpgas 
rapid advances fpga hardware technologies architectures configurable computing engines arithmetic logic unit alu modified fly computation popular 
configurable architectures offer opportunity adapting underlying hardware computation efficiency 
typically need configuration arises due fact hardware alu configuration better suited execution algorithmic step 
program abstraction sequence algorithmic steps need reconfiguration changing configuration arise different program points corresponding algorithmic steps 
problem identifying optimal configurations different steps program complex supported darpa contract army dabt responsible communication 
issue allows power architectures maximally solved 
success architectures critically depends effectiveness compiler research area just 
purpose specifically focus automatic compilation framework developed effectively exploit operator parallelism 
example consider loop nest executed configurable alu loop split loops preserving forward dependence due 
reconfigurable alu configured multipliers entry point loop instances execute parallel 
alu reconfigured entry point loop adders execute instances 
configuring hardware entry point loop nest overhead associated 
success scheme depends trade performance gain due operator parallelism exploited configuration overheads generating configurations 
trade focal point automatic compiler analysis transformation framework 
organized follows section discusses related section discusses approach section discusses framework loop operator transformations 
section discusses analysis trade offs gains overheads reconfiguration 
motivation illustrated example algorithms automatic reconfiguration analysis loop transformations 
results discussed section section 
appendix gives pseudo codes algorithm developed framework 
related considerable amount done loop optimizations parallel computing especially focusing issues loop transformations 
works deal optimizations loops focusing data locality data loop alignment redistribution 
high performance fortran important attempt exploit data parallelism loops 
vectorization early attempt exploiting vector parallelism codes 
randy allen ken kennedy discuss comprehensive framework translating fortran programs vector form 
gokhale carlson discussed compilation issues parallel machines 
approaches assume configurable alu 
configurable alu support varying demands operator parallelism opening important issues analyzed compiler 
developing efficient mapping techniques reconfigurable architectures focus research 
hardware library approaches synthesis efficient hardware exploiting instruction level parallelism ilp different approaches 
approaches focused effectively utilizing power reconfigurable alus proposing variable instruction sets prism ii brigham young university dynamic instruction set computer disc 
developed framework synthesize efficient hardware pipeline configured suit computation 
important compiler driven approaches undertaken raw project 
raw compilation framework tries exploit ilp asynchronous instruction streams basic blocks 
approach gives excellent speedups custom alus applicability general purpose reconfigurable engines fpgas limited due high overheads reconfiguration 
motivates approach analyzing loops determine trade offs macro level achieving performance enhancement 
goal determine program points reconfiguration beneficial overhead reconfiguration incurred loop nests benefits gained times trip count 
approach introduce notations definitions configuration set operators number operator implemented hardware support computation time 
configuration expressed set tuples 
example configuration comprising multipliers adders represented 
cutset group statements represented set execute particular configuration 
example statements execute configuration 
denoted cutset fs 
approach automatic reconfiguration analysis 

loop operator transformations phase takes pdg input performs loop transformations loop splitting statement reordering loops 
undertakes operator transformations reconfiguration elimination configuration reuse 
section explains specific optimizations undertaken detail 

reconfiguration analysis phase analyzes trade offs costs reconfiguration performance gains due reconfiguration exploiting operator parallelism loop nests 
space time cost models operators compile time analysis phase 
phase uses pass solution generates pdg annotated reconfiguration directives 

machine dependent optimizations phase performs architecture specific optimizations targetted specific reconfigurable system 

code generation phase generates code execution reconfigurable hardware implemented near 
depending computational demands loop set statements loop may demand certain hardware configuration best execution 
problem determining set statements prefer certain configuration highly combinatorial due enormous number possibilities involved 
statements grouped terms preferred configurations goal analyze assigned different configurations 
hard graph partitioning problem 
developed heuristics efficiently solve problems 
practice costs reconfiguration current generation fpgas quite high 
performance gains systems greatly increased number code transformed code parallel additions fig 

example codes reconfigurations kept minimum 
order heuristics effective program transformations done expose opportunities configuration reuse 
focus section operator loop transformations targetted configuration reuse 
transformations done preprocessing step configuration analysis 
framework operator loop transformations initially loop transformations performed expose parallelism statements optimally utilize hardware space parallel execution operations 
useful transformation loop conversion loop split sequence loops 
loop exhibit maximum operator parallelism boundary loops potential reconfiguration point 
certain loop transformations loop peeling scalar expansion performed remove dependencies resulting loop split sequence loops 
operator transformation motivation operator transformation reuse previous configurations generated order reduce reconfigurations 
consider code implemented hardware execution 
loop nest consists parallel additions iteration configuration 
loop nest hand contains multiplication operation configuration 
reconfiguration done loop nests 
transform multiplication operator series additions shown avoid reconfiguration configuration demand 
cost implementing multiplication series additions higher transformation reuse previous configurations saving reconfiguration overheads 
complex operation broken simpler constituent operations executed parallel 
hardware support higher multiplicity simple operations operations span range complex operations eliminate redundant reconfigurations operator transformations 
statement re ordering configuration reuse configuration consists set operators multiplicities may attempt transformation statements similar operators moved statement re ordering 
doing dependencies program preserved 
consider statements loop cutset configuration 


due limited hardware space compiler may attempt generate configurations shown 
see statements share operator statements share operator gamma 
note moving maintain dependency increase configuration locality 
configurations reduced fs executing 
fs executing 
gamma operator locality results fewer number configurations 
framework reconfiguration analysis transformations done phase compiler focuses analyzing program dependency graph pdg determine cut sets corresponding configurations 
phase split passes 
input pass pdg cost model reconfigurable alu includes execution time operators reconfigurable processing unit space occupied total reconfigurable space reconfiguration time algorithm generates cut sets corresponding configurations loops 
problem generating optimal cut sets corresponding configurations np hard 
problem shown equivalent knapsack problem idea pack statements possible configuration minimize reconfiguration subject constraint hardware space 
heuristics analysis tractable 
heuristics described subsection 
second pass analysis reduce number reconfigurations undertaken 
pass total cost execution consecutive cut sets reconfiguration overheads compared total time execute cut sets merged single configuration 
cost lesser cut sets merged eliminating reconfiguration cut sets 
motivating example explain motivation approach example 
detailed description cost model xilinx family compile time analysis implementation section 
pdg cutset configuration generation reconfiguration minimization cutsets configurations heuristic configuration match heuristic requirement fpga space model cost fig 

cutset configuration generation cutset configuration 
config 
config 
config example forward dependencies statements loop 
loop split sequence loops 
pdg generated loop statements analyzed topological order 
statements level require multiplication addition operations statement loop executed times 
multipliers adders instances executed parallel 
similarly level statements level statements 
statements level executed order data dependencies 
operators required statement instances generated hardware executed parallel 
statement may need different support concurrent execution instances 
limited hardware problem group statements need similar operator support form cut sets 
heuristics find cut sets configuration match fpga space requirement explained subsection 
cut sets associated hardware configuration configuration match heuristic loop tabulated example 
seen loop split sequence loops 
loop cutset executing configuration cutset 
reconfiguration needed loop nests configuration requirements different 
transformed loop 
cut set configuration generation approach involves analysis program pdg constructed loop nest level 
nodes pdg annotated data array scalar elements referenced operations involved data elements 
node pdg corresponds statement 
directed edges pdg represent data dependence node direction edge 
nodes pdg level numbers 
level number represents depth node level level level cut set cut set cut set key multiplier divider adder step step 
config config step step generate config step 
config config step fig 

pdg loop pdg 
node level number data dependent statements loop 
level node level max predecessor level 
nodes level number executed order 
pdg loop traversed level level order flow dependence program 
annotated node operators required statement multipliers adders determined 
amount space required statement multiplicity operators surrounding loop trip count space needed implementation 
example statement involves multiplication addition loop count require multipliers adders execute instances statement parallel 
underlying hard ware configured support multipliers adders instances statement execute parallel step 
algorithm generating cut sets uses space constraint determine statements grouped configuration 
factors affecting program execution motivate development heuristic approaches generate cut sets 

number reconfigurations performed reconfiguration overhead significant reconfigurations kept minimum 
motivates grouping statements similar operator requirements 

fpga space utilization fpga space utilized maximum extent fully exploit available parallelism configuration 
algorithm traverses pdg topological order generates cut sets configurations incrementally 
level algorithm invokes selected heuristic determine ordering statements level inclusion current cutset incremented 
statements ordered algorithm uses space constraints decide include statement current cutset start new cutset 
case algorithm decides include statement current cutset corresponding configuration may may incremented 
give formal description algorithm appendix 
heuristics developed generate cut sets follows configuration match heuristic selects statement inclusion current cutset maximal match operator support available current configuration operator support required statement 
assume heuristic process selecting statement inclusion current cutset 
current configuration comprise operators statements candidates inclusion current cutset configuration 
require operators ok require operators require operators om statement required operators available current configuration match 
operators available matches match 
perform ordering 
statements match counts 
statement placed count lower count equal match count greater criteria statements ordered better candidate inclusion current cutset heuristic motivation ordering statements enforce maximal overlap new configuration old configuration maximally utilize partial reconfiguration space constraint met 
example illustration candidate space constraint met start new cutset new configuration ok 
see new configuration amount overlap previous configuration 
reconfiguration partial resulting minimal reconfiguration overheads 
fpga space requirement second heuristic orders statements require higher fpga space generating configuration placed need lesser space 
cutset corresponding configuration generated space constraint met 
new cutset configuration generated space constraint met 
enable maximum utilization fpga space give better performance loop nest 
ideas formally algorithms detailed appendix 
reconfiguration minimization pdg completely traversed cut sets generated pass cut sets 
pass cut sets analyzed adjacent ones time 
denote sum execution cost cut sets respective configurations reconfiguration cost 
denote total execution cost cut sets common configuration 
lesser phase merge cut sets generate common configuration 
cut sets configurations left unchanged 
common configuration comprise operators configuration cut sets 
example configuration cutset 
cutset 
gamma common configuration comprise gammag 
multiplicity operator computed total fpga chip space 
example available space enables generate operator common configuration 

gamma loop taken ac bc ad ac unite bd bc ad bd loop equation state fragment livermore loops loop hydro fragment loop discrete ordinates transport conditional recurrence xx di xx dk dn di dn xx vx dn xx xx dn xx loop taken hm hm hm sin sin sin sin hm perfect benchmark loops rho energy ppp press cpc gamma cp ppp gamma cpc loop taken dup tg lo tg lo ci cb cb loop taken fig 

benchmark loops implementation results implementation framework implemented suif compilation system 
framework tested loops taken standard benchmarks perfect benchmarks suite scientific engineering programs livermore loops set loops extracted operational codes lawrence livermore national laboratory 
scalar variables loop scalar expanded arrays 
loops unknown loop bounds cases loop counts considered small medium large 
benchmark loop structures shown results cost model xilinx family fpgas developed compiler analysis 
cost model provides cost time executing operator space operator takes reconfigurable system partial reconfiguration costs 
developed parametric model xilinx family processors different operator implementations 
models xc xc measure characterize performance approach 
relative space time costs derived detailed space time cost model operator common operators involved benchmark programs shown operator add sub mul div time space loops partitioned cut sets corresponding configurations generated 
total execution time including reconfiguration overhead computed loop 
determining speed ups loop completion time reconfigurable processor xc compared time taken non reconfigurable processor 
assume reconfigurable system processor type environment reconfigurable fpga memory local system 
experiments assume corresponding data needed loops locally available memory pre fetch overlapping dma cycles cpu execution 
speed defined ratio sequential execution time non reconfigurable processor execution time reconfigurable processor 
illustrate speed calculation example loop loop taken 
statements denoted order appear loop 
non reconfigurable processor loop executed sequentially 
multiplications division operation loop 
loop count 
cost model loop completion time time units 
cut sets configuration obtained algorithm 
cut set config steps time 
mul 
div reconfiguration time reconfiguring xc chip 

time units 
loop completion time medium loop including reconfiguration overhead multiplication division time units 
speedup 
speed computation clock speeds reconfigurable processors assumed 
practice fpga reconfigurable processors slower traditional non reconfigurable processors risc factor terms clock speeds 
instruction set processors need memory accesses instruction fetch incur overheads instruction decode 
overheads absent hardware approaches reconfigurable processors 
considering trade speed ups shown degrade factor 
resulting speed values quite attractive 
table gives average space fpga processor required configurations generated 
refers space config match heuristic applied refers space fpga space heuristic applied 
average space percentage total hardware space 
speedup results small medium large size benchmark loops xc reconfigurable chip computed table 
xc chip results table 
cut sets corresponding configurations generated pass 
pass merging cut sets performed reconfiguration overheads outweigh performance benefits obtained reconfiguration 
tables spd refers speed obtained factor execution times 
subsection summarize discussion results 
livermore loops perfect benchmarks type loop conf match fpga space conf match fpga space pass pass pass pass pass pass pass pass spd spd spd spd spd spd spd spd small medium large table 
speed ups obtained benchmarks xc processor discussion results comparison speed ups speed ups obtained substantial cases ranging 
noted earlier actual speed times lesser accounting slow clock speeds current fpgas 
heuristics cases speed ups heuristics comparable case loop loop perfect benchmarks suite configuration match heuristic performed significantly better medium large sized loops tables 
seen loop structures loops complex operations multiplications divisions wide disparity space time costs 
suggests better configuration match reduce execution time tends waste fpga space 
loop bounds increased parallelism increases config match algorithm tends utilize fpga space reducing wastage 
able perform better loops large diversity operators large loop bounds 
loop sizes loop sizes increase operator parallelism increases cases speed ups increase 
fpga space limited increase parallelism space limitation help improving performance 
large loop sizes execution sequential fpga space constraint limit reached 
example loop livermore loop perfect loop perfect considerable change speed small loop bounds medium loop bounds small change speed medium large 
improvement optimizing second pass second pass resulted significantly improved speed ups case small loops 
speed improvements times cases 
comparison fpga space cases heuristics efficient fpga space small fraction space left unused 
quite obvious second heuristic livermore loops perfect benchmarks type loop conf match fpga space conf match fpga space pass pass pass pass pass pass pass pass spd spd spd spd spd spd spd spd small medium large table 
speed ups obtained benchmarks xc processor perform better terms fpga space utilization evident case loops medium large loop bounds refer table 
cases loop bounds increase unused fpga space decreases heuristics effectively fpga space 
presents framework automatic compilation analysis loops targetted reconfigurable systems 
methods improving effectiveness analysis configuration reuse loop operator transformations 
key focus framework identifying program points reconfiguration beneficial analyzing trade offs costs benefits due reconfiguration 
framework proposes pass solution problem implemented suif compilation system 
shows lot operator parallelism exists loops exploited performing right analysis utilize power reconfigurable alus 
reconfigurable system commercially available fpgas cost effective method exploiting parallelism 
advent larger faster fpgas solutions provide powerful mechanism exploiting operator parallelism 

randy allen ken kennedy 
fortran programs vector form 
acm transactions programming languages systems oct 

peter athanas harvey silverman 
processor reconfiguration instruction set metamorphosis 
ieee computer march 
livermore loops perfect benchmarks xc xc xc xc type loop rs fs rs fs rs fs rs fs small medium large table 
average space total fpga benchmarks 
banerjee 
loop parallelization 
loop transformations restructuring compilers 
boston kluwer academic 

blelloch chatterjee zagha 
solving linear recurrences loop 
journal parallel distributed computing feb 

clark hutchings 
supporting fpga microprocessors software tools 
proceedings ieee workshop fpgas custom computing machines pages april 

bau pingali solving alignment elementary linear algebra 
proceedings th international workshop languages compilers parallel computing pages june 
lncs 

kaushik huang johnson sadayappan approach communication efficient data redistribution 
proceedings acm international conference supercomputing pages june 

high performance fortran forum 
high performance fortran language specification version 
technical report tr center research parallel computation rice university houston tx 
revised january 

gokhale carlson 
compilation issues parallel machines 
journal supercomputing dec 

anderson lam global optimizations parallelism locality scalable machines 
proceedings sigplan conference programming language design implementation pages 

tu padua automatic array privatization 
proceedings sixth workshop language compilers parallel computing august 

pande compile time partitioning method doall loops distributed memory systems 
proceedings international conference parallel processing pages august 

stanford university 
suif library 
manual part suif compiler documentation set suif stanford edu 

elliot michael taylor vivek sarkar walter lee victor lee jang kim matthew frank peter finch rajeev barua jonathan babb saman amarasinghe anant agarwal 
software raw machines 
ieee computer september 


compilation pipeline synthesis reconfigurable architectures 
reconfigurable architectures high performance proceedings raw april 

brown 
software development system fpga data system 
proceedings ieee workshop custom computing machines pages april 

michael brad hutchings 
dynamic instruction set computer 
proceedings ieee workshop fpgas custom computing machines pages april 

michael wolfe 
high performance compilers parallel computing 
addisonwesley publishing 
appendix notations algorithm config tuple operator field configuration tuple config tuple denoted config tuple oper multiplicity denoted config tuple oper count 
space req denotes space required implement operator hardware 
space req denotes space required implement operators needed statement note algorithm variable store configuration current cutset 
copied variable go new level pdg 
processing 
new operators added operator multiplicity changed updated 
algorithms algorithm input pdg loop body 
heuristic chosen config match fpga space requirement output cut sets comprising group statements edges cut sets annotated reconfiguration directives 



list store cut sets corresponding configurations 
list consist nodes node cutset corresponding configuration 



traverse pdg topological order order flow dependence program perform group statements pdg level 
call returns ordered set statements chosen heuristic 
copy tuples 
statement sorted order ffl determine operators required ffl ffl operator ffi config tuple oper ffi config tuple oper count loop count 
ffi config tuple ffl config tuple tuple config tuple oper tuple oper subset true subset false ffl config tuple tuple config tuple oper tuple oper config tuple oper count tuple oper count false true ffl subset true false required operators required number available 
support parallel execution instances statement ffi fs operator ll subtract count operator corresponding operator count ffi tuple config tuple tuple oper config tuple oper tuple oper config tuple oper tuple oper count tuple oper count gamma config tuple oper count need support new operators number existing operators 
check satisfy requirement 
ffl space req ffl config tuple tuple tuple oper config tuple oper config tuple oper tuple oper diff config tuple oper count gamma tuple oper count diff config tuple oper count space req space req diff theta space req config tuple oper ffl space req fpga space generate required operators 
update configuration include newly generated operators update multiplicity operators existing 
ffi fs ffi gamma space req operators update multiplicity 
new operators create new tuple set fields tuple add 
ffi config tuple tuple tuple oper config tuple oper config tuple oper tuple oper tuple oper count tuple oper count config tuple oper count tuple oper config tuple oper tuple oper count config tuple oper count ffl subset true required operators multiplicity lower required number 
additional space available increase multiplicity 
execute instances parallel 
execute set instances sequential steps 
ffi fs ffi min count count operator multiplicity minimum 
operators required take count operator multiplicity min 
instances execute parallel 
number steps required loop count min count ffi steps loop count min count ffl required operators additional fpga space create 
need reconfigure 
ffi set configuration 
ffi add 
ffi new cutset 
ffi fs ffi ffi space req operator space req ffi min space req loop count ffi update newly created config 
update operator multiplicities 
generated operators ffi operator config tuple oper config tuple oper count tuple oper tuple oper count ffi gamma space req increment repeat statements statements pdg 
procedure input current fpga configuration 
heuristic chosen configuration match fpga space requirement set statements rearranged 
output rearranged statements 
heuristic configuration match statements arranged configuration requirement closely matches arranged followed statements fewer match 
ffl create local array size equal number statements input 
element array structure fields match count count input statement 
ffl element local array ffi match count ffi count ffi statement input statements ffl element local array ffl statement ffl operator ffi increment match count 
ffi increment count 
ffl arrange elements local array decreasing sorted order criteria 
statement count count 
count count match count match count 
ffl return sorted statements 
heuristic fpga space requirement ffl statement input ffi space req operator space req ffl arrange statements local array decreasing order fpga space required 
ffl return sorted statements 
