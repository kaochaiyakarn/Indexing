appears journal logic programming pp 
november 
logic algebraic languages interoperability multidatabase systems laks lakshmanan sadri iyer subramanian developing declarative approach interoperability context multidatabase systems major goal research 
take step goal developing simple logic called schemalog syntactically higher order order semantics 
schemalog provide interoperability multiple relational databases federation database systems 
develop fixpoint theory definite clause fragment schemalog show equivalence model theoretic semantics 
develop sound complete proof procedure clausal theories 
establish correspondence schemalog order predicate calculus provide reduction schemalog predicate calculus 
propose extension classical relational algebra capable retrieving schema databases multidatabase system prove equivalence form relational calculus inspired schemalog syntax 
address correspondence department computer science concordia university montreal canada laks cs concordia ca department mathematical sciences university north carolina nc usa sadri edu department computer science concordia university montreal canada cs concordia ca research supported part natural sciences engineering research council canada fonds pour formation de aide la recherche quebec 
illustrate simplicity power schemalog variety applications involving database programming schema browsing schema integration schema evolution cooperative query answering aggregation 
highlight implementation schemalog realized federation ingres databases 
key words multidatabases interoperability higher order logic fixpoint model theoretic semantics sound complete proof procedure algebra calculus database programming schema browsing line analytical processing olap 
rapid progress database systems research past couple decades resulted evolution diverse database environments data application programs generated specifically environments typically incompatible 
resulted inability share data programs different platforms need compelling 
motivates need multidatabase systems mdbs capable operating distributed network encompassing heterogeneous mix computers operating systems communication links local database systems 
multidatabase systems referred heterogeneous database systems federated database systems fdbs different authors 
reader referred particular see sheth larson litwin mark roussopoulos hsiao surveys field 
basic functionality mdbs feature interoperability 
interoperability defined ability uniformly share interpret manipulate information component databases mdbs 
aspects heterogeneity mdbs database schemas data models communication protocols query processing consistency management security management raise challenges interoperability 
objective develop languages facilitating interoperability mdbs 
interacting databases mdbs calls ability query manner independent discrepancies structure data semantics 
focus question query component databases mdbs store semantically similar data dissimilar schema 
approaches attempted far interoperability broadly classified approaches common data model ii non procedural languages 
survey representative works approaches 
comprehensive survey related literature reader referred 
common data model databases participating federation mapped common data model cdm object oriented model naturally meets cdm requirements terms richness modeling power acts interpreter 
similarities information contents individual databases semantical inter relationships captured mappings cdm 
setting user queries cdm cdm language usually aware cdm schema 
sophisticated scenario views correspond schema participating databases defined cdm providing user convenient illusion information gets database 
called tight coupling 
canonical example cdm approach pegasus project ahmed 
pegasus defines common object model unifying data models underlying systems 
rosenberg functional model cdm project 
uses relational cdm allows relational interoperability extensions include text 
federation users may formulate queries sql 
major problem associated approaches category amount human participation required obtaining cdm mappings 
dynamic changes semantics schemas individual databases lead cdm mappings requiring major costly human intervention 
cases autonomy requirements impose limits information available constructing cdm mappings 
levy srivastava kirk architecture query processing global information systems 
approach description logic 
framework general traditional mdbs issues study arise mdbs techniques applicable mdbs 
perspective approach mapping component information systems called world view similar cdm 
query optimization main concern issues schema browsing restructuring database programming addressed 
non procedural languages second approach interoperability involves defining language allow users define manipulate collection autonomous databases non procedural way 
cdm defined previous case required non procedural language sense plays role cdm 
major advantage associated approach flexibility loose coupling provides 
litwin mark roussopoulos advocate concept mdbs language central notion mdbs system 
argue global interpretation obtained cdm approach discuss merits language multidatabase sql extension sql interoperability multiple relational databases 
salient features language include ability retrieve update relations different databases define multidatabase views specify compatible equivalent domains different databases 
chomicki litwin propose extension functional object oriented language 
language constructs capable declaratively specifying broad class mappings multiple object oriented databases 
sketch operational semantics language 
siegel rosenthal introduce theory semantic values unit exchange facilitates interoperability 
apply theory relational model propose extension sql called 
attribute schema provides capabilities specifying manipulating meta attributes correspond properties attribute 
meta attributes provide context information interoperability databases mdbs 
languages higher order logic vehicle interoperability 
underlying philosophy schematic information seriously considered part database information content 
approaches especially suited handling schematic discrepancies commonly occuring mdbs 
approaches involve defining higher order logical language express queries ranging meta information corresponding individual databases schemas 
major advantage associated approaches derive logical foundations 
lefebvre topor logic kifer provide data mappings local databases assumed global database integrated view local databases 
mappings take care data schema discrepancies local databases 
global queries translated local ones query translation algorithm written logic 
major strength approach declarative medium provide mapping query translation rules helps conciseness modularity maintenance 
krishnamurthy naqvi propose horn clause language range data meta data allowing higher order variables 
krishnamurthy litwin kent extend language demonstrate capability interoperability 
provide formal modeltheoretic proof theoretic semantics language language full fledged logic 
approach falls classifications dm model barsalou 
dm deals set formalize data model constructs second order logic 
data model collection dm 
schema instantiates set order types 
database consists instances schema types 
dm organized inheritance lattice provides extensibility 
approaches discussed far suffer drawbacks 
order effectively handle schematic discrepancies schema information primary status values appearing databases language 
functionality lacking approaches 
approaches uniform treatment data meta data schema browsing specifying higher order mappings inconvenient 
higher order capabilities logic uniformly manipulating data schema approach uses logic primarily query translation provides sql user interface 
severely limits schema browsing capabilities user interface 
approaches base interoperability higher order mappings component databases provide support adhoc queries refer possibly compare data schema components multiple databases shot 
provide uniform syntax multiple databases manner glosses schematic discrepancies 
combination logic object orientation metaprogramming gives power dm model second order nature raises questions possibility practical implementations approach 
semantics quite complex 
interoperability unstructured information systems active area current research 
tsimmis hermes noteworthy systems built facilitate interoperability heterogeneous information sources necessarily traditional databases 
reported naturally extended settings confine study interoperability issues multiple relational database systems term lattice mathematical sense loosely authors put forth ideas 
develop logical foundations higher order logic called schemalog 
schemalog believe key requirement interoperability component databases mdbs 
logic approach interoperability bring advantages clear foundations sound formalism proof procedures providing truly declarative environment 
conventional database query languages predicate calculus useful querying data database 
seen interoperability necessitates functionality query data database schema metadata 
calls higher order language treats components meta data class entities semantic structure 
framework queries manipulate data schema breath naturally formulated 
important concerns designing expressive logic language 
language sound complete ii tractable admitting simple efficient proof procedures effective implementation iii enhance expressive power significantly adding relatively simple constructs order logic iv admit queries programs expressed intuitively concisely 
believe achieved goals design schemalog 
contributions ffl develop logical foundations interoperability mdbs higher order logic called schemalog 
introduce schemalog informally motivating example section 
syntax section inspired part 
provide formal semantics develop model theoretic section fixpoint section proof theoretic section semantics schemalog 
language schemalog full fledged logic 
technically framework developed different 
ffl propose proof procedure full clausal schemalog show sound complete section 
ffl schemalog hilog chen syntactically higher order semantically order :10.1.1.52.7860
give reduction schemalog order predicate calculus section 
reduction yields technical benefits soundness completeness compactness schemalog 
argue interoperability crucial requirement query language schema preservation see section prove requirement schemalog strictly higher expressive power order logic 
ffl propose extension classical relational algebra capable retrieving manipulating schema data component databases mdbs 
establish equivalence algebra form relational calculus inspired schemalog syntax section 
ffl illustrate number applications schemalog practical problems field mdbs schema browsing cooperative query answering schema evolution integration computation powerful forms aggregation abilities conventional languages sql 
outline potential schemalog providing theoretical foundation olap line analytical processing currently active area research tremendous practical potential section 
ffl compare schemalog previously proposed higher order logics including logic hilog bring unique features section 
briefly highlight implementation schemalog interoperable system federation ingres databases section 
summarize discuss research section 
confine interoperability problem relational databases 
eventual objective extend schemalog logic capable providing interoperability different data models notably object oriented model 
rest federation mean collection relational databases interoperate 

schemalog example section introduce syntax intuitive semantics proposed language informally example 
follow formal account syntax semantics section 
example 
consider federation university databases consisting relational databases univ univ univ corresponding universities database maintains information university departments staff average salary 
univ pay info category dept avg sal prof cs assoc prof cs secretary cs prof math 
univ pay info category cs math prof assist prof asso prof 
univ cs category avg sal prof assist prof ece category avg sal secretary prof 
university databases univ database single relation pay info tuple department category department 
database univ single relation pay info case department names appear attribute names values corresponding average salaries 
univ relations departments tuples corresponding category average salary dept relations 
heterogeneity representations evident example atomic values univ dept appear attribute names univ relation names univ user databases may need interact databases context federation universities 
user able express queries 
departments average salary universities category 
list similar departments univ univ average salary similar categories staff 
database relations relation tuples functions mapping attributes values 
identification set tuples constitute relation accomplished associating tuple id 
query expressed schemalog gamma univ pay info dept category avg sal univ pay info category category univ category avg sal query expressed gamma univ pay info category category univ category avg sal notice query variable ranges domain values attribute relation names 
flexibility querying medium highly expressive declarative 
variables intuitively stand tupleid corresponding tuples relations 
queries variable explicitly compared attribute category occurs position ranges attributes 
explicit comparison required known relation called category univ 
schemalog syntax semantics section formally syntax semantics language 
simplified version problem assuming names databases 
reality dept database relation correspond department 
issue suppressed loss generality name mappings easily realized framework 
existential variables projected writing rules 
mainly focus intuition syntax schemalog 

syntax strings starting lower case letter constants starting upper case letter variables 
special case denote arbitrary terms language 
denote arbitrary formed formulas denote arbitrary atoms 
vocabulary language schemalog consists pairwise disjoint countable sets function symbols non function symbols variables usual logical connectives 
symbol term language 
place function symbol terms term 
atomic formula expression forms terms example illustrates intuitive meaning syntax 
atom form refer terms non id components id component 
id component intuitively stands tuple id tid 
depth atomic formula denoted depth number non id components depths categories atoms introduced respectively 
definition atoms appears atoms depth 
formed formulas wff defined usual atom wff wff wff variable 
permit molecular formulas form abbreviation corresponding formed formula delta delta delta 
spirit similar molecules logic 
literal atom negation atom 
clause formula form delta delta delta xm delta delta delta ln literal xm variables occurring delta delta delta ln definite clause clause positive literal represented bn called head bn called body definite clause 
unit clause clause form definite clause empty body 
example 
molecule univ pay info category context university federation asserts fact database univ relation pay info attribute category attribute contains tuple value 

semantics non empty set elements called intensions corresponding terms 
consider function maps non function symbol corresponding intension function fun interprets function symbols functions true atoms model captured function takes arguments name database relation name attribute name tuple id maps corresponding individual value 
atomic formula true function corresponding formula mapping symbols formula corresponding intensions defined structure values match 
semantic structure language tuple fun ffl non empty set intensions ffl function associates element symbol ffl fun function symbol arity ffl denotes set partial functions illustrate role consider atom atom true defined similarly atom true defined 
variable assignment function function gamma 
extend set terms follows 
ffl ffl fun function symbol arity terms 
term 
satisfaction atomic formula structure defined follows 
ffl form iff defined ffl form iff defined ffl form 
iff defined ffl form 
iff defined satisfaction compound formulas defined usual way ffl iff ffl iff ffl iff may possibly differ closed formulas depend simply write closing section note built predicates introduced interpreted schemalog usual manner 
shall freely built predicates examples 

reduction schemalog predicate calculus richer syntax schemalog may raise questions axiomatizability potential implemented viable medium mdbs interoperability 
section prove schemalog formula encoded predicate calculus equivalence preserving manner 
show schemalog inherits desirable properties order logic offering convenience higher order syntax 
syntax define language fol derived schemalog language fol consists set logical symbols variables function symbols unique predicate symbols call call call call correspond schemalog formula encoding predicate calculus determined recursive transformation rules 
discussion db rel attr id val set terms formulas 
encode encode encode encode encode encode encode db rel tid attr val call encode db encode rel encode tid encode attr encode val encode db rel attr call encode db encode rel encode attr encode db rel call encode db encode rel encode db call encode db encode encode encode encode encode encode encode encode encode encode encode encode qx qx encode 
semantics schemalog structure fun construct corresponding order structure encode fol follows 
interprets function symbols fol functions appropriate arity interprets predicate symbols fol relations appropriate arity note logical symbols function symbols arity 
def un def fun un arity un call predicates fol interpreted way hd vi call iff defined hd ai call iff defined hd ri call iff defined hdi call iff defined variable assignment function variables fol universe extended set terms analogously way done section 
truth formed formula variable assignment structure fol defined follows 
atomic formula form call db rel tid attr val db rel tid attr val terms fol fol call db rel tid attr val iff db rel tid attr val call 
similarly atoms depth 

wff involving connectives quantifiers satisfaction defined usual inductive manner 
theorem 
encoding theorem schemalog formula schemalog structure 
encode order formula corresponding encode corresponding structure order language fol iff encode encode 
proof 
fun schemalog structure 
encode structure fol 
shall show induction structure formulas iff fol encode 
base case atom 
cases consider depending depth atom 
shall give proof case depth 
proof atoms depth analogous 
atom db rel tid attr val db rel tid attr val terms db rel tid attr val iff db rel tid attr defined db rel tid attr val iff 
db rel attr tid val call iff fol call db rel tid attr val iff fol encode 
induction suppose compound formula involving connectives quantifiers 
shall indicate proof case remaining cases follow analogously 
form arbitrary schemalog formulas 
fol encode fol encode fol encode encode fol encode fol encode 
theorem simple induction follows schemalog program encoded order logic program encode schemalog structure maps output structure iff encode maps encode encode 
simple words means mappings schemalog structures expressible schemalog programs exist corresponding transformations encodings schemalog structures expressible order logic programs 
technically schemalog expressive power order logic database programming language 
consequence order semantics results axiomatizability decidability compactness accrue schemalog 
discussion expressive power results preceding section indicate schemalog expressive power order logic view fact simulated 
raises question schemalog yield higher expressive power order logic 
understand question perspective note simulation schemalog order logic crucially relies assumption federation conventional databases available reduced form form call relations call call call call see proof theorem 
equivalence expressive power firstorder logic schemalog holds databases reduced form input databases conventional form 
notice simulated simulating languages take federation databases input inputs equivalent 
ross addresses similar issue context algebra proposes hilog introduces notion relation preserving simulation 
defines simulation relation preserving simulated simulating formalisms operate database 
context interoperability extend notion level federation speak simulations preserve schemas 
definition 
transformation class input output instances logic language 
say program expresses provided 
definition 
schema preserving simulation language simulated schema preserving manner language provided program expresses transformation program expresses crucial point observe definition programs simulated simulating languages manipulate input instances identical schemas identical data 
contrasted kind simulation entailed theorem schemalog programs manipulate relational databases conventional form simulating order logic programs manipulate encoded versions databases clearly different schema 
theoretical motivation schema preservation arises fact databases federation encoded arbitrarily purpose simulation useful information normal forms integrity constraints lost 
certainly case reduced form encoding proof theorem 
practical perspective autonomy requirements due prohibitive cost involved encoding databases federation reduced form infeasible 
theorem yield schema preserving simulation establish simulation possible 
theorem settles issue finality 
theorem 
order logic simulate schemalog schema preserving manner 
proof 
consider schemalog program db rel gamma db rel 
clearly generates relation width dependent data rel 
hand relational algebraic operator produces output schema data independent 
induction order logic program property transformation expressed expressed order logic program 
theorem theorem implies order logic express mapping conventional database reduced form 
hand schemalog readily express powerful forms restructuring databases see section 
view discussions see schema preservation essential practical requirement query languages interoperability 
conclude requirement schema preservation schemalog strictly higher expressive power order logic 
final note language higher expressive power requirement schema preservation leads queries chosen application domain natural concise compared language simulate encodings preserve schemas 

programming schemalog purposes database programming section focus definite clause fragment schemalog 
develop fixpoint model theoretic semantics fragment establish equivalence 
section develop sound complete proof theory full logic schemalog 
simplicity exposition address issue equality sections 
appendix show results sections lifted case equality theory addressed 

fixpoint semantics consider program set definite clauses 
notions herbrand base herbrand interpretation herbrand model follow conventional ones extensions induced nested structure schemalog atoms 
definition 
atomic formula depth 
restriction depth formula obtained retaining non id components depth important simply say restriction restriction atom depth depth 
example 
restriction depth respectively 
definition 
set ground atoms 
closure denoted cl defined cl fa restriction depth depth set atoms closed cl extend notion closure set sets atoms defining cl def fcl ig 
definite program 
herbrand universe set ground variable free terms constructed symbols herbrand base bp set ground atoms formed logical symbols appearing note definition herbrand base program closed 
herbrand interpretation closed subset bp shown herbrand interpretation obtained principles definition structure interpreting logical symbols function symbols usual herbrand style equivalent simpler notion herbrand interpretation 
model satisfies clauses easy show union intersection closed subsets bp closed 
cl bp set herbrand interpretations complete lattice partial order set inclusion 
top element lattice bp bottom element phi 
union intersection correspond join meet usual 
definition 
definite program 
mapping tp cl bp cl bp defined follows 
herbrand interpretation 
tp cl fa bp gamma ground instance clause fa ig 
results 
lemma 
definite program 
mapping tp continuous monotone 
proof 
directed subset cl bp 
fa ang lub iff fa ang show tp continuous show tp lub lub directed subset tp lub ground instance clause fa ang lub restriction ground instance clause fa ang restriction tp lub 
proves tp continuous 
monotonicity follows 
lemma 
definite program herbrand interpretation model iff tp proof 
model iff ground instance gamma clause fa ang implies true tp particular notice atom tp restriction gamma ground instance clause fa ang closed 
theorem 
fixpoint characterization herbrand model definite program 
set herbrand models intersection 
model called herbrand model lfp tp fa bp ag 
proof 
know glb herbrand model 
follows lemma lfp 
theorem follows lemma 
details identical classical logic programming 
directed finite subset upper bound incorporating various forms negation studied logic programming see schemalog difficult 
discuss issue 

proof theory schemalog section develop sound complete proof theory schemalog full fledged logic 
consider arbitrary schemalog theories just definite clauses 
analogous order logic show arbitrary theories transformed clausal theories 
achieved skolemization usual 
develop proof theory schemalog theories consisting clauses resolution 

skolemization schemalog sentence oe schemalog transformed equivalent sentence oe prenex normal form 
sentence prenex normal form form formula containing quantifiers 
transformation lines predicate calculus 
algorithm transformation chang lee easily adapted schemalog 
skolemization process eliminating existential quantifiers formula replacing suitable functions called skolem functions 
intuition skolemization 
formula asserts exists property holds choice seen function skolemization simply assigns new arbitrary function symbol represent choice function 
eliminate existential quantifier associated notice skolemization schemalog virtually identical classical order logic 
essential reason schemalog classical logic function symbols directly interpreted extensions 
contrast hilog example interprets function symbols symbols intensionally 
new symbol chosen represent skolem function assigned new intension may possible 
authors hilog get difficulty unused arity old symbols represent skolem function 
see details :10.1.1.52.7860
schemalog skolemization works manner identical predicate calculus refer reader details 

herbrand theorem virtue skolemization loss generality restrict attention formulas prenex normal form universally quantified 
transforming formulas conjunctive normal form obtain schemalog formulas clausal form 
recall notions herbrand universe herbrand base herbrand interpretations section 
proposition 
set clauses suppose model 
herbrand model 
proof 
interpretation herbrand interpretation defined fa true ig 
follows easy induction model model lemma 
set clauses unsatisfiable iff false respect herbrand structures 
proof 
satisfiable proposition shows herbrand model 
chang lee introduce notion semantic tree 
classical case shall semantic trees establish strong version herbrand theorem see theorem schemalog prove completeness proof procedure 
notions needed defining semantic trees 
recall notion restriction atoms smaller depths see definition 
notion extended literals obvious manner 
definition 
literal reducible literal restricted depth 
atom 
literal contradicts reducible set fa called contradictory pair 
notice contradicts general follow contradicts example db rel attr db rel 
definition 
set clauses herbrand base semantic tree tree edges labeled finite sets ground literals node finite number children delta delta delta edges connecting children lit denote finite set literals labeling view set lit denoting conjunction literals set 
lit delta delta delta lit tautology 
ii node union labels edges appearing branch root contains contradictory pair literals 
node semantic tree denote union labels edges appearing branch root note general viewed partial interpretation 
definition 
herbrand base set clauses 
semantic tree said complete provided leaf node atom contains notice complete semantic tree infinite 
definition 
node semantic tree set clauses failure node falsifies ground instance clause falsify ground instance clause ancestor node said closed provided branch terminates failure node 
node closed semantic tree called inference node immediate descendant nodes failure nodes 
state strong version herbrand theorem schemalog plays important role proof completeness proof procedure 
proof analogous classical predicate calculus sketched appendix 
theorem 
herbrand theorem set wffs clausal form unsatisfiable iff complete semantic tree finite closed subtree 
note just classical case get easy consequence theorem set clauses unsatisfiable finite subset ground instances 
unification unification schemalog treated differently way done conventionally 
case predicate calculus natural need literals unequal depth unified 
see consider example 
consider definite program fdb rel attr gamma asserting existence database db relation named rel attribute attr defined 
consider query gamma db rel asks existence database db relation named rel defined 
resolution conventional sense result refutation 
switch head rule goal consider program fdb rel gamma query gamma db rel attr 
intuitively understand resolution fail 
example illustrates key issues unification schemalog involves literals commutative 
intuitively issues related definition closure fixpoint semantics 
turn associated nested structure atoms allowed language 
conventional notion unification needs extended discuss 
definition 
substitution finite set form ft xng xn distinct variables term different definition 
unifier literal literal substitution directionality associated unification arises logic different reason molecule fewer components may unified components 
feature schemalog molecular level 
logic schemalog unification needs directional atomic level 
reducible see definition 
literal unifiable literal unifier definition 
unifier oe literal literal general unifier mgu iff unifier exists substitution oe 
unification algorithm unification algorithm essentially similar classical logic 
adopt certain modifications account peculiar syntax schemalog somewhat different notion unification defined 
develop algorithm modifying unification algorithm discussed ullman 
consider schemalog atoms loss generality may assume variable occurs 
variables renamed 
test unified clearly necessary condition depth depth shall assume algorithm 
algorithm 
computing general unifier 
input atomic formulas disjoint sets variables 
output general unifier indication exists 
method algorithm consists phases 
phase distinguishes equivalent subexpressions identical mgu 
phase ii determines mgu exists 
phase finding equivalent subexpressions 
tree corresponding constructed 
rules inductively define tree 
tree constructed similar way 

form tdb trel tid tree unlabeled root children vid left right order root tree term fdb rel id attr atom depth tree unlabeled root children corresponding terms appearing 

term form tn function symbol arity terms tn tree root labeled root children vn root tree rules completely describe tree schemalog atom 
building trees group nodes equivalence classes 
equivalence classes represented equivalence relation rules defining 
ra rb roots trees ra rb 
suppose nodes ta tb respectively cases arise case root ra root rb case uk children ra vn children rb 
say child corresponds child provided correspond database relation tuple id attribute value term 
corresponds set case nodes ta tb roots 
case labeled 
internal nodes labeled function symbols 
function symbols distinct conclude unified exit 
number children say un vn respectively 
set 
nodes labeled variable 
node phase ii algorithm constructs mgu considering equivalence class obtained previous phase 
phase identical phase ii unification algorithm classical logic ullman refer reader details 
give example unification illustrate algorithm 
example 
consider unifying schemalog formula rel 
equivalence classes obtain fwg fug fy fx fg vg mgu obtained rel 
theorem 
unification theorem atomic formulas algorithm correctly computes general unifier mgu exists 
proof theorem follows lines discussed classical logic ullman 
modifications proof account modified phase algorithm straightforward 

resolution completeness section show extension resolution proof procedure higher order setting sound complete schemalog 
presenting resolution recall notions 
definition 
literals clause general unifier oe coe called factor coe unit clause called unit factor definition 
clauses called parent clauses variables common 
literals respectively 
general unifier oe clause obtained removing oe oe disjunction oe oe called binary resolvent literals called literals resolved 
definition 
resolvent parent clauses binary resolvent factor factor definition 
clause variant clause provided substitution maps variables distinct variables 
set clauses standardized apart classical sense 
deduction finite sequence cn clauses variant clause resolvent proof lemma appendix proof completeness theorem follows closely follow proofs corresponding results predicate calculus 
cases provide major steps ideas involved proof details analogous 
lemma 
lifting lemma instances respectively resolvent resolvent instance theorem 
soundness completeness resolution set clauses unsatisfiable deduction empty clause proof 
suppose unsatisfiable 
herbrand base complete semantic tree herbrand theorem theorem subtree finite closed semantic tree 
root node giving trivial deduction 
node inference node get trivial contradiction finiteness inference node assume loss generality exactly children 
definition semantic tree children case children handled similarly case 
clearly failure nodes 
labels edges respectively 
failure node exist ground instances clauses false respectively falsified 
contain contain resolving literals obtain resolvent false 
lemma resolvent ground instance closed semantic tree fcg obtained deleting nodes edges node root falsified 
clearly number nodes strictly fewer finite apply technique inductively adding resolvents clauses fcg obtained deduction fcg forth eventually obtaining empty subtree consisting root 
point clearly obtained deduction empty clause soundness follows straightforward way 
molecular programming vs atomic programming mentioned section molecular formulas introduced syntax schemalog abbreviation conjunction atomic formulas 
molecular formulas provide mechanism direct convenient programming 
illustrate point example 
consider old 
example 
grandfather predicate defined parent predicate schemalog rule db pers gamma db par pers db par pers 
notice rule molecules 
precise model theoretic semantics molecular formulas schemalog relies equivalence corresponding conjunction atoms 
reader verify expressing rule atoms quite cumbersome 
relational context completely dispense tid interface long molecular programming supported system 
system fill tid 
point tid needed order keep model necessitate rules argument predicate 
theoretic semantics schemalog simple allow tuples intensions tid opposed extension actual tuple values 
quite keeping eventual objective providing integration disparate data models including object oriented model 
fixpoint theory proof theory molecular programs straightforward extensions atomic programs 
rest shall freely molecules examples 
molecules programming certain queries easier shall see section clever manipulation tuple id gives schemalog great power expressing sophisticated queries relational context 
programming predicates context queries view definitions convenient facility predicates part database available 
difference predicates database may regarded corresponding temporary tables need carry tid predicates 
call predicates programming predicates distinction database predicates 
technical side programming predicates easily incorporated schemalog introducing separate set predicate symbols interpreting classically 
shall freely programming predicates examples section see query section 
main distinction programming predicates database predicates database predicates schema components programming predicates formal status schemalog 
programming predicates syntax similar predicates datalog 

algebra calculus section develop algebra extending conventional relational algebra new operations resulting algebra capable accessing database names relation names attribute names values federation databases 
define calculus fragment schemalog useful federation querying prove equivalence results extended relational algebra calculus 
result lifts equivalence classical relational algebra relational calculus framework manipulates data schema uniformly 
study algebra important right 
schemalog query compiled algebraic form hide low level algorithmic details implementation 
better reveal various query optimization opportunities suggested properties algebraic operations 
study fundamental development strategies efficient query processing 
programming predicates conventional syntax namei 
note introduces ambiguity syntax schemalog programming predicate confused functional term 
remove ambiguity requiring functional terms conform syntax 
sake clarity simplicity exposition ignore point 
intended meaning schemalog expressions clear context 

extended algebra classical relational algebra considers data elements relation objects intrinsic interest 
particular schema elements secondary status operators algebra operate values relation 
section introduce extension classical relational algebra capable uniform treatment data schema components relational databases 
achieve introducing new operators algebra allow extraction schema related information 
extended algebra facilitates powerful meta data querying providing conventional data querying 
algebra consists classical relational algebra operators selection oe projection cartesian product theta union difference gamma new operators ffi ae ff fl 
define new operators 
definition 
new operator introduce ffi ary returns set names databases federation databases 
ffi fd name database federation operation university federation example return unary relation univ univ cg 
definition 
second operator unary operator takes unary relation set input returns binary relation follows 
ae fd name database federation relation name dg database name input set ae associates name relation part database federation 
example relation univ cg ae university federation yield relation pay csi 
definition 
operator algebra intended extract attribute names relations federation 
takes binary relation argument returns ternary relation 
ff fd hd ri database federation relation name attribute name scheme rg 
hd ri pair appearing relation federation database ff associates pair names attribute scheme context university federation csig ff return relation cs cs avg 
formally new operator fl algebra basic definitions order 
definition 
pattern sequence hp forms 
called attribute component called value component relation 
satisfied tuple relation satisfied tuple relation attribute satisfied tuple relation attribute scheme trivially satisfied tuple relation pattern hp satisfied tuple relation hp hp satisfied operator fl takes binary relation input pattern parameter returns relation consists tuples corresponding parts database queried pattern exists 
formally definition 
binary relation hp pattern defined definition 
fl hp ki fd hd ri database federation relation attributes tuple satisfies hp ig 
note pattern empty fl hi return set pairs hd ri non empty relation database federation 
example 
operation fl secretary university databases example yield relation 
univ pay info univ pay info univ cs univ ece univ pay info category secretary dept cs univ pay info category secretary category secretary univ pay info category secretary avg sal univ ece category secretary category secretary univ ece category secretary avg sal 
relation output fl secretary operators oe theta gamma ffi ae ff fl extended algebra form independent set operators operator simulated operators 
particular note binary relation effect operations ff fl ff contains output tuples form hd ai hd ri relation possibly empty database attribute scheme 
hand output fl includes non empty relations 
example 
query section list similar departments univ univ average salary similar categories staff expressed extended algebra oe oe category fl pay theta fl avg sal ae cig denote algebra introduced section era 

schemalog query language general schemalog permits querying data schema component databases restructuring 
instance straightforward restructure info database univ example conform schema database univ simple schemalog program see section 
definition 
querying fragment schemalog lq obtained imposing constraints definite clause fragment schemalog function symbols allowed ii rule heads required programming predicates iii rules non recursive safe iv tid rule bodies unshared existential variables 
rationale restrictions follows 
restriction rule heads programming predicates ensures resulting language permits querying opposed database restructuring 
restriction tid ensures querying depend internal details tid somewhat akin conventional relational query languages 
time owing higher order nature language permits schema browsing queries explore rich semantics schema 
restriction non recursive fragment relating language extended relational algebra defined earlier 
programming fragment molecules terms constant variable symbols 
programs language essentially ignore tid 
resulting database programming language quite line relational model allow manipulation tid 
lemma proved appendix 
lemma 
federation databases edb set safe rules lq predicate defined denote output computed input relation corresponding 
rule safe variables appearing rule limited argument non negated subgoal equated constant limited variable chain equalities 
exists expression era 
extended calculus section study language lc spirit domain relational calculus inspired syntax schemalog 
establish equivalence extended algebra era querying fragment lq schemalog 
definition 
term lc variable constant 
atomic formulas atoms forms ii iii iv terms atom involving built predicates 
formulas formed closing atoms usual boolean connectives quantifiers 
atoms type iv called database atoms type called built atoms 
depth database atom lc defined follows 
atoms depth defined schemalog section 
database atoms defined depth 
built atoms depth 
expression lc form fx xm oe xm xm distinct free variables lc formula oe 

domain safety lc provides primary status database names relation names attribute names federation domain include apart values appearing federation names databases relations attribute names 
definition captures notion 
definition 
define depth formula oe depth oe maximum depth atoms formula 
set constants appearing oe 
domain oe denoted dom oe defined follows 
depth oe dom oe depth oe dom oe fs database name federation depth oe dom oe fs database name relation name federation depth oe dom oe fs database name relation name attribute name federation depth oe dom oe fs database name relation name attribute name value federation safety formulas lc consider pay attention domain formula 
ullman call domain indepen note atoms lc correspond general molecules note explicit tid dispensed lc dent formulas safe formulas 
formally define safe formulas 
formula oe variable constant oe denotes result replacing free occurrences oe definition 
formula oe lc safe satisfies properties 
ffl answer oe comes dom oe 
ffl subformula oe form oe oe false regardless values substituted free variables oe dom oe 
ffl subformula oe form oe oe true regardless values substituted free variables oe dom oe 
call fragment lc corresponding safe formulas safe lc lemmas proved appendix 
lemma 
expression era expressible safe lc lemma 
safe lc query expressed safe lq theorem stating equivalence expressive power era safe lq safe lc consequence lemmas 
theorem 
set queries expressed expressions era safe lq programs safe lc formulas 
proof 
follows lemmas 

applications schemalog section give variety examples illustrating power applicability schemalog database programming schema integration schema evolution cooperative query answering aggregation 
case adopting uniform framework schema integration evolution illustrate examples schemalog fulfill need 

database programming schema browsing main advantage schemalog database programming lies simplicity syntax buys ease programming 
higher order syntax gives sufficient power express complex queries natural way bringing programming closer intuition 
instance take look example query adopted :10.1.1.52.7860
find names binary relations token john appears 
query expressed hilog way relations gamma relations gamma gamma relations john consider variant find names relations token john appears 
way query expressed hilog writing set rules arity various relations database presupposes user knowledge schema database 
contrast schemalog query expressed quite elegantly follows 
relations rel gamma db rel gamma relations john rel considered query context just database 
databases relations john occurs interest write rule whereabouts db rel gamma db rel ask query gamma whereabouts john db rel 
hand specifically want binary relations john appears query expression query direct concise schemalog hilog schemalog query uses stratified negation 
leave reader judge types queries typical practically useful 
furthermore section revisit query illustrate schemalog extended aggregate functions express query concise way see example 
interesting program demonstrates usefulness schemalog database programming 
natural join ubiquitous operation database applications 
program demonstrates schemalog invoke natural join unconventional practically useful settings 
consider query relations database db schemes unknown compute natural join 
obvious query expressed classical logic 
schemalog query expressed follows 
db join gamma db db db join gamma db db gamma db db program pair tuples relations respectively regarded common attribute attr disagree rule 
cases regarded joinable 
join rules copy incidentally browsing capability available logic 
components pair joinable tuples 
tuple result relation sub tuple corresponding relation computed rule 
rule computes sub tuple corresponding relation tuples joinable safely copied componentwise fear inconsistency 
example demonstrates tuple id write powerful elegant schemalog programs 
sections contain examples tuple id contexts 

schema integration requirements schema integration mdbs developing unified representation semantically similar information structured stored differently individual component databases 
concept mediator proposed wiederhold means integrating data heterogeneous sources 
expressive power schemalog ability resolve data meta data conflicts suggests potential platform developing mediators 
illustrate schemalog higher order syntax achieve case component databases relational 
consider examples section 
argued order user language querying databases belonging federation aware schemas belonging individual databases interested 
queries discussed section illustrating power language 
idea schemalog vehicle formulating higher order views databases user interact interface transparent differences component database schemas 
instance consider example higher order view defined university federation example 
db view univ department categ sal db univ gamma univ pay info category dept avg sal 
db view univ department categ sal db univ gamma univ pay info category category db view univ department categ sal db univ gamma univ category avg sal example view relation placed unified derived database called db view 
provides unified view component databases 
illustrates rules defining views 
idea logic program define unified view different schemas mdbs conveniently queried federation user 
logic rules offers great flexibility setting views 
manner component database structured schemalog conform schema database 
approach unifying representations component databases obviates need canonical datamodel see section 
fact contrast cdm example adaptation similar example 
approach approach affords great flexibility maintaining mappings changes component representations 
turini 
university pisa implemented mediator language schemalog 

schema evolution schema evolution process assisting maintaining changes schematic information contents database 
somewhat abused term database field interpreted mean different things different researchers 
kim treats versioning schema object management schema evolution nguyen considers various schema change operations associated consequences main issues 
osborn gives interesting perspectives consequences polymorphic constructs object oriented databases aids avoiding code evolution 
important issue schema evolution provide evolution transparency users able pose queries database possibly old version schema familiar schema evolved different state 
related ullman argues need allowing user ignorant structure database pose queries database knowledge attributes relations database 
front user declarative longer bothered details database schema 
pointed ullman natural language interfaces essentially require facility handle needs 
consider application schema changes happening dynamic way 
time schema gets modified previous application programs written database invalid user rewrite modify updating schema status 
maintain user bothered details schema database especially keeps changing 
better approach assume user knowledge particular schema formulate queries database schema modified 
idea shield modifications schema database user possible 
consequence possible maintain currency relevance application programs little modifications account changes schema 
argue uniform approach schema integration evolution desirable possible 
view schema evolution problem schema integration point view way 
stage schema evolution may conceptually considered different database schema dealing 
mappings different database schemas defined logic programs suitable higher order language schemalog 
framework affords possibility schema independent querying programming 
consider example illustrate approach 
example assumes loss information meta data different stages evolution 
time schema rel rel 
time current schema schema rel rel rel 
relation rel split rel rel time assuming decomposition loss join 
schemalog program defines mapping schemas 
schema rel gamma schema rel schema rel schema rel gamma schema rel suppose user view schema pose queries view 
transformation program take care relevant evolutionary relationship schemas 
mapping older versions evolved versions schema maintained declaratively logic program maintenance application programs easier 
complication may arise context schema evolution evolution involve loss meta information say deletion attributes 
produce meaningful answers queries older version schema refer lost information 
suggest cooperative query answering approach problem section 

cooperative query answering research area cooperative query answering databases seeks provide relevant responses queries posed users cases direct answer helpful informative 
overview done area 
consider aspect concerned answering queries data knowledge base systems extending scope query information gathered answers discussed cuppens 
responses generated looking details related original answers literal answers original query 
consider application schema evolution discussed previous section 
mentioned case evolution involving loss meta information query addresses lost meta information just return direct nil false answer provide relevant information pertaining query 
cooperative functionality realized schemalog example illustrates 
example 
suppose want capture parts old schema discontinued new 
note values database correspond parts schema 
schemalog program computes discontinued parts schema 
items schema gamma schema items schema gamma schema items schema gamma schema new gamma items old items snew 
just stratified negation 
items pairs schemas various items information exists relation names attribute names values 
simply says item discontinued database 
easily basic idea information certain item meta information deleted discontinued kept 
cases addition telling user item longer exists current database tell dropped 
similar approach taken identifying items newly introduced snew existed old second aspect interest arises want generalize responses queries different earlier approach ways example illustrates 
example illustrate useful powerful way querying involving schema browsing 
example 
consider query tell john possibly find database 
simplicity suppose john token value database considering 
program expresses query token interest 
interest gamma db interest gamma interest db info gamma interest rule says token occurs value attribute tuple relation tuple ht value tuple occurs attribute name interest 
second rule says certain token relevance tuples interesting respect interest rule simply collects tuples token relation name attribute name value attribute pertains token simple assumption information john contained single database query expressed notice issue having correspondence tables mappings old names new ones commonly arises actual implementation maintenance federations suppressed loss generality tables simply add edb relations logic program maps old database new 
gamma info john 
order response query meaningful user add rule program 
schema rich info gamma interest rule generates set databases corresponding token appears input database 
database relations containing tuples corresponding relation input database pertain token directly indirectly 
related query want verify individuals say john mary database related 
want know related 
idea john mary considered related appear tuple relation relation existing database relation obtained sequence existing relations 
addition output include details equijoin schema information essential relationship john mary 
challenge express query detailed knowledge schema database 
schemalog readily expressed interest gamma db interest equijoin gamma interest db db existing database db new newly created 
membership test performed predicate sure self joins performed computation terminates 
straightforward write rules define predicate 
hand performance reasons may want implement built predicate 
relationship john mary queried gamma interest john mary 
complex situation item known token attribute relation value easily write appropriate rules schemalog browse navigate schema compile relevant information 
close section noting schema browsing navigation find interesting applications context federation 
john international criminal 
information may tracked criminal mdbs operated 
point schemalog equipped handle situations 
inevitably numerous aliases john captured edb relation representing correspondence mappings names component databases federation 

aggregation aggregate functions constitute important functionality practical database query languages 
far discussions examples illustrating expressive power schemalog mainly drawn higher order features 
section informally discuss schemalog extended aggregate functions 
shall show clever manipulation tuple id express powerful aggregate computations 
normally aggregate queries considered literature implemented commercial systems involve collecting multisets values appearing column grouped specific criteria applying system supplied aggregate operations avg count max min sum 
crucial point values retrieved columns 
call conventional aggregation vertical aggregation convenience 
shall see possible express conventional forms grouping sql express novel practically useful forms grouping aggregation counterparts sql 
section shall mainly consider aggregate queries context non recursive queries 
semantics aggregate queries deductive databases recursion discussed ramakrishnan 
theme semantics schemalog queries aggregates recursion obtained follows 
schemalog rule aggregates form db rel tid attr val attr val agg xn gamma 
tid attr val terms usual agg usual aggregate functions 
conjunction usual schemalog molecules programming built predicates 
grouping captured tuple id tid conjunction attribute names suppose db rel ground simplicity 
relation computed head obtained follows 
ym set variables occurring rule head 
relation corresponding body rule 
projection columns corresponding arguments 
variables appear arguments tid rule head 
partition relation values columns 
block partition compute multiset values column associated attribute compute aggregate agg multiset 
ground facts tuple id tid merged tuple output 
semantics case db rel non ground defined analogously 
informal semantics 
investigation formal issues arising schemalog queries aggregates subject addressed depth 
example 
consider relation part database db storing information prices various stocks different exchanges possibly different countries day day basis may 
vertical aggregation example simple query stock compute average may closing price relation corresponding rule body computed minor adaptations functions discussed ullman 
date stock 
stock exchange database toronto stock exchange 
query conventional aggregate query expressible conventional languages sql 
schemalog expressed toronto stock avgp rice avg gamma db stock toronto 
rule instructs system retrieve multiset closing prices toronto exchange stock compute average 
note tid achieve effect similar sql groupby stock 
shall see grouping tid powerful sql groupby 
query extended various ways depending need application 
suppose need compute similar average price stocks exchange 
number exchanges small known user priori expressed obvious way sql 
schemalog require complete prior knowledge schema part user 
regardless number exchanges involved simply write query stock avgp rice avg gamma db stock stock date 
rule creates database view computes exchange average price stock exchange 
suppose stores information pertaining year 
suppose addition relation database dates weeks maps dates week numbers 
assuming financial year starts april closes march expect dates weeks dates weeks hold 
consider query stock compute weekly average closing prices exchanges 
expressed may realized virtual relation implemented external function call may assume loss generality accessible programming predicate call dates weeks 
stock avgp rice avg gamma db date stock stock date dates weeks 
horizontal aggregation consider query stock compute daily average closing price various exchanges 
note conventional aggregate queries involve collecting values occurring column grouping criterion involves collecting values appearing row 
number exchanges small known user priori express query sql 
schemalog detailed knowledge schema user express rule daily date stock avgp rice avg gamma db date stock stock date note choice tid rule instructs system perform horizontal aggregation 
query assumes reasonably stock date uniquely determine closing prices exchanges 
words stock date form key relation 
example consider query stock find daily maximum minimum closing price exchanges exchanges prices prevailed 
assuming complete knowledge schema number exchanges involved typical situation expressing query sql involve writing complicated program involving temporary relations 
schemalog accomplished elegantly 
daily date stock max max min min gamma db date stock stock date daily xmax xmin gamma daily max pmax min pmin db date stock xmax pmax xmin pmin xmax date xmax stock xmin date xmin stock rule computes daily maximum minimum closing prices stock 
second rule derives names associated exchanges checking maximum minimum prices various exchanges 
note tuples output relation daily assembled piecemeal different rules compute values different attributes 
rules assume daily maximum minimum prices occur unique exchanges 
assumption means exchange close maximum minimum price stock 
case output query contain tuple exchange maximum minimum closing price 
leave simple exercise reader modify tid rules achieve effect 
global aggregation situations need perform aggregates multisets values retrieved positions general just rows columns 
example consider stock week number compute average closing price exchanges 
output query form weekly stock avg obvious meaning 
problem multiset values averaging performed stock week number contained rectangular block relation 
clear queries expressed sql rule schemalog express straightforward manner 
global stock week avgp rice avg gamma db date stock stock date dates weeks 
appreciate effect attribute names influencing way values grouped multisets notice schemalog rules queries identical 
particular rule bodies identical tuple id rule head identical 
computes series vertical conventional aggregates computes global aggregate 
dramatic difference arises individual multisets prices grouped associated attribute avgp rice exchange average computed 
contrast prices grouped multiset associated attribute avgp rice constant global average computed 
aggregation arbitrary collections values retrieved different relations databases quite conveniently expressed schemalog manner similar illustrated example query call aggregation arbitrary collections global aggregation 
note general global aggregation simulated sequence horizontal vertical aggregations 
case aggregate function additive 
average example non additive function 
instance avg avg avg avg 
example section illustrates concept arity predicates elegantly captured schemalog 
example 
revisit query find names binary relations token john appears section 
show query expressed succinct manner schemalog 
idea system relation defined schemalog aggregation called arity 
relation maintain information arity relation database federation 
program illustrates relation defined utilized expressing query system arity db rel ary count gamma 
whereabouts gamma system arity db rel ary 
gamma whereabouts john db rel close section noting power higher order variables clever manipulation tid grouping user express powerful class aggregate computations schemalog 
remarks hold suite basic aggregates avg count max min sum available normal implementations augmented functions implemented external function calls 
dynamic restructuring horizontal block aggregation capabilities offered flexible syntax schemalog indicate schemalog develop theoretical foundation olap line analytical processing technology tremendous practical potential lacking clear foundations 
show querying restructuring capabilities schemalog visualized terms fundamental restructuring algebraic operators augmented classical algebraic operators 
develop algebra context dimensional data model called tabular data model prove complete generic computable transformations 
show tabular data model tabular algebra serve foundation olap 
develop language called drawing inspiration schemalog experience 
illustrate usefulness olap applications 

comparison logics notion higher associated logic ill defined 
chen point provide clear classification logics order syntax semantics :10.1.1.52.7860
generally believed higher order syntax quite useful context object oriented databases database programming schema integration 
section compare schemalog existing higher order logics 
comment design decisions development schemalog 
hilog hilog chen powerful logic higher order syntax order semantics :10.1.1.52.7860
parameters language distinction predicate function constant symbols eliminated 
hilog terms constructed logical symbol followed finite number arguments 
hilog blurs distinction atoms terms 
language powerful syntactic expressivity finds natural applications numerous contexts see details :10.1.1.52.7860
hilog sound complete proof theory 
discusses applicability hilog database programming language 
higher order syntactic features language find interesting applications schema browsing set operations implementation vehicle object oriented languages 
viewpoint mdbs interoperability hilog concept ness lack means syntax refer places corresponding attributes method names cumbersome express queries range multiple databases multiple relations database see section 
hilog extensions unsuitable purpose interoperability 
logic kifer provide logical foundation object oriented databases logic called logic 
hilog logic logic higher order syntax order semantics logic powerful capture object oriented notions complex objects classes types methods inheritance 
logic schema browsing facility hints possibility application interoperability 
syntax logic schemalog designed interoperability main goals 
logic mdbs interoperability admits alternatives depending mdbs modeled logic syntax 
undertake detailed study various possibilities modeling mdbs logic proposed higher order logics contrast approaches schemalog approach interoperability 
analysis derived respect approaches logic 
details reader referred 
approach logic suffers drawbacks logic approaches known suffer drawback 

access path violation context interoperability mdbs natural require relation referred asserting existence database belongs attribute referred indicating relation defined forth 
syntax impossible enforce access path language level 

closure property violation attempt capturing interoperability ensure full atom specifying existence database having certain value relation attribute tid needs imply expression asserts existence database relation schemalog notion naturally captured model theory 
approaches logic enforce property logic making necessary write programs enforce constraints 
schemalog uses concepts techniques similar hilog logic important technical differences include function symbols schemalog interpreted extensionally hilog interpreted intensionally 
feature allows classical techniques skolemization proof procedure schemalog minor modifications account syntax notion closed structure 
schemalog features position independence achieved attribute names tuple id 
position independence allows ignore argument positions relations database referred unambiguously names 
hilog position dependent 
logic position independent names methods attributes way schemalog semantic structure interprets attribute names significantly different way logic structure interprets method names 
true strips aspects logic structure needed methods take arguments attributes relation ii aspects needed mainly non monotonic method inheritance considered 
inheritance 
hol higher order language computing labeled sets introduced 
language supports structured data object identity sets 
belongs class languages semantics order 
illustrates template mechanism define database schema 
obvious extend language framework support queries higher order objects multiple databases 
col abiteboul grumbach introduce logic called col defining manipulating complex objects 
col achieves functionality manipulating complex objects introducing called base derived data functions 
syntax semantics col higher order 
syntax support constructs necessary interoperability 
approach annotated logic subrahmanian studied problem integrating multiple deductive databases featuring inconsistencies uncertainties non monotonic forms negation 
proposes approach annotated logics realizing mediator component knowledge bases 
observe contribution neatly complements schemalog data integration schemalog helps resolve conflicts arising data meta data interplay subrahmanian framework allows handle inconsistencies data component databases 
easily augment framework schemalog annotations spirit annotated logics information source tracking framework studied lakshmanan sadri 
resulting language powerful handle kinds inconsistencies 
schemalog approach principle augment hilog logic facilities naming individual schemas naming attributes case hilog 
project chosen start neutral zone try build logic simple possible effectively solving problem hand 
benefits approach regard ease implementation see section 
development relational calculus inspired schemalog syntax algebra equivalent expressive power strong impact ease efficiency implementation schemalog 
pointed implementation experience difficulties implementing logic complex semantics proof theory 
led researchers investigate implementations languages restricted versions logic 
aware algebra corresponding restricted versions logic 
secondly extending schemalog cater oo data model really need incorporate features oodbs logic simply need construct act interface oodb retrieve information 
details rich features oodb modeled left outside language far purpose interoperability goes 
making schemalog hilog see discussions molecular programs section presents problems semantics 
chosen keep logic complex necessary problem studied 
simplicity schemalog appears quite powerful easy program applications see section 

implementation section briefly discuss implementation querying fragment schemalog mdbs consisting schematically disparate ingres databases 
principle equivalence predicate calculus result section realize implementation prolog 
implementation clearly inefficient existing federation need rewritten order reduced form expensive process 
adopt approach 
important aspects schemalog higher order features access schema information multiple databases ii recursion 
significant feature implementation aspects handled independently 
schema information manipulated operators era section realized ingres embedded sql deductive dbms coral recursive query processing 
phase implementation concerned extracting schema related information databases federation converting order form 
phase essentially extended algebra era discussed section 
implementation compiles schemalog program algebraic form 
optimizations suggested properties algebraic operators employed minimize cost fetching meta information reduce amount information needs processed phase 
second phase inference engine coral rich suite recursive query optimization strategies exploited efficient query processing 
system sports pleasant user interface capable things schema browsing facility 
details implementation discussed 
demonstrated implementation simplicity schemalog resulted elegant design easy realization framework current relational database systems 
ongoing involves database storage manager exodus storing output phase 
expect yield significant gain performance coral direct interface exodus storing manipulating persistent relations 
ongoing implementation includes full power schemalog programming language allowing schemalog molecules opposed just programming predicates rule heads 

research objective study foundations interoperability issues arising multi database systems 
mind developed elegant logic called schemalog 
simple flexible syntax schemalog possible express powerful queries programs context component database interoperability 
schemalog treats data database schema individual databases federation databases class citizens 
schemalog syntactically higher order 
developed simple order semantics schemalog idea making intensions higher order objects explicit semantic structure making higher order variables range intensions extensions stand 
developed fixpoint theoretic proof theoretic semantics schemalog 
fact framework extended incorporate various forms negation extensively studied literature deductive databases logic programming see survey notably stratified negation difficulty 
studied extension classical relational algebra capable manipulating schema data component databases federation established equivalence form relational calculus inspired schemalog syntax 
briefly discussed implementation practically useful fragment schemalog mdbs consisting ingres relational databases 
schemalog quite simple study experience indicates rich expressive power making applicable variety problems including interoperability database programming schema browsing schema integration evolution cooperative query answering powerful forms aggregate computations spirit olap applications 
view reduction predicate calculus see section may ask question standard predicate calculus applications envisaged 
reasons approach superior order reduction 
demonstrated programming schemalog natural concise 
pointed section impossible classical predicate calculus interoperability schema preserving manner 
notion closure section directly captured schemalog unification theory 
order encoding approach closure needs captured roundabout way adding axioms form call gamma delta delta delta call delta delta delta reduced program 
clearly leads inefficiency query evaluation 
schemalog better equipped developing paradigm capable addressing interoperability issues arising mdbs featuring multiple data models 
step confined interoperability multiple relational databases 
propose extend direction provide interoperability mdbs featuring disparate data models 
preliminary results incorporating er hierarchical network models schemalog framework 
interested extending current implementation support programming full schemalog language 
ongoing addresses related issues 
authors wish anonymous referees numerous comments suggestions led considerable improvement presentation 

abiteboul grumbach col logic language complex objects 
proc 
workshop database programming languages pages 

acm computing surveys sept 
special issue 

acm 
acm transactions database systems volume june 

ahmed desmedt kent litwin shan pegasus system seamless integration heterogeneous information sources 
ieee compcon pages 

ahmed du kent litwin pegasus heterogeneous multidatabase system 
ieee computer december 

turini language extensions semantic integration deductive databases 
proc 
intl 
workshop logic databases lid pages pisa italy july 

barsalou open framework interoperation multimodel multidatabase systems 
ieee data engg 

carey dewitt richardson shekita object file management exodus extensible database system 
proc 
intl 
conf 
large databases 

chang lee symbolic logic mechanical theorem proving 
new york academic press 

chawathe garcia molina hammer ireland papakonstantinou ullman widom tsimmis project integration heterogeneous information sources 
proc 
ipsj tokyo japan 

chen kifer warren hilog platform database language 
nd intl 
workshop database programming languages june 

chen kifer warren foundation higher order logic programming 
technical report suny stony brook 
preliminary versions appear proc 
nd intl 
workshop dbpl proc 


chomicki litwin declarative definition object oriented multidatabase mappings 
ozsu dayal valduriez editors distributed object management 
kaufmann publishers los altos california 

codd codd providing olap line analytical processing user analysts mandate 
white url www com papers html 

cuppens cooperative answering methodology provide intelligent access databases 
second intl 
conf 
expert database systems 


foundations deductive object oriented database systems 
phd dissertation research report university melbourne australia march 

godfrey minker overview cooperative answering 
journal intelligent information systems 

gyssens marc lakshmanan subramanian tables paradigm querying restructuring 
proc 
acm symposium principles database systems pods june 

hsiao federated databases systems part tutorial data sharing 
vldb journal 

hurson bright multidatabase systems advanced solution global information sharing 
ieee computer society los alamitos ca 
collection papers 

kifer lausen wu logical foundations object oriented frame languages 
journal acm may 
tech 
rep suny stony brook 

kifer li semantics rule expert systems uncertainty 
gyssens van gucht editors nd intl 
conf 
database theory pages bruges belgium august september 
springer verlag lncs 

kifer michael subrahmanian theory generalized annotated logic programming applications 
journal logic programming 

kim won 
object oriented databases 
mit press 

krishnamurthy litwin kent language features interoperability databases schematic discrepancies 
acm sigmod intl 
conference management data pages 

krishnamurthy naqvi real horn clause language 
proc 
th vldb conf pages 

lakshmanan laks sadri modeling uncertainty deductive databases 
proc 
intl 
conf 
database expert systems applications dexa athens greece september 
springer verlag lncs 

lakshmanan laks subramanian iyer higher order logics multidatabase interoperability 
tech 
report concordia university montreal quebec 

lakshmanan sadri subramanian extending database technology sophisticated database programming 
tech 
report concordia university montreal june 

lakshmanan sadri subramanian language querying restructuring multidatabase systems 
proc 
ieee int 
conf 
large databases vldb pages bombay india september 

lakshmanan subramanian papoulis 
declarative system multi database interoperability 
editor proc 
th intl 
conference algebraic methodology software technology amast montreal canada july 
springer verlag 
tools demo 

rosenberg overview 
distributed databases pages 

lawley prolog interpreter logic 
tech 
report griffith university 

lefebvre topor query transformation accessing heterogeneous databases 
workshop deductive databases conjunction jicslp pages november 

levy srivastava kirk data model query evaluation global information systems 
journal intelligent information systems sept 
special issue networked information systems appear 

litwin multidatabase language 
information science 

litwin witold mark leo roussopoulos nick 
interoperability multiple autonomous databases 
acm computing surveys sept 

higher order logic data model 
proc 
north american conf 
logic programming pages 

gori mario della lena fabio 
schemalog implementation mediator language 
master thesis department computer science university pisa pisa italy october 

mumick pirahesh ramakrishnan magic duplicates aggregates 
proc 
th intl 
conference large databases vldb pages brisbane australia 

nguyen schema evolution object oriented database systems 
data knowledge engg north holland 

osborn sylvia 
role polymorphism schema evolution objectoriented database 
ieee trans 
knowledge data engg pages sept 

papoulis 
realizing schemalog 
tech 
report dept cs concordia univ montreal canada 

ramakrishnan srivastava sudarshan coral control relations logic 
proc 
intl 
conf 
large databases 

ross kenneth 
relations relation names arguments algebra calculus 
proc 
th acm symp 
pods pages june 

siegel rosenthal semantic values facilitate interoperability heterogeneous information systems 
acm transactions database systems june 

shepherdson negation logic programming 
minker editor foundations deductive databases logic programming 
morgan kaufmann 

sheth amit larson james federated database system managing distributed heterogeneous autonomous databases 
acm computing surveys sept 

subrahmanian semantics quantitative logic programs 
proc 
th ieee symposium logic programming pages computer society press washington dc 

subrahmanian amalgamating knowledge bases 
acm transactions database systems 

subrahmanian brink emery lu rogers ross ward hermes heterogeneous reasoning mediator system 
tech 
report submitted publication institute advanced computer studies department computer science university maryland college park md 

front distributed heterogeneous databases 
proc 
ieee pages may 

ullman database theory past 
proc 
acm symp 
pods 

ullman principles database knowledge base systems volume ii 
computer science press maryland 

ullman principles database knowledge base systems volume computer science press maryland 

van emden kowalski semantics predicate logic programming language 
jacm october 

wiederhold mediators architecture information systems 
ieee computer march 
appendix 
equality simplicity exposition left open issue equality interpreted presentation model theory proof theory 
straightforward approach view equality semantically 
instance herbrand structure contains atoms force contain atom says terms semantically denote intension 
idea consider quotient herbrand structures respect congruence 
proof theory correspondingly augmented paramodulation preserving soundness completeness theorems 
logic follows approach 
advantages approach feel practical perspective database querying natural view equality syntactically 
example emp sal emp sal appropriate conclude knowledge inconsistent regard semantically equal 
definition satisfiability formalizes notion syntactic equality 
definition 
theory satisfiable model distinct ground terms language interpreted model different intensions 
corresponding model theoretic property satisfiability introduce proof theoretic counterpart consistency 
definition 
atom db rel db rel 
ambivalent ground substitutions hdb rel ai hdb rel theory inconsistent exist ambivalent atoms necessarily distinct consistent inconsistent 
note single atom ambivalent 
consider theory fd lift soundness completeness theorem theorem section account satisfiability consistency 
theorem 
theory consistent iff satisfiable 
proof 
consistent 
assume satisfiable 
exist ground atoms distinct clearly ambivalent 
theorem implies inconsistent contradiction 
satisfiable 
assume inconsistent 
exist ambivalent atoms substitutions ground atoms agree components value component 
theorem follows satisfiable contradiction 

proofs results theorem 
herbrand theorem set wffs clausal form unsatisfiable iff complete semantic tree finite closed subtree 
proof 
shown section transformation schemalog order logic schemalog formula true structure iff corresponding order formula encode true corresponding order structure encode theorem 
herbrand theorem proved result technique similar predicate calculus 
main observation unsatisfiable branch complete semantic tree failure node 
node finite number children application konig lemma implies existence finite closed subtree details straightforward suppressed 
lemma 
lifting lemma instances respectively resolvent resolvent instance proof 
variables renamed common variables 
literals respectively resolved fl mgu clause obtained removing fl fl disjunction fl fl 
substitution 
mgu literals say fl correspond delta delta delta clearly literal factor follows instance unifiable unifiable oe mgu disjunction disjunction obtained removing oe oe 
proved resolvent clearly instance obtained removing fl fl oe ffi oe general ffi fl 
lemma 
federation databases edb set safe rules lq predicate defined denote output computed input relation corresponding 
exists expression era proof 
major parts proof 
part need prove predicate defined equivalent expression era second part deals proving dom set symbols appearing edb relations generated era part proof part similar 
subgoals rules consist conventional programming predicates schemalog molecules 
subgoal corresponding era expression schema relation corresponding variables appearing subgoals programming predicates handled 
show relations corresponding subgoals schemalog molecules derived era 
cases consider depending depth 
subgoal schemalog molecule depth ffi 
constant simply fdg 
ae ffi 
constants variable simply modify imposing appropriate additional selection 
essentially expression ff ae ffi joined times 
terms constants repeating variables impose appropriate selections 
form vn oe conditions fl hp ni ae ffi attribute value pair forms depending pair contains constants 
oe conditions corresponds selection conditions capturing occurrence constants repeating variables list arguments corresponding distinct variables occurring technique applied obtain expression part ii evaluating negated subgoals involves generating complementary relations 
need prove era generate dom set constants appearing databases federation 
framework treats attribute names relation names class citizens era expression generating dom include domain 
set constants appearing dom expressed way 
dom ffi ae ffi ff ae ffi fl ae ffi modifications proof easily obtained lines 
lemma 
expression era expressible safe lc proof 
proof induction number operators era expression say similar proof expressibility classical algebra expressions safe drc 
difference new base case ffi new induction cases ae ff fl considered 
base case ffi safe lc formula corresponding expression fx xg 
safety formula follows definition 
induction case 
ae equivalent safe query fd oe discussed section tid component ignored lq equivalent safe query fd oe rg 
case 
ff safe queries corresponding fd equivalent safe query fd case 
fl equivalent safe lc query fd equivalent safe query fd vn vn vn safety equivalent lc queries straightforward 
lemma 
safe lc query expressed safe lq proof 
proof works lines proof expressibility safe drc queries safe non recursive datalog 
shown safe lc query oe equivalent safe lc query formula satisfies conditions 
ffl contain 
ffl subformula set free variables 
ffl delta delta delta fn maximal conjunct free variables limited appearing free possibly built atom negated formula equated constant limited variable chain equalities 
ffl subformula part subformula form delta delta delta delta delta delta negated 
oe translated algorithmically discussed 
safe lc formula 
may assume loss generality satisfies conditions 
maximal conjunct subformulas xn free variables prove subformula lq program defines relation programming predicate pg xn pg true iff xn true 
xn denotes ground formula obtained substituting delta delta delta base case lc atoms 
define predicate pg pg xm gamma delta delta delta xm free variables definition safe lc formulas follows limited 
safe rule lq induction need consider cases contain appear conjunctions 
free variables atom predicate corresponding pg defined pg gamma gamma ph 
definition safety free variables 
proof claim argument free variable appear true need true free variable take value particular belong dom 
free variables rules express pg gamma ph pg gamma delta delta deltag rule expressed pg gamma delta delta delta sn subgoal corresponding obtained inductively free variables appearing 
