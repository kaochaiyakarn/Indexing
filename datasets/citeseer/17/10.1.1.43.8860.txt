recursive query plans data integration oliver duschka michael genesereth department computer science stanford university stanford ca usa alon levy department computer science engineering university washington seattle wa usa generating query answering plans data integration systems requires translate user query formulated terms mediated schema query uses relations stored data sources 
previous solutions translation problem produced sets conjunctive plans limited ability handle recursive queries exploit data sources binding pattern limitations functional dependencies known hold mediated schema 
result plans incomplete sources encountered practice produced subset possible answers 
describe novel class recursive query answering plans enables settle open problems 
describe algorithm finding query plan produces maximal set answers sources arbitrary recursive queries 
second extend algorithm presence functional full dependencies mediated schema 
third describe algorithm finding maximal query plan presence binding pattern restrictions sources 
cases recursive plans necessary order obtain maximal query plan 
problem data integration information gathering agents received considerable attention due growing number structured information sources available online 
goal data integration systems performed author working ai principles research department laboratories 
preprint submitted elsevier preprint january tsimmis hermes internet softbot sims information manifold disco occam razor infomaster provide uniform query interface multiple data sources freeing user having locate relevant sources query isolation combine manually information different sources 
data integration systems general architecture 
user interacts uniform interface form set global relation names formulating queries 
relations called mediated schema 
actual data stored external sources called source relations 
order system able answer queries specify mapping relations mediated schema source relations 
common method specify mappings employed describe source relation result conjunctive query single horn rule relations mediated schema 
example data source containing papers authored db researchers described follows gamma author db 
relations author db mediated schema formulating queries source relation 
query user formulated terms relations mediated schema system translate query mentions source relations relations available 
system needs find query expression mentions source relations equivalent original query 
new query called query plan 
problem finding query plan problem rewriting queries views 
context views relations sources 
problem rewriting queries views investigated database literature importance query optimization data warehousing :10.1.1.57.1452
previous considered problem finding query plans query plan required equivalent original query 
practice collection available data sources may contain information needed answer query need resort plans 
maximally contained plan provides answers possible obtain sources expression describing plan may equivalent original query 
example source available query asks papers computer science researchers maximally contained plan gamma 
article consider important extensions problem finding maximally contained plan query set data sources 
extensions show possible find maximally contained plan restrict non recursive plans 
introduce new class recursive query plans show results ffl describe algorithm finding maximally contained plan cases user query recursive 
show problem finding equivalent plan case undecidable 
ffl describe algorithm finding maximally contained plan functional full dependencies mediated schema 
presence dependencies complicates rewriting problem allows rewritings valid 
furthermore show context exist non recursive maximally contained query plan 
ffl practice data sources limitations ways accessed 
example name server institution holding addresses employees provide list employees addresses 
provide address name 
extend algorithms case limitations sources described set allowed binding patterns 
case known recursive plans may necessary 
describe algorithm constructs recursive maximally contained query plan 
significant advantage algorithms generative descriptive 
algorithms generate rewriting time polynomial size query 
contrast previous methods describe space possible candidate rewritings propose heuristics searching space 
methods combine process finding rewriting process checking equivalent original query np hard 
contrast method isolates process generating maximally contained rewriting done efficiently 
related previous problem consider cases queries recursive functional full dependencies exist mediated schema 
algorithm checks plans executed restrictions guaranteed produce maximally contained rewriting restrictions 
algorithm produces conjunctive plans guaranteed adhere limitations binding patterns guaranteed compute maximally contained plan 
theoretical investigations problem concentrated showing bound size resulting query plan 
results establish complexity rewriting problem yield non deterministic algorithms solution 
stated algorithms propose heuristics searching space candidate plans 
proposed pseudo equivalent rewritings case equivalent rewritings exist 
ideas give algorithm rewriting conjunctive queries source relations described source descriptions 
problem finding query plans presence binding pattern limitations considered algorithm finding equivalent plan 
kwok weld showed restrict plans sets conjunctive queries may finite rewriting presence binding pattern limitations 
complex query capabilities sources considered 
complex capabilities modeled ability source answer potentially infinite number conjunctive queries 
considered answer queries infinite number conjunctive source descriptions 
authors considered problem rewriting queries views query optimization 
context usually requires query plan equivalent original query 
algorithms described explain combine search query plans traditional system style query optimizer 
rewriting queries views explored purpose deciding cached answers mediator 
algorithms described aimed capturing frequently occurring cases detected efficiently 
organization article article organized follows 
section explains basic terms discussion 
section describes construction inverse rules basis algorithms describe article 
section shows construction inverse rules suffices order compute maximally contained query plans recursive queries 
sections describe extensions algorithm presence functional full dependencies respectively 
section describes algorithm case limitations binding patterns 
inverse rules described section set function symbols 
section show function symbols removed obtain query plans datalog queries 
article full version previously published conference papers 
addition containing full proofs theorems article extends full dependencies shows recursive plans necessary functional dependencies mediated schema 
preliminaries relations queries model mediated schema data sources sets relations 
relation associate attribute name arguments 
example attribute names binary relation author may person 
tuple relation attribute denote value attribute consider datalog queries sets relations 
datalog query set function free horn rules form gamma predicate names tuples variables constants 
head rule body 
subgoal rule 
require rules safe variable head rule occur body rule 
predicate intensional database predicate idb predicate query appears head rule predicates appearing head extensional database predicates edb predicates 
assume query idb predicate called query predicate represents result input datalog query consists database storing extensions edb predicates database bottom evaluation start ground edb facts apply rules derive facts idb predicates 
output denoted set ground facts generated query predicate bottom evaluation 
intermediate result algorithms construct datalog programs function symbols 
arguments bodies heads rules functional terms 
datalog queries contain function symbols refer logic queries 
general bottom evaluation logic query may terminate 
turns introduce function symbols controlled fashion particular evaluation logic queries guaranteed terminate 
furthermore show section remove function symbols 
query define dependency graph nodes predicate names appearing rules 
edge node predicate node predicate appears body rule head predicate query recursive cycle dependency graph 
conjunctive query single non recursive function free horn rule 
recursive datalog query seen finite encoding potentially infinite set conjunctive queries 
consider interpreted predicates article 
containment datalog query contained datalog query databases subset 
datalog queries equivalent contained 
problem determining datalog query contained datalog query general undecidable 
problem remains decidable non recursive 
discussion algorithm test union conjunctive queries contained recursive query replace variables distinct constants 
consider database contains exactly tuples corresponding subgoals frozen bodies rules called canonical database evaluate canonical database 
contained frozen heads rules contained 
example datalog query gamma edge edge black gamma edge black determine non recursive datalog query gamma edge edge black black gamma edge edge edge black black contained replace variables rules distinct constants gamma edge edge black black recall non recursive datalog program translated equivalent union conjunctive queries 
gamma edge edge edge black black yields canonical database edge hc hc hc hc hc black hc hc hc hc output datalog query canonical database hc hc hc hc output contains hc hc contained functional dependencies instance relation satisfies functional dependency tuples abbreviate set attributes relations satisfy set functional dependencies sigma refine notion containment relative containment query contained query relative sigma denoted sigma database satisfying functional dependencies sigma 
order decide containment conjunctive queries presence functional dependencies aho show suffices precede containment algorithm applying chase algorithm contained query 
step applying chase body conjunctive query 
functional dependency holds relation conjunctive query subgoals variables values attributes variable attribute replace occurrences value variable full dependencies functional dependencies special form general kind dependencies called full dependencies full dependency ffi order formula form full dependencies include known dependencies multivalued dependencies join dependencies 
oe oe conjunction relations equality atoms variables relation equality atom variables equality atom ffi called equality generating dependency 
relation ffi called tuple generating dependency 
examples omit universal quantification sake brevity 
functional dependency relation equality generating dependency written form 
query contained query relative set full dependencies delta denoted delta database satisfying full dependencies delta 
data sources query plans schema mediator includes set virtual relations 
relations mediator virtual extensions stored 
role provide user uniform interface multitude data sources 
refer schema mediator mediated schema 
actual data stored set external data sources 
model source containing extension source relation 
set names source relations disjoint set names relations mediated schema 
answer user queries mediator mapping relations mediated schema source relations 
follow approach taken mappings source descriptions specified set conjunctive queries source relation 
predicates heads conjunctive queries source relations predicates bodies relations mediated schema 
meaning mapping tuples data source satisfy query mediated schema relations 
example consider mediated schema includes relations parent male female 
source descriptions say source relations store father mother relation respectively 
gamma parent male authors distinguished case source contains tuples satisfy query case tuples may missing source 
discussion distinction matter 
gamma parent female query user mediator needs formulate query plan query bottoms source relations produces answers query plan set horn rules edb predicates include source relations 
expansion exp query plan obtained replacing source relations corresponding source descriptions 
existentially quantified variables source descriptions replaced new variables expansion 
example query plan determines grandparents ann sources described example gamma ann gamma gamma expansion query plan datalog query gamma ann gamma parent male gamma parent female equivalent vs maximally contained query plans query plan contained datalog query exp contained equivalent exp equivalent query plan contained query plan exp contained exp query plan maximally contained datalog query contained query plan contained contained containment maximal containment relative set functional dependencies sigma relative set full dependencies delta defined accordingly 
note notion maximal containment relative fixed set source relations 
ideally mediator try find query plan equivalent user query 
practice may sufficient data sources completely answer user query 
mediator tries find maximally contained query plan 
sense maximally contained query plan produces answers query retrieved available sources 
course exists plan equivalent user query maximally contained plan 
article focus finding contained plans 
turns cases consider article maximally contained query plan may recursive datalog program 
furthermore show query recursive finding equivalent query plan undecidable finding maximally contained query plan decidable 
inverse rules recursive queries section describe compute set inverse rules set source descriptions 
intuitively inverse rules viewed query plans predicates mediated schema 
inverse rules common constructions describe article 
show inverse rules recursive datalog query provide maximally contained plan noted previous considered construction query plans non recursive datalog queries 
show problem finding equivalent query plan recursive queries undecidable 
explained constructing inverse rules function symbols 
function symbols eliminated show section 
set function symbols inverse rules 
source relation variables body head source description function symbol arity function arity definition inverse rules source relation defined source description gamma 
gamma inverse rule denoted gamma modify obtain tuple follows constant variable unchanged variables appearing body replaced denote set inverse rules source descriptions gamma example inverse source descriptions gamma edge edge edge gamma edge set rules simplify notation edge gamma edge gamma edge gamma edge gamma datalog query set conjunctive source descriptions construction query plan follows 
delete rules contain mediated schema relations appear source descriptions 
resulting query denoted gamma add rules gamma call query obtained gamma gamma 
notice edb predicates remaining rules idb predicates gamma gamma appear heads rules gamma naming idb predicates arbitrary rename idb predicates gamma gamma names differ names corresponding edb predicates ease exposition 
example consider recursive query gamma edge gamma edge determines transitive closure relation edge 
assume data source available gamma edge edge source stores endpoints paths length 
just source way determine transitive closure relation edge best hope achieve compute endpoints paths lengths 
relation edge edb predicate appears description gamma gamma just rules gamma added gamma gamma gamma edge gamma edge edge gamma edge gamma gamma gamma yields endpoints paths length result 
example assume instance edb predicate edge represents graph gamma gamma introduces new constants named 
idb predicate edge gamma represents graph gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma computes transitive closure notice pairs transitive closure contain new constants exactly endpoints paths length original graph query gamma gamma logic query inverse rules contain function symbols 
order show maximally contained plan show evaluation gamma gamma terminate database 
key observation function symbols introduced inverse rules 
inverse rules recursive terms nested function symbols generated 
lemma datalog query set conjunctive source descriptions finite instances source relations logic query gamma gamma unique finite minimal fixpoint 
furthermore bottom evaluation guaranteed terminate produces unique fixpoint 
proof 
gamma recursive introduce function symbols 
hand gamma introduces function symbols recursive 
idb predicates gamma depend edb predicates 
bottom evaluation gamma gamma necessarily progress stages 
stage extensions idb predicates gamma determined 
second stage standard datalog evaluation gamma datalog queries unique finite minimal fixpoints proves claim 
extensions edb predicates logic query produce tuples containing function symbols result 
extensions edb predicates contain function symbols datalog query produces tuples result containing function symbols 
order compare result evaluating evaluating gamma gamma set data sources need define filter gets rid extraneous tuples functional terms 
set sources containing tuples edb predicates query plan function symbols set tuples contain function symbols 
plan sources computes 
theorem shows simple construction adding inverse rules gamma yields logic query uses source relations best possible way 
discarding tuples containing function symbols result gamma gamma contained result query plan contained contained gamma gamma 
theorem datalog query set conjunctive source descriptions query plan gamma gamma maximally contained gamma gamma constructed time polynomial size proof 
prove gamma gamma contained instances edb predicates em determine instances source relations turn edb predicates gamma gamma 
assume gamma gamma produces tuple contain function symbols 
consider derivation tree gamma gamma 
leaves source relations source relations edb predicates gamma gamma 
removing leaves tree produces tree original edb predicates new leaves 
instances source relations derived constants consistently replacing function terms constants yields derivation tree gamma gamma contained arbitrary query plan contained prove contained gamma gamma 
arbitrary conjunctive query generated prove exp contained gamma gamma contained gamma gamma proves claim 
canonical database exp exp contained exp contained output applied conjunctive query generated produces exp 
predicates query exp predicates exp appear source description generated gamma exp contained containment mapping exp 
variable exp appear existentially quantified source description xm mapping maps variable corresponding term xm gamma gamma derive gamma derive specialized conjunctive query 
rules gamma derivation gamma extended derivation conjunctive query contains source relations 
identity mapping containment mapping proves contained gamma gamma 
gamma gamma constructed time polynomial size subgoal source description corresponds exactly inverse rule gamma stated earlier exists equivalent plan query maximally contained plan 
equivalence datalog programs undecidable general test gamma gamma equivalent plan testing equivalent theorem shows problem exists query plan equivalent undecidable 
theorem datalog query conjunctive source descriptions undecidable query plan equivalent proof 
arbitrary datalog queries 
show decision procedure problem allow decide contained containment problem datalog queries undecidable proves claim 
loss generality assume idb predicates name query predicates named respectively arity datalog query consisting rules rules xm gamma xm xm gamma xm new zero ary global relation 
furthermore global relation assume source relation described source description gamma 
show contained query plan equivalent assume contained equivalent query plan consisting rules replaced corresponding additional rule xm gamma xm 
assume query plan equivalent instantiation global relations exp yield result especially instantiations empty relation contains empty tuple 
empty relation produces exactly tuples produced exp likewise 
contains empty tuple produces union tuples produced exp produces union 
exp contain exp produce set tuples regardless instantiation follows equivalent union contained mediated schemata functional dependencies section consider problem generating maximally contained plan query presence functional dependencies mediated schema 
describing algorithm generating plan section show recursive plans may necessary context 
restrict plans unions conjunctive queries may obtain possible answers data sources 
example section illustrate difficulties introduced functional dependencies algorithm 
suppose relations mediated schema conference conference year year location conference year location relations describe conference publication year location conference held year 
conference published year 
year conference held specific location 
functional dependencies conference conference year year location conference year location suppose data sources gamma conference year gamma conference year location tells conference year stores location presentation directly 
assume user wants know pods held gamma location pods plan answer query gamma pods informally query plan proceeds follows 
finds pods finds location conference plan correct conference year 
fact dependencies hold way answering query sources 
important note source relation needed query plan predicates conference year don appear query 
functional dependencies source descriptions contain predicates appearing user query need considered 
going give construction query plans guaranteed maximally contained queries presence functional dependencies 
previous section computing set inverse rules purpose recover tuples relations source relations 
inverse rules example conference gamma year gamma conference gamma year gamma location gamma example rule extracts conference year held location suppose stores information bottom beats top datalog henceforth abbreviated datalog pods stores information bottomup beats top datalog philadelphia 
inverse rules derive conference datalog philadelphia year datalog philadelphia location hf datalog philadelphia datalog philadelphia inverse rules don take account presence functional dependencies 
example functional dependency relation conference conference possible conclude function term datalog philadelphia constant pods 
model inference introducing new binary relation intended meaning holds equal functional dependencies 
extension includes extension tuples derived chase rules shorthand definition chase rules functional dependency satisfied relation mediated schema 
attributes chase rule corresponding denoted chase rule gamma 
denote chase sigma set chase rules corresponding functional dependencies sigma 
example chase rules gamma conference conference gamma year year gamma location location chase rules allow derive facts relation hf datalog philadelphia hf datalog philadelphia extension reflexive construction symmetric symmetry chase rules 
guarantee equivalence relation needed enforce transitivity rule denoted sufficient guaranteeing transitivity relation describe relation reflexive ease exposition 
rule having subgoal body add modified version rule subgoal removed replaced resulting set rules wouldn require reflexive 
gamma 
final step construction rewrite query way equivalences derived relation define rectified query modifying iteratively follows constant subgoals replace new variable add subgoal 
ii variable head replace body new variable add subgoal 
iii variable head appears subgoals replace occurrences add subgoal 
apply steps additional changes query 
example query rewritten gamma location pods note evaluating query reconstructed relations mediated schema derived equivalence relation yields desired result pods held philadelphia 
query set source descriptions set functional dependencies sigma constructed query plan includes inverse rules gamma chase rules chase sigma transitivity rule theorem shows query plan maximally contained relative sigma 
theorem sigma set functional dependencies set conjunctive source descriptions conjunctive query relations mediated schema 
denote set rules gamma chase sigma maximally contained relative sigma 
furthermore constructed time polynomial size sigma 
proof 
key proof show conjunctive query plan sigma exp sigma exp recursive query plans seen encoding union infinitely conjunctive query plans suffices prove claim conjunctive query plans 
prove statement induction query conjunctive query plan sequence queries exp results applying chase step exp sigma exp prove maximally contained relative sigma 
exp contained shown theorem implies exp contained gamma exp follows exp contained exp relative sigma 
induction step assume gamma functional dependency holds relation applied gamma gamma contains subgoals values variables attributes contains variable attribute replaced value variable containment mapping shows contains replace value variable argument position mapped argument position variable gamma new variable new variables add subgoals identical new variables corresponding attributes attribute respectively new variables remaining attributes 
find containment mapping query query gamma shows gamma contained exp gamma chase sequence gamma induction hypothesis exp exp chase rule chase transitivity rule reflexivity relation show 
follows exp sigma exp query contains subgoals additional subgoals sum arities subgoals inverse rules subgoals source descriptions 
exactly chase rules functional dependencies sigma 
conclude constructed time polynomial size sigma 
showed recursive query plans expressive extract maximal amount information data sources presence functional dependencies 
ask possible recursion plans 
example shows recursion really needed order answers 
example suppose relation mediated schema schedule airline flight date pilot aircraft represents pilot scheduled certain flight aircraft flight 
assume functional dependencies relations mediated schema pilot airline aircraft airline expressing pilots airline joint ownership aircraft airlines 
data source available gamma schedule records date pilot flies aircraft 
assume user asks pilots airline mike gamma schedule mike schedule source doesn record airlines pilots 
functional dependencies relation schedule drawn pilots airline mike 
example mike ann known flown aircraft ann works airline mike functional dependency aircraft airline 
ann known flown aircraft john flown aircraft ann john airline second functional dependency 
infer john mike airline 
general query plan gamma mike gamma gamma gamma contained user query contained shorter query plan 
means non recursive query plan fixed number subgoals maximally contained user query 
full dependencies section generalize algorithm previous section arbitrary full dependencies 
added expressive power full dependencies allows example express constraints different relations 
example assume united airlines rule uses specific aircraft connection directions 
expressed full dependencies schedule ua schedule ua flight ua flight ua schedule ua schedule ua full dependency expresses united airlines operates aircraft flight number 
second full dependency states aircraft directions 
key generalizing algorithm define chase rules general dependencies 
ffi full dependency 
rectified full dependency ffi obtained ffi rectifying antecedent implication procedure rectifying queries section 
example rectified version full dependency full dependency schedule schedule ua ua full dependency equivalent rectified full dependency 
suffices define generalized chase rules rectified full dependencies 
definition generalized chase rules gamma gamma rectified full dependency mediated schema relations equality atoms 
generalized chase rule corresponding full dependency rule gamma gamma gamma 
mediated schema relation equality atom defined 
denote chase delta set generalized chase rules corresponding full dependencies delta 
generalized chase rule corresponding rectified full dependency mentioned rule gamma schedule schedule ua ua note functional dependencies generalized chase rules identical corresponding chase rules defined section 
generate plan presence full dependencies follow algorithm section replace chase rules generalized chase rules 
theorem generalizes theorem 
theorem delta set full dependencies set conjunctive source descriptions query relations mediated schema 
denote set rules gamma chase delta relative delta 
furthermore constructed time polynomial size delta 
proof theorem similar theorem noting presence full dependencies suffices precede containment test chase algorithm 
dependencies consider chapter called full dependencies variables appear right hand side implication dependency occur left hand side 
restrictions essential 
dependency full dependency flight flight kind dependency usually refered inclusion dependency asserts set values appearing attribute included set values appearing attribute 
dependency expresses airline offers flight cities airline offers flight directions 
allowed kind dependency corresponding chase rule flight gamma flight 
rule recursive introduces new function terms 
naive bottom evaluation query containing rule wouldn terminate 
question possible build maximally contained query plan presence general including non full dependencies remains open 
limitations binding patterns case consider article presence limitations access data sources 
practice information sources answer arbitrary atomic queries relation store 
particular data source may require arguments relations input 
model source capabilities attach source relation adornment see chap 
specifying binding patterns source supports 
adornment source description string length arity meaning adornment source supports queries arguments bound 
arguments may bound free 
example adornment bf means argument bound queries define executable query plan follows 
definition executable query plan set source descriptions binding conjunctive query plan gamma simplicity exposition assume source relation single adornment 
query plan executable holds argument position adornment ff th element ff constant ff appears gamma datalog query plan includes source relations idb relations 
model idb relations having free adornment relation arity 
query plan executable rule executable 
shown existence binding pattern limitations looking query plan equivalent user query bound number literals need consider candidate query plans 
example adapted shows may finite maximally contained query plan restrict query plans recursion 
example consider sources gamma bf gamma cites gamma source stores pods papers second citation database accepts queries argument bound third source tell won award 
suppose query find award papers gamma executable conjunctive query plan contained gamma gamma furthermore may produce answers obtained intuitively answer number links need followed pods bound size conjunctive queries maximally contained plan 
show allowing recursive plans produce query plan 
example construction include new recursively defined relation papers extension set papers reached papers construction result plan 
papers gamma papers gamma papers bf gamma papers 
describe construction set adorned source relations query recursive plan includes unary relation dom intended extension set constants appear query source descriptions obtained iteratively querying sources 
rules involving dom definition domain rules source relation arity suppose adornment says arguments positions need bound arguments free 
rule domain rule dom gamma dom dom 
constant appearing source descriptions query fact dom domain rule 
denote domain set rules described defining predicate dom 
notice domain rules executable relation dom adornment query plan transformed executable query plan inserting literal dom subgoals variable argument position required bound appear subgoals left body 
resulting query plan denoted exec executable 
show exec equivalent combining result previous section conclude theorem theorem delta set full dependencies set conjunctive source descriptions binding query relations mediated schema 
chase sigma domain gamma exec maximally contained relative delta 
proof 
observations proof executable conjunctive plan variable value take execution extension predicate dom 
executable conjunctive plan reordering subgoals executable produce set answers 
claim proved induction place subgoal number appears time second claim proved showing variable bound time bound superset values answer plan 
denote plan chase sigma domain gamma exec proof theorem proceeds follows 
previous theorems know ignore binding pattern limitations appearances predicate dom conjunctive plan contained query exists conjunctive plan conjunctive queries encoded contained containment mapping ignores dom atoms variables variables complete proof suffices show execution subgoal bindings subgoal execution final result projection result variables 
consider subgoal options 
binding arguments come subgoals dom predicate 
case observation entails necessary bindings 
second option binding arguments come previous subgoals case observation entails ordering subgoals change result note query plan constructed time polynomial size delta 
eliminating function symbols section demonstrated efficient procedure answer datalog query possible source relations desirable transform constructed logic query datalog query represents answer 
means looking datalog query equivalent gamma gamma 
key observation underlying construction datalog query finitely function symbols gamma gamma 
nested function expressions generated bottomup evaluation possible little bit bureaucracy keep track function terms produced gamma gamma generating tuples containing function terms 
transformation proceeds bottom fashion 
function terms idb predicates gamma eliminated replacing list variables occur 
idb predicate names need annotated indicate belonged function term 
instance example rule edge gamma replaced rule edge gamma annotation represents fact argument edge identical argument edge second third argument edge combine function term function symbol second argument edge 
bottom evaluation gamma gamma yield function term argument idb predicate gamma new rule added correspondingly expanded annotated predicates 
definition states construction formally 
shorthand list variables constants fii shorthand adornment 
fi stand ith position fi respectively 
definition predicate splitting query plan function symbols 
going define query plan split encodes exactly derivations doesn contain function symbols 
transformation split called predicate splitting idb predicate represented idb predicates split ffl ff ff gamma inverse rule query plan split contains rule hfi fi fl gamma fl jff ff variable constant arity ff function term function symbol fl fl gamma jff fi ff variable constant jff ff function term function symbol jff fl gamma ff ff variable constant ff function term kth argument 
ffl gamma pm xm rule inverse rule query plan split contains rules fi fi heads ii identical fi fi iii constant fi query plan split contains rule fii gamma fi fi ym fi fi variable occurs occurs variables constants represent variables constants represent places 
example shows transformation 
example logic query example transformed datalog query 
lines indicate stages generation datalog rules 
edge gamma edge hf gamma gamma edge hf gamma edge hf gamma edge hf hf gamma edge hf hf gamma edge hf gamma edge hf generated datalog query shows explicitly arguments original logic query able produce function terms 
resulting datalog program apply standard optimizations 
example predicate contribute answers query predicate graph program path query predicate rules defining deleted 
example dependency graph datalog query example paths predicates hf predicates irrelevant 
rules defining irrelevant predicates dropped 
resulting datalog query edge gamma edge hf gamma hf gamma edge hf hf gamma edge hf gamma edge hf keep track function symbols gamma gamma split know resulting instance query predicate adornment exactly subset result gamma gamma contain function symbols 
immediate corollary theorem 
corollary datalog query set conjunctive source descriptions edb predicates query plan gamma gamma split maximally contained exists query plan equivalent gamma gamma split equivalent introduced novel approach creating information gathering plans allows recursive plans 
shown recursive plans enable solve open problems 
described algorithms obtaining query plan case recursive user queries presence dependencies presence limitations binding patterns mediated schema 
results practical importance dependencies limitations binding patterns occur frequently information sources practice www 
recursive information gathering plans important methodological advantage 
query plans constructed describing set inferences mediator needs order obtain data sources 
consequence simpler construct plans believe easier extend methods contexts 
dan weld discussions comments earlier versions article 
abiteboul duschka 
complexity answering queries materialized views 
proceedings seventeenth acm sigact symposium principles database systems pods june 
candan papakonstantinou subrahmanian 
query caching optimization distributed mediator systems 
proceedings acm sigmod international conference management data pages june 
aho sagiv ullman 
equivalences relational expressions 
siam journal computing may 
arens knoblock 
shen 
query reformulation dynamic information integration 
international journal intelligent cooperative information systems june 
chandra merlin 
optimal implementation conjunctive queries relational data bases 
proceedings ninth annual acm symposium theory computing pages 
chaudhuri krishnamurthy potamianos shim 
optimizing queries materialized views 
proceedings eleventh international conference data engineering ieee comput 
soc 
press pages los alamitos ca 
chaudhuri vardi 
equivalence recursive nonrecursive datalog programs 
journal computer system sciences feb 
chawathe garcia molina hammer ireland papakonstantinou ullman widom 
tsimmis project integration heterogeneous information sources 
proceedings th anniversary meeting pages tokyo japan oct 
information processing society japan 
duschka 
query optimization local completeness 
proceedings fourteenth national conference artificial intelligence aaai pages providence ri july 
duschka genesereth 
answering recursive queries views 
proceedings sixteenth acm sigact sigmod sigart symposium principles database systems pods pages tucson az may 
duschka genesereth 
query planning infomaster 
proceedings acm symposium applied computing san jose ca feb 
duschka levy 
recursive plans information gathering 
proceedings fifteenth international joint conference artificial intelligence ijcai nagoya japan aug 
etzioni golden weld 
tractable closed world reasoning updates 
proceedings th international conference principles knowledge representation reasoning pages san francisco ca june 
etzioni golden weld 
sound efficient closed world reasoning planning 
journal artificial intelligence jan 
etzioni weld 
softbot interface internet 
communications acm 
florescu raschid valduriez 
methodology query reformulation cis semantic knowledge 
international journal intelligent cooperative information systems special issue formal methods cooperative information systems 
friedman weld 
efficiently executing information gathering plans 
proceedings fifteenth international joint conference artificial intelligence ijcai nagoya japan aug 
garcia molina papakonstantinou quass rajaraman sagiv ullman vassalos widom 
tsimmis approach mediation data models languages 
journal intelligent information systems 

aggressive views extract information 
technical report stan cs tr department computer science stanford university 
kwok weld 
planning gather information 
proceedings aaai thirteenth national conference artificial intelligence 
levy 
obtaining complete answers incomplete databases 
proceedings nd international conference large databases pages bombay india 
levy mendelzon srivastava sagiv 
answering queries views 
proceedings th acm sigact sigmod sigart symposium principles database systems san jose ca may 
levy rajaraman ordille 
query answering algorithms information agents 
proceedings thirteenth national conference artificial intelligence aaai portland aug 
levy rajaraman ullman 
answering queries limited external processors 
proceedings th acm sigact symposium principles database systems montreal canada 
qian 
query folding 
proceedings th international conference data engineering pages new orleans la feb 
rajaraman sagiv ullman 
answering queries templates binding patterns 
proceedings th acm sigact symposium principles database systems 
ramakrishnan sagiv ullman vardi 
proof tree transformation theorems applications 
proceedings eighth acm sigact sigmod sigart symposium database systems pages philadelphia pa mar 
shmueli 
equivalence datalog queries undecidable 
journal logic programming 
tomasic raschid valduriez 
data model query processing techniques scaling access distributed heterogeneous databases disco 
ieee transactions computers special issue distributed computing systems 
solomon ioannidis 
gmap versatile tool physical data independence 
vldb journal 
ullman 
principles database knowledgebase systems volume 
computer science press 
yang larson 
query transformation psj queries 
proceedings thirteenth international conference large data bases pages los altos ca 
