fold unfold program semantics graham hutton languages programming group department computer science university nottingham uk www cs nott ac uk explain recursion operators structure reason program semantics functional language 
particular show recursion operator fold structure denotational semantics dual recursion operator unfold structure operational semantics algebraic properties operators reason program semantics 
techniques explained aid main examples concerning arithmetic expressions second concerning milner concurrent language ccs 
aim give functional programmers new insights recursion operators program semantics relationships 
computations naturally expressed recursive programs defined terms properties proved programs form inductive argument 
surprisingly programs similar recursive structure proofs similar inductive structure 
avoid repeating patterns program proof special recursion operators proof principles common patterns introduced allowing concentrate details specific different application 
functional programming community previous area focussed recursion operator called fold associated proof principle called universality 
fold captures common programming pattern list values processed certain recursive manner universality captures common pattern inductive proof concerning programs process lists 
fold universality proved useful variety application areas including algorithm construction hardware construction compiler construction automatic program transformation 
ideas category theory fold uniformly generalised lists large class recursive datatypes :10.1.1.1.7380
appears proc 
rd acm sigplan international conference functional programming baltimore maryland september 
concerned application recursion operators area program semantics 
popular styles semantics denotational approach meaning programs defined valuation function maps programs values appropriate semantic domain 
valuation function defined set recursion equations compositional sense meaning program defined purely terms meaning syntactic subcomponents 
fact pattern recursion required compositionality precisely pattern recursion captured fold 
denotational semantics characterised semantics defined folding program syntax 
widely known certain circles functional programmers aware connection 
recursion operator fold natural dual called unfold captures common programming pattern list values produced opposed processed certain recursive manner 
dual proof principle called universality captures common pattern coinductive proof concerning programs produce lists 
unfold generalised lists large class recursive datatypes :10.1.1.1.7380
applications fold abound relatively little attention unfold functional programming community 
popular style semantics operational approach meaning programs defined transition relation captures single execution steps appropriate machine 
transition relation defined set inference rules meaning program repeatedly applying relation generate transition tree captures possible execution paths program 
fact pattern recursion construct transition trees precisely pattern recursion captured unfold 
operational semantics characterised semantics defined unfolding transition trees 
connection developed category theory functional programmers aware connection 
explain recursion operators structure reason program semantics functional language haskell 
particular show fold structure denotational semantics unfold structure operational semantics algebraic properties operators reason program semantics 
techniques explained aid main examples concerning arithmetic expressions second concerning milner concurrent language ccs 
proceeds adopt increasingly categorical approach semantics give deeper understanding issues 
previous knowledge category theory required 
aim give functional programmers new insights recursion operators program semantics relationships 
denotational semantics denotational semantics meaning terms defined valuation function maps terms values appropriate semantic domain 
section explain denotational semantics characterised semantics defined folding syntactic terms 
formally denotational semantics language syntactic terms comprises components set semantic values valuation function maps terms meaning values 
valuation function compositional sense meaning compound term defined purely terms meaning subterms 
set semantic values clear denotational semantics identified compositional valuation function 
arithmetic expressions example consider language simple arithmetic expressions built set integer values addition operator 
language expressions defined grammar assume parentheses disambiguate expressions required 
grammar expressions directly translated haskell datatype definition parameterised type values flexibility data expr val add expr expr example expression represented value add val add val val 
mainly consider expressions represented haskell 
arithmetic expressions obvious denotational semantics haskell type int integers expr int int evaluation function expressions defined recursively follows val add definition satisfies compositionality requirement meaning compound expressions form add defined purely applying meanings subexpressions evaluation function translated directly haskell function definition eval expr int 
int eval val eval add eval eval example eval add val add val val drawing expressions trees eval add pi piff ff ff ff ff val add pi piff ff ff ff ff val val sigma ffi ffi ffi ffi upsilon ffi ffi ffi ffi looking example see expression evaluated removing constructor val equivalently replacing constructor val identity function id integers replacing constructor add addition function integers 
eval defined recursively behaviour understood non recursively simply replacing constructors expressions functions id 
fold expressions abstracting specific case eval consider general case denotational semantics deno gives meaning arithmetic expression replacing val function add function definition semantics defined manner compositional meaning addition defined purely applying meanings argument expressions deno val deno add deno deno behaviour functions understood non recursively don define manner 
precisely fold allows 
fold arithmetic expressions define denotational semantics expressions simply supplying function replaces val function replaces add 
example fold denotational semantics eval simply defined follows eval fold id example fold define alternative semantics comp doesn evaluate expressions directly compiles expressions list instructions execution stack 
eval defining semantics fold compositional definition data inst push int add comp expr int 
inst comp fold push xs ys xs ys add example comp add val add val val push push push add add 
fold function defined simply abstracting free variables general definition denotational semantics deno expressions fold val fold add fold fold type fold inference rule 


fold expr 
generalising course fold define denotational semantics specific language arithmetic expressions generalised languages 
example consider extending expressions integer variables form var character fold operator simply generalised take extra argument function replace constructor var expression fold val fold add fold fold fold var turn denotational semantics eval generalised give meaning expressions functions stores containing value variable integers 
assuming type store stores function find looking value variable store eval defined generalised fold follows eval expr int 
store 
int eval fold 
fx fy 
fx fy 
find defining semantics fold compositional definition 
example set semantic values non trivial languages usually involve functions way 
general discussion fold return functions see 
general simple connection denotational semantics fold operators denotational semantics folding syntax trees operational semantics operational semantics meaning terms defined transition relation captures execution steps appropriate machine 
section explain operational semantics characterised semantics defined unfolding transition trees 
formally operational semantics language syntactic terms comprises components set states transition relation theta relates states states reached performing single execution step 
applications general notion transition relation may appropriate simple notion suffices 
hs say transition state state usually write set states clear operational semantics identified transition relation 
arithmetic expressions returning example previous section simple arithmetic expressions obvious operational semantics haskell type expr expressions expr transition relation defined inference rules add val val val add add add add rule states values added give single value rules permit rule applied argument addition expression 
example concrete expression possible transitions transition rule applied argument top level addition 
repeated application transition relation possible generate transition tree captures possible execution paths syntactic term 
example expression gives rise transition tree captures possible execution paths fflffl fflffl fflffl fflffl inference rules defining transition relation expressions easily translated haskell function definition 
relation represented list valued function maps expressions lists expressions reached performing single execution step trans expr int 
expr int trans val trans add val val val trans add add trans add trans turn define haskell datatype transition trees execution function converts expressions trees repeated application transition function data tree node tree exec expr int 
tree expr int exec node exec trans looking definition exec see expression executed yield tree expression unchanged root tree equivalently applying identity function id expressions generating list residual expressions processed give subtrees applying trans function 
exec defined recursively behaviour understood non recursively simply applying identity function id generate root expression transition function trans generate list residual expressions processed generate subtrees 
unfold trees abstracting specific case exec consider general case operational semantics oper gives meaning trees function generate root tree function generate list residual values processed generate subtrees oper 
tree oper node oper behaviour functions understood non recursively don define manner 
precisely unfold allows 
unfold trees define operational semantics trees simply supplying function generates root tree function generates residual values 
example unfold operational semantics exec simply defined follows exec unfold id trans unfold function defined simply abstracting free variables general definition operational semantics oper trees unfold node unfold type unfold inference rule 

unfold 
tree generalising course unfold define operational semantics specific language arithmetic expressions generalised languages 
simple connection operational semantics unfold operators operational semantics unfolding transition trees precisely dual connection denotational semantics previous section 
structured approach program semantics recursion operators revealed duality denotational operational semantics missed 
section see recursion operators brings benefits proving properties semantics 
reasoning semantics main reasons defining formal semantics programming languages support formal reasoning languages programs written 
section explain properties semantics proved universality recursion operator fold explicit structural induction 
arithmetic expressions consider equations concerning semantics finite simple arithmetic expressions deno deno trans true size size trans true deno vals oper true equation states transition function preserves denotational semantics expressions 
second equation states transition function decreases size expressions size defined number add constructors 
equation states denotational operational semantics equivalent sense integer values transition tree generated operational semantics equal value obtained denotational semantics 
auxiliary functions size vals easy define 
equations proved induction structure turn making auxiliary results proved induction size proofs structural induction proved universality fold avoids need explicit induction 
universality expressions simple arithmetic expressions universality fold captured equivalence val add fold equivalence states fold unique solution equations proved simple structural induction 
equations precisely assumptions required show fold structural induction 
specific cases verifying assumptions typically done need induction appeal universality complete inductive proof fold manner universality captures common pattern inductive proof just fold captures common pattern recursive definition 
prove equation universality fold expressed form fold case defined simply abstracting left hand side equation deno deno trans abstracting right hand side equation gives constant function 
true expressed form fold defining true appealing universality fold expressions conclude equation equivalent equations val true add equations verified routine calculations need explicit induction 
universality prove similar way need explicit induction 
concurrent processes ccs point examples concerned arithmetic expressions 
remainder show techniques apply real life example milner language ccs calculus concurrent systems describing concurrent processes 
section consider haskell datatypes required syntax semantics ccs processes show defined manner fixpoints functors 
shall see subsequent sections approach permit treatment semantics processes 
set process names set ff process actions language processes ccs defined grammar ff gamma finite choice assume parentheses disambiguate processes required 
named processes defined possibly recursive equations 
set ff actions assumed comprise input actions corresponding output actions silent action indicate synchronisation 
relabelling function function actions actions preserves underlying structure sense simple example process consider recursive equation intuitively equation defines process perform action continue perform action continue 
formally meaning process described possibly infinite transition tree nodes represent states process edges labelled actions performed moving states 
example meaning infinite tree pictured 
assuming types name act names actions respectively grammar processes directly translated haskell datatype definition data proc con name pre act proc cho proc par proc proc res proc act rel proc act 
act ffi ffi pi fi fi fi fi fi ffi pi fi fi fi fi fi ffi psi psi ffi phi phij ffi phi phij ffi phi phij 
transition tree proc type parameterised type actions fixed type act simplicity 
turn datatype trees defined follows data tree node act tree approach defining proc tree permit semantics processes trees defined manner 
defining types directly recursive datatypes prefer define indirectly fixpoints functors 
fixpoints semantics common model recursively defined values fixpoints non recursively defined functions 
special case recursively defined types fixpoint fix type constructor function types types defined haskell follows newtype fix fix example recursive type proc expressed fixpoint non recursive type constructor definition precisely original proc type recursive call definition replaced instance type parameter type proc fix data con name pre act cho par res act rel act 
act constructors new proc type defined simply applying tag constructors con con pre pre cho ps cho ps par par res res rel rel turn recursive type tree expressed fixpoint non recursive type constructor type tree fix data node act definitions shown proc tree types defined fixpoints isomorphic original types defined explicit recursion 
types equivalent sense oneto correspondence values 
functors concept considered functor comes category theory 
notion functor captured built class haskell defined follows class functor map 


definition states type constructor member class functor equipped map function lifts functions type 
functions type 
explicit haskell definition functor preserve identity function distribute function composition sense map id id map map map example type constructor instance class functor definition instance functor map case con 
con pre 
pre cho ps 
cho ps par 
par res 
res rel 
rel easy verify definition satisfies equations required functor 
turn type constructor instance class functor follows instance functor map node xs node xs summary expressed recursive type proc fixpoint non recursive functor recursive type tree fixpoint nonrecursive functor map functions functors play role subsequent sections 
operational semantics ccs languages involving form concurrency standard semantics ccs operational semantics 
section show operational semantics processes trees defined haskell manner polytypic version unfold 
operational semantics ccs transition relation theta ff theta set processes ff set actions 
hp say process perform action process usually write transition relation defined set inference rules pna na example rules named process defined possible transitions repeated application transition relation possible generate possibly infinite transition tree captures possible execution paths process 
example process gives rise tree 
inference rules defining transition relation processes easily translated haskell function definition 
relation represented list valued function maps processes lists action process pairs arise single execution steps trans proc 
act proc trans case con 
trans defn pre 
cho ps 
concat map trans ps par 
par trans par trans tau par trans trans synch res 
res trans strip strip rel 
rel trans auxiliary function defn maps process names definitions defined appropriate user synch decides actions synchronise strip removes bars action give underlying name 
synch strip easy define 
turn define execution function converts processes trees repeated application transition function unfold function trees exec proc 
tree exec unfold trans general purpose unfold function type tree transition trees defined follows unfold node unfold exploiting fact tree defined fixpoint functor execution function defined manner repeated application transition algebra polytypic version unfold specific particular recursive datatype 
algebras concept algebra comes category theory generalises idea transition function 
haskell algebra functor function type 
specific type example transition function processes converted transition coalgebra functor simple definition trans proc 
proc trans node trans general example algebra concerns fixpoint type fix particular inverse function tag algebra functor fix 
fix polytypic unfold algebra special algebras functor fact final algebra 
technically means algebra 
unique function unfold 
fix diagram commutes unfold fflffl fix fflffl map unfold fix diagram fact inverse unfold function defined follows unfold map unfold function unfold applies algebra break argument type structured value type applies function map unfold recursively process components give value type fix applies tag give value recursive type fix manner unfold general purpose function producing values recursive type simple pattern recursion 
previously defined unfold functions specific particular recursive datatypes example trees version unfold polytypic sense recursive datatype expressed fixpoint functor 
case processes datatype tree expressed fixpoint functor transition function expressed algebra trans execution function maps processes trees defined polytypic version unfold exec proc 
tree exec unfold trans summary expressed operational semantics processes trees unique function unfold trans diagram commute proc unfold trans trans fflffl tree fflffl proc map unfold trans tree denotational semantics ccs previous section defined operational semantics processes trees unfolding transition function expressed algebra 
section consider known denotational semantics processes trees show defined dual manner folding combining function expressed algebra 
algebras spirit category theory notion algebra dual algebra 
haskell algebra functor function type 
specific type example tag function fix 
fix algebra functor specific example algebra concerns semantics processes trees 
particular natural define algebra functor follows comb tree 
tree comb node case con 
eval defn pre 
cho ts 
concat map ts par 
comb par comb par tau comb par synch res 
comb res strip strip rel 
comb rel auxiliary function eval defined shortly destructor function trees tree 
act tree node xs xs refer comb combining function takes value built applying ccs operator trees processes combines trees single tree interpreting operator appropriate manner trees 
example third case parallel composition par states tree labelled branch subtree tree labelled branch subtree actions synchronise resulting combined tree tau labelled branch recursively computed subtree comb par 
polytypic fold algebra special algebras functor fact initial algebra 
technically means algebra 
unique strict function fold fix 
diagram commutes fix map fold fflffl fix fold diagram fact inverse fold function defined follows fold map fold function fold applies function break argument recursive type fix structured value type fix applies function map fold recursively process fix components give value type applies algebra combine components single result value type manner fold general purpose function processing values recursive type simple pattern recursion 
previously defined fold functions specific particular recursive datatypes example expressions version fold polytypic 
definition fold precisely dual unfold 
approach recursion operators revealed explicit duality fold unfold missed 
returning processes datatype proc expressed fixpoint functor combining function expressed algebra comb denotational semantics processes trees defined polytypic version fold eval proc 
tree eval fold comb summary expressed denotational semantics processes trees unique strict function fold comb upper square diagram commute dually operational semantics processes trees unique function unfold trans lower square commute 
proc map fold comb fflffl tree comb fflffl proc fold comb unfold trans trans fflffl tree fflffl proc map unfold trans tree reasoning ccs defined operational denotational semantics ccs 
natural ask semantics related 
section show equal exploiting universality recursion operator fold 
universality fold arbitrary recursive datatypes expressed fixpoints functors universal property fold captured equivalence strict map fold fold polytypic operator universal property polytypic proof principle 
returning semantics processes easy verify unfold trans strict definitions functions concerned strictness tags defined newtype 
applying universal property gives unfold trans fold comb comb map unfold trans unfold trans final equation verified routine induction size argument proc size defined number tags operational denotational semantics ccs equal processes finite size 
required extend proof processes infinite size 
semantics proved equal dual universal property unfold fold proof works simpler 
summary shown fold unfold structure reason program semantics haskell 
categorical semantics explaining ideas haskell simpler accessible wider audience executable 
interesting topics include ffl application techniques examples including languages different paradigms ffl monadic fold operators structure denotational semantics programming languages imperative effects mutable state ffl exploring recursion operators algebraic properties correspond non structural patterns induction induction size values ffl applications fold unfold 
supported engineering physical sciences research council epsrc research gr structured recursive programming 
colleagues birmingham cambridge glasgow nottingham oxford york useful comments suggestions 
richard bird 
constructive functional programming 
proc 
marktoberdorf international summer school constructive methods computer science 
springerverlag 
richard bird oege de moor 
algebra programming 
prentice hall 
andy gill john launchbury simon peyton jones 
short cut deforestation 
proc 
acm conference functional programming computer architecture 
graham hutton 
fold preparation 
johan jeuring patrik jansson 
polytypic programming 
john launchbury erik meijer tim sheard editors advanced functional programming lncs pages 
springer verlag 
geraint jones 
designing circuits calculation 
technical report prg tr oxford university april 
geraint jones mary sheeran 
circuit design ruby 
editor formal methods vlsi design amsterdam 
elsevier science publications 
john launchbury tim sheard 
warm fusion deriving build recursive definitions 
proc 
acm conference functional programming computer architecture 
saunders maclane 
categories working mathematician 
number graduate texts mathematics 
springer verlag 
malcolm 
algebraic data types program transformation 
science computer programming september 
lambert meertens 
algorithmics programming mathematical activity 
proc 
cwi symposium centre mathematics computer science amsterdam november 
erik meijer 
calculating compilers 
phd thesis nijmegen university february 
erik meijer maarten fokkinga ross paterson 
functional programming bananas lenses envelopes barbed wire 
john hughes editor proc 
conference functional programming computer architecture number lncs 
springer verlag 
erik meijer graham hutton 
bananas space extending fold unfold exponential types 
proc 
th international conference functional programming computer architecture 
acm press san diego california june 
robin milner 
communication concurrency 
prentice hall 
john peterson haskell language report version 
available world wide web www haskell org april 
gordon plotkin 
structured approach operational semantics 
report daimi fn computer science department aarhus university denmark 
jan rutten daniele turi 
initial algebra final coalgebra semantics concurrency 
de bakker editor proc 
decade concurrency reflections perspectives lncs 
springerverlag 
david schmidt 
denotational semantics methodology language development 
allyn bacon 
tim sheard leonidas fegaras 
fold seasons 
proc 
acm conference functional programming computer architecture 
springer 
daniele turi gordon plotkin 
mathematical operational semantics 
proc 
ieee conference logic computer science pages 
computer society press 

