formal study slicing multi threaded programs jvm concurrency primitives john hatcliff james corbett matthew dwyer stefan sokolowski hongjun zheng santos laboratory kansas state university university hawaii 
previous shown program slicing useful step model checking software systems 
interested applying techniques construct models multi threaded java programs 
past address concurrency primitives java provide rigorous notions slice correctness necessary reasoning programs non deterministic behaviour potentially infinite computation traces 
define semantics simple multi threaded language concurrency primitives matching java virtual machine propose bisimulation notion correctness slicing setting identify notions dependency relevant slicing multi threaded java programs dependencies specify program slicer language 
discuss dependencies refined take account common programming idioms concurrent java software 
program slicing program reduction technique widely applied software engineering static analysis debugging applications :10.1.1.20.9646
previous showed backward static slicing component constructing finite state models sequential software systems :10.1.1.43.3170
existing model checking tools check automatically models software specifications written various temporal logics 
main idea slicing throw away portions program irrelevant specification verified 
reduces size software model reachable state space 
reduces time required model checking 
previous provides part foundational theory set tools building model checking java programs called bandera tool set 
essence bandera pipeline tools compile java source code inputs existing model checking tools smv spin 
supported part nsf ccr ccr ccr ccr darpa nasa nag 
nichols hall manhattan ks usa 
dwyer stefan cis ksu edu corbett mit edu goal scale previous slicing techniques concurrency mechanisms java 
give formal semantics small core language contains concurrency primitives java virtual machine section 
describe notion weak bisimulation concurrency theory adapted define notion correctness slicing relevant multi threaded programs infinite execution traces section 
building various notions dependency earlier slicing sequential multi thread programs introduce additional notions dependency arise considering java concurrency primitives dependencies arise trying preserve semantics programs infinite execution traces 
discuss dependencies stem assumptions may overly pessimistic considers constructing finite state models typical java source code explain dependencies refined section 
discussion related section conclude brief discussion experiments prototype implementation applied concurrent java software section 
concurrent fcl bandera built top soot java compiler framework developed laurie hendren sable group university mcgill 
soot framework java programs translated intermediate language called jimple 
jimple essentially language control flow graphs statements appear code form explicit stack manipulation inherent jvm instructions removed introducing temporary variables various java constructs method invocations synchronized statements represented terms virtual machine counterparts invokevirtual 
formal study slicing setting define language called concurrent flowchart language captures essence jimple control flow graphs focuses tightly jvm instructions thread synchronization including wait notify notifyall start join 
simplicity consider evaluation assignment statements atomic 
treat level storage model jvm threads ch 

due focus concurrency issues omit features method calls dynamic object creation exceptions 
presents syntax gives simple program 
program begins declaration variables variable implicitly typed nat 
model implicit lock associated java object variable list followed list lock identifiers synchronization primitives 
body program series thread declarations 
thread declaration consists thread identifier label initial block executed thread followed list basic blocks 
programs threads blocks block labels assignments syncs variables locks thread identifiers expressions constants jumps operations thread thread goto enter monitor exit monitor wait notify notify goto return fig 

syntax kinds basic blocks block containing list assignments followed jump synchronization block containing single synchronization statement unconditional jump 
assignment statements operate variables shared threads 
synchronization construct operates respect particular lock semantics explained 
conditional tests non zero value represents true zero represents false 
target jump appear thread presentation slicing need reason nodes control flow graph graph separate node assignment synchronization statement jump thread assume statement unique index block block label unique entire program 
node uniquely identified pair block label index value 
statement indices annotations brackets delta ignore annotations indicate results slicing 
example assignment prod put block unique identifier node number prod put 
flow graph consists set statement nodes set directed control flow edges unique start node unique node nodes reachable reachable nodes inverse gamma flowgraph flowgraph gamma edges reversed start states swapped 
node dominates node written dom path start node passes note dominates relation reflexive 
node post dominates node written post dom path node node passes equivalently dom gamma 
cfg back edge edge target dominates source 
back edge natural loop count total prod cons shared variables buffer tally lock identifiers producer code consumer code thread producer thread consumer enter monitor buffer enter monitor buffer goto goto count count wait buffer wait buffer goto goto count count count count count count notify buffer notify buffer goto goto exit monitor buffer exit monitor goto goto enter monitor tally enter monitor tally goto goto total total total total goto goto exit monitor tally exit monitor tally goto goto prod prod cons cons return return thread thread fig 

producer consumer control system buffer size subgraph consisting set nodes containing nodes reached flowgraph passing edge set connecting nodes subgraph 
node called loop header 
cfg reducible structured partitioned disjoint sets forward edge set back edge set forms dag node reached entry node edges back edges muchnick notes implies reducible flowgraph loops natural loops characterized back edges vice versa 
follows definition reducible flowgraph jumps middle loops loop entered header 
syntax jimple allows arbitrary control flow originally designed target byte code decompiler 
target java compiler front 
impose constraints control flow structure thread corresponding constraints properties java source code 
java allows structured control flow goto control structure thread required form reducible flow graph 
enter exit constructs arise compiling java synchronized blocks assume enter exit come matching pairs 
addition unique start node unique node sub flow graph appearing containing thread flow graph 
monitor delimiter able obtain cfg corresponding monitor critical region 
condition define function cr maps node inner critical region appears 
cr enter monitor command matching exit monitor nodes form inner critical region appears 
compiler front annotates conditional type source construct gave rise 
example tell conditional arises conditional source code exit conditional loop 
impossible tell general java loop terminate loops refer exit conditionals loops pre divergence points 
remaining hitch generating cfg satisfying constraints threads satisfy unique node property required definition flowgraph 
specifically thread may return multiple return 
case appears thread contains loops exit conditional guarantees infinite loop 
flowgraphs reducible loop natural loop defined uniquely characterized back edge 
simplicity nodes replace goto jump associated back edge conditional jump return 
second case assume extract cfg thread insert additional node labeled halt successors predecessors return nodes program refer set thread cfgs values labels block labels oe stores variables values pc pcs thread identifiers nodes runnable thread identifiers ftrue falseg blocked sets locks theta thread identifiers lock counts wait tables locks theta thread identifiers lock counts lock tables locks fcl thread identifiers theta lock counts fig 

operational semantics programs semantic values cfg technically misnomer set control flow graphs control flow graph 
access code particular program points program functions 
code map function code maps cfg node code statement labels 
example code prod put yields assignment count count 
function maps label cfg node occurring block labeled example prod put prod put 
function def maps node set variables defined assigned node singleton empty set ref maps node set variables referenced node thread map maps cfg node thread identifier belongs 
example prod put producer 
synchronization java achieved wait notify monitors 
illustrates monitors achieve proper synchronization simple producer consumer system 
note example omits actual manipulation shared buffer gives code properly controls buffer access 
implicit lock associated java buffer object represented lock buffer 
consider producer process example recall variables default value 
process begins trying acquire buffer lock prod obtain lock process acquires lock held blocked set associated lock 
lock producer check see buffer full buffer count 
buffer full producer release lock suspend executing wait instruction causes process placed wait set associated lock increment count items buffer 
increment causes buffer move empty non empty state producer notifies consumer may waiting due empty buffer 
process executes notify continues hold lock process waiting moved wait set blocked set producer releases buffer lock exit monitor instruction block tries obtain tally lock 
tally lock acquired producer increments total number produce consume actions far releases lock 
producer increments total number produce actions far begins cycle 
actions consumer process symmetric 
formalize notions semantics program expressed transitions configurations form hpc oe li gives formal definition configuration components 
program counter pc assigns thread node executed 
store oe maps variable value 
run state table maps thread true signifying runnable state instruction pc immediately executed false signifying blocked waiting gain access lock suspended wait instruction successfully terminated executing return instruction 
blocked table assigns pair hk ti number times thread needs acquire lock unblocked 
semantics jvm thread may acquire lock multiple times 
bhk ti signifies thread blocked lock lock waiting table assigns pair hk ti number times thread needs acquire lock awakened 
ti signifies thread waiting lock lock table maps held lock pair ht ni thread currently holds number times acquired lock difference number preceding enter monitor exit monitor instructions executed 
thread holds lock false 
formally set configurations defined follows configurations pcs theta stores theta runnable theta blocked sets theta wait tables theta lock tables set configurations includes exception configuration bad monitor meant model raising exception jvm 
semantics defined transitions possible exception configuration reached 
gives rules define program indexed transition relation gamma 
configurations 
program indexes relation gives rise code map code thread identifiers semantics 
omit program index writing relation clear context 
execution program begins initial configuration hpc oe li pc init init start node cfg oe true bhk ti oe assign oe hpc oe li gamma 
hpc 
oe li true pc code succ sync hpc oe li gamma 
hpc 
oe true pc code succ sync bad monitor hpc oe li gamma 
bad monitor true pc code oe jump hpc oe li gamma 
hpc 
oe li true pc code oe jump halt hpc oe li gamma 
hpc 
oe 
false li true pc code halt fig 

operational semantics programs transitions ti false 
general transition occurs exists runnable thread indicated runnable thread arbitrarily chosen giving rise nondeterminism program counter pc code map consulted find command evaluate 
separate transition rule syntactic category command 
rule relies auxiliary judgement defines semantics particular command category 
intuition rules judgements follows 
oe expr means store oe expression evaluates value note expression evaluation change value store 
oe assign oe means store oe assignment yields updated store oe oe jump means store oe jump cause transition block labeled sync means run state map blocked set map wait set map lock map execution synchronization statement thread may produce updated versions structures 
gives rules define relation synchronization statements rules expressions assignments jumps straightforward omitted 
enter lock held lock table changed show thread acquired lock 
lock held acquisition count incremented 
thread holds lock placed blocked set current acquisition count run status changed runnable 
exit monitor thread lock count greater count simply decremented lock released 
thread lock count equal lock relinquished 
set threads blocked non empty thread chosen non deterministically blocked set lock 
thread holds lock relinquished placed wait set lock count 
thread non deterministically chosen blocked lock run state set runnable 
notify thread holds lock wait set empty command effect op 
wait set empty thread associated lock count non deterministically removed wait set added block set 
notify thread holds lock wait set empty command effect op current block set unioned empty set 
wait set empty threads associated lock count removed wait set added block set 
thread executes exit monitor notify notify lock exception raised 
returning definition transitions normal final configuration run state threads false thread program counters yield halt 
clear transition gamma 
executes exactly command node write gamma 
gamma 
executing command node gamma 
gamma 
executing command node gamma 
gamma 
executing command node correctness multi threaded program slicing program slice consists parts program potentially affect variable values referenced program points interest :10.1.1.20.9646
program points interest traditionally called slicing criterion 
definition slicing criterion 
slicing criterion program non empty set nodes fn node statement flow graph 
cases slicing literature desired correspondence source program slice formalized leads subtle false sync enter monitor 
ht ht ni sync enter monitor 
ht ht ni sync enter monitor 
false hk ti 
ht ni sync exit monitor 
ht gamma ht sync exit monitor 
false bhk ti 
true hk 

ht ni bhk ht ni sync wait hk ti 

false 
false bhk ti 
false 
true hk 

ht mi bhk ht ni sync notify ae ti hk 
hk 
ht ni sync notify hk hk ae bhk bhk ht ni false sync bad monitor monitor wait notify notify kg fig 

operational semantics programs synchronization statements differences presentations 
notion correct slice stated notion projection finite deterministic execution traces 
clearly moving concurrent setting notions correctness need generalized handle non deterministic execution possibly infinite execution semantics reactive programs designed run indefinitely 
model checking applications typically program temporal logic specification check 
ideal case slicer produce executable program holds holds key point slicer needs preserve semantics parts influence satisfaction 
intuitively nodes actions program observable respect influence satisfaction nodes actions correspond silent moves non observables respect 
discussion suggests appropriate notions correctness slicing concurrent programs derived notion weak bisimulation concurrency theory 
intuitively notion projection generalized notion weak bisimulation actions associated nodes slicing criterion considered observable actions considered silent analogous moves ccs 
definition analogous ccs notion derivative describes situation program zero non observable moves observable move followed zero non observable moves 
addition definition forces values variables referenced observable node match values contained store oe 
allow maintain correspondence store manipulated definition oe derivative 
slicing criterion oe store domain oe ref 
define relation oe hold exist configurations gamma 
gamma 
gamma 
ref oe oe oe store configuration notion oe derivative definition specifies means programs simulate respect observable actions slicing criterion 
definition bisimulation 
programs slicing criterion set nodes cfg 
binary relation configurations theta configurations bisimulation store oe oe exists oe ii store oe oe exists oe configurations bisimilar related bisimulation 
definition bisimilarity 
slicing criterion configurations respectively 
bisimilar written exists bisimulation words fs said correct slice respect initial configurations bisimilar 
definition program slice 
slicing criterion program slice respect initial configurations respectively 
note consists single thread finite execution trace notion bisimulation gives relation usual definition projection originally defined weiser 
computing multi threaded program slices slicing criterion fn computing slice involves finding nodes statements nodes depend 
nodes referred relevant nodes 
relevant variables variables defined referenced relevant nodes 
slicing literature constructing set relevant nodes performed stages 
stage builds program dependence graph pdg captures various dependencies nodes control flow graph 
second stage nodes depend computing transitive closure dependences pdg respect describing types dependence relations required slicing programs 
data dependence related notion reaching definition node data dependent node variable referenced definition assignment reaches node depends node assignment influence value computed definition data dependence :10.1.1.20.9646
node data dependent written dd variable exists non trivial path node gamma fm ng def def ref 
example prod put dd prod put prod check dd prod put prod put dd prod put prod update tally dd prod update tally prod cycle dd prod cycle similarly consumer thread 
control dependence information identifies conditionals may affect execution node slice :10.1.1.20.9646
definition control dependence 
node control dependent written cd exists non trivial path node gamma fm ng post dominated post dominated node control dependent immediate successors cfg conditional paths connect contains 
example prod wakeup control dependent prod put prod release lock post dominates prod put 
noted existing slicing goal construct slices preserve projection semantics terminating program executions 
preserve semantics non terminating executions needs sure slice includes program points lying paths relevant nodes cause non termination 
definition divergence dependence 
node divergence dependent node written omega pre divergence point exists non trivial path node gamma fm ng point 
note definition allow slicing remove infinite loops infinitely delay execution relevant node 
producer thread pre divergence points prod check prod cycle 
nodes producer thread reachable nodes nodes thread divergence dependent 
consider dependencies arise due concurrent execution 
interference dependence captures situation definitions shared variables reach threads 
definition interference dependence 
node node written id variable def ref 
example count prod check prod put prod put interference dependent definition count cons get 
relevant variable defined node inside critical region locking associated region preserved corresponding enter monitor exit monitor commands appear slice 
omitting monitor allow shared variable interference original program 
situation say inner enclosing enter monitor exit monitor nodes imagine conservative analysis distinguish simple cases loops guaranteed converge eliminate exit conditionals loops set pre divergence points 
dependence case nested critical regions captured transitive closure relation 
variable count relevant variable slicing criterion buffer monitors relevant preventing concurrent increments decrements count interfering 
definition synchronization dependence 
node synchronization dependent node written sd cr fm just introduced divergence dependence capture situation infinite loop may prevent execution observable node introduce notion ready dependence 
informally statement statement failure complete reached wait notify occurs block reaching completing delaying execution indefinitely 
definition ready dependence fairly conservative discuss section refined notion safe lock 
definition ready dependence 
node ready dependent node written rd 
reachable cfg code enter monitor 
code enter monitor code exit monitor 
reachable code wait 
code wait code notify kg 
ready dependences follows nodes producer thread reachable wait prod wait nodes thread ready dependent condition nodes thread ready dependent enter monitor tally line prod enter tally condition wait buffer prod wait ready dependent notify buffer cons wakeup condition 
program define relation respect union relations defined respect union dd cd omega id sd rd 
pdg consists nodes cfg edges formed relation 
pdg approach slicing constructing program slice proceeds finding set nodes sc called slice set cfg reachable nodes definition slice set 
slicing criterion program pdg slice set sc respect defined follows sc fm mg addition nodes sc residual program contain nodes goto matching enter monitor exit monitor commands formed 
slice set sc briefly sketch residual program constructed details see extended version 
assignment synchronization statement sc appear residual program 
enter monitor matching exit monitor appears sc appear residual program vice versa exit monitor 
goto return jumps appear residual program 
sc node sc control dependent 
doesn matter execution follows true branch false branch 
case replace conditional jump point branches merge 
source statements omitted residual program 
process yields residual program contains trivial blocks blocks containing assignments goto sc jump 
unshared trivial blocks target jumps removed simple post processing phase 
example consider slicing program criterion prod cycle threads example tightly coupled slicing algorithm correctly identifies statements assignments total cons appear residual program 
general ready dependences wait statements causing large amount synchronization structure included slice 
intuitively impossible general tell conditions thread notified eventually occur 
expect monitors contain notify commands assignments irrelevant variables tally monitor example removed 
fact tally monitor removed refinements safe locks 
course monitors containing wait removed certain situations relevant nodes reachable 
theorem correctness slicing 
slicing criteria program residual program constructed wrt process outlined 
program slice initial configurations bisimilar 
identified common programming idioms ready dependence cause overly large slice produced 
describe relatively inexpensive static analyses program flow graph applied refine ready dependences consequently reduce size slice preserving correctness 
example contains common coding pattern program threads threads main loop regions loop body protected locks 
consider loop back edge thread force node loop body ready dependent enter monitor command body 
occurrence enter monitor lock ready dependent exit monitor commands program threads resultant dependencies force monitor related commands threads included slice occur monitor commands threads removed 
recall ready dependence implying enter monitor commands may cause monitor commands infinitely delayed 
locks threaded programs held indefinitely presence dependencies usually unnecessary assume jvm implementation guarantees scheduling fairness 
define safe lock held indefinitely 
attempt compute exact set safe locks focus easily identified subset safe locks 
lock safe paths matching enter monitor exit monitor commands contain wait free loops wait commands locks enter monitor exit monitor commands unsafe locks 
wait free loop loop path body include wait command 
lock safety computed depth marking program flow graph fragments rooted enter monitor commands results boolean lock function safe 
example locks satisfy safety conditions 
count lock eventually released monitor exits wait iteration inner loop loop header prod check 
easy see tally monitors producer consumer guaranteed release lock contains single assignment 
lock safety information refine definition stating ready dependencies arise conditions definition lock unsafe safe 
slicing example program criterion prod cycle removes tally monitors producer consumer prod cycle longer ready depends producer tally monitor depend statement tally monitor 
hand buffer monitors producer consumer included slice prod cycle ready dependent wait buffer command cause entire buffer synchronization structure threads included 
annotations indicate statements removed program slicing prod cycle safe lock refinement note post processing retarget goto prod release lock cons release lock jump prod cycle cons cycle respectively 
formally speaking individual thread actions correspond blocking enter monitor command unobservable 
way blocking influence observable behavior slice indefinite 
ready dependence unsafe locks preserves indefinite blocking slice 
safe locks finite duration blocking equivalent finite sequence unobservable moves blocked thread bisimilar system unobservable moves 
related static slicing concurrent programs cheng presents approach static dynamic slicing concurrent programs generalization pdg calls program dependence nets pdn 
pdn include edges cheng calls synchronization dependence communication dependence selection dependence 
synchronization dependence roughly corresponds synchronization dependence 
interprocess communication setting channel notion communication dependence analogous interference dependence 
selection dependence generalization control dependence non deterministic choice operators appearing language 
tip notes cheng state prove property slices computed algorithm :10.1.1.20.9646
zhao addresses static slicing java programs thread graphs 
able handle method calls incorporate notions divergence dependence call synchronization dependence synchronized methods handled synchronized statements ready dependencies dependencies associated component handled incorporate notion safe lock 
notion correctness defined 
krinke considers static slicing multi threaded programs shared variables focuses issues associated interference dependence :10.1.1.37.2306
notes considering interference dependence transitive done result slice viewed overly imprecise 
krinke uses notion witness sequence configurations extracted valid execution trace program filter situations transitive inference dependencies give imprecise results 
filtering worst case exponential behavior number transitive dependence edges 
approach precise slices intriguing unclear significant practical benefits outweigh extra conceptual overhead description slicing associated computational cost 
krinke language includes threads fork join operations explicit synchronization mechanism include notions analogous synchronization dependence ready dependence 
consider notion divergence dependence state prove property slices computed algorithm 
slicing tool model construction teitelbaum study static slicing promela model description language spin application model checking simulation protocol understanding extension modification cheng 
emphasize imprecise slices give useful reductions model checking 
formalize semantics concurrency promela slicing methods 
clarke tool slicing vhdl programs dependence graphs 
pdg approach data control dependence new notion called signal dependence similar synchronization dependence 
slicer integrates transformations properties appear hardware design languages 
briefly discuss relationships slicing model checking optimizations 
constructed prototype implementation processes subset jimple intermediate language ideas 
preliminary experiments real java systems appears refinements section crucial slicing away significant amounts synchronization activity :10.1.1.37.4678
example real java application consisted threads organized pipeline topology slicing system directed ltl formula specifies appropriate shutdown thread yielded residual program threads removed 
unrefined slicing algorithm take safe locks account able slice away small portion code threads coupled wait notify related ready dependences 
examples examined contain common idioms concurrent java systems experiments broad range concurrent software architectures needed confirm effectiveness approach 
scaling previous formal study modal logic directed slicing language features :10.1.1.43.3170
obviously needed treat features java addressed 
documentation jvm synchronization primitives taken inside java virtual machine 
form monitor jvm called wait notify monitor called signal continue monitor 
kind monitor thread currently owns monitor lock suspend inside monitor executing wait command 
thread executes wait releases monitor lock enters wait set 
thread stay suspended wait set time thread executes notify command inside monitor 
thread executes notify continues monitor releases monitor accord executing wait completing critical section executing exit monitor command 
notifying thread released monitor waiting thread reacquire monitor roughly speaking 
addition having wait set clear lock associated set blocked threads waiting acquire lock 
taken java virtual machine specification gives detail happening enter monitor exit monitor instructions 

thread lock 
certain constraints operations performed respect lock operation may occur thread number preceding unlock operations equals number preceding lock operations 
formally thread time permitted lay claim lock thread may acquire lock multiple times relinquish ownership matching number unlock operations performed 
unlock operation thread lock may occur number preceding unlock operations strictly number preceding lock operations 
formally thread permitted unlock lock 
clear discussion happen thread executes exit hold lock exception raised instruction interpreted op 
language situation arise assume enter monitor exit monitor come matching pairs 
taken java virtual machine specification gives details wait set associated count lock acquisitions particular threads 
object addition having associated lock associated wait set set threads 
object created wait set empty 
wait sets methods wait notify notifyall class object 
methods interact scheduling mechanism threads 
method wait invoked object current thread call locked object lock 
suppose thread fact performed lock operations matched unlock operations 
wait method adds current thread wait set object disables current thread thread scheduling purposes performs unlock operations relinquish lock 
thread lies dormant things happens thread invokes notify method object thread happens arbitrarily chosen notify 
thread invokes notifyall method object 
call wait method specified time interval specified amount real time elapsed 
thread removed wait set re enabled thread scheduling 
locks object may involve competing usual manner threads gained control lock performs gamma additional lock operations returns invocation wait method 
return wait method state object lock exactly wait method invoked 
notify method invoked object current thread locked object lock exception thrown 
wait set object empty arbitrarily chosen thread removed wait set re enabled thread scheduling 
course thread able proceed current thread relinquishes object lock 
notifyall method invoked object current thread locked object lock exception thrown 
thread wait set object removed wait set re enabled thread scheduling 
course threads able proceed current thread relinquishes object lock 

cheng 
slicing concurrent programs graph theoretical approach 
proceedings international workshop automated debugging number lncs pages 

clarke fujita rajan reps shankar teitelbaum 
program slicing design automation automatic technique speeding hardware design simulation testing verification 
technical report 

matthew dwyer john hatcliff 
slicing software model construction 
olivier danvy editor proceedings acm workshop partial evaluation program manipulation pepm january 
brics notes series ns 

matthew dwyer james corbett john hatcliff stefan sokolowski hongjun zheng 
slicing multi threaded java programs case study 
technical report kansas state university department computing information sciences march 

holzmann 
model checker spin 
ieee transactions software engineering may 

lynette tim teitelbaum 
slicing promela applications model checking simulation protocol understanding 
proceedings th international spin workshop 

jens krinke 
static slicing threaded programs 
proc 
acm sigplan workshop program analysis software tools engineering paste pages 

tim lindholm frank yellin 
java virtual machine specification 
addisonwesley 

mcmillan 
symbolic model checking 
kluwer academic publishers 

robin milner 
communication 
prentice hall 

muchnick 
advanced compiler design implementation 
morgan kaufmann publishers 

tip 
survey program slicing techniques 
journal programming languages 

mark weiser 
program slicing 
ieee transaction software engineering 

zhao 
slicing concurrent java programs 
proceedings seventh ieee international workshop program comprehension pages may 
