representing control study cps transformation olivier danvy kansas state university danvy cis ksu edu andrzej filinski carnegie mellon university andrzej filinski cs cmu edu february revised june investigates transformation terms continuation passing style cps 
show appropriate expansion fischer plotkin pass equational specification cps transform obtain static context free separation result terms essential administrative constructs 
interpreting syntax builders directly executable code obtain simple efficient pass transformation algorithm easily extended conditional expressions recursive definitions similar constructs 
new transformation algorithm leads simpler proof plotkin simulation indifference results 
show cps control operators similar general scheme call cc naturally accommodated new transformation algorithm 
demonstrate expressive power operators equivalent concise formulation efficient cps transformation algorithm 
relate fundamental ideas underlying derivation similar concepts program manipulation derive pass cps transformation terms outline promising areas research 
appear journal mathematical structures computer science 
technical report cis revised version department computing information sciences kansas state university 
department computing information sciences kansas state university manhattan kansas usa 
partly supported nsf ccr 
school computer science carnegie mellon university pittsburgh pennsylvania usa 
contents motivation classical cps transformation step second step third step completing transformation syntactic constructions complete transformation tail calls redexes reduction properties enriching cps transformation cps translation extended applied terms duplicating contexts currying vs tupling multi argument functions abstracting control reynolds escape operator shift reset control prompt cps translation terms shift reset translating control operations pass problem name clashes direct transformation cps related cps transformation primitive operators control operators partial evaluation issues call name continuations list figures fischer plotkin cps transformation terms pass cps transformation terms pass properly tail recursive cps transformation terms pass cps transformation extended applied terms direct style pass cps transformation terms plotkin cps transformation terms pass cps transformation terms pass properly tail recursive cps transformation terms pass properly tail recursive cps transformation terms continuations motivation usual presentation continuation passing style cps transformation concise simple tends yield unreasonably large residual terms containing lot administrative redexes 
redexes turn relatively harmless theoretical perspective require special twist called colon translation proving certain important properties transformation 
practice eliminating administrative redexes absolutely essential obtain transformed terms manageable size 
post reduction pass integrated independent simplifications optimization steps leads relatively complex cps transformers 
consider pass cps transformation focusing attention redexes introduced transformation explicitly reducing correspond redexes source term 
exploiting distinction show possible perform administrative reductions fly single pass constructing unreduced terms explicitly 
cps transformation permits simple definition generalized escape constructs scheme call cc 
operators perceived eliminate need explicit cps programs 
greater generality genuine cps needed express algorithm implement backtracking 
investigation cps transform leads naturally new control operators shift reset allow additional power general cps exploited direct style programs 
example show operators permit express efficient cps transformation algorithm derived concisely 
prerequisites assume basic familiarity cps calculus applicative order calculus forms core languages scheme standard ml 
convenience referring individual applications generally express explicit operator writing mn traditional simple juxtaposition purely syntactical variation change refinement semantics implied notation 
standard ml contrast scheme assume strict left right evaluation order application mn evaluated distinction matters potentially nonterminating escaping terms evaluation order scheme programs considered fixed similar construct 
note adopt convention simplify presentation advocate general style programming depends implicitly argument evaluation order 
occasionally reynolds notion serious trivial terms 
evaluating serious term loop term transformed cps evaluating trivial loop term need transformed 
mn fischer plotkin cps transformation terms recall main property cps term independence reduction order 
reducing cps term call name cbn call value cbv strategies yields evaluation steps 
overview rest organized follows 
section describes stepwise derivation pass cps transformer plotkin pass equational specification 
theorem states pass transformer computes result fij equivalent original fischer plotkin transformation 
section investigates reduction properties pass transformer 
theorem captures plotkin indifference simulation theorems original cps translation 
section extends pass transformer handle conditional expressions recursive definitions section introduces control operators cps transformation 
control operators presents pass cps transformer direct style 
section reviews related continuations partial evaluation section concludes 
section reproduces development section plotkin cps transformer terms 
classical cps transformation consider fischer plotkin equational specification transforming term cps displayed :10.1.1.15.8355
source terms represented double brackets fresh variable 
taken literally translation yields artificial administrative redexes second pass obtain result commonly recognized continuation passing style 
example translating results kf ky mn kx mn post reduction yields mx conversely overly enthusiastic post reducer perform reductions ones correspond actual reductions source term 
may useful right automatically considered part cps transformation proper 
particular excessive post reduction lead uncontrolled code duplication result untyped case nontermination simplification 
concentrate integrating second passes subject constraints pass translation introduce administrative redex pass translation perform reduction correspond reducing source term 
derivation simple 
analyze original equational specification identifying redexes get built independently actual source term 
redexes reduce translation time 
context dependent alter translation meaning preserving transformations construction redexes 
goal game stage cps transformation translation time part run time part 
precision conciseness text label lambdas applications specification mn development structured steps 
step observed result elementary transformation variable abstraction application abstraction 
question abstractions occur residual cps term post reduction 
answer cases body argument argument cases translation building redex simplified fi reduction 
case simplification take place immediately 
consequence abstractions post reducible contextdependent 
question get rid dependence 
answer introducing redex definitional translation abstractions 
new redex exhibit continuation body new redex safe sense preserving operational behavior cbn cbv abstraction 
expanding general meaning preserving functional type 
expanding safe 
expansion may felt step backwards optimizing translation reduction usually perceived actual optimization step 
fact illustrated development premature optimization translation abstractions contributes water translated terms 
repeat question question abstractions resulting elementary transformation occur residual term 
answer cases argument argument argument translation building fi redex 
redex simplified unconditionally 
second step abstractions reduced translation time enumerate possible arguments 
question syntactic constructs denoted answer cases second argument identifier second argument second argument situation irregular argument applications value denoted gets applied application reducible cases context dependent fashion 
question get rid dependence 
answer introducing redex translation abstractions 
redex exhibit application continuation 
km repeat question question syntactic constructs denoted answer cases second argument second argument second argument different occurrences ensured denote abstractions 
third step question occur 
answer cases argument argument second argument cases translation building redex simplified fi reduction 
case simplification take place immediately 
consequence application post reducible context dependent case occur function position application 
question get rid dependence 
answer introducing redex definitional translation applications 
redex exhibit sending result application continuation 
mn repeat question question occur 
answer cases argument argument argument consequence construction translation building abstraction ensured occur function position application classify abstractions applications unconditionally 
summarize abstractions applications reduced unconditionally part translation 
exist translation time refer static 
km mn completing transformation syntactic constructions list possible arguments second arguments identifier identifier may bound ffl occurs argument bound simplification possible 
bound fi reduction possible correspond reduction original term want perform 
classified irreducible syntax syntax syntax km mn pass cps transformation terms ffl occurs second argument irreducible 
ffl occurs second argument reduced argument identifier consequence argument irreducible irreducible 
consequence second argument irreducible 
summarize underline abstractions applications built unconditionally part translation 
part transformed term refer dynamic 
km mn simple inspection level specification shows application possibly dynamic fi redex redex resulting cps term happens bound dynamic happens abstraction source term contains fi redex point 
want reduce dynamic fi redex correspond reducing fi redex source term job cps transformation 
complete transformation conclude shows final version transformer labels expository purposes 
static dynamic annotations read level specification la nielson nielson 
operationally correspond functional abstractions applications translation program underlined occurrences represent syntax constructors 
transforming term cps amounts representing contexts terms hole abstractions 
empty context top level represented identity function 
arbitrary dynamic context represented continuation result transforming term cps empty context result transforming term cps dynamic context km noticed initial contexts represented translation time abstractions dictated answer question 
rest section refer translation time abstractions static continuations 
instrumented new translation yields terms extraneous redexes pass 
static dynamic distinction aimed defining administrative fi redexes 
administrative fi redexes bound translation time occur residual terms 
development summarized theorem 
theorem equational specification km computes result fij equiva lent original fischer plotkin transformation 
proof started fischer plotkin specification altered meaning preserving way introducing redexes 
obtained staged specification static dynamic constructs distinct context independent 
nielson nielson terminology level specification typed reduce away static fi redexes 
specification compositional simple typing argument suffices show defined source terms static reductions fact terminate 
static lambdas applications matter purpose termination dynamic lambdas applications just uninterpreted constructors 
static part transformation simply typed single base type syntax type syntax syntax static variables just type syntax 
particular initial continuation strongly normalizable term type syntax 
interpreted functional program transformation terminates essentially linear time static data duplicated 
redexes original term reduced abstraction source term translated dynamic syntax constructor corresponding cps term reduced away 
observation term cps counterpart related follows ffl variable translated 
ffl abstraction translated abstractions application 
ffl application translated applications abstraction 
observation provides simple correspondence size term cps counterpart 
new abstractions introduced translation abstracted variable occurs exactly body relationship extends directly number reduction steps performed evaluation terms section 
syntax syntax syntax mn syntax syntax kx mn pass properly tail recursive cps transformation terms tail calls redexes introducing redexes crucial avoid building fi redexes residual terms simple case yields extra redexes transformed program 
surprisingly arises tail calls illustrated ka straightforward possibilities come mind 
leave redexes useful term subjected transformation observation tail call optimizations change number reduction steps 
detect newly constructed abstraction redex simplify time 
instrument translation inherited attribute identifying tail call contexts eliminating dynamic tests term structure entirely 
equivalently duplicate rules account tail call contexts way reminiscent clinger double induction proof scheme compiler 
rationale auxiliary translation static continuation form km avoids building redex transformation applications term properly tail recursive 
result transforming term cps empty context result transforming term cps dynamic context simply construction instrumented new translation yields terms extraneous redexes course fi redexes completely syntax directed pass 
difference transformation elimination trivial redexes new translation preserves statement theorem 
reduction properties formulate results new cps translation analogous ones original specification 
eliminated administrative redexes proofs considerably simpler unoptimized translation 
may worth quickly going administrative redexes raise problems original translation 
ideally implication hold unfortunately administrative redexes get way result 
really happens sequence administrative reductions corresponding original redex 
reason expect reduces fact expand back recreate administrative redexes 
prove implication holds modulo administrative reductions 
formalized called colon translation developed plotkin 
term value defines syntactically term proves equal series administrative reductions performed corresponding term 
proves reduction sequence non functional value take get crucial note colon translation removes redexes expose real reduction 
particular removes redexes abstractions 
acts proof technique code optimization pass 
new translation hand get direct correspondence reduction steps original translated term 
possible modify colon translation perform administrative reductions translation time :10.1.1.26.6893
practical translation full language scheme approach awkward combinatorial explosion arising translation time distinctions values non values source terms 
observe elementary properties level translation 
simplify presentation generally treat ff equivalent dynamic terms equal 
definition value variable abstraction define psi differs plotkin psi eliminate administrative redexes inside transformed abstractions 
immediate psi value 
lemma value value application simple properties hold term term type syntax static continuation term type syntax syntax psi psi proof immediate cases 
write substitution 
need show static parts translation interfere substitution 
definition say variable occurs free static continuation occurs free called schematic terms variable occurring free informally ensures preserves syntactic structure argument capture free variables occurring 
easily sees defined static abstraction static application syntax constructors dynamic abstractions introducing new variables schematic 
formalize substitution arbitrary values identifiers commutes lemma term value variable schematic continuation term 
psi psi new variable renaming necessary take care case occurs free 
proof induction cases straightforward psi psi psi psi psi psi psi psi psi mn mn psi psi mn psi psi psi cases second equation analogous 
recall formal definition reduction strategies definition step value reduction defined follows mn value similarly step name reduction mn xn xn write reduction relations refer transitive reflexive transitive closure respectively 
lemma terms schematic continuation 
fact reductions 
proof induction derivation ffl base case 
mn psi psi psi cases arise value 
lemma term equal required 
reductions correspond transferring argument value return continuation uncurried cps translation section reduction needed 
value 
lemma gives psi psi additional reduction case corresponds application return continuation value just computed 
ffl inductive case mn mn mn ffl inductive case mn psi psi mn restrict evaluation closed terms term value contains redex 
results extend easily open terms free variables treated uninterpreted constants associated ffi rules 
case third possibility evaluation may halt non value term xy progress possible 
plotkin define definition necessarily open term said stuck strategy value reducible reduction rules strategy 
quick inspection definition shows terms form value term xv call value xv xs call name note term stuck cbn stuck cbv 
lemma term static continuation 
stuck cbv stuck strategy 
proof structural induction stuck term base case xv xv mn psi inner application entire term stuck 
inductive case sn mn stuck induction hypothesis 
inductive case mn psi stuck induction hypothesis 
statically typed setting problem occur typing rules ensure non functional constant applied argument 
argument extends easily languages possibility runtime errors division zero 
simple refinement proof shows cps translation distinguish properly different error conditions evaluation original program causes specific error evaluation cps transformed program 
state main result analogous plotkin indifference simulation theorems original cps translation theorem term necessarily closed value 
psi times steps 
particular free variable original term evaluates psi conversely evaluate value call value strategy strategy evaluate 
proof part follows immediately lemma applied step reduction 
conversely infinite value reduction sequence starting gives rise infinite strategy independent reduction sequence starting 
original reduction sequence stops cbv stuck term corresponding cps reduction sequence ends term stuck strategy lemma 
enriching cps transformation section investigates translation terms usual applicative order functional languages problem currying functions vs tupling arguments 
cps translation extended applied terms turn translating terms applied constants pure primitive operations extended conditional expressions letrec expressions restricting values bound recursively functions 
applied extended terms come straight scheme standard ml 
line section displays pass equational specification cps transformation 
primitive operations treated differently ordinary applications simplify equations 
primitive operator passed functional value written explicit abstraction done syntax analysis time 
result transforming term cps empty context result transforming dynamic context km instrumented new translation yields terms extraneous redexes tail calls handled section pass 
obtained equations analyzing binding times valuation functions continuation semantics calculus line section 
simulation indifference properties cps transformed terms generalize translation exception primitive operations transformed continuation passing versions longer direct correspondence ffi reductions original cps transformed term 
optimized translation primitives completely pure operations see section 
syntax syntax syntax km mn letrec letrec kn pass cps transformation extended applied terms non trivial symbolic reductions calculus face problem name clashes 
occur context moved inside scope binding construct illustrated example renamed introduced inadvertently captured free variable static continuation variables declared abstractions need renamed contexts moved inside scope abstraction 
note subterm translation expression value notably abstraction corresponding variable transformed term bound opposed bound psi 
translation compatible restricted variant ml style polymorphism generalization applied values 
duplicating contexts cps translation duplicates contexts conditional expression increases size residual terms pointed steele 
example translating direct style expression yields voluminous 
kv kv kv kv bigger term compile correspondingly object code produce 
reason compiler writers usually refrain duplicating contexts introducing dynamic expression share static continuation branches conditional km kn inserted appropriate redexes line section 
modification restores linearity property static part translation bound variables static abstractions bodies maintains linear relationship sizes original transformed terms 
expression introduces explicit name context conditional branch de facto occurs dynamic context just body translated abstractions 
section special tail call translation contexts example expression translated room left simplification case expressions 
revealed simple inspection equations translating expressions headers application conditional expression produce identity expressions 
redundant expressions prevented translation time currying vs tupling practical applications cps transformation algorithm described need slight refinement considered section 
call name language correspondence curried forms multi argument functions call value property lost may non equivalent ways currying function 
example curried form argument function written terms qualify curried forms sense pair values behave differently applied single argument fails terminate 
cps transform clearly needs accommodate curried functions programs simple curried functions appear unnecessarily complex 
example curried addition translated somewhat awkward natural problem higher order type clear outermost function serious trivial examples 
solved extending source language product type new trivial function space restoring equivalence trivially curried uncurried forms functions 
result translating function type oe cps answer type expressed curried cps oe uncurried cps oe theta functions resulting curried cps transform easily checked trivial immediately return closure clear type 
want treat transformation result call value term uncurried form translation precise 
multi argument functions languages standard ml explicit product type expressing functions arguments essentially equations directly 
multiple variables abstractions treated syntactic sugar projections single argument tuple construction new primitive operator 
scheme language argument tuple autonomous entity closely tied functional abstraction application 
need adjust cps equations constructs slightly want uncurried source source transformation kx precisely argument list translated follows full application pi pi represents list concatenation 
scheme style connection lists argument tuples closer put continuation argument argument list 
allow translate procedures lambda cdr lambda directly lambda cdr lambda respectively 
readability appears suffer continuation argument large followed application 
making continuations occur compile functional programs program transformation 
simple write pass cps transformer continuations precede values just swap values continuations specifications displayed figures 
abstracting control far investigating perform cps transformation 
section explores properties extensions transformation function 
reynolds escape operator calculus term obtainable result cps transformation 
unused terms correspond control operators source language 
example operator escape scheme call cc defined equation escape control operator escape captures current continuation provides representation current continuation function source program 
applying function value amounts abandoning current context computation passing value captured continuation 
example transforming term escape cps empty context unfolding yields cx observed equation escape duplicates code current continuation 
lines section prevented equation escape ka km rest section shall concerns duplications contexts 
shift reset note escaping constructs result translation ordinary cps form nested function applications 
suggests considerable amount expressive power cps formalism reflecting control structures translations general terms 
particular define operators shift reset conceptually serving composition identity continuation functions shift hmi shift abstracts current context ordinary composable procedure contrast exceptional non composable procedures yielded escape reset delimits scope context 
shift differs escape implicitly duplicating current continuation felleisen operator introduced behavior duplicating continuations 
example shift fuller control contexts afforded operators express functional style control structures required rewrite program extensively introduce side effects 
example consider functional representation applicative nondeterministic sense backtracking programming embodied programming language icon 
define basic nondeterministic choice procedure flip shift tt cff invoked flip return twice possible truth value 
specified final answer nondeterministic program true return values causes context evaluate true 
canonical example boolean expression free variables determine satisfiable exists assignment truth values variables making expression true simply evaluate natural direct style program flip flip approach nondeterministic programming easily handles irregular search structures tests may depend outcome previous guesses simulating nondeterministic finite automaton 
control prompt shift reset similar felleisen operators control prompt significant semantical difference shift reset control prompt context abstracted shift determined statically static program text control captures context nearest dynamically enclosing prompt 
difference shift control probably best displayed characteristic equations shift xi mi control mi bound procedure abstracts control context capture shift semantics determined context defined 
hand control semantics control operator occurring capture context point applied particular capture part 
case simple procedure control effects effects operators coincide 
shift reset approach viewing program computing function expressed cps representing control function continuation 
contrast prompt control introduced independently cps admit simple static interpretation 
denotational descriptions introduce algebra control lead representation continuations prompt delimited sequences activation frames composition concatenation sequences 
earlier prompts specified operational description terms textual reductions 
general static vs dynamic interpretations lead different behaviors 
framework reset naturally direct style counterpart initializing continuation cps term identity function 
reset equivalent prompt terms control general cps counterpart 
cps translation terms shift reset note definitions shift reset yield cps terms continuations may applied non values 
defining terms lose important property enforcing strict call value evaluation ensured proper cps 
restore property translating defining pure calculus terms cps yielding term metacontinuation passing style 
treated ordinary functional parameter proper evaluation order ensured new continuation 
example leaving notation aside readability term occurring empty context shift gets cps transformed noticed term cps call tail call nested call definition second cps transformation gives proper cps term continuation parameter cc kx cc iterating construction leads extended cps hierarchy control operators 
real forte cps approach advanced control structures obtain natural notion levels control allowing express collections paths nondeterministic subcomputation defined section 
translating control operations pass binding time analysis equations section section express cps transformation control operations level terms escape shift hmi cps transformation introduces expressions 
unfolded substituting control abstractions identifiers translated terms specified escape shift substitutions introduce residual fi redexes control abstractions applied scope declaration 
example shift cx ka preferable cx keep fi reduction translation time risk duplicating contexts shift distinguish identifiers declared abstraction identifiers declared control abstraction 
unfortunately decision transformation way introducing class primitive operators cf 
section 
adopt simple solution syntax analysis time occurrences identifiers declared control abstraction guaranteed occur application position single tagging application throw standard ml new jersey 
escape shift throw cm avoid dealing substitutions translated terms introduce translation time environment mapping identifiers translation time abstraction declared control abstraction 
corresponding version cps transformer completed translation time environment 
equations unchanged addition environment ae passively transmitted 
env var syntax syntax syntax syntax env syntax syntax syntax escape ae 
ae shift ae 
ae throw ae ae aec note terms translation static 
administrative reductions performed translation time fi redexes built applications control abstractions 
problem name clashes problem remain name clashes 
occur control operator moves part context inside scope binding construct illustrated example escape throw ae simplest solution probably systematically rename bound variables 
direct transformation cps view cps transformation section applicative order program expressing transformation algorithm 
program expressed cps style 
lead believe program expressed concisely traditional control operator call cc 
unfortunately quite possible program cps 
notably translation mn continuation application subterm syntax constructor delta delta delta 
conversely continuation applied potentially non trivial term 
situations arise translation conventional direct style term calculus escape 
shift reset express exactly behavior 
rewrite transformation equations implicit continuations 
result displayed 
result transforming term cps empty context similarly result transforming arbitrary context cps counterpart applicative order program expressing transformation algorithm equations section set equations section verified easily coincide original translator 
transformers yield textually output input internal organization differs 
shift ca shift shift letrec shift letrec escape shift cv shift shift cv hmi direct style pass cps transformation terms set equations seen meta circular compiler language new control operators purely functional subset 
alternatively omitting equations shift reset translates terms scheme language calculus escape standard cps 
transformation practical interest compiling scheme standard ml programs constitutes significant example shift reset pure cps translation expressed naturally new control operators 
meta circular definitions need bootstrap 
interpreter language shift reset execute translator obtaining cps transformer written pure calculus 
hand get interpretive semantics extended language translating trivial defining shift terms shift extended cps 
correspondence helps ensure consistency methods language definition 
related cps transformation works independently employed cps translations similar 
appel cps transformer standard ml new jersey compiler 
second wand combinator compilation technique 
motivate transformer section extend control operators normal order sections revealed source code sml nj compiler cps transformer operates pass keeping translation time continuation redexes identical section 
contrast goal aim exact continuation passing counterparts source programs simplify possible simplifications correspond source reductions 
particular care taken avoid building extraneous redexes pointed section 
compiler relies powerful blind simplifier cps terms processes redexes corresponds source reductions 
interesting measure precise cps transformer relieves simplifier 
similarly devising particular representation run time procedures application wand compiles programs cps transformer redexes section motivating 
today sabry felleisen investigating cps transformation pass lawall author investigating inverse direct style transformation :10.1.1.22.7509
primitive operators cps compilers program analyzers continuation passing forms primitive operators 
practical justification radical cps transform completely clear 
particular oft quoted advantage having explicit names subexpressions realized equally expressions 
clearly side effecting operators need tied explicit conversion continuation passing variants 
expressing trivial computations tuple construction destruction arithmetic cps introduces unnecessary sequentialization obscures fact computations rearranged eliminated duplicated affecting meaning program 
possible problem concerns primitive operators division signal error conditions pure 
clearly translation preserve exception raising behavior original program compromise order evaluation independence cps terms 
hand going full cps functional operators may overkill reasons outlined 
possible factor original operator aspects control behavior process computation possibly error raising expressed cps pure freely function computed case get best worlds 
control operators reynolds escape call cc scheme control operators nicely introduced cps transformation 
cps appears constrain expressive power felleisen successively proposed new control operators compose continuations limit extent :10.1.1.34.4440
shown sitaram felleisen inclusion control delimiters necessary obtain fully models control cps models escape 
motivation shift reset somewhat different devising new theories new models new representations control set explore cps thoroughly 
particular shift reset introduced representing composition identity continuation functions respectively proper cps form restored iterating cps transformation 
partial evaluation partial evaluation accurately program specialization heavy binding time information process static dynamic semantics source programs 
bondorf author emphasize issues code duplication termination properties technique enumerating finitary constructs sections 
central shivers higher order flow analysis 
concepts pervasive derivation pass cps transformer 
particular notion level calculus advocated nielson nielson tml proves useful develop express new cps transformations distinguish properly translation time run time constructs 
respect partial evaluation development illustrates connection cps transformer calculus interpreter expressed cps 
level version 
derivation illustrates new trend partial evaluation cps improve binding time properties source programs leading better specialization 
going automate process 
issues proven constructively transforming terms cps expressed pass moving administrative redexes translation time context free way 
actual transformation algorithm independently discovered times slightly different forms believe systematic derivation analysis correctness properties 
translation easily extended usual constructs applicative order functional languages account control operators 
control operators shift reset derived naturally cps formalism translation formulated concisely directly 
role continuations programming language design implementation long dominated pragmatic concerns 
years subject seen renewed theoretical interest especially concepts methods mathematical logic category theory :10.1.1.26.6893:10.1.1.43.8416
believe investigation advanced control structures cps transform able pick integrate developments directly free standing approach derived intuitively desirable operational behavior 
fact developments support conviction 
close relationship computational monads generalized cps suggested abstracting control properly formalized wadler :10.1.1.100.9674
effectively implies cps control operators shift reset uniformly express rich class computational behaviors including partiality nondeterminism state 
natural take indication theoretical practical significance functional representations control grow stronger years come 
grateful editor referees 
due dave schmidt patience chet murthy enthusiasm 
andrew appel 
compiling continuations 
cambridge university press 
anders bondorf 
automatic higher order recursive equations 
science computer programming 
anders bondorf olivier danvy 
automatic recursive equations global variables data types 
science computer programming 
william clinger 
scheme compiler exercise denotational semantics 
conference record acm symposium lisp functional programming pages austin texas august 
william clinger jonathan rees editors 
revised report algorithmic language scheme 
lisp pointers iv july september 
charles consel olivier danvy 
static dynamic semantics processing 
popl pages 
charles consel olivier danvy 
better support static data flow 
proceedings fifth acm conference functional programming computer architecture number lecture notes computer science pages cambridge massachusetts august 
olivier danvy 
programming tighter control 
special issue journal putting scheme july 
olivier danvy 
back direct style 
bernd krieg bruckner editor proceedings fourth european symposium programming number lecture notes computer science pages rennes france february 
olivier danvy andrzej filinski 
abstracting control 
lfp pages 
olivier danvy julia lawall 
back direct style ii class continuations 
lfp 
olivier danvy carolyn talcott editors 
proceedings acm sigplan workshop continuations san francisco california june 
technical report stan cs stanford university 
bruce duba robert harper david macqueen 
typing class continuations ml 
popl pages 
matthias felleisen 
theory practice class prompts 
proceedings fifteenth annual acm symposium principles programming languages pages san diego california january 
matthias felleisen daniel friedman bruce duba john merrill :10.1.1.34.4440
continuations 
technical report computer science department indiana university bloomington indiana february 
matthias felleisen daniel friedman eugene kohlbecker bruce duba 
reasoning continuations 
proceedings symposium logic computer science pages cambridge massachusetts june 
ieee 
matthias felleisen daniel friedman eugene kohlbecker bruce duba 
syntactic theory sequential control 
theoretical computer science 
matthias felleisen mitchell wand daniel friedman bruce duba 
continuations mathematical semantics handling full functional jumps 
proceedings acm conference lisp functional programming pages snowbird utah july 
andrzej filinski 
linear continuations 
popl pages 
michael fischer 
lambda calculus schemata 
proceedings acm conference proving assertions programs pages 
sigplan notices vol 
sigact news january 
pascal fradet daniel le 
compilation functional languages program transformation 
acm transactions programming languages systems 
timothy griffin :10.1.1.26.6893
formulae types notion control 
proceedings seventeenth annual acm symposium principles programming languages pages san francisco california january 
acm press 
ralph griswold griswold 
icon programming language 
prentice hall 
bob harper mark lillibridge 
polymorphic type assignment cps conversion 
danvy talcott 
technical report stanford university 
neil jones peter sestoft harald sndergaard 
mix self applicable partial evaluator experiments compiler generation 
lisp symbolic computation 
proceedings acm conference lisp functional programming nice france june 
proceedings acm conference lisp functional programming san francisco california june 
chris mellish steve hardy 
integrating prolog environment 
john campbell editor implementations prolog pages 
ellis horwood 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
eugenio moggi 
computational lambda calculus monads 
proceedings fourth annual symposium logic computer science pages pacific grove california june 
ieee 
murthy 
extracting constructive content classical proofs 
phd thesis department computer science cornell university 
murthy 
control operators hierarchies pseudo classical type systems 
danvy talcott 
technical report stanford university 
flemming nielson 
level semantics interpretation 
theoretical computer science 
flemming nielson hanne riis nielson 
level semantics code generation 
theoretical computer science january 
gordon plotkin 
call name call value calculus 
theoretical computer science 
proceedings eighteenth annual acm symposium principles programming languages orlando florida january 
acm press 
proceedings nineteenth annual acm symposium principles programming languages albuquerque new mexico january 
acm press 
john reynolds 
definitional interpreters higher order programming languages 
proceedings th acm national conference pages boston 
jon riecke 
function continue 
master thesis department electrical engineering computer science massachusetts institute technology cambridge massachusetts january 
amr sabry matthias felleisen 
reasoning programs continuation passing style 
lfp 
olin shivers 
semantics scheme control flow analysis 
paul hudak neil jones editors symposium partial evaluation semantics program manipulation sigplan notices vol 
pages new haven connecticut june 
acm acm press 
dorai sitaram matthias felleisen 
reasoning continuations ii full abstraction models control 
lfp pages 
guy steele jr rabbit compiler scheme 
technical report ai tr artificial intelligence laboratory massachusetts institute technology cambridge massachusetts may 
philip wadler 
essence functional programming 
popl pages 
mitchell wand 
correctness procedure representations higher order assembly language 
steve brookes michael main austin melton michael mislove david schmidt editors mathematical foundations programming semantics volume lecture notes computer science pittsburgh pennsylvania march 
th international conference 
plotkin cps transformation terms syntax syntax syntax km kn pass cps transformation terms call name consider plotkin equational specification transforming term cps displayed 
want apply method section stage cps transformation 
taken literally translation yields artificial redexes post reduced second pass size explosion drastic call value 
example translating yields mx post reduction yields mx cps counterpart term equally evaluated call name call byvalue 
simple consequence continuation implemented strict function altering meaning original term 
subject original specification treatment section get cps transformer 
answer resulting transformation shows immediate success 
original specification transformed build fi redex 
result transforming term cps empty context specification viewed applicative order program re expressed shift reset 
syntax syntax syntax syntax pass properly tail recursive cps transformation terms new cps translation suffers deficiency observation 
observation term cps counterpart related follows ffl variable translated application abstraction 
ffl abstraction translated abstractions application 
ffl application translated applications abstractions 
points hold plotkin specification point reveals new translation produces redexes 
new specification produces redexes nearly hard get rid fi redexes produced original translation outlined 
redexes constructed tail contexts identifiers occurring abstraction bodies arguments functions corresponds algol situation suspending suspension 
section eliminated translation time duplicating rules cf 

rationale auxiliary translation special case km avoiding construction extraneous redexes 
result transforming term cps empty context result transforming term cps dynamic context construction instrumented new translation yields terms fi redexes pass 
syntax syntax syntax syntax syntax xk mk syntax mk pass properly tail recursive cps transformation terms continuations continuations making continuations occur introduces new opportunity extraneous redexes residual cps terms 
result transforming term occur function position argument static lambda applied static continuation function position argument static lambda applied dynamic continuation function position 
cases handled suitable series tests intermediate result duplicating rules 
notice terms correspond case terms correspond case terms correspond case 
suggests clinger style compiler terms proven triple induction hypothesis 
usual result transforming term cps empty context result transforming term cps dynamic context better final translation yields terms fi redexes new redexes pass 

