visual language syntax semantics complex reactive systems lewis chau chan department computer science hong kong university science technology clear water bay hong kong 
describe syntax semantics visual programming language behavioral specification complex reactive systems 
bnf grammar specifying syntax textual programming languages demonstrate visual language syntax defined rewrite rule language 
rules act visual program generators visual program parsers 
time visual program mapped rewrite rule language execution existing logic program interpreters 
words syntax operational semantics visual language described declarative semantics logic program 
executability visual program nice tool modeling complex reactive systems 

behavior specification reactive systems provides description systems intended behavior 
state space specification model powerful describing reactive systems 
reactive systems highly concurrent distributed fall quite naturally multiple levels certain details hierarchical relationships states usually display unpredictable behavior unanticipated circumstances 
order practical modeling real complex systems specification modular hierarchical 
addition power specifying concurrency independent subsystems extremely important 
investigating formal methods behavior specification reactive systems presents real challenges 
internal state system time supported direct allocation dag 
put important reaction 
clarity intuition systems greatly enhanced adoption visual languages 
addition executable language rapidly prototyped 
languages ought possible move easily initial stages identifying requirements specification prototyping design form basis modifications maintenance stages 
formally define syntax semantics visual programming language order term rewriting system 
graphical syntax visual language important subset known graphical formalism statecharts 
bnf grammar specifying syntax textual programming languages visual language syntax defined set functional logic grammar rules order term rewriting system 
logic grammars set functional logic grammar rules generate parse visual program specify complex reactive systems 
semantically operational behavior visual program defined specialized non deterministic nonterminating rewrite strategy proven sound complete 
set grammar rules compiled logic program directly executed existing prolog interpreters 
result syntax semantics visual programming language defined unified framework term rewriting system embedded logic programming 
executability visual language nice tool modeling complex reactive systems 
introductory example rewrite rule language consider rules defining lists concatenated 
xj xj 
prolog rules appending lists concise description provides necessary 
rules essentially equivalent usual prolog definition append 
append xj xj append 
grammar rules form lhs rhs lhs rhs order terms restrictions 
refer formal definition 
grammatical formalism specify syntax semantics visual language 
section presents visual language reactive systems hierarchical finite state machine 
section defines syntax semantics visual language order rewrite rule language 
section sketches implementation section presents case study 
compare 

hierarchical finite state machine reactive systems represented hierarchically physical properties 
states classified basic states 
informally superstate virtual state includes states common properties 
states included superstate basic states 
hierarchical relationship states represented tree structure node tree denotes state children node denote immediate substates 
words leaves tree denote basic states non leaf nodes tree denote 
call state 
complex reactive systems consist set sequential processes running simultaneously 
sequential process fact regarded simpler reactive system concurrency sequential processes composes complex reactive system 
sequential processes orthogonal components active current state multiple state transitions take place parallel 
set concurrent components abstracted making child parent state 
sake simplicity issues event communication various subsystems addressed 
operationally state reached default substate active 
reached children active 
words multiple transitions occur simultaneously concurrent components resulting state changes composite state cross product states composite state 
formally define concurrency model section 
consider example vending machine vm test agent ta shown 
system switched indicated event start vm ta activated 
ta possesses money test purposes 
receives testing commands operator emits testing events coin choice abort vm 
omit notation specify event communication vm ta 
receiving events vm carries internal transition accordingly 
response generated vm detected ta internal input event 
ta check vm acts correctly report operator 
system switched indicated event vending machine test agent deactivated system terminates 
service ready start vm ta coin coin abort choice response cmd coin cmd abort cmd choice vending machine test agent definitions originating statecharts simplified extended 
aim keeping essence statecharts time providing rigorous simple model specifying complex reactive systems 
definition finite set elements states organized tree structure function fl defined set child function fl ae leave node child node sg definition descendent functions fl fl defined tree structure set 
fl fxg fl fl gamma fl 
fl fl 
fl fl fsg 
definition finite set elements states organized tree structure 
function ffi defined set parent function ffi root node parent node sg definition sibling states ffi ffi definition finite set elements child function fl defined elements partitioned disjoint subsets basic super basic fl super fl basic super sets basic state superstate respectively 
definition function type fand org assigns superstate type state state 
fl type fl exclusive decomposition system state children 
definition default entrance function ae identifies state immediate descendants ae fl default state 
transition enters state causes ae entered 
definition definition orthogonal states adapted 
ffl set states common ancestor denoted lca defined state 
fl 

fl follows fl 
ffl states orthogonal fl fl lca fx yg state 
ffl set states called orthogonal set ffl orthogonal set called maximally orthogonal state gamma fsg orthogonal 
maximally orthogonal set represents configuration system 
definition state transition rule written sibling states lca fs state 
event current state changes fl 
definition hierarchical fsm tuple ev ffl finite set states organized tree structure definitions ae fl ffi 
ffl ev finite set events 
ffl initial state 
ffl finite set state transition rules 
example tree structure vending machine testing agent shown 
vm ta ready service tree structure vending machine test agent example maximally orthogonal sets ae vm ready ae ta 
visual language syntax semantics basic concern programming language design syntax semantics 
section propose formal rewrite rule language define syntax semantics visual language restriction relaxed 
described previous section 
rewrite rule language directly executed existing prolog interpreters 
short syntax semantics visual language described logic program 
syntax define set grammar rules describe syntax visual language 
grammar rules act visual program generators visual program acceptors 
acceptance generation duality familiar users definite clause grammar ability employ grammars acceptors generators applications 
init state 
state state 
state state 
state state 
state state def state def state 
state state def state state tran set 
def state default state 
def state def state 
def state def state def state 
state state 
state state state 
tran set transition 
tran set transition tran set 
transition state arrow state 
state generates basic state state state 
state generates children children treated default states 
words children active simultaneously 
state generates children children specified default 
tran set recursively generates transitions source state destination state 
vending machine test agent example defined resulting visual program parse trees shown 
semantics semantics visual language defined rewrite rule language 
transition hierarchical concurrency structure simple def state default state init state state def state default state state def state state tran set state state state def state default def state state state tran set state default state state state state state state state vm ta ready service parse tree vending machine test agent state arrow state transition tran set tran set transition tran set tran set state arrow state state arrow state transition state arrow state transition ready coin service service abort ready service choice ready service coin service parse tree transition set natural mapping set rewrite rules 
set rewrite rules interpreted logic program simulates behavior hierarchical state machine 
mapping shown 
hierarchical structure specifies hierarchical relationship state immediate substates 
default entrance specifies default substate enter state reached 
concurrency structure specifies orthogonal set states active state reached 
notice concurrency interleaving 
state reached children active children performs state transition 
interleaving various concurrent components produces possible configuration complex system 
supplementary rules needed state 
state parent 
concurrent select transit 
select hjt 
select hjt select 
terminal state cng symbol initial state state state 
terminated 
state parent state 
parent state 
sm transition sm state 
parent sm state 
concurrent sm 
concurrent state 
init state concurrency state hierarchical structure state hierarchical specification model transit es 

implementation propose software architecture shown previous specification model called finite state machine 
front performs syntax directed translation visual program back simulates operational behavior hierarchical state machine 
executability visual programming environment supports modeling complex systems 

graphical specification language graphical user interface gui basically graphical editor 
graphical specification hierarchical state machine originated statecharts complex reactive systems 
captures semantic representations hierarchy concurrency important characteristics complex reactive systems 

visual compiler visual compiler basically defined set visual grammar rules 
visual grammar introduced powerful formalism specifying syntax semantics visual languages general graphical specification language particular 
visual grammar order term rewriting system 
specification graphical gui front back events trace visual compiler visual program storage specification specification visual grammar rewrite rule language interpreter rewrite rule language software architecture complex reactive systems takes hierarchical state machine input produces target language order term rewrite rule language semantic interpretation 

interpreter target language visual compiler input interpreter order rewrite rule language 
semantics rewrite rule language defined specialized non deterministic non terminating lazy rewrite strategy proven sound complete 
key concept implementing interpreter build meta interpreter top prolog prolog interprets rewrite rule language simulates lazy rewriting 
words operational semantics visual language defined declarative semantics rewrite rule language logic program 

interface front back interfacing front back done demand driven fashion 
front consumes terminal symbol processing sending request back 
back produces terminal symbol grammatical generation passes front 
process performed demand driven fashion shown 
case study binary stopwatch adopted case study specifying functions binary stopwatch 
basic structure binary stopwatch shown 
display head return head tail head tail term loop loop term term init tail simplify term simplify term interface front back interfacing front backend high medium low time time stopwatch binary stopwatch basic structure binary stopwatch design specification top approach 
high level point view stopwatch consists main states state 
state default state 
see 
stopwatch high level structure stopwatch specification simple follows stopwatch default state state stopwatch high level view stopwatch state arrow state state arrow state want include details define details state 
state contains concurrent components high medium low intended represent bits binary counter 
structure view shown 
stopwatch high medium low top level structure tree stopwatch high medium low concurrency state stopwatch note concurrency status shown specified follows default state high default state medium default state low final illustration define complete specification binary stopwatch shown 
specification simple default state stopwatch default state default high default state state state arrow cm state state arrow cm state default medium default state state state arrow cl state state arrow cl state default low default state state state arrow time state state arrow time state state arrow state state arrow state state arrow state stopwatch state stopwatch arrow state visual program generated accepted visual compiler mapped rewrite rule language see execution 

related known example behavior specification finite state automata statecharts 
statecharts specify finite state machine graphically advantage hierarchical relationships terms operations set states avoiding combinatorial explosion number states independently specifying orthogonal components operands 
semantics statecharts studied 
visual formalisms similar statecharts argos 
esterel lustre signal lotos estelle programming languages formal description reactive systems text 
users learn syntax semantics languages write programs 
causes trouble non technical users languages user friendly 
aim describing multi dimensional structures addressed variety syntactic formalisms 
helm marriott described declarative constraint visual languages 
visual specifications compiled constraint logic programs execution 
constraint visual grammatical formalisms include relation grammars visual grammars wittenburg 
previous approaches behavioral specification reactive systems statecharts estelle rest finite state automata extension 
computational model rigorous formal semantics language difficult express 
example syntax statecharts defined basic sets elements states transitions primitive events primitive conditions variables 
semantics sequence time instants corresponding sampling rate system description 
finding way execute specification straightforward 
approach employ executable declarative programming language constraint logic programming proposed 
pointed expressive power logic programming limited order properties complex reactive systems difficult specify 
automata close relationship grammar rules rewrite rules 
automata theory equivalence finite state automaton regular expression proven 
extended regular expressions easily defined grammar rules context free grammar definite clause grammar narrowing grammar 
attempt provide unified framework define syntax semantics visual language important subset statecharts constructs complex systems 
syntax visual program defined set executable rewrite rules 
rules act visual program generators visual program parsers 
resulting program naturally mapped set rewrite rules execution logic program interpreter 
result provide declarative semantics means logic program visual program alternative approach proposed 
best knowledge existing approach follow direction 

provided unified framework order term rewriting system embedded logic programming define syntax semantics visual language 
demonstrated visual language syntax specified set functional logic grammar rules 
grammar rules serve visual program parser executed logic program interpreter 
resulting visual program mapped order rewrite rule language execution logic program interpreter 
words syntax operational semantics visual language described declarative semantics logic program 
executability visual program nice tool modeling complex reactive systems 
berry gonthier synchronous programming reactive systems esterel programming generation computers elsevier science publisher 
north holland nivat eds inria report 
caspi pilaud halbwachs plaice lustre declarative language programming synchronous systems th acm symposium principles programming languages january 
chan finite state machine modeling execution analysis master thesis computer science department hong kong university science technology sept 
chau narrowing grammar lazy functional logic formalism language analysis phd dissertation ucla computer science department technical report csd sept 
chau narrowing grammar comparison logic grammars proceedings north american conference logic programming cleveland ohio pp 
october published mit press lusk eds 

chau parker narrowing grammar theory implementation applications journal logic programming vol 
pp 
november 
nota tucci relation grammars application multi dimensional languages journal visual languages computing 
diaz editors formal description technique estelle north holland 
ding katayama attributed state machines behavior specification reactive systems th international conference software engineering knowledge engineering 
van eijk vissers diaz editors formal description technique lotos northholland 
gauthier le guernic besnard signal declarative language synchronous programming real time systems proceedings rd conference functional programming languages computer architecture lncs springer verlag 
harel statecharts visual formalism complex systems science computer programming 
harel pnueli schmidt sherman formal semantics statecharts proc 
ieee symp 
logic comp 
sci pp 

helm marriott declarative specification visual languages proc 
ieee workshop visual languages chicago illinois october pp 

graphical description semantics verification reactive systems process algebra international workshop automatic verification methods finite state systems 
von neumann theory automata construction reproduction homogeneity part ii theory self reproducing automata university illinois press 
pnueli shalev step semantics statecharts proc 
symposium theoretical aspects computer software lecture notes computer science vol 

springer verlag berlin pp 

pereira warren definite clause grammars language analysis artificial intelligence 
wittenburg visual grammars incremental parsing interface languages proc 
ieee workshop visual languages chicago illinois october pp 

