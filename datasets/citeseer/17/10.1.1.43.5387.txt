context sensitive rewriting strategies salvador lucas departamento de sistemas inform computaci universidad polit de valencia de vera valencia spain mail upv es url www upv es users elp html context sensitive rewriting simple restriction rewriting formalized imposing fixed restrictions replacements 
restriction purely syntactic basis explicitly automatically specified arguments symbols signature inductively extended arbitrary positions terms built symbols 
termination preserved usually improved methods developed formally prove 
investigate definition properties context sensitive rewriting strategies particular fixed sequences context sensitive rewriting steps 
study define order obtain efficient computations ensure context sensitive computations terminate possible 
give conditions enabling strategies root normalization normalization infinitary normalization 
show theory suitable formalizing definition analysis real computational strategies programming languages obj elan 
keywords infinitary normalization normalization replacement restrictions strategies sequentiality term rewriting 
extended revised version appeared proc 
th international conference algebraic logic programming alp 
partially supported spanish cicyt tic 
contents preliminaries omega gamma 
context sensitive rewriting characterization normal forms normalization 
context sensitive rewriting strategies definition normalizing strategies root context sensitive rewriting 
effective definition step normalizing strategies sequentiality 
strong sequentiality 
nv sequentiality 
nv indices replacement restrictions 
strong indices replacement restrictions 
indices defining context sensitive strategies 
context sensitive index reduction strategies properties context sensitive index reduction strategies 
normalization normalization normalization infinitary normalization infinitary normalization 
fairness infinitary normalization 
context sensitive rewriting infinitary normalization 
related applications context sensitive rewriting evaluation strategy obj 
context sensitive rewriting evaluation strategies elan 
context sensitive rewriting csr luc restriction rewriting associated term rewriting system trs 
signature sigma mapping sigma called replacement map discriminates argument positions kg ary symbol perform replacements 
replacements forbidden argument positions 
restrictions raised arbitrary positions terms obvious way 
example consider trs zero permits derivation underline redex contracted rewriting step zero infinite meaningless derivation zero zero delta delta delta avoided restriction 
second step 
context sensitive computations replacement map obtain normal forms terms rewritten 
sufficient conditions ensure restriction rewriting able compute root stable terms called head normal forms values established luc 
fact able automatically provide replacement maps supporting computations 
specially important canonical replacement map denoted specifies restrictive replacement map automatically associated trs order achieve completeness context sensitive computations see luc details 
instance replacement map example fact canonical replacement map associated trs example 
csr restriction rewriting preserves termination trs terminating means term initiates infinite rewrite sequence terminating term initiates infinite rewrite sequence 
interesting csr improve termination avoid infinite rewrite sequences exist 
term rewriting main approaches addressing problem ensuring finiteness rewriting computations issued trs study termination prove term starts infinite rewrite sequence see der survey topic study definition normalizing strategies rules define specific rewrite sequences avoid infinite rewritings starting terms normal form 
obviously approach excludes second trs proved terminating rewrite sequence finite definition normalizing strategies trivial efficiency issues 
unfortunately termination general undecidable 
requiring termination trs considered quite strong restriction applications 
researchers investigated define normalizing rewriting strategies conditions usually imposing strong syntactic restrictions typically orthogonality orthogonality shape rules trss am dm hl ken nt sr toy 
formal techniques proving termination general usually apply arbitrary trss 
order formalize claim csr improve termination going show normalization computation normal forms instance compute normal forms exist 
unrestricted rewriting order ensure finiteness context sensitive computations try show infinite rewrite sequence proving termination trs see gs luc zan fr 
example consider trs manipulate prime numbers gs rules defining divides included 
primes sieve head tail sieve filter sieve filter divides filter filter true false sieve head filter divides giesl middeldorp show terminating 
possibility look computation rule avoids infinite rewrite sequences starting terms having normal form 
contrast unrestricted rewriting show approaches useful complement defining normalizing strategies terminating trss terminating instance trss examples 
expressed result demonstrate left linear confluent terminating trs admits step normalizing strategy corollary 
able show normalizing strategies suited infinitary normalization obtaining possibly infinite normal form term exists 
fact show termination criteria serve ensure trs infinitary normalizing sense term finite normal form infinite 
instance trss examples infinitary normalizing 
summary investigate definition properties context sensitive rewriting strategies just strategies replacement map concrete fixed sequences context sensitive rewriting steps 
knowledge strategies studied 
particular pay attention definition normalizing strategies strategies obtain normal form term exists prove left linear confluent trs normalizing strategy induces normalizing strategy strategy trivially normalizing terminating trss 
replacement map ensure termination fail prove need provide normalizing strategies 
known theory defining efficient normalizing strategies huet evy theory needed reductions hl hl 
needed redex redex contracted descendants rewrite sequence normal form 
orthogonal trss term normal form contains needed redex 
repeated reduction needed redexes normalizing hl 
huet evy theory provides basis definition normalizing rewriting strategies 
reduction needed redexes adequate defining normalizing strategies 
terms normal form normal form 
terms having normal form need normal form redex term normal form needed useful discriminating redexes contracted normalize term 
similarly needed reduction taken basis root normalization infinitary normalization 
middeldorp provided unified framework analyze reductions leading root stable terms normal forms infinite normal forms mid 
framework relies notions root normalization root 
redex root needed redex descendants reduced root normalizing derivation issued term 
term root stable contains root needed redex reduction root needed redexes root normalizing mid 
proven certain conditions normal forms root stable luc middeldorp theory provides adequate framework definition normalizing strategies result orthogonal trs admits step normalizing strategy 
preliminary definitions section brief contextsensitive rewriting section addresses main topics 
characterization normal forms normalization process respect unrestricted rewriting section 

definition notion context sensitive rewriting strategy analysis general properties section 

effective definition normalizing context sensitive rewriting strategies sections 

context sensitive strategies defining root normalizing normalizing infinitary normalizing rewriting strategies sections 
concludes revision related particularly applications analysis computational properties strategies rewriting programming languages obj elan section concluding remarks directions section 
preliminaries introduce main notations 
full definitions refer am bn dj klo 
set denotes set subsets theta binary relation set denote transitive closure reflexive transitive closure 
say confluent exists element said normal form exists say normal form normal form say terminating iff infinite sequence delta delta delta terminating relation element normal form 
confluent terminating relation normal form exists unique 
denotes countable set variables sigma denotes set function symbols ff having fixed arity function ar sigma 
denote set terms sigma 
tuple terms written number elements tuple clarified context 
ar set variables terms viewed labelled trees usual way 
positions represented chains positive natural numbers address subterms denote empty chain denote length chain jpj 
position set positions set fp qg 
positions ordered standard prefix ordering iff means subterm position denoted tj term subterm position replaced depth subterm tj length position jpj 
denote set positions term pos 
terms pos denotes set positions pos iff tj positions non variable symbols denoted pos sigma pos variable occurrences 
term said linear multiple occurrences single variable 
symbol labelling root denoted root 
set symbols sigma appearing sigma ff sigma pos root tj fg 
chain symbols lying positions pos prefix root prefix root prefix 
strict prefix prefix 
refer term exists term just context replacement occurs 
roughly speaking context term zero holes fresh constant symbol 
write denote usually single hole position generally usually write denote arbitrary context clarifying number location holes clarified situ 
called empty context 
new constant symbol omega introduced represent arbitrary terms 
terms sigma omega said omega gamma denote prefixes terms 
denote omega term variables replaced omega gamma positions pos omega said omega gammae ordering omega gamma omega ar 
means prefix write compatible exists note maximal context omega gamma omega gamma rewrite rule ordered pair written sigma ar ar 
left hand side lhs rule right hand side rhs 
trs pair sigma set rewrite rules 
denotes lhs instance oe lhs rule redex 
say normal form 
fact 
lemma left linear trs 
term 
omega iff redex 
left linearity required part lemma 
instance omega omega redex 
set redex positions fp pos tj oe denote omega term outermost redexes replaced omega gamma omega gamma form omega gamma pos omega 
trs left linear linear term 
possibly renamed rules overlap non variable position pos general unifier oe oe lj oe 
pair hoe oe oe called critical pair called overlay critical pair ht si trivial left linear trs critical pairs called orthogonal 
called orthogonal critical pairs trivial overlays 
trivial critical pairs called weakly orthogonal 
term rewrites position written just tj oe oe rule pos substitution oe 
eventually detailed writing step rewrite relation 
reduct inner reduction relation gamma 
gamma 
term root stable rewritten redex 
term said root normalizing root stable reduct 
term said normalizing normal form 
omega reduction reduction relation omega called omega km omega gamman omega just omega pos tj omega gamma tj omega omega gamma reduction relation omega confluent terminating arbitrary trss hl km 
omega normal form clearly omega gamma omega redex omega gamma proposition km sigma trs 
sigma omega 


tj 

term strongly root stable strong head normal form omega gamma proposition trs 
strongly root stable root stable 
proof 
strongly root stable omega gamma root stable exists derivation oe 
proposition oe omega gamma omega gamma contradiction 
general converse statement true 
example consider trs term root stable strongly root stable omega omega omega omega omega term rigid soft omega klo 
say context rigid omega gamma rigid term 
proposition klo sigma trs 
term sigma omega written uniquely omega omega gamma rigid soft 
compositional 
fact 
lemma sigma trs rigid contexts 
rigid context 
proof 
contradiction 
rigid rigid follows pos sigma omega tj compatible omega 
omega tj get omega omega omega omega omega rigid 
context sensitive rewriting signature sigma mapping sigma replacement map sigma map sigma ar replacement map determines argument positions reduced symbol sigma luc 
inclusion ordering extends ordering sigma set sigma accordingly lattice induces lattice sigma minimum element 
sigma maximum element 
ar sigma upper bound lub greatest lower bound sigma 
way means considers positions reduction 
say restrictive equally restrictive set replacing positions pos pos fg pos fg pos non replacing positions pos pos gamma pos 
proposition luc sigma pos 
pos iff pos pos tj result immediate 
proposition pos pos 
proposition luc pos pos pos pos 
context sensitive rewriting rewrite subterms replacing positions rewrites written 
simply 

pos 
set replacing redexes pos pos 
term normal form pos 
example reformulate example new notation 
write zero 

second derivation allowed give rewriting step zero 
zero restriction avoids replacement redex term zero 
confluence termination trs mean confluence termination 
see luc luc 
term minimum replacement map ensuring subterms non replacing positions variables pos pos equivalently pos sigma pos sigma delta delta delta fi luc 
example 
get 
canonical replacement map trs note automatically associated means simple calculus 
relevance replacement map enables completeness csr root normalizations 
proposition luc sigma left linear trs linear term sigma oe substitution oe substitution 
ar oe 
luc com denoting canonical replacement map 
believe new notation clearer 
theorem luc sigma left linear trs sigma sigma root stable term 
exists 
root root gamma 
theorem luc sigma left linear trs sigma sigma 
exists 
gamma 
theorem luc sigma orthogonal trs sigma sigma root stable term 
exists root stable term 
gamma 
characterization normal forms proposition easy see pos downward closed pos pos pos 
motivates definition 
definition maximal replacing context term sigma signature sigma sigma maximal replacing context context mrc mrc ae mrc note mrc fp minimal pos positions tj downward closedness pos pos implies holes context subterm mrc replacing 
justifies name maximal replacing context 
proposition sigma signature sigma sigma pos mrc pos mrc 
proof 
induction structure mrc 
note replacement map maximal replacing context term empty mrc 
prove maximal replacing contexts normal forms rigid contexts 
proposition sigma left linear trs sigma sigma omega normal form pos omega mrc 
omega rigid strongly root stable 
proof 
prove omega rigid omega omega 
proceed induction omega 
omega case omega gamma omega possible immediate 
omega gamma omega gamma ar omega gamma assume omega gamma ar rigid 
omega rigid omega maximal context omega common part omega omega omega gamma omega gamma omega case omega left linear lemma redex 
pos redex normal form 
omega sj omega gamma pos sigma omega 
replacing omega gammap definition proposition pos 
pos sigma omega pos omega 
omega proposition get pos leading contradiction 
prove omega omega gamma omega strongly root stable 
empty omega omega gamma omega rigid omega omega omega follows 
left linearity required proposition example consider non left linear trs note 
maximal replacing context 
despite fact normal form term omega omega rigid strongly root stable omega omega omega omega condition required proposition 
example consider trs example 
zero normal form 
maximal replacing context 
omega omega rigid omega omega omega 
omega omega omega note normal form contains replacing occurrences omega gamma mrc need rigid 
example consider example 
term normal form redex 
mrc omega omega conclude mrc rigid 
hand omega normal form pos omega omega omega omega proposition sigma left linear trs sigma sigma normal form mrc 
omega strongly root stable 
proof 
proposition omega omega 
proposition omega proposition omega omega omega follows 
proposition formalizes idea maximal replacing contexts normal forms stable parts reducts normal forms unrestricted rewriting 
corollary sigma left linear trs sigma normal form strongly root stable 
corollary proposition easily conclude result 
theorem luc sigma left linear trs sigma normal form root stable 
corollary sigma left linear trs sigma normalizing term root normalizing 
normalization proposition establishes conditions ensuring set normal forms closed unrestricted rewriting 
proposition sigma left linear trs sigma sigma normal form 
normal form mrc mrc 
proof 
normal form pos assume pos 
mrc mrc 
proposition omega 
exists sj proposition pos 
proposition pos proposition pos contradicting pos 
pos 
pos sj redex contradicting omega gamma proposition 
hand omega follows omega gamma omega gamma omega omega exists pos omega omega omega gamma omega gamma proposition proposition pos omega 
proposition pos omega contradicting proposition 
left linearity dropped proposition 
example consider example 
note normal form normal form 
trs confluent unique normal form property holds term normal form unique 
confluence imply unique normal form property example consider confluent trs replacement map 
note normalizing derivations 


yield different normal forms 
result 
proposition sigma left linear confluent trs sigma normal forms mrc mrc 
proof 
mrc mrc 
confluence proposition mrc mrc mrc 
unfortunately confluence suffice ensure proposition 
example consider trs example 
terminating critical pairs confluent critical pair lemma newman lemma see bn instance 
note derivations 

producing different normal forms maximal replacing contexts coincide 
immediate consequence proposition 
theorem sigma left linear confluent trs sigma normal forms mrc mrc 
unique normal form property ensured confluence confluence 
luc 
proposition establishes unrestricted reduct normalizing term normalizing 
proposition sigma left linear confluent trs sigma normalizing normalizing 
proof 
normal form confluence exists term derivations proposition normal form 
mrc 
prove induction structure exists normal form constant variable normal form unique root stable reduct theorem 
root stable theorem theorem 
normal form mrc induction hypothesis normal forms 

mrc rigid normal form 
confluence sufficient ensuring proposition 
example consider confluent trs 
note term normal form 
reduct normal form 
context sensitive rewriting strategies non deterministic rewriting strategy trs function assigns nonempty set non empty finite rewrite sequences term normal form mid 
specialization previous notion step non deterministic rewriting strategy trs mean function assigns non empty set redex positions term normal form 
trss orthogonal need supply rewrite rule selected redex contracted redex may contractum see am details 
write step strategies 
sequence reduction sequence form delta delta delta say reduct strategy root normalizing root normalizing term possible infinite sequence starting contains root stable term normalizing normalizing term infinite sequence starting contains normal form reducts normal forms normalizing normalizing term infinite sequence starting proposition sigma left linear trs sigma rewriting strategy infinite sequence contains normal form 
normalizing 
proof 
proposition 
differentiate main topics practical definition rewriting strategies existence ensure term normal form 
computability provide effective method computing strategy 
behaviour provide evidence computational property strategy typically root normalizing normalizing efficiency ensure computations achieved strategy satisfy criterion efficiency instance minimality reduction steps 
orthogonal trss huet levy notion needed reduction provides framework defining normalizing strategies hl hl 
needed redex term redex reduced descendant normalizing derivation starting hl 
reduction sequences contract needed redexes called needed reductions 
main theoretical aspects 
formalizes notion efficiency rewriting computations 
normalizing derivation contracts needed redexes considered efficient useless reductions performed 
allows definition normalizing strategies needed reduction normalizing 
hand known fact orthogonal trss term normal form contains needed redex see hl ensures existence rewriting strategies contract needed redexes 
unrestricted rewriting csr deterministic consider notion context sensitive rewriting strategy 
definition context sensitive rewriting strategy sigma trs sigma non deterministic context sensitive rewriting strategy just strategy function assigns non empty set non empty finite rewrite sequences term normal form 
step strategy function assigns non empty set pos reducible term write 

step strategies 
strategy sequence reduction sequence form delta delta delta sequence delta delta delta maximal normal form 
note strategies obtain normal forms normal forms 
normal form strategy forced reduce 

strategy necessarily rewriting strategy 
strategy root normalizing root normalizing term possible maximal infinite sequence starting contains root stable term normalizing normalizing term infinite sequence starting true consider graph stores different occurrences redex single shared location 
note dealing strategy need clarify maximal sequences contain root stable terms order keep natural assumption root normalizing strategies generate rewriting sequences compute term initial root normalizing term 
reason strategy forced reduce normal form possible finite maximal sequences contain root stable terms 
principle ensured normal forms root stable theorem 
immediate property strategies 
theorem sigma left linear trs sigma normalizing 
normalizing strategy root normalizing 
proof 
normalizing strategy normalizing term normal form 
normalizing term initiates infinite sequence 
maximal finite sequences normal form theorem root stable 
note dealing terminating left linear trs trivially ing strategy normalizing 
corollary sigma left linear trs sigma terminating 
strategy root normalizing 
general extend theorem non normalizing trss 
example consider orthogonal trs 
note terms arbitrary terms normal form 
strategy reduces inner redexes terms normalizing root normalizing delta delta delta reduction step root normalizes 
example shows confluence orthogonality help general improve previous results 
step strategy extended step strategy sh follows sh normal form mrc tj generalization arbitrary strategies immediate 
property 
proposition sigma left linear trs sigma normalizing root normalizing strategy sh normalizing proof 
proposition sh normalizing root normalizing exists infinite sh sequence delta delta delta contain normal form root stable term 
definition sh fact justified theorem sh sequence contain root stable terms contain normal forms corresponds infinite sequence delta delta delta contradicts normalizing root normalizing 
definition normalizing strategies normal forms need normal forms theories normalization normalizing strategies completely adequate studying defining normalizing strategies 
particular needed reduction useful defining normalizing strategies definition redex term having finite normal form needed 
example consider trs mid normal form 
normal form 
redex needed repeated reductions redex 

delta delta delta normalize 
theorem shows normal forms left linear trs root stable 
possible normalize term successively root normalizing maximal non root stable subterms reducts thought root normalization ken mid basis defining normalizing computations derivation leading normal form obtains root stable term step derivation 
fact corollary normalization term thought preliminary root normalization obtains root stable term followed normalization replacing arguments middeldorp noticed root normalizing strategies need normalizing 
example consider trs mid strategy selects unique outermost redex faces term case redex selected 
clearly root normalizing normalizing infinite reduction sequence delta delta delta normal form computed middeldorp pointed solution problem special root normalizing strategies context free strategies 
definition context free strategy mid step strategy context free root stable term kg arbitrary strategies context freeness defined follows mid contextfree root stable terms kg subsequence non empty theorem mid confluent trs 
context free root normalizing reduction strategy normalizing 
basis similar result middeldorp see mid improve theorem 
corollary confluent trs 
reduction strategy extended context free root normalizing reduction strategy normalizing 
proof 
reduction strategy extended context free root normalizing strategy normalizing exists infinite reduction sequence delta delta delta normalizing term extends infinite reduction sequence contradicting theorem 
root normalizing context free rewriting strategies need normalizing 
example consider trs replacement map 
note consider rewriting strategy contracts leftmost outermost redex leftmost maximal non root stable subterm term 
sequence delta delta delta compute normal form obtained reduction sequence 

restrict reduction sequences contract replacing redexes context sensitive strategies prove root normalization adequate basis normalization 
note realm csr notion step context free strategy equivalently formulated imposing root stable terms analogous generalization arbitrary strategies 
theorem sigma left linear confluent trs sigma context free root normalizing reduction strategy normalizing 
proof 
context free root normalizing reduction strategy normalizing term having normal form proceed induction structure mrc maximal replacing context theorem depend selected normal form 
constant variable unique normal form unique root stable reduct root normalizing infinite sequence starting assume delta delta delta infinite 
root normalizing contains root stable term 
proposition normal form theorem maximal replacing context mrc mrc 
root stable write 

normalizes mrc 
infinite context free initiates infinite sequence 
contradicts induction hypothesis normalizing corollary sigma left linear confluent trs sigma strategy extended context free root normalizing strategy normalizing 
corollary formalizes root normalizing strategies defining normalizing strategies 
sections investigate effectively define 
root context sensitive rewriting notion root needed computation ken mid provides suitable formal framework definition root normalizing normalizing infinitary normalizing reduction sequences mid 
redex term root needed contracted descendants rewrite sequence root stable term 
orthogonal trss non root stable term root needed redex 
root stable terms root needed redex redexes terms having root stable reduct trivially root needed 
root needed redexes maximal non root stable subterms term needed 
root necessary set redexes set redexes redexes set descendants reduced root normalizing derivation 
repeated contraction root necessary sets redexes called root necessary reduction 
theorem mid root normalizing term 
parallel rewrite sequences starting contain infinitely root necessary steps 
root necessary reduction root normalizing orthogonal trss 
particular repeated contraction root needed redexes called root needed reduction orthogonal trss 
aim root defining normalizing strategies 
points enumerated section address problem proving existence strategies 
result corresponds theorem mid orthogonal trss non root stable term root needed redex 
prove accurately formulated orthogonal trss non root stable term replacing root needed redex 
need previous results 
lemma mid orthogonal trs 
term rewrites redex pattern redex unique 
lemma orthogonal trs 
term root stable redex gamma 
oe 
set positions non root stable proper subterms minimal pos sigma tj position root needed redex tj tj root needed redex proof 
implicit middeldorp proof theorem mid 
lemma sigma orthogonal trs sigma non root stable term gamma 
oe 
set positions proper non root stable subterms minimal pos sigma pos 
proof 
assume minimal pos sigma 
gamma 
oe 
subterm tj reduced allow matching lj tj non root stable pos sigma pos sigma minimal pos sigma leads contradiction 
pos sigma pos 
proposition pos 
theorem sigma orthogonal trs sigma non root stable term replacing root needed redex 
proof 
follow proof theorem mid 
just outline proof comment particulars context sensitive rewriting 
middeldorp distinguishes redex non redex 
case pos pos orthogonal trss corresponds root needed redex 
second rewrite sequence leading root stable form splits gamma 
oe redex pattern reduction oe depend particular derivation lemma 
consider set occurrences non root stable proper subterms candidates root needed redexes root needed redexes subterms tj minimal pos sigma lemma 
prove pos 
follows immediately lemma 
tj replacing root needed redex lemma root needed redex replacing tj pos proposition replacing root needed redex theorem means replacing redexes better approximation enclose root needed redexes smaller set redexes 
csr completely capture root 
example consider trs set root normalizing derivations 




see redex occurrence root needed 
set redex replacing pos 
root needed redexes replacing 
hand replacing redex root needed derivation contract 
replacing redexes root needed 
theorem establishes possibility defining step strategy orthogonal trs fp pos tj root needed tg root stable root stable construction context free theorem invoked justify normalizing character 
orthogonal trs admits step normalizing strategy 
unfortunately definition effective root root stability undecidable 
interested establishing additional conditions enable effective selection replacing root needed redex subset replacing redexes pos root necessary 
address problem section 
concerning second refine middeldorp result outermost redexes root necessary set redexes 
restrict outermost replacing redexes 
theorem sigma orthogonal trs sigma non root stable term 
minimal pos root necessary set redexes 
proof 
proceed structural induction 
redex immediate 
redex proof theorem minimal pos tj root necessary set redexes minimal pos sigma 
minimal pos tj position root needed redex tj lemma tj root needed redex minimal pos tj root necessary set redexes minimal pos sigma 
pos proposition minimal pos tj minimal pos follows 
replacement map parallel outermost strategy po follows po ft 

delta delta delta 
pn 
fp minimal pos note possible po step thought single step parallel rewriting 
orthogonal trss possible po sequence issued leads term po clearly context free 
result 
theorem sigma orthogonal trs sigma po normalizing 
proof 
theorem theorem po root normalizing 
po context free theorem follows 
theorem provides effective example parallel normalizing strategy 
section devoted definition step normalizing strategies 
effective definition step normalizing strategies root undecidable approximated 
means necessary provide method decide redex needed identify class trss ensuring reducible term redex previous method succeeds dm 
decidable approximations extensively explored com dm hl jac js km nst nt toy 
investigated approximations capture root orthogonal trss luc 
demonstrated nv sequentiality strong sequentiality hl particular case general approximation root 
sequentiality sequentiality notion index 
omega gamma pos omega omega gamma index respect predicate omega gamma omega gammay implies omega km 
set indices respect denoted 
property proposition km monotone predicate omega terms omega term 
omega 
term sigma omega gammai test redex position index applying previous definition omega gamma monotone predicate sequential sigma omega hold exists holds follows orthogonal trss sequential indices respect predicate nf nf holds normal form sigma approximate needed redexes index omega gamma tj needed redex trs sequential predicate nf sequential 
sequentiality indices trss undecidable decidable approximations investigated 
strong sequentiality trs rewrite relation 
arbitrary reduction defined follows 
exists pos tj redex arbitrary term km 
clearly set normal forms respect 
coincides set normal forms 
trs strongly sequential hl km predicate nf 
nf 
holds exists arbitrary reduction sequence 
normal form sigma sequential 
indices respect predicate nf said strong indices sequential indices indices nf 
set strong indices term denoted nf 

strong indices effectively computed omega section fresh symbol ffl pos omega iff ffl ffl km toy 
fact js toy take result re definition strong index 
trs strongly sequential omega gammay form strong sequentiality proven decidable left linear trss js 
properties 
proposition js km sigma trs 
sigma omega 
tj 
proposition klo km sigma trs 
omega omega gamma rigid soft 
omega gamma tj 
consider false true booleans 
nv sequentiality trs sigma write nv exist pos tj omega omega note nv 
predicate term defined follows term holds exists sigma nv nv succeeds removing omega gammae 
predicate term clearly monotone 
set indices term respect term written nv term 
decidable polynomial time position pos omega nv index 
trs nv sequential nv omega gammay form decidable left linear trss com 
strong nv sequentiality related 
proposition strong indices nv indices 
proposition strongly sequential trss nv sequential 
write 
just 
pos tj omega gamma tj omega rule omega lemma nv sigma omega 
exists sigma omega 

implies 
characterizes nv indices follows 
lemma sigma omega pos omega 
nv exist pos sigma omega gamma omega ffl 
omega 
properties 
lemma nv nv tj 
lemma luc orthogonal trs term 
nv omega gamma lemma trs sigma omega pos nv 

nv 
proof 
note tj omega omega gamma nv lemma exist omega ffl 
omega 
note ffl ffl ffl 
ffl cases ffl 
contradicting nv 
lemma hold comparable 
example consider trs note nv index omega possible 
reduction step issued ffl ffl 
ffl omega 
nv index 
lemma trs sigma omega nv 
nv 
proof 
tj omega gamma 
occurrence omega rules tj redex ffl substitution oe ffl oe 
ffl omega lemma contradicts nv 
note omega gamma 
nv lemma 
case proposition nv 
second lemma nv proposition nv 
follows 
nv indices replacement restrictions previous discussion section interest nv sequentiality stems result 
theorem luc sigma orthogonal trs sigma non root stable 
nv omega gamma tj root needed 
order distinguish replacing non replacing indices term denote replacing redexes ff ff pos ff fs 
result establishes canonical replacement map captures nv indices non root stable terms 
theorem sigma orthogonal trs sigma sigma omega root stable nv omega gamma nv omega gamma 
proof 
nv omega gamma nv omega gamma need prove nv omega gamma implies pos omega gamma 
pos omega gamma note root stable rewrites redex 
proposition derivation 

delta delta delta 
gamma pn gamma 
oe substitution oe 
assume gamma rewriting steps oe contract inner positions 
prove induction length nv omega gamma pos 
base case consider oe obtain contradiction lemma 
induction step note pos pos proposition 
contradict lemma 

implies omega gamma 
omega gamma lemma nv omega gamma 
proposition pos 
induction hypothesis follows 
particular pos oe nv oe omega gamma 
oe redex contradicts lemma 
general theorem hold root stable terms 
example consider example 
assume note root stable 
recall nv index non replacing position pos 
corollary sigma orthogonal trs sigma sigma omega root stable nv omega nv omega 
proof 
nv omega omega omega gamma proposition nv omega gamma 
theorem nv omega gamma pos omega gamma 
proposition pos omega nv omega 
point usefulness results theorem replacing indices considered non root stable terms explicit consideration replacement restrictions nv indices non replacing ones 
shows context sensitive restrictions accurately enclose redexes contracted root normalization need test redex occurrences inside maximal replacing context mrc non root stable term strong indices replacement restrictions strong indices nv indices proposition strongly sequential trss proposition 
previous results apply strong indices strongly sequential trss 
strong indices improve theorem corollary follows 
lemma sigma trs sigma omega omega delta delta delta omega un omega pos pos pos pos 
proof 
induction length derivation 
omega gamma omega 
clearly pos pos pos downward closed pos pos pos 
follows 
result establishes deal soft term define omega gamma sequence considers compatible terms replacing positions write omega omega pos 
proposition sigma trs sigma omega omega 
omega omega number steps 
proof 
induction length derivation omega omega delta delta delta omega pn omega omega gamma omega omega gamma pos immediate 
consider step omega pos 
fp step performed 
fp ig 
set defined lemma pos pos pos proposition perform omega reduction directly lemma pos 
build derivation omega omega omega delta delta delta omega gamma gamma omega omega delta delta delta omega pn omega omega omega gamma gamma 
soft apply derivation omega omega takes gamma steps follows 
fp lemma pos consider tj omega prove omega contradiction 
reductions performed positions fp gamma disjoint assume pos relevant 
omega pos previous reductions non replacing positions modify root tj write omega maximal non empty context 
omega compatible compatible 
root omega gamma pos omega omega omega reduction performed root subterm positions compatible proposition pos omega reduction non replacing positions choice arbitrary 
means compatible omega leading contradiction 
eliminate omega reduction step omega reduction step omega useless 
obtain shorter derivation follows 
proposition sigma trs sigma 
omega omega pos sigma omega 
omega omega number steps 
proof 
induction length derivation 
omega omega gamma omega pos 
follows 
induction step omega 
omega omega gamma exists tj omega pos 
maximal context omega omega gamma omega gamma proposition pos proposition pos sigma 
pos 
proposition pos tj proposition pos leading contradiction 
tj omega gamma pos proposition pos 
omega gamma omega omega gamma omega omega cases omega omega gamma omega 
omega omega steps follows 
omega induction hypothesis 
omega omega gamma steps 

omega omega steps follows 
theorem sigma trs sigma sigma omega soft term 
proof 
pos omega 
assume pos omega non replacing strong index gamma 
omega gamma proposition 
omega omega gamma proposition ffl 
omega omega contradicting strong index theorem hold nv indices 
example consider trs example omega soft omega omega omega omega omega omega example shown nv index omega 
pos nv nv 
unfortunately theorem extended non soft terms instance consider trs example term omega omega rigid 
strong indices pos 
indices defining context sensitive strategies previous results allow establish 
corollary sigma orthogonal nv sequential trs sigma sigma omega root stable nv omega 
proof 
omega omega gamma form nv sequentiality nv omega corollary nv omega 
theorem corollary entail result complements theorem 
theorem sigma orthogonal nv sequential trs sigma non root stable term replacing root needed redex 
proof 
non root stable term 
corollary nv omega 
nv omega 
omega omega gamma proposition proposition nv omega gamma 
theorem tj root needed redex proposition tj replacing redex 
corollary allows define step strategy orthogonal nv sequential trss ae nv omega root stable root stable corollary strategy 
theorems root normalizing 
construction context free normalizing theorem 
unfortunately root stability remains undecidable definition completely effective 
order overcome problem try fact considering nv sequential trss reducible term contains redex addressed nv index omega context sensitive index reduction strategies say step strategy index reduction strategy reduces replacing redexes pointed indices 
notice nv index reduction strategy 
example consider example term 
assume 
root stable nv omega reduction step nv index omega ffl 
ffl omega ffl omega omega 
particular try define arbitrary strong nv index reduction follows omega nv nv omega redex es occurring replacing strong nv index positions selected reduction 
point definitions mention root stability term considered reduction 
prove possible define ff index reduction strategies particular prove existence nv write 

pos 
result 
proposition sigma trs sigma sigma omega gamma omega omega 
pos sigma omega exists sigma omega gamma omega 
number steps omega proof 
induction length derivation 
omega omega reasoning proof proposition conclude omega note pos omega induction step 

exists tj omega pos 
proposition reasoning base case omega omega 

follows 

induction hypothesis exists omega 
gamma steps omega 
steps follows 
proposition sigma trs sigma sigma omega gamma omega omega 
exists sigma omega gamma omega 
number steps omega proof 
induction length derivation 
immediate 


induction hypothesis exists 
gamma steps omega pos 

follows 
pos proposition omega tj 
gamma steps omega follows 
result ensures existence nv index strategies nv sequential trss 
theorem sigma nv sequential trs sigma sigma omega omega normal form pos omega nv proof 
structural induction 
omega gamma immediate 
omega gamman form pos omega exists omega gamma form pos omega 
induction hypothesis nv 
assume nv 
nv lemma omega ffl 
omega nv possibility assume ffl 
obviously means exists omega derivation 
reduces positions derivation ffl 
omega proposition exists omega 
omega nv sequentiality nv nv 
assume nv pos 
proposition exists omega ffl 
omega contradicts nv 
need condition ensure result example consider trs example assume 
note consider omega normal form omega omega 
omega ffl omega omega nv 
note nv pos nv 
theorem formalizes existence nv nv sequential trss 
unfortunately justify existence result justifies existence strong index reduction strategies strongly sequential trss 
theorem sigma strongly sequential trs sigma sigma omega omega normal form pos omega proof 
proposition consider maximal rigid context soft terms 
pos omega tj omega gamma form pos pos omega strong sequentiality theorem 

omega gammay rigid context trivially index omega 
proposition 
proposition pos follows 
properties context sensitive index reduction strategies establish main properties strong nv index reduction strategies 
proposition arbitrary reduction strong nv indices context free 
proof 
root stable 
nv omega gamma lemma proposition nv omega gamma showing context freeness nv concerning proposition lemma 
theorem sigma orthogonal trs sigma ff fs 
ff index reduction strategy root normalizing 
proof 
ff index reduction strategy root normalizing term 
maximal finite sequences normal forms containing theorem root stable term 
infinite reduction sequence delta delta delta contain root stable term theorem considering proposition strong indices infinite root necessary reduction sequence existence contradicts theorem 
particular theorem implies nv theorems exist strongly nv sequential trss respectively orthogonal strongly nv sequential trs theorem sigma orthogonal strongly sequential trs sigma strong index reduction strategy normalizing 
proof 
theorem strong index reduction strategy 
strong index reduction strategy extended proposition contextfree theorem root normalizing corollary entails 
theorem sigma orthogonal nv sequential trs sigma nv index reduction strategy normalizing 
proof 
theorem nv nv index reduction strategy 
nv index reduction strategy extended nv proposition context free theorem root normalizing corollary follows 
normalization normalization section discuss context sensitive strategies defining normalizing strategies 
problem address concerns ability csr approximate possibly normal form term means normal forms 
fact general terms having normal forms normal forms terms having normal forms normal form shown example 
example consider nonterminating trs take 
term weakly normalizing normalizing infinite rewriting sequence 

delta delta delta 
term normalizing normal form normalizing delta delta delta establish conditions ensuring normal form corresponding normal form rewrites 
theorem sigma left linear trs sigma sigma normal form exists normal form 
proof 
normal forms root stable theorem term 
gamma 
root root 
prove existence induction structure 
constant variable ary symbol desired normal form 
root root 
ar 
normal form apply conclude normal forms ae note 

order prove normal form proceed contradiction 
normal form redex rewrite rule means oe substitution oe 
subterms non replacing occurrences variables 
proposition mrc mrc 
oe substitution oe normal form contradiction 
theorem ensures term normal form normal form prelude normal form 
fact ordering omega gamma give standard formulation approximation proposition obtain 
omega fact mrc 
immediate consequences theorem 
corollary sigma left linear trs sigma normalizing term normalizing 
corollary sigma left linear trs sigma weakly normalizing weakly normalizing 
results ensure normalizing strategy giving normal form applied normalizing term term having normal form 
basis proving fact main result section 
theorem sigma left linear confluent trs sigma normalizing sh normalizing 
proof 
normalizing strategy normalizing term 
corollary normalizing 
normalizing infinite sequence starting definition sh sh sequence issued normalizing term written possibly empty finite sequence delta delta delta leading normal form followed possibly empty sh sequence delta delta delta proceed induction structure normal form constant variable unique normal form 
sequence empty sh sequence issued fact sequence 
infinite sh sequence starting confluence proposition write normal forms mrc definition sh infinite exists delta delta delta infinite contradicting induction hypothesis 
general theorem hold non confluent trss 
example consider non confluent trs clearly terminating see luc formally prove claim 
strategy normalizing 
particular set second rule reducing redex delta delta delta normalize normalizes corollary sigma left linear confluent trs sigma terminating 
sh normalizing strategy corollary expresses formal connection termination theory normalizing strategies 
corollary left linear confluent terminating trs admits normalizing strategy 
normalization infinitary normalization lazy functional languages admit possibility giving infinite values meaning expressions fh rea 
infinite values defined limits converging infinite sequences partially defined values defined 
example consider trs example 
term normal form application rule introduces new function call function 
reduction sequence abbreviate delta delta delta suggests infinite value delta delta delta corresponds infinite list natural numbers considered infinite value 
situation research done concerning infinitary rewriting rewriting considers infinite reduction sequences probably involving infinite terms term rewriting systems built infinite terms ken mid 
infinite sequence elements taken set mean function denote th element sequence 
definition notion convergence limit infinitary sequences set done introducing distance elements distance function theta ir iff 
set distance metric space 
metric space 
sequence elements said convergent exists ffl ffl 
exists unique called limit sequence 
sequence said cauchy sequence ffl ffl 
convergent sequence cauchy sequence cauchy sequences limit metric space said complete cauchy sequence convergent 
known metric space embedded complete metric space standard procedure called metric completion 
infinitary normalization discuss infinitary rewriting follow middeldorp approach mid simpler adequate programming purposes 
infinite rewrite sequence infinite sequence terms 
terms largest natural number nodes depth equal label mch maximal common height mch ae root root min ar distance sigma theta sigma ir terms follows ae metric completion sigma yields set sigma infinite terms 
infinitary cauchy convergent rewriting sequence limit finite infinite term 
infinitary normalization interested infinite sequences length 
limit ordinal limit possibly infinite normal form 
kennaway developped notion strongly converging rewrite sequence 
kind sequences depth contracted redexes tends infinite 
definition mid infinite rewrite sequence delta delta delta strongly converging index depth redex contracted delta delta delta note finite sequences strongly converging infinite strongly converging sequence delta delta delta limit necessarily infinite term 
normal form exists index depth subterm root stable definition mid rewrite sequence called infinitary normalizing strongly converges possibly infinite normal form 
infinite rewrite sequence infinitary normalizing called perpetual 
definition mid reduction strategy trs called infinitary normalizing perpetual rewrite sequences starting terms admit infinitary rewrite sequence 
definition trs infinitary normalizing finite term admits infinitary normalizing sequence 
context having hole denote length shortest path root hole excluding hole min 
theorem sigma left linear trs sigma normalizing 
exists normalizing strategy infinitary normalizing 
proof 
normalizing strategy term show possible build strongly converging sequence reductions starting normalizing normal form 
assume 
normal form 
defined normalizing 
mrc 
proposition rigid 

reducing normal form obtain corresponding maximal replacing contexts mrc rigid lemma context rigid obtained min fd note notice reductions starting take place redexes depth greater equal subterms depth lesser stable overlap rigid context 
repeat process 
easy show sequence delta delta delta constructed way strongly converging sequence gamma 
construction derivation depth redex contracted tail subderivation delta delta delta satisfies desired 
strongly converging derivation limit case normal form follows 
corollary theorem shows termination implies infinitary normalization 
result sense 
case termination termination differ terminating trss admit infinite rewrite sequences 
apply result non terminating trss prove terminating 
way termination criteria gs luc zan proving infinitary normalization 
corollary sigma left linear trs sigma terminating infinitary normalizing 
corollary expresses formal connection termination theory infinitary termination trss 
corollary left linear trs terminating infinitary normalizing 
fairness infinitary normalization stated mid hope achieve infinitary normalization imposing fairness condition mid 
definition mid infinite rewrite sequence delta delta delta called fair maximal non root stable subterm root stable reduct position redex contracted step position possibly infinite rewrite sequence delta delta delta pos say delta delta delta subsequence empty integers gamma gamma fig delta delta delta subsequence delta delta delta lemma 
lemma trs term finite infinite normal form 
rigid pos tj rewrite subsequence fair infinite rewrite sequence delta delta delta normalizing fair infinite 
proof 
fp finite subsequence starting tj yielding term normal form maximal non root stable subterm definition subsequence pos rigid maximal non root stable subterm finite infinite normal form root stable reduct 
fair redex contracted step position reduced contradicting ends infinite definition subsequence fair 
definition mid reduction strategy trs called infinitary perpetual fair sequences starting terms admit infinitary normalizing rewrite sequence 
proof theorem suggests possible build infinitary normalizing strategies normalizing strategies 
proposition sigma left linear trs sigma normalizing 
normalizing strategy 
infinite fair sh sequence delta delta delta rigid normal forms 
proof 
induction take 
note proposition sh normalizing 
normalizing normal form written follows delta delta delta delta delta delta normal form proposition 
mrc tj gamma finite infinite rewrite subsequence extracted tail starts fact definition sh sh sequence delta delta delta theorem ensures term infinitary normalizing proposition ensures rigid lemma finite normalizes fair infinite sh sequence 
finite length infinite induction hypothesis rigid normal forms 
ae finite infinite note definition subsequence sigma 
normal forms rigid contexts having hole lemma rigid 
note min min theorem sigma left linear trs sigma normalizing 
normalizing strategy sh infinitary 
proof 
show infinite fair sh sequence infinitary normalizing derivation strongly converges possibly infinite normal form 
immediate consequence proposition 
theorem shows normalizing strategies property normalizing strategies useful obtaining infinitary normal forms 
corollary sigma left linear trs sigma terminating 
sh infinitary fair normalizing strategy corollary left linear trs 
terminating sh infinitary fair normalizing strategy theorem corollary complement results infinitary normalizing strategies mid apply left linear trss orthogonal trss 
counterpart require termination 
non terminating trss normalizing strategies 
theorem mid confluent trs 
reduction strategy extended context free root normalizing reduction strategy infinitary fair normalizing 
proposition context free strategy sh context free 
theorem left linear confluent trs sigma strategy extended context free root normalizing strategy sh infinitary fair normalizing 
proof 
context free root normalizing extension proposition root normalizing 
proposition context free 
sh extended sh theorem follows 
theorem theorem proposition strong nv index reduction strategies infinitary fair normalizing orthogonal strong nv sequential trs respectively 
context sensitive rewriting infinitary normalization parallel outermost strategy po proved infinitary normalizing orthogonal trss mid corollary 
po infinitary fair normalizing fair unfortunately po fair 
example consider trs mid 
note normal form 
po sequence 
delta delta delta fair redex second term derivation considered reduction placed non replacing position pos 
fact example shows general infinitary normalizing 
applied normal form behaves exactly po fair 
way ensuring normalization trss reveals important achieving behavior pure context sensitive rewriting strategies infinitary normalization 
concerning possible weaker notion fairness consider non replacing positions maximal non root stable subterms note general useful ensuring normalizing character trs ensure eventually stops giving normal form possible sh explore non replacing positions infinitary normalization ensured 
unfortunately normalizing trss normalizing strategy obtain fairness sh example consider trs note terminating 
reducible term easy see possible strategy sh sequence 
delta delta delta fair 
dealing normalizing strategies normalizing trss fairness obtained specific effort strategy strategy denote set derivations ng normal form normal form normal form normal form mrc definition results proved similar way previous ones 
theorem sigma left linear trs sigma normalizing 
normalizing strategy infinitary 
theorem sigma left linear trs sigma normalizing 
normalizing strategy fair 
theorem theorem 
corollary sigma left linear trs sigma normalizing 
normalizing strategy infinitary normalizing 
example consider trs example 
sequence delta delta delta fair 
note advantages respect po general po wasteful perform useless reductions orthogonal trss rewrites set redexes set root needed redexes see mid sr discussion question 
optimal sense reduces root needed redexes easy show due maximal replacing context reducible parts strategy jumps placed 
necessary multi step rewriting strategy general po instance context sensitive index reduction strategies section onestep strategies optimal provide optimal infinitary normalizing strategies extend computational scope 
related applications proposals syntactic replacement restrictions programming fw hm originated years ago search complete implementations lisp mcc mcc 
list processing prominent computational model lisp authors works studied implementations list constructor operator cons evaluate arguments certain stages computation 
roughly speaking corresponds imposing eventually jumping outermost non replacing positions list done strategy sh operator cons specific program build datatype list kind restriction computation thought purely syntactic symbolic 
refinement idea hw authors studied evaluation annotations structure arbitrary tuples lists 
main goal specification strictness patterns describe evaluate streams possibly infinite lists combining lazy eager styles evaluation 
difficult see arguments arbitrary function symbol list arguments done lisp way annotations lists annotate arguments symbols signature 
annotations eventually collected replacement map 
realm lisp list processing syntactic replacement restrictions explicitly implementation programming languages 
lazy functional programming different kinds syntactic annotations program strictness annotations pey global local annotations pe introduced order drive local changes basic underlying lazy evaluation strategy obtain efficient executions ben bur bur mn myc pe pey wad 
languages constructor symbols lazy arguments evaluated needed 
permits structures contain elements evaluated lead error fail terminate hpf 
number overheads implementation feature see pey lazy functional languages gofer jon haskell allow syntactic annotations arguments datatype constructors allowing immediate evaluation 
example definition haskell data list nil cons list declares type list binary data constructor cons evaluates argument note symbol argument data constructor cons 
lazy functional languages clean pe allow general annotations 
example specification bool 
true false annotated definition function forces evaluation argument call see mark type declaration called global annotation pe 
implementation annotations kind understood follows pe lazy strategy indicates argument function call evaluated 
overcome rule evaluating head normal form th argument annotated profile annotations play secondary role global execution mechanism underlying strategy assumed 
programs annotations usually obtained kind strictness analysis 
strictness analyses usually costly involve fixpoint computations cp myc wad 
case safety deviation main strategy ensured strictness analyses derived semantics functional language 
programmer allowed discouraged annotate program 
case way determine kind modification semantics computational behavior introduced annotations 
syntactic replacement restrictions utilized term rewriting referred syntactic annotations kw mar 
syntactic replacement restrictions define rewriting restrictions permit implementation lazy reductions eager rewritings transformed trs kw permit optimal reductions graph rewriting techniques mar 
proposals syntactic annotations auxiliary tool modifying computational mechanisms 
context sensitive rewriting takes symmetric approach thought mechanization syntactic annotations 
assume extra sophisticated evaluation mechanism 
luc luc analyzed computational properties confluence termination completeness computations leading infinite normal forms infinite values head normal forms constructor head normal forms csr giving solid theory computing 
knowledge analyses computational properties reductions guided kind annotations see luc detailed comparison 
methods depend source annotations strictness analyses programmer notes 
fact strictness information defining replacement map instance defining str th argument strict ensure computational properties csr example trs 
see clear correspondence str 
consider function defined strict str 

hand consider defined example 
strict second argument 

str 
note root normalized str normal form 
strictness information csr ensure root normalization terms 
contrast note general strictness adequate csr usual computational interpretation strictness annotations assumes underlying lazy strategy altered strictness annotations 
annotations play secondary role computation 
contrast syntactic annotations way activate reductions csr underlying computational mechanism assumed 
extensions csr computational frameworks investigated ferreira ribeiro extended csr ac rewriting provided methods prove ac termination fr 
luc proposed replacement maps mechanism restrict search space narrowing narrowing unification parameter passing mechanism extends functional evaluation goal solving capabilities logic programming sla 
complete implementations functional logic languages mainly narrowing aeh fri han red proven replacement maps help cut narrowing computations losing completeness evaluations luc 
far know systematic restrictions integrated setting 
hand strictness annotations functional logic languages suitable notion strictness functional logic languages available 
context sensitive rewriting evaluation strategy obj algebraic languages obj obj cafeobj fn maude admit specification local strategies associated function symbols 
show computations issued languages modeled context sensitive computations 
syntactically local strategy sequence integers parentheses operator attribute keyword strat 
example specification obj example sorts zero nznat nat list subsort zero nat subsort nznat nat op 
zero op nat 
nznat op cons nat list 
list strat op nat 
list op sel nat list 
nat var nat var list eq cons eq sel cons eq sel cons sel endo obj version trs sel sel sel notice explicit local annotations symbol cons 
lack annotations symbols sel means adopts default local strategy 
ary symbol explicit local strategy default local strategy determined requires argument places contain non variable term rule evaluated applying equations top 
difficult recognize specification local strategies trs compatible canonical replacement map local strategies serve completely guide strategy evaluation considering function call arguments indices list associated local strategy evaluated ordering specified list 
index reduction external function call attempted 
note local strategies completely determine strategy indicating modifications principal strategy 
authors give rewriting implementation evaluation strategy algebraic languages obj cafeobj 
describes implementation regular strategy assumes additional limitation admissible local strategies 
regular strategy local strategy empty ends zero contains occurrence positive integer successive occurrences zero eke 
reduction relation er implements rewrite sequences controlled regular strategy correspond contextsensitive rewriting steps local strategy explicitly implicitly associated symbol represented fi gamma 
correspondence redex position pos considered er order perform reduction step er belongs pos see 
fact normal forms normal forms 
example consider obj specification example 
local strategy cons specification default rule assigning unspecified local strategies cons symbol implementations cafeobj maude ary symbol default local strategy see eke 
means theory context sensitive rewriting study computational properties strategy 
particular ensure strategy able compute root stable forms values see luc ensure terminating behavior 
done proving normalizing strategy shown trs terminating 
instance methods developed zan possible prove example terminating 
results luc prove possible obtain value expression sort nat 
assumption regularity strategy see eke discussion possible problems regular strategies properties ensure regular strategy able completely evaluate arbitrary expressions sort nat risk infinite computations 
instance possible evaluate sel 
context sensitive rewriting evaluation strategies elan computational systems operational principle reduction functional algebraic equational programming languages theorem provers rewriting techniques incorporate predefined reduction strategy break non determinism inherent reduction relations 
elan system provides environment specifying prototyping deduction systems language rules controlled strategies 
context rewriting user defined strategies introduced elan bkk 
elan kinds rules labelled unlabelled 
operational semantics elan takes advantage differentiation evaluation term proceeds steps 
leftmost innermost reduction strategy applied attempt normalization respect unlabelled rules 
user recommended provide confluent terminating unlabelled rewrite system order ensure termination unicity result 

normalized term respect unlabelled rules tries apply labelled rule strategy described logic description 
leads possibly empty collection terms 
set empty evaluation backtracks choice point empty evaluation continues setting new choice point evaluating returned terms starting step 
description user completely control evaluation specifying adequate strategy set non labelled rules empty 
elan provides language definition strategies semantics functional style strategy considered mapping terms sets terms obtained consequence application rewriting steps indicated strategy see bkk 
application strategy term denoted 
say strategy fails elementary strategy called primal strategy mean term built constructor symbols just normal form 
rewrite rule rule considered function maps term reduct top position bkk 
different rules share label label considered mapping terms sets terms comes different rules 
elan incorporates rich suite primitive strategies operators combining see 
instance strategies symbol signature strategy defined follows bkk ae root overloaded 
particular applied sets terms ff operator applied list strategies selects strategy fail arguments returns results 
id identity strategy fails 
strategies defined means rewrite rules involving terms built preceding operators 
possible specify context sensitive rewriting strategies elan strategy 
exemplify procedure defining leftmost innermost restricted strategy 
example consider elan specification trs example symbols lists included better comprehension module module identity part standard library import local identity sort nat operators global nat nil nat nat nat nat sel nat nat global ev nat nat 
nat 
ev 

rules nat global 
rules nat nat global sel 
sel 
sel strategies nat implicit 
rli nat 
rli nat sel rli nat id sel id rli strategies implicit 
rli 
rli nat id specification corresponds leftmost innermost evaluation strategy restricted replacing redexes 
sel 
note strategy fails replacing redex available reductions 
definition easy understand see similar definition leftmost outermost reductions calculus bkk argument symbol considered sort considered reduction starting left right skipping non replacing arguments 
notice cases instance operator replacing argument strategy rli nat list associated rli 
reductions argument allowed necessary include 
similar applies component id rli needed defining rli reductions second argument allowed 
rule considered sort tried top position 
theory context sensitive rewriting study computational properties elan strategy discussion section conclude possible elan strategy obtain complete evaluation expressions sort nat entering infinite computation 
instance evaluation sel possible default unrestricted leftmost innermost evaluation strategy elan leads infinite computation 
formalized notion context sensitive rewriting strategy 
investigated definition properties context sensitive rewriting strategies strategies replacement map 
effective definition normalizing strategies relies notions root normalization root mid decidable approximations luc 
provides measure efficiency context sensitive strategies theory root needed reductions 
proven orthogonal trs admits step normalizing strategy 
orthogonal nv sequential trss strategies effectively 
shown restricted parallel outermost strategy normalizing orthogonal trs 
shown normalizing strategies defining efficient normalizing infinitary normalizing strategies 
results summarized follows left linear confluent trs normalizing strategy particular terminating trss admits step normalizing strategy assumed left linear normalizing trs admits normalizing strategy admits infinitary normalizing strategy 
cases optimality underlying strategy inherited induced normalizing infinitary normalizing strategy 
theory applied analysis computational properties evaluation strategies obj maude cafeobj elan 
author knowledge formal results analysis behavioral properties computations strategies believe contribution practical understanding languages 
conclude summarizing number results complement improve results standard theory rewriting 
refine middeldorp result non root stable term root needed redex proving correct incomplete considering replacing redexes 
means cs restrictions provide simple correct bound 

nv sequential indices proved currently best decidable approximation root see luc able refine result considering replacing nv indices suffices losing nv index approximating root needed redexes 

demonstrated proving termination trs proof infinitary normalizing nature 
research direction detailed comparison methods investigated 

theories termination root normalization defining normalizing strategies normalizing infinitary normalizing strategies set interesting link approaches probably sufficiently explored far 
problem implementing computational systems rewriting redexes pointed strong indices considered dur hl str 
unfortunately comparable effort devoted nv indices 
practice strong index reduction strategies implemented means omega gamma omega gamma identifying redexes reduced computation step 
main approaches 
describe class trss calculus strong indices simple instance weakly orthogonal left normal trss trss function constant symbols occur left variables left hand sides bn leftmost outermost redex term addressed strong index toy 
second approach provide adequate data structure able combine pattern matching operation search strong index finding redex term redex addressed strong index matching dags hl index trees dur str 
plan systematically adapt methods ease specification implementation context sensitive rewriting strategies setting 
aeh antoy hanus 
needed narrowing strategy 
proc 
st annual acm symposium principles programming languages popl pages acm press 
am antoy middeldorp 
sequential reduction strategy 
theoretical computer science 
arnold nivat 
metric space infinite trees 
algebraic topological properties 
fundamenta informaticae 
borovansk dubois kirchner kirchner 
moreau ringeissen vittek 
elan user manual version 
january 
barendregt van eekelen kennaway plasmeijer sleep 
term graph rewriting 
de bakker editors proc 
nd conference parallel architectures languages europe parle lncs springer verlag berlin 
ben benton 
strictness analysis lazy functional programs 
phd thesis university cambridge computer laboratory 
bkk borovansk kirchner kirchner 
functional view rewriting strategies semantics elan 
sato toyama editors proc 
rd fuji international symposium functional logic programming flops pages world scientific press singapore 
borovansk kirchner kirchner 
moreau ringeissen 
overview elan 
kirchner kirchner editors proc 
nd international workshop rewriting logic applications electronic notes computer science 
bn baader nipkow 
term rewriting 
cambridge university press 
bur burn 
evaluation transformers model parallel evaluation functional languages extended 
kahn editor proc 
functional programming languages computer architecture conference lncs springer verlag berlin 
bur burn 
lazy functional languages interpretation compilation 
pitman london mit press cambridge ma 
dur eker lincoln mart oliet meseguer quesada 
maude specification programming rewriting logic 
maude system documentation march 
eker lincoln meseguer 
principles maude 
proc 
st international workshop rewriting logic applications electronic notes theoretical computer science elsevier sciences 
cp clack peyton jones 
strictness analysis practical approach 

jouannaud editor functional programming computer architecture lncs springer verlag berlin 
com comon 
sequentiality second order monadic logic tree automata 
th annual ieee symposium logic computer science lics pages ieee computer society press 
der dershowitz 
termination rewriting 
journal symbolic computation 
dj dershowitz 
jouannaud 
rewrite systems 
van leeuwen editor handbook theoretical computer science volume formal models semantics pages 
elsevier amsterdam mit press cambridge ma 
dershowitz kaplan plaisted 
rewrite rewrite rewrite rewrite rewrite 
theoretical computer science 
dm durand middeldorp 
decidable call need computations term rewriting extended 
mccune editor proc 
th international conference automated deduction cade lnai springer verlag berlin 
dur durand 
bounded strongly sequential forward branching term rewriting systems 
journal symbolic computation 
eke eker 
term rewriting operator evaluation strategies 
kirchner kirchner editors proc 
nd international workshop rewriting logic applications electronic notes computer science 
em ehrig mahr 
fundamentals algebraic specification 
volume eatcs monographs theoretical computer science 
springer verlag berlin 
van eekelen plasmeijer smetsers 
concurrent clean 
language manual version 
technical report university nijmegen 
futatsugi goguen 
jouannaud meseguer 
principles obj 
conference record th annual acm symposium principles programming languages popl pages acm press 
fh field harrison 
functional programming 
addison wesley publishing 
fn futatsugi nakagawa 
overview cafe specification environment algebraic approach creating verifying maintaining formal specification networks 
proc 
st international conference formal engineering methods 
fw friedman wise 
cons evaluate arguments 
michaelson milner editors automata languages programming pages edinburgh university press 
fr ferreira ribeiro 
context sensitive ac rewriting 
narendran rusinowitch editors proc 
th international conference rewriting techniques applications rta lncs springer verlag berlin 
fri fribourg 
logic programming language interpreter clausal superposition rewriting 
proc 
nd 
ieee international symposium logic programming pages ieee press 
gierz hofmann keimel lawson mislove scott 
compendium continuous lattices 
springer verlag 
gs giesl middeldorp 
transforming context sensitive rewrite systems 
narendran rusinowitch editors proc 
th international conference rewriting techniques applications rta lncs springer verlag berlin 
goguen thatcher wagner 
initial algebra approach specification correctness implementation data types 
yeh editor current trends programming methodology vol 
iv data structuring pages prentice hall englewood cliffs nj 
goguen winkler meseguer futatsugi 
jouannaud 
obj 
goguen malcolm editors software engineering obj algebraic specification action kluwer 
goguen winkler meseguer futatsugi 
jouannaud 
obj coleman goguen editors applications algebraic specifications obj 
han hanus 
integration functions logic programming theory practice 
journal logic programming 
han hanus 
functional logic languages combine search efficient evaluation 
lloyd editor proc 
international symposium logic programming ilps mit press cambridge ma pages 
hm henderson morris jr lazy evaluator 
conference record rd 
acm symposium principles programming languages popl acm press pages 
hpf hudak peterson fasel 
gentle haskell 
yale university department computer science technical report yaleu october 
hudak peyton jones wadler 
report functional programming language haskell non strict purely functional language 
sigplan notices 
hw hall wise 
compiling strictness streams 
conference record th annual acm symposium principles programming languages popl pages acm press 
ho hoffmann donnell 
pattern matching trees 
journal acm 
hl huet evy 
call need computations linear term rewriting systems 
technical report france 
hl huet evy 
computations orthogonal term rewriting systems 
lassez plotkin editors computational logic essays honour alan robinson pages 
mit press cambridge ma 
hue huet 
confluent reductions properties applications term rewriting systems 
journal acm 

canonical forms unification 
proc 
th conference automated deduction cade lncs springer verlag berlin 
jac 
decidable approximations term rewriting systems 
ganzinger editor proc 
th international conference rewriting techniques applications rta lncs springerverlag berlin 
jon jones 
gofer 
oxford programming research group 
js jouannaud 
strong sequentiality left linear overlapping rewrite systems 
dershowitz lindenstrauss editors proc 
workshop conditional term rewriting systems ctrs lncs springer verlag berlin 
kirchner kirchner vittek 
designing constraint logic programming languages computational systems 
van hentenryck saraswat editors principles practice constraint programming 
mit press 
kw th 
walters 
lazy rewriting eager machinery 
hsiang editor proc 
th international conference rewriting techniques applications rta lncs springer verlag berlin 
ken kennaway 
sequential evaluation strategies parallel related reduction systems 
journal pure applied algebra 
ken kennaway 
conflict call need computation parallelism 
dershowitz lindenstrauss editors proc 
th workshop conditional term rewriting systems ctrs lncs springer verlag berlin 
ken kennaway 
transfinite rewriting 
international school type theory term rewriting invited survey glasgow 
klo klop 
term rewriting systems 
abramsky gabbay maibaum 
handbook logic computer science volume pages 
oxford university press 
kennaway klop sleep 
de vries 
transfinite reductions orthogonal term rewriting systems 
information computation 
km klop middeldorp 
sequentiality orthogonal term rewriting systems 
journal symbolic computation 
luc lucas 
termination context sensitive rewriting rewriting 
meyer auf der heide monien editors proc 
rd 
international colloquium automata languages programming icalp lncs springer verlag berlin 
luc lucas 
context sensitive computations functional functional logic programs 
journal functional logic programming january 
luc lucas 
root approximations 
information processing letters 
mar 
optimal derivations weak lambda calculi orthogonal term rewriting systems 
conference record th annual acm symposium principles programming languages popl pages acm press 
mcc mccarthy 
recursive functions symbolic expressions computations machine part communications acm 
mcc mccarthy 
history lisp 
wexelblat editor history programming languages academic press new york 
mid middeldorp 
call need computations root stable form 
conference record th annual acm symposium principles programming languages popl pages acm press 
mid middeldorp 
context freeness infinitary normalization 
proc 
th japanese term rewriting meeting 
nara institute science technology 
mn mycroft norman 
optimising compilation 
part ii lazy functional languages 
proc 
xix seminar current trends theory practice informatics 
moreno navarro rodr iguez artalejo 
logic programming functions predicates language babel 
journal logic programming 
myc mycroft 
theory practice transforming call need callby value 
robinet editor proc 
th international symposium programming lncs springer verlag berlin 
smetsers van eekelen plasmeijer 
concurrent clean 
aarts leeuwen rem editors proc 
parallel architectures languages europe parle lncs springer verlag berlin 
nst sakai toyama 
sequentiality left linear term rewriting systems 
rims technical report pages university kyoto 
nt toyama 
decidability left linear growing term rewriting systems 
narendran rusinowitch editors proc 
th international conference rewriting techniques applications rta lncs springer verlag berlin 
donnell 
computing systems described equations 
lncs springer verlag berlin 
donnell 
equational logic programming language 
mit press cambridge massachusetts 
donnell 
equational logic programming 
gabbay hogger robinson editors handbook logic artificial intelligence logic programming volume chapter 
oxford university press 
ogata futatsugi 
implementation term rewritings evaluation strategy 
glaser hartel editors proc th international symposium programming languages implementations logics programs plilp lncs springer verlag berlin 

nv sequentiality decidable condition call need computations term rewriting systems 
siam journal computing 
pe plasmeijer van eekelen 
functional programming parallel graph rewriting 
addison wesley reading ma 
pey peyton jones 
implementation functional programming languages 
prentice hall international london 
pla plaisted 
equational reasoning term rewriting systems 
gabbay siekmann editors handbook logic artificial intelligence logic programming volume oxford university press 
rea 
elements functional programming 
addison wesley publishing 
red reddy 
narrowing operational semantics functional languages proc 
ieee international symposium logic programming pages 
sla 
automated theorem proving theories commutativity associativity 
journal acm 
sr sekar ramakrishnan 
programming equational logic strong sequentiality 
information computation 
str 
classes equational programs compile efficient machine code 
dershowitz editor proc 
rd international conference rewriting techniques applications rta lncs springer verlag berlin 
toy toyama 
strong sequentiality left linear overlapping rewrite systems 
proc 
th annual ieee symposium logic computer science lics pages ieee computer society press 
toyama smetsers van eekelen plasmeijer 
functional strategy transitive term rewriting systems 
sleep plasmeijer van eekelen editors term graph rewriting theory practice pages john wiley sons 
wad wadler 
strictness analysis non flat domains interpretation finite domains 
abramsky hankin editors interpretation declarative languages pages ellis horwood john wiley sons 
zan zantema 
termination context sensitive rewriting 
comon editor proc 
th international conference rewriting techniques applications rta lncs springer verlag berlin 

