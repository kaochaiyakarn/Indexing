direct execution framework fast accurate simulation superscalar processors venkata krishnan josep torrellas department computer science university illinois urbana champaign il venkat cs uiuc edu cs uiuc edu multiprocessor system evaluation traditionally direct execution execution driven simulations eds 
environments processor component system fully modeled 
superscalar processors norm today multiprocessor nodes urgent need modeling processor accurately 
model superscalar processor considered open problem 
current approaches model processor interpreting application executable 
unfortunately approach slow 
propose novel direct execution framework allows accurate simulation wide issue superscalar processors need code interpretation 
achieved aid interface window front architectural simulator buffers necessary information 
eliminates need full fledged instruction emulation 
approach enables detailed fast eds superscalar processors 
evaluate framework show performance uni multiprocessor configurations 
software simulation plays integral role design validation high performance uni multiprocessor systems 
major simulation methodologies trace driven simulation tds execution driven simulation eds 
tds hardware probes software instrumentation application allow information basic block data addresses collected trace buffer application execution :10.1.1.13.6511
generated information drive simulator system study 
application may execute billions instructions reduce storage requirements traces sampling 
supported part national science foundation nsf young investigator award mip asc mip darpa contract dabt nasa contract nag gifts ibm intel 
tds effective methodology study high performance uniprocessor systems applicable multiprocessor systems 
reason systems important faithfully model interleaving memory accesses different processors 
actual interleaving depends things memory system 
trace generated existing memory system tds uses different simulated memory system tds may result incorrect interleaving traces 
area eds plays crucial role 
execution application simulation completely interleaved 
application instrumented appropriate points generate events backend simulator 
simulator called processes event 
returns control application 
method facilitates feedback simulator guide execution parallel application 
eds multiprocessor system simulators risc cisc architectures :10.1.1.13.3810
eds systems direct execution 
instrumented application executed directly host machine simulation runs 
results fast simulation 
unfortunately simulation direct execution comes price 
simulated processor model studies processor need modeled accurately 
unfortunately direct execution eds commonly multiprocessor environments main focus study memory subsystems modeling processor detail may give rise inaccurate results 
current multiprocessor systems typically complicated processors wide issue dynamic 
accurately simulating current dynamic superscalar processors direct execution considered open problem 
consequently necessary model processor simulators resort interpreting application executable :10.1.1.13.3810
results slowdowns orders magnitude 
addressing problem motivation 
contribution design evaluation novel direct execution framework allows accurate simulation advanced processor architectures uni multi processor environments incurring slowdowns approach 
achieved aid interface window front architectural simulator buffers limited instruction information 
eliminates need full fledged instruction emulation 
direct execution framework addresses need having single efficient simulation environment allows detailed modeling processor architecture uni multi processor environments 
organized follows section details simulation framework section evaluates performance section concludes 
direct execution framework processor level simulation section presents framework 
describe methodology modeling execution instruction complete view framework examine way collect statistics 
modeling instruction execution primary aim model advanced processor architectures uni multi processor environments 
way achieving interpret instruction simulated processor 
lead significant slowdowns cases :10.1.1.13.3810
approach perform limited functional emulation 
elaborate approach rest section 
instrument application generate events basic block boundaries 
tracks control flow application 
furthermore load store instructions instrumented generate events simulator 
instruction basic block need limited information change state simulated processor 
information register usage partial opcode information 
need full fledged instruction emulation 
specifically map host isa internal instruction set term isa 
isa captures full functionality native instruction set concerned different flavors instruction type 
instance combine single class alu instructions take number cycles execute simulated processor functional units simulated processor 
isa instruction represented generic alu operation registers uses 
branch delay slot scheduling undone mapping code performed 
complete set instructions shown table 
simulation framework consists modules 
front instruments directly executes executable file 
mint known system operates mips executables 
modified mint handle mips ii binaries 
conventional simple direct execution simulator events longer passed directly memory simulator back 
intercepted processor simulator 
processor simulator changes internal state instruction operations covered alu add sub set xor move shift logical arithmetic shifts md integer multiply divide unconditional branch cond conditional branch call function call ret function return ld load st store floating point add sub mov abs trunc floor floating point multiply floating point square root div 
table description instruction set 
events releases memory memory simulator 
incorporating processor simulator existing mint memory simulators extremely simple 
requirement memory simulator ability support hit handle multiple accesses cycle 
information passed modules detailed 
interface window application executed modified mint front generates trace basic block memory addresses 
processor simulator invoked event 
reasons 
simulation slow 
secondly importantly simulator consume just instruction time 
size basic block instructions integer applications wide issue advanced branch prediction schemes fetch instructions multiple basic blocks 
model permit sufficient information front gathered dictated branch prediction scheme simulated processor invoking simulator 
effect achieved interface module front processor simulator called interface window 
interface window buffers events issued front basic block memory addresses calling processor simulator 
outcome branch program known branch prediction mechanism simulated processor see predicted branch correct way 
continue filling interface window events frontend 
filling window call processor simulator 
simulator consume events window 
note processor simulator access encoded representation application contains basic block individual instruction basis limited opcode information register usage information explained 
simulator reaches mispredicted branch instruction continues executing instructions wrong path 
note basic blocks wrong path known simulator access application file 
simulator reaches point mispredicted branch resolved mint front processor simulator interface window memory simulator executable input simulator back high level view simulation framework 
simulated processor simulated pipeline flushed front invoked 
approach correctly model speculative execution simulated processor 
possible interface window filled completely reaching mispredicted branch 
typically occurs running floating point applications branch prediction close ideal 
case front stops processor simulator invoked 
window low instructions front invoked 
studies set interface window entries 
see interface window allows correct modeling different branch prediction schemes independently processor model 
addition enables instruction scheduling correct modeling speculative execution 
consider issue turn 
instruction scheduling typically application compiled run optimally host processor 
aggressive narrower issue width simulated processor 
consequently need generate appropriate instruction schedule simulated processor 
may degrade performance simulated processor especially simulating order issue completely depend compiler scheduling 
solve problem exploit fact basic blocks interface window reschedule instructions 
typical compiler superscalar vliw machine performs inter basic block code scheduling window instructions represents frequently executed path 
frequently executed path may estimated statically acquired profiles 
superblock impact compiler trace window multiflow compiler typical examples approach 
take instructions interface window perform resource constrained list scheduling instructions limited register renaming remove false dependences invoking processor simulator 
furthermore loops small bodies automatically unrolled inside window amount unrolling constrained size window 
perform compile time optimizations run time run time information load store addresses 
information branch prediction simulated processor growing window 
unfortunately compiler look huge instruction windows spanning thousands instructions perform advanced optimizations software pipelining restricted size run time interface window scheme 
approach falls short pure compiler approach scheduling 
show evaluations approach considerably improves ilp modeling order issue 
noted similar strategy adopted ultrasparc team generate code order issue ultrasparc processor 
speculative execution model speculative execution branch prediction mechanism simulated processor indicated 
allows multiple branch predictions performed pending unresolved branches 
addition realistically allows pipeline polluted instructions squashed outcome mispredicted branch known 
allows simulation proceed somewhat independently native execution application 
analysis know addresses data accessed wrongly speculated instructions 
application running mint execute instructions 
address problem perform careful analysis value registers wrongly speculated instructions cases determine data addresses 
simplify problem current setup neglect issue assume memory accesses wrongly speculated instructions hit cache pollute 
simulator framework framework quite flexible allows different processor types configurations modeled 
base processor models supported include inorder issue superscalar speculatively fetch branches order issue superscalar modeled lines mips shown 
model quite detailed incorporates superscalar features register renaming mechanism instruction cache instruction fetch unit cache data load store units floating point units branch target buffer dispatch decode rename integer registers mapping table fp registers instruction queue reorder buffer integer units architecture order issue superscalar 
cache processor cache interface network directory network memory memory memory interface processor cache cache network processor cache cache interface multiprocessor architecture 
large associative instruction queue order issue speculation multiple branches order instruction retirement 
model pipeline great detail 
scoreboard keeps track operand availability 
instruction dispatched operands ready corresponding functional unit available 
event queues speed simulation 
consider instance instruction queue 
scanning cycle possibility instruction changes status 
example load instruction misses cache causes dependent instructions clog instruction queue skip checking instruction queue load data available 
framework uses superscalar core building block model advanced processor architectures chip multiprocessor cmp multiple superscalar cores share single chip simultaneous multithreaded smt processor adds multiple threads superscalar allows instructions different threads issued cycle hybrid architectures supports smt processors single chip 
varying parameters number chip processors number threads smt processor model different architectures 
model multiprocessor system node system processor types 
memory subsystem uniprocessor conventional cache hierarchy multiprocessor system supports directory cache coherence protocol 
processor memory subsystem parameters specified startup time modeling machine table 
statistics collection simulator allows detailed statistics collection cycle thread processor 
processor gather statistics issue slot basis 
total number slots product total number cycles taken application maximum issue rate 
wasted non useful slots classified type hazard prevented slot 
different categories hazards lack functional units structural memory access memory data dependences data branch mispredictions control 
addition executing parallel applications threads spin barriers locks sync 
category frequent events running renaming registers 
order issue processor hazard type responsible unfilled slots cycle uniquely identified 
extension needs running multiple threads order issue smt processors 
threads compete issue slot assign non useful slots proportionally 
example consider threads issue smt processor 
assume cycle slots filled useful instructions 
total wasted slots cycle 
assume threads issue instructions say stalled memory accesses stalled data hazard remaining issue structural hazard 
statistics assign non useful slots different reasons proportional basis 
formula type total threads wasted wasted theta stalled total threads slots slots reason example wasted slots assigned follows theta memory slots theta parameter processor type number processors chip cmp level threads processor smt level issue mechanism issue policy order order issue width dynamic issue mechanism renaming registers instruction queue entries branch prediction correlating prediction table entries misprediction penalty cycles functional units int load store fp number units type instructions handled instruction latency repeat rate non pipelined units multiprocessor support number processing nodes memory related number outstanding loads stores cache size associativity block size banks local remote memory latency table sample simulation parameters specified startup time 
data slots theta structural slots 
order issue processor usually impossible attribute hazard type cycle 
scan instruction queue cycle record type hazard faced instruction unable issue 
addition processor threads threads 
wasted slots divided proportionally different types hazards 
features framework ability dynamically turn simulation 
allows sampling regular intervals 
selectively turn processor simulator allowing memory memory back 
particularly helpful running parallel applications initialization phase need processor simulated caches program enters parallel section 
additionally allows development testing memory back independently processor simulator 
evaluation complete framework implemented lines code 
accuracy speed kept mind implementation 
interpretation simulations simulator validated results produced application simulations direct execution difficult validate model timing aspect application 
mitigate problem implemented simulator executed different modes safe mode assertions added stage fast mode disables checking 
safe mode validates implementation processor model course execution 
mode set sample inputs fast mode experiments 
evaluate framework uni multiprocessor environment 
evaluation uniprocessor environment performed specint com press ijpeg multimedia mpeg specfp swim tomcatv hydro mgrid applications 
splash radix cholesky applications evaluate multiprocessor environment 
applications compiled mips processor highest level optimization mips option 
mips simple single issue processor 
want model aggressive architecture reschedule instructions interface window 
architecture modeled way dynamically statically scheduled superscalar processor 
value architectural parameters specified table 
processor entry direct mapped correlating branch prediction table allows multiple branch predictions cycle 
functional units fully pipelined instructions cycle complete 
exceptions follows integer multiply divide take cycles respectively floating point multiply takes cycles divide takes single precision double precision cycles 
processor outstanding memory accesses half loads 
characteristics memory hierarchy shown table 
issue number entries number width funct 
units instruction renaming regs 
int ld st fp queue int fp table characteristics superscalar processor 
parameter value size kbytes line size bytes associativity way way banks latency cycles latency cycles memory latency cycles table characteristics memory hierarchy 
latencies refer round trips 
perform sets experiments 
measure ipc increases result performing instruction scheduling interface window described section 
evaluate slowdowns result simulator incorporated exec 
time breakup structural memory data control useful ipc compress ijpeg mpeg swim tomcatv hydro mgrid ipc execution time breakup way order issue superscalar real memory system 
mint front 
experiments include processor simulator memory backend simulator 
done isolate slowdowns caused processor simulator 
interface window scheduling see impact rescheduling instructions interface window described section simulate statically scheduled processor instruction rescheduling 
table shows average ipc applications instruction rescheduling 
table sets data assuming memory system characteristics table real memory system data accesses hit level caches ideal memory system 
table see rescheduling ipc increases applications memory systems 
increases range average 
instruction rescheduling interface window effect order issue processors 
processor hardware aggressively reorders instructions 
result ipc changes negligible 
shows ipc order issue superscalar real memory system table 
average ipc 
shows detailed breakup total execution time terms different categories mentioned section 
provides valuable information identifying performance bottlenecks 
instance large data contribution loop intensive floating point applications highlights need software pipelining 
slowdowns uniprocessor multiprocessor simulation section evaluate slowdown simulator modeling uni multi processor system 
isolate slowdowns caused processor simulator include memory back experiments 
original mint version enhanced processor simulator linked empty memory back functions 
application report average time taken runs 
measurements ideal memory system application ipc 
ipc 
compress ijpeg mpeg swim tomcatv hydro mgrid average real memory system application ipc 
ipc 
compress ijpeg mpeg swim tomcatv hydro mgrid average table impact ilp enhancing instruction way order issue superscalar node sgi mips processors 
columns table give slowdown mint modeling issue static dynamic 
table see slowdown varies widely applications 
average slowdown experiments 
application mint mint native static dynamic compress ijpeg mpeg swim tomcatv hydro mgrid average table slowdowns empty memory back simulating way static dynamic superscalar 
column shows mint slowdown native execution applications 
mint reported slowdown 
application number nodes mint mint mint mint radix cholesky table slowdown simulating multiprocessor configuration way dynamic superscalar 
mint represents time taken mint single node configuration 
applications quite different 
case see slowdowns range 
factoring full simulator times slower native execution 
contrast time slowdowns systems mxs processor simulator simos 
addition processor simulator independent front flexibility faster front shade utilizes dynamic compilation caching improved performance 
examine slowdowns simulator simulating multiprocessor configuration node way dynamic superscalar 
parallel applications radix cholesky purpose 
table gives results 
columns table show slowdown mint simulator relative simulation single node original mint simulator 
recall experiments empty back memory simulator 
expected slowdown increases processors 
importantly column ratio previous columns 
shows slowdown system relative mint number processors 
see slowdowns increased relative uniprocessor slowdowns table 
high 
numbers vary little different numbers processors 
indicates simulator scales quite efficiently number processors 
tds typically evaluate highperformance uniprocessor systems 
applicable multiprocessor systems require eds model exact interleaving memory accesses 
common approach modeling systems direct execution eds 
system model superscalar processors long considered open problem 
consequently existing schemes resort application code interpretation results extremely slow simulations 
proposed evaluated novel approach eds modeling advanced processor architectures uniprocessor multiprocessor setup 
evaluations showed model processor great detail resorting application code interpretation time achieve fast simulations 
acknowledgments referees members group valuable feedback 
greatly appreciate matt reilly comments substantially improved earlier version 
josep torrellas supported part nsf young investigator award 

critique trace driven simulation sharedmemory multiprocessors pages 
kluwer academic publishers editors dubois may 
brewer dellarocas weihl 
proteus high performance parallel architecture simulator 
technical report mit lcs tr mit laboratory computer science september 
chang mahlke chen water hwu 
impact architectural framework issue processors 
th international symposium computer architecture pages may 
davis goldschmidt hennessy 
multiprocessor simulation tracing tango 
international conference parallel processing pages ii august 
wood hill kessler 
model estimating trace sample ratios 
acm sigmetrics conference measurement modeling computer systems pages may 
dwarkadas jump sinclair 
execution driven simulation multiprocessors address timing analysis 
acm transactions modeling computer simulation october 
hammond olukotun 
single chip multiprocessor 
ieee computer september 
krishnan torrellas 
clustered approach multithreaded processors 
th international parallel processing symposium ipps april 
lam 
software pipelining effective scheduling technique vliw processors 
sigplan conference programming language design implementation pages june 
lee potkonjak mangione smith 
mediabench tool evaluating synthesizing multimedia communications systems th international symposium microarchitecture micro pages december 
lenoski laudon gharachorloo gupta hennessy 
directory cache coherence protocol dash multiprocessor 
th international symposium computer architecture pages may 
lowney freudenberger lichtenstein nix donnell 
multiflow trace scheduling compiler 
journal supercomputing may 
mips technologies microprocessor chipset product overview 
muchnick 
advanced compiler design implementation 
morgan kaufmann 
mukherjee reinhardt litzkow hill larus wood 
wisconsin wind tunnel ii fast portable parallel architecture simulator 
workshop performance analysis impact design paid held conjunction isca june 

nguyen michael sharma torrellas 
multiprocessor simulation toolkit intel architectures 
international conference computer design pages october 
pai ranganathan adve 
execution driven simulator ilp shared memory multiprocessors uniprocessors 
proceedings third workshop computer architecture education february 
pai ranganathan adve 
impact instruction level parallelism multiprocessor performance simulation 
proceedings third international symposium high performance computer architecture pages february 

pan 
improving accuracy dynamic branch prediction branch correlation 
th international conference architectural support programming languages operating systems asplos pages september 

yew 
execution driven tools parallel simulation parallel architecture applications 
proceedings supercomputing pages november 
kessler hill wood 
comparison trace sampling techniques multi megabyte caches 
ieee transactions computers june 
cmelik keppel 
shade fast instruction set simulator execution profiling 
acm sigmetrics conference measurement modeling computer systems pages may 
rosenblum herrod witchel gupta 
complete computer system simulation simos approach 
ieee parallel distributed technology systems applications winter 
smith 
tracing pixie 
technical report csl tr center integrated systems stanford university november 
srivastava eustace 
atom system building customized program analysis tools 
sigplan conference programming language design implementation pages june 
conte hwu 
systematic prototyping superscalar computer architectures 
rd ieee international workshop rapid system prototyping june 
torrellas gupta hennessy 
characterizing caching synchronization performance multiprocessor operating system 
th international conference architectural support programming languages operating systems asplos pages october 
tremblay 
design microarchitecture ultrasparc 
proceedings ieee december 
tullsen eggers emer levy lo 
exploiting choice instruction fetch issue implementable simultaneous multithreading processor 
rd international symposium computer architecture pages may 
uhlig nagle stanley mudge brown 
design tradeoff software managed tlbs 
acm transactions computer systems august 
veenstra fowler 
mint front efficient simulation shared memory multiprocessors 
mascots pages january 
wall 
limits instruction level parallelism 
th international conference architectural support programming languages operating systems pages april 
woo singh gupta 
splash programs characterization methodological considerations 
nd international symposium computer architecture pages june 
yeh patt 
alternative implementations twolevel adaptive branch prediction 
th international symposium computer architecture pages may 
