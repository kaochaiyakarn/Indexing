syntactic approach type soundness andrew wright matthias felleisen department computer science rice university houston tx june rice technical report tr appear information computation new approach proving type soundness hindley milner style polymorphic type systems 
keys approach adaptation subject reduction theorems combinatory logic programming languages rewriting techniques specification language semantics 
approach easily extends polymorphic functional languages imperative languages provide exceptions continuations similar features 
illustrate technique type soundness theorem core standard ml includes type soundness proof polymorphic exceptions continuations 
type soundness static type systems programming languages attempt prevent occurrence type errors execution 
definition type error depends specific language type system includes function arguments defined attempted application non function 
static type system sound typed programs cause type errors programming language sound static type system strongly typed 
easy design sound type system explicitly typed monomorphic language formulation sound type system language hindley polymorphism type inference delicate :10.1.1.12.9871
treatment purely functional languages relatively understood framework incorporation imperative features exceptions requires extreme care soundness systems obvious 
formal proof soundness research supported part united states department defense national defense science engineering graduate fellowship nsf ccr texas arp atp 
syntactic type soundness required lend credibility claim system prevents type errors may crucial tool design type system 
view static type system implicitly typed language filter selects typed programs larger universe untyped programs 
partial function eval programs answers defines semantics untyped programs 
result wrong returned programs evaluation causes type error eval undefined programs evaluation terminate 
mean type system assigns program type typed 
simplest soundness property states typed programs yield wrong 
definition weak soundness eval wrong 
weak soundness establishes static type system achieves primary goal preventing type errors possible demonstrate stronger property relates answer produced type program 
view type denoting different subsets set answers strong soundness states answer produced terminating program type element subset definition strong soundness eval strong soundness permits implementation language associate representation value type omit representation tags required dynamically typed languages 
weak soundness follows strong soundness wrong member type significant effort invested proving type soundness hindley milner style type systems practical realization programming language standard ml 
soundness proofs exist functional fragment extensions including monomorphic language including class continuations :10.1.1.12.9871:10.1.1.54.5309
drawbacks existing proofs 
proofs type soundness sensitive precise formulation semantics language different techniques required denotational versus operational formulations semantics different languages semantic framework 
proofs different languages difficult reconcile prove soundness language including features 
existing techniques complicated resulting proofs lengthy error prone 
illustration difficulties proofs refer reader tofte discussion damas faulty proof type soundness theorem polymorphic language 
simple approach proof soundness hindley milner style polymorphic type systems 
approach subject reduction classical result combinatory logic rewriting means specifying operational semantics 
demonstrate approach develop proof soundness core standard ml extends functional polymorphic language exceptions 
show soundness extension standard ml class continuations 
principle approach uniformly applicable language mitchell harper refer functional polymorphic sublanguage essence ml 
difficulties typing exceptions fact expressed facilities functional core indicate equally important :10.1.1.12.9871:10.1.1.54.5309
syntactic type soundness practice resulting proofs lengthy simple requiring ordinary inductive techniques 
section describe prototypical functional language polymorphic type system discuss various approaches previously prove type soundness 
section presents essence approach proving type soundness remaining sections develop illustrative proofs type soundness specific functional language various extensions 
previous approaches proving type soundness proof type soundness intimately tied formulation semantics language 
earlier proofs relied denotational semantics proofs structural operational semantics 
subsections briefly approaches historical perspective 
third subsection discusses problems 
brief formulation hindley milner style type systems order introduce notation 
prototypical functional language syntax var const 
constants const include data integer real boolean operations xi 
variables var lexically scoped 
juxtaposition denotes application left associative expressions construct call value procedural abstractions 
semantically expression behaves binding value type system allows polymorphic different occurrences may assigned different types 
polymorphic type system language types form ground types int bool 
type system formulated deductive proof system assigns types expressions 
proof system produces type judgments form gamma meaning expression type type environment gamma 
type environments finite maps variables types give types open expressions 
typing rules gamma gamma var gamma typeof const gamma 
gamma abs gamma gamma gamma app gamma gamma 
gamma syntactic type soundness function typeof assigns types constants 
gamma 
denotes functional extension update map gamma 
means capture avoiding substitution programs closed expressions 
program typed type empty type environment write proofs denotational semantics milner milner formulated proved type soundness theorem functional language denotational semantics language untyped expressions 
semantic domain solution reflexive domain equation phi phi phi phi basic domains bottom integers booleans function domain domain consisting single element wrong phi separated sum builds continuous functions 
meaning function constructed assign denotation wrong programs result type errors 
assign meanings expressions free variables meaning function takes environment ae var ffi gamma 
finite map variables denotational values 
establish soundness milner introduced semantic relation 
relation identifies type ideal domain 
ideal simply subset domain closed certain operations subset upper bounds finite consistent subsets basic domains forms ideal 
denotational value possesses type written member ideal corresponding iff environment ae respects type environment gamma written ae gamma domain ae large domain gamma variable domain gamma ae gamma 
semantic soundness theorem states expression type type environment gamma environment ae respects gamma denotation ae possesses type theorem semantic soundness gamma ae gamma ae theorem proved induction structure strong soundness follows restricting theorem closed expressions 
theorem strong soundness weak soundness consequence fact wrong possess type 
theorem weak soundness wrong 
syntactic type soundness damas damas extended milner results language cells destructive assignment 
proof technique derived milner technique proof significantly complicated 
denotational semantics uses domain construction phi phi phi phi phi omega 
domain locations flat domain natural numbers domain stores sequences values omega smash product 
procedures take input value store produce result new store 
meaning function parameterized store environment 
due presence stores types longer ideals finite maps store typings subsets store typing finite map locations types values stored 
semantic relation involve types values store longer defined induction types existence established category theoretical argument generalizes technique inclusive predicates 
complexity semantic relation complicates proof tofte mistake damas proof theorem thought false page 
abadi cardelli pierce plotkin abadi demonstrate type soundness functional language dynamic type related operations 
proof respect denotational semantics similar milner proof complicated presence dynamic values 
dynamic value pair consisting value tag drawn set typecode encodes type domain equation includes domain dynamic values phi phi phi phi phi typecode theta type codes correspond types denotation type code type 
types turn denote ideals due unusual element domain equation establishing types denote ideals requires extending ideal model recursive types 
proof required fixed points exist new model involves metric space argument straightforward extension original 
type system abadi polymorphic possible extend type system soundness proof include polymorphism 
duba harper macqueen duba languages extending monomorphic functional core class continuations spirit scheme 
describe approaches proving type soundness languages 
simplification reader interested precise definition referred damas thesis 
syntactic type soundness respect continuation passing denotational semantics domain equations phi phi phi phi phi domain continuations domain answers 
meaning function takes environment continuation 
semantic relations state means value possess type written continuation accept value type written relations defined simultaneously induction types 
semantic soundness theorem states expression type type environment gamma ae respects gamma continuation accepts values type meaning environment ae continuation wrong 
theorem semantic soundness gamma ae gamma ae wrong purely functional setting semantic soundness theorem states typed programs go wrong weak soundness produce answers expected type 
approach strong soundness duba give argument continuation passing style cps translation simply typed calculus 
programs ground type denotation expression denotation cps transform identity function initial continuation cps strong soundness holds simply typed calculus cps type programs ground type strong soundness holds programs ground type 
argument extend higher types 
details refer reader page 
proofs structural operational semantics tofte tofte reformulated milner functional language structural operational semantics 
semantics specified deductive proof system deduction states expression evaluates value environment value environment finite map variables operational values 
values basic constants closures result evaluation expressions 
soundness theorem requires definition semantic relation operational values types 
basic constants relation explicitly specified function typeof closures relation defined induction types evaluation correctly typed argument values 
semantic soundness theorem states expression type type environment gamma environment respects gamma evaluates value environment possesses type theorem semantic soundness gamma gamma syntactic type soundness proof straightforward proceeds induction depth deduction strong weak soundness follow 
tofte turned structural operational semantics order consider 
reformulated semantics form meaning environment store expression evaluates value new store semantic relation involves contents store store typing st map locations types values stored 
semantic relation st may read st typed store value possesses type possibility cycles store relation definable induction defined maximal fixed point monotonic operator appropriate space 
semantic soundness theorem states expression type type environment gamma store type st environment respecting gamma evaluates store typing st possesses type theorem semantic soundness gamma st gamma exists st st theorem proved induction depth deduction lemmas involving semantic relation proved technique induction milner tofte developed purpose 
leroy weis successfully applied tofte technique show soundness different type system polymorphic 
talpin jouvelot applied technique demonstrate soundness system infers types effects regions 
duba harper macqueen duba proof type soundness respect structural operational semantics monomorphic language continuations 
proof adaptation tofte technique semantics significantly restructured technique represent flow control explicitly 
semantics judgment forms 
kind indicates expression evaluates answer environment continuation second kind indicates continuation evaluated value produces answer denotational case semantic relations defined indicating means value possess type continuation accept type 
denotational case theorem establishes weak soundness 
theorem semantic soundness gamma gamma wrong clear proof goes presence fixed point operators page obtain strong soundness framework 
discussion case proof soundness language different formulation language semantics involves different proof technique 
techniques syntactic type soundness unrelated provide guidance proving soundness new languages language features 
seemingly minor extension language may require complete restructuring denotational structural operational semantics may require completely new approach re establish soundness 
example introducing milner functional language damas changed domain equations denotational semantics accommodate store component necessitating completely different strategy induction 
introducing type dynamic abadi changed domain equations extended ideal model types match 
accommodate continuations duba changed domain equations foregoing tools developed milner damas 
separate argument establish strong soundness 
introducing operational formulation functional language tofte changed form judgments obtained semantics technique induction establish proof 
continuations structural operational semantics duba completely altered semantics changing structure proof dramatically 
proofs considers language single extension functional core 
natural ask extensions merged natural union type systems sound 
proofs involves different technique generally impossible merge proofs 
tofte proof duba proof continuations give direct assurance standard ml type system sound features standard ml ignored 
syntactic approach proving type soundness approach type soundness operational formulation language semantics rewriting 
intermediate state evaluation program program evaluation program performed successive reductions new state gamma 
gamma 
reduction may continue forever may reach final state evaluation possible gamma 
gamma 
final state represents answer type error 
proving type soundness reduces proving typed programs yield typed answers 
programming language calculi calculus natural choice specify semantics language intermediate step evaluation program 
plotkin shows semantics prototypical functional language relates calculus 
calculi extensions state extend strategy languages similar constructs 
likewise control calculi adapted address non local control facilities exceptions class continuations 
intermediate states evaluation programs may apply type system deduce type state 
strategy proving type soundness rests fundamental observations types states 
observation intermediate state may assigned type original program reductions preserve type furthermore take evidence addition continuations standard ml substantial change incremental modification language page 
believe indicates problem semantic framework 
syntactic type soundness gamma 
combinatory logic property known subject reduction 
second observation sound type systems assign type irreducible expressions sources type errors true 
furthermore expression containing subexpression untypable call expressions containing irreducible subexpressions faulty faulty observations imply final states reached typed program typed answers 
definition eval takes faulty expressions wrong type system weakly sound 
answers produced typed programs subject reduction establishes strong soundness 
state answer lies correct subset values employ type system iff yields soundness theorem syntactic connection answers types gamma 
strong soundness follows definition eval takes faulty expressions wrong 
summary proving syntactic soundness theorem involves ffl demonstrating subject reduction ffl characterizing answers faulty expressions ffl showing faulty expressions untypable 
structure proof remains language includes combination exceptions continuations features 
related curry feys introduced notion subject reduction combinatory logic 
language combinatory logic cl term deduction concluding called subject type called predicate 
subject reduction states reduction subject deduction preserves predicate 
subject reduction holds terms cl calculus 
mitchell plotkin type preservation theorem subject reduction variant second order polymorphic calculus 
language explicitly typed declarations proof type preservation significantly simpler presence declarations 
develop type soundness theorem 
abadi give proof soundness type dynamic respect structural operational semantics addition denotationally proof 
structural syntactic type soundness operational semantics substitutions carried immediately expressions evaluate closures judgments contain environment component 
answers syntactic values type system applied answers show evaluation preserves typing 
proof similar proof subject reduction extension continuations apparently involves difficulties tofte duba proofs 
road map sections illustrate approach proving soundness languages 
section considers functional language similar considered milner 
section considers extension extension exceptions shows results may merged consider language 
knowledge proof soundness exceptions 
section illustrates soundness extension providing firstclass continuations proof strong type soundness continuations polymorphic language 
conclude discussion technique suggestions application languages 
functional ml functional ml applicative language constants call value higher order functions hindley milner style polymorphic type system 
natural basis calculus functional ml plotkin untyped calculus 
var denumerable set variables const set constants 
expressions values functional ml expressions values var const 
free variables fv bound variables expression defined usual expressions binding variables 
expression binds bindings recursive 
fixedpoint combinator provides recursion 
barendregt adopt convention bound variables distinct free variables distinct expressions identify expressions differ consistent renaming bound variables 
set values free variables 
semantics calculus functional ml relations called notions reduction gamma 
ffi ffi defined ffi gamma 

fi gamma 

gamma 
syntactic type soundness precise set constants assume existence partial function ffi const theta interprets application functional constants closed values yields closed values 
fi reductions substitution notation 
means substitution free occurrences renaming bound variables necessary avoid capture 
reduction introduces abstraction applied value appear free variable conventions 
refer union relations simply gamma 
danger confusion 
notion reduction gives rise system reductions gamma 
relation gamma 
reflexive transitive compatible closure gamma gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
context expression subexpression replaced hole denoted 
expression results placing expression hole operation may involve capture free variables equational system may constructed congruence closure plays role 
appropriate choice ffi calculus satisfies church rosser standardization properties proofs variants plotkin proofs calculus 
standardization know expression reduces value precisely reduction leftmost outermost redexes outside abstractions leads value 
idea calculus define evaluation function 
gamma 
relation gamma 
iff gamma 
gamma 
special contexts evaluation contexts ensure leftmost outermost reduction applicable reduction entire program 
evaluating left right application consistent standard ml 
contexts possibility capture placing expression hole evaluation context hole appear inside binding construct 
gamma 
reflexive transitive closure gamma 
partial function eval defined closed expressions eval iff gamma 
eval easy see decomposition program redex evaluation context unique 
follows stepping relation gamma 
function eval function 
syntactic type soundness typing type system deductive proof system assigns types expressions 
types functional ml ff types ground types basic constants int bool real ff ranges denumerable set type variables 
type variables stand fixed unknown type 
function types right associative 
polymorphic type system allows certain variables set different types 
example identity function bound variable may function type int int applied values type int may function type bool bool applied values type bool 
type schemes represent sets types ff means zero distinct type variables oe ff free type variables ftv oe type type scheme defined usual ff ff binds ff ff identify type schemes differ consistent renaming bound type variables reordering binding occurrences 
identify types may regarded type schemes bound type variables 
type scheme ff ff represents set types may obtained substituting ff ff formalized notion generalization type scheme oe generalizes type written oe substitution bound variables oe yielding substitution partial function type variables types 
substitution may applied type obvious way write substitution type schemes respects bound type variables capture avoiding 
generalization type defined ff ff iff dom fff ff 
generalization extended type schemes oe oe iff oe oe examples ff ff ff int int ff ff ff ff int bool ff ff ff ff ff ff ff ff ff ff ff ff generalization partial order type schemes 
order assign types open expressions assumptions types free variables provided type environments denoted gamma 
type environments finite maps variables type schemes 
free type variables ftv gamma type environment syntactic type soundness gamma gamma var gamma typeof const gamma gamma 
gamma abs gamma gamma gamma app gamma gamma 
close gamma gamma close gamma ff ff fff ff ng ftv ftv gamma typing rules functional ml free type variables type schemes range 
stating proving various lemmas convenient define substitution type environments pointwise fhx oe hx oe ig fhx soe hx soe ig 
function typeof const associates type scheme constant 
precisely specified set constants functional ml really class languages parameterized set const functions ffi typeof just standardization church rosser properties restrict admissible set ffi functions particular choice const ffi typeof satisfy typability condition type soundness hold 
typeof ffi defined ffi ffi typability condition requires ffi defined constants functional type arguments matching type restricts set results ffi may produce 
rules moment functional constants division defined values input type 
type judgment gamma expression functional ml deduction constructed inference rules 
judgment gamma read type environment gamma expression type 
type environment judgment empty write expression typed program closed judgment formulation typing rules rule applicable expression 
deduction assigning expression specific type deduction unique 
permits proofs induction structure deduction type judgment proceed case analysis structure expression type judgment 
type system important property algorithm determine expression type 
type environment expression algorithm computes substitution type 
algorithm sound respect syntactic type soundness type system meaning infers valid typings 
theorem soundness milner gamma succeeds gamma algorithm complete meaning expression valid typing algorithm find typing 
furthermore algorithm terminates 
theorem completeness damas milner gamma gamma succeeds exists gamma gamma close gamma gamma succeed stops fail 
proving completeness involves demonstrating expression type principal type substitution instances 
theorem principal typing gamma exists gamma gamma close gamma type principal gamma 
existence sound complete algorithm establishes decidability type system 
solely property type system says relation type system semantics language 
type soundness proof type soundness rests notion subject reduction 
subject reduction property states reductions preserve type expressions 
lemma extends subject reduction functional ml 
subject reduction sufficient type soundness 
addition prove programs containing type errors typable 
put differently expression irreducible due type error say type system able assign type expression 
typed program reduce expression violating subject reduction cause type error occur 
call expressions type errors faulty expressions prove faulty expressions typed 
obvious facts deductions ado gamma exist gamma gamma ii gamma gamma gamma gamma follow facts exactly inference rule expression form inference rule requires proof subexpression expression 
facts generalization follow definition close oe oe close gamma 
oe close gamma 
oe ii dom gamma close gamma close gamma 
oe 
lemma states extra variables type environment gamma judgment gamma free expression may ignored 
syntactic type soundness lemma gamma gamma fv gamma iff gamma key lemma proof subject reduction functional ml extensions replacement lemma adapted hindley seldin page 
allows replacement subexpressions typable expression subexpression type disturbing type expression 
lemma replacement deduction concluding gamma ii concluding gamma iii occurs position corresponding hole iv gamma gamma proof 
think deductions trees root 
deduction concluding gamma cut subtree replace replace relevant occurrences resulting tree resulting tree valid deduction concluding gamma may shown induction height tree page 
subject reduction functional ml states reductions preserve type 
main lemma subject reduction gamma gamma 
gamma proof 
proof proceeds case analysis reduction gamma 
case gamma 
ffi 
gamma gamma follow gamma app 
gamma ffi ffi typability condition 
case gamma 


gamma 
gamma gamma app 
gamma 
follows abs 
gamma 
lemma 
case gamma 


gamma gamma gamma 
close gamma 
close gamma ff ff fff ff ftv ftv gamma gamma 
lemma 
case gamma 

gamma app gamma gamma gamma 
lemma gamma 

app gamma abs gamma app 
syntactic type soundness completes essence proof 
remains establish lemmas 
substitution lemma key showing type preservation reductions involving substitution 
lemma substitution gamma 
ff ff dom gamma gamma fff ff ftv gamma gamma 
proof 
proceed induction length proof gamma 
ff ff case analysis step 
case typeof const gamma const 
gamma 

case gammax var gamma var 
gamma 

var gamma 
ff ff ff ff find substitution domain fff ff gamma lemma gamma gamma dom ftv gamma gamma gamma 

gamma 
case abs follows assumption gamma 
ff ff gamma 
ff ff 
gamma 

ff ff choose substitution fff ff fff ff ff ff ff ff ftv gamma distinct 
gamma 

ff ff lemma gamma 
lemma ftv gamma 
fff ff choice 
gamma 

inductive hypothesis 
bijection gamma exists gamma gamma 

gamma lemma gamma 

gamma 
abs gamma 

syntactic type soundness case 
gamma 
ff ff 
premise app gamma 
ff ff gamma 
ind hyp 
second premise app gamma 
ff ff gamma 
ind hyp 
app gamma 


gamma 

case premise gamma 
ff ff gamma 
ind hyp 
second premise gamma 
ff ff 
close gamma 
ff ff gamma 
close gamma 
ff ff 
ff ff gamma gamma 
close gamma 
ff ff lemma 
fff ff ftv gamma 
close gamma 
ff ff fff ff ftv gamma ftv close gamma 
ff ff fff ff ftv close gamma 
ff ff fff ff ftv ftv ftv gamma 
ff ff fff ff ftv ftv gamma 
ff ff fff ff ftv gamma ftv ff ff fff ff ftv ff ff fff ff ftv fff ff inductive hypothesis gamma 
close gamma 
ff ff 
gamma 
close gamma 
lemma gamma 

gamma 

lemma establishes typing stable substitution 
syntactic type soundness lemma gamma substitution gamma proof 
proof proceeds induction length proof gamma case analysis step 
proof adaptation tofte proof similar lemma lemma 
lemma shows generalizing type variable type environment impact deduction 
lemma gamma 
oe oe oe gamma 
oe proof 
proof proceeds induction length proof gamma 
oe case analysis step 
proof adaptation damas milner proof similar lemma lemma 
interesting case case expressions 
case premise gamma 
oe gamma 
oe ind hyp 
second premise gamma 
oe 
close gamma 
oe gamma 
oe 
close gamma 
oe ind hyp 
gamma 
oe 
close gamma 
oe ind hyp 
gamma 
oe 
corollary subject reduction standard reduction steps preserve type 
corollary gamma gamma 
gamma proof 
gamma 
gamma 
gamma replacement lemma 
result follows induction length reduction sequence gamma 
subject reduction ensures start typable expression reach untypable expression sequence reductions 
yield type soundness 
subject reduction simply ensures properties implied typability preserved reduction 
critical property seek evaluation typable expression get stuck 
definition stuck expressions evaluation expression stuck value gamma 
course expression eventually reduces stuck expression decidable property 
approximate set expressions stuck set faulty expressions 
syntactic type soundness definition faulty expressions faulty expressions functional ml expressions containing subexpression ffi undefined 
idea faulty expression may stuck property reduces faulty expression conservative approximation reduces expression stuck 
faulty expressions superset stuck expressions 
example expression true faulty subexpression true stuck reduces 
behavior evaluation summarized lemma 
mean diverges gamma 
gamma 
exists gamma 
lemma uniform evaluation closed gamma 
faulty gamma 
proof 
induction length reduction sequence need show faulty gamma 
closed value 
definition gamma gamma 
iff gamma 

recall 
proceed induction structure case value 
case closed case occur 
case inductive hypothesis cases consider 
faulty faulty 
gamma 
gamma 

value gamma 


case 
inductive hypothesis cases consider 
faulty faulty 
gamma 
gamma 

value 
inductive hypothesis subcases consider 
faulty faulty 
gamma 
gamma 

values possibilities summarized follows gamma 
faulty gamma 
faulty gamma 
faulty theta gamma 
gamma 
gamma 
theta gamma 
gamma 
gamma 
theta theta theta theta theta cases marked theta occur expression closed 
cases marked gamma 
indicate combination reduces 
relate faulty expressions typability show faulty expression typable 
syntactic type soundness main lemma faulty expressions untypable faulty gamma gamma proof 
suffices show subexpressions cause faulty untypable 
general proceed case analysis form subexpression functional ml case 
suppose faulty gamma app gamma gamma ffi typability condition ffi defined contradicts assumption faulty 
faulty expressions untypable type preservation property reduce faulty expression implied typability 
theorem syntactic soundness gamma 
proof 
uniform evaluation gamma 
faulty gamma 
subject reduction implies suppose gamma 
faulty 
faulty expressions untypable contradiction case occur 
gamma 
state strong weak soundness theorems definition evaluation differentiates programs diverge cause type errors 
answers values special result wrong define eval eval wrong gamma 
faulty gamma 
eval programs cause type error return special answer wrong 
strong weak soundness corollaries syntactic soundness 
theorem strong soundness eval theorem weak soundness eval wrong 
exceptions functional facilities class exceptions important core programming facilities standard ml similar languages 
section consider extensions functional ml 
subsection deals ml extension functional ml 
uses previous calculus state particular cell oriented variant 
second subsection addresses exception ml extension functional ml exceptions 
uses modified version control calculus especially fragment prompts 
final subsection presents core ml includes exceptions 
type preservation guarantee type soundness 
consider trivial type system type subtype type 
type preservation holds expression assigned type 
system prevent type errors rejects expressions 
syntactic type soundness ml extending calculus calculus functions requires extending syntax new kind expression new values underlined ae expressions ref values hx vi expression hx binds represents finite function variables values treat set pairs components distinct 
identify ae expressions differ consistent renaming bound variables 
values ref familiar operations ml 
application ref value creates cell containing value 
application cell returns value contained cell 
binary assignment operator evaluates operands evaluate cell assigns value second operand cell 
operations curried application assignment operator variable value 
specifically expression may thought capability assign cell ae expression semantically abbreviation expression hx ref ref arbitrary values right type 
order simplify semantics treat 
intuitively ae expression plays role store fragment reduction program imperative assignment statements 
cell represented variable pair hx vi ae expression indicates cell contains value semantics addition reductions reductions ref gamma 
vi ref ae hx vi 
gamma 
ae hx vi deref ae hx gamma 
ae hx assign ae ae gamma 
ae ae merge ae gamma 
ae ae lift introducing ref values special forms ref 
simplifies proofs lemmas proceed induction structure expressions 
approach requires duplicating case applications 
semantics due crank felleisen derived felleisen hieb 
similar definition evaluation dealing state rewriting techniques appears mason talcott 
syntactic type soundness variable conventions free ref reduction domains disjoint ae merge free variables disjoint domain ae lift refer union reductions notions reduction adapted mutatis mutandis full syntax form basis calculus functions 
refer union vr write vr gamma 
reduction vr 
extended notion reduction gives rise system reductions equations extension contexts ae ae hx ci calculus satisfies basic properties calculus 
definition relies set contexts contexts new reductions reflects additional sequencing restrictions side effects programming language requires semantics deterministic 
particular creation dereferencing updating operations cell ordered linear fashion implies ordering operations distinct cells 
contexts build minimal order evaluation reductions refer cells operations ml choose perform operations left right 
reductions cell represented ordinary variable appearing domain store fragment 
program creates new cell ref ref reduction introduces ae expression records cell current value 
dereference operator selects cell value closest ae expression relative contexts 
appropriate cell bound ae expression closest intervening ae expressions merged outer 
accomplished ae lift ae merge reductions lift partial store contexts merge outer stores variable convention cells renamed appropriately avoid collisions 
assignment replaces cell current value closest ae expression performing necessary lift merge steps returns assigned value 
example consider expression ref ref expression assignments happen arbitrary order system reductions admits possibilities 
assignments happen outermost application reduced 
gives possible reduction sequence 
calculus constrains relative ordering ref deref assign reductions 
defining extended evaluation contexts ae fix order reductions ref deref assign may applied 
stepping function vr gamma 
defined 
show vr gamma 
function requires simple syntactic type soundness ref ref gamma 
theta ref ae lift gamma 
assign gamma 
assign fi gamma 
theta ae lift ae merge gamma 
fi gamma 
deref gamma 
ffi reducing program side effects diamond theorem order ae lift ae merge reductions happen fixed context ae lift rule selected nondeterministic fashion 
answers returned evaluation program longer simply closed values answer may cell 
answers values ae expressions enclosing values ae answers definitions evaluation may defined eval vr iff vr gamma 
eval vr typing typing cells presence polymorphism straightforward obvious solution unsound 
assign types cells extend set types additional constructor ff ref type ref type cells containing value type obvious types operators indicated semantics gamma ref ref gamma ref gamma ref example argument assignment operator cell 
second argument value matching type cell 
result type second argument assignment operator returns value assigned 
expression illustrates typing unsound ref true syntactic type soundness type bound generalized ff ff ff ref cell treated having type int int ref assignment having type bool bool ref dereference expression typable bool 
evaluating expression leads type error ref true gamma 
yi true gamma 
yi true gamma 
ni true gamma 
ni true tofte points problem obvious typing generalization type variables appear free type value store 
central idea tofte solution ensure storable values polymorphically run time 
type variables partitioned imperative applicative variables set type variables named types classified accordingly imperative type contain applicative type variables 
values imperative type stored 
type value generalized expression type variables appear types values store required imperative generalized 
notion generalization requires appropriate adaptation 
ff ff dom fff ff substitution required map imperative type variables imperative types 
ff imperative type variable ff ff ff int int ff ff ff ff ff ff ff ff ff ff ff potentially applicative meta variable ff represents type variable imperative applicative 
techniques typing tofte system requires modifying typing rule expressions 
rule split rules right hand side declaration value 
gives new rules 
second rule generalize imperative type variables generalize type value store 
expression bound expression value rule evaluation create new cell generalization imperative type variables type generalize type value store 
tofte uses terminology expansive non expansive denote syntactic classification expressions may create new definitely create new 
tofte classify values non expansive stronger type system possible classifying expressions non expansive 
syntactic type soundness gamma gamma 
close gamma gamma gamma gamma 
appclose gamma values gamma close gamma ff ff fff ff ng ftv ftv gamma appclose gamma ff ff fff ff ng ftv ftv gamma modified expression typing rules gamma ref ref imperative ref gamma ref deref gamma ref assign gamma 
ref 
ref gamma 
ref 
ref imperative gamma vn rho additional typing rules gives additional typing rules cells 
typing rules ref ae expressions ensure value placed store imperative type 
typing rules need explicitly constrained implicitly constrained type value store 
addition restrictions placed typing constants functional ml require constants type ref 
ensures values type fact cells assigned dereferenced 
restriction proof theorem 
new system assigns types old functional ml expressions 
indicate provability old functional system indicate provability system 
proposition expression functional ml gamma purely applicative gamma iff gamma functional ml expressions contain ref ae expressions imperative type variables need chosen type expression close appclose yield type scheme applicative types 
type soundness prove type preservation extended language show notion reduction extended new syntax preserves types reductions syntactic type soundness preserve types 
showing extended preserves types amounts re proving various lemmas section extended system 
general refer extension lemma lemma showing preserves types involves adding case reduction proof subject reduction 
cases involving contexts fact gamma gamma type environment gamma antecedent consequent contexts bind variables 
main lemma subject reduction vr gamma vr gamma 
gamma proof 
cases reductions appropriately extended replacement lemma similarly extended lemma 
case ref gamma 
vi gamma ref ref imperative gamma ref app gamma 
ref lemma gamma 
ref ref var gamma vi ref rho 
order satisfy imperative restriction typing ae expressions ref applications yield values imperative type ensured ref 
case ae hx vi 
gamma 
ae hx vi 
gamma ae hx vi 
rho gamma imperative gamma ref gamma ref gamma deref app 
replacement lemma gamma ae hx vi case ae hx gamma 
ae hx 
gamma ae hx rho gamma imperative gamma ref gamma ref assign app gamma gamma gamma app 
replacement lemma twice gamma ae hx case ae ae gamma 
ae gamma ae ae rho gamma ae gamma hx hx gamma gamma 
ref 
ref rho gamma gamma hx hx gamma gamma 
ref 
ref dom dom variable conventions gamma gamma ae rho 
syntactic type soundness case ae gamma 
ae 
gamma ae proceed induction structure show gamma ae case 
ae ae 
case 
gamma 
ae app gamma ae gamma gamma ae ind hyp 
rho gamma 
ref gamma 
ref hx hx fv gamma 
ref lemma gamma 
ref app gamma ae rho 
case 
similar previous case 
case gamma ae gamma ae gamma 
appclose gamma gamma ae ind hyp 
rho gamma 
ref gamma 
ref hx hx imperative fv gamma 
appclose gamma 
ref lemma gamma 
ref 
appclose gamma imperative due restriction typing ae expressions appclose gamma appclose gamma 
ref expansive gamma 
ref 
appclose gamma 
ref gamma 
ref gamma ae rho 
non expansive gamma 
ref 
close gamma 
ref gamma 
ref gamma ae rho 
syntactic type soundness gamma ae induction 
remains extend proofs various lemmas 
straightforward substitution lemma 
definition generalization substitutions proof required map imperative type variables imperative types 
lemma substitution gamma 
ff ff dom gamma gamma fff ff ftv gamma gamma 
proof 
cases proof functional ml unchanged exception expression case applies bound expression value 
new case expansive expressions new cases additional syntax 
case ref 
case gamma gamma gamma case 
gamma 
case ae gamma 
ff ff ae rho gamma 
ff ff 
ref gamma 
ff ff 
ref hx hx xm distinct imperative choose substitution fff ff fff ff ff ff distinct type variables sff ff fff ff fff ff ftv gamma ftv ftv 
lemma gamma 
ff ff 
ref gamma 
ff ff 
ref gamma 
ref 
ff ff lemma gamma 
ff ff 
ref gamma 
ff ff 
ref gamma 
ref 
ff ff applying inductive hypothesis gamma 
ref 
gamma 
ref 
bijection gamma exists gamma 
ref 
gamma 
ref 
gamma ae 

rho gamma 
ae 
syntactic type soundness case values 
premise gamma 
ff ff gamma 
ind hyp 
second premise gamma 
ff ff 
appclose gamma 
ff ff gamma 
appclose gamma 
ff ff 
ff ff choose substitution fff ff fff ff ff ff distinct imperative type variables bijection fff ff ftv gamma ftv fff ff 
lemma gamma 
appclose gamma 
ff ff 
ff ff gamma 
gamma 
ff ff 
ff ff gamma 
appclose gamma 
ff ff 
ff ff domain contains imperative type variables 
gamma free gamma 
appclose gamma 
ff ff fff ff ftv gamma 
appclose gamma 
ff ff fff ff ftv gamma ftv appclose gamma 
ff ff fff ff ftv appclose gamma 
ff ff fff ff ftv ff ff fff ff ftv fff ff fff ff ftv ftv gamma 
ff ff inductive hypothesis follows gamma 
appclose gamma 
ff ff 
bijection gamma exists lemma gamma gamma 
appclose gamma 
ff ff 
gamma gamma 
appclose gamma 
ff ff 
lemma gamma 
appclose gamma 
gamma 

gamma 

syntactic type soundness evaluation expression ml stuck new reasons 
expanded definition faulty expressions reflects fact 
definition faulty expressions faulty expressions ml expressions containing subexpression form ffi undefined 
var var ae hx 
uniform evaluation lemma stating programs yield answer diverge reduce faulty expression 
lemma uniform evaluation closed vr gamma 
faulty vr gamma 
proof 
proof proceeds induction length reduction sequence similar proof functional ml 
expressions expanded definition untypable 
main lemma faulty expressions untypable faulty gamma gamma proof 
suffices show subexpressions cause faulty untypable 
proceed case analysis form subexpression assuming case expression typed deriving contradiction 
case ffi undefined 
functional ml 
case 
var assume gamma gamma ref app deref implies variable value type ref contrary assumption 
case var assume gamma gamma ref app assign implies variable contrary assumption 
case ae hx 
assume gamma ae hx gamma rho gamma ref gamma gamma gamma gamma app gamma contradicts gamma ref type soundness follows 
theorem syntactic soundness ml vr gamma 
proof 
exactly theorem appropriately extended lemmas 
syntactic type soundness exception ml due ffi typability constant functions defined values input type 
precludes constants integer real division defined recognizable input values correct type 
standard ml solves problem introducing exceptions 
exception extension provides named exceptions parameters means raising exceptions means handling exceptions 
extension includes new phrases exception raise handle phrase declares exception names lexically bound second phrase requires evaluate exception name raises exception parameter value parameter propagates exception site exception handled 
third phrase evaluates subexpressions installs value exception handler exceptions raised evaluation subexpression evaluate exception name evaluate function accepts parameters exceptions 
exception raised control transfers dynamically closest handler kind exception 
handler function applied exception parameter result application returned result handle phrase 
active handler raised exception evaluation terminates unhandled exception answer 
extend functional ml exceptions add new phrases syntax exception expressions raise handle raise handle values expression exception variables bound treat set variables call exception names 
raise curried binary operator application raise value value included syntactic class values ml 
likewise expression handle value receives exception name handler function ordinary application 
application handle value value 
semantics raising handling exceptions requires new reductions raise gamma 
raise raise raise handle gamma 
handle exception raise handle gamma 
exception raise handle gamma 
new notions reduction rely different kinds contexts enforcement specific order evaluation applications connection raising syntactic type soundness handling exceptions raising handle handling exception raised raise reductions propagate exception outwards eliminating pending computations 
contexts include phrase handle raise reductions propagate exception closest exception handler 
closest handler matches raised exception handle reduction applies handler function exception parameter 
handler match exception reduction discards handler exception may continue propagate raise reductions 
expression protected handler evaluate value raising exception reduction discards handler 
exception expression requires additional reductions similar ae expressions exception exception gamma 
exception exn merge exception gamma 
exception exn lift difference exception expression bind values variables 
purpose exception expression distinguish different exceptions reduction order evaluation deterministic 
different bound subsequent reductions may substitute exception bound variable making raise reduction applicable 
example exception raise handle gamma 
exception raise handle gamma 
exception insisting exception bound ensures refer distinct exceptions 
reduction handle require variables exception bound substitution necessarily replaces instances handle redex exception name 
refer reductions exceptions introduced 
union extended full syntax yields vx notion reduction exception ml 
evaluation contexts extended exception handle stepping function vx gamma 
may defined lines 
answers eval vx exception exception raise answers due variable conventions exceptions generative standard ml 
syntactic type soundness answers third form unhandled exceptions handlers dynamically bound possible exception raised handler installed 
evaluation defined eval vx iff vx gamma 
eval vx extend domain ffi admit functions division allowing ffi return expression raises exception ffi const theta raise functions division defined element input type returning exception application sense 
typing extend set types additional type constructor ff exn type exn type exceptions parameter type typing exceptions presence polymorphism encounters similar difficulties typing 
phrase raise requires exception type exn matching parameter type type phrase handle requires exception type exn handler exceptions 
handler function type takes exception parameter input returns value returned place value obvious typing exceptions allows parameter types exceptions fully polymorphic permitting expression typed rh exception pair raise handle snd rh fst rh true gamma 
exception true functions raise handle exception returned pair bound expression rh 
body expression expression raise type ff ff handle type int ff 
ff ff ff exception parameter type ff generalized body expression exception may raised argument type bool fst rh caught snd rh expecting argument type int 
problems typing exceptions similar surprising modifications typing rules functional expressions apply types type variables classified imperative applicative rule split bound expression expansive see 
presents additional typing rules exceptions 
ml require additional restriction constants exception type exn 
usually set exceptions may raised constant functions defined initial environment take alternative approach simplify presentation 
constants pair fst snd provide pairing projection operations 
syntactic type soundness gamma raise exn raise gamma gamma handle exn 
handle gamma 
exn 
exn imperative gamma exception xn exn additional typing rules exceptions type soundness exceptions establish soundness exception typing proceed establish type preservation vx show faulty expressions exception ml untypable 
main lemma subject reduction vx gamma vx gamma 
gamma proof 
cases reductions 
case raise gamma 
raise gamma raise gamma raise app 
gamma raise gamma app 
gamma exn app raise gamma raise app raise gamma raise app 
case exception exception gamma 
exception similar ae merge lemma 
case exception gamma 
exception 
similar ae lift lemma 
case handle gamma 
gamma gamma handle handle app 
case raise handle gamma 
gamma 
raise handle handle app raise gamma gamma gammax exn 
gamma app 
syntactic type soundness case exception raise handle gamma 
exception raise gamma 
raise handle gamma 
raise handle exn 
app gamma raise handle gamma exception raise replacement extension various lemmas proof type preservation exception ml complete 
lemmas go simple adaptations new syntax 
new kinds faulty expressions exception ml 
definition faulty expressions faulty expressions exception ml expressions containing subexpression form ffi undefined raise var handle var exception exception handle uniform evaluation lemma shown faulty expressions proven untypable 
type soundness exception ml follows 
theorem syntactic soundness exception ml vx gamma 
core ml combine exceptions language core ml essential features standard ml 
combining exception extensions ensure interact appropriately 
semantics combine calculi extensions contexts fragment extended include phrases exception fragment likewise contexts extended include phrases fragment handle ae syntactic type soundness phrase exception included order exceptions store escape bindings exception expressions move ae expressions exn lift reduction appropriate variable renaming ae exception gamma 
exception ae vice versa exception ae hr xi gamma 
ae hr xi exception second permissible reduction occurrence store escape binding 
extension contexts resulting notion reduction full syntax 
evaluation contexts defining gamma 
eval extended handle ae exception answers ing fae answers ing fae raise means phrase may omitted 
complete calculus core ml may appendix 
typing combine typing rules fragments easy rely classification types imperative applicative interfere 
complete typing rules core ml may appendix 
type soundness core ml type soundness resulting calculus requires re establishing various lemmas theorems extended syntax extended evaluation contexts 
proofs straightforward 
combinatorial increase kinds faulty expressions interaction fragments raised handled exceptions dereferenced assigned 
structure proof stays 
definition faulty expressions faulty expressions core ml expressions containing subexpression form ffi undefined 
var var ae hx exception 
exception raise var handle var exception ae hx vi raise ae hx vi handle syntactic type soundness ae ae hx ci exception handle type soundness follows subject reduction uniform evaluation faulty expressions untypable 
theorem syntactic soundness core ml rx gamma 
rx control ml section extension functional ml providing class continuations 
typing extension similar described duba implemented standard ml new jersey 
simple matter merge extension core ml 
control ml extends functional ml syntax new constructs abort expressions callcc values abort expression evaluates subexpression value returns value result program 
callcc operator call current continuation applied function captures representation current continuation program control stack encapsulates continuation abstraction applies abstraction 
abstraction applied value control transfers captured continuation 
semantics defining calculus reductions class continuations possible resulting calculus inappropriate problem 
interested evaluation take simpler approach 
give top level evaluation rules program reductions control operators extending stepping relation gamma 
directly gamma 
iff gamma 
ffi fi callcc gamma 
abort callcc abort gamma 
abort style semantics evaluation context represents current continuation 
abort reduction simply discards current continuation continuing evaluation subexpression 
callcc reduction captures current continuation encapsulates function applies callcc argument function 
continuations created callcc invoked discard continuation surrounding application syntactic type soundness product callcc letrec nil 
car car cdr product cons cons cons cons nil program illustrating simple callcc abort reduction installing captured continuation 
answers simply values eval defined functional ml 
illustrates simple callcc 
program computes product list numbers performing multiplications answer zero 
constants nil cons nil car cdr usual constants operations lists 
expressions letrec syntactic sugar appropriate constant applications 
program computes product list numbers performing multiplications answer zero 
program escapes pending multiplications jumping recursion continuation application product 
typing obvious approach typing callcc leads rule gamma callcc naive callcc indicated callcc reduction callcc takes function argument procedural abstraction evaluation context continuation 
evaluation context expects value type continuation type type callcc argument ignores continuation produce value type implies callcc argument type result type continuation arbitrary application built continuation ensures returns 
obvious typing unsound illustrated example callcc pair pair snd fst true callcc application returns pair type ff ff theta ff ff int consisting identity function function applies continuation 
ff free type environment closed type scheme ff ff ff theta ff ff int body expression 
evaluating body fst polymorphic identity function may validly applied true 
second function pair applied variation example discovered robert harper mark lillibridge sml electronic mailing list july 
despite widespread naively typed callcc extension standard ml new jersey took years problem discovered 
syntactic type soundness continuation invoked pair consisting 
second evaluation fst true results attempt add true 
exceptions correct typing continuations builds classification types imperative applicative requires typing rules 
correct typing rules gamma callcc imperative 
callcc gamma gamma abort abort abort expression may type regardless type subexpression evaluated returns 
weak type soundness abort expressions return value type proving type soundness continuation extension simple previous extensions 
example expression type bool program abort true typable typing rules returns int bool true false 
subject reduction usual sense hold weaker lemma hold stating typability preserved 
main lemma typability preservation gamma 
proof 
need consider additional cases callcc abort reductions 
simply adapted lemma subject reduction functional ml 
case abort gamma 
gamma abort closed bind variables closed case callcc gamma 
abort 
callcc callcc callcc app imperative 
closed appear free claim 
proof claim proceeds induction structure case 

var 
case 

callcc app callcc 
ind hyp 


lemma fv 

app 
syntactic type soundness case 
similar previous case 
case callcc callcc expansive callcc expansive 
callcc 
appclose 
ind hyp 

appclose 
lemma 

appclose critical restriction imperative appclose appclose 


appclose 


completes proof claim 

abort abort 
abort abs abort app abort replacement faulty expressions control ml functional ml extended new syntax 
definition faulty expressions faulty expressions control ml expressions containing subexpression ffi undefined 
functional ml faulty expressions untypable uniform evaluation holds 
typability preservation obtain weaker version syntactic soundness indicate type answers 
theorem weak syntactic soundness gamma 
proof 
uniform evaluation gamma 
faulty gamma 
typability preservation implies suppose gamma 
faulty 
faulty expressions untypable contradiction case occur 
gamma 
weaker theorem establishes weak soundness imply strong soundness 
fact abort unrestricted possible predict type answer example section illustrates 
syntactic type soundness strong type soundness examining proof typability preservation reveals reduction exception abort preserves type 
particular callcc reduction preserves type suggests callcc strongly sound 
obtain proof strong soundness callcc eliminate abort surface language available programmers retain underlying language evaluation callcc reductions 
abort expressions introduced callcc applications restricted shape return values top level type program compromise strong soundness 
establish subject reduction lemma define augmented type system infers ordinary type expression set abort types 
abort types expression types immediate subexpressions abort expressions augmented system permit abort types generalized ensuring syntactic occurrence abort produce type answer 
restriction eliminates expressions abort true typed program aborts answer produced program abort types 
type judgments augmented system form gamma meaning type environment gamma expression ordinary type abort types set types 
presents typing rules augmented system 
augmented type system corresponds closely original type system control ml 
rule typing abort expressions rule connects ordinary type abort types expression 
axiom var const callcc abort set completely unconstrained inference rules simply propagate abort set 
expression rules generalize type variables set abort types augmented system permit polymorphic uses abort accepts subset expressions accepted ordinary system 
correspondence lemma establishes connection ordinary system 
augmented system 
lemma correspondence gamma contains abort expressions gamma ii gamma gamma proof 
proof direction shows construct deduction consequent deduction antecedent 
proofs straightforward 
subject reduction augmented system establishes reduction preserves set abort types 
callcc reduction introduces abort expression top level type program set abort types preserved subject reduction includes top level type 
syntactic type soundness gamma gamma var gamma typeof const gamma gamma 
gamma abs gamma gamma gamma app gamma gamma 
close gamma gamma gamma gamma 
appclose gamma values gamma gamma callcc imperative callcc gamma gamma abort abort close gamma ff ff fff ff ng ftv ftv gamma ftv appclose gamma ff ff fff ff ng ftv ftv gamma ftv augmented type system control ml main lemma subject reduction gamma 
proof 
proof proceeds case analysis reduction gamma 
case easily adapted corresponding case proof typability preservation straightforward adaptations necessary lemmas 
uniform evaluation fact faulty expressions untypable ordinary system obtain syntactic soundness theorem abort free expressions 
theorem syntactic soundness contains abort expressions gamma 
proof 
uniform evaluation gamma 
faulty gamma 
contains abort expressions correspondence subject reduction implies similarly correspondence suppose gamma 
faulty 
faulty expressions untypable contradiction case occur 
gamma 
syntactic type soundness discussion subject reduction key lemma approach proving type soundness 
order demonstrate subject reduction possible assign type intermediate evaluation state program 
easily accomplished specifying evaluation rewriting 
rewriting may specified local reductions calculus core ml program top level rewriting control ml 
semantics various languages calculi permit local reductions 
possible proof technique semantics specifies program reductions gamma control ml 
semantics ml slightly simpler ref ae merge ae lift reductions coalesce program reduction structure proof essentially 
alternative type system uses approach 
chose calculi resulting proofs regular structure 
specifying semantics calculus additional expression form ae expression ml 
noted earlier ae expressions may regarded abbreviations semantic perspective typing perspective typing rule ae expressions derived abbreviation 
principle possible eliminate ae expressions syntax specification redexes reduction rules complicated 
alternatively ae expressions may considered belonging state space evaluation language programs may written programmer 
presentation typing rules consumption programmers typing rule ae expressions may deleted 
ae expressions abort expressions continuation fragment considered abbreviations 
obtain strong soundness theorem abort expressions considered belonging evaluation space syntax programs 
exception fragment additional expressions 
operational denotational techniques specifying semantics introduce additional semantic objects closures stores additional expression forms 
type system apply objects stating proving strong type soundness requires introducing semantic relation semantic objects types see section 
believe introducing additional expression forms typing rules simpler choice offer simpler proofs produced method evidence 
concentrated essential aspects ml features static type systems believe technique address 
standard ml contains datatype specification mechanism allows definition new types associated data constructors 
mechanism indispensable writing non trivial ml programs 
subtyping inheritance type inference records strong focus research efforts explain object oriented languages popular objectoriented languages unsound static type systems 
reppy successfully addressed concurrency technique possible treat nondeterminism distributed computing 
technique prove alternative type system sound 
may possible adapt technique demonstrate consistency module systems standard ml 
syntactic type soundness bob harper pointing type preservation known subject reduction combinatory logic hans boehm anonymous referees comments earlier drafts 
syntactic type soundness appendix core standard ml syntax ae exception ref raise handle raise handle hx vi ing fae ing fae raise semantics eval iff gamma 
gamma 
iff gamma 
handle ae exception functional ml gamma 
ffi ffi defined ffi gamma 

fi gamma 

gamma 
ref gamma 
vi ref ae hx vi 
gamma 
ae hx vi deref ae hx gamma 
ae hx assign ae ae gamma 
ae ae merge ae gamma 
ae ae lift handle exceptions raise gamma 
raise raise raise handle gamma 
handle exception raise handle gamma 
exception raise handle gamma 
exception exception gamma 
exception exn merge exception gamma 
exception exn lift handle ae syntactic type soundness typing functional ml gamma gamma var gamma typeof const gamma gamma 
gamma abs gamma gamma gamma app gamma gamma 
close gamma gamma gamma gamma 
appclose gamma values gamma close gamma ff ff fff ff ftv ftv gamma appclose gamma ff ff fff ff ftv ftv gamma gamma ref ref imperative ref gamma ref deref gamma ref assign gamma 
ref 
ref gamma 
ref 
ref imperative gamma hx rho exceptions gamma raise exn raise gamma gamma handle exn 
handle gamma 
exn 
exn imperative gamma exception exn syntactic type soundness abadi cardelli pierce plotkin dynamic typing statically typed language 
acm transactions programming languages systems april 
previously appeared proceedings th annual symposium principles programming languages january 
barendregt lambda calculus syntax semantics revised ed vol 
studies logic foundations mathematics 
north holland amsterdam 
crank felleisen parameter passing lambda calculus 
proceedings th annual symposium principles programming languages january 
curry feys combinatory logic volume north holland amsterdam 
damas milner principal type schemes functional programs 
proceedings th annual symposium principles programming languages january 
damas type assignment programming languages 
phd thesis university edinburgh 
donahue demers data types values 
acm transactions programming languages systems july 
duba harper macqueen typing class continuations ml 
proceedings th annual symposium principles programming languages january 
felleisen theory practice class prompts 
proceedings th annual symposium principles programming languages 
felleisen expressive power programming languages 
science computer programming 
preliminary version proceedings european symposium programming lncs 
felleisen friedman control operators secd machine calculus 
formal description programming concepts iii wirsing ed 
elsevier science publishers 
north holland amsterdam pp 

felleisen friedman syntactic theory sequential state 
theoretical computer science 
preliminary version proceedings th annual symposium principles programming languages 
felleisen friedman kohlbecker duba syntactic theory sequential control 
theoretical computer science 
preliminary version proceedings symposium logic computer science 
syntactic type soundness felleisen hieb revised report syntactic theories sequential control state 
tech 
rep tr rice university june 
appear theoretical computer science 
hindley principal type scheme object combinatory logic 
transactions american mathematical society december 
hindley seldin combinators calculus 
cambridge university press 
leroy weis polymorphic type inference assignment 
proceedings th annual symposium principles programming languages january 
macqueen plotkin sethi ideal model recursive polymorphic types 
proceedings th annual symposium principles programming languages january 
mason talcott programming transforming proving function abstractions memories 
proceedings international conference automata languages programming lncs springer verlag pp 

milner theory type polymorphism programming 
journal computer system sciences 
milner tofte induction relational semantics 
theoretical computer science 
milner tofte commentary standard ml 
mit press cambridge massachusetts 
milner tofte harper definition standard ml 
mit press cambridge massachusetts 
mitchell harper essence ml 
proceedings th annual symposium principles programming languages january 
mitchell plotkin types existential type 
acm transactions programming languages systems july 
appeared proceedings th annual symposium principles programming languages 
plotkin call name call value lambda calculus 
theoretical computer science 
plotkin structural approach operational semantics 
tech 
rep daimi fn university september 
rees clinger revised report algorithmic language scheme 
sigplan notices december 
syntactic type soundness reppy higher order concurrency 
phd thesis cornell university 
reynolds definitional interpreters higher order programming languages 
acm conference proceedings 
reynolds relation direct continuation semantics 
proceedings international conference automata languages programming 
scott data types lattices 
siam journal computing 
seldin sequent calculus type assignment 
journal symbolic logic 
standard ml new jersey release notes version 
bell laboratories november 
talpin jouvelot type effect discipline 
tech 
rep ecole des mines de paris july 
tofte operational semantics polymorphic type inference 
phd thesis university edinburgh 
tofte type inference polymorphic 
information computation november 
wright typing effect inference 
proceedings european symposium programming lncs springer verlag pp 

