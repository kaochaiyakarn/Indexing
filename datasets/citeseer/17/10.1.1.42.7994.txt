graph transformation specification programming marc andries gregor engels habel berthold hoffmann hans jorg kreowski sabine detlef plump andy schurr gabriele taentzer framework graph transformation combines potentials advantages graphs rules single computational paradigm 
developments applying graph transformation rule framework specification development systems languages tools 
reviewing basic features graph transformation discuss selection applications including evaluation functional expressions specification interactive graphical tool example specification data types definition visual database query language 
case studies indicate need suitable structuring principles independent particular graph transformation approach 
concept transformation unit allows systematic structured specification programming graph transformation 
keywords graph transformation rule specification transformation units structuring 
graphs known understood frequently means represent system states complex objects diagrams networks flowcharts entity relationship diagrams petri nets 
rules proved extremely useful describing computations local transformations arithmetic syntactic deduction rules known examples 
areas language definition logic functional programming algebraic specification term rewriting theorem proving concurrent processes partially supported deutsche forschungsgemeinschaft esprit basic research working group computing graph transformation ii esprit working group applications graph transformation ec tmr network general theory graph transformation systems universities aachen berlin bremen hildesheim paderborn 
author addresses andries information systems brussels mail andries wi nl engels universitat gh paderborn mail engels uni paderborn de habel universitat hildesheim mail habel informatik uni hildesheim de hoffmann 
kreowski plump universitat bremen mail informatik uni bremen de schurr universitat der munchen email informatik muenchen de taentzer tu berlin mail cs tu berlin de expert systems witness prominent role rules 
graph transformation known graph rewriting graph reduction combines potentials advantages graphs rules single computational paradigm 
years ago rosenfeld pr rm usa schneider ehrig wadsworth sch sch wad eps europe introduced graph transformation generation manipulation recognition evaluation graphs 
graph transformation studied variety approaches motivated application domains pattern recognition semantics programming languages compiler description implementation functional programming languages specification database systems specification data types specification distributed systems development documented proceedings collections selected papers monographs handbook cer pve se cm 
surveys developments applying graph transformation specification development systems languages tools 
section recalls basic concepts fairly general approach graph transformation points possible variations generalizations 
section reports case studies demonstrate usefulness graph transformation typical application domains 

known implementation functional programming languages efficient evaluation functional expressions requires avoid multiple representations subexpression 
leads idea term graph rewriting known jungle evaluation graph reduction represents oldest successful applications graph transformation 

agg system graphical tool editing graphs transforming graph transformation rules 
parts agg system specified graph transformation exemplify graph transformation concepts specification graphical case tools similar systems 

red black trees kind balanced binary trees non trivial rebalancing operations 
specification red black trees graph transformation system illustrates data types modelled adequately means graph transformation 

visual languages promising research topic area programming languages general database languages particular visual representations improves comprehension programs 
example usefulness graph transformation context report definition hybrid database query language hql eer graph transformation 
case studies selection wide range applications graph transformation find literature 
chosen authors illustrate potentials graph transformation specification programming different fields computer science 
order support applications case studies properly apply graph transformation realistic context needs structuring principles graph transformation 
section notion transformation units structuring principle incorporates experiences reported case studies particular 
illustrate specification programming graph transformation performed transformation units reformulating aspects case study term graph rewriting 
transformation units differ graph transformation concepts respects 
graphs exist variants directed undirected unlabelled labelled attributed simple multi hypergraphs 
various ways apply rules graphs control process iterated rule application 
led competing graph transformation approaches 
merits choice particular approach largely depends application mind 
needs structuring concepts 
transformation units approach independent 

concept transformation unit offers structuring principle building large specifications programs smaller ones reusing existing components 
particular concept transformation unit encapsulates rules control conditions descriptions initial terminal graphs allows transformation units 
application local rules may interleaved calls transformation units 
interleaving semantics supports induction principles modular proofs 
specifying programming transformation units combines advantages graphs rules relies graph transformation basis interpreter semantics theorem proving facilities 
addressed readers want know graph transformation works applied independently particular graph transformation approach independently certain type graphs rules specific way rule application 
may particularly interesting readers familiar special graph transformation approach want know fits general idea setting applied graph transformation 
mentioned concentrate sequential mode graph transformation discuss aspects parallelism concurrency deserve attention cf 
ek kre cmr tae 
concepts graph transformation section recall basic features sequential graph transformation graph derived graph applying rule 
presentation completely formal oriented general approach kreowski rozenberg kr combines aspects major approaches 
labelled directed graphs underlying structures consider fairly general type rule application covering major notions encountered literature particular features section 
ignoring technical details application rule graph called direct derivation defines binary relation graphs iterated arbitrarily yielding derivation process 
way set rules gets operational semantics 
starts particular initial graph collects derivable graphs labels terminal label alphabet gets notion graph grammar generated language 
section discuss properties graph transformation relevant specification programming paradigm 
section take ideas graph transformation independently particular type rule application basic elements structuring principle graph transformation 
graphs basic structures graph transformation choose node edge labelled directed graphs 
graph consists set labelled nodes set labelled directed edges connects pair nodes 
formally graphs defined follows 
graphs 
labelled directed graph nodes edges source target label consists finite set nodes nodes finite set edges edges mappings source target assigning source target node edge mapping label assigning labelling symbol alphabet node edge 
edge goes source source target target incident source target 
nodes edges called items 
may contain parallel edges node node label 
graphs called multigraphs 
graphical representations nodes drawn points circles boxes edges drawn arrows source target 
labels written points arrows inside circles boxes indicated different shapes colours fill styles shown nodes edges labelling 
node identifiers incorporated graphical representations 
shows graphs node identifiers 
graph subgraph denoted node edge sets subsets respective sets source target label mappings coincide respective mappings graph subgraph occurrence denoted mapping occ maps nodes edges nodes edges respectively preserves sources targets labellings edge source image coincides image source target image coincides image target item label image coincides label particular occurrence occ subgraph consisting images nodes edges 
occurrence denoted occ simply occ known context 
mapping bijective isomorphic 
graph occurrence nodes identified denoted node corresponds node gamma 
graphs subgraph occurrence variations extensions graph concept 
number variations simple extensions graph concept 
directed graphs classical sense graphs edge set binary relation set nodes coincide directed graphs parallel edges 
undirected graphs may represented directed graphs replacing undirected edge directed edges opposite direction 
hypergraphs generalize graphs sense edge sequence source nodes sequence target nodes 
hierarchical graphs graphs subgraph abstracted node bunch edges abstracted subgraphs edge 
concept hierarchical graphs introduced pratt nodes labelled graphs pra pra 
typing important concept specification programming 
transferred graphs means labels typed graphs divided classes called types edges certain type restricted incident certain types source target nodes 
language progres sch typed graphs specified called graph schemata 
attributed graphs equipped attributes 
attribute number text expression list graph 
attributes different types attribute operations compatible types available manipulate attributes 
graph transformation graph transformation consists applying rule graph iterating process 
rule application transforms graph replacing part graph 
purpose rule contains left hand side right hand side application graph replaces occurrence left hand side right hand side done removing part occurrence second gluing remaining graph third connecting insertion new edges nodes gluing specified gluing component rule connection embedding component 
replacement shall done controlled way rules may contain application conditions 
described procedure graph transformation may look unnecessarily complicated reader familiar graph transformation 
due generality framework section captures properties main approaches literature includes special cases see 
major approaches simpler general framework 
rules 
graph transformation rule glue emb appl consists graphs called left hand side right hand side respectively subgraph called interface graph occurrence glue relating interface graph right hand side embedding relation emb relating nodes nodes set appl specifying application conditions rule 
application rules 
application rule glue emb appl graph yields resulting graph provided obtained steps 
choose occurrence left hand side 
check application conditions appl examples hypergraphs section hierarchical graph section 
examples typed graphs graph schemata sections 
examples attributed graphs sections 

remove occurrence occurrence dangling edges edges incident removed node 
yields context graph contains occurrence 
glue context graph right hand side occurrences construct disjoint union item identify corresponding item corresponding item yields gluing graph 
embed right hand side context graph embedding relation emb removed dangling edge incident node image node node new edge label incident node established provided belongs emb 
application yielding called direct derivation denoted simply illustrates steps performed applying rule glue emb appl appl requires occurrence isomorphic emb relates unfilled nodes gamma gamma gamma glue gamma gamma gamma gamma gamma gamma choose check remove embed glue illustration graph transformation step graph rule glue emb appl occurrence variant constructing derived graph general intuitive 
case nodes edges occurrence removed images items left hand side outside interface graph 
gluing step adapted accordingly 
means general interface graph kept invariant 
special cases graph transformation consider fit special notion rule application called single pushout approach discussed paragraph section applies rules general sense 
note practical applications step remove needs delete dangling edges replaced new embed 
rule application implemented way remove yield graph general 
theoretical point view correctness proofs useful obtain graph intermediate step rule application 
graph transformation approaches 
readers familiar graph transformation shall mentioned framework combines gluing aspects algebraic approaches ehr low cmr embedding aspects set theoretic approaches nag er context direct neighbourhood occurrence additional application conditions 
double pushout approach ehr cmr single pushout approach low node replacement approach er set theoretic approach progres sch seen special cases framework 
transparent consider special cases 

choose check 
general occurrences allowed identify nodes edges 
practice uses injectivity condition requires occurrence isomorphic restrictive special application conditions contact condition identification condition 
contact condition assures dangling edges arise remove 
requires image node contacts edge image node identification condition requires occurrence may identify nodes edges interface graph interesting examples application conditions context conditions 
require forbid existence nodes edges certain subgraphs graph 
general treatment application conditions eh kre hht 

remove 
contact condition required application rule may remove edges context occurrence dangling ones 

glue 
special case occurrence isomorphic result gluing step may obtained adding special case interface graph empty added 
embed 
special case emb empty relation additional edges inserted 
general emb allows embedding context consisting nodes incident dangling edge dangling edge incident image node redirected node emb 
note special forms rules correspond rules graph transformation approaches 
rules application conditions empty embedding relation correspond single pushout rules 

rules contact identification condition empty embedding relation correspond double pushout rules 

rules single node left hand side empty interface graph correspond node replacement rules 

rules occurrence glue interface graph correspond progres rules restricted embedding direct neighbourhood occurrences 
introduced notion graph transformation quite general cover approaches encounters literature 
hand discuss sequential mode graph transformation parallel graph transformation covered cf 
ek kre cmr tae 
hand application rule strictly local respect removal addition nodes edges 
approaches covered allow global effects rule application cf 
nag fw ph 
extensions graph transformation concept 
typed graphs transformed application rule preserve certain typing constraints 
attributed graphs may depend certain attribute values occurrence kind application condition application may compute new attributes attribute operations 
graph transformation systems notions rule direct derivation graph transformation systems graph grammars graph languages defined usual 
set rules simplest form graph transformation system set rules initial graph set terminal labels forms graph grammar 
set rules graph sequence successive direct derivations delta delta delta derivation rules provided rules belong graph said derived rules set graphs labelled symbols derived initial graph rules language generated slightly general may consider specifying initial terminal graphs respectively set rules induces binary relation graphs relating initial graph terminal graphs derived initial graph 
note non determinism occurring graph transformation choose rules applicable graph 
furthermore chosen rule may applicable occurrences left hand side 
result graph transformation depends choices completely arbitrary 
non determinism may restricted control conditions ways 
prescribing order rules applied 
determining rule dependence previous 
applying rule priority 
prototypes transformation systems matrix systems considered formal language theory programmed graph transformation systems see bunke bun bun schurr sch graph transformation systems priorities see lm 
section introduce notion transformation unit encapsulates discussed components graph transformation systems set rules descriptions initial terminal graphs control conditions allows additionally transformation units 
properties graph transformation properties graph transformation discussed interest graph transformation considered specification programming method 
satisfaction discussed properties requested general may helpful certain contexts 
locality 
rule character graph transformation ensures certain degree locality action manipulates mainly occurrence rule 
principle weakened respects 
may non local application conditions nonlocal computations new attributes 
deletion dangling edges embedding mechanism described destroy locality property concern direct neighbourhood occurrence 
programmed graph transformation principle locality longer obeyed 

systems databases graphical tools undo operations desirable reconstruct previous state 
graph transformation specification undo operations may described inverted rule applications 
application rule inverted satisfies contact condition identification condition morphism glue injective embedding relation empty see ehr 
furthermore application conditions left hand side transformed equivalent right hand side conditions 
case attributed graphs transformation concerning attribute part invertible 
consistency conditions 
consistency conditions concerning existence nonexistence subgraphs cardinality restrictions number outgoing edges proven derived graphs 
consistency conditions transformed equivalent application conditions sense consistent graph transformation application conditions satisfied produces consistent graph hw 
independence confluence 
direct derivations commute graph double pushout approach case occurrences steps overlap deleted nodes edges ek 
graph transformation system confluent derivations graph confluence implies graph transformed irreducible graph 
prove system confluent method double pushout approach computation critical pairs pairs overlapping direct derivations plu 
termination 
graph transformation system called terminating infinite derivations impossible 
simple sufficient conditions termination rule reduces size graph number occurrences fixed subset labels 
general termination undecidable plu 
sufficient necessary condition termination double pushout approach certain restricted derivations called forward closures terminate plu 
forward closures inductively generated rules property step derivation depends previous step 
complexity 
central problem graph transformation efficient matching left hand side rule subgraph current working graph 
similar problems occur testing application conditions 
ideas developed efficient implementation matching problem variant ops rete matching algorithm may maintain set occurrences set rules derivation sequences bgt 
approaches building search plans matching purposes rs 
search plans start known nodes indexes node labels attribute values locate start nodes efficiently 
traverse edges starting known nodes extend partial match step step 
known techniques constraint logic programming languages may increase probability early failures reduce number candidate nodes considered 
existing languages tools languages tools available graph transformation 
early visual programming languages graph transformation plan dfs 
graph transformation tools pagg got graph ed wan progres sch gks agg lb 
contain graph editor drawing graphs interpreter graph transformation 
editors usually support graphical representations mouse menu driven interfaces different views graphs different sections graph different layouts different levels abstraction 
interpreters able apply rules occurrences selected user automatically 
language offers programmed graph transformation interpreters provide backtracking mechanism perform prescribed applications rules 
offer type checker checker graph theoretic properties automatic layout cross compilers modula programs 
case studies graph transformation section discuss case studies demonstrate typical applications graph transformation 
term graph rewriting evaluation functional programs oldest successful application domains 
second parts graphical tool editing transforming graphs agg system specified illustrate usefulness graph transformation tool development 
third particular type balanced trees sophisticated rebalancing operations specified example data type specification 
illustrated visual database query language hql eer defined indicating graph transformation may play similar role area visual languages context free chomsky grammars traditional programming language design 
case studies progres framework provides far developed tool environment 
second case studies employ algebraic approaches 
different approaches case studies may considered special cases graph transformation approach introduced previous section 
basic idea system performs local manipulations complex structured graphical objects graph transformation formalism specify program 
term graph rewriting equations functional expressions common concept specification programming 
essential ingredient functional programming algebraic specification data types program verification 
context equations compute value expression prove equality expressions 
cases equations employed directed rewrite rules replace subterms see dj bn klo 
implement rewriting efficiently adequate represent expressions strings trees 
data structures certain equations enforce copying subexpressions multiply evaluation 
example application distributive law theta theta theta term form theta duplicates subterm subsequently evaluated twice 
kind inefficiency overcome expressions represented structures allow share common subexpressions 
instance term thetat thetau resulting just mentioned rewrite step compactly represented graph structure triangles stand representations subterms 
representation subterm evaluated 
put way evaluation graph corresponds parallel evaluation occurrences string tree representation 
omega omega omega omega omega omega omega omega omega theta theta graph structure representing theta theta name term graph rewriting introduced come evaluation expressions graph transformation 
outline term graph rewriting works state fundamental properties computational model 
highlight relations conventional term rewriting model 
presentation jungle evaluation approach term graph rewriting hp hp plu plu 
term graphs term graphs directed acyclic hypergraphs hyperedges labelled function symbols variables node represents term 
consider hyperedges source node sequence zero target nodes 
number target nodes inclusive repetitions fixed number arguments function symbol hyperedge labelled 
shows term graphs function symbols fib suc binary fib suc unary constant 
hyperedges depicted boxes inscribed labels filled circles represent nodes 
line connects hyperedge source node arrows point target nodes 
order target sequence left right order arrows leaving box 
node term graph represents term ae label target empty label target unique hyperedge source label label target target sequence term graph node root node reachable write term root 
example left term graph represents term fib suc suc fib suc suc 
nodes representing variables source nodes hyperedges labelled variables called variable nodes 
explain term graph rewrite steps hypergraphs particular shape 
variable collapsed tree term term graph term variable nodes shared variable represented unique node 
term graph denote hypergraph obtained removing hyperedges labelled variables 
rewriting set equations 
consider equations left right rewrite rules require equation variables occur variable 
term graphs 
evaluation step denoted isomorphism term graph constructed follows choose equation occurrence 
remove hyperedge source root yielding hypergraph 
glue constructing disjoint union ii identifying root root iii identifying variable nodes satisfying term term 
remove nodes hyperedges reachable root steps alternatively described application called evaluation rule equation evaluation rules hypergraph transformation rules sense section 
shape evaluation rule equation shown 
left hand hypergraph sigmaf middle hypergraph obtained removing topmost hyperedge 
right hand hypergraph constructed gluing 
embedding relation emb set cond application conditions empty 
step construction evaluation steps known garbage collection implementation functional programming languages 
garbage collection described hypergraph transformation rules see section 
infix operator better readability 
delta delta delta omega omega omega omega omega omega delta delta delta shared variable nodes oe ae omega omega omega omega omega omega delta delta delta shared variable nodes oe ae omega omega omega omega omega omega shared variable nodes oe ae evaluation rule schematic evaluation steps consider called collapse steps enhance degree sharing term graph changing represented term 
term graph distinct hyperedges identical labels target sequences identification including source nodes realizes collapse step specify collapse steps rules collapse rule shown assigned function symbol variable 
collapse rules empty embedding relation application condition requiring occurrence left hand side identify hyperedges 
instance collapse rule function symbol fib applied rewrite step 
delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta collapse rule standard implementations functional programming languages collapsing usually employed see kah implementation fully collapsed term graphs 
allow collapse steps reasons 
firstly needed deal properly equations having repeated variables left hand sides 
collapsing equation may applicable term graph applicable represented term 
secondly collapsing term graph rewriting complete equational proofs sense term rewriting term graphs equivalent respect reflexive symmetric transitive closure rewrite relation represented terms equivalent respect equations 
property fails collapsing see plu particularly important term graph rewriting implementations theorem provers 
example subsection demonstrate collapsing may speed evaluation process drastically certain cases 
respect collapsing related memoization technique functional programming see hug studied term graph rewriting hof 
example fibonacci function equations define fibonacci function natural numbers suc denotes successor function fib fib suc suc fib suc suc fib suc fib evaluation rule third equation depicted 
shows collapse step evaluation step rule 
note suc hyperedges middle term graph removed garbage collection 
fib suc suc suc suc suc fib suc fib suc evaluation rule third fibonacci equation fib fib suc suc fib suc suc fib suc fib collapse step evaluation step notation means node glued node 
evaluation step corresponds consecutive term rewriting steps term represented middle term graph fib suc suc fib suc suc 
fib suc fib fib suc suc 
fib suc fib fib suc fib suppose want evaluate term fib suc suc fibonacci equations 
term graph rewriting requires space number evaluation collapse steps linear size suitable strategy applying evaluation collapse steps chosen see hp 
contrast evaluating term rewriting term graph rewriting collapsing requires space number rewrite steps exponential size matter rewrite strategy 
properties term graph rewriting consider transformation term graphs evaluation collapse steps arbitrary order 
union relations write term rewrite step equation reflexive transitive closures relations denoted soundness completeness 
term graph rewriting sound sense step realizes sequence term rewrite steps implies term term hp hp completeness respect equivalence generated equations 
term term reflexive symmetric transitive closures follows term graph rewriting complete proof method equational theory plu plu 
termination 
term rewriting terminating meaning infinite chains steps impossible holds converse need hold 
term graph rewriting terminates equation sets term rewriting hp hp 
reason sharing created equations repeated variables right hand sides may exclude certain term rewrite derivations 
termination term graph rewriting proved recursive path order term graphs generalizes corresponding order terms see plu 
evaluation strategies 
evaluation strategies term rewriting restrict non determinism rewriting 
strategies called normalizing lead evaluated term possible 
certain classes equation sets normalizing term rewriting strategies turned normalizing term graph rewriting strategies plu rao 
confluence 
property means arbitrary rewrite sequences starting common object extended common object 
confluence implies object evaluated irreducible object 
term rewriting confluent term graph rewriting converse hold general 
test term graph rewriting confluence method analysis critical pairs term graph rewrite steps plu 
survey positive negative confluence results term graph rewriting various classes equation sets 
modularity 
known union equation sets terminating term rewriting disjoint function symbols may yield nonterminating set contrast termination term graph rewriting carries plu 
nice consequence fact term graph rewriting terminates term rewriting 
sets additionally confluent resulting set plu 
modularity properties may certain function symbols common 
see ko rao extensions modularity results 
summary term graph rewriting computational model efficient conventional term rewriting model close real implementations 
fact term graph rewriting common implementation technique lazy functional programming languages witnessed books peyton jones pey plasmeijer van eekelen pve 
term graph rewriting sound complete equational computations sense term rewriting differs properties termination confluence 
respect termination modularity graph model behaves friendly 
variations rewriting model considered various authors 
see example sta pad ak 
extensions deal cyclic term graphs infinite computations fw term graph rewriting logic programming equation solving cmr cr cw hp 
area related term graph rewriting graph reduction lambda calculus 
numerous literature area mention wad lam 
specification interactive graphical tool objects interactive graphical tool represented graphs operations modelled graph transformation 
consider agg system developed tu berlin tool editing transforming graphs show parts specified graph transformation see lb tb 
agg system agg system prototype implementation algebraic approach graph transformation 
contains flexible graph editor transformation component applies user selected rules automatically user selected occurrences 
editor supports mouse menu driven creation modification graphs rules 
underlying graphs agg hierarchical graphs higher order edges edges edges 
graphs called agg graphs useful rule occurrence graph level diagram level describe manipulate graphs rules occurrences uniform way 
include usual definition graphs special case 
higher order edges represent relations graphs graphs 
common relations graphs rules occurrences graphs 
edges objects order edge node possible 
graphs abstracted nodes bundles edges abstracted single edges 
formal definition concept lb regards graphs set objects partial mappings source target abstraction 
node object source target undefined 
obvious consistency conditions enforced abstraction mapping compatible source target mapping acyclic 
editor show different views graph different windows allows graphs edited concurrently different abstraction levels 
abstraction level may shown different windows 
windows editing transformation 
change window immediately propagates windows showing graph 
editing operations tailored manipulation rules occurrences transformations gluing operation merges objects new object inherits incidence relations original objects connecting copy operation draws edges original objects copies 
consecutive snapshots shall illustrate agg system allows graphs rules occurrences handled uniform way 
shows rule occurrence different abstraction levels graph level left window diagram level right window 
left window circles solid arrows display graphs left hand side rule left right hand side right host graph rule shall applied left 
dashed arrows display relations graphs glue component rule horizontal dashed arrows occurrence vertical dashed arrows 
general dashed arrows may connect edges edges see bottom 
right window presents rule occurrence higher abstraction level diagram level left hand side rule right hand side host graph transformation step graph level diagram level graph abstracted single node respectively 
left upper node abstraction left hand side right upper right hand side lower host graph 
glue occurrence relation abstracted single arrows dashed arrows pointing nodes left hand side right hand side represented single dashed arrow abstraction left hand side abstraction right hand side 
analogously dashed arrows left hand side host graph abstracted single dashed arrow pointing abstraction left hand side abstraction host graph 
applying rule indicated occurrence leads situation shown 
diagram level contains rectangle derived graph relations host graph right hand side rule indicated 
graph level left window shows detail 
transformation component implements single pushout approach graph transformation see low 
note node host graph dashed arrows point deleted corresponding nodes left hand side belongs interface graph 
node right hand side corresponding interface node deleted dangling edges 
general graphs may abstraction levels 
large graphs structured hiding details lower levels abstraction 
modelling agg system graph transformation discuss interesting aspects specifying agg system graph transformation 
states agg system described attributed graphs sense section 
represent agg objects windows agg graphs abstraction levels agg nodes agg edges nodes relations edges 
properties agg objects position type state selection reflected attributes corresponding nodes 
abstr level graph object abstr level object window pos pos pos pos cursor vis vis vis vis lrc lrc window lrc lrc section agg state modelled graph representation facets 
logical structure agg graphs represented nodes type object connected source target abstraction edges 
object nodes representing agg nodes outgoing edges 
way higherorder edges abstraction mechanism modelled easily 
addition nodes represent chain abstraction levels graph 
object points untyped edge node belongs 

system state agg system specified nodes representing windows cursor selection hiding agg objects described special attributes object nodes 

layout graphs described different types attributes position type agg nodes size position windows bending agg edges visibility agg objects shows representation state agg system graph consisting abstraction levels lower contains node loop displayed windows upper level empty displayed cursor indicates current window 
position attributes cursor windows agg objects shown 
position agg edge positions source target bending points 
initial state agg system bordered dashed lines initial graph abstraction level empty 
editor operation transformation step agg system modelled graph transformation single pushout approach mentioned section extended application conditions 
example consider agg operation open new window modelled 
operation opens new window current window 
size adjusted parameter values position upper left corner lower right corner lrc 
objects previous current window displayed new window long fit object decided visible new window 
operation modelled operating graph transformation rules 
rule case study nodes labelled type 
cursor window abstr 
level window window cursor abstr 
level new window rule opening new window abstr 
level object pos pos cursor object pos pos cursor window window true abstr 
level vis lrc lrc lrc lrc false object show node vis vis pos lrc rule computing visibility nodes new window depicted 
input parameters set size attributes new window node consistent 
application rule show node applied long applicable 
rule determines visible graph objects current window 
application new window works section choose occurrence left hand side agg state graph 
check application condition shown left 
remove edge issuing occurrence cursor node 
glue right hand side graph insert new window node connect edges coming cursor node leading node resp set attribute values rule parameters 
additional embedding step 
rule show node depicted determines graph object belonging current abstraction level visible 
left hand side rule object node vis edge struck indicate negative context condition 
implicitely edge negative context 
apply rule occurrence left hand side negative context extended forbidden nodes edges 
asserts object represents pointed section negative context conditions application conditions 
fit general framework graph transformation section 
agg node issue edge visibility edge computed 
rule show edge similar show node needed compute visibility agg edges depending visibility source target nodes 
order perform agg operation open new window rules show node show edge applied long possible application new window 
agg operations insertion deletion nodes edges abstraction levels gluing copying specified similarly kind controlled graph transformation 
initial agg state shown part obtain graph grammar describing reachable agg states 
consistency conditions 
agg states satisfy consistency conditions exactly current window 
window shows objects abstraction level 
object visible 
lrc values window consistent lrc lrc shown modelling agg operation preserves consistency conditions 
open new window stated violate condition cursor moved new window 
rule show node similarly show edge applied object current abstraction level 
condition preserved 
negative context conditions rules applied object exactly condition satisfied 
condition enforced application condition rule new window 
consistency check done automatically transforming consistency conditions equivalent conditions rule sense consistent graph application rule new window additional application conditions satisfied yields consistent graph 
compare section consistency conditions 
properties 
applications rule show node agg node current abstraction level independent modify different parts agg state graph 
applied parallel order speed computation process new agg state graph 
undo redo mechanism helpful editors 
modelling graph transformation rules inverted 
looking agg operation open new window possible defining agg operation close window modelled application inverted rule show node application conditions node current abstraction level similarly edges 
inverted rule new window applied application condition 
undo redo mechanism looks complicated invertibility rules offers automatic way provide undo redo functionality 
summary description agg states graphs agg operations graph transformations imperative close object description methods 
graphical note single pushout rule inverted injective satisfies contact condition 
presentation demonstrates graph transformation leads intuitive constructive specifications checked thoroughly consistency 
similar done development environment progres specified progres 
biggest problem developing graph specification agg system complexity 
agg allows different views graphs displayed windows offers complex editor operations 
refinement possibilities stepwise incorporation structural information help manage complexity 
starting logical description agg graphs specification may refined incorporating system states agg tackling graphical layout agg graphs 
compare subsection tools consistency checking support development correct specifications 
planned extend agg system comprehensive transformation component system manager consistency checker tool checking independence transformations tool defining layout graphs 
system offer comprehensive set tools specification software graph transformation 
challenge specify kernel extended system possible modularity concept graph transformation available show consistency specification 
specification data type section report usage graph transformation language progres specifying prototyping data types visual programming languages 
name progres short hand programming graph rewriting systems 
progres integrated programming environment developed graph grammar group nagl rwth aachen 
attempt define implement graph transformation strongly typed programming language defined syntax static dynamic semantics sch sch 
mixed textual diagrammatic language permits quite different styles programming supports 
graphical textual definition graph database schemata declaration derived graph properties 
rule oriented diagrammatic specification atomic graph transformation steps means parametrized graph transformation rules complex preconditions 
imperative programming composite graph transformation processes means deterministic non deterministic control structures 
respect progres similar called visual database languages instance hy cm qbd acs 
note languages pure query languages limited support definition complex transformations 
contrast progres programming environment support definition manipulation data extent 
red black trees graph schemata language progres mainly designed specification case tools eln 
gradually obvious kind visual database programming language high level language implementing graph data types 
running example section red black trees cf 
clr special kind height balanced binary search trees 
red black trees edges nodes different colours black red 
compute heights subtrees balanced respect black edges 
consequence height left right subtree node may differ factor 
increases time complexity search operations reduces necessary rebalancing overhead insert remove operations considerably 
example selected order demonstrate advantages programming graph transformation rules contrast usage conventional programming languages 
red black trees complex tree restructuring operations data model just binary tree coloured nodes 
emphasize progres allows definition arbitrary directed attributed graphs restricted trees 
believe sense specify tree data structures progres language elaborated type system visual rule oriented character 
language graph data model attributed graphs cf 
section typed nodes typed directed edges 
node attributes binary relations nodes extensionally defined manipulated graph transformation rules intrinsic attributes edges intensionally defined maintained progres runtime system derived attributes materialized path expressions 
lazy incremental evaluation process keeps derived data consistent state 
progres graph schema red black trees defined graphical entity relationship diagram representation detailed textual representation 
displayed defines invariants 
different nodes tree different integer values key attributes cf 
declaration intrinsic derived attribute value 

red black tree contains type nodes different types edges cf 
declaration node type edge types lack eft 

parent child edge red black leads left right child cf 
declaration derived relations paths left right parent 

node left right child parent node cf 
cardinality constraints form 

height subtree maximum number black edges path leaves cf 
declaration derived attributes height 

height left subtree node equal height right subtree cf 
declaration restriction balanced 

target red coloured edge source red coloured edge cf 
declaration restriction 
node class intrinsic key value integer derived height integer max self self self bl height self rl height self br height self rr height edge type bl edge type br edge type rl edge type rr path left bl rl path right br rr path parent restriction balanced valid self self restriction rr node type 
cutout red black tree graph schema contains examples binary search trees coloured edges 
top left corner contains red path length node node violating integrity constraint 
operation right explained subsection restructures tree legal red black tree bottom left corner 
please note restrictions may specify invariants static integrity constraints data structure 
intermediate graph transformation results may violate constraints automatically inserted runtime checks ensure specified top level transactions abort return consistent results transaction insert 
ongoing concerning verification runtime validation graphically expressed integrity constraints reader referred hw 
distinction node classes node types needs detailed explanation 
concrete node type belongs node class 
progres stratified type system types nodes class objects 
node classes multiple inheritance hierarchies types node types determine common properties node type instances 
instance node type class mentioned attributes legal source target introduced edge types paths section gives example interesting class hierarchy 
graph transformation rules transactions ensure afore mentioned properties red black trees reorganized insertion deletion certain nodes 
backbone reorganization process input host graph output host graph red black tree rotating rule graph instances subtree rotation operations 
presents pseudocode tree rotating operations slightly simplified 
called deals ight ed edges meet 
slightly modified version operation clr difficult understand 
contrast progres specification shown consists rule similar graphical explanation clr 
clearly states reorganizes subtree root red right child root reorganized subtree 
application red black tree graph divided basic steps choose check remove glue embed section 
rule left hand side separator defines graph pattern transformed 
matches subgraph host graph consists node parent parent nodes red right children parents 
furthermore node may may black left child optional existence visualized dashed box representation 
please note node inscription requires bound actual value rule input parameter general symbol left hand side links node identifiers input parameters right hand side links node identifiers right hand side left hand side 
rule application steps choose check just responsible finding appropriate matches remaining node variables rule right hand side defines subgraph replaces selected match left hand side 
consists nodes inscriptions form procedure compute match variables parent parent black left child black right child right left black left nil parent left redirect black left right edge parent parent parent parent left parent left parent right parent red left child left red parent pseudocode operation node identifier right hand side node identifier left hand side 
progres notation defining interface graph occurrence glue rule preserves matched nodes deletes creates number edges 
effect red left child red right child black right child remove glue 
furthermore line starting embedding redirects incoming black left right edge old root node new root node embed 
remaining basic operations tree rotation defined similar way 
needed red black tree interface operations programmed means imperative control structures calls graph transformation rules graph traversing paths 
contains specification operation insert selects correct place inserting new value simultaneously reorganizing tree needed inserts new leaf reorganizes tree means rotating rules 
details see sch contains complete specification red black trees 
mention example available progres features 
instance node types class objects may parameter values graph transformation rules meta attributes cf 
section 
furthermore progres offers means deal non determinism inherent property graph transformation paradigm 
vary collecting manipulating sets possible outcomes atomic values prolog style programming built backtracking capabilities 
graph transformation rules support 
selection injective non injective occurrences left hand sides 
definition application conditions form predicate logic formulas derived node attributes path expressions 
construction edges new nodes context graph means textual graphical embedding rules 
summary graph transformation language progres application specification known data structure 
language provides users diagrammatic textual constructs definition graph schemata derived graph transaction insert val integer loop choose split rotate val val val rotate path val integer valid val valid val self value right complex graph transformation insertion red black tree properties graph transformation rules complex graph transformation processes 
examples produced progres environment offers means create analyze execute specifications 
furthermore compiler backends added translate progres specification equivalent modula code 
latest version progres environment available free software sun workstations see www page www informatik rwth aachen de research progres index html 
contains rapid prototyping tool translates specification stand program tk tcl user interface 
generated prototypes store graphs graph oriented database system 
way graph transformation environment supports specification realization data types generally tools manipulate complex data structures section 
subject current research activities develop new compiler backends generating programs store graphs main memory object oriented database system 
experience progres various sites cf 
section shown needs enhancement 
data model generalized support attributed hyperedges hierarchical graphs sections 

concepts modularization developed structure large specifications small reusable parts defined interfaces 

possible define language subsets executed efficiently allow progres specific applications term graph rewriting section 
serious efforts develop new graph transformation language environment suitable module concept mechanisms adapt graph data model graph transformation approach specific needs selected application areas 
partly topic section 
definition visual language years graphical visual software tools environments role purely text oriented terminal display 
illustrative example field case environments instance class diagrams support modelling structural aspects software system data flow diagrams state transition diagrams petri nets support modelling dynamic aspects 
user case environments deals documents written visual language textual language 
section illustrate example potentials graph transformation formal definition diagram languages 
chosen example hybrid database query language hql eer extended entity relationship model eer ae ae allows specification database queries partly graphically partly textually 
section short informal hql eer briefly illustrate simple example syntax semantics graphical part may defined graph grammar specification 
purpose progres language environment introduced section 
see complete specification hql eer 
hybrid database query language hql eer hql eer allows formulation queries database structure defined schema extended entity relationship model egh 
small example eer database schema visually represented eer diagram shown 
defines structure entity person single valued attribute name type string list valued attribute addr address predefined type list members 
database instance consists person entities person entity name list addresses attributes 
addr list address person string name sample eer diagram eer model equipped textual sql query language called sql eer 
extending sql eer graphical alternatives language constructs obtained hybrid query language hql eer 
language database user choose part query wants express graphically textually respectively 
gives purely graphical query hql eer node drawn bold indicates information shall retrieved names persons share address john 
john addr list address person string name addr list person string name sample hql eer query example shows hql eer query consists nodes edges labelled names corresponding eer diagram 
graphical part hql eer query viewed graph cf 
section syntactical structure defined graph grammar 
syntax definition hql eer constituent list address query constituent constituent constituent constituent constituent constituent constituent def def def def def def def def string person address list address person string name person addr person name person addr person attr attr er cont mm mm attr attr er cont mm mm attr attr er attr attr er graph representation hql eer query syntax hql eer defined graph grammar steps appropriate graph representation words visual language chosen language graphs defined graph grammar 
graph language may associated graphical part hybrid query follows cf 
shows nodes edges graph corresponding hybrid query 
graphical elements query nodes edges represented nodes 
nodes corresponding edges query shown bottom nodes corresponding nodes query shown directly 
node representing edge query linked nodes representing source target means suitably labelled edges 
design decision represent edges query nodes due technical restriction progres node types may refined graph schema edge types may 
nodes represent edges allows specify transformation rules terms language constructs entity relationship keep independent particular eer database schema 
eer database schema dependent elements occur clearly identifiable part graph schema subclasses node types added eer schema independent part graph schema 

graph representation contains node sub query graphical part query 
query subqueries graph representation contains single query node linked indirectly nodes correspond nodes query 
node play different roles query illustrated address node 
impossible parallel edges identical label progres intermediate constituent nodes introduced 

labels nodes graph representation dependent derived concrete eer diagram person address independent concrete eer diagram query constituent 

non structural characteristics query stored node attributes 
table shows syntactic attributes nodes graph 
fact string node selected output respectively value john represented setting boolean flag output corresponding constituent node true respectively setting string valued attribute value string node john 
id label att 
name attribute value constituent output true string value john formally define language graphs representing graphical part hql eer queries means progres specification consisting 
graph schema declaring types nodes edges attributes 
set graph transformation rules obey type restrictions imposed graph schema specify instances components defined graph schema may composed 
specification defines graph language exactly described section syntactically correct graph yielded applying sequence rules initial empty graph 
node class entity ent rel node class atomic value value intrinsic value string node class constituent intrinsic output boolean false node type constituent constituent node class attribute meta type ent rel val type value edge type attr er attribute ent rel edge type attr attribute value node class person entity node type person person node type string atomic value node type name person attribute meta person val string graph schema partial shows cutout graph schema specification hql eer queries 
declares node classes specialization node classes entity specialization ent rel subclass 
note declarations graph schema independent considered eer diagram entity labels eer diagram person 
attributes declared initialized node class declarations may redefined node type declarations 
intrinsic attributes string attribute value declared node class atomic value apply nodes considered class 
contrast meta attributes apply node types 
specification meta attributes node type set node types represented class value 
instance meta attribute applies types class attribute initialized person representing set node types class name person node type 
meta attributes enforce type correctness 
nodes linked typed edges attr er edges connect attribute node ent rel node expressing fact attributes may assigned entity relationship types 
cardinality expresses correspondence attribute applies exactly entity relationship 
collection declarations contained graph schema defines graph class contains subset graphs represent syntactically correct hql eer queries 
means restrictions imposed subgraphs linked 
restrictions expressed means graph transformation rules 
er cons def constituent cons def val cons def ev attr er att production add attribute er ent rel query att type attribute val type value value constituent return condition att val val er type att rule inserting attribute shows rule adds eer attribute entity relationship 
attribute represented means nodes inserted linked new constituent existing nodes 
parameter att may replaced node type descendant attribute node class hierarchy graph schema 
additionally condition clause rule enforces type compatibility input parameters 
instance checked value type val value type expected attribute type att stored type meta attribute val 
fact node types redefine attribute values just coincidence progres allows attributes redefined 
rule add attribute applied entity type person node types name person string parameters att val respectively 
semantics definition hql eer hql eer offers graphical alternatives textual language constructs sql eer 
natural way defining semantics hql eer translation graphical elements sql eer 
additional motivation choosing approach fact progres formalism allows seamless integration semantics definition syntax definition graph grammar specification 
translation incorporated graph representation hql eer queries attributing nodes graph corresponding sql eer expressions 
remember constituent nodes precisely representing fact query element plays part query 
ideal place storing sql eer expressions 
table shows semantic attributes graph 
term attribute query node contains precisely sql eer query represented hql eer query 
semantic attributes associated constituent nodes contain sql eer declarations terms formulas 
id label att name attribute value query term select name person addr person addr person person person name person john constituent declaration person term constituent term addr person constituent term name person formula name person john example extension graph schema specification hql eer follows directly declarations node classes query constituent extended declarations attributes mentioned appropriate derivation rules term attribute 
semantic attributes constituent nodes initialized rules create 
example clause transfer term term string att added rule add attribute shown 
stands string concatenation string function converts att values string representations 
summary act specifying hql eer means graph grammar important lessons may drawn 
shows attributed graph grammar allows seamless integration definition syntax semantics graph language single specification way attributed string grammars textual languages 
second defining graph languages ability graphs basic primitives graph rules surely advantages having general purpose specification language graphs encoded 
allows concentrate essentials graph language details applied specification language 
third specification hql eer illustrates soon size graph grammar specification exceeds certain limit hard manage understand 
progres language offers variety mechanisms capturing detailed aspects language graphs clearly lacks modularization concepts 
availability module concept including defined notions interfaces module interrelationships inheritance substantially improve understandability reusability specifications 
structuring principle graph transformation case studies section illustrated graph transformation applied system specification programming natural way 
case studies quite small compared real world applications may consist large complex graphs hundreds thousands rules 
graph transformation systems extended structuring mechanisms allow compose modular way 
furthermore case studies indicated different graph transformation approaches suitable different applications 
structuring principles needed approach independent sense allow specification programming different approaches 
steps direction concept transformation unit see kk kks 
section outline basic features transformation units 
demonstrated reformulating aspects case study term graph rewriting section 
similarly examples redesigned structured way 
interesting various respects add illustration concept graph transformation works 
concentrate examples 
main features informally discuss main characteristics transformation units formal treatment section 
rule graph transformation 
motivated section illustrated section quite natural combine graphs means describing complex structures rules means manipulate structures 
elementary level transformation unit consists set graph transformation rules applied graphs 
precisely transformation unit transforms graph applying rules iterating process 
key operation performed transformation unit application rule graph 
initial terminal graphs 
desirable start graph transformation special graph underlying graph class 
example generate graph language transformation may start particular initial graph graphs particular shape cf 
section 
reduce graphs initial graphs may arbitrary transformed rule applicable 
concept transformation unit generalizes notions providing graph class expressions specify classes initial terminal graphs 
consequently valid transformations start initial graphs terminal graphs 
description initial graphs viewed precondition graph transformations performed transformation unit 
analogously terminal description serves postcondition 
control conditions 
general graph transformation non deterministic reasons may rule applied certain graph 
second applying graph transformation rule graph means transform locally may various parts graph manipulated rule application 
regulate graph transformation process example choosing rules priority prescribing certain sequence steps suitable control conditions needed 
conditions treated example bun sch sz mw cf 
dp regulation concepts string grammars pve evaluation strategies functional programming 
transformation units graph transformation process regulated control conditions 
approach independence 
mentioned components graphs rules graph class expressions control conditions form called graph transformation approach 
literature exist variety graph transformation approaches progres algebraic ones double pushout approach ehr single pushout approach low agg tb restricted approaches node replacement jr edge replacement hk hyperedge replacement 
see overview 
differ mainly underlying graph data model type transformation rules 
example progres attributed graphs transformed agg manipulates hierarchical ones single pushout rules hyperedge replacement applies called hyperedge replacement rules hypergraphs 
approaches provide specific kinds control conditions graph class expressions progres agg 
case studies underline approaches convenient specification programming 
order widely applicable main feature units independent specific graph transformation approach 
means suitable manipulate graphs existing user defined graph transformation approaches 
structuring 
practice rule systems may consist immense set rules 
design systems reasonable way needs structuring principles allow compose small re usable units systematic way 
transformation units provide apart rules specifications initial terminal graphs control condition import component allows transformation units 
way set local rules transformation unit kept small 
import part transformation unit consists set names refering transformation units 
reasons simplicity consider section transformation units hierarchical import structure 
interleaving semantics 
graph transformation sequence rule applications starting initial graph 
operational semantics graph transformation system usually defined set transformations 
abstracting intermediate steps transformation obtains input output relation graphs pair contains initial graph transformation transformed graph 
concept operational semantics basis semantics transformation units defined binary relation graphs 
particular transformation units transform initial graphs terminal ones interleaving rule applications calls imported transformation units control condition obeyed 
transformation units provide functional abstraction meaning complex graph transformation encapsulated binary relation graphs 
imported transformation units treated atomic sense applied graphs importing unit 
encapsulation property known structuring methods computer science transactions database systems procedures programming languages 
note general concept transformation units transform arbitrary objects rule manner graph transformation basic subject restrict data models graphs 
transformation units transformation units graph transformation systems built small pieces 
independent particular graph data model specific type rules defined graph transformation approach 
graph transformation approaches graph transformation approach comprises class graphs class rules rule application operator class graph class expressions class control conditions 
purpose control conditions restrict non determinism graph transformation semantics binary relation graphs 
control conditions may contain identifiers usually imported transformation units local rules semantics depends environment mapping associates identifier binary relation graphs 
way semantic effect control conditions defined forward transformation units 
intuitively may think environment names rules transformation units corresponding direct derivation relations corresponding interleaving semantics 
formally graph transformation approach consists class graphs class rules rule application operator yielding binary relation theta class graph class expressions specifies subclass sem class control conditions set id identifiers specifies binary relation theta environment id theta 
section introduced different classes graphs rules 
give typical examples remaining components graph transformation approach graph class expressions control conditions 
note overloaded operator sem denote various semantic operations 
distinguished types arguments presence absence additional index refering environment 
graph class expressions various standard ways choose graph class expressions arbitrary graph classes graph transformation approaches 
cases deals finite graphs explicit representations 
single graphs finite enumerations graphs may serve graph class expressions 
semantically graph represents sem fgg 
initial graph graph grammar typical example type 

kind default graph class expression effect may term specifying class graphs sem 
graph reduced respect set rules rule applicable way considered graph class expression sem set reduced graphs respect term rewriting term graph rewriting halting condition 

class graphs labelled alphabet sigma set sigma suitable graph class expression specifying class graphs labelled 
way distinguishing terminal objects quite popular formal language theory 

graph grammar considered graph class expression specifies generated language 

choosing examples atomic expressions may build complicated expressions recursively set theoretic operators union intersection complement 

graph theoretic properties graph class expressions 
particular monadic second order formulas directed graphs hypergraphs suitable candidates see cou 

graph schemata progres typed graphs graph class expressions allow specify generic graph classes see sections 
control conditions description binary relation graphs may control condition 
typical examples 
grammar automaton expression specifying string language id serve control condition 
environment string delta delta delta specifies binary relation obtained sequential composition meaning delta delta delta ffi delta delta delta ffi empty string specifies empty set 
example graph transformation rules meaning consists pairs graphs results applying delta delta delta specifies pairs graphs obtained applying rules order 
language specifies union semantic relations elements 
control conditions language type point extended set id arbitrary set elementary control conditions 
mechanism binary relations ae ae theta sequential composition ae ae defined ae ffi ae ae ae gg 
specifies language serve control condition semantics defined point string delta delta delta delta delta delta ffi delta delta delta ffi environment 

particular set elementary control conditions class regular expressions purpose 
explicit reg recursively reg reg reg 
order omit parentheses assume stronger binding stronger binding regular expression reg abbreviated environment semantics regular expressions obtained follows ffi 
kind default control condition effect may term true specifies relation true theta independently environment 

control condition expression serves induced control condition applies long possible 
means environment pair graph 

pair graph class expressions defines binary relation graphs sem sem theta sem control condition independent choice environment sem environments 
deterministic non deterministic control structures progres serve control conditions 
allow define imperative commands control conditions 
transformation units transformation unit encapsulates specification initial graphs set transformation units imported set rules control condition specification terminal graphs 
import structure hierarchical lowest level unstructured transformation units import transformation unit may import transformation units lower level 
transformation units defined graph transformation approach 
formally graph transformation approach set transformation units recursively defined follows set transformation units empty initially 
transformation unit system graph class expressions finite set rules control condition 
note specifies single graph empty constant true gets usual notion graph grammar approach special case transformation units 
interleaving semantics operational semantics transformation unit binary relation graphs containing pair graphs initial graph terminal graph binary relation ae ae denotes reflexive transitive closure 
second obtained interleaving derivations graph transformations specified imported transformation units third pair allowed control condition 
detail consider transformation unit assume imported transformation unit defines binary relation graphs sem theta defines binary relation sem way pair graphs belongs sem sem sem sequence graphs pair gamma belongs semantic relation sem imported transformation unit directly derives gamma gamma addition pair gamma accepted control condition specific environment 

environment sem assuming identifiers occurring elements names 
resulting semantic relation sem called interleaving semantics sequences graphs called interleaving sequences 
definition interleaving semantics follows recursive definition transformation units 
definedness follows easily induction hierarchical structure transformation units 
empty interleaving sequence consists derivations interleaving semantics generalizes ordinary operational semantics sets rules derivations 
particular control condition ignored true single initial graph second components pairs interleaving semantics significant transformation unit kind seen graph grammar interleaving relation corresponds generated language 
particular transformation unit called generating unit graph class expression done example 
example example picks case study section 
illustrates term graphs specified term graph rewriting modelled transformation units 
approach set function symbols fixed arity fixed number arguments 
set variables 
graph transformation approach example consists components 
ffl graph hyperedge labelled directed hypergraph labels froot leaf label root special symbol indicating root node term graph unique node node reachable needed specifying garbage collection see 
label leaf generation trees 
ffl rule glue emb appl component emb empty appl subset contact stands contact condition ident identification condition see section 
ffl graph class expressions particular initial graph particular generating unit constant set rules specify reduced graphs 
ffl class control conditions contains set reg regular expressions consists set id identifiers containing names transformation units plus condition reg 
transformation units indicating components respective keywords 
trivial components imported transformation units rules graph class expression control condition true omitted 
transformation unit rule set fp graph class expression reduced abbreviation fp control condition abbreviates regular expression jp delta delta delta jp rule introduced section depicted arrow points left hand side right hand side subgraph occurrence glue indicated numbering corresponding nodes application conditions written left hand side term graphs specify class term graphs collapse rules introduced section 
term graphs collapsed trees term graph constructed generating tree collapsing 
transformation unit trees graph grammar generating class trees root hyperedge attached root top manner 
rule set trees contains rule variable function symbol 
rules application conditions applied arbitrary order 
terminal expression ensures generated graphs labels 
trees initial root leaf rules leaf leaf delta delta delta leaf leaf arity terminal reduced semantics trees consists pairs initial graph tree root root labelled hyperedge attached 
note trees generating unit 
collapse steps performed transformation unit collapse applies collapse rule collapse exactly input graph see section definition collapse rules 
collapse rules collapse conds semantics collapse consists pairs graph obtained applying collapse rule transformation unit term graphs generates set term graphs initial graph trees 
calls trees exactly collapse arbitrarily 
term graphs uses trees collapse conds trees collapse semantics term graphs depends semantics imported transformation units consists pairs initial graph trees term graph root incident root labelled hyperedge 
apart root labelled hyperedge term graphs section 
root hyperedge implicitly specification garbage collection 
term graph rewriting term graph rewriting explained section comprises evaluation collapse steps term graphs 
transformation unit collapse reused 
set equations properties described section 
evaluation step consists applying evaluation rule eval followed garbage collection see section definition evaluation rules 
transformation unit eval applies rule eval exactly input graph eval rules eval conds semantics eval consists pairs graph obtained applying evaluation rule 
transformation unit garbage performs garbage collection 
rule garbage deletes node outgoing hyperedge contact condition satisfied incident hyperedge 
due contact condition nodes hyperedges reachable root hyperedge deleted initial graph garbage results applying evaluation rule term graph 
garbage rules contact delta delta delta delta delta delta delta delta delta arity contact terminal reduced semantics garbage consists pairs graphs graph obtained applying rules garbage arbitrary order long possible 
eval garbage transformation unit evaluation constructed 
evaluation steps shall performed term graphs initial graphs evaluation generated transformation unit term graphs 
evaluation initial term graphs uses eval garbage conds eval garbage semantics evaluation consists pairs term graphs obtained applying eval garbage 
semantics evaluation coincides relation section 
transformation unit rewrite imports evaluation collapse called arbitrarily arbitrary order restriction applied 
rewrite initial term graphs uses evaluation collapse conds evaluation collapse semantics rewrite consists pairs term graphs obtained performing arbitrary non empty sequence evaluation collapse steps 
semantics coincides transitive closure relation section 
construct transformation unit rewrites term graphs long possible 
initial term graphs uses rewrite conds rewrite semantics contains pairs term graphs obtained performing arbitrary sequence evaluation collapse steps reduced respect evaluation collapse steps 
lazy eager collapsing depending set equations may desirable rewrite term graphs strategies order improve efficiency 
control condition rewrite transformation unit viewed simple general strategy computing reduced term graphs 
specialized strategies lazy eager collapsing 
lazy collapsing 
lazy collapsing attempts collapsing steps evaluation rule applicable 
equations repeated variables left hand sides collapsing may enable subsequent evaluation steps 
lazy coll initial term graphs uses evaluation collapse conds evaluation collapse eager collapsing 
eager collapsing applies collapse rules term graph long possible performing evaluation step 
eager coll initial term graphs uses evaluation collapse conds collapse evaluation control conditions units express special priority schema transformation units 
general units need semantics 
interesting question classes equation sets semantics coincide semantics 
case strategies defined units called normalizing see plu 
import structure transformation units depicted solid edges represent dependence relation uses components dashed edges show generating unit term graphs initial parts 
consider transformation units parameterized units component inside parentheses formal parameter obtain family structured sets transformation units list actual parameters 
term graphs rewrite evaluation eval garbage collapse trees eager coll lazy coll import structure set transformation units demonstrated usefulness graph transformation specification programming 
case studies section indicate spectrum potential applications similar kinds literature 
follow simple idea complex objects advantageously represented graphs rules specify transformation generation recognition objects 
emphasize common philosophy recalled main features graph transformation section 
case studies prove principal applicability graph transformation concepts various areas reveal shortcomings troublesome aspects 
various types graphs rules various ways rule applications leading different graph transformation approaches easily combined easily switch 
proper choice approach may cause problems 
structuring principles missing hard manage large collections rules 
overcome drawbacks graph transformation introduced notion transformation units section provides means structuring purposes approach independent integrating various approaches may choose 
mentioned transformation units basic structuring concept graph rule centered language grace 
development grace ongoing activity involving researchers aachen berlin bremen erlangen hildesheim munchen paderborn 
actual emphasis laid points 
semantics transformation unit binary relation graphs graph language 
sophisticated module concepts developed cover ary relations greater sets relations single relations 
explicit notion parameterization appears example implicitly introduced 
confer suggestions concerning modularization refinement abstraction ee ch es ts 

grace planned provide efficient specification programming environment includes editor interpreter database graphical interface 
particular play important role allows grace visual specification programming language 
im graph transformation systems see sch sch sch gks lb tb reuse components far possible build grace environment 

grace offers choice various graph transformation approaches 
furthermore investigate conditions approaches combined final goal want design simple easy language defining new approaches users 

important aim provide proof support system grace 
recursion depth transformation units length interleaving sequences induce induction principles 
structure transformation unit may correspond modular proof structure 
establish proof theory grace proof system built 
confer attempt consistency checking hw 

case studies particularly stress application grace language environment specification parallel distributed systems tae including appropriate semantic considerations process semantics cmr 

anonymous referees valuable comments led various improvements survey 
acs michele tiziana catarci santucci 
qbd graphical query language recursion 
ieee transactions software engineering 
ae marc andries gregor engels 
syntax semantics hybrid database languages 
schneider ehrig se 
ae marc andries gregor engels 
hybrid query language extended entity relationship model 
journal visual languages computing 
ak ariola jan willem klop 
equational term graph rewriting 
fundamenta informaticae 
ariola jan willem klop detlef plump 
bisimilarity term graph rewriting 
information computation 
appear 
andrea asperti laneve 
comparing calculus translations sharing graphs 
dezani ciancaglini gordon plotkin editors proc 
typed lambda calculi applications lecture notes computer science 
marc andries 
graph rewrite systems visual database languages 
phd thesis rijksuniversiteit te leiden netherlands 
available ftp ftp ftp wi nl pub cs andries ps gz 
bgt horst bunke 
tran 
efficient implementation graph grammars rete matching algorithm 
ehrig 
bn franz baader tobias nipkow 
term rewriting 
cambridge university press 
bun horst bunke 
programmed graph grammars 
claus cer 
bun horst bunke 
generative power sequential parallel programmed graph grammars 
computing 
hendrik barendregt marko van eekelen john richard kennaway rinus plasmeijer ronan sleep 
term graph rewriting 
proc 
parallel architectures languages europe lecture notes computer science 
janice cuny hartmut ehrig gregor engels grzegorz rozenberg editors 
proc 
graph grammars application computer science lecture notes computer science 
cer volker claus hartmut ehrig grzegorz rozenberg editors 
proc 
graph grammars application computer science biology lecture notes computer science 
ch andrea corradini heckel 
compositional approach structuring refinement typed graph grammars 
corradini montanari cm 
clr thomas cormen charles leiserson ronald rivest 
algorithms 
mit press cambridge 
cm mariano consens alberto mendelzon 
hy query visualization system 
sigmod record 
cm andrea corradini ugo montanari editors 
proc 
joint workshop graph rewriting computation electronic notes theoretical computer science www elsevier nl locate entcs 
cmr andrea corradini ugo montanari francesca rossi hartmut ehrig michael lowe 
graph grammars logic programming 
ehrig 
cmr andrea corradini ugo montanari francesca rossi 
graph processes 
fundamenta informaticae 
cmr andrea corradini ugo montanari francesca rossi hartmut ehrig heckel michael lowe 
algebraic approaches graph transformation part basic concepts double pushout approach 
rozenberg 
cou bruno courcelle 
graph rewriting algebraic logical approach 
jan van leeuwen editor handbook theoretical computer science volume 
elsevier amsterdam 
cr andrea corradini francesca rossi 
hyperedge replacement jungle rewriting term rewriting systems logic programming 
theoretical computer science 
cw andrea corradini dietmar 
jungle rewriting description lazy narrowing machine 
schneider ehrig se 
dfs ernst reinhold franck wolfgang streng 
plan dimensional programming language 
dirk editor 
der gesellschaft fur informatik lecture notes computer science 
dj nachum dershowitz jean pierre jouannaud 
rewrite systems 
jan van leeuwen editor handbook theoretical computer science volume 
elsevier 
dp jurgen 
regulated rewriting formal language theory 
eatcs monographs theoretical computer science 
springer verlag 
ee hartmut ehrig gregor engels 
pragmatic semantic aspects module concept graph transformation systems 
cuny 
egh gregor engels martin gogolla uwe klaus richter gunter saake hans dieter ehrich 
conceptual modelling database applications extended er model 
data knowledge engineering 
eh hartmut ehrig habel 
graph grammars application conditions 
grzegorz rozenberg salomaa editors book 
springer verlag 
hartmut ehrig heckel martin michael lowe ribeiro annika wagner andrea corradini 
algebraic approaches graph transformation part ii single pushout approach comparison double pushout approach 
rozenberg 
ehr hartmut ehrig 
algebraic theory graph grammars 
claus cer 
ek hartmut ehrig hans jorg kreowski 
parallelism manipulations multidimensional information structures 
proc 
mathematical foundations computer science lecture notes computer science 
hartmut ehrig hans jorg kreowski grzegorz rozenberg editors 
proc 
graph grammars application computer science lecture notes computer science 
eln gregor engels claus lewerentz manfred nagl wilhelm schafer andy schurr 
building integrated software developments part tool specification 
acm transactions software engineering methodology 
hartmut ehrig manfred nagl grzegorz rozenberg editors 
proc 
graph grammars application computer science lecture notes computer science 
hartmut ehrig manfred nagl grzegorz rozenberg rosenfeld editors 
proc 
graph grammars application computer science lecture notes computer science 
eps hartmut ehrig michael hans jurgen schneider 
graph grammars algebraic approach 
ieee conf 
automata switching theory iowa city 
er joost engelfriet grzegorz rozenberg 
node replacement graph grammars 
rozenberg 
es gregor engels andy schurr 
hierarchical graphs graph types meta types 
corradini montanari cm 
fw william farmer ronald 
redex capturing term graph rewriting 
international journal foundations computer science 
joseph goguen claude kirchner jos meseguer 
concurrent term rewriting model computation 
proc 
graph reduction lecture notes computer science 
gks john richard kennaway ronan sleep 
experimental graph rewriting language 
ehrig 
got herbert 
der 

springer verlag berlin 
marc jan paredaens jan van den bussche 
graph oriented object database system 
sigmod record 
habel 
hyperedge replacement grammars languages 
lecture notes computer science 
springer verlag 
uwe gregor engels 
sql eer syntax semantics entity relationship query language 
information systems 
hht habel heckel gabriele taentzer 
graph grammars negative application conditions 
fundamenta informaticae 
michael himsolt 
graph ed interactive tool developing graph grammars 
ehrig 
hk habel hans jorg kreowski 
characteristics graph languages generated edge replacement 
theoretical computer science 
habel hans jorg kreowski detlef plump 
jungle evaluation 
fundamenta informaticae 
hof hoffmann 
term rewriting sharing memoization 
kirchner levi editors proc 
rd int conf 
algebraic logic programming alp lecture notes computer science 
hp berthold hoffmann detlef plump 
jungle evaluation efficient term rewriting 
proc 
algebraic logic programming 
mathematical research berlin 
akademie verlag 
lecture notes computer science 
hp berthold hoffmann detlef plump 
implementing term rewriting jungle evaluation 
rairo theoretical informatics applications 
hp habel detlef plump 
term graph narrowing 
mathematical structures computer science 
hug john hughes 
lazy memo functions 

jouannaud editor ifip conf 
funct 
lang 
comp 
arch lecture notes computer science 
hw heckel annika wagner 
ensuring consistency conditional graph grammars constructive approach 
corradini montanari cm 
jr dirk janssens grzegorz rozenberg 
structure node graph languages 
information sciences 
kah stefan 
uniqueness implementation 
bruynooghe wirsing editors proc 
programming language implementation logic programming lecture notes computer science 
kk hans jorg kreowski sabine 
interleaving semantics transformation units step grace 
cuny 
kks hans jorg kreowski sabine andy schurr 
nested graph transformation units 
international journal software engineering knowledge engineering 
richard kennaway jan willem klop ronan sleep fer jan de vries 
adequacy graph rewriting simulating term rewriting 
acm transactions programming languages systems 
klo jan willem klop 
term rewriting systems 
abramsky dov gabbay maibaum editors handbook logic computer science volume 
oxford university press 
ko kurihara azuma 
modularity term rewriting 
theoretical computer science 
kr hans jorg kreowski grzegorz rozenberg 
structured graph grammars ii 
information sciences 
kre hans jorg kreowski 
parallelism concurrency 
part derivations graph grammars 
ehrig 
kre hans jorg kreowski 
facets hyperedge replacement 
editor proc 
fundamentals computation theory lecture notes computer science 
norbert andy schurr bernhard westfechtel 
software engineering database system 
information sciences 
lam john lamping 
algorithm optimal lambda calculus reduction 
proc 
th symposium principles programming languages 
acm press addison wesley 
lb michael lowe martin beyer 
agg implementation algebraic graph rewriting 
claude kirchner editor proc 
rewriting techniques applications lecture notes computer science 
lm igor yves 
computing graph rewriting systems priorities 
theoretical computer science 
low michael lowe 
algebraic approach single pushout graph transformation 
theoretical computer science 
mw andrea 
kernel language programmed rewriting hyper graphs 
acta informatica 
nag manfred nagl 
set theoretic approaches graph grammars 
ehrig 
pad peter 
graph grammars operational semantics 
theoretical computer science 
pey simon peyton jones 
implementation functional programming languages 
prentice hall 
ph detlef plump habel 
graph unification matching 
cuny 
plu detlef plump 
graph reducible term rewriting systems 
ehrig 
plu detlef plump 
implementing term rewriting graph reduction termination combined systems 
stephane kaplan okada editors proc 
conditional typed rewriting systems lecture notes computer science 
plu plump 
hypergraph rewriting critical pairs undecidability confluence 
sleep 
plu detlef plump 
collapsed tree rewriting completeness confluence modularity 
michael rusinowitch jean luc emy editors proc 
conditional term rewriting systems lecture notes computer science 
plu detlef plump 
evaluation functional expressions hypergraph rewriting 
phd thesis universitat bremen 
plu detlef plump 
critical pairs term graph rewriting 
igor pr peter editors proc 
mathematical foundations computer science lecture notes computer science 
plu detlef plump 
termination graph rewriting 
manfred nagl editor proc 
graph theoretic concepts computer science lecture notes computer science 
plu detlef plump 
simplification orders term graph rewriting 
proc 
mathematical foundations computer science lecture notes computer science 
plu detlef plump 
termination graph rewriting undecidable 
fundamenta informaticae 
pr john rosenfeld 
web grammars 
proc 
int 
joint artificial intelligence 
pra terrence pratt 
semantic modeling hierarchical graphs 
acm sigplan symp 
prog 
lang 
def 
pra terrence pratt 
pair grammars graph languages string graph translations 
journal computer system sciences 
pve rinus plasmeijer marko van eekelen 
functional programming parallel graph rewriting 
addison wesley 
rao krishna rao 
graph reducibility term rewriting systems 
proc 
mathematical foundations computer science lecture notes computer science 
rao krishna rao 
modularity termination term graph rewriting 
proc 
rewriting techniques applications lecture notes computer science 
rm rosenfeld milgram 
web automata web grammars 
machine intelligence 
grzegorz rozenberg 
nlc way rewriting graphs 
ehrig 
grzegorz rozenberg editor 
handbook graph grammars computing graph transformations vol 
foundations singapore 
world scientific 
rs jan rekers andy schurr 
defining parsing visual languages layered graph grammars 
journal visual languages computing 
sch hans jurgen schneider 
chomsky systeme fur 
technical report universitat erlangen 
sch hans jurgen schneider 
formal systems structure manipulations 
technical report tu berlin 
sch andy schurr 
progres attribute graph grammar specification language 
manfred nagl editor proc 
graphtheoretic concepts computer science lecture notes computer science 
sch andy schurr 
mit formale und 
phd thesis technische hochschule aachen 
sch andy schurr 
progres language graph grammars 
ehrig 
sch andy schurr 
rapid programming graph rewrite rules 
proc 
usenix symp 
high level languages santa new mexico 
sch andy schurr 
programmed graph replacement systems 
rozenberg 
se hans jurgen schneider hartmut ehrig editors 
proc 
graph transformations computer science lecture notes computer science 
ronan sleep rinus plasmeijer marko van eekelen editors 
term graph rewriting theory practice 
wiley sons chichester 
sta john staples 
computation graph expressions 
theoretical computer science 
andy schurr andreas winter albert 
graph grammar engineering progres 
proc 
th european software engineering conf 
esec lecture notes computer science 
springer verlag 
sz andy schurr albert 
nondeterministic control structures graph rewriting systems 
schmidt rudolf editors proc 
graph theoretic concepts computer science lecture notes computer science 
tae gabriele taentzer 
parallel distributed graph transformation formal description application communication systems 
phd thesis shaker verlag 
tb gabriele taentzer beyer 
amalgamated graph transformation systems specifying agg algebraic graph grammar system 
schneider ehrig se 
ts gabriele taentzer andy schurr 
diego step module concept graph transformation systems 
corradini montanari cm 
wad christopher wadsworth 
semantics pragmatics lambda calculus 
phd thesis university oxford 
wan egon 
tools analyzing graph grammars 
ehrig 
albert 
eine fur 
phd thesis technische hochschule aachen 

