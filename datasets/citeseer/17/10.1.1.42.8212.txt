logic programming depth bounded bottom evaluation logic programs jan chomicki depth bounded bottom evaluation algorithm logic programs 
show sound complete terminating queries programs syntactically restricted datalog ns class logic programs limited function symbols 
datalog ns extension datalog capable representing infinite phenomena 
predicates datalog ns arbitrary unary limited ary function symbols distinguished argument 
precisely characterize computational complexity depth bounded evaluation datalog ns compare depth bounded evaluation evaluation methods top magic sets 
show universal safety finiteness query answers database decidable datalog ns 

non termination bottom query evaluation query processing algorithms deductive database systems bottom evaluation popular evidenced survey bancilhon ramakrishnan textbook ullman 
deductive database systems today bottom evaluation 
algorithm starts finite set facts database derives new facts deductive horn rules 
algorithm terminates new facts derived 
research partially supported nsf iri iri aro daal university maryland institute advanced computer studies 
address correspondence jan chomicki computing information sciences kansas state university manhattan ks mail chomicki cis ksu edu 
journal logic programming science publishing avenue americas new york ny immediately clear presence function symbols recursion rules infinitely facts may derived consequently bottom evaluation may fail terminate 
example 
rules describe schedule meetings professor students meets meets meets meets recursive rule expresses student meets professor time student meets professor time consider database containing facts meets emma emma kathy kathy emma rules derive infinitely facts database meets emma meets kathy meets emma meets kathy delta delta delta termination problem distinct subproblems 
bottom evaluation finite answer queries terminate 
example query list students meet professor time finite answer kathy query list students meet professor time 
straightforward bottom evaluation queries requires computation infinite relation meets 
second subproblem involves queries infinite answers example query list time instants professor meets emma 

datalog ns extension datalog address issue termination bottom evaluation queries context datalog ns class logic programs limited function symbols 
datalog ns programs type occurrences function symbols restricted way function symbols unary limited ary having single distinguished argument appear single distinguished argument predicates 
addition datalog ns study subset datalog single unary function symbol written postfix allowed 
program example valid datalog program 
datalog ns decidable 
context datalog ns infinite query answers finitely represented 
datalog ns programs potentially applications knowledge systems example temporal reasoning event scheduling planning pathfinding 
envision datalog ns programs input language intelligent office tools calendar personal planner 
subsequently tools provide answers user queries algorithms developed 
syntactic restrictions introduced motivated way 
distinguished argument function symbols may appear plays role state index time instant 
set facts distinguished argument may looked set facts holding state 
set finite may treated snapshot relational function free database 
unary function symbols seen denoting operators map states states maps state state 
restrictions type occurrences function symbols essential guarantee termination finite answer queries 
lifted resulting class logic programs undecidable 
example 
example distinguished variable denoted time instant 
plays role state situation 
function symbols correspond operators available robot 
example move stands robot moving position position situation example limited ary function symbol function symbol single distinguished argument 
complex term corresponds sequence robot moves path 
constant denotes empty path 
predicate path true path connecting predicate mem true edge path path position path move connected path mem move path connected mem move path connected mem path mem query list holds returns quadruples points robot move position path containing edge 
argue sense define study syntactically restricted logic programming languages particularly query termination guaranteed datalog datalog ns languages insufficient general purpose programming suitable concept definition languages 
example concept transitive closure defined datalog concepts infinite periodic set repeating path defined datalog ns query termination guaranteed undesirable situation arises user formulate rules defined concept corresponds 
cases datalog datalog ns query termination guaranteed program corresponds defined concept 
cases specific bounds complexity query evaluation established 
research direction pave way query evaluation methods terminate syntactically restricted classes logic programs efficiently arbitrary logic programs 

depth bounded evaluation want able evaluate finite answer query computing entire fixpoint infinite 
achieve goal finiteness query answer 
consider queries single atoms 
datalog ns finiteness answer guaranteed distinguished argument query atom ground term existentially quantified variable see queries example 
find way propagate information argument query program 
known problem area deductive databases studied names pushing selections projections rules 
methods achieve goals rule rewriting 
surprisingly able guarantee termination bottom evaluation finite answer datalog ns queries 
methods magic sets defined bancilhon maier sagiv ullman introduce additional termination problems noticed ramakrishnan seki :10.1.1.32.1488
obtain termination different way 
essentially show context datalog ns sufficient consider ground refutations containing terms bounded depth 
consequently bottom evaluation facts terms bounded depth generated 
provide tight upper lower bounds term depth refutations 
call algorithm depth bounded evaluation 
depth bounded evaluation bottom counterpart bounded depth search proposed stickel 
depth bounded evaluation works queries ground existentially quantified distinguished argument 
cases queries distinguished argument free variable finite answers 
depth bounded evaluation complemented safety tester algorithm checks query answer finite 
show testing relative safety finiteness answer set rules set facts universal safety finiteness answer set rules set facts decidable datalog ns fact depth bounded bottom evaluation testing relative safety report unsafe generated facts get large 
shows datalog ns akin datalog kinds safety decidable full prolog recursively enumerable 
interesting compare depth bounded evaluation query processing algorithms datalog ns 
data complexity algorithms matches corresponding lower bounds query evaluation pspace complete datalog exptime complete datalog ns case evaluation requires exponential time datalog double exponential time datalog ns shown datalog informally complexity function database size size rules 
polynomial bound refutation size guarantees depth bounded bottom evaluation terminate polynomial time 
property identify polynomial time computable subclasses datalog reasons studying depth bounded bottom evaluation 
bottom evaluation resolution algorithms constructs bindings existentially quantified variables query 
provide boolean answers enumerate answer substitutions 
case lower bound algorithms mentioned yield answers 
second rule optimization methods assumption queries evaluated bottom 
able combine methods depth bounded evaluation obtain practical query processing system datalog ns third better single evaluation mode bottom top works arbitrary logic programs incompatible procedures applicable restricted classes logic programs 

summary summary 
section define syntax semantics datalog ns section introduce depth bounded evaluation show upper lower bounds execution time datalog ns section compare depth bounded evaluation query evaluation algorithms datalog ns particular consider lower bound algorithms algorithms construct finite representations infinite query answers 
discuss algorithm top algorithms resolution 
show close connection depth bounded evaluation bounded depth search 
discuss magic sets 
section show relative universal safety decidable datalog ns relate results works dealing safety problem 
section summarize results discuss prospects 

basic notions recalling standard definitions terminology logic programming datalog detail reader referred books lloyd ullman 
definitions attempt capture intuition datalog ns deal separate domains domain standard unstructured database constants called data terms domain inductively built objects called functional terms 

syntax atom form predicate symbol arity term usual order logic sense 
term atom said ground variable free 
fact ground atom 
database finite set facts 
set facts extension predicate symbol arity set facts form rule formula written bm clausal form delta delta delta bm bm atoms called head bm body rule individual called subgoals 
logic program finite set rules database 
variables rules implicitly universally quantified 
query atom functional argument variable ground term 
consider queries closed existential quantifiers 
query free variable open closed 
fact query ground atomic query 
simple query atom arguments distinct free variables 
query defined represented simple query additional rule convenient assumption part sections 
formula logic program possible addition negation query formula clausal form 
distinguish extensional database edb intensional database idb predicates 
edb predicates correspond relations defined database idb predicates correspond derived relations defined rules 
edb predicates may appear database facts bodies rules idb predicates appear rules queries database facts 
datalog language function free logic programs logic programs terms constants variables 
call terms data terms 
datalog ns extension datalog atoms terms may single distinguished argument said functional addition usual data arguments 
functional arguments functional terms built distinguished functional constant data constants functional variables data variables distinct functional variables function symbols 
data arguments atom term data terms 
data terms appear data arguments 
implies functional term contains single occurrence single functional variable 
instance functional variable functional terms 
functional term atom viewed tree node son leaf 
distinguish functional predicates functional argument data predicates data arguments 
depth variable constant 
depth complex functional term equal plus depth functional argument 
definition datalog allows special built predicates equality inequality 
results hold equalities inequalities data terms allowed 
proof decidability universal safety requires exclusion inequalities 
study separately datalog programs datalog ns programs exactly unary function symbol 
class defined earlier expressive power function free studied abadi manna 

restrictions number assumptions ffl rules range restricted variable limited 
variable limited appears literal body rule equated equality limited variable assume constants rules 
ffl equalities eliminated picking variable class equated variables substituting variables 
transformation range restricted rule variable appear literal body 
ffl rules contain ground terms 
terms eliminated introducing additional predicates 
ffl rules normal 
datalog ns rule semi normal contains functional variable variable appears appear functional argument atom 
datalog ns rule normal functional terms depth 
convenience assume set normal rules functional variables different rules identical just functional variable program usually named set datalog ns rules equivalent set normal datalog ns rules 
show obtain 
ffl non unary function symbols eliminated instantiating data variables appearing functional terms data constants appearing program creating new unary function symbol combination 
transformation number function symbols rules program may database dependent 
affect results obtained universal safety 
assumption justifies name datalog ns datalog successors considering programs unary function symbols successors 
treating different successor letter empty string view ground functional terms successors strings finite alphabet 
notation generally follow prolog notation 
delta delta delta denotes complex term delta delta delta delta delta delta denotes delta delta delta delta delta delta times denotes delta delta delta delta delta delta times vector terms written terms variables terms ground 

semantics interpretation mean herbrand interpretation formula identified subset herbrand base model herbrand model 
herbrand universe herbrand base datalog ns formula function symbol infinite 
results van emden kowalski datalog ns program herbrand model intersection herbrand models contains facts implied model considered intended meaning program model infinite presence function symbols see example 
van emden kowalski define mapping herbrand interpretations herbrand interpretations ts fa fact ground instance rule sg successive iterations defined follows 
ts 
equal fixpoint denoted lfp 
lfp ms 

query evaluation assuming interpretation pi phi formulas phi means model phi pi phi means pi implies phi 
substitution free variables query answer substitution set facts ground 
open answer denoted ans set answer substitutions closed answer 
evaluation computation answer queries considered clearly monotonic ans ans logic program query answer substitutions interest herbrand model ans ms 
function symbols rules may infinitely countably ground answer substitutions ms algorithm evaluating query sound computed substitution element ans complete substitution ans computed finite time terminating computation terminates 
task obtaining answer substitutions query finite representation called generation task providing answer ms recognition 
query finite answer query ans finite 
ms may infinite explicitly answer substitutions computed directly definition 
quantifier free positive query condition closed existential quantifiers equivalent 
particular ground equivalent condition equivalent unsatisfiability formula set clauses qg 
procedures determine existence herbrand model qg recognition 

depth bounded bottom evaluation section show bottom evaluation algorithm computes fixpoint set horn rules 
presence function symbols rules may lead infinite fixpoint algorithm may fail terminate datalog ns show depth bounded bottom evaluation algorithm datalog ns terminates finite answer queries 
prove correctness analyze complexity 
section compare algorithm evaluation algorithms datalog ns section study problem detecting infinite query answers datalog ns safety 

bottom evaluation describe standard algorithm bottom evaluation logic programs 
algorithm straightforward implementation operator defined previous section 
may seen form hyperresolution 
sequel assume logic program consists finite set rules finite database application set rules database defined rule rule basis 
take rule am ground substitution 
describes bottom algorithm iterations loop lfp mz mz infinite iterations necessary compute 
repeat 
bottom evaluation algorithm algorithm easily adapted evaluate query herbrand model mz add evaluation inside loop 
correct iteration mz queries consider monotonic 
finitely iterations finite rules range restricted 
evaluated relational database 
algorithm usually termed naive evaluation improved ways 
particular semi naive evaluation incremental variant algorithm 
rest assume naive evaluation simplicity 
results easily adapted variants semi naive evaluation 
clearly query infinite answer generation answer terminate 
recognition guaranteed terminate logic programming language consideration capable expressing computations arbitrary turing machine 
case unrestricted logic programs shown 
datalog ns intermediate case 
fixpoints query answers may infinite see example terminating sound complete recognition algorithm 
algorithm different bottom evaluation 
resolution hyperresolution 
hand bottom evaluation terminate datalog ns requires computation entire fixpoint may infinite 
question bottom evaluation terminate preserving soundness completeness case datalog ns interested termination recognition generally termination evaluation finite answer queries 
achieve goal introduce notion depth bounded bottom evaluation 
intuitively going impose finite bound depth atoms derived bottom evaluation 
bound large query evaluation remain complete 
finite bound exist arbitrary logic programs exist datalog ns due syntactic restrictions imposed type occurrences function symbols 
assume non negative integer 
define bounded version datalog ns rule rule jm identical body contains subgoal depth called depth constraint term appears functional argument head atom example rules example bounded version meets meets depth meets meets depth similar way define jm bounded version set datalog ns rules slightly extend notion rule application ground substitutions considered added depth constraint true 
depth bounded evaluation defined way 
algorithm application replaced application jm bounded version resulting algorithm terminates finitely facts generated 
evaluate finite answer query sound value achieve completeness sufficiently large 
order find appropriate value necessary look closer various parameters datalog ns program 

deriving depth bound glance obvious bounded bottom evaluation finite complete evaluation procedure finite answer datalog ns queries 
arbitrary logic programs isn fixpoints datalog ns programs repetitive structure fact bound depth terms appearing bottom evaluation 
formally characterize introduce new notions 
definitions assume set functional data facts ground functional term 
finite 
finitely generated number different constant function symbols appearing elements finite 
fixpoint defined earlier property 
define snapshot fp may thought result selection oe 
additionally finite data arguments assume finitely values 
define state fp may thought result projecting functional arguments predicates 
finite function free database 
finitely different states 
known entire set reconstructed 
define data part set data facts set finite 
consider datalog ns program consisting set rules database query parameters program query identified maximal arity predicate number facts database number different data constants maximum depth ground functional term term 
depth functional term term 
denote size number facts state mz may contain facts built symbols appearing considered 
functional predicates arity size sigma gamma similarly data predicates arity data part mz may contain size facts size sigma fixed set rules size size polynomial functions number data constants database polynomial functions number facts database 
define range number different states mz number facts state bounded size range size size polynomial function number facts database 
special cases range bounded polynomial size database mentioned previous section evaluating ground query model logic program equivalent testing unsatisfiability formula qg 
evaluating query free variables consists constructing ground substitutions unsatisfiable 
consider closed queries 
define basis datalog ns formula phi qg way basis phi max range basis phi max size show reduce satisfiability datalog ns formula phi existence finite model formula phi derived phi 
define instance datalog ns formula phi result substituting ground functional term single functional variable phi 
instance ground data variables may unbound 
clear model phi iff model functionally grounded instance 
example 
assume rule follows functionally grounded instance rf datalog ns formula phi define phi follows phi depth ground functional terms built function symbols appearing phi considered 
notice phi finite formula 
lemma 
phi satisfiable iff phi satisfiable basis phi 
proof 
folk result referenced papers 
haven able locate proof appendix result needed fundamental property models datalog ns programs 
lemma 
datalog ns program maximum depth functional term ground functional terms depth greater equal function symbol mz mz mz mz corollary 
fact mz depth range infinitely different terms mz proof 
range different states mz different terms depth greater equal proper subterm subterm mz mz 
lemma repeatedly conclude proper subterm depth mz mz 
assume delta delta delta 
lemma repeatedly obtain mz mz delta delta delta 
fact mz way infinitely facts satisfying thesis obtained 
prove main results section 
theorem shows soundness completeness depth bounded bottom evaluation queries 
theorem shows somewhat larger finite bound finite answer queries completely evaluated 
notation introduced earlier section 
theorem 
basis phi bounded bottom evaluation closed query sound complete 
proof 
finite set facts computed bounded bottom evaluation 
mz mz monotonic herbrand model phi qg unsatisfiable soundness 
phi unsatisfiable phi depth lemma 
formula phi fully grounded version phi unsatisfiable 
phi finite obtain phi data constants phi finite number 
completeness ground hyperresolution ground hyperresolution refutation phi construction refutation consists data facts functional facts functional terms depth induction length refutation easy see refutation obtained bounded bottom evaluation 
way completeness obtained 
theorem 
max delta range bounded bottom evaluation finite answer query sound complete 
proof 
data variables free analysis applies 
examine case functional variable free 
soundness immediate evaluation gives substitution mz 
assume answer substitution mz mz 
denote ground functional term functional variable mapped 
depth range infinitely different answer substitutions mz differ terms assigned functional variable corollary 
answer ms infinite contradiction 
conclude depth range 
consequently basis max depth range delta range ground refutation containing facts terms depth delta range 
refutation obtained bounded bottom evaluation delta range see proof previous theorem 
note view theorem context datalog ns answer query finite iff computed terminating algorithm 
context notions safety query answer finiteness existence terminating algorithm compute answer called effective computability coincide 
depth bounded evaluation algorithm bf 
note bounded evaluation max bounded evaluation max delta range 
reason modification follows calculated directly text program 
tighter bound range size provided bound may algorithm bf 
repeat jm evaluate 
depth bounded bottom evaluation algorithm bf termination depth bounded evaluation obtained different way 
introducing depth constraints termination condition changed atoms terms depth equal basis phi gamma 
computational complexity estimating execution time depth bounded evaluation datalog ns assume set rules fixed database query vary 
common assumption database theory called data complexity chandra harel vardi 
theorem 
execution time bounded evaluation basis phi bounded function double exponential number facts database 
case datalog bound reduced single exponential 
proof 
loop iteration new fact obtained 
number generated facts bounded nr delta delta size size number ground terms depth built constant function symbols appearing phi 
basis phi exponential size database presence just unary function symbol exactly ground term depth 
unary function symbol number terms depth exponential time bound execution bf single exponential datalog double exponential datalog ns theorem 
set datalog rules ground datalog query infinite family datalog databases property dn size polynomial test unsatisfiability phi dn qg interpreter bf derive set facts cardinality exponential proof 
basic idea encode adding bit number 
predicates time th bit 
zero time th bit 
time th bit changed 
time th bit changed 
database dn contains facts zero additionally fact 
set rules follows zero zero zero zero zero pair rules describes pattern bits change 
second pair rules describes pattern bits change 
third pair rules describes bits time fourth pair rules describes bits time 
rule contains constant rule replaced constant free rule additional database fact 
query requires derivation set facts cardinality exponential theorem 
set datalog ns rules ground datalog ns query infinite family datalog ns databases property dn size polynomial test unsatisfiability phi dn qg interpreter bf derive set facts cardinality double exponential proof 
database identical proof theorem 
set rules take copies rules proof function symbol replacing replacing 
additionally add rules query simply 
ground functional term depth gamma fact generated interpreter bf 
necessary derive execution bf require derivation double exponential number facts 

comparison evaluation algorithms survey number approaches evaluating datalog ns queries 
compare depth bounded bottom evaluation number evaluation algorithms datalog ns earlier 
analyze sources differing computational properties algorithms 
briefly comment algorithm extensively top evaluation sld resolution 
particular going show close connection depth bounded evaluation bounded depth search 
discuss impact rule rewriting methods magic sets termination bottom evaluation 

evaluation algorithms datalog ns lemma immediately suggests method check satisfiability datalog ns formula phi qg 
formula phi contain non ground functional terms may considered function free formula 
establish satisfiability phi sufficient consider finite herbrand interpretations 
fact consider interpretations defined states depth approach simply enumerate interpretations check model phi details approach just mention leads recognition algorithms pspace data complexity datalog algorithm exptime data complexity full datalog ns algorithm 
algorithms earlier 
plaisted furer 
bounds improved unsatisfiability datalog resp 
datalog ns pspace data complete resp 
exptime data complete 
previous approach method effectively construct finite representation model mz lemma provides theoretical foundation method 
finite representation subsequently evaluate queries 
shown method evaluation called algorithm qf achieve best possible complexity bounds mentioned 
algorithm qf uses recognition algorithm subroutine variants qf qf qf bf qf bf 
interested finding 
algorithm consideration recognition generation computing entire answer 
algorithm terminates achieves lower complexity bound pspace datalog exptime datalog ns 
algorithm scales runs polynomial time restricted classes rules 
algorithm works supersets datalog ns recognition algorithm generation algorithm accept existentially quantified variables queries evaluate queries computing bindings variables 
recognition algorithm generation answers existential query computing bindings existentially quantified variables query 
terminates achieves lower bound scale 
know non trivial restriction rules trivial example exclusion function symbols recursive rules guarantee runs polynomial time 
algorithm works extension datalog ns clauses required horn 
recognition algorithm datalog shares properties depth bounded evaluation algorithm bf recognition generation query answer finite see section methods check condition 
algorithm bf terminates achieve lower bound 
example theorem algorithm algorithm bf execute exponential number steps 
contrast guaranteed bf runs polynomial space 
algorithm works single exponential time bf requires general double exponential time clearly deficient 
polynomial bound basis phi guaranteed bf run polynomial time datalog programs 
case enumeration approach inherent 
depth bounded evaluation requires clauses horn sense bf general datalog programs considered 
generation algorithm qf terminates achieves lower bound closed open queries 
complete queries infinite answers constructs finite representation answer 
scale uses recognition algorithm 
generation algorithm qf bf terminates achieve lower bound scales bf runs polynomial time datalog polynomial bound basis phi guaranteed 
qf qf bf require rules horn construct finite representation herbrand model program 
algorithms presuppose input program datalog ns program 
handle simple extensions datalog ns non horn clauses 
complete refutation procedures arbitrary logic programs 
rule rewriting methods introduced order efficiently evaluate query additional information query variable bindings existential quantification 
methods applicable yield significant gains performance rules executed bottom 
algorithm bf able benefit 
unclear algorithms qf able methods 
look possible sources differences complexity algorithms 
case datalog bf constructs exponentially sized ground hyperresolution refutation theorem 
clear ground resolution refutation formula constructed proof theorem contain clauses ground terms depth gamma size refutation exponential 
non ground resolution issue subtle 
exponentially sized ground refutations non ground counterparts polynomial 
example 
take datalog ns program query evaluate query bottom steps needed 
minimal size ground resolution refutation 
rule resolved shorter step refutation suffices 
sequence clauses obtained delta delta delta clause yields unsatisfiability steps 
terms encoded binary size refutation polynomial 
lower bound example theorem contains non linear clauses acceleration possible size obtained nonground resolvents grows exponentially 
pursue issue conjecture lower bound example datalog theorem produce exponentially sized refutations variant resolution 
case full datalog ns interpreter works single exponential time bf requires general double exponential time 
trace deficiency inability ground resolution hyperresolution deal isomorphic 
open problem resolution method match upper bound achieved proposed resolution procedure uses atom ordering clause condensation essentially tableau minimization 
procedure attractive properties 
complete recognition procedure arbitrary logic programs 
fact refutation procedure arbitrary order formulas 
second terminating datalog ns queries finite answers require termination bound calculated text program supplied 
combined sld resolution resulting procedure incomplete 
completeness require ability resolve rules 
clear efficiently implement facility 
number researchers pursued ideas 
considered various classes formulas clausal form decided resolution hyperresolution 
particular book gives hyperresolution decision procedure applied datalog ns procedure requires similarly depth bounded bottom evaluation program dependent bound supplied 

top evaluation top evaluation sld resolution practical incarnations prolog evaluation procedure introduces additional problems termination 
guaranteeing termination memoing breadth search ground loop checking possible datalog programs generally logic programs finite fixpoints 
presence infinite fixpoints methods insufficient obtain termination finite answer datalog ns queries 
technique necessary finite bound size ground refutations 
bounded depth search proposed stickel technique 
version due keefe means example 
example 
extend example 
predicate names shortened 
query 
keefe method yields rules added arguments count number resolution steps refutation 
database modified contains facts facts contain variables problem considering top evaluation 
query follows equal number steps sld resolution necessary evaluate query 
number equal nr maximum number literals body rule nr equal number distinct facts generated depth bounded bottom evaluation program theorem 
context datalog shown naughton ramakrishnan top evaluation fact exponentially efficient bottom evaluation 
top bounded depth search terminates counts number resolutions 
bound term depth top refutations imposed loop detecting techniques required obtain termination 
method come correct value bound dispense knowledge 
iterative deepening algorithm invokes bounded depth evaluation consecutive integer bounds 
point value bound reaches nr time possible refutation 
clear terminate iterative deepening correct value nr advance 
saturation test terminating new answer substitutions obtained current iteration leads incompleteness datalog ns 
rule rewriting methods argue termination bottom evaluation finite answer datalog ns queries general obtained existing rule rewriting methods goal push selections projections rules 
clearly able consider methods 
study magic sets best known methods pushing selections rules 
try show methods kind incapable guaranteeing termination introduce additional sources non termination 
example 
consider program example query 
result applying magic sets follows magic magic magic magic magic magic magic magic magic magic query finite answer bottom evaluation transformed version program terminate relation magic infinite 
achieve completeness example relation magic contain finite database dependent number facts 
possible achieve effect magic sets rule rewriting method 
addition magic predicates rules need magic bound limit magic facts generated bottom finite number 
mentioned inherent difficulty evaluating programs example noticed literature 
kifer call diverging cycle feeding converging 
technique called signatures helpful opposite situation converging cycle feeding diverging 
seki presents variant technique context magic sets 
technique originates sato tamaki 
ramakrishnan recognizes additional sources non termination introduced magic sets transformation :10.1.1.32.1488
clearly datalog ns programs queries magic sets provide termination 
example rules query magic fact magic magic finite relation bottom evaluation program terminate 
program example transformed hand program bottom evaluation terminates 
deal complicated program example resulting adding clauses program proof theorem longer clear obtain equivalent terminating program evaluates query program exists 
conjecture datalog ns programs finite answer queries rewritten database independent way yield program bottomup evaluation terminates 
claim true highlight inherent limitation rule rewriting methods applied task improving termination behavior logic programs 
proving disproving claim formidable task leave research 
noted rule rewriting methods applied improve execution time datalog ns programs 
claim combining methods standard bottom evaluation guarantee termination finite answer datalog ns queries 
achieve termination bottom evaluation replaced depth bounded version 

safety section deal issue infinite query answers 
answer query infinite depth bounded bottom evaluation complete 
discuss approaches problem 
approach interested relative safety answer query finite set rules database 
relative safety determined depth bounded evaluation sufficiently large bound 
user get addition finite set answer substitutions replies answer substitutions infinitely answer substitutions 
second approach set rules query tested universal safety answer query finite database 
query universally safe user know depth bounded evaluation query appropriate bound complete 
query retested universal safety rules change 
updates database common rule changes influence universal safety definition 
show testing universal safety datalog ns decidable similarly datalog consider simple queries queries consisting single atom arguments different variables 
restriction query simple add new rule body head atom new idb predicate symbol arguments distinct equal free variables 
relative safety theorem 
datalog ns program maximum depth functional term delta range 
answer simple datalog ns query infinite iff bounded bottom evaluation returns substitution functional variable mapped ground term range depth delta range proof 
right left direction follows immediately corollary 
assume bounded evaluation return substitution satisfying condition 
answer substitution existed bounded evaluation return theorem 
conclude exist 
answer substitution functional variable mapped ground term depth greater delta range 
substitution missed bounded bottom evaluation 
easy consequence lemma term range depth delta range mz mz 
answer substitution maps functional variable identical maps functional variable contradiction 
consequently substitutions missed bounded evaluation answer finite 
approach testing relative safety datalog ns queries 
finiteness query answer detected finite representation model mz 
algorithm works exponential time datalog ns polynomial space datalog superior method complexity double exponential time theorem single exponential time respectively theorem 
testing relative safety bottom depth bounded evaluation advantages 
example bottom evaluation scales better pointed previous section 
rule rewriting may improve execution time 

universal safety theorem 
set datalog ns rules xn simple datalog ns query 
decidable ans mz finite database proof 
proof consists major steps reduction monadic datalog ns subset datalog ns predicates arity proof universal safety decidable monadic datalog ns ans mz infinite database ans mz infinite database obtained replacing data constant arbitrary single data constant 
reverse implication trivially true 
easily seen bottom computation mz mz requires infinitely iterations compute answer query 
crucial rules range restricted contain inequality symbol 
define skeleton datalog ns term atom result removing data arguments definition extended obvious way clauses sets clauses 
claim ans mz infinite iff ans infinite 
easily seen bottom computation simulates mz step step 
skeleton monadic datalog ns program 
show detecting universal safety decidable monadic datalog ns formulating universal safety sentence monadic second order theory infinite ary tree sns shown decidable rabin 
going show construction example query 
consider formula oe second order variables correspond predicates respectively oe formula expresses property contains result query database consisting interested smallest satisfying oe 
expressed smallest oe oe universal safety expressed finite finite finite smallest thomas shows express finite meaning finite lexicographic ordering strings ordering turn expressed sns 
construction possible correspondence ground functional terms strings finite alphabet 
may appear non unary function symbols allowed definition datalog ns may create additional problems 
symbols eliminated result elimination database dependent universal safety database independent property 
skeleton construction easily generalized datalog ns programs non unary function symbols 
resulting monadic datalog ns programs database independent set unary function symbols 
note 
provide elementary fixed height exponential upper bound time complexity universal safety problem datalog ns follows 
notice datalog ns program sns formula expresses universal safety simple query involving predicate program contains bounded number negations elimination order variables result klarlund complementation rabin tree automata done single exponential time known correspondence automata sns conclude complexity universal safety datalog ns elementary 
exact complexity universal safety datalog ns remains open problem 

related safety shmueli kifer show relative universal safety datalog decidable arbitrary logic programs recursively enumerable 
far know datalog ns class logic programs function symbols problems decidable 
notion safety studied ramakrishnan bancilhon silberschatz kifer ramakrishnan silberschatz sagiv vardi 
different model assumed function symbols infinite edb relations finiteness monotonicity constraints 
model usually called extended datalog 
extension edb predicate satisfies finiteness constraint sets argument numbers tuple set values tuples agree finite 
extension edb predicate satisfies monotonicity constraint oe tuple value argument argument comparing models infinite relations vs function symbols issues addressed 
error approximation queries safe function symbol model fail safe infinite relation model second computational complexity safety testing query safe infinite relation model safe function symbol model function symbols provide special instances infinite relations appropriate constraints 
models 
reflect special role functional argument datalog ns predicates compare monadic datalog ns monadic extended datalog monadic idb predicates 
universal safety monadic extended datalog finiteness constraints checked polynomial time 
case approximation provided constraints crude safe queries missed 
example 
consider datalog ns program query 
program corresponds extended datalog program binary edb relation captures successor function symbol 
finiteness information expressed finiteness constraints universal safety model requires answers query finite extensions satisfy constraint finite extensions satisfy remaining constraints 
codes exactly successor 
example consider infinite extension delta delta delta extension consisting 
answer edb infinite 
classified unsafe infinite relation model clearly safe 
monotonicity constraints really help witnessed example 
example 
consider datalog ns program program modelled extended datalog program function symbols replaced binary relations respectively monotonicity constraints oe oe appropriate finiteness constraints property intersection extensions finite lost 
consequently query classified model unsafe clearly safe 
complexity decidability testing universal safety monadic extended datalog presence monotonicity constraints addition finiteness constraints knowledge established 
decidability universal safety extended datalog unknown 
various sufficient conditions universal safety developed 

shown bottom query evaluation algorithm datalog ns class logic programs limited function symbols 
algorithm sound terminating complete finite answer queries 
shown relative universal safety datalog ns decidable 
criteria compared different query evaluation methods datalog ns analysis complemented comparison practical implementations methods 
example classified algorithms membership specific complexity classes rough measure 
general depth bounded evaluation looks promising various implementation techniques developed logic programs example incremental evaluation rule rewriting methods 
earlier results datalog tractable classes datalog ns identified 
interesting see classes logic programs evaluated depth bounded approach 
depth bound easily obtained text program validated referring non trivial properties datalog ns ways obtaining depth bounds ways rely analysis single program properties entire class programs 
context may fruitful explore connections ullman van gelder sohn brodsky sagiv deriving constraints argument sizes logic programs 
simple notion depth bound inequality form depth may generalized bound constraints constraints built arithmetic expressions involving various parameters terms depth number subterms 
similar ideas pursued context top evaluation potter 
challenging establish power depth bound evaluation vis vis rule rewriting methods magic sets 
replicate termination behavior 
positive negative answer question interesting 
interesting compare exact approximate infinite relation model safety analyses various syntactically restricted classes logic programs 
properties interest include error approximation computational complexity analyses 
believe research reported step finding general evaluation method logic programs terminate interesting syntactically defined classes programs 

acknowledgments revised version part ph dissertation written rutgers university supervision professor tomasz nski 
gratefully acknowledge participation stage doctoral research 
early versions results joint seventh acm sigact sigmod sigart symposium principles database systems march austin texas 
am grateful professor jack minker supporting continuation research university maryland dr damian niwi nski discussions leading proof theorem 
detailed comments anonymous referees gratefully acknowledged 

abadi manna 
temporal logic programming 
journal symbolic computation september 


generalised completeness horn predicate logic programming language 
acta cybernetica 

bancilhon maier sagiv ullman 
magic sets strange ways implement logic programs 
acm sigact sigmod sigart symposium principles database systems 

bancilhon ramakrishnan 
amateur recursive query processing strategies 
stonebraker editor readings database systems 
morgan kaufmann 


temporal logic programming complete expressive 
acm sigact sigplan symposium principles programming languages 

brodsky sagiv 
inference inequality constraints logic programs 
acm sigact sigmod sigart symposium principles database systems 

chandra harel 
structure complexity relational queries 
journal computer system sciences 

chomicki 
functional deductive databases query processing presence limited function symbols 
phd thesis rutgers university new brunswick new jersey january 
laboratory computer science research technical report lcsr tr 

chomicki 
polynomial time computable queries temporal deductive databases 
acm sigact sigmod sigart symposium principles database systems nashville tennessee april 

chomicki nski 
temporal deductive databases infinite objects 
acm sigact sigmod sigart symposium principles database systems austin texas march 

chomicki nski 
relational specifications infinite query answers 
acm sigmod international conference management data portland oregon may 

chomicki nski 
finite representation infinite query answers 
acm transactions database systems june 

lewis 
logical syntax computational complexity 
computation proof theory pages 
springer verlag lecture notes mathematics 

ch 

resolution variant deciding classes clause sets 
borger richter editors workshop computer science logic pages 
springer verlag lncs 

ch 

resolution methods decision problem 
springer verlag lncs 

furer 
alternation ackermann case decision problem 


green 
application theorem proving problem solving 
international joint conference artificial intelligence 

jr resolution strategies decision procedures 
journal acm july 

kifer 
safety domain independence database queries 
data knowledge base conference jerusalem israel 

kifer 
implementing logic programs database style 
ieee transactions software engineering 

kifer ramakrishnan silberschatz 
axiomatic approach deciding query safety deductive databases 
acm sigact sigmod sigart symposium principles database systems pages austin texas march 

klarlund 
progress measures immediate determinacy subset construction tree automata 
ieee symposium logic computer science 

krishnamurthy ramakrishnan shmueli 
framework testing safety effective computability extended datalog 
acm sigmod international conference management data 


deciding horn clauses hyperresolution 
borger richter editors workshop computer science logic pages 
springer verlag lncs 

lewis 
complexity results classes quantificational formulas 
journal computer system sciences 

lloyd 
foundations logic programming 
springer verlag nd edition 

naqvi tsur 
logical language data knowledge bases 
computer science press 

naughton ramakrishnan 
bottom evaluation logic programs 

lassez plotkin editors computational logic pages 
mit press 

keefe 
craft prolog 
mit press 

plaisted 
complete problems order predicate calculus 
journal computer system sciences 


termination proofs logic programs predicate inequalities 
warren szeredi editors international conference logic programming pages 
mit press 

rabin 
decidability second order theories automata infinite trees 
transactions ams 

ramakrishnan 
magic templates approach logic programs 
journal logic programming 

ramakrishnan bancilhon silberschatz 
safety recursive horn clauses infinite relations 
acm sigact sigmod sigart symposium principles database systems pages 

ramakrishnan srivastava sudarshan 
coral control relations logic 

yuan editor international conference large data bases pages vancouver canada august 
morgan kaufmann 

robinson 
automatic deduction hyperresolution 
international journal computer mathematics 

sagiv vardi 
safety datalog queries infinite databases 
acm sigact sigmod sigart symposium principles database systems pages philadelphia pennsylvania march 

sato tamaki 
enumeration success patterns logic programs 
theoretical computer science 

seki 
power alexander templates 
acm sigact symposium principles database systems pages philadelphia pennsylvania march 

shmueli 
equivalence datalog queries undecidable 
journal logic programming february 

sohn van gelder 
termination detection logic programs argument sizes 
acm sigact sigmod sigart symposium principles database systems 

stickel 
prolog technology theorem prover 
ieee symposium logic programming pages 

tamaki sato 
old resolution tabulation 
international conference logic programming pages 
springer verlag 


resolution program able decide solvable classes 
martin lof mints editors pages 
springer verlag lncs 



horn clause computability 
bit 

thomas 
automata infinite objects 
jan van leeuwen editor handbook theoretical computer science volume chapter pages 
elsevier mit press 

ullman 
principles database knowledge base systems volume 
computer science press 

ullman 
principles database knowledge base systems volume 
computer science press 

ullman van gelder 
efficient tests top termination logical rules 
journal acm 

kemp somogyi stuckey 
design overview deductive database system 
ieee international conference data engineering pages 

van emden kowalski 
semantics predicate logic programming language 
journal acm 

van gelder 
deriving constraints argument sizes logic programs 
acm sigact sigmod sigart symposium principles database systems pages nashville tennessee april 

vardi 
complexity relational query languages 
acm sigact symposium theory computing pages 

potter 
metalogical control logic programs 
journal logic programming october 


recursive query processing power logic 
theoretical computer science 


maslov inverse method decidable classes 
annals pure applied logic 
finite satisfiability lemmas prove lemma asserts datalog ns formula phi qg satisfiable iff phi satisfiable basis phi 
non trivial direction right left 
formula phi basis phi contain non ground functional terms looked function free formula 
phi satisfiable finite model maximum depth ground functional terms phi model completely characterized states ground terms depth states empty 
construct model phi repetitive structure 
start definitions 
formula phi basic form satisfies restrictions ffl predicates functional 
ffl ground functional term facts program query 
assume phi basic form 
ground functional term initial subterms ground functional term repeating initial 
construct inductively induction depth terms 
take 
assume constructed terms depth smaller determined term initial 
take term depth initial put copying 
repeating initial subterm 
put reusing 
shown easy induction constructed satisfies properties ffl initial subterm initial 
ffl initial subterm initial 
follows subterms initial term correspond different states 
range different states considered states mz considered conclude initial depth range see facts terms depth copied remainder constructed reusing show model phi 
take instance initial construction ffl subterms particular 
ffl function symbols lemma proved conclude truth truth repeating find subterm initial 
consequently 
construction function symbol lemma conclude truth truth phi basic form guarantee ground terms phi data parts agree subterm term phi subterm simply put result term phi 
preserve agreement bigger initial part copied depth max depth max subterm put 
facts terms depth copied basis phi max range 
rest argument essentially 
lemma appropriately generalized 
lemma 
assume herbrand interpretations datalog ns formula phi basic form ground functional terms function symbol 
iff proof 
take ground substitution ground assume data variables different clauses renamed apart 
functional atom ground 
function symbol view assumptions corresponding literal truth value substitution equality inequality true false 
ground iff thesis follows 

