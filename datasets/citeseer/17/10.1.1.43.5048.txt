debugging standard ml reverse engineering andrew tolmach andrew appel department computer science princeton university cs tr march acm conference lisp functional programming nice june 
built novel efficient replay debugger standard ml compiler 
debugging facilities provided instrumenting user source code approach feasible ml safety property machineindependent back independent 
replay practical ml normally functionally compiler uses continuation passing style program state checkpointed quickly compactly call current continuation 
instrumentation replay support simple elegant debugger featuring full variable display polymorphic type resolution stack trace back reverse execution compiler highly optimizing run time stack 

traditional source level debuggers real machine level 
rely detailed information underlying machine model compiler back runtime system 
debuggers typically access original source text symbol table data coordinating source object run time requires extensive reverse engineering difficult 
result source level debuggers typically characterized limited functionality poor portability considerable inter supported part nsf ccr 
nal complexity 
problems greatly exacerbated presence compiler optimization task mapping machine code back original source essentially impossible hennessy 
standard ml new jersey sml nj appel highly optimizing compiler standard ml language milner 
fact completely transforms code times lambda calculus continuation passing style global optimization phases 
difficult impossible write traditional debugger deal resulting machine code 
standard approach turning optimization compiler methodology code transformation 
faced task getting program run debugger programmers commonly instrument code key points print values variables trace flow control 
respect works unusually ml language safe compile time type checking guarantees run time core dumped 
means understand run time behavior ml programs buggy ones underlying machine model assuming compiler functions correctly 
instrumentation part code ml compiler back guarantees modify semantics performing optimization 
course instrumenting code hand tedious time consuming 
key idea debugger automatically insert instrumentation user source code support subsequent debugger queries 
identifier bound add code report value function called add code report caller callee 
added instrumentation executed decided run time information generated wanted conditionally break program instrumentation point 
predict advance information wanted programmer debugger supports reverse execution 
means arrange information collected known relevant user request 
example determine value scope variable jump back time bound turn conditional instrumentation reports value record value return original time 
time travel kind turns remarkably versatile implement location breakpoints display stack trace backs run time system stack tail call elimination 
replay debuggers typically implemented periodic checkpoints program state turns sml nj quite efficiently 
ml functional language functional part execution state completely captured continuation 
call current continuation callcc primitive friedman gives way save reset continuations point program execution 
sml nj compiler uses continuation passing style run time stack appel implementation callcc extremely simple time efficient 
single continuation may large continuations taken adjacent checkpoints typically point memory cells feasible keep multiple checkpoints main memory 
ml nonfunctional features including mutable store support different efficient methods capture non functional part program state part state typically smaller rest 
instrumentation done pass transformation syntax tree produced compiler parser conceptually preprocessing source code easier 
instrumented code runs times slower ordinary code runs fast unoptimized code faster interpreter 
debugging strategies known require inhibition optimization extensive interpretation believe approach practical time competitive 
method consume deal memory believe memory relatively inexpensive resource computer systems 
debugger implementation completely machine independent uses defined back features state checkpointing 

events time debugger modifies source code functions adding instrumentation form events 
events located value declarations top function case branch immediately prior function call excluding built functions cause side effects 
note place events calls insures compiler tail recursion elimination methods apply 
event basic block binding location 
practice adjoining events basic block coalesced reduce overhead ignore complication follows 
enables events serve potential breakpoint locations convenient points collect values bound variables 
distinct event program text unique event number 
debugger maintains mapping event numbers locations original syntax tree retained debugging 
instrumented program runs debugger maintains counter incremented time event executed associated breakpoint taken 
counter form software instruction counter uniquely identify points program execution history 
refer value counter current time talk corresponding time event execution 
controlled entirely basis time break taken event execution time event matches value variable maintained debugger 
addition debugger keeps array indexed event number records time event executed 
array allows simulated time described section 
summary instrumentation code described far shown 
note event shown subroutine practice code normally placed line execution efficiency 
fun event currenttime currenttime currenttime break update currenttime 
fun rev event event type val rev fun binding fn entry application rev nil val binding nil application fn entry user code rev function 
val currenttime fun rev event val currenttime val event rev val event val currenttime event rev nil event nil val event rev instrumented code rev function 

debugger adds instrumentation binding event val val rec declarations rule fn case create new variable named event number 
variable scope variables bound associated event value time binding occurred 
importance variables described section 
user program debugger related coroutines 
breakpoint taken user program transfers control debugger calling break arguments event number time previous scope binding event execution appropriate variable list values bound event 
values tagged fixed order deduced debugger syntax corresponding event 
shows user code short ml function reverses list 
locations events code indicated annotating event numbers adjacent table lists type event 
shows instrumented version code original program bold font added instrumentation italics event function 
states time travel debugger starts user program setting suitable value invoking program coroutine 
user program executes normally target time program reached debugger re entered break 
receives control debugger checkpoint current state user program tagged current time 
continue normally breakpoint debugger simply resumes user program coroutine leaving state unchanged 
debugger restart user program previous time state checkpoint simply restoring state resuming user program coroutine 
restart user program arbitrary previous time debugger resets program state latest time checkpoint sets re executes forward 
sure won re execution automatic breaks caused regular intervals 
particular user explicitly wishes break particular time assume period immediately prior interest level interest increasing exponentially approach asked go time nearest previous stored time break time halfway estimate cost re execute directly store state 
breakpoints forward execution costs small amount extra time saves great deal time want jump back period time travel mechanism encapsulated routine called primitive debugger commands 
takes primary argument specifies time past reset time advance secondary argument need reset time approximately wasteful bother re executing precise time stored checkpoint units forward execution take place 
breakpoints expensive execution time storing checkpoints expensive space important keep set checkpoints remember reasonably small manage cache 
choose size cache dynamically getting memory demand information run time system 
cache size new state added cache previously stored state may need thrown 
ideally keep states useful restarts predict precisely heuristic needed 
heuristic form throw away states restarts long time 
approach rank states expensive regenerate throw away expensive 
easy construct scenarios heuristics fails find compromise scheme 

breakpoints allow user set breakpoints particular source program locations traditional debuggers particular times program execution history past 
debugger unusual making fundamental mechanism implement location breakpoints 
think programmers find efficient time breakpoints useful conventional debuggers achieve similar effect forward direction laboriously repeated single stepping debuggers keep list breakpoints user execute forward backward nearest breakpoint 
encountering breakpoint simply returns control user principle easy associate actions breakpoints 
remainder section assumes breakpoint methods described handle multiple breakpoints mixtures time location breakpoints difficulty 
conventional debugger gdb measured single stepping times slower ordinary execution 
debugger execute time breakpoint rate times slower ordinary execution see section 
implementation time breakpoints trivial primitive 
reverse execution breakpoint easy simply look time event array goto time 
forward execution complicated 
goal find time entry event changed 
jump looking outside bound time 
priori idea true distance desired time jump forward arbitrary delta entry hasn changed jump forward twice 
repeat doubling jump time find entry changed program finishes 
note phase algorithm go twice far true distance total number breaks take proportional log true distance 
having bounded desired time perform binary search pinpoint time entry changed 
number breaks take phase proportional log true distance initial starting time 
invocations specify broad error margin hopes able reuse stored checkpoints re execution 
chosen implementation location breakpoints keep event instrumentation simple 
alternative implementation forward location breakpoints maintain separate boolean array indexed event number 
user code instrumentation extended break event occurs true target time reached 
give simpler forward increase cost event breakpoints 
basing breakpoint decisions time keeps event test simple efficient 
binary search method extended pinpoint event having monotonic indicator function user specified far efficient traditional implementations watch pointing repeated breakpoints memory protection tricks 
break index variable reaches 

displaying values recall event associated ml statement binds value identifier bound value passed debugger associated break executed 
basis technique displaying value identifier jump back identifier binding time cause break occur collect associated value return original time 
values typically passed debugger specific request user 
works large proportion ml objects immutable discuss handling mutable objects 
user request value interpreted context particular time event occurrence program currently halted 
variable requested scope point variables name hidden scope 
variable just bound current event debugger obtained value control received program 
jump back latest prior event execution bound scope variable time execution passed debugger argument break 
repeat process find desired value scope variable bound binding chain event executions 
example consider rev program figures 
suppose stopped event just doing list append user asks value values passed event jump back event fact just time unit earlier 
event time give value repeat procedure jumping back associated event 
notice generally execution event occurred recursive call rev calculating time bears simple relation original starting time 
desired value available event process completes 
note variables act access links conventional run time system block structured language unfortunately occupy storage proportional depth recursion program 
length binding chain number calls needed look variable proportional static size program execution time 
look values multiple variables context expect revisit times chain checkpoints cached re execution needed obtain second subsequent values 
method displaying values objects mutable store arrays somewhat different 
go back binding site object case collect pointer object passed break object contents 
jump back current time fetch current contents object may changed repeatedly interim 
method correctly essential code creating store object re executed typically finding bind time object reuses object pointer created original execution 
done may multiple versions object referenced different saved checkpoints get erroneous results 
mechanism avoiding problem described section 
plan support modification store values 
debugger get pointer ref variable just described change value directly care violate type constraints expressed syntax 
effect changing execution history program stored states thrown away 
furthermore record change sure gets re executed pass time essentially internal action associated breakpoint 
display variable value need know type 
ml supports polymorphic variables example concrete types may depend types actual arguments enclosing functions deduced compile time 
compiler ml compilers run time type tagging scheme 
happily debugger ability find variable binding time deduce types 
done finding calling function variables determining types recursively applying algorithm necessary rerunning compiler algorithm 
similar scheme tag free run time environment described appel 
disadvantage algorithm may require time proportional depth function call nesting hope improve common cases specialized code analysis 
knowledge binding site variable display value program source defined 
particularly useful variables representing functions printable value 
simply pretty print syntax binding may simple assignment function call fn lambda expression 
plan analyze definition recursively find print bindings functions referenced right hand side binding easier debug programs functions class values 

reconstructing call histories sml nj doesn maintain stack optimizes tail calling iteration 
debugger easily produce stack trace back showing complete history function calls arguments 
possible event immediately prior application ii event top function rule body executed immediately application event iii top function events appear binding chain 
determine caller current function skipping back binding chain find current top event stepping back time unit corresponding application event 
repeat process display calling history depth desired 

checkpointing program state program state separate parts 
current continuation continuation invoked resume break 
continuation encompasses values immutable objects control flow 

contents mutable store values ref cells arrays 

state history activity streams 
part state checkpointed different method 
keep parts state checkpoint main memory parts maintained backing store noted 
fundamental assumption continuation part state normally far voluminous 
fortunately easiest part capture call current continuation callcc primitive provided sml nj run time system fact existence feature key motivation approach 
storing current continuation fast involving copying registers costs space keeps live pointers objects garbage collected 
continuations inherently incremental checkpointing mechanism 
capture current continuation break byproduct switching debugger coroutine operation straightforward say continuation state 
capture state record operations time indexed log 
normal mode operation appends result log returning 
replay operation performed log entry current time returned 
obviously better interactive avoid keeping log input files assuming files stable checkpointing file pointers may implement approach 
reasonable keep log backing store 
capturing mutable store state biggest challenge 
fortunately expect store account relatively small part total data example objects created sml nj compiles immutable 
acceptable penalize programs heavy store 
obvious method checkpointing store copy contents arrays ref cells wholesale wasteful store objects created updated break 
keep delta lists break record changes occurred break 
build lists instrumenting array creation update appends pointer updated element global list 
global list temporarily occupy great deal space similar list maintained generational garbage collector cost increased dependence details back 
break occurs debugger retrieves list removes duplicate entries typically numerous fetches copy contents entry 
resulting delta list stored tagged current time 
reset store time consult order contents delta lists tags reset values element list 
objects repeatedly updated tend appear lists appearance overwritten 
improve efficiency circumstance periodically merge adjacent lists removing duplicate elements 
principle keep lists backing store 
algorithm looking store object values see section puts demand store history system insure object creation re executed original object live original object reused 
maintain table store objects hashed creation time instrument creation check table 
relevant entry reused object created inserted table 
significant source inefficiency looking alternative methods solve problem 
special weak pointers store objects debugger data structures 
weak pointers ordinary ones garbage collector allowed remove objects pointed weak pointers 
suppose case large number store objects created user program short lived local scope loop body normally reclaimed take break 
weak pointers allows continue happening ordinary pointers prevent objects treated garbage 

implementation performance implemented debugger ml extension sml nj compiler 
implementation divided modules support checkpointing time travel code instrumentation query commands clearly separated 
debugger code wholly independent compiler back continuation checkpointing uses callcc store checkpointing uses weak pointers basic knowledge run time data formats 
code roughly lines long size compiler 
normal instrumented debugging unoptimized interpreted program store code execution code execution debug execution execution events size time size time time time time lexer benchmark statistics code size bytes vax machine code 
times form execution time garbage collection time cpu seconds 
table debugger fully integrated sml nj interactive system code compiled executed debug mode simple commands ordinary ml functions loaded user top level environment 
user write new debugger functions existing primitives ml customization language 
benchmarked debugger mb running ultrix results shown table 
top section table contains entries typical programs insertions tree lexer lexical analysis ml source text counts tokens reads strings file union find operations path compression purely functional program benchmarked symbolic differentiation term rewriting 
entries bottom section table represent worst case program types simply creates mutable cells just updates cells just copies input file output file 
column labeled store events gives percentage event executions represent creation update mutable store cells 
report execution time garbage collection time separately believe arbitrarily small sufficient memory appel virtual memory techniques shaw expected production compiler 
left hand side table compares normal uninstrumented optimized code instrumented code timing figures 
execution time time needed execute instrumented program completion breaks measures overhead instrumentation 
debug time time needed execute location breakpoint program involves periodic checkpoints part tail program thirds program worst case intended measure cost executing program typical debugging context 
nearly added time re execution separate measurements detailed show checkpointing costs little 
emphasized debug time reported dependent arbitrary parameters minimum maximum checkpointing intervals effort tune 
timings confirm practicality approach 
typical programs execute times slower debugger normally 
debug times worst twice long 
entirely tolerable price pay debugging functionality 
operations slow things substantially worstcase benchmarks clear cause typical programs suffer 
particularly expensive replay accounts debug times higher expected 
right hand columns table give evidence instrumentation approach compares possible debugger methods time performance 
unoptimized execution time time execute normal program compiled optional optimizations turned 
approximates time expected tried build conventional debugger top compiler didn code rewriting optimizations 
times column comparable instrumented execution times 
interpreted execution time time execute normal program lambda calculus interpreter interpreter users reasonably debug manually instrumenting code needed run time 
interpretation typically order magnitude slower instrumented execution 
table shows instrumenting code increases size significantly compile time increases accordingly somewhat worse linearly 
mitigate effect compiling event instrumentation line cuts compilation time increasing execution time 
speed compiler 
compare memory demands debugging versus normal execution separately consider memory compile program ii static memory occupied program compiled iii dynamic memory occupied program data running extensively measured memory compilation 
program temporarily require memory second larger instrumented version syntax produced intermediate representations correspondingly larger 
code size see table static space requirements instrumented non instrumented code similar 
instrumented version requires small additional data structure describing events structure points original syntax large kept standard system anyway 
dynamic memory interesting 
shows dynamic memory usage mb live data measured regular intervals course typical benchmark run checkpoint caching disabled 
lowest curve graph shows amount data gen get picture memory demand machine add size underlying compiler run time system mb standard system vs mb system supporting debugging operating system 
erated ordinary non instrumented code 
middle curve shows amount data generated instrumented code extra data accounted log delta lists mutable store larger code closures 
top curve includes additional space needed store uncompressed delta lists mutable store final increment part checkpoint contribute significantly temporary memory requirements 
note figures obtained measuring live data size full garbage collections 
valid comparative purposes multiplied substantial factor get estimate actual peak memory requirements adequately functioning system 
illustrates phenomenon storage sharing continuations typical benchmark 
case series checkpoints taken exponentially decreasing intervals approaching particular time computation log scale axis display points clearly 
lower curve graph shows memory checkpoint thrown away stored 
upper curve represents case checkpoints retained cache resulting exponential distribution cache entry times typical debugger operations 
substantial sharing occurs cases programs build data structure sharing 
programs turn live data rapidly marginal space cost additional checkpoints approaches zero interval decreases 

related ideas anticipated balzer seminal system balzer 
uses similar instrumentation method log important events buffer eventually file subsequent post mortem analysis 
ideas binding site information resemble analysis revived miller 
major difference collect event data request keeps execution overheads low support interactive debugging low cost conditionally triggered events exploited similar way system 
automatic instrumentation interactive debugging 
hanson describes lexer lexer time steps dynamic memory usage 
time steps overlapping checkpoint storage 
generalized event mechanism built programming language snobol support debugging 
dybvig describes lisp debugging mechanism instrumentation powerful macro system 
previously instrumentation ml produce execution profiles appel 
johnson explores continuations stores class objects language gl suggests utility debugging 
replay debuggers proposed especially connection parallel programming systems curtis leblanc mcdowell idea log govern assist re execution established 
important issue systems measure time proposed hardware instruction counter mellor crummey assembly code level instrumentation implement counter software 
higher level software counter easier compiler performs significant rewriting optimization 
key issue support checkpointing efficiently 
thorough checkpointing system proposed analyzed wilson supports idea history large systems preserved acceptable cost 

built practical ml debugger source code instrumentation time travel 
debugger provides novel solutions challenges posed compiler methodology prevents ordinary source level debugger techniques working 
execution time instrumented code times slower ordinary code 
space requirements checkpointing functional state minimized continuations share storage 
space needed keep track changes mutable store kept low simple coordination garbage collector 
callcc debugger completely independent compiler back underlying machine 
result relatively simple write trivial port 
obvious goal build body users experience debugger real life applications 
enable develop set realistic benchmarks representing typical debugging sessions having prerequisite serious performance analysis particular testing alternative checkpoint caching strategies 
see time travel debugger uses internally comprehensive way prove equally valuable user level facility 
finding suitable metaphors methods navigating history computation increasingly important replay mechanisms common part programming environments 
main replay debugging date parallel programming systems expect debugging approach extend naturally systems time travel tricks may carry multi thread environment 
notion event easily extended cover various kinds communication synchronization operations instrument code source level approach mesh particularly languages support operations explicitly 
believe instrumentation key technique debugging systems 
compilers increasingly aggressive transforming code 
computation originally expressed programmer source language may transformed machine code performs quite different computation 
normally acceptable new computation external behavior consistent original 
debug program effectively need machine code conform closely original program text 
best way compiler produce code extend program external behavior internal state observable recording trace statement execution permitting display update intermediate variables 
translating extended program compiler constrained produce machine code mirrors original computation degree precision required 
source level instrumentation natural way produce extended version source 
particularly interested applying approach lazy parallel languages indeterminate execution order 
languages transformational compilers type just discussed 
addition offer challenge debugging desirable fix particular repeatable execution order program 
may achieved transforming program time performs computation original determinate replay 
believe instrumentation useful 
david tarditi implemented support run time resolution polymorphic types 
type checking callcc standard ml due bruce duba david macqueen 
appel 
appel macqueen standard ml compiler functional programming languages computer architecture ed 
kahn lncs vol 
pp 
springer verlag 
appel 
appel garbage collection faster stack allocation information processing letters vol 
pp 

appel 
appel duba macqueen profiling presence optimization garbage collection technical report cs tr princeton university dept computer science 
appel 
appel runtime tags aren necessary lisp symbolic computation vol 
pp 

appel 
appel continuation passing closure passing style sixteenth acm symp 
principles programming languages pp 


schaffer efficient debugging primitives multiprocessors proc 
rd international conf 
architectural support programming languages operating systems 
balzer 
balzer extendable debugging monitoring system afips proc 
spring joint computer conference vol 
pp 
afips press arlington va 

adaptability portability symbolic debuggers thesis cmu cs carnegie mellon university dept computer science sept 

cheap hardware support software debugging profiling proc 
sigplan symposium compiler construction pp 
june 
curtis 
curtis bugnet debugging system parallel programming environments proc 
rd international conf 
distributed computing systems pp 
october 
dybvig 
dybvig friedman haynes expansion passing style general macro mechanism lisp symbolic computation vol 
pp 

friedman 
friedman haynes kohlbecker programming continuations program transformation programming environments ed 
pepper pp 
springer 
hanson 
hanson event associations snobol program debugging software practice experience vol 
pp 

hennessy 
hennessy symbolic debugging optimized code acm transactions programming languages systems vol 
pp 
july 
johnson 
johnson duggan stores partial continuations class objects language environment proc 
th acm sigact sigplan symposium principles programming languages san diego ca january 
leblanc 
leblanc mellor crummey debugging parallel programs instant replay ieee transactions computers vol 
pp 
april 
mcdowell 
mcdowell helmbold debugging concurrent programs acm computing surveys vol 
pp 
december 
mellor crummey 
mellor crummey leblanc software instruction counter proc 
rd international conf 
architectural support programming languages operating systems 
miller 
miller choi mechanism efficient debugging parallel programs proc 
sigplan conference programming language design implementation pp 
atlanta georgia june 
milner 
milner tofte harper definition standard ml mit press cambridge mass 
shaw 
robert shaw improving garbage collector performance virtual memory stan tr stanford university computer science department 
wilson 
wilson moher memory process histories proc 
sigplan conference programming language design implementation june 
zellweger 
zellweger interactive source level debugging optimized programs csl xerox palo alto research center may 
