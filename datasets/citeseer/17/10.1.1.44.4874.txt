sequence implementations haskell pedro borges college november qualifying dissertation submitted support application transfer phil 
status 
delta oxford university computing laboratory programming research group sequence implementations haskell pedro borges data type sequence defined operations empty isempty cons snoc popfront poprear tolist toseq 
sequence operations indexable sequence 
sequence catenation called catenable sequence 
functional implementations data types taken literature described 
implementations classified stacks deques flexible arrays catenable lists efficient implementations traditional data types 
extended provide operations defined sequences 
comments directions research included 
implementations functional programming language haskell instances classes sequence operations defined type 
instances classified subset operations instance supports efficiently logarithmic complexity 
contents contents sequences basic trees leaf trees 
braun trees 
queues deques deques pair lists 
recursive slowdown deques 
flexible arrays arrays braun trees 
arrays leaf trees 
catenable lists catenable lists trees 
recursive slowdown catenable lists 
comments directions 
list figures ii list figures class definitions sequences 
instance declarations lists 
implementation ltree 
implementation 
implementation queue 
implementation dequeh 
implementation version 
implementation final version 
auxiliary functions final version 
operations pst 
implementation 
implementation 
implementation 
implementation version 
final version part 
final version part ii 
data structures concrete representations data types 
data type set collection operations performed elements set 
design implementation data structures traditionally major area research computer science 
research conducted area data structures designed implemented imperative programming language extensive literature topic see example mt including textbooks describing subject ahu sed clr 
data structures destructive updates assignments multiple access points arbitrary placement pointers 
features available functional programming language traditional data structures easily implemented context 
straightforward technique implement imperative data structure functional language simulate behavior underlying model computation ram machine ahu functional language 
functional implementation extra cost log space original imperative implementation pon bag 
better approach design data structures functional setting possibly adapting existing imperative data structures implemented directly functional language 
approach yielded functional data structures asymptotic complexity existent imperative data structures data type 
data structures functional language called functional data structures 
apart obvious interest functional programming community automatically persistent 
data structure persistent supports multiple versions 
update operation updated non updated versions available imperative data structures heavy destructive updates usually version data structure available ephemeral 
persistent data structures useful areas computational geometry text file editing tree pattern matching dr interest programmers general 
context imperative programming done develop persistent data structures 
frequently approach achieve persistence implement data structure functional style mye bur 
developments area functional data structures relevance imperative programmers functional programmers 
functional language implementation persistence guaranteed common complexity operations data structure persistently single persistent uses 
case complexity data structure amortized tar worst case usually amortized analysis longer valid data structure persistently 
persistence required considered designing data structures imperative functional languages 
functional data structures developed persistent non persistent 
restrict coverage data types stack queue deque flexible array catenable list 
define data type sequence embeds 
sequences similar considered pj tam 
describe various functional implementations data types language haskell phe 
particular hugs system jon small simple haskell interpreter available platforms 
haskell code modifications haskell phe easily translated modern functional languages ml pau 
data structures described adapted original implementation language haskell 
cases implemented operations data structures described original description provide operations define sequences 
usually superset operations data structure called partially persistent supports queries previous versions updates 
updates possible versions data structure said fully persistent 
persistent data structure fully persistent terminology originally described implementation 
provide improved descriptions operations 
haskell chosen implementation language standard lazy functional language 
lazy language implementations achieve stated complexity presence memoization offered lazy functional languages 
implementations translated eager language ml complexity may persistent uses oka 
amortized complexity usually give details analysis obtained refer reader original source 
analysis usually require standard techniques determining amortized complexity potential banker methods tar clr debit method described okasaki persistent structures oka oka 
section give definition sequences operations supported 
define class sequence implementations instances 
describe implementations classified 
section describe implementations trees sections 
section describe sequence implementations efficient implementations queues 
done sections various sequence implementations described implementations deques flexible arrays catenable lists respectively 
conclude section comments directions 
sequences sequences sequence type finite linear succession zero elements elements added removed 
operations required provides equality operation membership test sequence defined 
implicit ordering elements sequence order elements added sequence 
denote sequence elements xn gamma 
operations define sequences front rear cons snoc popfront poprear lengthseq defined informally sequence elements front xn gamma rear xn gamma xn gamma cons xn gamma 
xn gamma snoc xn gamma 
xn gamma popfront xn gamma 
xn gamma poprear xn gamma 
xn gamma lengthseq xn gamma addition empty returns empty sequence isempty checks sequence empty 
sequence described way corresponds closely usually called deque literature data structures 
programs may want operations find th element sequence change 
call sequence operations indexable sequence provides xn gamma xn gamma 
gamma xn gamma addition catenation sequences may required call sequence operation catenable sequence cat xn gamma 
ym gamma 
xn gamma ym gamma alternative approach consider indexing catenation operations part sequence definition defining indexable catenable subtypes 
view taken pj call indexable catenable sequences defined sequences opposed collections insertion order irrelevant required equality called bulk types 
prefer definitions implementations described indexing catenation naturally implemented 
function names 
different approaches deciding name operations meaning different data types 
example operation returns front element queue deque list 
alternatives pros cons 
alternative provide totally different set names type 
second provide called qualified names front function say queue front deque front third alternative overload names functions function name front invoked suitable types 
opinion alternative convenient 
second alternative easily implemented module construct haskell phe 
prevented second alternative hugs implementation haskell provide module facilities provide qualified names jon 
left overloading approach implemented easily class mechanism 
implement sequences haskell define type class sequence general operations described additional coercion operations convert sequence list vice versa 
default implementation toseq provided 
indexable sequences sequences class seq empty isempty 
bool front 
rear 
cons 

snoc 

popfront 
poprear 
lengthseq 
int tolist 
toseq 
toseq xs foldr cons empty xs class seq 
int 

int 


class seq 
cat 

class definitions sequences 
define class class catenable sequences 
declarations definitions appear 
pointed pj sequences admit naturally map method standard haskell class functor methods classes monad monadplus case indexable sequences 
valid functor superclasses seq monadplus superclass 
operations classes standard default definition terms operations defined sequences 
order prevent implementations get unnecessarily long implement catenation operator suitable 
lot operations sense sequences particular standard operations lists take drop scan split implement 
sequences sense generalization traditional types stack queue deque random access list flexible array catenable list 
traditionally distinction data types considered operations allowed 
data type queue example usually allowed operations empty isempty front dequeue enqueue length 
correspond sequence operations empty isempty front popfront snoc lengthseq 
depart tradition embracing data types sequences 
classify different implementations sequence operations supported efficiently implementation opposed operations allowed 
consider operation efficient sequence length operation complexity log 
sequence implementations classified groups queues 
sequence implementations operations efficient front snoc popfront 
instance queue described section 
deques 
sequence implementations operations efficient front rear cons snoc popfront poprear 
implementations section dequeh 
flexible arrays 
indexable sequence implementations operations efficient cons snoc popfront poprear 
describe implementations section 
catenable lists 
catenable sequence implementations operations efficient front cons popfront 
describe implementations section 
table summarizes complexities operations implementation 
sequences list queue dequeh front log rear log log cons log log snoc log log popfront log log poprear log log lengthseq log tolist toseq cat table summary complexities sequence implementations 
complexities amortized 
section describe implementations trees sequence implementations 
different operation naming convention required restriction operations provided implementation desired 
changes easily done module construct provides detailed control aspects haskell 
class mechanism optional 
type cons lists predefined haskell functional programming languages gives efficient implementation stacks 
programs written lists different data type specially rapid prototyping 
purpose mind provide haskell declarations lists instance sequence classes shown 
instance seq empty isempty null front head rear popfront tail poprear init cons snoc xs xs lengthseq length tolist id toseq id instance flip 
xs xs xs xs error index range instance cat instance declarations lists 
basic trees basic trees section describe tree types sequence implementations described sections 
tree types leaf trees type ltree braun trees type 
case describe needed sequence implementations 
leaf trees leaf trees type defined non empty full binary trees elements stored leaves 
full binary mean internal node successors 
addition internal node contains number elements descendants 
implementation correspond type declared data ltree lf bin int ltree ltree data ltree lf bin int ltree ltree join ltree 
ltree 
ltree join bin size size size ltree 
int size lf size bin frontier ltree 
frontier lf bin ind int 
ltree 
ind lf ind bin size ind ind size ind error ind index bounds ltree upd int 

ltree 
ltree upd lf lf upd bin size bin upd bin upd size upd error upd non existent position ltree ltree 
ltree bin lf bin bin ltree 
ltree bin lf bin bin 
ltree xs foldr map lf xs ts size size join ts ts implementation ltree size subtree number elements easily calculated constant time size lf size bin constructor bin applied size field set appropriately 
convenience provide function join applies constructor bin arguments setting size field basic trees join bin size size frontier tree list elements left right order 
define corresponding function haskell frontier lf bin time complexity proportional size tree 
elements tree indexed position frontier tree 
function ind arguments gives th element element position ind lf ind bin size ind ind size tree upd element position function upd implemented upd lf lf upd bin size bin upd bin upd size implementations take time proportional height tree 
insertion deletion elements tree varies general properties tree desired balancing properties 
define simple versions functions deletion left rightmost elements 
name functions satisfying equations leaf tree frontier tail frontier frontier init frontier tail gives list element init gives list element 
functions implemented bin lf bin bin bin lf bin bin time complexities proportional height tree perfect trees special kind tree useful practice perfectly size balanced internal node descendants equal size 
full binary leaf tree property called perfect kd complete binary leaf tree oka 
properties perfect tree short leaves depth height size natural called rank 
perfect tree regular structure sense subtrees properties perfect subtree perfect precisely proportional length right left spine respectively basic trees perfect holds perfect 
function creates list list perfect trees strictly increasing sizes elements drawn formally iii holds kg perfect ii frontier frontier iii gamma size size note size non zero digit weight binary representation length list defined length log 
implementation converts element list xs leaf repeatedly invokes inserts leaf size ascending order second argument preserving relative order members list 
function keeps second argument strictly size increasing list perfect trees built empty list 
invoked tree size size tree second argument 
join tree inserted size tree list 
creates new perfect tree inserted turn recursively tree list larger size tree inserted 
final list seen satisfy equation 
implementation xs foldr map lf xs ts size size join ts ts note cost proportional number join performed node tree 
perfect tree size nodes total number join create size delta delta delta size proportional length list 
functions ind upd described similarly kd leaf trees implement dynamic lists flexible arrays dynamic sets 
braun trees braun trees br node oriented binary trees shape uniquely determined number elements size 
subtree braun tree braun tree 
size balanced size left right subtrees differ case left subtree larger 
braun tree left subtree right subtree size size size size ii braun trees height braun tree minimum possible logarithmic size 
implement braun trees type data nil node braun tree size elements positions gamma 
element position stored root elements form stored left subtree form stored right subtree 
element position position left subtree element position position gamma right subtree 
obtain list elements braun tree ordered positions define function 
note list elements left subtree indexed positions similarly list elements right subtree 
obtain list elements take element list second 
done function merge 
implementation basic trees data nil node 
nil node merge merge xs xs merge ys ys merge xs ys merge xs ys ind int 

ind node ind node ind div ind div ind error ind index range upd int 


upd nil node nil nil upd node node upd node node upd div node upd div upd error upd index range 

nil node nil nil node node 
node nil nil nil node node node int 


upd int 

nil node node div node div size 
int size nil size node size diff diff nil diff node nil nil diff node diff div diff div 
head foldr build nil levels build xs ts ts ts splitat ts repeat nil zipwith node xs ts ts levels levels xs xs xs splitat xs xs levels xs implementation basic trees nil node merge merge xs xs merge ys ys merge xs ys merge ys xs complexity log tree size shape braun tree determined size bijection braun trees lists properties braun trees indexing operations simple addition removal elements 
element position tree obtained root 
th element position div left right subtree 
left subtree odd 
similarly right subtree odd 
gives code indexing function ind ind node ind node ind div ind div similar function upd changes element position upd node node upd node node upd div node upd div languages patterns gofer jon ind similarly upd expressed patterns hoo ind node ind node ind ind node ind operations clearly seen complexity log accessing position insert remove element position define functions satisfy init tree note elements odd positions positions relative order left subtree right subtree 
similarly right subtree left incorporate clear implementation nil node nil nil node node symmetric reasoning gives node nil nil nil node node node complexity functions proportional height tree logarithmic size 
functions similar ind upd hoo chapter pau 
sources braun trees described context implement flexible arrays 
calculate size braun tree algorithm described okasaki oka 
algorithm uses property ii braun tree right subtree size basic trees size left subtree 
discerning sizes implemented efficiently direct approach calculate size 
function diff defined satisfying property braun tree size diff size diff size size 
implement diff case trivial diff nil diff node nil nil second argument analyze separately odd 
left right subtrees braun tree calculations premise size fsize size size rg size size fby size size fby ii size diff size result calculate diff assuming size size diff fsize size size rg size size diff fby diff diff diff diff second argument diff calculate size fsize size size rg size size fby size size fby ii size size diff redo diff assuming size size diff steps similar diff diff note div diff implemented diff node diff div diff div basic trees clearly seen implementation diff runs log size time 
size implemented diff size nil size node size diff second clause follows 
running time implementation proportional total cost calls diff 
tree size diff called second arguments div div div total cost log div log div log div log 
direct approach implement size size size size time complexity 
define functions insert remove element position braun tree 
contrast position root node position left right subtree depending size tree 
size tree known algorithm similar function ind guides search element position gamma tree size function implemented non nil size nil node node div node div insert element position tree size find position insertion 
similar implementation implementation adapted pau 
key idea upd defined far job called argument problem reaches desired position nil node 
problem solved adding clause upd upd nil node nil nil implemented size upd sections versions size included 
implementations run log tree size describe algorithm published okasaki oka create braun tree elements taken list 
want function defined list note straightforward algorithm just repeatedly call element list 
approach yield implementation complexity log 
okasaki approach implemented 
relations braun tree list assume element appears element denote left child left right child right ambiguity 
assumption affect generality algorithm obtained elements referenced position actual value matter 
consider root depth children depth 
blog size elements depths levels possibly full 
elements depth gamma 
gamma elements remaining size gamma gamma depth basic trees level list elements depth left right order 
function level defined kg level satisfies ii level level level ii level gamma size gamma gamma state relationship elements full levels level elements level gamma level left right property definition suggests way inverting obtain implementation phases 
list elements tree partitioned levels tree 
create tree partition explain 
step partition list levels 
done function levels gives desired partition level paired size level possibly 
function levels implemented recursively provided argument indicates length level created call levels levels xs xs xs splitat xs xs levels xs required partition list obtained invoking levels note algorithm levels complexity 
find create tree levels partition 
assume level full 
level gamma level gamma 
know respectively left right children left right children 
split level halves length obtain gamma gammai 
respectively lists left right children members level correct order 
straightforward define function build create level list ts subtrees roots members level analogous ts obtained level list ts split halves constructor node mapped elements level second third arguments second half ts implemented build xs ts ts ts splitat ts zipwith node xs ts ts parameter length level processed function levels pairs level length 
directly provide way creating nodes left right child appear easily seen missing child nil node 
previous implementation modified generate nil nodes subtree required argument 
final implementation build build xs ts ts ts splitat ts repeat nil zipwith node xs ts ts function build folded partition created levels 
note list empty partition empty build produce list nil subtree 
fold provided nil empty list 
element list obtained build element extracted head basic trees head foldr build nil levels implementation invoked call build runs time proportional parameter successive values fold sum 
levels runs time complexity 
description algorithm oka analytical precise possibly intuitive visual 
queues queues queue provide efficient implementations operations empty isempty front popfront snoc 
imperative programming languages easily achieved maintaining pointers ends linked list circular array ahu clr providing operations worst case complexity 
standard queue implementation functional languages time gri bur appears modern functional programming textbooks pau tho 
simple adapting idea pointers ends queue functional setting described 
trick represent queue pair lists intended queue reverse empty queue pair empty lists 
front queue front accessible constant time element empty requiring traversal order access 
avoid case occur allowed empty queue empty invariant maintained bur tho require invariant combine operations front popfront invariant front element queue front popfront just take tail possibly violating invariant causing empty 
normalize resulting queue restore invariant invoked brings queue normalization called snoc may cause invariant violated 
newtype queue instance seq queue empty isempty true isempty false front xs front error front queue empty rear ys rear error rear queue empty rear xs xs popfront xs ys xs ys popfront error popfront queue empty poprear xs ys xs ys poprear error poprear queue empty poprear xs init xs cons xs ys xs ys snoc xs ys xs ys lengthseq xs ys length xs length ys tolist xs ys xs reverse ys toseq xs xs 
reverse instance queue xs ys xs ys xs reverse ys xs ys implementation queue 
operations described far take constant time normalization performed queues takes time proportional amortize cost snoc necessary create obtaining amortized complexity operations required efficient 
argument valid queue single 
persistent uses lazy evaluation helps cases guarantee complexity certain unbounded persistent uses see chapter oka 
persistence required invariant strengthened lazy evaluation gives amortized complexity 
change required operation check new invariant length length reverse convenient add integer fields maintain lengths detailed analysis complexity implementations oka :10.1.1.54.6229
additional operations easy implement poprear lengthseq coercions take time proportional length queue 
desired straightforward constant time lengthseq adding integer pair lists maintain length queue affecting complexity operations 
haskell code implements type queue described 
type renamed haskell requires type constructor define instance class phe 
define catenation operation case desired 
functional implementation queues constant time operations persistent described hm 
constant time achieved performing reverse rear list incrementally intermediate lists 
implementation obtained complex consisting lists counters 
similar technique okasaki oka lazy list perform reverse incrementally 
obtained data structure consisting lists lazy list 
deque implementations described section provide efficient implementations queues 
deques deques deque double ended queue efficient operations ends 
simple implementation possible gives amortized complexity modifying previous implementation queue treat ends sequence symmetrically 
implementation described gt prefer presentation functional setting hoo includes formal derivation 
complicated implementation kt worst case complexity 
implementations 
deque indexing operations called flexible array implementations described section 
deques pair lists represents deque pair intended deque reverse add third component maintain length deque normalization procedure 
invariant type ensures elements ends queue front implementation deque appears 
functions cons snoc popfront poprear just insert take front accordingly call normd normalize deque case invariant violated 
normalization done splitting deque halves making new proper order normd ys reverse splitat div ys normd xs reverse splitat div xs normd cost normalization proportional length deque amortized cons snoc invoked obtaining constant time amortized complexity 
proof bound potential method tar single done hoo 
persistently argument fails cons snoc re executed different versions data structure 
coercion function lengthseq simply returns value constant time 
tolist returns intended deque list toseq puts list normalize deque 
time complexity proportional length deque 
implement catenation operation takes time proportional length result deque 
addition sequence operations implement folding function type dequeh implementations catenable lists section 
implemented right left fold schema foldr function lists defined haskell phe 
defined type dequeh fact defined class sequence invokes sequence operations 
queue generalization restores constant time bound persistent uses lazy evaluation oka 
generalized invariant form 
detailed complexity analysis cases oka oka 
performing normalization incremental way worst case constant complexity may achieved 
technique applied deques hoo cg oka 
deques newtype dequeh int instance seq dequeh empty isempty true isempty false front xs front front error front deque empty rear ys rear rear error rear deque empty cons normd snoc normd popfront empty popfront xs ys normd xs ys popfront error popfront deque empty poprear empty poprear xs ys normd xs ys poprear error poprear deque empty lengthseq tolist xs ys xs reverse ys toseq xs normd length xs xs normd ys reverse splitat div ys normd xs reverse splitat div xs normd instance dequeh cat xs ys xs ys normd xs reverse ys xs ys 



dequeh 
isempty front popfront implementation dequeh 
deques recursive slowdown deques kaplan tarjan describe kt technique structuring data type representations call recursive slowdown adapting ideas called segmented binary numbers implementation see example chapter oka bst 
technique implement deques catenable deques constant time operations persistent 
data structure described imperative language pointers applicative style care maintain persistence requires copying bookkeeping operations explicitly needed functional language implementation 
section describe deque implementation follows closely description kaplan tarjan 
basic idea recursive slowdown technique recursively decompose data structure deque case levels 
operations level implemented worst case constant time complexity 
operation data structure manipulates top level occasionally manipulates levels 
describe implementation levels need manipulated may require constant time 
describe final version performs worst case constant time 
general description data structure deque deq empty decomposed prefix inner deque theta deq theta suffix prefix suffix deques elements 
length prefixes suffixes limited operations perform constant time reasonable implementation 
particular implementation described previous section 
prefer lists simplify implementation mainly benefit pattern matching 
describe deq deq empty empty deque px sx px sx lists deq theta elements sequence defined deque ordered follows 
elements prefix 
elements inner deque ordered way 
component pair precedes second 
elements suffix 
elements prefix suffix order stored list 
deque description may contain inner deque turn may contain deque 
deques enumerated outermost innermost deq px sx deque levels internal deques represented list non recursive components 
list ps prefix suffix pairs 
list defined ps ps psm gamma psm ps px sx px sx psm dm empty empty pair list implemented haskell ps type 
lists ps ps contain pairs elements ps contain pairs pairs 
general prefix suffix ps lists gamma theta gamma ps pair lists pair type easily represented perfect leaf tree height subtrees precisely perfect trees height gamma 
elements represented trees height deques leaves 
order elements pair corresponds left right order leaves tree 
leaf trees described section including perfect leaf trees 
notation list representing deque specified deque levels represented ps psm ps px sx px sx psm dm empty ii px sx lists elements description heights trees varies level level 
type system haskell allow parameterize trees sizes implement general leaf trees 
implementation respect previous description 
description implement deques haskell type 
member list ps implemented type pst 
suffix prefix ps implemented lists leaf trees implemented type ltree section 
declarations newtype ps type pst ltree ltree version implementation seen figures 
additional type color defined 
described 
note ps list described empty pair 
represented pair empty lists 
include pair implementation call list pair empty lists regular 
list kept regular empty deque represented 
implement function empty empty isempty isempty pss null pss clear elements deque stored list describe function tolist implemented 
denote list px list sx elements stored px sx order appear deque informally define tolist tolist px sx list px list px list list list sx list sx possible implementation tolist traverse list adding elements px add elements sx traversing 
prefer implement fold implementation follows structure alternative definition tolist tolist tolist px sx ps list px tolist ps list sx needed function takes ps tolist ps gives equivalent right hand side second clause 
name function 
need implement function list obtain elements stored prefix suffix correct order 
mentioned elements stored left right order leaves trees 
list elements tree obtained collecting leaves tree left right order 
precisely function frontier section 
lists elements tree order appear list 
list concatmap frontier concatmap haskell function defined standard prelude phe 
explicitly implement list inline definition obtaining implementation deques px sx rest concatmap frontier px rest concatmap frontier sx function tolist deques implemented tolist pss foldr pss invariant data structure consider deque levels px empty sx 
similar previous implementation deque pair lists 
main difference px sx may contain elements bound cost operations 
element inserted px sx may full capacity 
gives rise level elements level pushed second 
turn gives rise second major difference respect previous implementation ps px sx elements px general contiguous elements sx evident 
similarly element extracted px sx level required list may empty 
attempt extract element empty px called underflow 
attempt insert element px length called overflow 
implementation ensure overflows underflows occur 
invariant property data structure maintained color assignment ps defined terms color assignment px sx 
px sx said red length signalling operation cause underflow overflow 
px sx said yellow operation may turn red length 
said green 
case length 
define function colorx gives color px sx list px sx colorx red length length yellow length length green length length colors assigned prefix suffix indicate close state underflow overflow may occur 
red color signals operation cause conditions 
yellow color signals operations cause conditions operations necessary cause underflow underflow green prefix suffix 
colors ordered red minimum green maximum 
defined implementation members type color ordered explained making instance class ord see 
color assignment extended prefix suffix pairs 
ps close error condition closer components ps px sx assigned minimum colors components 
ps px sx list special case 
seen elements px sx contiguous deque 
interpreted single list 
px sx empty color ps assigned general case 
px sx empty ps color empty 
define function gives color ps ps psm representing deque gamma ps min colorx px colorx sx ii psm colorx isempty isempty colorx isempty isempty min colorx colorx function colorx implemented directly definition 
implement directly 
implement function list deques ps returns color ps list 
way easily check ps 
implementation appears seen conform sx colorx sx px colorx px px sx pss min colorx px colorx sx colors prefix suffix pairs impose invariant property red ps preceded unique green ps call green ps safety pair ps defined safety ps ps ps isyellow ps isyellow hold arguments respectively yellow green 
invariant stated red ps ps psm representing deque ps safety ps ps particular invariant implies ps non red safety pair exist 
implies consecutive pairs red second red pair safety pair 
clear insert extract element ps causing overflow underflow 
insertion deletion invariant violated cases 
ps red safety ps exist 
case ps yellow current operation ps red safety pair 

ps yellow safety pair non yellow pair ps ps safety pair 
ps changed red ps red consecutive red pairs 
cases invariant violated non yellow pair red ps ps second cases 
non yellow pair fixed restore invariant 
pair exists guaranteed non red 
element inserted extracted deque possibly violating invariant list normalized invariant restored violated 
define function normd perform normalization 
determine violation invariant effectively occurred non yellow pair examined fixed case red 
red pair fixed making green pair 
function normd implemented normd px sx pss case red 
fix px sx pss yellow 
px sx normd pss green 
normd clause initial yellow pairs passed non yellow pair 
green list conforms invariant 
red function fix invoked pair fixed rest list 
second clause handles case list empty looking non yellow pair 
case red pairs invariant violated 
color assignments derive property px sx length px sx length px sx holds argument red 
combined length px sx zero empty 
empty red length length 
deques fix red pair px sx pair calculate number elements px sx zero pair empty removed list need safety pair 
elements px sx store px remaining sx making pair green 
px sx contains elements create new empty pair function distribute elements pairs making px sx green 
case handled fix px sx splitat px sx ps ps px sx ps ps length px length sx note value zero greater 
new pair empty room elements 
fix red px sx pair function previous case distribute elements px sx pair ps fix ps ps pss ps ps ps ps ps regular ps pss may need extract elements ps empty pair non regular 
function regular deletes ps case 
green pair px sx prefix suffix green 
done pushing extracting elements pair ps prefix green function suffix 
function implemented px sx ps px ps px ps sx ps sx ps px sx ps note ps non red prefix suffix red 
insert element prefix suffix 
ps may contain element total 
case ps pair components empty element 
case ps yellow 
pair interpreted single list 
extract element necessary 
consider left ps empty 
prefix px green left elements 
contains elements pushed pair ps elements ps pairs elements px implementation elements ps trees height elements px trees height elements px pushed ps single tree height function join section 
similarly element ps extracted px contains element 
element extracted ps tree form bin trees height see section elements px 
px contains elements green 
may occur sx red 
function implemented px ps px sx px splitat px px join px sx bin ps px ps px ps length px deques element extracted ps function function extract element 
functions described shown 
suffix sx green procedure similar 
difference case ps empty 
indicated function 
case ps pair considered empty components empty 
gives implementation sx ps px sx sx sx sx px sx join ps bin ps sx ps sx ps length sx true false note elements ps precede elements sx deque 
elements sx inserted ps analogously elements ps inserted sx functions shown remain unchanged final version implementation 
clear ps px sx fixed px green 
sx left yellow 
case ps pair empty 
case ps green yellow ps deleted making ps pair invariant violated ps red longer case 
ps pair ps non yellow pair new contains yellow pairs invariant restored 
ps green need safety pair 
ps green may yellow 
problem ps safety pair red pair ps case safety pair ps ps ps yellow may red ps green safety pair 
ps green invariant restored 
operations described far related color assignment normalization constant time complexity function normd 
function traverse list find non yellow pair may need traverse list 
overcome problem data structure modified second version implementation 
describe remaining operations version 
deque operations version operations list need extract element pair ps px sx 
general operations related element ps manipulate px related element ps manipulate sx mentioned ps pair elements px sx contiguous deque 
ps may considered single list px sx extraction operation ps differentiate cases ps pair 
invariant property ensures operations may need interpret ps single list ps pair 
implement px sx contiguous 
element ps needed looked px empty 
px empty element looked sx instance return element ps implement function xs xs similar implementation extracts element ps ys ys xs ys xs ys deques newtype pst type pst ltree ltree data color red yellow green deriving eq ord instance seq empty isempty pss null pss front error front deque empty front ps pss lf ps rear error rear deque empty rear ps pss lf ps cons lf cons px sx pss normd lf px sx pss snoc lf snoc px sx pss normd px sx lf pss popfront error popfront deque empty popfront ps pss normd ps pss poprear error poprear deque empty poprear ps pss normd ps pss lengthseq pss foldr pss px sx length px length sx tolist pss foldr pss normd pst 
pst normd px sx pss case red 
fix px sx pss yellow 
px sx normd pss green 
normd fix pst 
pst 
pst fix px sx splitat px sx ps ps px sx ps ps length px length sx fix ps ps pss ps ps ps ps ps regular ps pss regular pst 
pst regular regular pst 
color sx colorx sx px colorx px px sx pss min colorx px colorx sx implementation version deques functions returns element ps px sx extracts implemented analogously 
manipulate sx empty px 
operations shown 
describe top level functions deque shown 
functions empty isempty described tolist 
function front return element deque 
element ps list representing deque stored ps tree height leaf 
leaf element form lf see section 
tree obtained 
implementation front front ps pss lf ps function rear similar requires element ps obtained 
implementation rear ps pss lf ps insert element deque represented cons insert tree form lf px empty 
invariant guarantees ps non red insertion possible 
length px changed color changed cause violation invariant 
function normd invoked restore needed 
empty new empty pair created tree inserted prefix 
pair yellow invariant maintained 
gives implementation cons lf cons px sx pss normd lf px sx pss function snoc implemented analogously new element inserted suffix px snoc lf snoc px sx pss normd px sx lf pss extract element non empty deque extracted ps function function required 
color ps red invariant extraction cause underflow underflow 
color px changed normalization function normd invoked 
gives implementations popfront poprear popfront ps pss normd ps pss poprear ps pss normd ps pss functions front rear cons snoc popfront poprear constant time complexity normalization required 
calculate length deque represented count total number leaves trees stored number trees height stored trees stored ps trees height consider list ps psm gamma psm 
psm contains nm trees height trees contains trees height gamma 
nm gamma trees height gamma psm gamma total number trees height gamma psm gamma psm nm gamma nm general ps contains trees height trees height ps psm number trees height ps psm fold calculation right left get number leaves implement lengthseq lengthseq pss foldr pss px sx length px length sx deques cost lengthseq proportional length px sx size trees increases exponentially ps length px sx total length px sx logarithmic length deque 
cost lengthseq deque length log 
function toseq resort default implementation definition class sequence 
final version implementation version described constant worst case time function normd may need traverse list needed find non yellow pair problem solved changing structure change consists storing contiguous yellow pairs single internal list consecutive yellow pairs passed single step traversal elements representing deque denoted may single ps non yellow list ps ps yellow pairs 
ps ps change definition reflect new structure deque levels represented ps isyellow ps ps ps fi jg isyellow ps ii ps px sx px sx psm dm empty iii px sx lists enumeration internal deques representation ps retained 
implementation kept regular psm appear list 
internal lists yellow pairs yellow lists short maximal length empty px sx px sx isyellow gamma ii exists isyellow iii structure non yellow pair gamma 
normalization find required pair steps 
type declarations version additional type represent elements single pair constructor ps 
yellow list 
constructor declarations newtype data ps pst pst type pst ltree ltree data color red yellow green deriving eq ord describe implementation operations modified manipulate new representation 
functions type pst change shown 
top level operations shown remaining auxiliary functions shown 
additional operations implemented deal directly modification popps extract prefix suffix pair yellow 
non yellow stored single constructor ps 
yellow extracted corresponding internal list 
internal list contains single yellow pair yellow list deleted value returned pair ps 
implementation deques newtype data ps pst pst type pst ltree ltree data color red yellow green deriving eq ord instance seq empty isempty pss null pss front error front deque empty front cs ps popps cs lf ps rear error rear deque empty rear cs ps popps cs lf ps cons ps lf cons cs px sx cs popps cs normd fixy ps lf px sx cs snoc ps lf snoc cs px sx cs popps cs normd fixy ps px sx lf cs popfront error popfront deque empty popfront cs ps cs popps cs normd fixy ps ps cs poprear error poprear deque empty poprear cs ps cs popps cs normd fixy ps ps cs lengthseq cs foldr cs ps px sx length px length sx pss foldr map ps pss tolist cs foldr cs ps ps rest ps rest pss rest foldr rest pss implementation final version popps ps ps cs ps cs popps ps cs ps cs popps ps pss cs ps pss cs note defined argument empty 
second additional operation fixy time ps inserted yellow 
inserted single ps constructor ps fixy stores yellow list yellow 
yellow lists maximal length member yellow list new yellow pair inserted 
implementation fixy ps ps isyellow ps ps isyellow sx colorx sx yellow isyellow px colorx px yellow isyellow px sx min colorx px colorx sx yellow fixy ps ps cs isyellow ps case cs pss cs 
ps pss cs 
ps cs deques isyellow px sx min colorx px colorx sx yellow note color assignment pair different pair clause local function isyellow 
functions empty isempty implementation 
functions cons snoc popfront poprear modified similar way 
major change involves extraction ps done pattern matching list done function popps 
modification involves functions insert ps inserted constructor ps regardless color function fixy invoked change necessary 
instance function cons implemented cons ps lf cons cs px sx cs popps cs normd fixy ps lf px sx cs functions shown 
function lengthseq slightly changed 
local function see calculate length single ps 
argument function single ps previous version 
argument yellow list recursively processed list single ps 
implementation lengthseq cs foldr cs ps px sx length px length sx pss foldr map ps pss function tolist implemented folding function elements type intermediate function defined 
invokes argument single ps 
argument yellow list invokes internal fold ps yellow list 
implementation tolist cs foldr cs ps ps rest ps rest pss rest foldr rest pss functions normd regular fixy essentially implementation type changed reflect new type function extra clause element yellow list 
case color ps obviously yellow 
new implementation ps cs yellow ps sx colorx sx ps px colorx px ps px sx pss min colorx px colorx sx deques popps 
pst popps ps ps cs ps cs popps ps cs ps cs popps ps pss cs ps pss cs normd 
normd cs case red 
fix cs yellow 
normd cs green 
normd fix 

fix ps px sx ps splitat px sx ps ps px sx ps ps fixy ps ps length px length sx fix ps ps cs case ps ps ps 
fixy ps ps regular ps cs ps ps 
ps ps fixy ps ps cs ps cs popps cs fixy 
fixy ps ps isyellow ps ps isyellow sx colorx sx yellow isyellow px colorx px yellow isyellow px sx min colorx px colorx sx yellow fixy ps ps cs isyellow ps case cs pss cs 
ps pss cs 
ps cs isyellow px sx min colorx px colorx sx yellow regular 
regular ps regular 
color ps cs yellow ps sx colorx sx ps px colorx px ps px sx pss min colorx px colorx sx auxiliary functions final version deques pst 
pst 
pst pst px sx ps px ps px ps sx ps sx ps px sx ps ltree 
pst 
ltree pst px ps px sx px splitat px px join px sx bin ps px ps px ps length px ltree 
pst 
ltree pst sx ps px sx sx sx sx px sx join ps bin ps sx ps sx ps length sx true false colorx ltree 
color colorx px green yellow red length px pst 

px sx rest concatmap frontier px rest concatmap frontier sx pst 
ltree xs xs pst 
ltree xs xs ys ys pst 
pst ys ys xs ys xs ys pst 
pst xs init xs xs ys xs init ys operations pst flexible arrays flexible arrays flexible arrays random access deques arrays efficient indexing operations flexible sense grow shrink deques 
arrays extended shortened called sided flexible arrays random access lists opposed fully flexible arrays 
arrays considered fully flexible terminology 
arrays fixed length predefined major imperative languages supporting constant time indexing 
incorporated functional languages array library haskell predefined implementations efficient indexing 
array required flexible predefined implementations suited user defined implementation 
simplest implementation flexible arrays plain lists yields linear complexity size array indexing operations 
constant time complexity cons popfront linear time snoc poprear 
improve cost indexing operations trees height logarithmic sizes lists 
gives logarithmic complexity operations 
traditional implementations balanced trees avl trees trees represent arrays cha mye 
forms trees described purpose simpler program avoid cumbersome rotations traditional forms 
implementations flexible arrays kinds trees described section 
braun trees hoo 
leaf trees described dk 
consider front element array length index rear index gamma 
interesting data structure supports efficient indexing sequences described oka random access list implemented forest complete pre ordered trees 
include data structure support efficient snoc 
arrays braun trees braun trees represent flexible arrays hoo describes simple elegant derivation implementation br 
braun trees defined operations flexible arrays straightforward 
implementation braun trees type section hoo additional operations taken oka 
implement flexible array pair braun tree positions correspond positions array size 
size tree length array 
pair new type constructor usual previous sequences gives type declaration newtype int empty array represented nil 
sequence operations just invoke corresponding functions keep account implementation seen 
functions front rear check array empty obtain element position gamma ind functions cons snoc increment insert new element position 
similarly popfront poprear decrement delete desired element accordingly 
operations log worst case complexity 
function lengthseq just gives constant time 
coercion operations provided braun trees implementation tolist obtains list elements tree ordered position toseq creates desired tree sets field size 
operations take time proportional length sequence 
indexing operations provided implementation section complexity log accessing position function gets required precisely accessing position flexible arrays newtype int instance seq empty nil isempty true isempty false front error front array empty front ind rear error rear array empty rear ind cons snoc popfront error popfront array empty popfront poprear error poprear array empty poprear lengthseq tolist toseq xs xs size instance ind upd error non existent index implementation 
element ind function checks position greater position array updates upd 
additionally position access checked non negative 
leave functions braun trees detect error 
arrays leaf trees describe implementation closely follows dk kd leaf trees 
kind trees complexity operations general proportional height trees 
accessing single element leaf tree may expensive logarithmic complexity braun tree leaf trees suitable operations manipulations segments array 
perform better elements accessed sequential order oka 
operations needed leaf trees described section 
operations insert element described determine shape tree height 
implementation leaf trees consider empty trees represent non empty array leaf tree empty array special constructor empty 
type declarations data empty atree ltree complete implementation appears 
empty simply returns empty front rear check argument empty ind obtain element array 
functions popfront poprear signal error argument empty leaf return empty delete flexible arrays data arr empty atree ltree instance seq arr empty empty isempty empty true isempty false front atree ind front empty error front array empty rear atree ind size rear empty error rear array empty cons atree atree cons empty atree lf snoc atree atree snoc empty atree lf popfront atree lf empty popfront atree atree popfront empty error popfront array empty poprear atree lf empty poprear atree atree poprear empty error poprear array empty lengthseq empty lengthseq atree size tolist atree frontier tolist empty toseq empty toseq xs atree foldl join xs 
ltree 
ltree bin bin 
ltree 
ltree lf bin lf lf bin size size bin lf bin 
ltree 
ltree bin bin 
ltree 
ltree lf bin lf lf bin size size bin lf bin instance arr atree ind empty error array empty atree atree upd empty error array empty implementation 
flexible arrays element tree 
simple implementations functions section job 
function lengthseq simply gives zero empty array size tree 
coercion tolist gives empty list array empty gives frontier corresponding tree 
function toseq depends general desired shape tree described 
trees certain properties ensuring height logarithmic size 
tree said left perfect left subtrees perfect see section 
predicate defined ltree predicate perfect section lf true bin perfect tree leftist height left subtrees height right siblings 
formally predicate leftist defined ltree leftist lf true leftist bin height height leftist leftist height height tree similarly symmetric predicates defined lf true bin perfect lf true bin height height definitions clearly seen height leftist trees depends heights left right subtrees respectively 
subtrees perfect left perfect right perfect trees respectively 
height perfect leaf tree log size leftist bin bin height bin log size bin bin height bin log size size subtrees indicates trees perfect leftist bin bin perfect bin size size bin bin perfect bin size size note perfect tree properties perfect leftist perfect properties non empty array represented empty leaf leaf tree top level left subtree right perfect tree flexible arrays top level right subtree leftist left perfect tree 
type invariant array represented empty size atree lf size atree bin size leftist property height tree representing array logarithmic size 
note functions section maintain invariant 
note properties perfect tree represent non empty array invariant perfect satisfies non empty array implement functions insert remove element ends array 
ends treated symmetrically describe working front array 
implementations seen 
insert element front array leaf array empty inserted position tree representing array function 
implement cons cons atree atree cons empty atree lf insert element position tree representing array check tree leaf 
case position left subtree right perfect tree 
insertion define function 
tree leaf leaf 
create perfect tree adequate 
implementation simple bin bin implementation maintain invariant argument tree 
tree perfect simple solution right subtree new element left subtree 
case recursively insert new element left subtree violating invariant 
determine tree perfect property 
gives implementation lf bin lf lf bin size size bin lf bin implement toseq 
list empty empty array created 
non empty leaf tree satisfying representation invariant created 
done different ways exact shape tree determined invariant 
case braun trees straightforward approach repeatedly inserting element yield log algorithm function section definition implement toseq complexity list 
applying gives size increasing list perfect trees single tree 
easiest way doing join right left 
creates single tree right subtree perfect left subtree right perfect 
tree satisfies invariant 
particular length original list power give perfect tree correct 
implementation flexible arrays toseq empty toseq xs atree foldl join xs altogether toseq performs join node result tree 
nodes tree leaves complexity toseq list length functions described dk kd 
exceptions front rear popfront poprear special cases functions empty isempty tolist lengthseq considered 
implementation toseq turned special case algorithm described bir create tree minimum height 
catenable lists catenable lists catenable lists lists short sequences efficient implementation cat 
addition constant time complexity operations lists remain lists cons popfront 
additionally creating element sequence takes constant time snoc efficient implemented catenation original sequence element sequence new rear element 
sequences efficient catenation implemented kinds trees avl trees mye obtaining log complexity operations 
dst implementation described achieves constant time desired list operations log log catenation 
recording operations performed data structure catenation log log number operations 
described imperative setting making lot bookkeeping information may easily adapted functional setting 
describe implementation closely follows okasaki oka oka constant time amortized complexity operations efficient list :10.1.1.54.6229
implementation uses ary trees 
describe implementation kt constant time complexity operations 
implementation uses recursive slowdown technique requires implementation non catenable deques 
okasaki described variation data structure constant amortized time oka 
catenable lists trees implementation okasaki develops simple idea 
elements front list easily accessible list implemented ary pre ordered tree elements lists 
lists front element front element elements removed 
child tree representing similarly root tree removed child contains elements sequence top level tree 
behavior children node collected queue oka oka 
implementation provide poprear operation lists requires manipulation child deque 
achieve amortized constant time bounds operations deque constant time worst case amortized 
particular type dequeh section 
list empty components root element front deque children lists 
gives type data empty cons dequeh implementation seen 
type null pair empty pair cl cl cons element representing deque children 
keep deques unnecessarily long facilitate operations invariant maintained cl cl occurring level cl said cons snoc implemented creating new list new element list cons cl cat cons empty cl snoc cl cat cl cons empty implementation cat function insert second list child 
ensures maintained catenable lists data empty cons dequeh instance seq empty empty isempty empty true isempty false front cons front empty error front catenable list empty rear cons isempty rear rear rear empty error rear catenable list empty cons cl cat cons empty cl snoc cl cat cl cons empty popfront cons cat empty popfront empty error popfront catenable list empty poprear cons isempty empty poprear rear poprear cat cons poprear empty error poprear catenable list empty lengthseq cons cl lengthseq cl lengthseq empty tolist cons concatmap tolist tolist tolist empty instance cat empty cl cl cat cl empty cl cat cl cl cl cl 

cons cl cons snoc cl implementation 
cat empty cl cl cat cl empty cl cat cl cl cl cl cons cl cons snoc cl remove front list cl cl cl top level list children single deque cl cl call popfront cl perform operation cl inserted child cl cl cl inserted respective previous children 
accomplished cl cl right left fact fold cl 
function section implement popfront popfront cons cat empty remaining list operation front implementation trivial front cons functions cons snoc implemented terms cat operation 
function popfront performs list elements 
cost catenable lists popfront amortized cat performed directly cons snoc 
analysis amortization detailed oka gives amortized constant time complexity cons snoc cat popfront lazy evaluation 
implement remaining operations sequences provided oka oka complexity 
rear element list cl cl rear cl applies recursively cl list form reached 
gives implementation rear rear cons isempty rear rear worst case may take list length remove rear element cl cl take cl deque recursively remove rear element obtaining cl cl inserted back deque cl maintaining invariant case cl empty 
done cat 
trivial case remove rear element list simply produce 
algorithm implement poprear poprear cons isempty empty poprear rear poprear cat cons rear implementation worst case complexity list length length list sum lengths lists implementation lengthseq just calculates mentioned sum provides initial value lengthseq cons cl lengthseq cl lengthseq empty convert list elements converted lists lists front tolist cons concatmap tolist tolist tolist empty toseq resort default implementation provided class seq see implementation complexity 
recursive slowdown catenable lists kaplan tarjan describe kt implementation call catenable stack ended queue steque supports front cons snoc popfront cat constant time complexity 
data structure operations called output restricted deque 
implementation support constant time poprear implement part operations sequences 
implement data structure steps 
describe preliminary version operations constant time complexity invariant needs restored 
describe preliminary version modified achieve constant time complexity operations efficient list snoc 
preliminary version seen 
complete final version figures 
catenable lists general description data structure basic idea similar author implementation deques see section list list deque decomposed prefix suffix inner medium part 
prefix suffix deques inner part list el list el 
el element prefix pair prefix list el 
list deque px cl sx px sx deques cl list el el px px deque px cl px deque cl list el elements sequence defined list ordered follows 
list single deque elements sequence come order appear deque 
list form px cl sx elements contained px comes elements cl elements contained sx 
elements form px cl elements px precede elements cl list description may contain inner list turn may contain list list single deque 
lists enumerated outermost innermost cl list cl cl cl cl cl px cl sx note cl list cl list elements cl list elements elements 
list levels represented list non recursive components px sx gamma gamma dm list defined ps psm gamma dm ps px sx cl px cl sx dm cl homogeneous list 
dm single deque ps pairs deques 
define type haskell comprises cases members type arrive description cl list levels cl represented px sx cl px cl sx cl ii cl list px sx cl deques type non homogeneous deques contain members members deques form el define haskell generalize el include members define type cel 
implementation respect description seen 
haskell define type corresponds members may prefix suffix pair single deque elements 
type cel corresponds elements different types said 
type list list case different types wrapped suitable constructors 
declarations catenable lists newtype data dq dequeh cel ps dequeh cel dequeh cel data cel dequeh cel pl dequeh cel type dequeh section deques 
implementation deques long provides constant time front cons snoc popfront poprear 
operations deque worst case complexity list operations 
complexity amortized complexity list operations 
empty list represented empty single empty deque 
empty list forbid occurrence empty single deque internal call list property regular defined regular empty keeping list regular trivial know list empty case empty 
implement isempty isempty cs null cs possible implementation empty empty see elements sequence obtained implementation describe function tolist converts list list elements type define function list obtained creates list containing members function gives list members element 
implementation functions dq concatmap tolist ps px sx concatmap tolist px concatmap tolist sx px concatmap tolist px pl px cs concatmap tolist px foldr cs implement tolist list tolist cs foldr cs functions slightly modified final version implementation 
final version appears 
color assignment invariant structure achieve constant time complexity cons snoc front popfront cat elements assigned colors red yellow green 
colors impose invariant property invariant guarantee operations need manipulate bounded number starting way complete traversal necessary operations 
ideally access see restoring invariant need 
achieve constant time complexity modification data structure done final version implementation 
discussion follows single deque considered prefix suffix colors assigned interpreted follows 
red allow operation manipulate red fixed operation require fixing possible accessing elements keep requirements minimum fixing done extracting element see observing element catenable lists may needed front extracting needed popfront fixing gamma require element stored red needs fixed needed fix gamma furthermore see deques stored element form px px cl prefix px sx may eventually interchange positions 
color assigned deques length prefix red may prefix 
deques occur element prefix px sx required length length prefix red yellow red element extracted prefix popfront fixing gamma yellow prefix contains element prefix red length prefix yellow 
green red element extracted prefix 
length prefix green 
far properties px occurring length finding suitable value consequently note fixing red gamma possible extracting element prefix remain color assigned prefix remain length red imply gamma possible fix gamma red 
invariant guarantee red gamma fixed yellow green 
prefix gamma contains elements type members prefix form el members form px px cl px deque fix gamma prefix combined px green 
px length combining px length yield prefix length px fixed second extracted obtain 
minimum chosen special case 
contains element list empty element extracted 
empty appear kept regular 
gamma px sx fixed de done combining px sx single deque element required empty element may extracted fix gamma new fixed 
single deque pose problem operation requires 
considered green color assignment stated representing list px sx color red lengthseq px yellow lengthseq px green lengthseq px ii green predicates isyellow hold argument respectively green yellow red 
isyellow implemented 
pairs px sx yellow red implementations defined pairs see 
kt single deque considered suffix prefix green 
description equivalent 
catenable lists describe invariant property red preceded unique green call green safety defined safety isyellow red internal stored element form px required safety red state invariant incorporates property list representing list properties ng safety ii red px safety iii length px element note invariant implies non red 
px sx yellow red popfront extracts element px violates invariant safety exists 
px sx green may yellow popfront possibly violating invariant non yellow red 
case safety safety longer exists 
case invariant restored fixing non yellow call procedure normalization said fixing requires non red 
normalization needs fix yellow current operation red safety exist needed fix changed red 
non red safety exist 
operations version insertion operations cons snoc insert argument list wrapped constructor element 
sort possible different configurations functions 
functions insert new element accordingly 
cons snoc implemented cons cs cs snoc cs cs empty create single deque new element new single deque new element inserted 
new element inserted px sx accordingly 
gives implementation cel dq cons cel empty cel dq dq cons cel cel ps px sx cs ps cons cel px sx cs cel dq snoc empty cel dq cel dq snoc cel ps px sx cs cel ps px snoc sx cel cs implementations perform cons snoc deques assumed implemented constant time complexity 
list operations implemented constant time complexity 
create red invariant violated 
lists cat defers receives create new list cat cs cs cs cs create new list distinguish lists empty catenable lists rest consider major cases 
single deque 
second case single deque 
third case lists single deque 
organization differs kt gives result 
prefix new list 
elements elements cons ed elements prefix new list suffix suffix new list 
new element list created 
px sx sx suffix new list px precede rest elements gives implementation dq lengthseq case dq 
ps ps px sx cs 
ps sx pl px cs dq empty case evident elements form px 
note prefix new elements red created invariant preserved 
second major case px sx 
new list conform ordering px sx px prefix new list suffix 
elements sx inserted function obtaining ps px sx cs dq cs cs sx ps px cs case constant time complexity implemented constant time complexity 
length px decreased invariant preserved 
auxiliary function implemented cs sx px cs px cs cons front sx px cs sx px lengthseq sx note length sx prefix property iii 
final major case px sx px sx 
new list conform ordering px sx px sx accomplished new px sx 
elements sx inserted px function obtaining px element px snoc ed 
gives implementation ps px sx cs ps px sx cs cs px cs sx px ps px sx cs pl px cs px remains length increased red invariant preserved 
implementation front simple 
auxiliary function split list pair consisting element list 
ii element implementation front front cs cs catenable lists newtype clist data dq dequeh el ps dequeh el dequeh el data el dequeh el pl dequeh el instance seq clist empty isempty cs null cs cons cs cs snoc cs cs front error front empty catenable list front cs cs popfront error popfront empty catenable list popfront cs cs cs norml cs instance clist cat cs cs cs cs cel dq cons cel empty cel dq dq cons cel cel ps px sx cs ps cons cel px sx cs cel dq snoc empty cel dq cel dq snoc cel ps px sx cs cel ps px snoc sx cel cs dq lengthseq case dq 
ps ps px sx cs 
ps sx pl px cs dq empty ps px sx cs dq cs cs sx ps px cs ps px sx cs ps px sx cs cs px cs sx px ps px sx cs pl px cs norml ps px sx cs isyellow px sx ps px sx norml cs px sx fix px sx cs norml cs cs fix px sx dq cons sx px fix px sx cs case cs px cs 
ps cons px px sx cs pl px cs 
ps cons px px sx cs px sx lengthseq px isyellow px sx lengthseq px cs sx px cs px cs cons front sx px cs sx px lengthseq sx dq lengthseq front front dq popfront ps px sx cs front px ps popfront px sx cs implementation version 
catenable lists extract element differentiate single deque pair px sx 
case element extracted single deque take care keeping list regular 
gives implementation dq lengthseq front front dq popfront ps px sx cs front px ps popfront px sx cs front clearly constant time complexity 
remaining efficient operation popfront easily implemented may cause violation invariant needing restored 
need extract element done resulting list need normalized norml invoked 
implementation popfront popfront cs cs cs norml cs implementation performs constant time operations invokes norml 
said invariant described violated safety longer exists red furthermore happen offending list red 
problem solved look non yellow green invariant violated 
red fixed fix receives red pair rest list 
norml implemented norml ps px sx cs isyellow px sx ps px sx norml cs px sx fix px sx cs norml cs cs second clause catch list contains single deque empty looking non yellow fix red px sx rest list empty elements px px sx red incorporated sx 
implementation fix px sx dq cons sx px invariant restored new green 
rest list empty element extracted 
ii prefix element pair prefix list 
prefix px elements px incorporated px prefix fixed pair 
pair px strategy applied addition rest list 
px elements px iii fixed pair green 
implemented fix px sx cs case cs px cs 
ps cons px px sx cs pl px cs 
ps cons px px sx cs see invariant restored case arguments fix 
non yellow list normalized 
invariant guarantees non red safety exist normalized list remains violate invariant yellow 
rest new list constructed fix begins green said 
element extracted form px member new list element extracted 
red safety invariant restored red new list corresponding safety pair 
remain unchanged new list red corresponding safety pairs 
catenable lists extracted element form px rest new list catenation rest list normalized 
said obeys invariant 
red apart possibly see ii safety pair catenation rest list normalized red safety pair 
case required safety pair seen non yellow list normalized performed constant time complexity 
finding non yellow implies arbitrary traversal list 
traversal avoided final version implementation description follows 
version described far appears 
final version implementation said implementation described far achieve constant time complexity popfront may require normalization data structure 
normalization traverse list non yellow 
traversal far include list having linear time length list 
overcome problem structure modified grouping contiguous yellow internal list 
yellow stored single 
denote modified list contains elements form represents list described isyellow fi jg isyellow keep lists yellow maximal length empty px sx px sx isyellow gamma ii exists isyellow iii way non yellow gamma 
traversal norml may go far second element type declarations final version essentially version members type correspond 
list prefix suffix pairs wrapped constructor final declaration newtype clist data dq dequeh el ps dequeh el dequeh el dequeh el dequeh el data el dequeh el pl dequeh el final implementation appears figures 
describe changes previous implementation obtain final version 
start describing normalization function norml improvement goal modification data structure 
function looks non yellow element red fix fixy 
final implementation simply bypass yellow list norml pss cs pss norml cs norml ps px sx cs px sx fix px sx cs norml cs cs function appears 
function fixy changed appears 
introduce new auxiliary function popps extracts prefix suffix pair 
version list usually pattern matched cases empty single deque prefix suffix pair element 
case single pattern pair stand pair member list yellow pairs 
configurations handled popps implemented catenable lists newtype clist data dq dequeh el ps dequeh el dequeh el dequeh el dequeh el data el dequeh el pl dequeh el instance seq clist empty isempty cs null cs cons cs cs snoc cs cs front error front empty catenable list front cs cs rear error rear empty catenable list rear cs tolist cs popfront error popfront empty catenable list popfront cs cs cs norml cs toseq toseq xs dq toseq map xs tolist tolist cs foldr cs instance clist cat cs cs cs cs el 

cel dq cons cel empty cel dq dq cons cel cel cs px sx cs popps cs fixy ps cons cel px sx cs 
el 
cel dq snoc empty cel dq cel dq snoc cel cs cel px sx cs popps cs fixy ps px snoc sx cel cs 

dq lengthseq case dq 
ps 
px sx cs popps ps sx pl px cs dq empty dq px sx cs popps cs cs sx fixy ps px cs px sx cs popps px sx cs popps cs px cs sx px fixy ps px sx cs pl px cs norml 
norml pss cs pss norml cs norml ps px sx cs px sx fix px sx cs norml cs cs final version part catenable lists popps ps ps cs ps cs popps ps cs ps cs popps ps pss cs ps pss cs seen popps returns pair component pair rest care taken leaving empty lists yellow pairs new auxiliary function fixy 
invoked prefix suffix pair yellow inserted pair inserted head pair yellow element yellow list inserted adjacent yellow list exists 
implementation fixy ps px sx cs isyellow px sx case cs pss cs 
px sx pss cs 
px sx cs function slightly modified 
splits previously pair component element 
prefix suffix pair extracts pair popps inserts back extracting element 
pair inserted back yellow fixy invoked 
implementation dq lengthseq front front dq popfront cs px sx cs popps cs front px fixy ps popfront px sx cs functions modified way 
clause extract prefix suffix pair done pattern matching version 
pattern matching replaced expression invokes popps shown 
new versions seen 
function described page takes list elements list contained gives list list elements contained clause added handle new kind elements type lists yellow pairs 
yellow list processed internal list pairs constructor ps mapped internal list 
new clause pss foldr map ps pss new version appears 
remaining functions implemented version change 
final version add coercion functions 
function toseq described 
remains modification described 
convert list list simplest possible list created 
empty list list represented list containing single deque 
members list elements applying constructor 
implementation toseq toseq xs dq toseq map xs sequence operation rear efficient list 
implementation straightforward may sight 
difficulty suffixes stored prefix suffix pairs empty 
traversed non empty suffix including final single deque 
suffixes empty rear element element prefix 
case element contains rear element form px px manipulation element needed 
opt simple inefficient implementation rear cs tolist cs catenable lists fix dequeh el dequeh el 

fix px sx dq cons sx px fix px sx cs case cs px cs 
ps cons px px sx cs pl px cs 
ps cons px px sx cs dequeh el dequeh el 
bool px sx lengthseq px isyellow dequeh el dequeh el 
bool isyellow px sx lengthseq px 
dequeh el 
dequeh el 
dequeh el cs sx px cs px cs cons front sx px cs sx px lengthseq sx 
el dq lengthseq front front dq popfront cs px sx cs popps cs front px fixy ps popfront px sx cs popps 
dequeh el dequeh el popps ps ps cs ps cs popps ps cs ps cs popps ps pss cs ps pss cs fixy 
fixy ps px sx cs isyellow px sx case cs pss cs 
px sx pss cs 
px sx cs 

dq concatmap tolist ps px sx concatmap tolist px concatmap tolist sx pss foldr map ps pss el 
px concatmap tolist px pl px cs concatmap tolist px foldr cs final version part ii 
comments comments described representative sample published functional data structures 
restricted attention sequences main design techniques functional data structures represented implementations described 
major techniques identified works area 
basic trees 
basic kinds trees implement data structures general implemented functional languages 
usually operations defined trees expressed succinctly elegantly functional language 
basic trees frequently cite avl trees trees trees weight balanced trees basic kinds trees described section 
implement sequences exemplified implementations flexible arrays section 
sequences pair lists 
old technique implement sequences functional languages variations described 
technique implementations queues deques described sections 
numerical representations 
representation natural number base consists sequence digits log digit weight representation analogous representation sequence list trees tree contains elements 
simplified version implementation flexible arrays leaf trees section described dk uses single leftist left perfect tree see section represent random access list 
single leaf tree obtained function toseq section forest perfect leaf trees joined single tree 
equivalent data structure obtained forest list trees manipulated 
forest representation example implementation binary numbers representation 
functions leftist left perfect trees section equivalent version works forest single tree 
describe forest implementation support efficient snoc poprear 
description analogy oka description general technique 
examples technique oka mye implementations random access lists described analogy skew binary number systems 

data structural bootstrapping 
technique described buchsbaum thesis buc 
consists basic ideas structural abstraction structural decomposition 
structural abstraction typically provide efficient catenation data type support 
done inserting data type element 
examples technique implementations catenable lists described section lists inserted abstracted list achieve efficient catenation 
structural decomposition refers recursive decomposition data structure data structures limited size 
idea recursive slowdown deques described section 
recursive slowdown 
technique seen uniting previous techniques 
sequences implemented technique kt described sections 
sequence recursively decomposed collection smaller data structures data structural bootstrapping 
smaller data structures implemented pair lists general organization data structure system colors analogous redundant numerical representation colors red yellow green seen respectively digits 
analogy described kt 
data structures developed techniques provide basic operations sequences asymptotic behavior provided imperative counterparts 
efficient functional implementations priority queues designed techniques kin bo 
efficient explicit implementations data type dictionary described mainly balanced trees mye 
efficient data structures known problems described 
notably comments related graph algorithms example lau specially union find problem 
interesting areas research 
directions short term plan conduct research directions 
improvements extensions existing data structures 
obtained preliminary results variation implementation flexible arrays leaf trees described section 
simplification algorithm perform insertions tree general form leaf trees obtained 
new implementation perform better certain cases flexible array created repeated applications cons repeated applications snoc 
preliminary done measure average depth leaves arrays created random application cons snoc 
far results new implementation better original data structure 
extensive measures remain done study worst case performance new version 
sketched extension random access list implementation oka support efficient insertions deletions list 

better presentation recursive slowdown structures 
description data structures kt improved sections 
plan refine obtain nice formal description structures implementation functional style 
lead uncover general principles design clarify relation design techniques 
particular expect state clearly relation finger search trees see topic 
plan study relation data structures described fingers search trees kos 
relation recursive slowdown deques section finger search trees sketched kt 
list implementation forest leaf tree mentioned seen equivalent presence finger leaf tree 
consider example leftist left perfect leaf tree 
start leftmost leaf proceed upwards trough left spine root node successive right children nodes path perfect leaf trees increasing size 
sequence perfect trees precisely obtained function section 
perform search list equivalent search leftist left perfect tree starts leftmost leaf proceeds upwards left spine downwards appropriate node 
search exactly performed finger placed leftmost leaf nodes left spine pointed parent 
corresponds simple version finger search leaf tree 
plan explore relations 
additional research topics explore monads functional data structures monads increasingly popular functional programming community hm mj wad 
major uses incorporate imperative features functional programming languages 
reasonably expect imperative features functional data structures adapt imperative data structures functional setting 
circular programs circular data structures lazy functional languages naturally allow creation circular data structures design circular programs 
features may yield efficient algorithms operations functional languages bir 
certain problems lazy languages powerful eager languages 
naturally obtained programming technique described 
circular structures described far major shortcoming easily modified created kw 
ahu aho hopcroft 
design analysis computer algorithms 
addison wesley reading ma 
ahu alfred aho john hopcroft jeffrey ullman 
data structures algorithms 
addison wesley 
lloyd allison 
circular programs self referential structures 
software practice experience february 
bag amir ben zvi galil 
pointers versus addresses 
journal acm july 
bir bird 
circular programs eliminate multiple traversal data 
acta informatica 
bir richard bird 
building trees height 
journal functional programming july 
richard bird geraint jones oege de moor 
speed lazy versus eager evaluation 
journal functional programming september 
bo gerth st chris okasaki 
optimal purely functional priority queues 
journal functional programming november 
br braun rem 
logarithmic implementation flexible arrays 
memorandum eindhoven university technology 
bst buchsbaum tarjan 
data structural bootstrapping linear path compression catenable heap ordered double ended queues 
proceedings rd ieee symposium foundations computer science pages 
buc adam louis buchsbaum 
data structural bootstrapping catenable deques 
phd thesis department computer science princeton university june 
bur warren burton 
efficient functional implementation fifo queues 
information processing letters july 
warren burton hsi kai yang 
manipulating data structures pure functional language 
software practice experience november 
cg chuang benjamin goldberg 
real time deques turing machines purely functional programming 
fpca 
proceedings conference functional programming languages computer architecture pages copenhagen denmark june 
acm 
cha 
implementation flexible arrays balanced trees 
computer journal october 
clr thomas cormen charles leiserson ronald rivest 
algorithms 
mit press cambridge massachusetts 
dk victor anne 
simple efficient flexible implementation flexible arrays 
bernhard moller editor mathematics program construction conference proceedings mpc number lecture notes computer science pages 
springer july 
dr paul dietz rajeev raman 
persistence amortization randomization 
proceedings second annual acm siam symposium discrete algorithms pages san francisco ca 
james driscoll neil daniel sleator robert tarjan 
making data structures persistent 
journal computer system sciences 
dst james driscoll daniel sleator robert tarjan 
fully persistent lists catenation 
journal acm september 
leo guibas edward mccreight michael janet roberts 
new representation linear lists 
conference record ninth annual acm symposium theory computing pages boulder colorado may 
gri david gries 
science programming 
texts monographs computer science 
springer verlag 
gt robert tarjan 
deques heap order 
information processing letters 
hm robert hood robert melville 
real time queue operations pure lisp 
information processing letters november 
hm graham hutton erik meijer 
monadic parser combinators 
technical report tr department computing science university nottingham 
hoo robert hood 
efficient implementation high level programming language constructs 
phd thesis department computer science cornell university 
tec 
report tr 
hoo rob 
logarithmic implementation flexible arrays 
bird morgan woodcock editors mathematics program construction second international conference proceedings number lecture notes computer science pages berlin june july 
springer verlag 
hoo rob 
symmetric set efficient list operations 
journal functional programming october 
giuseppe italiano neil 
fully persistent data structures disjoint set union problems 
dehne sack santoro editors algorithms data structures volume lecture notes computer science pages ottawa canada august 
nd workshop wads springer verlag 
jon mark jones 
gofer 
available unibe ch scg sw gofer 
jon mark jones 
hugs haskell user gofer system 
user manual 
available cs nott ac uk department staff mpj hugs manual manual html 
kd anne victor 
leaf trees 
science computer programming may 
kin king 
functional binomial queues 
hammond turner sansom editors glasgow functional programming ayr scotland 
springer verlag 
kos rao kosaraju 
localized search sorted lists 
thirteenth annual acm acm symposium theory computing pages milwaukee wisconsin may 
acm 
kt haim kaplan robert tarjan 
persistent lists catenation recursive slow 
acm symposium theory computing pages las vegas nevada may 
kt haim kaplan robert tarjan 
purely functional representations catenable sorted lists 
acm symposium theory computing pages may 
kw david wise 
graph algorithms lazy functional programming language 
proceedings th international symposium lucid intensional programming pages 
lau john launchbury 
graph algorithms functional flavour 
johan jeuring erik meijer editors advanced functional programming number lecture notes computer science pages sweden may 
international spring school advanced functional programming techniques springer 
mj erik meijer johan jeuring 
merging monads folds functional programming 
johan jeuring erik meijer editors advanced functional programming number lecture notes computer science pages sweden may 
international spring school advanced functional programming techniques springer 
mt mehlhorn 
data structures 
jan van leeuwen editor handbook theoretical computer science volume algorithms complexity pages 
elsevier mit press 
mye eugene myers 
applicative random access stack 
information processing letters december 
mye eugene myers 
efficient applicative data types 
eleventh annual symposium principles programming languages pages salt lake city utah january 
oka chris okasaki 
purely functional random access lists 
functional programming languages computer architecture pages 
acm press june 
oka chris okasaki 
simple efficient purely functional queues deques 
journal functional programming october 
oka chris okasaki :10.1.1.54.6229
functional data structures 
advanced functional programming volume lecture notes computer science pages 
second international summer school august 
oka chris okasaki 
purely functional data structures 
phd thesis school computer science carnegie mellon university september 
oka chris okasaki 
role lazy evaluation amortized data structures 
international conference functional programming pages may 
oka chris okasaki 
catenable double ended queues 
international conference functional programming pages june 
oka chris okasaki 
algorithms braun trees 
journal functional programming november 
appear 
pau laurence paulson 
ml working programmer 
cambridge university press 
phe john peterson kevin hammond editors 
haskell 
non strict purely functional language may 
available www cs nott ac uk research fpg report haskell report html 
phe john peterson kevin hammond editors 
haskell 
non strict purely functional language april 
available haskell cs yale edu 
pj simon peyton jones 
bulk types class 
phil trinder editor proceedings glasgow functional programming scotland july 
available www dcs gla ac uk fp workshops proceedings html 
simon peyton jones philip wadler 
imperative functional programming 
th acm symposium theory computing pages january 
pon carl ponder 
languages inefficient 
sigplan notices june 
sed robert sedgewick 
algorithms 
addison wesley nd edition 
tam roberto tamassia 
data structures 
acm computer surveys march 
tar robert endre tarjan 
amortized computational complexity 
siam journal algebraic discrete methods april 
tho simon thompson 
haskell craft functional programming 
addison wesley 
van van den 
new programming technique lazy functional languages 
science computer programming february 
wad philip wadler 
monads functional programming 
lecture notes marktoberdorf summer school program design calculi springer verlag august 
