computational comonads intensional semantics stephen brookes shai geva october cmu cs school computer science carnegie mellon university pittsburgh pa research supported part national science foundation ccr part darpa nsf ccr 
views contained document authors interpreted representing official policies expressed implied nsf darpa government 
keywords theory applicative functional programming semantics parallelism category theory lazy evaluation explore foundational issues development theory intensional semantics 
programming language may variety semantics differing level abstraction generally chooses semantics abstraction level appropriate reasoning particular kind program property 
extensional semantics typically appropriate proving properties partial correctness intensional semantics lower abstraction level required order reason computation strategy support reasoning intensional aspects behavior order evaluation efficiency 
obviously desirable able establish sensible relationships semantics language seek general category theoretic framework permits 
extensional category morphisms think functions kind model notion computation comonad certain extra structure regard kleisli category comonad intensional category 
intensional morphism algorithm thought function computations values 
view accords lazy operational interpretation programs 
certain general assumptions underlying category recovered kleisli category quotient derived congruence relation call extensional equivalence 
focus case underlying category cartesian closed 
assumptions kleisli category satisfies weak form cartesian closure application morphisms exist currying uncurrying morphisms sense diagram exponentiation commutes extensional equivalence 
underlying category ordered category identify conditions exponentiation diagram commutes inequality 
illustrate ideas results introducing notions computation domains discussing properties corresponding categories algorithms domains 
existing denotational semantic treatments programming languages extensional away computational details ascribe essentially extensional meanings programs 
instance standard denotational treatment imperative programs meaning program taken partial function states states standard denotational model simply typed calculus meaning term function type taken continuous function 
extensional models appropriate wants reason extensional properties programs partial correctness programs 
models give insight questions concerning essentially intensional aspects program behavior efficiency complexity 
instance typical extensional model sorting programs denote function regardless computation strategy regardless worst average case behavior 
desirable semantic model sensible comparisons programs extensional behavior basis computation strategy 
emphasize regard relative term programming language wish provide extensional semantics intensional semantics contains computational information lower level abstraction 
able extract extensional meanings intensional meanings show intensional semantics fits properly top extensional semantics 
suppose extensional semantics provided category objects represent sets data values morphisms functions kind intensional semantics category objects morphisms regard algorithms correspond functions equipped computation strategy 
reasonable able define equivalence relation algorithms hom set identifies pairs algorithms extensional part composition algorithms respect equivalence quotienting algorithms equivalence relation yield precisely extensional morphisms 
set basis category theoretic approach intensional semantics motivated intuition 
extensional meaning program may modelled kind function data values data values obtain intensional semantics introducing notion computation defining intensional meaning function computations values 
accords intuitive operational semantics programs execution program proceeds lazily coroutine manner program responds requests output say user performing input computation sufficient information supply output value 
formalize mean notion computation terms follows 
suppose extensional meanings category object specify object ta computations specify lift morphism morphism tf ta tb require functor specify object morphism ffl ta computations values morphism ffi ta maps computation computation ta 
intuitively ffl maps computation value computes ffi shows computation may computed 
require ffl ffi comonad regard kleisli category comonad intensional category objects intensional morphism just morphism ta say comonad computational natural way convert data value degenerate computation returning value 
enables extract algorithm function values values obtain extensional equivalence relation algorithms identifying pairs algorithms determine function 
show comonad computational kleisli category collapses extensional equivalence 
show assuming certain conditions concerning products kleisli category satisfies intensional analogue cartesian closedness property 
generalizes known result underlying category cartesian closed functor part comonad preserves products kleisli category cartesian closed 
underlying category ordered category identify conditions kleisli construction preserves certain lax forms cartesian closedness 
motivate definitions results means notions computation domains 
focus primarily forms computation differing levels abstraction 
discuss briefly examples indicate broader applicability ideas 
assume familiarity elementary category theory domain theory 
refer reader categorical background relevant domain theory :10.1.1.51.1284
computations comonads algorithms category regard providing extensional framework 
wish encapsulate terms notion computation build intensional category morphisms thought extensional morphisms equipped additional computational information 
model notion computation comonad functor part maps object object ta representing computations components comonad describe extract value computation computation built sub computations 
take intensional morphism extensional morphism ta essentially morphism input computations output values leads intensional category kleisli category objects morphisms exactly morphisms ta typically category morphisms functions kind refer intensional morphisms algorithms emphasize computational content 
case need compare kleisli categories different comonads underlying category term algorithm indicating comonad explicitly 
comonads kleisli category definition comonad category triple ffl ffi functor ffl natural transformation identity functor ffi natural transformation associativity identity conditions hold object ffi ffi ffi ffi ta ffi ffi ffl ta ffi ffi ffl ffi ffi id ta figures express requirements diagrammatic form 
ffl definition comonad ffl ffi kleisli category defined ta tb ta tb tf ffl ffl tf ffi ffi naturality ffl ffi comonad diagrams commute ta ta ta oe ffl ta ffl ffi id ta gamma gamma gamma gamma gamma gamma gamma gamma gamma id ta ta ffi ffi ffi ffi ta identity associativity laws comonad diagrams commute ffl objects objects ffl morphisms morphisms ta ffl identity morphism id ffl ta ffl composition denoted ffi composition ffi ta ta tb tb ffi ffi ta ffi ffi associativity identity laws comonad ensure category 
ffl morphisms ta model algorithms fits intuitive operational semantics coroutine mechanism 
program responds requests output performing computation input typically evaluate portion input information determine output value produce 
execution lazy computation demand driven 
operational behavior algorithm composition described follows 
ffi responds request output performing input computation transforming computation applying prefixes supplying argument details concerning operational semantics refer 
notions computation domains main examples category domains continuous functions 
avoid repetition precise domain mean directed complete algebraic partial order element 
domain set equipped partial order satisfying conditions ffl element denoted ffl non empty directed subset upper bound ffl non empty bounded consistent subset upper bound ffl element upper bound directed set finite approximations 
set directed iff set bounded iff element finite iff directed subsets example comonads really requires underlying domain algebraic presence element play prominent role course justifying existence fixed points 
just category directed complete bounded complete partial orders continuous functions 
property algebraicity natural computational setting example functors domains preserve algebraicity 
discuss examples different categories different types domain 
increasing paths notion computation introduce models terms sequence time steps incremental evaluation performed 
example program inputs may need evaluate input arguments may attempt perform evaluations parallel sequence may require partial information arguments typically case say argument function program needs apply argument known parameter 
natural way formalize form computation increasing sequence values drawn domain partial order reflects amount information inherent value 
define comonad increasing paths follows ffl domain set finite infinite increasing sequences ordered componentwise 
convenience represent finite sequence eventually constant infinite sequence 
elements form hd define hd hd iff vd ffl continuous function function applies componentwise 
hd ffl ffl upper bound comonad adapted scott domains introduced 
gamma gamma gamma gamma domain theta 
ffl ffi sequence finite prefixes hd ffit 
intuitively computation may viewed time indexed sequence increments amount information known data value value computed computation upper bound computation built progressively prefixes 
equivalently regard computation continuous function domain vertical natural numbers limit point ordering computations corresponds exactly pointwise ordering functions 
element sequence 
finite elements just eventually constant sequences elements finite easy verify maps domains domains functor 
comonad laws hold naturality ffl corresponds continuity naturality ffi states operation applying function componentwise sequence commutes prefixes computation upper bound prefixes prefix prefix prefix illustration domain domain theta shown shows continuous functions theta ordered pointwise 
give functions mnemonic names constant functions strict left argument strict right argument strict arguments poll returns arguments poll strict argument 
function depicted hasse diagram corresponding nodes shaded indicate image function described ffi corresponds ffl 
shows part theta 
shows algorithms theta ordered pointwise 
notation describing algorithms ffi representing ffl representing 
case intended algorithm continuous function paths consistent description 
nomenclature intended indicate informally function computed algorithm computation strategy algorithm uses 
instance algorithms pb lb rb db compute function pb computes arguments parallel immediately lb computes left right rb computes right left db computes arguments order 
diagram includes algorithm poll cases name algorithm function 
theta includes paths repeated steps distinctions algorithms differ order evaluate arguments amount time prepared wait successive increment achieved 
instance function algorithms pb lb rb db characterized ffi ffi ffi ffi gamma gamma gamma gamma ffi ffi ffi ffl gamma gamma gamma gamma ffi ffl ffi ffl gamma gamma gamma gamma ffi ffi ffl ffl gamma gamma gamma gamma ffi ffl ffl ffl gamma gamma gamma gamma poll ffl ffl ffl ffl gamma gamma gamma gamma gamma gamma gamma gamma continuous functions theta ordered pointwise 
ih paths theta ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffl pb ffi ffi ffi ffl ffi ffl lb ffi ffi ffi ffi ffl ffl rb ffi ffi ffi ffl ffl ffl db ffi ffl ffi ffl ffi ffl sl ffi ffi ffl ffi ffl ffl sr ffi ffl ffi ffl ffl ffl pl ffi ffi ffl ffl ffl ffl pr ffi ffl ffl ffl ffl ffl poll ffl ffl ffl ffl ffl ffl gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma algorithms theta ordered pointwise 
functions paths pb lb rb db db informally pb algorithm needs evaluate arguments returns provided evaluation succeeds result time steps 
similarly lb evaluates arguments returns provided evaluation left argument succeeds time steps evaluation right argument succeeds time steps 
relationships hold pb lb pb pb rb pb db lb rb pb pb lb lb db db 
sequences algorithms upper bound characterized algorithm maps path lub 
course pb just pb 
strictly increasing paths comonad computation built measure number time steps takes successive proper increments 
obtain notion computation retaining increments may distinctions basis order evaluation arguments 
model computation strictly increasing path 
define strictly increasing path comonad follows 
ffl set finite infinite strictly increasing sequences convenience represent finite sequence eventually constant infinite sequence 
elements form hd form 
dn gamma partial order 
dn gamma 
dn gamma dn vd ordering prefix ordering sequences adjusted take appropriate account underlying order data values 
order stable ordering regard elements strictly increasing possibly eventually constant stable functions note continuous function stable 
ffl continuous function define function applies componentwise suppresses repetitions constant suffixes 
continuous function fd fd fd fd fd fd ih part theta 
ffl ffl lub ffl ffi sequence prefixes hd ffit 
note strictly increasing ffi element sequence 
lub directed consistent set strictly increasing paths strictly increasing path finite elements eventually constant sequences form hd 
dn gamma id dn finite element element lub finite approximations 
maps domains domains 
functoriality easily checked 
order pointwise true lub prefixes 
comonad laws hold ffl ffi 
shows paths theta 
shows algorithms theta ordered pointwise notation 
nomenclature chosen indicate function computed computation strategy 
algorithms corresponding algorithm name different ordering paths additional algorithms 
note include paths repeated elements pb pb family pb algorithms defined corresponding algorithms 
timed data simple notion computation domains obtained regarding computation pair consisting data value natural number intuitively representing amount time cost associated calculation value 
reasonable regard computation hd ni approximating hd iff better computation produces precise data value time 
suggests comonad ffl theta op ordered componentwise 
ffl hd ni ni 
ffl ffl hd ni case ordered componentwise directed complete componentwise ordering 
ffi ffi ffi ffi ffi ffi phi phi omega omega ffi ffi ffi ffi ffi ffl phi phi omega omega pb ffi ffi ffi ffl ffi ffl phi phi omega omega lb ffi ffi ffi ffi ffl ffl phi phi omega omega rb ffi ffi ffi ffl ffl ffl phi phi omega omega db ffi ffl ffi ffl ffi ffl hh phi phi omega omega sl ffi ffi ffl ffi ffl ffl phi phi omega omega sr ffi ffl ffi ffl ffl ffl phi phi omega omega pl ffi ffi ffl ffl ffl ffl phi phi omega omega pr ffi ffl ffl ffl ffl ffl phi phi omega omega poll ffl ffl ffl ffl ffl ffl phi phi omega omega ffi ffi ffi ffl ffi ffi hh phi phi omega omega 
ffi ffi ffi ffi ffl ffi phi phi omega omega 
ffi ffi ffi ffl ffl ffi phi phi omega omega 
gamma gamma gamma gamma algorithms theta ordered pointwise 
ffl ffi hd ni ni ni 
op domain consisting natural numbers ordered reverse usual ordering element 
element may define continuous function algorithm hd ki fd clearly get ordering get simply hd ni fd 
lub function hd ni 
fd 
nomenclature show algorithms theta 
possible define comonad functor td theta usual ordering integer component 
relating algorithms functions computational comonads say comonad computational object data value regarded degenerate computation ta degenerate computations possess certain simple properties 
permits extract algorithm function values values looking algorithm effect applied degenerate computations 
algorithms called extensionally equivalent iff determine function 
precisely require existence natural transformation fl satisfying axioms capture formally mean degeneracy 
show permits define extensional equivalence relation hom set extensional equivalence preserved composition congruence underlying category may recovered quotient 
definition computational comonad category quadruple ffl ffi fl ffl ffi comonad fl natural transformation object ffl ffl ffi fl id ffl ffi ffi fl fl ta ffi fl naturality guarantees morphism ffl tf ffi fl fl ffi shows properties diagrammatic form 
ffl immediate corollary properties ffl epi fl mono object proposition ffl ffi fl computational comonad pair functors alg fun definitions properties ffl alg identity objects alg ffi ffl poll poll poll poll 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma algorithms theta ordered pointwise 
ta id au fl delta delta delta delta delta delta delta delta delta ffl ta ta fl ta fl ffi fl ta tb fl fl tf properties computational comonad diagrams commute morphisms ffl fun identity objects fun ffi fl ffl fun induces equivalence relation fun fun relation congruence ffi ffi ffl quotient category isomorphic ffl fun ffi alg fun alg ffl alg ffi fun alg fun proof functoriality alg fun straightforward 
instance fun ffi ffi ffi fl ffi ta ffi ffi ffi fl ffi ta ffi fl ffi fl ffi ffi fl fl ffi fl ffi fl ffi ffi fl naturality fl fun ffi fun similar calculation shows congruence 
quotient objects objects morphisms quotient category equivalence classes morphisms write equivalence class clearly map 
alg isomorphism hom sets showing isomorphic facts elementary consequences definitions 
say fun extensional morphism computed fun extensional morphism computed necessarily unique intensional morphism 
results show computational comonad produce intensional category yields back underlying extensional category take extensional quotient 
show fun alg natural transformations 
set category sets functions 
ta ta fun fun tf ta ta alg alg tf naturality fun alg computational comonad diagrams commute definition variable hom functor gamma gamma op theta set takes pair objects ta takes pair morphisms tf ta ta ta tf ffi ffi tf similarly variable hom functor gamma gamma takes ffi ffi ffl proposition ffl ffi fl computational comonad category fun alg defined proposition natural transformations fun gamma gamma gamma gamma alg gamma gamma gamma gamma identities hold fun ffi tf ffi fun tf ffi alg alg ffi expresses properties diagram form 
proof straightforward naturality fl ffl 
show example comonads introduced earlier extended examples computational comonads 
examples 

increasing paths comonad fl defined fl clearly fl continuous fl natural transformation 
computational comonad laws hold lub prefixes equal functor fun maps algorithm theta function theta 
particular fun pb fun lb fun rb fun db similarly fun pb fun fact alg 
illustrates result extensional quotient 
boxes enclose equivalence classes algorithms arcs boxes represent quotient ordering box retain pointwise order ease comparison 
expected quotient isomorphic identify equivalence class function computed 

strictly increasing paths comonad may fl fl continuous function fl natural transformation 
computational comonad laws hold 
shows quotient extensional equivalence 
note fun fun fun fun 
quotient diagram isomorphic 
timed data comonad obtain suitable fl deciding cost associate degenerate computation 
may take fl hd ki obtain natural transformation satisfying requirements computational comonad 
define fun functor action algorithms fun ffi fl equivalence relation induced fl example fun clearly iff 
kleisli category quotients underlying category congruence induced fl shows quotient equivalence induced fl products exponentiation products suppose underlying category products pair objects distinguished product denote theta projections 
easy show distinguished product objects product objects projections theta ffl ffi thetaa pairing morphisms pairing morphisms combination ht plays special role light properties 
pb lb rb db gamma gamma gamma gamma sl pl sr pr poll gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma quotient extensional equivalence 

gamma gamma gamma gamma pb lb rb db gamma gamma gamma gamma sl pl sr pr poll gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma quotient extensional equivalence 
poll gamma gamma gamma gamma poll poll poll 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma quotient equivalence induced fl proposition products oe gamma theta gamma gamma theta gamma defined oe theta ta theta tb oe ht natural transformation objects ffl theta ffl ffi oe ffl thetab ffi theta ffi ffi oe oe ta tb ffi oe ffi ffi thetab oe ffi fl thetab fl theta fl proof naturality oe follows universal property products functoriality remaining properties easy consequences naturality ffl ffi fl 
note identity oe ffi hf gi 
particular oe ffi oe omega ff exponentiation suppose underlying category cartesian closed 
assume distinguished terminal object distinguished binary products pair objects distinguished exponentiation object satisfying usual requirements morphism app theta morphisms theta unique morphism curry app ffi curry theta id equivalently category cartesian closed finite products pair natural isomorphisms curry gamma theta gamma uncurry gamma gamma theta gamma theta gamma contravariant hom functors op category set standard definitions 
requiring curry uncurry uncurry curry naturality conditions theta curry ffi theta id curry ffi uncurry ffi theta id uncurry ffi follows easily conditions choose app uncurry id suitable application morphism 
want give general conditions analogous properties obtained kleisli category assuming cartesian closed obvious candidate exponential object tb know natural isomorphism tb ta theta tb 
theta just theta clear assumptions relationship theta ta theta tb 
theta ta theta tb naturally isomorphic easy show cartesian closed apparently folk theorem 
comonad property gave proof property kleisli category cartesian closed 
reasonable examples preserve products including described earlier 
weaker assumption comonad equipped natural ways move back forth theta ta theta tb interact sensibly comonad operations ffl ffi fl 
conveniently summarized means natural transformations split merge satisfying certain combinational laws 
definition ffl ffi fl computational comonad 
computational pairing pair natural transformations split gamma theta gamma gamma theta gamma merge gamma theta gamma gamma theta gamma objects properties hold ffl theta ffl ffi split ffl thetab ffl thetab ffi merge ffl theta ffl split ffifl thetab fl theta fl merge ffi fl theta fl fl thetab ffi theta ffi ffi split split ta tb ffit split ffiffi thetab merge ta tb ffi ffi theta ffi split ffiffi thetab ffi merge naturality split merge requires split ffit theta tf theta tg ffi split merge ffi theta tg theta ffi merge summarize properties diagram form 
ffl properties listed formalize sense require splitting merging operations interact sensibly ffl ffi fl 
particular properties follow immediately 
corollary ffl ffi fl computational comonad split merge form computational pairing 
ffl theta ffl ffi split ffi merge ffl theta ffl split ffi merge ffi fl theta fl fl theta fl ffl thetab ffi merge ffi split ffl thetab merge ffi split ffifl thetab fl thetab seen oe ht qualifies suitable split operation proposition 
despite fact split merge generally uniquely determined computational pairing laws wish permit comonads non standard choices split 
naturality split merge imply computational pairing laws 
examples 
return increasing path comonad natural transformation oe ht oe hn isomorphism inverse merge hs ti hs intuitively operations works parallel components 
oe merge natural transformations satisfy computational pairing laws state ffl merging splitting commute componentwise application functions 
ta theta tb theta theta ta theta tb split split theta tf theta tg theta ta theta tb ta theta tb theta merge merge theta tf theta tg ta theta tb theta theta split gamma gamma gamma gamma gamma gamma gamma gamma gamma ffl theta ffl ffl thetab theta ta theta tb theta split fl theta fl fl thetab ta theta tb merge ffl theta ffl ta theta tb merge gamma gamma gamma gamma gamma gamma gamma gamma gamma fl theta fl ta theta tb theta ta theta tb theta theta ta theta tb theta merge split ffi theta ffi ffi theta ffi ffi thetab split merge ta tb split ta tb properties computational pairing diagrams commute ffl merging splitting respect lubs sequences 
ffl merging splitting respect prefixes 
ffl merging degenerate computations produces degenerate computation splitting degenerate computation produces pair degenerate computations 

intuitively sensible ways split merge increasing paths comonad define form left interleaving hs ti dn bn example gives hs hs hs hs hs go define split operates alternate steps computation split hn obtain identity split ffi id easy verify split natural transformations computational pairing properties hold making equalities bmin min bi dmin min di 
clearly right version interleaving interacts sensibly split 

strictly increasing paths comonad split merge combinations adapts obvious way modified ensure result splitting strictly increasing sequence pairs pair strictly increasing sequences 
example oe ih 
merge 
ih fact theta theta generally isomorphic strictly increasing sequence pairs necessarily increase strictly components stage 
oe merge natural transformations satisfying requirements listed computational pairing identity oe ffi merge id appropriately adjusted split operations form computational pairing split ffi id similar properties hold split pairing currying uncurrying algorithms split operation computational pairing provides way combine pair algorithms algorithm pairs 
split taken oe standard way form product morphisms kleisli category 
split define intensional analogues contravariant hom functors gamma theta gamma 
definition category finite products ffl ffi fl computational comonad split natural transformation gamma theta gamma gamma thetat gamma 
define theta theta theta theta theta ffi split 
ffl proposition category finite products ffl ffi fl computational comonad split merge form computational pairing 
functor theta theta maps pair objects theta maps pair morphisms theta theta ffi split 
proof show theta maps identity morphisms identity morphisms id theta id ffl theta ffl ffi split ffl thetab id thetab show theta preserves composition theta ffi theta theta ffi split ffi theta ffi split theta ffi split ffit theta ffi split ffiffi theta ffi ta theta ffi split ffit split ffiffi theta ffi ta theta ffi ffi theta ffi ffi split ffi ta ffi ffi theta ffi tb ffi ffi ffi split ffi theta ffi ffi split ffi theta ffi definition cartesian closed category ffl ffi fl computational comonad split merge form computational pairing 
contravariant functor gamma theta op set defined follows 
ffl objects functor maps theta 
ffl morphisms functor maps function ffi theta id theta theta 
similarly contravariant functor gamma tb op set defined ffl objects functor maps tb 
ffl morphisms functor maps function ffi tb tb 
ffl proposition ffl ffi fl computational comonad split merge computational pairing 
theta ta tb define curry ta tb uncurry theta curry curry ffi merge uncurry uncurry ffi split ffl curry uncurry natural transformations curry gamma theta gamma tb uncurry gamma tb gamma theta ffl theta uncurry curry ffl theta uncurry curry alg alg proof ffl naturality curry amounts requirement curry ffi theta id curry ffi theta follows naturality currying properties computational pairing curry ffi theta id curry ffi theta ffl ffi split ffiffi curry ffi theta ffl ffi split ffiffi ffi merge curry ffi theta ffl ffi merge ffi ffi theta ffi curry ffi merge ffi theta ffl ffi ffi theta ffi curry ffi merge ffi ffi ffi theta ffl ffi ffi curry ffi merge ffi ffi ffi theta id curry ffi merge ffi tf ffi ffi curry ffi tf ffi ffi curry ffi ffl similarly show naturality uncurry need uncurry ffi theta id uncurry ffi tb 
proof straightforward uncurry ffi theta id uncurry ffi split ffit theta ffl ffi split ffiffi uncurry ffi tf theta ffl ffi split ffit split ffiffi uncurry ffi tf theta ffl ffi ffi theta ffi ffi split uncurry ffi tf ffi ffi theta ffl ffi ffi ffi split uncurry ffi tf ffi ffi theta id ffi split uncurry ffi tf ffi ffi ffi split uncurry ffi ffi split uncurry ffi ffl theta uncurry curry ffi fl uncurry curry ffi merge ffi split ffifl ffi merge ffi split ffifl ffi merge ffi split ffifl ffi fl showing uncurry curry ffl theta uncurry curry alg uncurry curry alg ffi merge ffi split alg ffi merge ffi split ffi ffl ffi merge ffi split corollary ffi ffl alg shown intensional pairing produces weak form exponentiation structure obtain notions currying uncurrying algorithms natural transformations satisfy weaker condition isomorphism 
may rephrase properties terms existence notion application intensional category follows 
proposition cartesian closed category ffl ffi fl computational comonad split merge computational pairing 
application morphism app tb theta theta app ffi curry theta id proof define app uncurry id tb uncurry ffl tb corollary naturality uncurry proposition get app ffi theta id uncurry id ffi theta id uncurry id ffi uncurry particular app ffi curry theta id uncurry curry note curry unique morphism app ffi theta id morphisms satisfy condition uncurry weak form cartesian closedness usual diagram exponentiation replace relax uniqueness condition 
summarized 
consider happens assumptions relationship split merge 
proposition cartesian closed category ffl ffi fl computational comonad computational pairing split merge 
ffl merge ffi split id uncurry ffi curry id ffl split ffi merge id curry ffi uncurry id corollary get version folk theorem theta tb theta curry theta id gamma gamma gamma gamma gamma gamma gamma gamma gamma app computational pairing diagram commutes extensional equivalence theta corollary cartesian closed ffl ffi fl computational comonad computational pairing merge ffi split id split ffi merge id category cartesian closed 
note important fact definitions parameterized choice split merge 
chosen app curry uncurry determined uniquely 
kleisli category independent split merge happens choice natural transformations induces weak form exponentiation structure category 
kleisli category may possess different notions merging splitting different ways curry uncurry apply algorithms 
means may kleisli category give interpretation functional programming language containing syntactically semantically distinct forms application 
desirable instance language included strict non strict form application 
examples 
kleisli category increasing path comonad cartesian closed exponentiation structure built standard split merge combination form isomorphism 
computational pairing split obtain intensional forms currying uncurrying application call curry uncurry app provides weak form exponentiation curry uncurry natural transformations theta get app ffi curry theta id split ffi id curry uncurry uncurry curry example uncurry curry pb uncurry curry lb pb uncurry curry rb algorithm mapping path ih ih 
algorithm course computes function similar properties hold computation pairing split derived operations curry uncurry app 
strictly increasing paths comonad computational pairing oe merge operations curry uncurry app provide weak forms exponentiation 
remarked earlier oe merge isomorphisms 
oe ffi merge id theta computation merge oe pointwise curry uncurry uncurry curry example uncurry curry lb uncurry curry rb uncurry curry pb pb split computational pairing gives rise weak form exponentiation split computational pairing 
ordered categories far principal examples cartesian closed category domains fully exploited order structure 
permitted state prove results hold general category theoretic setting 
suppose underlying category ordered category hom set equipped complete partial order composition continuous 
functor ordered categories required respect ordering tf tg 
continuous action morphisms 
examples far satisfy conditions 
suppose ffl ffi fl computational comonad ordered category clearly ordered category 
results previous sections go ordered setting 
particular functors fun alg introduced earlier respect ordering proof proposition adapted show extensional quotient ordering just order 
obtain slightly stronger results advantage ordering 
omit proofs may easily obtained results monotonicity continuity composition 
proposition ordered ccc ffl ffi fl computational comonad computational pairing 
ffl split ffi merge id curry ffi uncurry id ffl split ffi merge id curry ffi uncurry id ffl merge ffi split id uncurry ffi curry id ffl merge ffi split id uncurry ffi curry id introduce simple generalization notion cartesian closed ordered category obtained relaxing requirement currying uncurrying form isomorphism 
allow currying uncurrying form adjunction homset example local adjunction see example additional properties :10.1.1.51.1284:10.1.1.51.1284
relevance lax notions adjunction computational settings albeit different motivations pointed different contexts authors instance 
definition ordered category cartesian closed finite products pairs objects object pair lax natural transformations curry uncurry gamma theta gamma satisfying curry uncurry uncurry curry curry ffi theta id curry ffi uncurry ffi theta id uncurry ffi similarly say cartesian closed iff finite products pair lax natural transformations curry uncurry satisfying curry uncurry uncurry curry curry ffi theta id curry ffi uncurry ffi theta id uncurry ffi ffl definition ordered category finite products 
ffl exponential objects object morphism app theta theta morphism curry app ffi curry theta id ffl exponential objects object morphism app theta theta greatest morphism curry app ffi curry theta id ffl result may shown adapting usual proof alternative definitions cartesian closed categories equivalent 
proposition ordered category cartesian closed iff finite products 
ordered category cartesian closed iff finite products exponentials 
note object morphism app qualifies simultaneously exponential forms usual notion exponentiation category cartesian closed usual sense 
proposition cartesian closed category ffl ffi fl computational comonad split merge computational pairing split ffi merge id merge ffi split id ffi theta ffi ffi split split ffit split ffiffi merge ffi ffi theta ffi split ffiffi ffi merge cartesian closed 
proof ffl theta tb 
uncurry curry uncurry curry ffi merge ffi split ffi merge ffi split curry uncurry curry uncurry ffi split ffi merge curry uncurry ffl show curry lax natural transformation theta curry ffi theta id curry ffi theta ffl ffi split ffiffi curry ffi theta ffl ffi split ffiffi ffi merge curry ffi theta ffl ffi merge ffi ffi theta ffi curry ffi merge ffi theta ffl ffi ffi theta ffi curry ffi merge ffi ffi ffi theta ffl ffi ffi curry ffi merge ffi ffi ffi theta id curry ffi merge ffi tf ffi ffi curry ffi tf ffi ffi curry ffi ffl show uncurry lax natural transformation suppose tb 
uncurry ffi theta id uncurry ffi split ffit theta ffl ffi split ffiffi uncurry ffi tf theta ffl ffi split ffit split ffiffi uncurry ffi tf theta ffl ffi ffi theta ffi ffi split uncurry ffi tf ffi ffi theta ffl ffi ffi ffi split uncurry ffi tf ffi ffi theta id ffi split uncurry ffi tf ffi ffi ffi split uncurry ffi ffi split uncurry ffi similar result holds cartesian closed category computational pairing satisfying reversed inequalities 
examples return third comonad introduced earlier introduce briefly related notions computation different categories domains functions 
timed data timed data comonad standard split operation split hha bi ni hha ni hb nii interpretation hd ni computation yielding cost obvious choice merge operation merge ha mi hb ni hha bi max operations natural transformations obtain properties split ffi merge id merge ffi split id ffi theta ffi ffi split split ffit split ffiffi merge ffi ffi theta ffi split ffiffi ffi merge underlying category cartesian closed cartesian closed 
follows proposition kleisli category cartesian closed 
strict algorithms category domains strict continuous functions cartesian closed category products 
pair domains set strict continuous functions ordered pointwise domain 
usual uncurrying operation functions preserves strictness usual currying 
may define variant form currying curry theta 
curry 
strict curry best strict function approximating curry pointwise 
instance lor ror sor left strict right strict doubly strict functions 
uncurry curry lor uncurry curry ror uncurry curry sor sor easy check curry natural transformation uncurry 
relationships hold theta curry uncurry uncurry curry category domains strict continuous functions cartesian closed 
set increasing paths just strict continuous maps ordered pointwise 
maps ffl ffi fl strict split merge operations 
may kleisli construction build model strict parallel algorithms 
illustrate model note algorithms belong category exception non strict 
underlying category cartesian closed computational pairings discussed earlier gives rise exponentiation structure category domains strict algorithms cartesian closed 
may adapt comonads category 
computation effectively domains category effectively domains computable functions cartesian closed 
domain effectively iff finite elements recursively enumerable countable decidable finite elements consistent index lub consistent finite elements decidable function indices 
element computable iff set indices finite approximations recursively enumerable 
functor adapted category defining effectively domain computable increasing paths equivalently computable continuous functions ordered pointwise 
auxiliary operations ffl ffi fl computable 
obtain category effectively domains computable algorithms category quotients underlying category effectively domains computable functions 
algorithms category cartesian closed 
functor maps effectively domains effectively domains auxiliary operations computable 
obtain category effectively domains algorithms quotients underlying category cartesian closed 
functor preserves algebraicity algebraicity may uncountably finite elements 
comonad adapt category effectively domains computable functions 
computation pre domains term pre domain domain directed complete bounded complete algebraic partial order requirement element 
category predomains continuous functions cartesian closed 
set non empty finite infinite increasing sequences ordered prefix ordering 
clearly forms pre domain finite elements just finite sequences 
generally pre domain domain element prefix ordering relate sequences different elements 
functor specifying usual applies componentwise 
ffl lub operation ffi sequence non empty prefixes ffl ffi forms comonad 
may regard computation length degenerate corresponds defining function fl fld hdi 
function fl continuous claim computational comonad obtain congruence relation algorithms defining hdi note ffi ffl ffi ffl easy modify proof proposition show kleisli category comonad quotients underlying category may define splitting merging operations follows 
standard way split split hx 
hx hx 

split hx hhx hy merge continuous function satisfying merge 

hx 
hx min merge 
hy hx 
hx merge hx 
hx 
hx merge hx hy hx clearly merge ffi split id split ffi merge id operations obviously natural satisfy computational pairing properties ffl ffi merge ffl theta ffl 
kleisli category cartesian closed 
described category theoretic approach intensional semantics idea notion computation intensional behavior may modelled means computational comonad kleisli category obtained viewed intensional model 
morphisms category map computations values morphism may recover map values values 
may define equivalence relation identifies algorithms compute function equivalence relation collapse kleisli category underlying category 
identified set conditions kleisli category possesses exponentiations weaker types exponentiation existence natural ways pair computations 
described series examples illustrate applicability definitions results 
doing placed wider context 
arose attempt begun generalize earlier intensional model berry curien 
defined category deterministic concrete data structures sequential algorithms showed category cartesian closed collapses category deterministic concrete data structures sequential functions obvious notion extensional equivalence 
sequential functions category cartesian closed construction sequential algorithms comonad 
operational semantics implicit coroutine lazy restriction computation proceed sequentially argument evaluated time 
generalization model relax sequentiality restriction permit parallel computation 
query model parallel algorithms deterministic concrete data structures described contains algorithms non sequential functions parallel 
model construction complex unable formulate suitable notion composition algorithms 
streamlined form algorithm scott domains time cast construction terms comonad 
comonads introduced corresponds comonad closer spirit query model able go considerably 
moggi developed view programming languages notion computation modelled monad :10.1.1.41.840:10.1.1.26.2787
examples notions computation monads include computation side effects computation exceptions partial computations non deterministic computations 
view meaning program taken function values computations intuitive operational semantics program takes input type returns output computation 
point view consistent input driven lazy operational semantics 
contrast opposite point view comonads monads opposite category consistent lazy operational semantics 
moggi states view programs corresponds call value parameter passing says alternative view programs functions computations computations corresponding call name 
shows third alternative programs functions computations values 
common approaches realization values distinguished computations endofunctor 
apart motivations operational intuitions monad approach comonad approach different feel approaches regarded orthogonal complementary 
extra structure algebraic laws embodied monad appropriate moggi context 
equally extra structure algebraic laws embodied comonad appropriate context 
plan explore extent effect approaches combined 
instance comonad monad category obtain assuming satisfy certain properties category algorithms morphism morphism ta pb 
plan investigate notions computation domain theoretic settings 
working categories algorithms generalized concrete data structures 
interesting see berry curien sequential algorithms category embedded kleisli category suitable comonad sequential functions category 
intend investigate notions computation category di domains stable functions category qualitative domains linear functions :10.1.1.45.4952
diagrams drawn macros designed john reynolds 
barr wells 
category theory computing science 
prentice hall international 
berry 
stable models typed calculi 
proc 
th coll 
automata languages programming number lecture notes computer science pages 
springer verlag july 
brookes geva 
theory parallel algorithms concrete data structures 
semantics concurrency leicester pages 
springer verlag 
brookes geva 
cartesian closed category parallel algorithms scott domains 
technical report cmu cs carnegie mellon university school computer science 
submitted publication 
brookes geva 
continuous functions parallel algorithms concrete data structures 
technical report cmu cs carnegie mellon university school computer science 
appear proceedings mfps 

curien 
categorical combinators sequential algorithms functional programming 
research notes theoretical computer science 
pitman 
:10.1.1.45.4952
girard 
proofs types 
cambridge university press 
gunter scott :10.1.1.51.1284
semantic domains 
handbook theoretical computer science volume formal models semantics 
mit press elsevier 
jay :10.1.1.51.1284
local adjunctions 
journal pure applied logic 
kahn macqueen 
coroutines networks parallel processes 
information processing pages 
north holland 
mac lane 
categories working mathematician 
springer verlag 
moggi 
computational lambda calculus monads 
fourth annual symposium logic computer science 
ieee computer society press june 
moggi 
notions computation monads 
information computation 
seely 
modeling computations categorical framework 
symposium logic computer science 
ieee computer society press june 
