slicing software model construction john hatcliff matthew dwyer hongjun zheng santos laboratory kansas state university december applying finite state verification techniques model checking software requires program source code translated finite state transition system safely models program behavior 
automatically checking transition system correctness property typically costly necessary reduce size transition system possible 
fact case program source code irrelevant verifying correctness property 
apply program slicing techniques remove automatically irrelevant code reduce size corresponding transition system models 
give simple extension classical slicing definition prove safety respect model checking linear temporal logic ltl formulae 
discuss slicing strategy fits general methodology deriving effective software models abstraction program specialization 
modern software systems highly complex extremely reliable correct 
years finite state verification techniques including model checking techniques received attention software validation method 
techniques effective validating crucial properties concurrent software systems variety domains including network protocols railway interlocking systems industrial control systems 
despite success high cost automatically checking correctness property software system typically enormous state space casts doubt broad application finite state verification software systems cost effective 
researchers agree best way attack state explosion problem construct finitestate transition system safely abstracts software semantics :10.1.1.116.9247
transition system small automatic checking tractable large capture information relevant property checked 
primary difficulties determining parts program relevant property checked 
show slicing automatically throw away irrelevant portions software code safely reduce size transition systems approximates software behavior 
envision slicing collection tools translating program source code models suitable verification 
previously illustrated techniques interpretation partial evaluation integrated applied help automate construction transition appear special issue higher order symbolic computation dedicated selected papers acm workshop partial evaluation program manipulation 
earlier version appeared proceedings acm workshop partial evaluation program manipulation january olivier danvy editor brics notes series ns 
supported part nsf ccr ccr ccr ccr nasa award nag 
www cis ksu edu santos hatcliff cis ksu edu nichols hall manhattan ks usa 
systems 
applying techniques realistic software systems revealed interesting interaction slicing abstraction building people currently perform slicing operations manually determine portions code relevant verifying property :10.1.1.55.9390
preprocessing software slicing applying partial evaluation abstraction techniques provide safe approximation relevant portions code ii enable scaling current manual techniques significantly larger complex systems iii reduce number components abstractions selected help guide selection iv reduce size program treated abstraction partial evaluation tools 
contributions contributions follows 
ffl show conventional slicing algorithms modified compress source level representations program models finite state verification 
involves reworking basic technical results slicing program dependence graphs language unstructured controlflow incorporating notion control slice introduced bates horwitz 
contrast abstraction approaches reducing models ensure sound models slicing approach generates reduced models sound complete respect temporal logic formula :10.1.1.116.9247
ffl devise simple automatic scheme directing modified slicing algorithm primitive propositions occurring temporal logic specifications 
works propose slicing reducing models formal link specifications inputs slicing algorithm 
ffl identify appropriate notions correctness slicing guarantee satisfaction specifications preserved reflected slicing 
discusses slicing model reduction defines proves correctness properties form slicing required preserving satisfaction specifications 
believe formalization proof correctness slicing necessary intends slicing component sound model construction methodology 
ffl show slicing connection abstraction techniques component set tools generating finite state models software 
ffl give preliminary experimental results illustrate impact slicing abstraction techniques model construction 
provides part foundational theory set tools building modelchecking java programs called bandera tool set :10.1.1.29.3872
essence bandera pipeline tools compile java source code inputs existing model checking tools smv spin 
major components bandera abstraction program specialization engine form partial evaluation combines interpretation partial evaluation transition system generator compiles abstracted java code program low level language translates guarded command program model checker input languages 
project web site gives additional information tool set application implementation 
web site contains tech report version 
includes expanded presentation correctness proofs 
organization section describes source language 
section presents reworking conventional definitions results slicing language 
brief overview approach generating models software section section discusses specific finite state verification technique linear temporal logic ltl model checking 
section describes technical details slicing model reduction 
section presents experimental results illustrate syntax domains programs fcl blocks fcl block labels fcl assignments fcl assignment lists fcl variables fcl expressions fcl constants fcl jumps fcl operations fcl grammar skip goto return syntax flowchart language fcl effectiveness slicing model reduction 
section discusses related slicing section summarizes concludes description 
appendix gives proofs basic properties control flow graphs appendix gives proofs correctness conventional slicing algorithm section appendix gives proofs correctness proposition slicing algorithm section 
flowchart language fcl bandera built top soot java compiler framework developed sable group university mcgill 
soot framework java programs translated intermediate language called jimple 
jimple originally introduced target language java decompiler 
accordingly jimple language control flow graphs statements appear code form 
explicit stack manipulation inherent jvm instructions removed introducing temporary variables 
capture essence jimple structure formal study slicing model checking simple flowchart language fcl gomard jones 
syntax presents definition fcl syntax 
fcl program consists list parameters label initial block executed non empty list basic blocks 
basic block consists label followed possibly empty list assignments 
block concludes jump transfers control block 
including boolean values non zero value represents true zero represents false test conditionals 
syntax specifies prefix notation operators infix notation examples deeply nested expressions improve readability 
presents fcl program computes power function 
input parameters program initial block specified line init 
parameters referenced assigned program 
variables result introduced explicit declaration 
initial value non parameter variable 
output program execution state memory return construct executed 
presentation slicing need reason nodes statement level control flow graph cfg graph separate node assignment jump program assume statement cfg node identifier unique program annotate statement source code unique identifier 
example assignment loop block unique identifier node number loop 
gives statement level control flow graph power program 
init init result init goto test init test loop test loop result result loop loop goto test loop return fcl program compute init init test loop loop loop power program statement level cfg definition introduces notions related statement level control flow graphs 
definition 
flow graph consists set statement nodes set directed control flow edges unique start node incoming arcs unique node outgoing arcs nodes reachable reachable nodes 
flow graph path sequence nodes path said non empty contains node non trivial contains nodes 
meaning clear context denote set nodes contained example write occurs sequence 
node dominates node written dom path start node passes note dominates relation reflexive 
node strictly dominates node dom 
node post dominates node written post dom path node node passes node strictly post dominates node post dom extracting cfg fcl program straightforward 
potential difficulty generating cfg satisfying constraints programs satisfy unique start node reachability properties required definition flowgraph 
easy restructure program generates flowgraphs properties assume restructuring done 
cfg write nodes set nodes block program said shared target jumps program test block shared loop block 
access code particular program points fcl program functions code def ref succ pred defined 
drop argument functions clear context 
ffl code map function code maps cfg node code statement labels 
program example code loop yields assignment 
ffl function maps label cfg node occurring block labeled example loop loop 
ffl function def maps node set variables defined assigned node singleton empty set ref maps node set variables referenced node 
example def loop ref loop mg 
ffl function succ maps node set nodes immediate successors node pred maps node set nodes immediate predecessors node 
examples succ test loop pred init fg 
semantics semantics fcl program expressed transitions program states oe cfg node identifier oe store mapping variables values 
series transitions gives execution trace statement level control flow graph 
example gives trace power program computing important note execution state oe code node executed 
intuitively code executed transition oe successor state oe 
gives simple operational semantics formalizes transition relation states 
top gives big step style semantics definitions expression assignment jump evaluation 
intuition rules constructs follows 
init 

result 
gamma 
init 

result 
gamma 
test 

result 
gamma 
loop 

result 
gamma 
loop 

result 
gamma 
loop 

result 
gamma 
test 

result 
gamma 
loop 

result 
gamma 
loop 

result 
gamma 
loop 

result 
gamma 
test 

result 
gamma 


result 
gamma 
halt 

result 
trace power program ffl oe expr means store oe expression evaluates value ffl oe assign oe means store oe assignment yields updated store oe ffl oe jump means store oe jump cause transition block labeled transition rules describe small step transitions caused assignment evaluation jump evaluation leading new block jump evaluation leading termination 
assume set node labels nodes fcl semantics contains distinguished node halt indicate terminal state 
evaluation program begins initial state oe init oe init initial store domain oe init set variables appearing gamma fx oe parameter oe values fcl 
presentation slicing section involves arbitrary finite non empty sequences states written pi write pi suffix starting pi 
execution trace state sequence pi constraints initial state halt oe oe gamma 
gamma 
consider finite traces corresponding terminating executions 
slicing techniques programs infinite traces handled bisimulation techniques propose presentation slicing multi threaded programs :10.1.1.43.1614
slicing program slices program slice consists parts program potentially affect variable values referenced program points interest 
program points interest traditionally called slicing criterion 
definition slicing criterion slicing criterion program non empty set nodes fn node statement flow graph 
example slicing power program respect slicing criterion loop yields program 
note assignments variables result declaration input parameter sliced away affect value line loop 
expressions assignments oe expr oe expr oe ng oe expr vn oe expr oe expr oe assign oe 
oe assign skip oe jumps oe jump goto oe jump return halt oe expr oe jump oe expr oe jump transitions oe assign oe oe gamma 
oe code successor oe jump oe gamma 
oe code oe jump halt oe gamma 
halt oe code semantic values values fcl oe stores fcl variables fcl values fcl nodes fcl states fcl nodes fcl theta stores fcl operational semantics fcl programs init init goto test init test loop test loop loop goto test loop return slice power respect criterion loop init 
gamma 
test 
gamma 
loop 
gamma 
loop 
gamma 
test 
gamma 
loop 
gamma 
loop 
gamma 
test 
gamma 

gamma 
halt 
trace sliced power program addition block init trivial removed post processing phase 
presents trace sliced program analogous trace source program initial value traces 
various notions slice slicing criterion differ application slicing techniques 
notion slicing described referred backward slicing algorithm starts criterion nodes looks backward program control flow graph find program statements influence execution criterion nodes 
forwards slicing works opposite direction looks forward control flow graph program statements criterion nodes influence 
backwards slicing appropriate notion applications interested finding portions program influence program features mentioned specification 
settings slice required executable program cases slice just set nodes cfg dependence information graphically displayed debugging applications 
cases slicing literature desired correspondence source program slice formalized emphasis applications foundations leads subtle differences presentations 
notion correct slice stated notion projection 
informally arbitrary trace pi analogous trace pi correct slice projecting nodes criterion variables referenced nodes pi pi yields identical state sequences 
instance projecting node loop variables ref loop traces figures yields state sequence loop 
loop 
formalize notions oe denote restriction domain oe variables definition projection follows 
definition projection program set nodes cfg 
projection function traces defined induction length traces follows delta delta oe sk ae oe ref sk sk delta represents empty sequence 
formalize notion program slice 
definition program slice program associated cfg slicing criterion program called residual program slice respect initial store oe init execution traces pi pi pi execution trace init oe init pi execution trace init oe init init init start nodes respectively pi pi example criterion loop pi pi execution traces figures respectively 
pi pi loop 
loop 
notable exception lack formalization large body horwitz reps members wisconsin slicing project 
approach taken wisconsin group summarized section 
computing slices program dependences program slicing criterion programs correct slices respect fact trivial slice course goal construct small slice possible weiser notes problem finding statement minimal slice 
starting slicing criterion fn computing slice involves finding nodes statements nodes depend 
nodes referred relevant nodes 
relevant variables variables defined referenced relevant nodes 
slicing literature constructing set relevant nodes performed stages 
stage builds program dependence graph pdg captures various dependencies nodes control flow graph 
second stage nodes depend computing transitive closure dependences pdg respect section describe basic notions dependence appear slicing sequential programs data dependence control dependence 
data dependence related notion reaching definition node data dependent node variable referenced definition assignment reaches node depends node assignment influence value computed definition data dependence node data dependent program written dd arrow pointing direction flow variable 
exists non trivial path cfg node gamma fm ng def 
def ref 
example power program loop data dependent init definition result init reaches result line loop 
control dependence information identifies conditionals may affect execution node slice 
definition control dependence node control dependent program written cd 
exists non trivial path cfg node gamma fm ng post dominated 
strictly post dominated node control dependent immediate successors cfg conditional paths connect unique node contains 
example power program loop loop loop control dependent test post dominates test 
program define relation respect union relations defined respect union dd cd 
pdg consists nodes cfg edges formed relation 
example presents pdg power program 
constructing slice pdg approach slicing constructing program slice proceeds finding set nodes sc called slice set cfg nodes reachable 
addition nodes sc residual program contain nodes goto formed 
slicing literature additional nodes determined adding extra dependencies pdg having separate phase generate residual program sc adding nodes appropriate 
take approach 
control dependence data dependence init init test loop loop loop power program pdg slice set sc criterion defined terms transitive closure dependence relations defined 
definition slice set slicing criterion program pdg slice set sc respect defined follows sc fm ng example power program loop sc loop test test node reachable loop dependence power program pdg 
slice set sc definition informally summarizes residual program constructed 
intuition assignment sc appear residual program 
goto statements initially retained residual program goto sc removed post processing phase 
return statements appear residual program 
conditional sc node sc control dependent 
doesn matter execution follows true branch false branch 
case replace condition jump point branches merge immediate post dominator 
property appendix establishes existence unique merge point 
process outlined yields residual program contains trivial blocks blocks containing assignments goto jump 
blocks may fact unreachable due specialization goto treatment assignment blocks 
trivial blocks removed final post processing phase 
definition residual program construction program slicing criterion resulting slice set sc residual program constructed follows 
ffl parameters parameter parameter iff ref def sc ffl blocks block form residual block label follows 
assignments skips assignment skip line identifier sc assignment appears residual block identifier node left residual program 
jumps jump goto return jump residual block identifier 
sc jump jump goto identifier label nearest block post dominating unique merge point paths leading 
ffl post processing trivial blocks unreachable blocks removed immediately contain nodes sc 
blocks contain nodes sc marked removable 
removable blocks block shared target jumps removed merging immediate predecessor successor 
important note conditional node replaced goto node identifier goto words node cfg code node changed slicing 
new nodes introduced slicing 
style presentation benefits simplifies proofs need establish correspondence source residual programs section introduces temporal logic propositions node identifiers simplifies reasoning correctness universe node identifiers grow program transformed 
prove correctness step approach slicing building slice set sc generating residual program helpful rephrase generation residual program terms series small slice steps step transforms removes single statement program 
definition defines valid slice steps program slicing criterion intuitively node computed slice set sc removed transformed yield reduced program derived criterion write simply write clear context 
intent slice generated definition reflexive transitive closure definition slice step slice set sc program derived steps 

assignment skip assignment sc obtained replacing assignment code node code skip skip ii 
skip removal gamma gamma skip block sc obtained replacing block labeled gamma gamma iii 
goto conditional sc obtained replacing condition jump node goto immediate postdominator omitting blocks unreachable initial block result changing jump code 
iv 
goto removal goto blocks block shared sc obtained replacing block labeled omitting block note assignment sc completely removed changing assignment skip rule removing skip rule ii 
similarly statement sc completely removed rule iii followed rule iv 
note code relative position node change slice step careful slice steps definition say removal parameters clause definition claim ps completely accurate 
step removing superfluous parameters obviously preserves execution trace semantics program ignore slight mismatch rest 
preserve unique identifiers node reasons definition residual program construction definition 
term slicing images cutting parts program steps definition clear transformation produced slicing best described program compression 
paths program compressed removing nodes influence computation nodes view slicing path compression central discussion model reduction section 
justify residual program generation definition series slice steps needs show certain invariants maintained step 
example case slicing criterion slice set sc slice set respect slicing criterion property slicing criterion sc slice set respect program properties holds 

nodes nodes sc nodes 

slicing criterion 
sc code code nodes nodes def def ref ref 

sc nodes dominates iff dominates 
nodes sc post dominated iff post dominated 
sc dd iff dd 
sc cd iff cd 
sc slice set respect proof see appendix lemma establishes correctness single slicing step 
lemma slicing criterion slice respect proof see appendix residual program construction definition phrased series slice steps theorem states constructed residual program correct slice 
theorem correctness slicing slicing criterion program residual program constructed wrt definition 
program slice defined definition 
proof see appendix note definition program slice definition predicated terminating executions source residual programs 
due fact virtually slicing algorithms literature slice away infinite loop relevant nodes loop example see discussion 
slicing may turn non terminating program terminating program 
authors additional notion dependence called divergence dependence ensure slicing preserves reflects program non termination properties 
essence node divergence dependent control predicate possibly infinite loop reachable combination divergence dependence control dependence essentially weak control dependence 
software model construction apply finite state verification software system construct finite state transition system safely abstracts software semantics 
transition system small automatic checking tractable large capture information relevant property checked 
bandera toolset uses slicing abstraction program specialization reduce size software models 
techniques orthogonal complimentary 
slicing removes program statements variables influence property 
reduces cardinality domains program variables removes infeasible execution paths 
model reduction steps need preserve information relevant choice slicing criterion domains driven program features program points variables mentioned property 
approach generate specialized model property checked 
experience generating single model adequate verifying wide range properties results large tractable checking 
give examples illustrate slicing model reduction 
reducing models slicing presents fcl rendering server process controls readers writers common resource 
due space constraints abbreviated unique node identifiers dropping label corresponding block 
example node identifier attempt write block abbreviates attempt write 
concurrent version system server process runs concurrently client processes requests start read read synchronization points control process 
fcl code requests program parameter reqs list values subrange 
assume interested checking property states variable writerpresent node start read reached section gives ltl formula property 
inspecting example program reasonably clear variable assignments irrelevant checking hand variables req activereaders relevant writerpresent mentioned assigned start write req activereaders appear test conditional controls access block start write 
slicing terms assignment writerpresent start write control dependent conditional attempt start write req activereaders 
variable req control dependent conditional block check reqs variable reqs 
presents result slicing example program property directed slicing algorithm section 
resulting slice conforms 
actual details constructing sliced program explained section 
second example consider property happens hold execution paths node req eventually reached section gives ltl formula property 
case point interest req control dependent conditional block check reqs variable reqs 
intuition tells variables influence reachability req 
presents result slicing example program property algorithm section 
absence variables reqs corresponds intuition 
reducing models slicing yields substantial reductions number possible value remaining data may lead intractable state space 
cases possible reduce dramatically cardinality program variable domains number possible values preserve information required check particular property 
idea tailor values associated variable property checked appropriate interpretation ai 
approach user declares certain program variables domain interpreting operations variable 
type inference attach domains reqs init init raise error req activereaders goto check reqs writerpresent goto check reqs check reqs null 
reqs return req req req car reqs reqs cdr reqs goto attempt start read attempt start read start read req activereaders writerpresent activereaders start read goto check reqs attempt read read attempt read activereaders req activereaders activereaders writerpresent read raise error attempt start write check reqs attempt start write start write req writerpresent activereaders goto check reqs writerpresent start write attempt write attempt write write req writerpresent writerpresent activereaders write raise error check reqs check reqs read write control example fcl reqs init init req activereaders writerpresent goto check reqs check reqs null 
reqs return req req req car reqs reqs cdr reqs goto attempt start read attempt start read start read req activereaders writerpresent activereaders start read goto check reqs attempt read attempt read read req activereaders activereaders activereaders read goto check reqs attempt start write attempt start write start write req writerpresent activereaders goto check reqs writerpresent start write attempt write attempt write write req writerpresent writerpresent goto check reqs write check reqs slice read write control program respect reqs init init goto check reqs check reqs null 
reqs return req req skip reqs cdr reqs goto check reqs slice read write control program respect remaining variables 
process combines interpretation partial evaluation creates residual program propagating values specializing program point respect values 
residual program concrete constants replaced constants 
residual program safely approximating finite state program fixed number variables defined finite domains 
program submitted toolset generates input existing model checking tools smv spin :10.1.1.41.863
approach applied verify correctness properties software systems written ada java :10.1.1.55.9390
general idea methodology choosing ai start simple ai throw information dataflow away incrementally refine ai information specification verified program 
steps methodology follows 

start point ai initially variables modeled point ai domain single value operations return 
effect throws away information variable value 

identify semantic features specification specification formula checked includes form propositions different semantic features program valuations specific program variables 
features modeled precisely ai hope checking property 
example formula includes proposition point ai ai capable distinguishing states non 
example ai zero pos abstraction natural numbers domain pos 
select controlling variables addition variables mentioned explicitly specification refined ai variables specification variables control dependent 
predicates controlling conditionals suggest semantic features modeled ai 
example specification variable control dependent conditional odd ai 
select variables broadest impact confronted multiple controlling variables model select appears conditional 
assume interested reasoning invariance property 
key features mentioned explicitly specification values variable writerpresent execution second line start read block 
point ai provide precision determine states writerpresent value zero 
writerpresent effect boolean variable representing false representing true effective ai writerpresent ftrue false point generate abstracted model check property consider additional refinements model choose illustrating example 
determine variables node start read nodes assignments writerpresent control dependent 
example variables writerpresent activereaders req 
modeling writerpresent req model external choice interactions control program input 
choose bind activereaders refined ai point 
conditional expressions involving variable activereaders activereaders choose zero pos ai 
shows abstracted program generated tools 
values assigned variables replaced associated abstractions discussed 
describe details program generated want illustrate natural number domain associated variable replaced small set abstraction tokens 
unanticipated feature non deterministic choose operator 
reqs abstracted point domain original test line check reqs decided replaced choose model constructor implement non deterministic choice destination blocks req 
addition top value associated reqs causes value computed req line req replaced non deterministic choice values associated sub range abstraction req 
property expansion analogous described partial evaluation literature trick 
abstracted program generated generate checkable model compiling input language model checker check property 
true result obtained sure property holds program finite state system models variables precision 
false result obtained examine counter example produced model checker 
may reveal true defect program may reveal infeasible path model 
case identify variables conditionals counter example path candidates binding precise ais 
finite state verification noted variety finite state verification techniques verify properties software 
presentation concrete consider single finite state verification technique model checking specifications written ltl 
ltl model checking reason properties wide range real software systems :10.1.1.35.104
linear temporal logic linear temporal logic rich formalism specifying state action sequencing properties systems 
ltl specification describes intended behavior system possible executions 
syntax ltl includes primitive propositions usual propositional connectives temporal operators temporal operator ffi omitted reasons explained 
propositional connectives temporal operators specifying properties software systems typically uses ltl formulas reason execution particular program points entering exiting procedure values particular program variables 
capture essence fcl primitive propositions 
rop ffl intuitively holds execution reaches statement unique identifier statement node executed 
call propositions form node propositions 
reqs init init req activereaders zero writerpresent false goto check reqs check reqs choose return req req req choose reqs top goto attempt start read attempt start read start read req activereaders pos writerpresent false goto check reqs start read attempt read attempt read read req activereaders activereaders zero choose zero pos read goto check reqs attempt start write attempt start write start write req writerpresent activereaders zero true writerpresent false goto check reqs start write attempt write attempt write write req writerpresent writerpresent true false write goto check reqs check reqs abstracted read write control example ffl intuitively rop holds value variable current node related relational operator rop rop 
call propositions form variable propositions 
ltl formula set primitive propositions appearing write nodes set cfg nodes mentioned node propositions vars set variables mentioned variable propositions semantics primitive proposition defined respect states 
oe ae true false rop oe ae true oe rop false semantics formula defined respect trace 
temporal operator requires argument true current state onward operator requires argument true point operator requires argument true point second argument true 
formally pi pi iff true pi rop iff rop true pi iff pi pi iff pi pi pi iff pi pi pi iff pi implies pi pi iff pi kg pi iff pi kg pi iff exists kg pi gamma pi specifications logic ranging simple complex :10.1.1.55.1098
ffl line reached block subsequently reached 
ffl line reached non zero 
ffl variable value execution 
ffl line reached subsequent step 
ffl time reached time reached reached twice 
multiple versions temporal operators appear literature 
semantics defines conventional reflexive versions 
varying primitive propositions logic ltl describe wide range safety liveness properties systems 
example illustrates intuition stated property obscured syntactic complexity formula 
suggests form automated assistance needed constructing specifications extracting appropriate slicing criteria generating safe sliced models 
approach overcoming issue system temporal logic specification patterns developed dwyer corbett avrunin analogous software design patterns provide templates commonly specification structures :10.1.1.35.104
section addresses issue 
reducing models slicing section provided intuition slicing guided program features appearing property checked 
idea concrete 
program specification desire criterion extraction function extract extracts appropriate slicing criterion 
slicing respect yield smaller residual program preserves reflects satisfaction little irrelevant information possible 
requirement expresses condition 
requirement ltl preserving extract program specification extract result slicing respect initial store oe init execution traces pi pi pi execution trace init oe init pi execution trace init oe init init init start nodes respectively pi iff pi possible define criterion extraction function slicing algorithm similar section earlier version compact models generated slightly modifying definition slicing criterion residual program construction obtain call proposition slicing 
proposition slicing criterion consider technical points guide modifying presentation slicing defining appropriate extraction function 
stated want preserve satisfaction formula remove irrelevant information original trace pi possible 
discussed situation certain variables values eliminated states trace pi influence satisfaction formula pi 
explain reduction general terms 
consider trace pi gamma assume state transition influence satisfaction 
formally pi iff pi pi compressed trace transition compressed pi gamma view change pi pi action ff causes change gamma action ff causes change combined action ff moves gamma intuitively formula doesn need know intermediate state example irrelevant transition assignment irrelevant variable transition nodes mentioned 
technical justification identifying compressible transitions purely syntactic examination propositions formula 
answer lies fact temporal operators treating state transitions don change satisfaction primitive propositions formula influence satisfaction 
means justify trace compressions reasoning single transitions satisfaction primitive propositions 
see property hold includes temporal operators state operator ffi 
formalize notions 
definitions give form proposition invariance respect particular transition 
definition ffl equivalent primitive proposition states 
said equivalent written jp write jp jp ffl stuttering transition primitive proposition pi gamma transition said stuttering jp set primitive propositions proposition transition stuttering transition said stuttering 
definition stuttering compression set primitive propositions 
pi gamma trace stuttering 
write pi pi pi obtained pi compressing stuttering transition removing 
pi pi pi pi pi pi defined follows pi gamma pi gamma lemma states satisfaction formula containing primitive propositions invariant respect compression stuttering steps 
lemma formula set primitive propositions appearing 
traces pi pi pi pi pi iff pi lemma fails includes state operator ffi semantics ffi iff example consider trace pi oe oe oe oe proposition note pi oe 
oe stuttering false states compressing transition obtain pi oe oe oe preserve satisfaction formula pi 
intuitively state operator allows count states attempt optimize compressing transitions setting problematic 
solutions proposed 
number researchers suggest dropping operator altogether done 
example systems spin guarantee semantics ffi preserved optimizations partial order reductions 
modified operator parameterized certain set actions 
allows states compressed implement action set 
dams gives nice overview issues 
consider equivalence relation generated definition equivalence set primitive propositions 
define smallest relation satisfying rules 
pi pi implies pi pi basis pi pi reflexivity pi pi implies pi pi symmetry pi pi pi pi implies pi pi transitivity lemma generalizes lemma stuttering equivalent traces 
lemma formula set primitive propositions appearing 
traces pi pi pi pi pi iff pi formula set propositions want modify slicing algorithm define extraction function guarantees transitions stuttering preserved residual program traces 
presents small example illustrates issues related variable node propositions 
consider slicing source program specification notice specification hold source program reached line value greater 
ffl variable propositions rop observe definitions variable may cause variable change value 
specifically cfg node assigns transition exiting guaranteed stuttering 
suggests proposition rop specification node assigns included residual program 
lines included sliced program 
ffl proposition entering exiting cfg node cause proposition change value cause transition non stuttering 
furthermore proposition satisfaction independent actual code node suggests node kept slice assignment conditional node may reduced skip goto respectively slice depends 
imagine need slice include modified node proposition formula 
possible slicing compress intermediate nodes cause removal non stuttering step associated entering leaving node 
example approach suggested removes assignments irrelevant variables lines changes assignment skip yielding naive slice center 
specification holds naive slice hold source program subformula trivially satisfied state true holds 
satisfaction specification preserved non stuttering transition compressed set propositions 
transition exiting line non stuttering changes false true 
transition entering line non stuttering source program naive incorrect slice goto return skip goto return correct slice skip skip goto return preserving non stuttering transitions changes false true 
non stuttering transitions replaced transition naive slice 
generation naive slice justified lemma 
transition line stuttering lemma justifies removing state associated 
correct slice slice preserves reflects satisfaction left program shown right 
concluding observations discussion follows 
observation 
variable proposition rop nodes assign included slice 
suggests slicing criterion contain nodes def 

node proposition syntax tree node identifier included slice actual code node may situations simplified skip goto 
simplifications variables referenced give rise extra dependencies possibly irrelevant variables cause slice larger necessary 
nodes slice treated differently nodes assign variables variable propositions notion slicing criterion modified include types nodes nodes statements slice nodes included code nodes may irrelevant 

node appearing node proposition treated additional care transitions nodes non stuttering 
particular avoid removing node doing cause immediately follow node containing assignment variable mentioned variable proposition node mentioned node proposition cause start node 
proposition node constraints enforced including slice nodes immediately precede control flow graph 
modified slicing algorithm motivated discussion modify notion slicing criterion provide different treatment required assignment statements required nodes 
definition proposition slicing criterion slicing criterion program pair sets nodes node statement flow graph 
ffl contains node identifiers criterion statements statements occur slice respect ffl contains node identifiers criterion nodes nodes occur slice respect slicing criterion write set criterion statements set criterion nodes abbreviate incremental program testing bates horwitz introduced notion control slice statements slicing criterion contribute slice control dependences 
notion exactly require criterion nodes motivated observation 
specifically order execution criterion nodes preserved slicing need preserve values variables mentioned criterion node node slice set 
modified definition slice set follows 
definition proposition slice set slicing criterion program pdg sets sc defined follows fm ng sc fm cd ng slice set sc respect defined sc sc criterion extraction function defined follows 
definition proposition extraction program specification set program variables occurring set nodes mentioned node propositions pred 
criterion defined follows 
ffl fn def ffl extract def notion slice step section revised take account types nodes criterion 
specifically steps retain nodes transform statements steps iii modified step node sc allows criterion node transformed dependencies caused appear slice set observation 
definition proposition slice step slice set sc program derived steps 

assignment skip assignment sc obtained replacing assignment node skip skip ii 
skip removal gamma gamma skip block sc obtained replacing block labeled gamma gamma iii 
goto jump sc obtained replacing condition jump node goto immediate postdominator omitting blocks unreachable initial block result changing jump code 
iv 
goto removal goto blocks block shared sc obtained replacing block labeled omitting block note node sc safe transform assignment node skip definition guarantees node sc data dependent 
similarly safe transform conditional goto definition guarantees node sc control dependent 
modification slicing step modify informal outline construction residual program 
definition proposition residual program construction program slicing criterion resulting slice set sc residual program constructed follows 
ffl parameters parameter parameter iff ref def sc ffl blocks block form residual block label follows 
assignments skips assignment skip line identifier sc appears residual block identifier skip appears residual block identifier node left residual program 
jumps jump goto return jump residual block identifier sc jump jump goto identifier label nearest block unique merge point paths leading 
ffl post processing trivial blocks unreachable blocks removed immediately contain nodes sc 
blocks contain nodes sc marked removable 
removable blocks block shared target jumps removed merging immediate predecessor successor 
conclude theorem justifies modified slicing algorithm ltl model compression theorem extraction function extract proposition slicing algorithm satisfies requirement 
examples example consider informally property section variable writerpresent node start read reached 
property expressed ltl follows start read writerpresent extract start read writerpresent yields criterion init start write write start read start read criterion statements assignments writerpresent criterion node set contains node start read mentioned formula immediate predecessor start read 
slicing example program respect modified slicing algorithm yields slice earlier 
slice identical original program variable block raise error disappear program 
detail irrelevant assignment node init removed 
previous conditional jumps read write raise error replaced unconditional jumps check req 
case slicing algorithm detected nodes raise error block irrelevant conditional jumps replaced unconditional jumps node true false paths leading conditionals meet 
control dependences force conditionals appear residual program 
addition post processing defined definition compress goto req compressed 
omitted results step connection source program clearer 
post processing compress remaining goto target shared block check reqs 
second example consider property section execution paths node req eventually reached 
property expressed ltl follows req extract yields criterion req check req criterion statements empty variables mentioned formula 
need force particular assignments included slice 
criterion node set contains node req mentioned formula immediate predecessor check req 
slicing respect criterion yields residual program earlier 
obvious residual program sufficient discovering req reachable reachable reqs initially empty list 
variables eliminated reqs appears test check reqs 
node check req retained appears conditional retained req control dependent control dependent 
addition slicing criterion dictates node req slice 
assignment node assign relevant variable assignment replaced skip 
assignment relevant variable reqs req appears residual program 
jump check reqs node req residual program result chaining series trivial goto post processing 
remaining goto check reqs compressed post processing check reqs shared 
observations avoiding compression non stuttering transitions approach including predecessors nodes mentioned key avoiding compression non stuttering transitions 
conservative solution may force inclusion additional nodes danger compressing non stuttering transition 
alternative sophisticated case approach employs additional context information identify obligatory nodes nodes sc appear residual program preserve non stuttering transitions 
proposition criterion program sc resulting proposition slice set node obligatory node program 
sc 
succ 
pred pred intuitively node obligatory slice set sc condition successor condition predecessor start node predecessor condition 
notice conditions match requirements observation 
definition place definition slice step definition residual program construction extended series special cases avoid removing obligatory nodes slice 
chosen take obligatory nodes approach presentation increases complexity slicing description correctness proofs 
entire issue artifact particular style specification logic granularity transition system model wishes expose user 
example uses action version ltl state version notion non stuttering transition appear alternate form require slightly different mechanism ensuring non stuttering transitions compressed 
addition approach software compiled models described model checker input languages single command source level method invocation broken different control states generated model 
realistic tool strategy avoiding non stuttering transition compression depends interprets control point propositions terms lower level model granularity control points finer 
slicing abstraction noted section contrast abstraction approaches reducing models ensure sound models slicing approach described generates reduced models sound complete respect temporal logic formula 
address issue detail 
specification program reduced program created conventional interpretation techniques specification holds source program holds contrast reduced program created slicing approach outlined holds source program holds weaker correspondence interpretation techniques stems approximate character data executions 
means executions usually contain additional branching encountered source program 
example section non deterministic branching introduced particular token activereaders variable block read decided 
reduced program approximate sense contain traces counterparts specification may fail hold due path infeasible situation referred practitioners false negative 
noted section model checking false negatives distinguished true negatives manual examination model checker counter example 
turn leads iteration model generation checking abstractions precise 
stronger correspondence slicing means matching execution trace trace sliced program false negatives produced slicing 
stems fact branching structure sliced program altered observable difference respect traversing conditional true false branch 
case believe multiple forms reduction including slicing abstraction optimizations needed successful model checking software 
impact slicing model checking implemented prototype slicing fcl programs capable producing example slices shown 
practical matter examples small illustrate effectively extent slicing reduce space time required model checking 
considering fcl examples section considers slicing model checking java program scaled slicer associated tools bandera tool set 
program consider multi threaded java program implements pipeline threads 
threads program main thread pipeline stages 
stages connected shared queues enable integer values passed stages 
pipeline operates having stage including main thread perform integer computation pass result connecting queue successive stage 
main thread passes value queue signal pipeline stages shut 
receiving shutdown signal stage pass signal stage shut 
illustrate effects slicing sets properties related correct shutdown pipeline stages 
set contains property denoted prop stage states main thread sends shutdown value stage eventually shutdown 
second set contains property denoted prop ii stage states stage shuts shutdown signal sent main thread 
sets properties contain types primitive actions main thread sends shutdown signal particular stage shuts 
actions correspond execution particular statements java source code 
stating primitive propositions line propositions form bandera tools allow user define symbolic names actions 
model property vars time sec reach 
states original prop slice prop slice prop slice prop slice prop abs slice prop abs slice prop abs slice prop abs slice prop original prop ii slice prop ii slice prop ii slice prop ii slice prop ii abs slice prop ii abs slice prop ii abs slice prop ii abs slice prop ii model checking results pipeline example assume action named shutdown corresponding sending main thread stage action named corresponding successful shutdown stage 
primitive actions property sets consist ltl formulae form prop shutdown prop ii shutdown shutdown shows data model checking properties models generated bandera version 
model checks performed spin mhz sparc ram running solaris 
data checking properties models generated original program program sliced property checked sliced program remaining queue variables abstracted classic signs interpretation domain fpos zero neg example model labeled slice produced slicing original program property prop ii model labeled abs slice produced abstracting sliced program signs abstraction 
original data properties ii listed table properties took space time 
case cost savings obtained slicing original program specification refers stage results primarily slicing away successive pipeline stages 
example slicing prop prop ii removes stages 
slicing prop prop ii successive stages remove 
size slice roughly size original program irrelevant variables removed 
cases generating slice takes second running entire model extraction pipeline including abstraction engine takes seconds 
included detailed times current implementation prototype timing results correspond carefully implemented system 
expanded discussion issues :10.1.1.29.3872
results single program small number properties clearly indicate performance improvement slicing provide model checking 
improvement achieved removal variables need modeled state transition system property reduction number program control points 
illustrated data abstraction yields additional improvement reducing size domains variables unable sliced program 
possible generalize small study feel results promising light realistic nature program properties considered 
study needed characterize breadth effectiveness slicing abstraction approach wider range model checking problems 
related program slicing developed technique simplifying programs debugging identifying parts programs execute parallel 
development concept slicing applied wide variety problems including program understanding debugging differencing integration testing 
pdg slicing horwitz reps members wisconsin slicing project developed large body foundations slicing 
program dependence graphs primary vehicle representing programs dependencies slicing transformations 
program statement level control flow graph graph data control dependencies provides information required drive slicing algorithm 
wisconsin pdg enhanced additional notions dependence giving ordering loop information pdg adequate representing programs call enhanced pdg distinguish pdg 
extra dependency information possible different programs isomorphic enhanced pdg 
example differ ordering set assignment statements dependencies exist nodes horwitz prins reps show programs isomorphic enhanced pdg strongly equivalent initial state halt final state diverge 
wisconsin group uses enhanced pdgs canonical representation programs correctness criteria slicing naturally liberal notion projection adopted 
specifically definition correct slice requires assignment statement sequence values assigned target variable predicate sequence boolean variables produced final value variable produced 
notion correctness slicing algorithms free rearrange order certain nodes intervening dependencies discussion set assignments 
correctness criteria require execution ordering observable nodes maintained 
projection correctness criteria slicing restricted collapsing paths removing irrelevant nodes program statement level control flow graph execution order observable nodes maintained 
liberal notion correctness particularly suited applications program differencing program integration ability rearrange code certain constraints 
hand application slicing preserve temporal relationships execution observable nodes enhanced pdg notion correctness permissive definition slicing correctness strong establish preservation satisfaction ltl formulas 
may possible reuse technical results adding additional dependencies enforce ordering require observable node execution 
reuse technical results hampered somewhat fact papers treat programs structured control flow language unstructured control flow 
study slicing programs unstructured control flow ball horwitz provide starting point reworking required technical results 
noted earlier proposition slicing presentation incorporates notion control slice introduced bates horwitz programs structured control flow 
slicing software artifacts slicing generalized software artifacts including attribute grammars requirements models formal specifications 
cimitile specifications define slicing criteria identifying reusable code legacy systems 
combination symbolic execution theorem proving process specifications derive slicing criteria 
slicing specialization touches relationship program specialization slicing 
slicing prelude specialization suggest abstraction specialization may reveal semantic features residual program syntax refined slicing criteria 
reps studied relationship different perspective 
show similar techniques equivalent slicing transformations achieved specialization vice versa 
slicing model reduction researchers studied slicing technique reduction systems state space purpose model checking temporal logic specifications 
teitelbaum study static slicing promela model description language model checker spin application model checking simulation protocol understanding 
emphasize imprecise slices give useful reductions model checking 
imagine establishing appropriate correctness results promela slicer conjunction slicing source code described 
chosen slice source code level dramatically reduce expense running tool components follow slicing interpretation lining model generation 
addition allows avoid building slicer model checking input language consider 
slicing phase model level yield reductions activities specialization lining easier determine statically portions model irrelevant 
clarke tool slicing vhdl programs dependence graphs 
pdg approach data control dependence new notion called signal dependence specific vhdl 
papers formalize correctness slicing methods establish connection ltl specifications generated slice 
believe formalization proof correctness slicing necessary intends slicing component sound model construction methodology 
model reduction techniques slicing viewed state space reduction technique number important theoretical practical differences reduction techniques appearing literature 
state space reduction preserve correctness respect specific class correctness properties 
contrast approach slicing criteria extracted formulae yields compressed traces contain state changes relevant propositions contained temporal logic formula 
slicing approach yields programs remain sound complete respect property checking 
sharp contrast abstraction techniques developed literature sacrifice completeness tractability :10.1.1.116.9247
significant progress developing algorithms data structures reduce model checking times obdds techniques seen complement slicing 
slicing removes variables system influence behavior checked model checker run faster regardless particular implementation techniques employs 
variation program slicing simple imperative language 
shown slicing criteria defined guarantee preservation model check semantics ltl specifications sliced program 
implemented prototype tool performs slicing experimented number examples 
scaling prototype handle significantly complex features programs including structured data treatment procedures multi threaded programs communicate shared data 
james corbett michael huth david schmidt provided illuminating discussions 
wish reviewers thorough helpful reviews 
olivier danvy deserves special patient careful editorial guidance 
control flow graph properties section contains properties control flow graphs extensively rest proofs 
rely notion minimal path control flow graph 
path node minimal exist path length smaller length clearly path exists minimal path note minimal paths unique may multiple minimal paths nodes property domination partial order domination relation nodes forms partial order reflexive anti symmetric transitive similarly post domination 
proof straightforward 
consider relationships exists dominators post dominators 
property nodes dominate dominates dominates exclusively similarly post domination 
proof 
assume dominates dominates exists path sm contain exists path sn contain initial arguments consider arbitrary minimal path arbitrary minimal path path show compares lengths paths arrive contradiction 
specifically paths equal length greater length 
imply assumption false dominates dominates assume path mq contain yields path sm mq contain contradiction dominates paths contain symmetrically paths contain mq path minimal length nq path minimal length assume mq nq equal lengths show leads contradiction 
paths contain minimal path mq contain strict subpath strict path nq length nq case nq shorter nq nq minimal nq longer nq mq minimal 
existence nq strict subpath mq contradicts assumption mq nq equal lengths 
assume mq greater length nq show leads contradiction 
paths contain minimal path nq contain path mq length mq strict subpath 
contradicts assumption mq greater length nq symmetric reasoning assuming nq greater length mq leads contradiction 
minimal paths mq nq equal length greater length contradicts existence minimal paths 
assuming dominates dominates leads contradiction 
dominates dominates fact domination relation anti symmetric property shows 
symmetric proof establishes property post domination 
corollary nodes nodes set nodes dominate domination relation imposes total order similarly post domination 
proof property establishes domination relation partial order property shows relation total property justifies selection unique immediate post dominator slicing step removal conditional slice set 
states nodes unique node nearest post dominator property nodes nodes exists unique node nodes post dominates post dominator post dominated post dominators totally ordered 
proof set post dominators intersection post dominators 
non empty node post dominates singleton property satisfied 
assume singleton 
result follows corollary 
property node nodes conditional target nodes nodes 
immediate post dominator proof assume show leads contradiction 
non cyclic path node path exist node reachable nodes 
mt 
case post dominator contradicts assumption non cyclic 
property nodes nodes totally ordered domination dominates post dominates dominates post dominates paths go case domination considered paths contain case post domination considered 
proof contradiction 
assume path anti symmetry domination property dominates dominate exist path sm start node contain sm forms path contain violates assumption dominates proof post domination symmetric 
properties helpful reasoning effects control dependence constructing slice 
particular justifying slice step replaces conditional goto immediate post dominator conditional branches 
property states node post dominated transition lead node post dominated property nodes post dominated post dominated proof assume post dominated show leads contradiction 
post dominated path node contain edge path contain contradicts fact post dominated property generalizes previous property paths roughly node post dominated path post dominated property nodes post dominated path post dominated proof property applied pair successive nodes moving gives result 
property reflects essence control dependence roughly path nodes conditional path allows passed case control dependent passed moving post dominated 
property nodes path mn exactly conditions holds 
post dominated 
exists control dependent proof assume hold show hold case 
show hold 
assume post dominate starting working start node encountered post dominated eventually reach post dominated 
path note non trivial post domination reflexive post dominates node gamma fq ng post dominated post dominated strictly post dominated hold simultaneously property implies node strictly post dominated condition definition control dependence satisfied 
definitions domination post domination contain quantifications paths dominates iff paths start node pass definition property show quantification reduced non cyclic paths 
aid construction proofs 
definition non cyclic path path program non cyclic node nodes occurs twice property domination non cyclic paths nodes 
dominates iff paths start node contain similarly post domination 
proof fact dominates implies non cyclic paths contain immediate definition domination 
show non cyclic paths contain path contains proceed induction length may assume hypothesis holds paths shorter path non cyclic done 
contains occurrences node qq qq successors qq shorter path induction hypothesis contains contained proofs conventional slicing noted body data dependences tied strongly concept reaching definition stated explicitly 
definition reaching definition def ref nodes definition reaches exists non trivial path gamma fm ng def 
case said reaching path 
described nodes slice set sc relevant sc irrelevant 
proofs follow require sophisticated set notions associated relevant nodes 
helpful adopt terminology intuition concurrency theory consider execution relevant node observable action execution node sc unobservable silent 
definition introduces notions observable node non observable path non observable descendent 
definition terms arbitrary set xi nodes set xi instantiated sc proofs conventional slicing subset slice set proofs proposition slicing 
definition observables xi nodes 

xi said xi observable 

nodes path said xi non observable xi 

nodes 
node said descend xi non observably xi non observable path including trivial path definition note descend non observably xi 
stems discussion execution semantics section noted execution state node executed 
execution state moves observable action performed 
observable performed execution transitions node node note descend non observably xi trivial path 
intuition transition path observable action associated performed 
need consider non observable state transitions execution traces follow paths 
write oe xi gamma 
oe transition state oe oe xi 
similarly write oe xi gamma 
oe oe moves oe executing xi non observable nodes trace follows xi non observable path 
note cases may xi discussion previous paragraph 
definition introduces notion dependence closed set 
intuitively establish properties slice set sc dependence closed definition slice set 
definition dependence closed dd data dependence relation program set nodes xi nodes dd closed xi dd node nodes implies xi similarly cd 
set nodes xi nodes closed xi dd closed cd closed 
basic properties control dependence cd closed sets 
intuition state oe state oe slice stores oe oe agree relevant variables defined precisely definition sc executions may take different paths due different results executing conditionals sc executions join node sc reached 
properties establish situation post dominated post domination guarantees joining different execution paths 
furthermore execution paths joined non observable actions occuring 
property xi nodes cd closed nodes 
exists xi non observable path xi post dominates proof path trivial result immediate post domination reflexive 
assume path non trivial prove result contradiction 
assume xi post dominate non trivial xi non observable path xi xi non observable post dominate property exists cd xi closed xi contradiction observable supposedly non path property xi nodes cd closed nodes post dominates exists non trivial xi non observable path paths xi non observable 
proof contradiction 
xi non observable path assume observable path observable encountered non observable path property post dominated post dominated corollary implies exactly holds post dominated post dominated show case leads contradiction 
assume holds property paths go contradiction implies observable occurs supposedly non observable path assume holds post dominated path qe node furthermore initial assumptions exists path contain contradicts fact post dominated properties justify fundamental aspect treatment conditionals generating sliced program conditional slice set replaced goto immediate post dominator conditional true false branches 
property guarantees paths conditional immediate post dominator non observable paths cross node slice set nodes paths may safely removed program 
property xi nodes cd closed nodes conditional node target nodes immediate post dominator xi path xi non observable 
proof contradiction 
assume path observable observable occuring observable node encountered non observable path 
property post dominates property post dominates 
contradiction immediate post dominator having established basic properties control dependence turn data dependence 
data control dependence relations give backward information execution arrives node dependence relations tell nodes encountered earlier execution influence execution statement node notion execution forward proofs obviously state transition relation formalizes execution need definition captures forward information 
specifically set xi nodes dd closed need know node program variables store relied execution calculating statements xi 
variables said xi relevant eventually prove execution reaches oe execution reaches store oe xi oe oe agree variables xi relevant definition xi relevant nodes xi nodes dd closed program variable xi relevant node conditions hold 
xi ref 
exists node xi ref path gamma fmg def 
write xi set xi relevant variables node series properties describe set relevant variables changes moves cfg program proofs straightforward omitted 
property states defines variable xi relevant successor dependence closedness xi ensures xi 
property xi nodes closed program def xi xi 
closed set xi xi property shows relevant variables identical 
property xi nodes closed program xi xi xi 
want corresponding property xi 
contrast previous property xi define variable relevant implies variables relevant may relevant example variables referenced relevant variables relevant variable possibly defined relevant conditional property states variables relevant conditional performs definition 
contrast property xi different variables relevant moving branch conditional 
property xi nodes closed program xi xi xi gamma def 
property states sequence execution steps perform xi observable action set relevant variables start sequence steps sequence modifies contents relevant variable 
property unobservable path preserves relevant store segments xi nodes closed program nodes 
oe xi gamma 
oe oe oe xi xi 
place proofs relating slice steps defined definition 
proof shows slice step removes nodes removed node slice set 
proof property slice step adds node program slice step changes code particular node leaves program intact 
slice step ii removes single node program sc slice step iii remove multiple nodes program unreachable start node changing node sc goto jumps merge point branches 
property nodes removed paths leading conditional sc slice step iv removes single node sc proof shows slicing criterion slicing criterion proof property definition slice criterion set nodes slicing criterion nodes 
slice steps remove nodes program steps ii iv remove nodes contained sc definition sc sc nodes nodes slicing criterion proof shows code node change nodes slice set 
furthermore nodes code change new variable definitions added 
proof property noted slice step modifies nodes contained sc immediate code code nodes sc furthermore node modified slice step assignment changed skip conditional changed goto 
case satisfies constraints variable definitions stated property 
slicing step preserves domination relation nodes xi 
intuition consider successors node change moving take advantage fact successors don change nodes particular path path exist proof property give proof dominates implies dominates proofs reverse direction similar 
start nodes cfg respectively 
assume sc dominates show dominates property suffices show non cyclic path start node contains case slice step result immediate step removes nodes changes successor relation 
case slice step ii applied node sc skip note unique successor set predecessors 
edges cfg appear cfg edges consider case case predecessors definition control flow graph definition empty 
exist edge path case unique successor path dominates note sc sc follows consider cases non empty 
cases exists rt exist rt case rt moves edge edge transition path contain case rt decomposed follows rt non cyclic paths follows path dominates sc sc case slice step iii applied node sc conditional note node successors change step target nodes conditional immediate post dominator conditional goto target addition note removed step step remove nodes predecessors case nodes originally reachable predecessors definition cfg 
cases qt qt case qt edge transition path contain dominates case qt path decomposed follows qt non cyclic edge transition paths path intuitively path branch conditional merge point removed slice step 
sc property 
follows case slice step iv applied node sc goto note unique successor set predecessors 
edges cfg appear cfg edges consider case case predecessors definition control flow graph definition empty 
exist edge path case unique successor path dominates note sc sc follows consider cases non empty 
cases exists rt exist rt case rt moves edge edge transition path contain case rt decomposed follows rt non cyclic paths follows path dominates sc sc refers preservation post domination relation 
proof property similar proof preservation domination relation 
proof shows slice step preserves data dependence relation nodes slice set 
proof property give proof slicing step proofs remaining steps similar 
assume dd exists non trivial path node gamma fm ng def def ref 
show dd case slice step applied node assignment sc sc cases gamma fm ng gamma fm ng 
case gamma fm ng path code code dd case gamma fm ng path assignment changed skip change code add new definitions dd assume dd exists non trivial path node gamma fm ng def def ref 
show dd case slice step applied node assignment note sc sc cases gamma fm ng gamma fm ng 
case gamma fm ng path code code dd case gamma fm ng path form code code nodes skip assignment note definition data dependence defined gamma fm ng gamma fm ng 
assignment define definition reach causing dd turn imply sc contradicts application slicing step 
dd need show slice step preserves control dependence relation nodes slice set 
examination definition control dependence definition reveals needs property post dominators 
property slicing criterion sc non trivial path nodes gamma fm ng post dominated iff non trivial path nodes gamma fm ng post dominated proof property assume non trivial path nodes gamma fm ng post dominated show exists non trivial path nodes gamma fm ng post dominated proof property simplify proof reducing problem non cyclic paths 
simply disallow cyclic paths need allow case conditional control dependent 
path nodes gamma fm ng post dominated clear exists path nodes post dominated non cyclic 
intuitively obtained short circuiting cycles path sufficient showing existence corresponding path proof assume non cyclic refer cycle assumption 
case slice step result immediate step removes nodes changes successor relation 
case slice step ii applied node sc skip note unique successor due syntactic properties fcl predecessor set predecessors 
edges cfg appear cfg edges edge note sc sc sc properties hold 
ffl node followed 
ffl non empty 
empty start node assuming contradicts assumption follows 
concluded furthermore violate cfg property start node predecessors 
ffl node non 
cases exists exist case arguments immediately occur followed qt occur moves edge edge implies edge transition path case decomposed follows cycle assumption paths follows rt path note removed obtain sc node gamma fm ng post dominated property node gamma fm ng post dominated case slice step iii applied node sc conditional note node successors change step target nodes conditional immediate post dominator cases qt qt 
case qt edge transition path case qt sc sc 
sc occur property 
decomposition note empty cycle assumption edge transition paths path qt note sc node gamma fm ng post dominated property node gamma fm ng post dominated case slice step iv applied node sc goto note unique successor set predecessors 
edges cfg appear cfg edges edge note sc sc sc properties hold 
ffl node followed 
ffl non empty 
empty start node assuming contradicts assumption follows 
concluded furthermore violate cfg property start node predecessors 
ffl node non 
cases exists transition exist transition case arguments immediately occur followed qt occur moves edge edge implies edge transition path case decomposed follows cycle assumption paths follows rt path note removed obtain sc node gamma fm ng post dominated property node gamma fm ng post dominated assume exists non trivial path nodes gamma fm ng post dominated show non trivial path nodes gamma fm ng post dominated simplify proof reducing problem non cyclic paths assume non cyclic refer cycle assumption 
case slice step result immediate step removes nodes changes successor relation 
case slice step ii applied node sc skip note unique successor due syntactic properties fcl predecessor set predecessors 
edges cfg appear cfg edges cases exists rt exist rt case rt moves edge edge transition path property nodes post dominated case rt decomposed follows rt cycle assumption rt rt paths follows path assumption nodes fr tg gamma fm ng post dominated property nodes fr tg gamma fm ng post dominated post dominated property 
nodes gamma fm ng post dominated case slice step iii applied node sc conditional note node successors change step target nodes conditional immediate post dominator cases qt qt case qt edge transition path property nodes gamma fm ng post dominated case qt sc sc 
decomposition qt note empty cycle assumption edge transition paths follows exists path non 
nodes gamma fm ng post dominated property nodes fq tg gamma fng post dominated empty non empty begins definition slice step iii post dominated non property nodes post dominated post dominated transitivity post domination nodes post dominated nodes gamma fm ng post dominated case slice step iv applied node sc goto note unique successor set predecessors 
edges cfg appear cfg edges cases exists rt transition exist rt transition case rt moves edge edge transition path property nodes gamma fm ng post dominated case rt decomposed follows rt cycle assumption edge transition paths path nodes gamma fm ng post dominated property nodes fr tg gamma fm ng post dominated post dominated property post dominated nodes gamma fm ng post dominated property fact slice step preserves reflects post domination property show slice step preserves reflects control dependence 
proof property slicing criterion sc assume cd show cd cd exists non trivial path nodes gamma fm ng post dominated strictly post dominated post dominated 
property exists non trivial path nodes gamma fm ng post dominated furthermore strictly post dominated property strictly post dominated cd showing cd implies cd symmetric steps 
data control dependence preserved reflected slice step slice sets respect identical proof property slicing criterion property slicing criterion sc sc slice set respect respectively 
show sc sc 
assume sc show sc 
sc exists properties data control dependencies preserved slice step sc 
proof showing sc implies sc follows pattern reasoning 
property shows strong relation paths original program resulting slice 
property showing slice step preserves reflects set relevant variables node 
property slice step preserves paths slicing criterion nodes nodes sc exists non trivial path iff exists non trivial path nodes gamma sc proof proof extracted reasoning proof property 
simple property relating start nodes property slicing criterion start nodes respectively 
descends sc property states set relevant variables node sc property slice step preserves relevant variables slicing criterion sc slice sets respect nodes nodes nodes rsc rsc 
proof showing rsc implies rsc follows cases reasons rsc 
showing rsc implies rsc similar 
ready final set properties describe execution traces source residual programs related 
remainder section abbreviate observable observable 
notions related observables indexed sc abbreviated similar fashion 
programs property addresses situation execution sequences observable node stores agree relevant variables 
node executing node node node descends note allows 
intuition slice step may removed node sc producing transitions node successor source program 
property slicing criterion sc stores oe oe oe rs oe nodes oe gamma 
oe iff nodes oe gamma 
oe descends oe oe rsc rsc 
proof note sc code code 
assume oe gamma 
oe show oe gamma 
oe appropriate constraints stores oe oe proof proceeds cases type code node case code note assignment unique successor unique successor sc ref rsc definition 
oe rs oe follows oe ref oe exists oe expr oe expr oe gamma 
oe oe gamma 
oe oe oe 
oe oe 

rsc rsc gamma fxg property oe rs oe oe rs oe follows oe 
rs oe 

need show non observable descendent done trivially non observable descendent definition 
sc removed performing slice step ii skip removal iv goto removal steps change successor relation assignment statement node 
case unique successor non observable descendent property rsc rsc 
case code skip similar case 
case code reasoning case assignments exists oe expr oe expr cases control transferred control transferred 
reasoning cases identical consider 
oe gamma 
oe oe gamma 
oe oe oe oe oe def rsc rsc property oe rs oe implies oe rs oe done trivially non observable descendent definition 
sc removed performing slice step ii skip removal iv goto removal steps remove node block block 
case successor non observable descendent property rsc rsc 
case code goto similar case 
case code return immediate return modify store set relevant variables empty halt 
showing oe gamma 
oe implies oe gamma 
oe appropriate constraints stores oe oe follows pattern reasoning 
property addresses situation execution sequences unobservable nodes stores agree relevant variables 
respective execution sequences joined node point sequences may taken separate non observable paths leading respectively 
guaranteed executions eventually coincide observable node reached 
property slicing criterion nodes sc nodes non observable descendents stores oe oe oe rs oe oe heads terminating execution trace oe heads terminating execution trace oe oe sc gamma 
oe iff oe oe sc gamma 
oe oe rs oe proof assumptions property oe sc gamma 
oe show oe sc gamma 
oe appropriate constraints oe oe want show execution oe lead oe 
descends descends descends property post dominated want show post dominated done post domination reflexive definition 
assume descends path mq mq observable post dominated mq property post dominated property post dominated oe heads terminating evaluation node eventually reached oe 
addition need show reached oe executing observable node node sc 
descends paths unobservable property 
means paths unobservable 
property sc sc exists path nodes unobservable 
property paths unobservable 
oe sc gamma 
oe 
need show constraints stores satisfied 
consider execution descends rsc rsc property applied repeatedly path oe sc gamma 
oe property entails oe oe rsc rsc 
consider execution descends rsc rsc property applied repeatedly path property rsc rsc 
oe sc gamma 
oe property oe oe rsc rsc rsc rsc 
property rsc rsc 
initially assumed oe rs oe putting previous constraints stores relevant variables oe rs oe proof oe sc gamma 
oe implies oe sc gamma 
oe similar 
show traces related sc projections 
intuitively means executions match observable nodes 
lemma slicing criterion nodes nodes non observable descendents stores oe oe oe rs oe oe heads terminating execution trace pi oe heads terminating execution trace pi pi pi proof induction number observable nodes pi 
case pi empty sequence 
follows pi empty sequence 
assume exists sc oe sc gamma 
oe 
property oe sc gamma 
oe pi contains oe contradicts fact pi contains observable nodes 
case exists sc oe sc gamma 
oe gamma 
oe gamma 
halt oe halt property property applied trace oe sc gamma 
oe gamma 
oe gamma 
halt oe halt oe rs oe oe rs oe descends pi trace oe pi oe 
pi contains observable pi induction hypothesis pi pi 
ref rsc definition property code code sc ref ref oe ref oe oe pi oe pi definition 
trace pi contains observables trace pi contains observables pi pi 
ultimately need show traces related sc projections projections 
follow immediate lemma property 
property shows traces related sc projections sc traces related projections 
property slicing criterion sc pi execution trace pi execution trace 
pi pi implies pi pi proof simple induction length pi 
proof lemma states slice respect proof lemma referring definition lemma slicing criterion program oe initial store follows oe initial store initial nodes respectively 
pi finite execution trace running oe pi finite execution trace running oe 
immediate oe rs oe property descends lemma pi pi property pi pi need explicitly state series slice steps obtain residual program constructed definition 
property slicing criterion program residual sliced program yielded definition 
proof examination definition relying property components 
proof correctness slicing 
proof theorem referring definition theorem slicing criterion program sc corresponding slice set residual program constructed definition 
oe arbitrary initial state pi terminating execution trace oe start node pi terminating execution trace 
property induction number slice steps applying lemma step pi pi 
slice respect proofs proposition slicing proofs lemmas form foundation justifying correctness property preserving slicing slicing property primitive propositions show source program trace pi sliced program generates stuttering equivalent trace pi vice versa 
proof lemma correctness stuttering step compression second lemma correspondence stuttering step equivalent traces 
proof lemma structural induction 
proof proceeds showing pi iff pi pi iff pi 
follows pi iff pi iff pi 
case show pi iff pi 
case definition pi iff true 
pi gamma true iff pi terms trace semantics 
pi pi pi iff pi 
case pi pi iff true pi pi iff true definition 
stuttering follows true iff true 
pi iff pi 
show pi iff pi 
definition pi iff true 
pi gamma pi iff true definition 
pi pi pi iff pi 
case rop similar case 
case show pi iff pi induction hypothesis pi iff pi definition pi iff pi pi iff pi pi iff pi show pi iff pi induction hypothesis pi iff pi definition pi iff pi pi iff pi pi iff pi case follows directly induction hypothesis manner similar case case follows directly induction hypothesis manner similar case case follows directly induction hypothesis manner similar case case show pi iff pi show pi implies pi assume pi definition pi ng 
note length pi gamma 
need show gamma pi case ig pi pi pi pi pi derived pi removing state stuttering transition induction hypothesis pi case fi gamma pi pi assumption pi pi gamma pi show pi implies pi assume pi definition pi gamma need show ng pi case ig pi pi pi pi pi derived pi removing state stuttering transition induction hypothesis pi case fi ng pi pi gamma assumption pi gamma pi ng pi show pi iff pi similar proof 
case show pi iff pi show pi implies pi assume pi definition pi ng 
note length pi gamma 
need show exists gamma pi case ig pi derived pi removing state stuttering transition induction hypothesis pi exists ig pi case fi ng case pi gamma pi assumption pi pi gamma exists fi gamma gamma pi exists gamma pi show pi implies pi assume pi definition pi gamma need show exists ng pi case ig case pi derived pi removing state stuttering transition induction hypothesis pi exists ig pi case fi gamma pi pi assumption pi pi exists fi ng pi exists ng pi show pi iff pi similar proof 
case show pi iff pi show pi implies pi assume pi definition exists ng pi gamma pi show exists gamma pi gamma pi proof proceeds cases case ig note pi derived pi removing stuttering transition induction assumption pi take note gamma pi derived pi removing stuttering transition induction hypothesis gamma pi case fi ng pi pi gamma gamma pi ig pi derived pi removing stuttering transition induction hypothesis pi fi gamma pi pi note gamma gamma gamma 
assumption pi pi gamma pi show pi implies pi assume pi note length pi gamma 
definition exists gamma pi gamma pi show exists ng pi gamma pi proof proceeds cases case ig note pi derived pi removing stuttering transition induction assumption pi take note gamma pi derived pi removing stuttering transition induction hypothesis gamma pi case fi gamma pi pi pi ig pi derived pi removing stuttering transition induction hypothesis pi fi gamma pi pi gamma note gamma gamma gamma 
assumption pi gamma pi gamma pi show pi iff pi similar proof 
proof lemma proof induction derivation pi pi applying lemma 
consider simple transformation stuttering equivalent traces 
reasoning local program transformations slicing step 
property allows change control point trace nodes node propositions 
sliced program travels different path original program paths non observable irrelevant property 
property allows change contents irrelevant variable point trace 
sliced program omits assignment irrelevant variable original program 
property unobservable effects transformation formula set primitive propositions appearing 

matching proposition nodes variables imply equivalent states oe oe states ffl nodes nodes implies ffl oe vars oe oe jp oe 

equivalent states transformation traces pi oe oe oe pi oe oe oe oe jp oe pi pi proof component need show oe oe 
consider case 
oe holds assumptions states follows oe holds 
showing oe implies oe symmetric 
establishing case rop straightforward 
second component consider trace pi oe oe oe oe pi pi transition oe oe stuttering 
reasoning pi pi pi pi symmetry transitivity property states traces observable actions start equivalent states stuttering equivalent 
property observables implies equivalence specification program primitive propositions occuring 
pi pi non empty finite traces pi oe oe pi oe oe oe vars oe oe pi oe vars oe nodes oe pi oe vars oe nodes 
pi pi proof transition pi pi stuttering 
pi pi compressed state pick state trace removing stuttering transitions pi oe pi oe repeated application lemma 
single states remaining compressed trace equivalent oe jp oe property 
pi pi property says heads tails stuttering equivalent traces equivalent 
proof immediately property property 
property stuttering equivalent traces heads tails specification program primitive propositions occuring 
pi pi jp 
pi pi jp proof component proof proceeds straightforward induction derivation stuttering equivalent traces 
property establishes conditions allow pairs stuttering equivalent traces conjoined 
proof lemma show complete execution trace source program stuttering equivalent complete execution trace residual program subsections traces stuttering equivalent 
property conjoining stuttering equivalent traces specification program primitive propositions occuring 
pi pi pi pi jp jp jp pi pi pi pi fs proof proof proceeds induction length derivations pi pi pi pi turn reworking proofs section handle proposition slicing 
property proposition criterion sc resulting proposition slice set program sc cd closed sc sc definition 
proof proof follows immediately definition proposition slice set definition dependence closedness 
property proposition criterion sc resulting proposition slice set program sc closed 
proof proof follows immediately definition proposition slice set definition dependence closedness 
proofs refer set sc closed slice set written program respect slicing criterion introduce alternate notion observable path relevant reasoning 
idea consider nodes sc 
execution order nodes preserved slice play lesser role nodes slice set relevant node control dependent data dependent 
notion unobservable path relaxed allow quasi observable nodes head path 
definition quasi observables proposition slicing criterion program 
nodes path said sc quasi non observable trivial path sc 
nodes 
node said descend sc quasi non observably sc quasi non observable path including trivial path due alternate notion observable modified versions basic properties control dependence observable nodes 
property analogue property 
property generalizes directly sc quasi non observable paths initial node paths sc node control dependent 
executions proceed different paths preserve slice semantics 
property nodes proposition slicing criteria sc resulting slice set 
exists sc quasi non observable path sc proof result immediate post domination reflexive 
assume prove result contradiction 
assume xi post dominate xi non observable path sc xi non observable post dominate property exists cd definition sc contradicts implications sc quasi non observable contradicts implication may contradicts implication contains nodes sc property analogue property 
property nodes post dominated proposition slicing criteria sc resulting slice set 
exists non trivial sc quasi non observable path paths sc quasi non observable 
proof similar proof property 
property analogue property 
property proposition slicing criteria sc resulting slice set nodes conditional node target nodes immediate post dominator path sc quasi non observable 
proof similar proof property 
turn issue unique notion control slice 
control dependence reflexive possible conditional control dependent 
intuitively conditional node control dependent controls loop path mm represents path body loop 
consider case nodes loop body sc definition control slice appear loop sliced away changing conditional goto 
loop may executed times original program preserve notion projection loop sliced away executed residual program 
property establishes loop preserved slice mm control dependent property proposition slicing criteria exists path mm possibly empty sc proof note contradicts assumption contains nodes sc definition cfg path nodes node conditional path successor post dominated node reachable working backwards conditional encountered 
note case successor post dominated strictly post dominated trivially post dominated 
um subpath mm nodes um gamma fu mg post dominated conditional satisfying conditions 
control dependent implies contains nodes sc case property criterion node conditional specification program primitive propositions occuring extracted slicing criterion 
nodes conditional successors nodes proof path mm empty property 
reasoning entails property cases control dependent case control dependent nodes definition proposition slice set control dependent case post dominated property post dominated done 
show assume show leads contradiction 
post dominated immediate post dominator property paths sc quasi non observable 
non cyclic path note node call predecessor definition criterion extraction 
sc quasi non observable empty sc path mm 
property follows contradicts assumption conclude property analogous property gives invariants maintained proposition slice step 
proofs omitted similar property 
property specification program primitive propositions occuring extracted slicing criterion 
program properties holds 

nodes nodes sc nodes 

slicing criterion 
code code nodes nodes def def ref ref 

sc nodes dominates iff dominates 
nodes sc post dominated iff post dominated 
sc dd iff dd 
sc cd iff cd 
sc slice set respect property analogous property shows path source program nodes sc corresponding path residual program projection respect slice set 
property proposition slice step preserves paths specification program primitive propositions occuring extracted slicing criterion 
program nodes nodes sc exists non trivial path iff exists non trivial path nodes gamma sc proof similar proof property 
property analogous property relates start nodes property specification program primitive propositions occuring extracted slicing criterion 
start nodes respectively 
descends sc proof identical proof property property analogous property states set relevant variables node sc property relevant variables preserved specification program primitive propositions occuring extracted slicing criterion 
sc slice sets respect nodes nodes nodes rsc rsc 
proof similar proof property 
property states slice step change predecessor relation node nodes 
useful trying establish non stuttering compressed 
intuitively node nodes occurs path know immediately preceding sc appear corresponding path slice step remove non stuttering transition nodes 
property predecessors preserved specification program primitive propositions occuring extracted slicing criterion nodes pred pred 
proof general scenarios may lead slice step changing predecessor relation node pred sc removed slice step ii skip removal pred sc removed slice step iv goto removal immediate post dominator branches conditional node conditional transformed goto slice step 
nodes definition criterion extraction sc disallows scenarios 
scenario break proof possible cases 
case non cyclic path un non empty assume show leads contradiction 
contradiction imply conditional changed goto slice step predecessor property un sc quasi non observable 
nodes predecessors contain pred contradicts fact un sc quasi non observable 
case non cyclic path un non empty property implies target true false branches conditional predecessor conditional transformed goto target goto immediate post dominator predecessor properties related data dependence appendix stated terms arbitrary closed set properties applied modification proposition slicing closed set need additional property stating values variables mentioned primitive propositions specification preserved sc quasi non observable executions 
property specification program primitive propositions occuring extracted slicing criterion nodes 
oe gamma 
oe oe vars oe proof path followed execution 
clearly assignment variable vars node cause oe vars oe definition criterion extraction node violates assumption nodes executed execution trace 
property specification program primitive propositions occuring extracted slicing criterion 
stores oe oe oe rs oe oe vars oe nodes oe gamma 
oe iff nodes oe gamma 
oe descends sc non observably oe oe oe vars oe pi pi pi pi traces 
proof assume oe gamma 
oe show oe gamma 
oe appropriate constraints stores oe oe proof proceeds cases type code node case code need show sc non observable descendent note assignment unique successor unique successor done trivially non observable descendent definition 
sc removed performing slice step ii skip removal iv goto removal steps change successor relation assignment statement node 
case unique successor sc non observable descendent show constraints oe oe satisfied 
property 
code code 
ref definition 
oe oe follows oe ref oe exists oe expr oe expr means oe gamma 
oe oe gamma 
oe oe oe 
oe oe 

gamma fxg property oe oe oe oe follows oe oe oe oe showing oe vars oe straightforward 
oe vars oe know vars gamma fxg oe oe oe oe 
furthermore reasoning relevant variable clear oe oe oe vars oe need show pi pi oe vars oe oe vars oe applying property twice gives pi oe oe oe oe oe oe pi sc nodes 
nodes leads contradiction nodes sc definition criterion extraction definition predecessor contradicts fact sc applying property gives pi oe oe oe oe oe oe pi case code skip similar case 
case code reasoning case assignments variables relevant oe oe 
exists oe expr oe expr cases control transferred control transferred 
reasoning cases identical consider 
oe gamma 
oe oe gamma 
oe oe oe oe oe def property oe oe implies oe oe done trivially sc non observable descendent definition 
sc removed performing slice step ii skip removal iv goto removal steps remove node block block 
case successor sc non observable descendent property 
showing oe vars oe trivial oe vars oe assumption oe oe oe oe need show pi pi oe vars oe oe vars oe applying property gives pi oe oe oe oe oe oe pi sc nodes 
nodes leads contradiction nodes sc definition criterion extraction definition predecessor contradicts fact sc applying property gives pi oe oe oe oe oe oe pi case code goto similar case 
case code return immediate return modify store set relevant variables empty halt 
showing oe gamma 
oe implies oe gamma 
oe appropriate constraints stores oe oe follows pattern reasoning 
property specification program primitive propositions occuring extracted slicing criterion 
gamma stores oe oe oe rs oe oe vars oe nodes oe gamma 
oe iff nodes oe gamma 
oe descend sc quasi non observably oe oe oe vars oe pi pi pi pi traces 
proof assume oe gamma 
oe show oe gamma 
oe appropriate constraints stores oe oe proof proceeds cases type code node case code showing descend sc quasi non observably note assignment unique successor gamma descends sc quasi non observably done 
sc removed performing slice step ii skip removal iv goto removal steps change successor relation assignment statement node 
case unique successor case sc sc non observable descendent sc quasi non observable descendent need show follows property sc quasi non observable non observable descendents property relevant variables preserved 
property applied oe oe 
property applied oe oe 
follows oe oe 
show oe vars oe initial assumptions oe vars oe assume vars show leads contradiction 
vars definition criterion extraction contradicts assumption def vars def vars code code skip 
values variables vars changed oe vars oe need show pi pi oe vars oe oe vars oe applying property gives pi oe oe oe oe oe oe pi sc nodes 
nodes leads contradiction nodes sc definition criterion extraction definition predecessor contradicts fact sc applying property gives pi oe oe oe oe oe oe pi case code skip similar case 
case code note descends sc quasi non observably property 
cases conditional unchanged slice step conditional transformed slice step goto 
case unchanged slice step code code obvious exists node oe gamma 
oe 
immediate descends sc quasi non observably furthermore 
code assignment oe oe oe oe oe oe immediate oe oe 
furthermore oe vars oe oe vars oe applying property gives pi oe oe oe oe oe oe pi cases successor successor successor successor case successor sc quasi non observable descendent reasoning case oe oe oe vars oe need show pi pi intuitively problem nodes vice versa 
consider case nodes nodes case symmetric 
property nodes case assumed contradicts initial assumption gamma nodes nodes 
property gives pi oe oe oe oe oe oe pi case successor removed slice step case removed slice step ii skip removal iv goto removal sc sc quasi unobservable descendent reasoning case oe oe oe vars oe need show pi pi intuitively problem nodes vice versa 
nodes imply sc contradicts fact removed slice step 
nodes implies predecessor definition extraction sc contradicts fact removed slice step 
nodes nodes 
showing pi pi proceeds case 
case successor successor second branch conditional branch case removed slice step ii skip removal iv goto removal sc sc quasi unobservable descendent reasoning case oe oe oe vars oe need show pi pi intuitively problem nodes vice versa 
nodes property contradicts initial assumption gamma implies sc contradicts assumption removed slice step 
nodes implies predecessor definition extraction sc contradicts fact removed slice step 
nodes nodes 
showing pi pi proceeds case 
case transformed slice step code goto immediate post dominator follows exists nodes take oe gamma 
oe 
need show descends sc quasi non observably follows immediately property 
implies descends non observably property repeatedly path code code assignment oe oe oe oe oe oe oe vars oe follows oe oe oe vars oe 
need show pi pi need show nodes nodes 
case nodes property implies successor branches jump block 
case immediate postdominator property gives pi oe oe oe oe oe oe pi case nodes assume nodes show leads contradiction 
nodes successor property imply assumed gammas assumed nodes 
successor path non empty 
predecessor definition extraction node sc contradicts fact descends sc quasi non observably nodes 
property gives pi oe oe oe oe oe oe pi case code goto similar case 
property specification program primitive propositions occuring extracted slicing criterion 
gamma nodes sc nodes non trivial sc quasi observable descendents stores oe oe oe rs oe oe vars oe oe heads terminating execution trace oe heads terminating execution trace oe oe sc gamma 
oe iff oe oe sc gamma 
oe oe rs oe oe vars oe pi pi pi pi traces 
proof assumptions property oe sc gamma 
oe show oe sc gamma 
oe appropriate constraints oe oe want show execution oe lead oe 
descends sc quasi descends descends sc quasi property post dominated furthermore path contains nodes sc property implies contradicts initial assumptions 
need show post dominated done post domination reflexive definition 
assume mq sc quasi unobservable path sc know mq property post dominated property post dominated oe heads terminating evaluation node eventually reached oe 
addition need show reached oe executing observable node node sc 
descends sc paths sc unobservable property 
means path sc unobservable 
property sc sc exists path nodes sc unobservable 
property paths sc unobservable 
oe sc gamma 
oe 
need show constraints stores satisfied 
consider execution descends sc quasi rsc rsc property applied repeatedly path oe gamma 
oe property entails oe oe rsc rsc 
consider execution descends sc quasi rsc rsc property applied repeatedly path property rsc rsc 
oe gamma 
oe property oe oe rsc rsc rsc rsc 
property rsc rsc 
initially assumed oe rs oe putting previous constraints stores relevant variables oe rs oe oe vars oe property applied pi pi gives oe vars oe oe vars oe oe vars oe need show pi pi case nodes predecessor pi traces sc unobservable path case predecessor length pi 
property pred pred pred pi traces sc unobservable path case length pi 
applying property gives pi oe oe pi case nodes path path sc unobservable nodes node nodes pi pi property pi pi proof oe sc gamma 
oe implies oe sc gamma 
oe similar 
property specification program primitive propositions occuring extracted slicing criterion 
sc nodes sc nodes sc unobservable descendents stores oe oe oe rs oe oe vars oe oe heads terminating execution trace oe heads terminating execution trace oe oe sc gamma 
oe iff oe oe sc gamma 
oe oe rs oe oe vars oe pi pi pi pi traces 
proof similar proof property 
show traces stuttering equivalent 
lemma specification program primitive propositions occuring extracted slicing criterion 
nodes nodes sc quasi non observable descendents stores oe oe oe rs oe oe vars oe oe heads terminating execution trace pi oe heads terminating execution trace pi pi pi proof proof proceeds induction number sc observable nodes pi follows structure lemma applying properties appropriate 
properties yields sub traces pi pi stuttering equivalent 
property glue stuttering equivalent traces 
slice step yields stuttering equivalent traces lemma know slice step preserves reflects satisfaction ltl specification 
hand proof theorem follows outline proof theorem induction number slice steps 
ball horwitz 
slicing programs arbitrary control flow 
fritzson editor proceedings international workshop automated algorithmic debugging volume lecture notes computer science 
springer verlag 
bates susan horwitz 
incremental program testing program dependence graphs 
conference record twentieth annual acm sigplan sigact symposium principles programming languages pages charleston south carolina january 
burch clarke mcmillan dill hwang 
symbolic model checking states 
proceedings fifth annual ieee symposium logic computer science pages 

process control design spin 
proceedings spin workshop october 
chang jh 
richardson 
static dynamic specification slicing 
proceedings fourth irvine software symposium april 

choi ferrante 
static slicing presence goto statements 
acm transactions programming languages systems 
cimatti giunchiglia traverso 
model checking safety critical software spin application railway interlocking system 
proceedings third spin workshop april 
cimitile de lucia munro 
identifying reusable functions specification driven program slicing case study 
keith bennett editors proceedings international conference software maintenance pages washington october 
ieee computer society press 
clarke fujita rajan reps shankar teitelbaum 
program slicing design automation automatic technique speeding hardware design simulation testing verification 
unpublished report computer sciences dept university wisconsin madison october 
clarke grumberg long :10.1.1.116.9247
model checking abstraction 
acm transactions programming languages systems september 
james corbett matthew dwyer john hatcliff shawn laubach corina pasareanu hongjun zheng :10.1.1.29.3872
bandera extracting finite state models java source code 
technical report kansas state university department computing information sciences 
corbett 
evaluating deadlock detection methods concurrent software 
ieee transactions software engineering march 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth annual acm symposium principles programming languages pages 
dennis dams 
interpretation partition refinement model checking 
phd thesis eindhoven university technology july 
dennis dams rob gerth orna grumberg 
interpretation reactive systems 
acm transactions programming languages systems march 
matthew dwyer john hatcliff 
slicing software model construction 
olivier danvy editor proceedings acm workshop partial evaluation program manipulation pepm january 
brics notes series ns 
matthew dwyer john hatcliff 
partial evaluation enable verification concurrent software 
acm computing surveys es september 
special issue dedicated symposium partial evaluation 
matthew dwyer corina pasareanu 
filter model checking partial systems 
proceedings sixth acm sigsoft symposium foundations software engineering november 
appear 
matthew dwyer corina pasareanu 
model checking generic container implementations 
technical report kansas state university department computing information sciences 
matthew dwyer corina pasareanu james corbett 
translating ada programs model checking tutorial 
technical report kansas state university department computing information sciences 
dwyer avrunin corbett :10.1.1.35.104
patterns property specifications finite state verification 
proceedings st international conference software engineering may 
appear 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 
godefroid wolper 
partial orders efficient verification deadlock freedom safety properties 
proceedings second workshop computer aided verification pages july 
carsten gomard neil jones 
compiler generation partial evaluation 
ritter editor information processing 
proceedings ifip th world computer congress pages 
ifip north holland 
john hatcliff 
partial evaluation simple flowchart language 
john hatcliff peter thiemann torben mogensen editors proceedings diku international summer school partial evaluation number appear tutorials computer science copenhagen denmark june 
john hatcliff james corbett matthew dwyer stefan sokolowski hongjun zheng :10.1.1.43.1614
formal study slicing multi threaded programs jvm concurrency primitives 
technical report kansas state university department computing information sciences march 
john hatcliff james corbett matthew dwyer stefan sokolowski hongjun zheng 
formal study slicing multi threaded programs jvm concurrency primitives 
proceedings th international static analysis symposium sas lecture notes computer science 
berlin springerverlag september 
appear 
john hatcliff matthew dwyer shawn laubach 
staging static analysis abstraction program specialization 
lncs 
principles declarative programming th international symposium plilp september 
john hatcliff matthew dwyer shawn laubach 
specializing configurable systems finite state verification 
technical report kansas state university department computing information sciences 
mats heimdahl michael 
reduction slicing hierarchical state machines 
jazayeri editors proceedings sixth european software engineering conference esec fse pages 
lecture notes computer science nr 
springer verlag september 
holzmann 
model checker spin 
ieee transactions software engineering may 
horwitz prins reps adequacy program dependence graphs representing programs 
proceedings fifteenth annual acm symposium principles programming languages pages san diego california january 
huth ryan :10.1.1.55.1098
logic computer science modelling reasoning systems 
cambridge university press 
appear 
lynette tim teitelbaum 
slicing promela applications model checking simulation protocol understanding 
proceedings th international spin workshop 
neil jones carsten gomard peter sestoft 
partial evaluation automatic program generation 
prentice hall international 
graf sifakis bensalem 
property preserving abstractions verification concurrent systems 
formal methods system design 
manna pnueli 
temporal logic reactive concurrent systems specification 
springerverlag 
mcmillan 
symbolic model checking 
kluwer academic publishers 
podgurski clarke 
formal model program dependences implications software testing debugging maintenance 
ieee transactions software engineering 
ramalingam reps semantics program representation graphs 
technical report university wisconsin madison december 
reps 
program specialization program slicing 
danvy gluck thiemann editors partial evaluation 
dagstuhl castle germany february volume lecture notes computer science pages 
berlin springer verlag 
reps yang 
semantics program slicing 
technical report computer sciences department university wisconsin madison wi june 
reps yang 
semantics program slicing program integration 
proceedings colloquium current issues programming languages barcelona spain march lecture notes computer science new york ny march 
springer verlag 
david schmidt bernhard steffen 
program analysis model checking interpretations 
giorgio levi editor proceedings th international static analysis symposium sas volume lecture notes computer science pages 
berlin springer verlag 
anthony sloane jason 
traditional program slicing 
steven editor proceedings international symposium software testing analysis pages new york january 
acm press 
tip 
survey program slicing techniques 
journal programming languages 
raja rai laurie hendren 
jimple simplifying java bytecode analyses transformations 
technical report sable research group school computer science mcgill university july 
weiser 
program slicing 
ieee transactions software engineering se 

