single pass generation static single assignment form structured languages marc ck eth rich institute computer systems years static single assignment ssa form established suitable intermediate program representation allows new powerful optimizations simplifies considerably 
algorithms known generate ssa form programs arbitrary flow control 
algorithms need passes 
show possible generate ssa form single pass parsing program contains structured control flow gotos 
programs dominator tree built fly 
categories subject descriptors programming languages processors code generation compilers optimization programming languages language constructs features control structures 
data structures trees 
general terms algorithms languages additional key words phrases dominator tree static single assignment form structured languages 
years static single assignment ssa form established suitable intermediate program representation allows new powerful optimizations simplifies considerably 
essential property ssa form assignment variable program text 
easy reason variables variables name contain value 
informal explanation ssa form explain construction ssa form informally turn description algorithm 
start simple sequence assignments 
obtain ssa form transform assignment variable left hand side unique name uses variable renamed accordingly 
subscripts variable names unique call subscripted variables value instances original variables values short 
research supported part swiss national science foundation zur der wissenschaftlichen forschung part eth rich 
authors addresses eth zurich institute computer systems ch zurich switzerland ck currently university linz institute computer science linz austria 
fig 

assignment sequence original form ssa form complicated programs contain branches join nodes join nodes multiple values variable may reach node different branches 
values merged single value reaches uses variable single assignment see 
purpose assignments generated called functions right hand side 
functions operands branches join node 
function operands 
meaning function control reaches join node th branch value function th operand 
fig 

values merged unique value shows control flow graphs statement statement instructions ssa form 
nodes graphs basic blocks instruction sequences single entry branch instruction possibly sequence 
cond cond cond cond fig 

control flow graphs statement instructions ssa form single assignment property simplifies reasoning variables value instance single defining assignment known 
assignment creates new value name kill invalidate expressions previously computed values 
particular expressions textually sure evaluate result 
efficient powerful optimization algorithms ssa form described constant propagation common subexpression elimination partial redundancy elimination code motion induction variable analysis 
single assignment property helpful instruction scheduling leaves essential data dependences code avoids output anti dependences 
ssa form adapted table driven code generation 
algorithms generating ssa form cytron efficient algorithm generating ssa form instructions arbitrary control flow graph dominator tree 
algorithm computes dominance frontiers graph nodes functions placed 
efficient algorithm currently known general flow graph requires passes instructions graph 
structured control flow graphs simplify generation ssa form 
kind folklore knowledge published detail best knowledge 
rosen sketch single pass algorithm generating ssa form algorithm requires topologically sorted control flow graph generates unnecessary assignments 
similar idea exploited horwitz construction dependence graphs 
johnson pingali describe method computing dependence flow graph program deriving ssa form 
identify single entry single exit regions place merge nodes similar assignments 
method similar structured control flow inherently multi pass 
technique generating ssa form single pass directly source text program 
applied structured programs programs contain assignments structured statements case repeat goto statements 
programs join nodes places insert assignments immediately known assignments generated fly parsing 
useful languages simula modula oberon lack goto statements 
language independence desired algorithm applied control flow graphs source programs 
advantage generating ssa form directly parsing saves intermediate step 
building high level representation program transforming directly generate machine specific instructions ssa form ready optimizations 
saves time memory 
technique generating machine independent representation 
deal alias problems caused assignments array elements parameters passed variables referenced pointers 
problems dealt way described 
cytron method requires construction dominator tree non trivial step method need data structure 
dominator tree useful subsequent optimizations worth showing structured programs built single pass parsing 
section explains algorithm generating ssa form section shows build dominator tree parsing 
section demonstrates extend method certain unstructured language features 
section estimates time bounds algorithm section shows measurements section draws 

computing static single assignment form naming values assignment variable generates new value unique number variable 
assignment current value subsequent replaced current value see 
current value variable stored symbol table entry 
assignments ssa form assignments original form current values fig 

current values compilation assignment sequence join nodes control structures statements introduce branches flow graph procedure 
node branches join called join node 
structured statements corresponding join nodes known advance see 
flow graph procedure add virtual start node enter virtual node exit 
introduce empty branch enter exit order exit join node 
case procedure repeat exit enter join node fig 

control structures join nodes flow graph control structures may nested 
join node innermost control structure currently compiled called current join node note introduce special nodes joins reuse nodes naturally appear points branches merged 
example join node statement contain statements 
case introduce additional join nodes repeat statements nested 
repeat repeat stats stats stats additional join node fig 

additional join nodes may inserted nested repeat statements necessary optimizations 
example join nodes loops merged move loop invariant calculations innermost loop 
place assignments assignment belongs certain branch enclosing control structure 
introduces new value value reaches join node different value variable reach join node branches 
assignment variable adds modifies assignment current join node 
operand corresponding branch contains assignment replaced current value see 



fig 

insertion modification assignment compiling assignments note assignments assignments generate new values cause placement assignments outer join node exception assignments exit node join node 
compiling statements start parsing statement immediately create new join node linked control flow graph 
join node container functions generated due assignments branches statement 
assignment variable part create new current value different current value part see 
old current value remembered backup value restored part parsed 
conveniently store backup value function created assignment statement sequence 
statement sequence traverse functions current join node reset current values stored backup values 
statement sequence leaves current values unchanged 
backup value fig 

current values branches statement 
stored backup value function join node 
shows various snapshots control flow graph translation statement 
snapshot current value reset current value reset note assignment branch assignment branch 
corresponding operands functions current values branches backup values 
statement parsed generated assignments committed processed assignments 
causes placement assignments join node enclosing control structure values left hand sides assignments new current values cond cond cond cond cond cond join node join node join node join node join node fig 

generation ssa form statement compiling statements join node statement header node loop node entry loop backward branch join 
assignments loop cause placement functions join node way done statements 
function inserted join node statement leads new current value variable loop 
uses variable replaced new current value 
value keep list instructions value chain 
traversing chain value instructions address larger address loop header easy replace occurrences value loop 
shows snapshots control flow graph translation statement 
cond cond cond cond join node join node join node fig 

generation ssa form statement 
note replaced 
statement parsed assignments join node committed 
causes placement new functions outer join node new current values instructions statement 
note language allows condition header contain assignments values created assignment taken current values statement 
compilation case statements statements follows lines compilation statements statements 
compiling repeat statements repeat statements special control leave join node 
join node loop header assignments repeat statement cause placement functions statements 
assignments committed repeat statement second operand function corresponding backward branch loop taken new current value repeat statement 
value operand function outer join node see 
repeat 
cond 
cond join node outer join node fig 
generation ssa form repeat statement 
current value repeat statement 
implementation ssa form generated procedure generate modify assignment procedure commit assignments join node 
assignment encountered th branch leading join node old called old value assignment 
value stored backup value assignment denoted 
old 
procedure node integer old value contains assignment insert old old old join node loop rename mentions old loop replace th operand assignment join node contained th branch outer join node committed called 
procedure node instructions old join node repeat val val val current value val old 
computing dominator tree method generating ssa form need dominator tree 
optimization algorithms require data structure show section 
show structured programs dominator tree built fly parsing 
dominator tree dominance relation basic blocks block said dominate block appears path start node flow graph called dominator closest dominator path start node called immediate dominator dominator tree tree father block immediate dominator 
efficient algorithm construct dominator tree arbitrary flow graphs described requires passes graph 
structured programs simpler technique allows build dominator tree single pass parsing 
structured statements repeat case statements subgraphs single entry node single exit node 
entry node dominates nodes inside statement immediate dominator inner nodes defined shown 
set immediate dominator node immediately create node 
case repeat control flow graphs dominator trees fig 

structured control flow graphs dominator trees 
extending method unstructured statements structured statements shown generate ssa form dominator tree single pass parsing 
section show possible extend method certain class unstructured statements loop exit return may cause exits control structures arbitrary points 
exits kind disciplined goto surprising harder handle structured statements 
elaborate processing unstructured statements simply want show statements handled single pass 
compiling loop exit statements loop statement see example endless loop left various points exit statement 
introduces join nodes loop header entry loop backward branch join node loop statement target exit branches see 
functions generated due assignments directly loop collected join node loop header 
loop statement assignments loop header committed assignments determine new current values loop statement 
dominator tree traversed node containing exit statement loop header assignments path cause placement functions join node loop statement 
assignments committed 
exit exit join node loop cond exit 
cond exit 
cond cond 
fig 

join nodes loop statement exit points exit statement removes incoming branch current join node 
operands corresponding branch removed 
functions having operands deleted 
programs containing exit statements construction dominator tree complicated 
exit statement removes branch current join node possibly changing immediate dominator node 
consider dominator tree control flow graph shown 
node contains exit statement dominator tree changes 
node node contain exit statement node reachable dominator tree changes 
fig 

control flow graph dominator tree exits exit node exits nodes building dominator tree simply remember statement sequence branch directly contains exit statement 
case branch said dead 
immediate dominator join node computed closest common dominator incoming branches dead 
order find closest common dominator nodes traverse dominator tree upwards take node paths 
look 
node contains exit statement second branch leading node dead immediate dominator 
contain exit statement branches leading dead dominator 
furthermore branch leading dead immediate dominator closest common dominator predecessors branches alive 
node loop statement immediate dominator computed closest common dominator incoming branches nodes containing exit statement leads target node 
compiling return statements return statements terminate procedure return control caller handled way exit statements 
return statement branch dead removes current join node 
exit statements corresponding operands functions join node removed 
immediate dominator join node computed closest common dominator live branches join node 

analysis cytron report run time complexity algorithm worst case maximum number nodes control flow graph number edges graph number original assignments number original mentions variable program 
algorithm worst case complexity 
surprising size ssa form number assignments number operands independent algorithm generation 
practice translation ssa form algorithms 
original assignment generates assignments average 
measurements correspondence numbers reported 
run time algorithm determined effort generate assignments rename mentions variables loop assignments variables inserted loop header see section 
original assignment generates assignment join node 
number original assignments number join nodes statement number assignment ab 
mentions renamed loop original mentions loop plus mentions assignments contained loop 
assignment mentions maximum number branches leading join node abn 
total run time ab abn 
maximum run time worst case 
algorithm worst case behavior described generates ssa form single pass algorithm needs passes plus additional effort build dominator tree 
algorithm looks assignment exactly immediately generating operand right join node 
furthermore usually choose appropriate name mention variable immediately generating instructions algorithm needs separate pass rename mentions assignments placed 
believe algorithm runs faster simpler implement 
proved empirical data topic research 

measurements implemented algorithm compiler subset oberon expressions assignments repeat loop exit statements scalar variables arrays 
generation ssa form construction dominator tree lines source code accounted compiler total source code 
table shows data compilation benchmark programs sieve calculating prime numbers heapsort polyphase sort 
measured total number generated instructions including assignments number generated instructions assignments 
furthermore measured time generate instructions source code generation assignments generation assignments 
measurements performed ns processor running mhz 
table statements generated instructions compilation time ms sieve heapsort polyphase sort results show algorithm imposes linear time penalty linear space overhead compilation practice 

static single assignment form dominator tree important data structures optimizing compilers difficult generate programs arbitrary flow control 
structured programs goto statements possible build ssa form dominator tree single pass directly parsing 
shown straight forward technique 
remarkable omission goto statement algorithms generate ssa form 
demonstrates poor language feature may cause undue overhead compiler 
regard important result restriction language simple control structures leads simpler efficient optimizing compiler 
algorithms allow building small efficient compilers easy understand 
possible teach undergraduate course weeks hours week students built full optimizing compiler small language ssa form 
ease powerful elegant ssa form generated structured languages see reason compilers languages build intermediate program representation syntax tree 
implemented algorithms compiler subset oberon 
generation ssa form construction dominator tree implemented lines code 
currently integrating technique full oberon compiler 
robert josef valuable comments earlier versions anonymous referees helpful suggestions 

aho sethi ullman compilers 
addison wesley 

alpern wegman zadeck detecting equality variables programs 
conference record th annual acm symposium principles programming languages 

birtwistle dahl nygaard simula 
lund sweden 

cytron lowry zadeck code motion control structures high level languages 
conference record th annual acm symposium principles programming languages 

cytron ferrante rosen wegman zadeck efficiently computing static single assignment form control dependence graph 
acm trans 
program 
lang 
syst 


lengauer tarjan fast algorithm finding dominators flowgraph 
acm trans 
program 
lang 
syst 


mcconnell johnson static single assignment form code optimizer 
acm letters programming languages systems 

horwitz prins reps integrating noninterfering versions programs 
acm trans 
program 
lang 
syst 


johnson pingali dependence program analysis 
proceedings sigplan symposium programming languages design implementation 

wang register allocation renaming impact finegrain parallelism 
proceedings th international workshop languages compilers parallel computing lecture notes computer science springer verlag 

rosen wegman zadeck global value numbers redundant computations 
conference record th annual acm symposium principles programming languages acm new york 

wegman zadeck constant propagation conditional branches 
acm trans 
program 
lang 
syst 


wirth programming modula springer verlag 

wirth reiser programming oberon steps pascal modula addison wesley 

wolfe 
induction variables 
proceedings sigplan symposium programming languages design implementation sigplan notices 
