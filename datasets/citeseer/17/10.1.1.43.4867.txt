modular interprocedural pointer analysis access paths design implementation evaluation ben chung cheng wen mei hwu department computer science department electrical computer engineering university illinois email crhc uiuc edu modular interprocedural pointer analysis algorithm access paths programs 
argue access paths reduce overhead representing context sensitive transfer functions ectively distinguish non recursive heap objects 
modular analysis paradigm techniques handle type casts function pointers able handle signi cant programs suites 
implemented algorithm tested pentium ii pc running linux 
observed resource consumption performance improvement encouraging 
interprocedural pointer analysis critical component accurate static memory disambiguation addressed researchers past years 
analysis goal evolved detecting aliases formal parameters fortran programs aliases multi level pointer dereferences java 
interprocedural pointer analysis mature feasibility fully functional interprocedural pointer analysis algorithm accommodate realistic large programs demonstrated literature 
function inlining register allocation ssa analysis interprocedural pointer analysis integrated commercial compilers 
key issues need addressed interprocedural pointer analysis algorithm include 
demonstrate algorithm raises applicability interprocedural pointer analysis level 
flow sensitivity 
pointer analysis algorithm considers ects pointer assignments currently employed sun microsystems palo alto ca 
permission digital hard copies part personal classroom granted fee provided copies distributed pro commercial advantage copies bear notice full citation rst page 
copy republish post servers redistribute lists requires prior speci permission fee 
pldi vancouver british columbia canada 
copyright acm 
respect statement orders 
bene assignment may kill earlier de nitions pointer 
algorithms allow strong updates scalar pointer variables :10.1.1.25.6013:10.1.1.37.6842
reality scalar pointers rarely rede ned 
rede ned frequently usually loops traverse arrays linked lists data structures treated conservatively single aggregate element 
result accuracy yielded proportional time spent earlier reports little bene observed studied benchmarks 
context sensitivity 
context sensitive interprocedural pointer analysis algorithm distinguishes di erent caller contexts common callee alias information carried caller leaked 
necessity performing context sensitive pointer analysis benchmarks shows little precision bene 
bene cial propose inexpensive context sensitive algorithm 
program modular analysis 
straightforward way maintain context sensitivity analyze program interprocedural control ow graph memory usage analysis time costly method :10.1.1.25.6013
partial transfer functions proposed wilson lam memoization avoid redundant analysis subset call graph 
modular analysis proposed chatterjee reduces memory requirement method bodies belonging strongly connected components scc program need memory resident simultaneously :10.1.1.37.6842
real programs contain large sccs desirable reduce memory requirement analyzing single scc 
storage path representation 
static algorithm needs notation represent run time accessed memory locations 
storage representation uses extended variable names physical memory locations :10.1.1.25.6013:10.1.1.25.6013:10.1.1.37.6842:10.1.1.37.6842
avoid ambiguity required single memory location represented storage name 
due di erent aliases formal parameters version transfer functions separately maintained collectively maintained di erentiated alias contexts required :10.1.1.37.6842
access paths hand simply represent physical memory locations accessed initial variable store model :10.1.1.152.183
long length access paths bound presence recursive data structures context independent representation summary transfer function easier way produce determine parameter call graph 
build estimated aliases 
analyze local statements context insensitive 
propagate concrete values 
context sensitive 
aliases 
determine parameter flow sensitive 
propagate summary transfer functions context sensitive 
intraprocedural interprocedural flow insensitive 
build accurate call graph statements propagate summary transfer functions analyze local propagate concrete function names 
phase propagate concrete values 
phase iii phase phase ii phase phase phase phase ii phase iii phase ii modular interprocedural pointer analysis rci algorithm subset proposed modular analysis complete unique names heap objects enabled 
literature explain summary transfer functions maintained access paths 
partial complete language features 
compiler needs full coverage language features order perform correct optimizations 
proposed wilson lam rst cover features applicability limited memory requirement program analysis 
hand ow context insensitive algorithms asymptotically faster handling realistic features may drastic impact complexity :10.1.1.11.3368
example handling structures unions steensgaard algorithm linear complexity aggregate elds considered complexity exponential 
ectiveness study 
earlier algorithms evaluated resource consumptions pointer resolutions statistics improved optimization opportunities 
wilson lam uses pointer analysis results guide loop spec benchmark diwan uses type alias analysis guide redundant load elimination load migration set modula programs 
cooper lu study ect register promotion variables presence pointers indirect accesses heap objects elds aggregates handled 
interprocedural pointer analysis results guide aggressive memory access optimizations including redundant load store elimination loop invariant memory access migration load store scheduling 
optimizations aggressive type safe language stack heap memory accesses optimized code regions containing function calls 
formal veri cation correctness pointer analysis results absent analysis results guide aggressive optimizations provides pragmatic alternative veri cation 
propose fully functional interprocedural pointer analysis algorithm handle widely programs 
design emphasizes practical aspect interprocedural pointer analysis adopting modular ow insensitive paradigm 
propagation summary transfer functions conducted context sensitive inexpensive manner access paths points analysis 
accommodating realistic features algorithm handles function pointers starting underestimated call graph augmented iteratively course interprocedural pointer analysis 
incorporate set representation structure union elds access paths handle aliases caused unions type casts 
addition demonstrate number names representing recursive heap objects bound location acyclic heap objects disambiguated access paths 
experiments conducted impact compiler framework complete benchmark suites including gcc contains lines code functions 
high workstation pentium ii pc mb memory running linux red hat demonstrate feasibility algorithm 
minutes analysis time mb memory usage analysis deliver average performance improvement peak improvement programs compiled pointer analysis memory access optimizations 
numbers demonstrate eciency ectiveness algorithm 
rest organized follows 
section details proposed modular interprocedural pointer analysis algorithm 
section evaluates complexity algorithm 
section presents empirical results 
section reviews related 
section concludes 
modular interprocedural pointer analysis modular interprocedural analysis technique decomposes program smaller modules small number modules need resident memory simultaneously 
algorithm consists major stages intraprocedural stage interprocedural stage 
typedef struct int key struct main void fn st st st fn fn fn fn fn st st fn st st fn fa fb fc temp temp fa temp fb fn fn key st key st key st neq key key init init init init init init eq key st key st key st st st st st st st st st storage path transfer functions shown dashed edges code versions distinguished alias contexts generic version applicable calling contexts 
intraprocedural stage function analyzed isolated compilation module formal parameters callee return values global variables assumed unknown values 
indirectly accessed locations unknown pointers represented access paths 
intraprocedural stage summary behavior function calculated including set memory locations accessible function boundaries set call site names set pointer de nitions involving pointers accessible function boundaries 
third set considered summary transfer function represented points relations 
interprocedural stage perform bottom propagation summary transfer functions call graph 
presence function pointers need perform top propagation function names partially resolved call graph indirect call sites may receive concrete function names parameters 
transfer function just resolved indirect callee may de ne function pointers program bottom top propagation needs performed iteratively xed point reached 
aliases formal parameters calculated top propagation concrete values complete call graph 
high level idea algorithm similar relevant context inference rci proposed chatterjee modular analysis reduce resource requirements :10.1.1.37.6842
signi cant improvements proposed distinguish highlighted 
rci covers subset constructs general features including explicit address operator function pointers structure members general pointer assignments excluded 
covers complete features generate safe analysis results guide code optimizations 
secondly rci uses estimated call graph 
indirect call site functions names taken identical signatures considered possible callees 
ijpeg benchmark functions names taken majority signature 
furthermore indirect call sites program 
estimated call graph inaccurate wastes time propagating summary transfer functions simplicity collectively term parameters mean function return values 
produces spurious results 
lastly rci uses alias contexts lazily enumerate potential aliases parameters order distinguish transfer functions di erent calling contexts 
method access paths enable representation transfer functions memory represent summary functions reduced 
consider example shown 
estimated call graph fn may invoke fn fn names taken signatures match 
fact fn called fn propagating summary transfer function fn spurious unnecessary 
shows summary transfer functions represented fn rci 
init init represent objects pointed respectively 
upper dashed edge indicates init points init receive concrete value lower dashed edge shows init points init receive di erent concrete values 
believe enumeration unnecessary caller knows better callee identical values passed di erent parameters 
long memory name transfer function faithfully represents memory location accessed formal parameters global variables context independent manner caller easily determine location replacing formal parameter concrete value 
shown post access paths straightforward call site derive stands st stands st call site derive stand st :10.1.1.152.183
points relations st st st st derived single summary points relation 
intraprocedural analysis stage advantage proposed algorithm comes access paths represent memory locations 
described regular expressions grammar access path variable call site name form eo denotes starting sets eld structure union denotes step dereference symbolically shown confusion closure symbol regular expressions 
conceptually access path simply encoded post sequence dereference set operations taken reach nal destination 
contents intermediate pointers access path known access path bound particular locations simply leads denoted locations 
de nition construction access paths de ned rules ap denotes function recursively determines post access paths expressions involve memory accesses 
ap variable 

ap exp ap exp exp call site direct indirect unique id 
ap exp ap exp exp function name 

ap exp ap exp exp function name 

ap exp index ap exp exp array type exp formal parameter 

ap exp index ap exp exp arbitrary pointer formal parameter array type 

ap exp op exp ap exp op arbitrary binary operator exp pointer type variable 

ap exp eld ap exp eo 

ap exp eld ap exp eo 

ap exp eld 
eld ap exp eo eo eo 
generating possible access paths variables access paths generated lazily observed expressions function 
recursively de ned de nition operators add constant set pointer omit set manipulation operators resulting coarse safe access path linearly accessed locations 
aggressively di erentiate elements array 
shown literature starting set set eo represent eld accesses ectively resolve aliases caused unions type casts 
integrate techniques coalescing back back elds shown rule 
example nested structure eld access assuming size bytes occupies rst bytes struct alias accesses location 
rule access paths encoded respectively 
rule normalized access path generated aliases easily detected 
explicit pointer assignments access paths byte sets resolve aliases caused type casts pointer arithmetics 
resolve aliases presence arbitrary pointer assignments discussed momentarily 
points relation proposed emami adopted represent data ow facts pointer assignments 
original points relation tuple form storage names representing physical pointer target memory locations respectively 
third operand speci es pointer possibly de nitely points target 
points notation de ned represented access paths attribute possible points relations generated 
pointer assignment lhs rhs lhs rhs pointer type expressions rhs null rst step determining corresponding points relations construct corresponding access paths lhs rhs noticing dereference operator added rhs expression 
due ects earlier pointer assignments lhs rhs may aliases 
example pointer prior pointer assignment access paths aliases 
similarly pointer prior pointer assignment aliases 
result statements cause point de nition right access path direct access variable right access path simply variable name 
memory location accessed indirectly right access path contrived access paths pointers appear rst rhs operand sequence pointer assignments propagate address indirectly accessed memory location 
way correctly represent ects set pointer assignments create points relations cross products aliases lhs pointer aliases rhs target 
complete enumeration unnecessary ways transform access path normalized form observations aliases caused pointer assignments pointers initialized 
pointer dereference small number right access paths explained de nition denote accessed memory location addresses assigned dereferenced pointer arbitrary number pointer assignments 
long encoded access paths expressions normalized right access paths fewer access paths ended fewer points relations need maintained 
de nition shows encoded access path expression existing points relations nd entire set right access paths de nition shows add points relations right access paths pointer assignment 
notice evaluated result set access paths singular path due pointer may de nition 
caused conditional de nitions pointer ow insensitive nature pointer analysis algorithm 
de nition finding right forms access path set points relations sptr evaluation access path recursively de ned 
eval sptr fv 
eval sptr fv function 
eval sptr eval sptr eval sptr point location fewer pre paths common types eval sptr pre paths common types longest 
eval sptr eval sptr fg de nition path points relations pointer assignment lhs rhs function fn lhs rhs pointer type expressions rhs null sptr set points relations added fn 
eval ap lhs sptr eval ap rhs sptr points relation added sptr sp int sp key sp key sp key sp sp sp sp sp sp sp sp sp sp sp sp sp sp sp sp sp sp sp sp sp access paths represent recursive data structures code di erent points relations controlled di erent values de nition de nes closure function eval evaluates contents intermediate pointers access path referencing existing points relations nd set right aliases input path 
rules terminal cases evaluation simple variables function names 
rule cases 
set discovers denoted locations determining denoted locations rst elements eval sptr points locations ones denoted 
pointer initialized potential dereference pointer addressed cases 
set simply creates trivial target uninitialized pointer recursive type instances recursive type denoted pre xes 
trivial points relation added 
longest pre type reused speci ed set 
recursive sensitivity parameter di rst objects linked list 
similar limiting approach control length access paths involving recursive data types 
consider example 
larger value better resolution expense access paths points relations 
experiments assume conservative case 
rule simply re nes locations denoted eld sets 
consider pointer assignments 
purpose variable temp designed show indirect modi cation fa captured de nitions 
analyzed points relation temp fa added 
analyzing due previously added points relation temp initialized pointer eval temp temp fa fa 
hand result eval fb sptr fb fb formal parameter assumed uninitialized intraprocedural phase 
points relation added fa fb 
shows pseudo code intraprocedural stage 
library functions approximate safe summary transfer functions template statements 
example points relation derived represent transfer function memcpy analyzing memcpy void void int char char currently library functions modeled template statements impact compiler 
cover library functions invoked mediabench unix utility programs 
intraprocedural pointer analysis fn sptr fn apply eval ap exp sptr fn pointer type actual parameter exp fn pointer assignment lhs rhs fn apply de nition construct points relations structure union assignment lhs rhs fn apply de nition lhs rhs pointer type eld new access paths points relations added pseudo code intraprocedural pointer analysis stage 
interprocedural analysis stage interprocedural analysis stage algorithm iterative phases followed acyclic phases shown 
fundamental tasks performed phases similar rci major phase numbers minor annotations 
summarized behavior function information needed interprocedural stage 
phase depth rst search dfs initiated function main construct call graph 
dfs call graph partitioned strongly connected components viewed directed acyclic graph scc dag 
program indirect calls iterative phases need entered complete call graph built rst invocation phase 
example points relation fn fn propagated main happen phase evaluating access path associated indirect call site fn phase iteration reveal callee eval fn fn fn fn 
phase summary transfer functions propagated scc dag reverse topological order 
summary transfer functions scc rst propagated iteratively xed point reached :10.1.1.37.6842
method ow insensitive need keep summary behavior caller full function body control ow information functions scc simultaneously memory 
shown experiments largest scc benchmark gcc holds functions introduce memory problems full summarized information memory resident analyzing scc 
largest benchmark studied methods largest scc methods :10.1.1.37.6842
de nition propagating summary transfer functions points relation function fn summary transfer function parameters global variables sux access paths 
propagated points relations caller fm eval sptr fm eval sptr fm global variable 
corresponding actual parameter fm 
relation holds points relation function summary behavior belongs function summary transfer function 
example trivial points relations count represent explicit pointer assignments 
points relation parameters global variables quali ed entry summary transfer function 
propagate points relation callee caller context sensitivity straightforward 
shown de nition initial step replace formal parameter corresponding actual parameter 
referencing points relations contained summary behavior caller function sux access path guides search locations caller denoted access path constructed callee 
example propagate points relation fa fb fn main fa rst fn eval fn sptr main ffn 
similarly fb replaced fn eval fn sptr main fn 
points relation propagated main fn fn fn 
example possible propagated pointsto relation represented caller formal parameters global variables meaning caller summary transfer function augmented reported grand callers 
formal parameters caller considered uninitialized interprocedural stage augmented transfer function context independent 
interesting question handle dynamically allocated objects propagate existence function boundaries 
generating pseudo variable names synthesized call site paths name heap objects directly allocated calling malloc call site names unique function shown rule de nition name heap objects indirectly allocated calling wrapper functions access paths derived actual parameters guarantee unique names generated objects allocated di erent calling contexts 
remaining problem detect potential dependence indirect accesses heap objects allocated calling context 
consider example shown 
function fn integer pointers calling malloc instances heap integer objects allocated 
propagating transfer function malloc fn assumed point disjoint locations denoted example point location disregarding fact may cause hazards statements 
options represent dependence creating explicit object adding dashed edges 
choose requires special representation heap objects 
concept extended access path statement causes points relation annotated edge 
determine extended access path fn access path fn summary behavior initiates parameter global variable eap rst element remove sptr fn eap de ned eap eap eo eap eo de ned eap eo eap eo eog pseudo code eap construction 
eap detect dependence algorithm shown 
basic idea algorithm callee function allocates heap object caller object reachable conducting dfs pointsto relations initiated parameters global variables 
eap considered reverse engineered access path obtained dfs indicates potential way object accessed parameter global 
rst eap access path chosen persistent name viewed caller 
example malloc malloc represent heap objects allocated malloc 
malloc unique eap malloc may assigned depending dfs initiates rst 
particular case dfs performed eap malloc points relation malloc considered malloc transfer function 
propagating malloc fn dashed edge added 
dfs performed added 
matter added long eval sptr fn eval sptr fn true asserts dependence memory accesses 
fact constituent points relations summary transfer function identi ed solely 
access path eap de ned means denoted location accessible caller points relations eap access paths considered part transfer function 
revised version definition propagates transfer functions detects dependence accesses heap objects 
de nition propagating summary transfer functions points relation fn 
part fn transfer function eap eap 
assuming parameters global variables 
propagated points relations caller fm eval sptr fm eval sptr fm remaining conditions identical de nition 
fn int malloc malloc int int int int malloc sizeof int int malloc sizeof int summary behavior fn malloc malloc eap eap summary behavior malloc malloc malloc handling heap objects code points relations functions summary behavior representing dependence accesses heap objects 
interprocedural pointer analysis prog resolve function pointers indirect call site dfs compose scc dag reachable functions prog scc prog bottom order determine eap access paths function scc iteratively propagate points relations scc scc function re determine eap function new points relations received propagate summary transfer function scc caller sccs scc prog top order iteratively propagate function names scc scc function propagate function names scc callee sccs call graph changed previous iteration scc prog top order iteratively propagate concrete values scc scc function propagate concrete values scc callee sccs determine aliases parameters pseudo code interprocedural pointer analysis stage 
phase ii performs subset done phase ii analysis rci propagate function names 
regardless function pointer de ned local statements handled phase side ects invoked functions handled phase concrete values passed callers handled phase ii accurate call graph iteratively built 
function names accumulated callee call graph built phase context insensitive 
call graph phases ii propagates concrete values top manner scc dag 
result phase ii phase iii order determine potential parameter aliases 
due space contraints details omitted similar :10.1.1.37.6842
pseudo code interprocedural stage shown 
complexity analysis section discuss complexity algorithm set parameters 
number user library functions contained program 
number call sites program 
vf sum variables call sites single function 
number data types declared program number unique instances distinguished linked lists 
typed nite number 
total number elds distinct starting sets structures unions 
number pointer assignments function number expressions result memory accesses function 
demonstrate number access paths stemmed variable bound kt 
intermediate path casted structure type path widened eld operations length path controlled number types program number unique instances linked lists 
space complexity store access paths intraprocedural phase single function kt program interprocedural phase fv kt 
space complexity store points relations intraprocedural phase single function kt fv kt interprocedural phase 
algorithms intraprocedural interprocedural phase terminate number access paths points relations types nite 
time complexity generating access path expression takes steps small xed number dereference eld accesses associated expression 
evaluating access path de nition takes lkt steps 
intraprocedural algorithm evaluates memory access pointer assignment time complexity iteration lkt 
algorithm ow insensitive time analyzing function bound table benchmark characteristics 
benchmark lines fns fns sts uns sccs scc espresso eqntott compress sc cc go ksim gcc compress li ijpeg perl vortex lkt 
interprocedural phase transferring access paths call graph bound lkt 
dfs partition call graph scc dag takes steps may di erent iteration iteration indirect function pointers resolved 
worst case bound 
dfs determine takes kt steps 
resolving indirect call site takes time lkt assuming indirect call sites program height call graph complexity interprocedural algorithm bound lkt kt 
worst case complexity occurs pointers including pointer variables elds casted point possible data types 
empirical results indicate worst case complexity observed studied benchmarks 
experiments proposed modular interprocedural pointer analysis algorithm implemented tested impact compilation framework 
quantify algorithm quality analysis result guide aggressive optimization routines including redundant load store elimination loop invariant location promotion load store scheduling 
similar experiments reported optimizer aggressive due fully resolved pointers function side ects 
traditional benchmarks adopted earlier benchmark suites chosen demonstrate analysis capable handling signi cant programs 
analysis costs section analysis costs benchmarks reported 
listed table general characteristics benchmark shown including numbers lines functions dead functions invoked library functions structures unions number unique elds structures unions strongly connected components scc functions contained largest scc 
number lines directly ects time spent intraprocedural stage number functions plays important role determining complexity interprocedural stage 
removing dead functions speedup compilation process improve run time table resource requirements conducting interprocedural pointer analysis 
benchmark intra 
inter 
total 
sec 
sec mem 
mb sec espresso eqntott compress sc cc go ksim gcc compress li ijpeg perl vortex performance 
addition inherited dead functions program function inlining introduce dead functions benchmarks 
proposed interprocedural pointer analysis algorithm considers summarized behavior library functions ective number functions analyzed number total functions minus number dead functions plus number library functions number ranges spec programs 
number structures unions determines number unique types programs 
number unique elds considered aggregate data types determine number derivable access paths variable 
benchmark gcc aggregate declarations unique byte set representations elds shown shortly analyzing benchmark takes longest time largest amount memory 
scc exactly function total number functions contained program plus number invoked library functions minus dead functions equal number sccs eqntott compress go compress 
due common recursive feature language processing programs cc gcc li large sccs 
proposed modular analysis technique section reduce memory usage analyzing single scc summary behavior function needs maintained 
table shows resource consumption statistics collected personal computer equipped intel pentium ii processor running mhz mb ram 
underlying operating system linux redhat impact modules compiled gnu version native compiler option turned 
elapsed time shown seconds excluding disk time memory usage shown mega bytes mb 
time intraprocedural stage column sums analysis time spent function 
high water mark memory usage intraprocedural stage shown function analyzed isolation memory usage di erent function level analysis 
interprocedural stage columns show elapsed analysis time interprocedural stage high water mark memory usage 
sum analysis time spent stages shown column table 
expected analyzing gcc consumes memory longest time due size functions lines code complex structure declarations intensive usage type casts 
due similar characters cc vortex require resources benchmarks 
conventional wisdom holds interprocedural pointer analysis expensive task requires high computer system huge amount memory accomplish 
statistics shown table demonstrated proposed modular interprocedural pointer analysis algorithm raises applicability pointer analysis level 
analyzed programs step closer real world programs system requirements met personal computer 
subsections shown new algorithm accurate provide signi cant performance improvements 
accuracy measurement literature metrics de ned measure accuracy pointer analysis 
common metric count number targets pointer points general rule judge accuracy pointer analysis algorithm closer number targets better analysis result 
target metric may misleading trivial pointer analysis algorithm simply assume pointers point target causing algorithm falsely judged perfect 
symmetric metric measures number pointers point target usually avoid biased measurement 
similarly better algorithm pointer target metric reasonable 
table shows statistics target pointer metric pointer target metric observed rightmost access paths merging interprocedural pointer analysis results function 
benchmark gone function inlining allows code growth 
numbers table re ect numbers outgoing points relations carried pointer type access paths numbers table columns re ect opposite 
di erent targets passed pointer type formal parameters di erent calling contexts considered single object multiple instances targets results programming style irrelevant accuracy pointer analysis 
average numbers targets resolved pointer paths range indicating pointers resolved single target path 
average numbers pointer target range showing usually table resolutions interprocedural pointer analysis target pointer pointer target 
benchmark avg 
espresso eqntott compress sc cc go ksim gcc compress li ijpeg perl vortex benchmark avg 
espresso eqntott compress sc cc go ksim gcc compress li ijpeg perl vortex espresso eqntott compress sc cc go ksim gcc compress li ijpeg perl vortex average benchmark unique anonymous named cyclic named acyclic distribution pointer de nitions 
pointer pointing target 
hundreds thousands pointers program low numbers shown metrics new modular interprocedural pointer analysis algorithm accurate 
accurate assessment ow sensitivity conduct sensitive insensitive analyses programs 
takes lot overhead implement methods compiler shown literature ow sensitive pointer analysis algorithm handle complete spec suites 
comparison conducted indirectly 
classi es intraprocedural pointer de nitions categories unique anonymous named cyclic named acyclic 
unique category represents pointers de ned function 
example local pointer variable initialized declared rede ned function belongs unique category 
pointer type parameter de ned caller passed callee dereferences pointer belongs unique category 
shown average pointers rede ned 
anonymous category accounts pointer de nitions average covers pointers simple variables de ned multiple times 
named cyclic portion accounting pointer de nitions covers pointer variables de ned loops named acyclic category represents pointer variables de nition acyclic code regions 
pointers rede ned ow sensitive pointer analysis algorithm update target information pointer variable de nitions happen acyclic code regions 
study shows pointer de nitions potentially better resolved ow sensitive algorithm 
shown section additional performance improvement provided pointers fairly small compared provided static memory disambiguation arguing worth trading ow sensitivity lower complexity 
performance improvements results interprocedural pointer analysis guide memory access optimizations mentioned 
potential bene ts memory access optimizations evaluated simulated processor issue instructions cycle order 
processor memory ports integer alus oating point units branch units integer oating point registers 
memory system consists direct mapped nonblocking data cache byte block size 
data cache write write allocate hit latency cycles penalty cycles hit second level cache 
second level cache uni ed way associative cache penalty cycles 
instruction cache assumed perfect goal experiments understand data access behavior 
branch prediction scheme entry btb bit counters 
instruction set architecture instruction latencies match hp pa microprocessor integer operations loads cycle latency 
sets parameters impact compiler con gured generate versions programs di erent levels sophistication memory disambiguation 
base version assumes memory instructions ambiguous function calls pessimistic side ects 
pessimistic assumptions completely prevent register promotion scheduling standard version employs memory disambiguation information derived 
memory disambiguation level commonly commercial compilers interprocedural pointer analysis ectively disambiguate accesses spill locations local variables global variables indirect accesses equivalent base registers sets revert ambiguous relations combinations 
precise side ects temporary variables inserted compiler local variables addresses taken promoted registers 
espresso eqntott compress sc cc go ksim gcc compress li ijpeg perl vortex average benchmark std base adv base performance improvements enabled memory disambiguation 
espresso eqntott compress sc cc go ksim gcc compress li ijpeg perl vortex average benchmark load store reduction rates load store instructions 
library function calls modeled pessimistic side ects assumed user functions 
advanced version utilizes complete memory disambiguation information generated interprocedural pointer analysis uses memory disambiguation information guide memory access optimizations 
side ects functions accurately modeled version 
di erences mentioned versions compiled inlining code increase classical optimizations superblock optimization 
training input sets levels experiments 
plots speedups execution time standard advanced versions base version observed issue processor 
gure indicates memory optimizations memory disambiguation performed provide average speedup 
optimization opportunities enabled better disambiguated memory accesses average speedup boosted 
additional performance improvement standard version advanced version ratio re ects advancement performance improvements derived compile time memory disambiguation technology 
better understand merits advanced static mem espresso eqntott compress sc cc go ksim gcc compress li ijpeg perl vortex average benchmark achieved performance scheduling ratio performance improvements enabled scheduling versus full memory access optimizations 
ory disambiguation run time behaviors standard advanced versions code studied 
left bar benchmark shows reduction dynamic loads standard advanced versions 
numbers show dynamic loads compress eliminated average reduction rate 
attributing minor variance speedup numbers normal deviation detailed simulation loads benchmarks eqntott gcc li ijpeg perl eliminated signi cant manner 
right bar benchmark stands percentage stores eliminated 
benchmarks numbers loads stores increased due reasons 
rst reason load instructions speculatively executed 
example consider code sequence branch store load 
interprocedural pointer pointer analysis relation store load may ambiguous load executed branch taken 
memory disambiguation information indicates store load independent empty memory slots branch load executed speculatively branch 
branch taken load instruction issued latency hidden 
unnecessary load executed result discarded 
second reason increased register pressure due memory contents held registers may increase numbers load store instructions register spilling re lling 
shown signi cant performance improvements obtained extra memory instructions 
shows contribution register promotion performance improvement memory disambiguation 
speedup derived performance di erence standard version advanced version achieved performance improvement shown bar obtained disabling load store scheduling 
comparing shows register promotion scheduling provide signi cant performance improvements 
benchmarks espresso compress obtain performance improvements register promotion 
speculatively executed load instructions may cause extra cache misses performance slightly better 
hand benchmark ijpeg negative load reduction rate performance speedup advanced standard version high total speedup achieved scheduling disabled 
additional experimental results including estimate performance loss due spurious analysis results impact reduced machine resources bene static memory disambiguation 
case studies spec code fragments included exemplify strength weakness proposed modular interprocedural pointer analysis algorithm 
related addition discussion section thorough study rci section summarize related section 
landi may alias representation perform ow context sensitive interprocedural pointer analysis 
pioneer improving accuracy pointer analysis interprocedural control ow graph icfg 
analyzed language simpli ed memoization 
emami propose points representation model storage shape graph 
analysis ow sensitive points relations classi ed de nite possible generate possible relations 
algorithm designed aggressively disambiguate heap objects memoization 
handle subset function pointers included 
choi propose sparse representation alias pairs invocation path memory allocation sites name heap objects 
experimental results implementation details provided 
look tradition applications pointer analysis rinard perform pointer analysis multithreaded programs 
algorithms types perform alias analysis 
deutsch uses symbolic access paths analyze alias relations accesses recursive structures typed programs :10.1.1.152.183
algorithm access path notation post low level sets elds 
types di erently directly resolve aliases due type casts control length access paths presence recursive data structures 
ow insensitive analysis proposed andersen cubic worse case running time ahndrich shows andersen method practical large programs 
shapiro propose hybrid method con gurable complexity steensgaard anderson algorithms 
hasti propose idea iteratively improving accuracy pointer analysis ssa form empirical result available 
zhang stocks balance complexity switching various algorithms 
largest benchmark handled lines code 
algorithm rst demonstrate ow insensitive analysis accommodating complete features handle programs lines code 
resolving aliases general pointer dereferences lot researchers focused obtaining detailed descriptions heap objects 
algorithm provide safe approximation detailed pro le 
ecient ective modular interprocedural pointer analysis algorithm programs 
algorithm calculate ow insensitive context sensitive summary transfer functions accurate call graph shorter analysis time better analysis results achieved program contains large number indirect function calls 
low level representation structure union elds access paths handles aliases caused type casts unions 
experimental results demonstrate method eciently handle larger programs interprocedural pointer analysis algorithms 
reasonable time memory usage suggest algorithm nice scalability feasible implementation production environments 
performance study complete benchmark suites shows proposed interprocedural pointer analysis provide signi cant speedup 
includes evaluation proposed algorithm broader range real applications 
handling spec benchmarks important milestone practical interprocedural pointer analysis size fraction real world applications 
actively studying relations aggressive static memory optimizations data speculation hardware supports 
acknowledgments authors members impact research group assistance especially dan connors erik nystrom design implementation memory access optimization routines marie conte hunter careful review 
valuable comments anonymous reviewers signi cantly improved quality 
research supported national science foundation nsf ccr intel foundation fellowship 
allen johnson compiling vectorization parallelization inline expansion proceedings acm sigplan conference programming language design implementation pp 
june 
chow hennessy register allocation priority coloring proceedings sigplan symposium compiler construction pp 
june 
cytron ferrante rosen wegman zadeck eciently computing static single assignment form control dependence graph acm transactions programming languages systems vol 
pp 
october 
emami ghiya hendren contextsensitive interprocedural points analysis presence function pointers proceedings acm sigplan conference programming language design implementation pp 
june 
wilson lam ective contextsensitive pointer analysis programs proceedings acm sigplan conference programming language design implementation pp 
june 
chatterjee ryder landi relevant context inference proceedings acm symposium principles programming languages pp :10.1.1.37.6842
january 
hind assessing ects pointer alias analyses lecture notes computer science springer verlag 
proceedings th international static analysis symposium 
ruf context insensitive alias analysis reconsidered proceedings acm sigplan conference programming language design implementation pp 
june 
landi ryder safe approximate algorithm interprocedural pointer aliasing proceedings acm sigplan conference programming language design implementation pp 
june 
cormen leiserson rivest algorithms 
mit press mcgrawhill 
deutsch interprocedural may alias analysis pointers limiting proceedings acm sigplan conference programming language design implementation pp :10.1.1.152.183
june 
burke carini choi hind interprocedural alias analysis presence pointers lecture notes computer science pingali banerjee gelernter nicolau padua eds pp 
springer verlag 
proceedings th workshop languages compilers parallel computing 
steensgaard points analysis linear time proceedings acm symposium principles programming languages pp 
january 
andersen program analysis specialization programming language 
phd thesis diku university copenhagen may 
steensgaard points analysis type inference programs structures unions lecture notes computer science ed pp 
springer verlag 
proceedings international conference compiler construction 
ghiya hendren putting pointer analysis proceedings acm symposium principles programming languages pp 
january 
cooper lu register promotion programs proceedings acm sigplan conference programming language design implementation pp 
june 
shapiro horwitz fast accurate points analysis proceedings acm symposium principles programming languages pp 
january 
diwan mckinley moss alias analysis proceedings acm sigplan conference programming language design implementation pp 
june 
yong horwitz reps pointer analysis programs structures casting proceedings acm sigplan conference programming language design implementation pp 
may 
chang mahlke chen warter hwu impact architectural framework multiple instruction issue processors proceedings th international symposium computer architecture pp 
may 
lee potkonjak mangione smith mediabench tool evaluating synthesizing multimedia communications systems proceedings th annual international symposium microarchitecture pp 
december 
bodik gupta load reuse analysis design evaluation proceedings acm sigplan conference programming language design implementation pp 
may 
hewlett packard cupertino ca pa risc architecture instruction set manual 
cheng pro le driven automatic inliner impact compiler master thesis department computer science university illinois urbana il 
aho sethi ullman compilers principles techniques tools 
reading ma addisonwesley 
hwu mahlke chen chang warter hank holm superblock ective technique vliw superscalar compilation journal supercomputing vol 
pp 
january 
cheng compile time memory disambiguation programs 
phd thesis department computer science university illinois urbana il 
choi burke carini ecient ow sensitive interprocedural computation aliases side ects proceedings th acm symposium principles programming languages pp 
january 
rinard pointer analysis multithreaded programs proceedings acm sigplan conference programming language design implementation pp 
may 
rinard commutativity analysis new analysis framework parallelizing compilers proceedings acm sigplan conference programming language design implementation june 
ruf partitioning data ow analyses types proceedings acm symposium principles programming languages january 
ahndrich foster aiken partial online cycle elimination inclusion constraint graphs proceedings acm sigplan conference programming language design implementation pp 
june 
hasti horwitz static single assignment form improve ow insensitive pointer analysis proceedings acm sigplan conference programming language design implementation pp 
june 
zhang ryder landi experiments combined analysis pointer aliasing proceedings workshop program analysis software tools engineering june 
stocks ryder landi zhang comparing ow context sensitivity modi cations side ects problem international symposium software testing analysis pp 
march 
jones exible approach interprocedural data ow analysis programs recursive data structures conference record th acm symposium principles programming languages january 
larus hil nger detecting con icts structure accesses proceedings acm sigplan conference programming language design implementation pp 
july 
hendren nicolau parallelizing programs recursive data structures ieee transactions parallel distributed system vol 
pp 
january 
chase wegman zadeck analysis pointers structures proceedings acm sigplan conference programming language design implementation pp 
june 
hendren hummel nicolau abstractions recursive pointer data structures improving analysis transformation imperative programs proceedings acm sigplan conference programming language design implementation pp 
june 
