design automation embedded systems fl kluwer academic publishers boston 
manufactured netherlands 
phase coupled mapping data flow graphs irregular data paths steven ls cs uni dortmund de rainer leupers leupers ls cs uni dortmund de department computer science university dortmund germany editor 

software compilers embedded processors produce machine code insufficient quality 
applications software meet tight code speed size constraints embedded software largely developed assembly language 
order eliminate bottleneck enable high level language compilers embedded software new code generation optimization techniques required 
describes novel code generation technique embedded processors irregular data path architectures typically fixed point dsps proposed code generation technique maps data flow graph representation program highly efficient machine code target processor modeled instruction set behavior 
high code quality ensured tight coupling different code generation phases 
contrast earlier works mainly heuristics approach constraint 
initial set constraints code generation prescribed processor model 
constraints arise code generation decisions concerning code selection register allocation scheduling 
possible decisions postponed sufficient information decision collected 
constraints active background guarantee local satisfiability point time code generation 
mechanism permits simultaneously cope special purpose registers instruction level parallelism 
describe detailed integration code generation phases 
implementation constraint logic programming clp language eclipse 
standard dsp show quality generated code comes close hand written assembly code 
input processor model edited user retargetability code generation technique achieved certain processor class 
keywords code generation embedded processors phase coupling constraint logic programming 
embedded systems frequently implemented mixed hardware software systems 
software parts system executed embedded processors hardware parts mapped dedicated non programmable hardware asics 
assignment pieces system functionality software hardware guided time area power consumption metrics 
compared asics embedded processors show significant advantages 
processors offer high degree flexibility 
allows late changes system specification re programming 
software implementation facilitates reuse system components software written highlevel language hll may reused applications 
processor exists research funded deutsche forschungsgemeinschaft dfg ma form core model vhdl physical layout core reusable 
due benefits general goal hardware software codesign systems implement system functionality possible software flexibility reuse primary concern 
software implementation possible software implementation meets speed size constraints critically depends quality machine code 
hll compiler responsible code quality 
unfortunately currently available compilers embedded processors particular dsps microcontrollers generate code insufficient quality 
confirmed numerous system designers empirical studies 
consequence large part embedded software written manually assembly language level 
due growing complexity embedded software embedded processors approach obviously longer viable hll compilers compulsory 
efficient compilers embedded processors highly desirable 
system implemented software hardware compiler may important costs system implementation hardware synthesis tool 
code quality flexibility compilers important issue 
embedded processors general efficient standard shelf processors exist large variety 
addition applicationspecific processors asips intended serve narrow range different applications 
order avoid necessity huge number different compilers embedded processors concept retargetability introduced 
retargetable compilers capable mapping hll code different target machines certain processor class 
retargetable compilers facilitate migration target processor 
furthermore retargetable compilers important hw sw codesign permit fine grained exploration hw sw trade 
usually retargetability high code quality contrary goals 
certain degree retargetability goal compiler construction developing target specific code optimization techniques different asip economically reasonable 
outline general difficulties code generation specific class embedded processors fixed point dsps novel solution approach 
approach target processor modelling formalism retargetability achieved large range processors 

constraints irregular data paths main challenge high quality code generation dsps caused irregular data path architecture processors distributed specialized register files rfs functional units fus 
causes strong mutual dependencies rfs fus due restricted interconnections resources 
turn leads strong dependencies different code 
adsp data path rts instruction types af mx mf ax ar ay ar ar ay ar ax ay ar ay mx mx operation operation ax mx ay operation typ operation operation alu mac typ typ operation typ memory memory machine instruction types register transfer operations rts ar ax ay mx generation phases 
furthermore certain degree instruction level parallelism ilp usually available exploited order generate highquality code 
hand ilp dsps restricted parallelization certain instructions due strongly encoded machine instruction formats 
currently lack techniques tools capable simultaneously handling restricted ilp irregular data paths difficult obey resulting large amount constraints code generation 
generally talk storage resources srs comprise rfs memories 
talk rfs important distinguish register files memories 
example order exemplify typical constraints consider adsp fixed point dsp 
primitive entities instruction behavior model register transfers rts 
rt reflects operation 
performed sr result operation stored srs operands operation reside 
fig 
partial data path adsp corresponding rts shown 
furthermore classification instruction types type accounts certain permissible combination rts operations moves machine instruction 
data path consists fus alu mac srs consist set far ax ax af mx rfs memories operands rts required special srs 
addition instance left operand required srs ax ar right operand ay af result stored accumulator ar feedback register af adsp fu operation move operations memory registers executed parallel corresponds machine instruction type typ fig 

requires move values located destination move ax mx destination move ay 
destination result operation executed fus alu mac restricted accumulators ar respectively 

phase coupling problems 
code generation phases machine code machine independent optimisations front code generation cs sequ 
ra ir fig 
coarse grain structure compiler illustrated 
front checks source program syntactical semantical correctness generates intermediate representation ir program 
code generation frequently called back concerned mapping ir sequence machine instructions mis target processor typically assembly binary code 
machine instruction comprises set rts executed parallel 
traditional code generators execute set phases strictly sequentially 
fig 
shows possible ordering basic code generation phases ffl code selection cs typically performed phase 
concerned mapping operations ir rts target machine 
ffl register allocation ra decides values reside registers reside memory point time program execution 
ffl instruction scheduling sense concerned finding sequential ordering selected rts 
goals reduce register usage prevent pipeline stalls risc architectures 
context ilp denote parallelization rts increase code speed frequently called code compaction 
mentioned explicitly meaning instruction scheduling remainder 

dft cover mx ar ax ay ar mx ax ay disadvantage sequential phase ordering decisions phase severely constrain phases 
example consider dependence cs current code selectors tree covering operate data flow tree dft irs basic blocks 
rts represented tree patterns pattern assigned cost value 
code selection performed covering dfts tree patterns minimizing total costs 
example covered dft shown fig 

tree able select locally optimal covers optimality refers sequential execution model 
underlying computation model determining optimal covers permit modeling ilp 
selection cover implies certain selection srs operands results selected rts 
ilp prevented unfavorable cs decisions 
fig 
optimal cover example dft adsp rts tree patterns shown 
selected rts hardly parallelized conflict constraints ilp adsp 
shown shorter schedule achieved different dft cover selected cs 

optimal dft cover neglecting ilp ar af ar ay ay ar ay ar ar ay ar ar af ar ay ar ay ar ar ay af ar ay ar ar af 
representation multiple rts frt ar ar ay ar ax ay ar ax af ar ar af frt ar ar ax ay af set rts 
representation covers frts ar ax ay af ar ax ay af ar ax ay af ar ax ay af ar af ar ax ay af ar af ar ax ay af ar ax ay af ar af ar ax ay af ar ax ay af 
phase coupling approach order improve code quality irregular architectures tight integration phase coupling code generation phases required 
exploitation potential ilp decisions postponed code selection register allocation integrated instruction scheduling 
order enable integration code selection covering technique computes set possible covers data flow graph dfg representation basic blocks efficiently single pass 
reduce set covers locally optimal solution retain set alternative covers remaining code generation process 
represent covers rts matching node dfg combined factorised rt frt fig 

frts concisely represent set similar rts 
frts locations result operands set alternative srs separated character 
set alternative covers represented frt cover dfg denote dfg frt fig 
shows dfg frt dft fig 

different options constructing dfg frt implemented techniques generate optimal covers respect sequential execution model 
may faster techniques partially reduce set initial covers code generation example enforce chained operations mac operation possible 

integrated code generation frts ax ay ax ay ax ay ax ay ax ay ax ay schedule schedule schedule schedule ax ay ax ay ax ay ax ay ax ay ax ay ar ax ay ax ay ar af ax ay ax ay ar ax ay ax ay ar af ax ay ar ax ay ax ay af ax ay ar af ar af dfg frt representation developed fully integrated technique code selection register allocation instruction scheduling 
basic concepts illustrated fig 
scheduling frts dfg frt fig 
fig 
shown 
example scheduling data transfers variables machine instruction corresponding frts reduced 
reducing frt means delete members set rts represented frt meet constraints ilp restrictions resources feasible instruction types 
adsp typ allowing parallel execution data transfers memory registers cmp 
fig 

rts sources destinations ax ay feasible operation 
srs af ar eliminated destinations frts 
remaining flexibility due commutativity addition see schedule 
decision variables loaded ax ay postponed 
generally may generate higher flexibility subsequent decisions 
scheduling variables leaves freedom schedule locations reduces possible locations addition result ar order meet ilp conditions 
locations variables determined immediately scheduling subtraction schedule 
schedule determines result location subtraction node 
implementation code generator constraint logic programming clp language eclipse 

overview section concerned related phase coupling approaches 
section gives overview constraint programming framework code generation system icg 
section internal machine model code generator retargeting mechanism described 
section describes concepts tree covering approach frt covering generating sets dfg covers 
integrated register allocation technique described section followed integration instruction scheduling section 
section comprises complexity analysis approach 
section describes post processing steps required generate executable code experimental results 
section gives mentions 

related traditional standard techniques homogeneous architectures described dragon book 
advanced techniques general purpose processors 
early contribution emphasizing phase ordering problems context microcode generation 
order compare existing phase coupling approaches give classification phase coupling approaches cases ffl regular architectures considered distinguish ilp considered 
case ilp orthogonal vliw parallelism assumed mutual dependencies srs fus neglected 
ffl irregular architectures primary concern 
differentiate classes approaches neglecting ilp 
approaches considering ilp heuristic techniques 
approaches considering ilp exact techniques 
distributed resources concern classify approaches sets resources simultaneously captured 
reflect coupling degree cs ra tree covering important context phase coupling problems dsps give overview existing approaches 
describe phase coupling approaches classification 

tree covering techniques effort put design efficient tree pattern matchers efficient code selector generators 
initiated graham lr parsing techniques pattern matching target machine specification defined context free grammar 
parser generator generating code selector basic problem approaches potential ambiguity required instruction set grammars 
tree pattern matching dynamic programming constituted solution problem 
code selector generators map specification target instruction set dedicated code selector 
specification techniques weighted regular tree grammars 
tree grammars represented set tree reduction rules form pattern cost action 
action part defines output code selector 
generated code selectors passes expression trees 
pass bottom finds covering minimum costs 
second pass top emits code 
examples code generator generators model beg twig burg iburg 
beg iburg tree pattern matchers hard coded mirror tree patterns recursive descent parsers mirror input grammars 
twig matchers table driven variant string matching 
table driven approaches finite tree automata move dynamic programming compile compile time 
tree pattern matching technique capable handling distributed sr fus 
tree pattern matchers capable computing set covers required delayed resource binding 
dsp related approaches application code selector generators :10.1.1.57.5855:10.1.1.48.4459
cbc machine description hardware description language nml 
machine specification transformed iburg specification code selector generated extended version iburg 
cbc developed irregular architectures 
instruction level parallelism supported delayed binding fus 
cbc tries take account common subexpressions cross basic block boundaries means heuristic node duplication 
control data flow graph modified order create complex rts basic block boundaries node duplication 
edges pruned order provide faster code selection dfts basic block architectures satisfying socalled rtg criterion 
code selectors generated code selector generator olive 
technique constructing spill free schedules machines satisfying model rtg criterion 

phase coupling regular architectures early approaches coupling code selection sequential instruction scheduling register allocation yielding optimal solutions trees architectures homogeneous register file ilp 
approaches concerned coupling register allocation scheduling 
consider ilp neglect irregularities target architecture 
register allocation tries reuse registers possible adding additional false dependencies constrain instruction scheduler ability reorder machine instructions 
instruction scheduling tries rts possible 
results high register pressure drastically increases amount interferences 
approaches exchange information phases 
goodman hsu manipulate scheduler data dependence graph width larger number registers available 
second method integrated pre pass scheduling ips local scheduler restricted fixed number registers local values 
register limits reached scheduler tries free registers increase register limit 
subsequent local register allocation generate spill code enforces rescheduling 
compares strategies graph coloring followed scheduling 
strategy improvement ips 
second called performs initial passes instruction scheduler estimating local schedule costs limited number registers maximum number available registers 
computed estimations priority scheme graph coloring followed local list scheduler 
freudenberger describes method integrates greedy register allocation trace scheduling order provide global optimisation 
approach data dependence graph incrementally respect global aspects utilised utilised regions resource requirements 
register allocation performed fly appropriate spilling 
approaches start initial register allocation 
instruction scheduling false dependencies eliminated dynamic renaming 
works graph coloring register allocation considering aspects parallelism norris add edges interference graph estimate re ordering effect instruction scheduling 
pinter constructs interference adding additional edges 
constructs graph data dependence graph transitive closure dependence edges placed graph undirected edges 
target machine resource conflicts added restrict parallel execution machine operations 
resulting graph graph complement constructed union register allocator interference graph constructed called parallel interference graph 
proposes method late register allocation limits additional interferences false dependencies limit instruction scheduler 
spilling necessary late register allocation switched back early register allocation 
early interference graph augmented edges exclusively late interference graph colored color early interference graph 
works graph coloring 
mutation scheduling takes account distributed fus 
integrates code selection register allocation instruction scheduling 
value program associated set alternative functionally equivalent expressions called mutations different set resources target architecture 
scheduling alternatives selected 
resources occupied mutation selected 
mutation sets change dynamically scheduling 
value moved register register added mutation set 
value spilled load entry corresponding location added 
initial register allocation performed 
contrast approaches spilling integrated 
re computation value considered mutation 
contrast equivalent expression selected 
issues irregular register sets ilp conditions considered 

phase coupling irregular architectures 
ilp considered approach combined code selection register allocation represented 
approach covering addresses accumulator architectures 
yields optimal results acceptable time small basic blocks 
approach paulin performs tree pattern matching dynamic programming delays binding locations result operands due register class specifications associated patterns 
interdependencies locations considered 
register allocation performed left edge algorithm 
free location value location bound 
register allocation take ilp account 
postpass compaction phase 

ilp heuristic approaches data routing incorporates register allocation distributed register files instruction scheduling 
aim data routing selection routing paths values 
bulldog compiler ellis performs local scheduling greedy register allocation fly 
data routing performed order support ilp 
spill decisions considered 
approach combining delayed binding fus consideration different data routes proposed 
distributed register sets finegrain parallelism taken account 
storage resources composed storage resources enable delayed binding srs 
code selector performs traditional tree pattern matching dynamic programming 
trace scheduler generated machine specification guide order choices trace scheduler respect requirements target machine 
trace scheduler performs register allocation fly 
rimey hilfinger perform local scheduling greedy binding fus register allocation fly 
pattern matching rts performed scheduling 
rt try find data routes definitions uses rt rt scheduled current instruction cycle 
data routes compatible current schedule 
hartmann approach refinement rimey hilfinger extended deadlock detection 
fus bound advance 
approach proposed determines data routes ilp account 
examines various data routes considering global spilling re computation 
selection data routes value guarded cost model distribution graphs 
fus operation bound advance 
retargetable code generator mssq embedded mimola software system simultaneously performs binding fus local instruction scheduling considering set machine instruction types :10.1.1.122.9899
variables pre allocated certain srs defined user 
temporary values allocated register cells fly pattern matching 
algebraic transformation rules considered spill code generation 

ilp exact approaches approaches strategies yielding optimal solutions 
code generation phases described form constraints generally linear equations inequations 
complete solution space explored constraints considered simultaneously leading complete phase integration 
approach performs instruction scheduling integer programming ip approach yielding optimal solutions 
code selection register allocation performed advance iburg generated code selectors 
results binding srs 
binding fus delayed scheduling 
complete integration code selection register allocation instruction scheduling ip 
wilson approach leads high runtimes due large ip models 
approach takes advantage describing constraints horn clauses 
mapped linear programming problems solved efficiently ip problems 
restricted classes architectures handled efficiently approaches 
architectures comprising register files multiple registers adsp typically lead explosion generated models 
covering approach finding minimal set vliw instructions ilp account specified 
approach covering 
detailed register allocation performed post processing phase 

non phase coupling approaches irregular architectures exact scheduling method architectures highly constrained ilp bipartite graph matching described 
search space pruned advance eliminating feasible schedules benchmarks results acceptable time 
resources fixed advance quality generated code depends earlier phases 
approach loop pipelining constraint analysis described 
resources bound advance 
resource constraints mapped dependency relations feasibility check holds schedules generated conventional scheduler 
infeasibility leads re binding registers means register assignment possible generation new sequencing constraints 
approach iterates feasible schedule re binding registers possible 
approach dfg covering bdds 
covering extended yield certain binding operations fus 
single covering resources fixed selected 
underlying cost criterion selection 
second phase list scheduling algorithm extended spill code insertion generates final schedule 
due fixed resource binding phase heavily depends covering phase 

main differences approach address irregular architectures ilp register files capacity larger 
code selection approach generates dfg covers respect set rts frts 
covers contain associated resource information mutual dependencies resources form constraints 
basic difference approach mentioned new concept delayed sr fu binding 
contrast existing approaches fix resources forced 
keep alternatives solutions long possible decision procedures information available 
integrated flexible spilling strategy 
approach spilling restricted loads stores memory 
order avoid exhaustive runtimes consider complete solution space ip approaches 
shown tight integration code generation phases allows generation high quality code 

constraint code generator icg section begins overview constraint programming outline constraint implementation 
overview components code generator icg system functionality data flow 
section ends remarks benchmark set evaluating system 

constraint programming model phase coupling code generation form constraint satisfaction problems csps 
short informal explanation 
csps represented set variables set constraints describing dependencies variables 
variables associated certain domains sets values 
csp solution mapping variable certain member domain meets constraints 
goal find valid solution optimal solution objective function 
algorithm determining satisfaction set constraints called constraint solver 
certain application domains exist dedicated solvers 
general technique solvers rewrite constraints called solved form clear solution exists gauss jordan elimination linear arithmetic constraints 
icg written constraint logic programming clp language eclipse 
eclipse prolog comes set domains dedicated constraints solvers search optimization strategies 
basic technique clp systems constraint propagation 
constraints occurring constraint logic program collected constraint store executing program 
adding new constraints generally leads reduction certain domains 
collected constraints operate background locally check feasibility domains eliminate members domains lead invalid solutions 
example consider variables associated domain 
impose constraint domain reduced legal assignment meeting constraint set 
feasible solution domain reduced 
setting leads reduction domain 
call variables domain variables 
domain variable reduced call reduction variable 
solving performed second phase consists labeling variables certain members domains 
constraints guide feasible labeling variables 
assignment meet set constraints rejected leads backtracking 
eclipse designed solving difficult combinatorial problems area scheduling resource allocation 
eclipse system offers predefined search strategies ordering selecting variables members domains provides direct control search strategies user 
addition propagation techniques mixed integer programming mip stochastic techniques simulated annealing supported 
eclipse enables user mix techniques order build hybrid search strategies 
provides powerful mechanisms define new domains constraints new search strategies solvers directly eclipse 
implementation effective finite domain fd library alternative resource sets implemented finite domains 
library provides predicates setting domains predefined constraints finite domains 
access domains variables predicates creating new domains existing ones known set operations updating domains variables 
features extensively specification new constraints needed system 
new complex constraints defined ffl set existing elementary constraints provided library ffl low level predicates direct domain access modification ffl making usage generalized propagation approach cf 
library manuals eclipse 
eclipse allows specifying conditions priorities constraints order prevent unnecessary 

icg system overview overview components code generation system icg communication components shown fig 

source programs mapped control data flow graphs 
basic blocks program represented data flow graphs 
current version data flow oriented parts program supported 
focus input icg 
second input model target machine code generated 
output icg sequence machine instructions form set parallel frts 
system comprises basic components 
frt covering dfg mapped initial dfg frt representing set covers input dfg 
comprises setting domains variables representing alternative resources variables generating constraints specifying mutual dependencies resources 
constraints guide concise reduction variables remaining code generation phases leading legal covers section 

pruning covers set strategies provided allow prune set covers advance 
includes reduction set optimal covers dfts 
allows reduce certain domains advance possible specify locations allowed common subexpressions 
strategies include labeling optimization strategies 
result smaller set alternative covers form reduced domains 

integrated register allocation ira integrates code selection register allocation comprises techniques data routing spilling section 
integrated instruction scheduling iis extends concepts developed ira instruction scheduling regards ilp section 
iis maps dfg frt sequence compacted machine instructions represented sets frts 
ira iis set new domain variables constraints 
data routing spilling data moves inserted 
constraints guarantee data moves feasible context current covers provide guidance register file resources exceeded inserted 
ilp constraints added guide concise reduction variables order meet ilp conditions 

labeling generates certain mapping variables resources 
serves feasibility check 
constraints check local feasibility may 
system overview dfg target machine model pruning covers reduction resources register allocation ira integrated instruction scheduling iis frt covering address generation post compaction post processing binary code icg labeling solving source program map set list frt sets machine instructions dfg dfg frt frt happen exists solution satisfies constraints 
case exists solution allow certain constraints violated insert correction code additionally post processing phases address generation 
phases executable code generated apply techniques developed earlier record compiler project 

remarks benchmarks run times evaluate system benchmarks benchmark set evolves standard benchmark set dsp compiler community 
icg currently able generate code data flow components programs basic blocks selected programs basically data flow oriented complex multiply complex update iir filter lattice filter 
basic blocks selected benchmarks represent realistic representative examples regards basic blocks benchmark set 
additionally set internal benchmarks tested large basic blocks upto nodes edges 
compared generated sequences machine instructions benchmarks hand written code results dedicated gnu compiler adsp 
metric code size 
basic blocks indicates code performance primary goal approach generate high quality code 
compilation speed secondary concern long acceptable range 
feasible compilation times minor concern embedded software run times hours acceptable certain cases 

internal machine model section describes internal model target machine code generator 
model frts 
understanding internal machine model quite essential understanding code generation techniques described section 
internal machine model comprises description instruction set form available set rts constraints ilp information address generation units specific control functions 
contribution concentrate set rts modeling ilp 
code generator re targeted exchanging internal machine model techniques dedicated certain processor model 
approaches modeling instruction sets strongly constrained ilp provisions retargeting major phases code generation 
approach constraints allows concise compact specification methodology 
introduce new concept modeling highly constrained ilp instruction types allows intuitive specification method 
notations set sr denotes available srs 
fu set fus set denotes set machine instruction types modeling ilp 

register transfers model rts rt patterns extended resource information eri 
rt pattern reflects operation srs result stored srs operands expected 
example sr fa cg rt denotes addition second operand reside srs respectively 
result stored sr call definition rt uses 
define functions def rt rt op un def rt denotes rt denotes written 
transfer operations tos specific rts form denote transfer value sr sr section fig 
rts adsp shown 
triple eri fu extended resource information denotes type consumed fu fu fu cost rt 
costs means instruction cycles necessary executing rt 
eri important meeting scheduling constraints rts resulting code 
types fus model potential parallelism rts 
rts executed parallel encoded instruction type consume fu fu 
factorised rts usage factorised rts frts code generator twofold 
explained frts represent set covers cf 
section 
frts concise specification internal representation set rts target machine matching frts derived covering 
consider subset rts implementing addition adsp far ar ay ar ay ar ax 
alternatives location operand ar ax 
combine rts single representation means example result frt ar ay represents set alternative srs 
model frts rt pattern set constraints 
rt pattern definition representing domain variables 
domain variables associated certain set srs 
set constraints define domains variables certain dependencies 
instance frt ar ay set constraints fd ar far 
call domain variable rt pattern location dom denotes domain domain variable dom far 
substitution locations frt assignment certain sr location 
feasible rts represented frt obtained set substitutions frt 
say frt orthogonal substitution locations yields feasible rt 
frt called constrained exist dependencies locations 
consider set rts fc bg frt fc ag fc ag 
need constraint order describe dependencies formulated sufficient 
set leads reduction order meet constraint 
adding new constraints frt domains variables may reduced 
turn may imply reduction set rts 
notation frts op dn set constraints dom dom dn dom un 
op dn interested denoting variables 
apply factorization eri 
achieved adding constraints domain variables allows define dependencies locations resource information 
way obtain compact specification target machine models 
allow compose frt set frts having rt pattern 

factorised machine instructions machine instruction set rts executed parallel 
set rts rt rt called compatible rt legal machine instruction 
concept factorization extended machine instructions means representing set frts set constraints guiding reduction frts obtain feasible machine instructions 

example analog devices adsp example fig 
frts adsp shown form tree patterns 
frts merged isomorphic 
factorised extended resource information types consumed resource fu 
costs mentioned costs equal shown frts 
rts modeled frt executed machine instruction type typ 
constraints model ilp condition typ enforces result rt located accumulator feedback register af mf 
constraint denotes result rt located feedback register rt included machine instruction typ typ 
frts modeling parallel transfer operations explicitly frt frt 
ilp modeled extended resource information plus resource description type machine instruction 
resources specified instruction field consumed rt machine instruction machine instruction types fig 

resources instruction type typ 
frts adsp af mx mf ax ar ay typ typ typ typ alu alu alu alu bus bus ar mx mf mf ar ax ay af ar af mf ar mx mf ay ax mx frt frt frt frt machine instruction types frts operations frt frt frt typ typ typ typ alu typ typ typ typ typ alu typ typ typ typ typ alu typ ar typ bus typ bus typ typ typ bus ar ax ay frts transfer operations 
sufficient model fus single resource alu rts executed fus performed parallel adsp 

retargeting code generator specification machine model input code generator 
parts specification adsp shown fig 

frt specified quintuple un eri constraints un domain variables denoting operation definition uses un eri typ fu cost domain variables denoting extended resource information constraints set constraints specifying dependencies variables transfer operations explicitly 
resource declarations permit introduce macros sets resources mems define sizes srs 
machine type declaration part relates machine types available fus type 
retargeting code generator performed generating set constraints specification eventually yields internal machine model ffl frts constraint match uses derived 
operation derive domains constraints input variables 
operands uses form list un domain variables 
ffl relation derived transfer operations 
holds value transfered single transfer operation 
ffl binary relation denotes reflexive transitive closure transfer operations 
holds value transfered sequence transfer operations 
ffl holds value transfered sequence transfer operations 
ffl constraints intf ilp derived declarations machine instruction types 
guide correct reduction machine instructions set frts order meet ilp conditions target machine 
furthermore functions yielding resource information sizes srs provided part machine specification 
techniques code generator constraints functions interface internal machine model 
far able handle target machine classes single cycle instructions 
specification frts fig 
represents high level specification methodology defining constraints provided eclipse certain mathematical symbols represented strings available text editors denoted 
derived constraints frt covering generalized propagation approach 
constraints intf ilp generic extensive usage low level predicates domain access provided finite domain library eclipse 

partial internal machine model adsp operations frt operation result typ alu operation result ar af ax ar ay af instr typ typ typ typ result af 
typ typ 
frt result typ alu cost result mf virtual sr mac operation 
mx ar mf cost cost mac operation 
typ typ typ typ typ result mf typ typ result cost 
frt operation typ alu operation typ typ typ typ typ 
frt operation result instr alu operation result ar af ay af typ typ typ typ typ result af typ typ 
frt const typ alu typ typ typ typ typ 
frt const result typ bus typ typ typ regs result 
transfer operations transfer src dst typ regs src 
transfer src dst typ regs src 
transfer src dst typ dst regs src 
resource declarations faf mf ar ax ay mx dg 
resource classes frts 
regs far ax ay mx 
mems fp dg 
size ar 
size ax 
machine instruction declaration instr typ alu 
instr typ alu bus 
instr typ alu bus 
instr typ alu bus 
instr typ bus 

code selection frt covering section review traditional approaches code selection means tree pattern matching dynamic programming 
introduce concept generating representing set covers means frt covering 
frt covering central issues icg 
goal provide representation set alternative covers able integrate code selection code generation phases 
goal select certain cover generate set alternative covers enable flexibility making decisions subsequent phases 
approach extended means account data routes definitions multiple uses 
additionally derived techniques pruning set alternative covers 
strategy generation optimal covers dfts neglecting ilp 
techniques labeling optimization strategies eclipse 
information optimal covers partially reduce initial set alternative covers 
overview section 

tree pattern matching dynamic programming current tree covering approaches tree pattern matching combined dynamic programming 
tree pattern matchers determine set possible covers dft 
order select locally cheap cover set possible covers tree pattern matching combined dynamic programming 

tree patterns ar mx mf mf ar ax ay af ar af ar ax ay af ar af mf ar mx mf mf ar mx mf rts represented tree patterns 
fig 
tree patterns adsp shown factorised form 
edges tree patterns associated srs required result operands 
srs taken account covering 
consider operation node fig 

nodes matched tree patterns rt rt generally tree pattern op un matches node operation op def rt exists sequence transfer operations move value def rt ng 
consider tree pattern depicted node 
matching second operand feasible exists data transfer ar ar 
approaches bottom tree pattern matching 
bottom tree traversal possible covers set rt patterns constructed simultaneously 
node tree labeled set matching tree patterns 
selection certain cover set possible covers done dynamic programming 
efficient technique create locally optimal code dfts 
nice feature code selectors generated automatically code selector generators 
retargetability supported 
require formal description target instruction set tree grammar tree pattern represented rule tree grammar srs represented nonterminals grammar 
rule associated cost action 
action describes emission code corresponding rule main drawback approaches dynamic programming ilp taken account contradict paradigm dynamic programming optimal solutions tree computed optimal solutions subtrees solutions subtrees independent 
additionally case inhomogeneous srs spill costs taken account 

frt covering subsection generation set alternative covers described 
pattern matching approach labeling dfg node frt denotes set rts matching denote operation associated node dfg op refer value generated operation value operand argument operation op 
frt associated node denoted frt frt represented set domain variables dv fd eri denotes definition frt denotes frt required location operand eri set domain variables ft cg corresponding extended resource information frt set matching rts determined frts internal machine model 
perform matching node applying constraint match cf 
section yields frt frt performed bottom traversal dfg 
operand frt apply constraint order take account distributed srs 
ensures exists path definition constraint eliminates dom dom sequence operations moving value exists 
reduction domains may lead reductions frt frt dependent associated constraints 
special handling dfg nodes program variables leaves common subexpressions 
node denoting program variable set possible initial locations basic block associated 
covering frt associated nodes domain variable denoting location 
location considered definition remaining covering process 
common subexpression cse associate extra variable covering common subexpressions rooted node handled defining relation machine specification formalism allows define certain allocations values special constraint cse loc 
cse loc generated cse uses handled uses operands 
frt cse generated 
legal covers left pattern matching 
code generation consists reducing domains domain variables frt reduces single rt 
constraints associated frts guide correct reduction domains order yield feasible rts 
clp framework eclipse constraints activated automatically domains variables reduced 
example fig 
covering reduction process exemplified 
reduction partial dfg essential domain variables shown left column fig 

new generated constraints re activations shown right column effects constraints described 
rows depict matching process dfg nodes respectively 
sake simplicity data move constraints cse uses shown generated application 
handling extra variable omitted 
constraints known fulfilled cause reduction variables reactivated killed 
row shows situation matching node 
result location node may locations fmr mf denotes virtual resource handle chained operations cf 
section 
second row row shows situation matching node 
new data move constraints generated 
specifies exists possibility move data mf sr mapped mf uses mapped mf denotes constraint modeling chained operations cf 
section 
equality hold removed domain order meet equivalence constraint 
row shows results matching node 
new generated data move constraint eliminates mf mf member alternative srs modification domain removes mf domain 
fulfilled killed 
fulfilled member 
frt covering mf mx mf mf mx mf mf killed killed killed mf mf mf mf eliminates mf eliminates mf eliminates fulfilled ar ax fulfilled row row row fulfilled fulfilled table run times frt covering selected benchmarks shown 
run times sparc cpu seconds 
runtime data indicate frt covering efficient 
frt covering internal benchmarks range seconds 
table shows characteristics benchmarks number dfg nodes dfg edges number 
coarse worst case analysis complexity frt covering 
complexity depends factors 
assume dfg nodes node maximum constraints activated 
constraint uses variables maximal size domains complexity constraints specifying frts depends number variables domain sizes denoted 
cases holds 
limited sizes 
range 
depend machine model depends maximal uses average benchmarks far 
limited maximal amount fus srs instruction types 
constraints generate disjunctive 
reactivation constraints triggered reduction domain variables 
constraint reactivated times 
total 
take maximal ranges account assume get complexity constant machine model 
important result analysis generally exponential number alternative covers representation linear size number dfg nodes means frt covers 
table 
run times frt covering source runtime dfg nodes dfg edges complex multiply complex update iir filter lattice filter 
pruning set alternative covers special application frt covering developed techniques pruning set alternative covers 
comprises ffl reduction certain variables srs specified target processor 
ffl generation optimal dfg covers neglecting ilp 
frt covering procedure stand optimal code selection technique dfts 
noted result set optimal covers contrast traditional approaches single optimal cover produced 
ffl information optimal covers order partially reduce set alternative covers 
adsp copy chained operations mac operations occurring optimal covers initial set alternative covers 
techniques generating optimal covers dfts consume exponential run times worst case 
due fact frt cover may represent exponential number alternative covers number dfg nodes 
worst case complete search space explored order find optimal solution 
experiments shown optimal dft covers generated efficiently time critical 
noted techniques dynamic programming faster order magnitude average 
experiments shown optimal dfg covers generated small medium size nodes reasonable amounts computation time cf 
table 
developed suboptimal strategy larger leads acceptable run times 
strategy labeling domain variables roots dfts uses basic block postponed usage labeled 
generally leads better results compared accumulated optimal costs dfts comes close optimal solution 
results shown table 
costs shown table denote accumulated costs dfts occurring basic blocks 
column denoted dft shows results optimal covering dft column shows suboptimal column optimal results 
run times cpu seconds 
uses may occur different dfts different orderings optimizing dfts basic block lead different results occurred internal test cases 
internal benchmarks sub optimally covered minute dft strategy minutes cse strategy 
optimal covers computed larger internal benchmarks acceptable time 
experiments suboptimal strategy order determine chained operations 
resources corresponding dfg nodes reduced necessary 
table 
optimization strategies source dfts time time time complex multiply complex update iir filter lattice filter 
integrated register allocation section integration code selection register allocation described 
includes tasks spill code generation data routing ffl spilling required number live values located certain sr exceeds sr capacity 
case values selected moved srs 
spill code inserted means transfer operations spill location reloading uses 
ffl data routing determines sr paths value take definition uses 
includes selection resources transfer operations implement paths 

sequentialization dfg frt ar ay ar ay ar ar ay af ar ay ar ar af ar af ar ax ay af ar ax ay af ar af ar ax ay af ar ax ay af ar af ar ax ay af ar ar ay ay ar af ar ay ay ar ar ar af ar af ar ax ay af ar ax ay af lvs ar af ar ax ay af ar ax ay af ar af ar ax ay af order frts schedule optimal cover input ira ira expects sequence frts sequential schedule dfg frt note sequence contain transfer operations cf 
fig 

inserted register allocator means data routing 
second task register allocator include necessary spill code 
register allocator keep track locations live values 
information means live value set lvs 
lv lvs tuple pl pl denotes current location value initial lvs register allocator contains locations variables live basic block cf 
fig 

respect live value set lvs denote frt data ready iff operands entry lvs ready iff operands required locations denoted predicate ready frt lv 
ready frts data ready definition 
sequence frts generated schedule optimal cover dfg 
schedule generated heuristic sequential instruction scheduling technique irregular data paths 
approach tree optimal dfg frt decomposed sequence frt trees 
instruction scheduling performed subsequently trees 
ordering reconstructed dfg frt representing set alternative covers fig 

register allocator traverses frt sequence 
frt inserts new live value definition lvs order provide subsequent frts locations operands 
operand location transfer operations inserted 
new locations inserted lvs see fig 

give informal description algorithm ira 
detailed description subsections 
sequences represented lists denotes concatenation lists 
represents empty list 
head gives element tail ffl input frt sequence frts basic block initial set lvs containing locations variables live basic block 
ffl output frt sequence frts ffl algorithm frts 

frt head frts 
operands ready operand frt ready generate necessary transfer operations may induce spilling insert spill code form list transfer operations sc results list transfer operations dm sc operand final list transfer operations operands dm dm dm jn 
uses eliminate uses lvs 
live values referenced frts frt live basic block 

add definition check spilling necessary inserting new live value definition frt spilling required generate necessary spill code sc 
insert new live value def frt definition frt lvs 

frts frts dm sc frt 
frts tail frts algorithms represented imperative style sake simplicity reflect backtracking features original implementation eclipse 
aspects backtracking mentioned required descriptions 

insertion transfer operations spill code frt frt inserted data moves operands frt spill code frts frts sc dm 
data routing operands current location operand lvs 
required locations operands frt list uses register allocator performs strategy check operands required locations 
uses determined operands required locations condition holds 

operands required location transfer operations inserted 
may result sequence transfer operations frt single step relation hold 

illustration data routing ar ar ay ay frts ar ar ax ay af ar ax ay af frts ira lvs ar lvs ar frt transfer operation frt example consider example fig 

register allocator reached frt checks locations operands 
locations operands lvs location operand ar means located accumulator ar 
operand located memories 
checked operand required location 
case operand condition holds 
equality leads reduction dom farg 
order yield feasible rts dom reduced faf 
operand required location 
transfer operation inserted 
single step relation hold 
order meet constraint location reduced ay af reached single move memory memory equality constraint leads reduction domains locations 
example domains reduced ar 
constraints equality hold code generation 
attached locations guide domain reductions 
case equality reduction domains enforce reduction domain 
data transfer new live value inserted lvs 
insertion new live values lead spilling 
spill code inserted transfer operation induced spilling 
generation spill code transfer operation form save value location spill operation performed new location spilled value 
irregular data paths spilling may enforce spilling values 
sequence spills spill operations need generated 
code induced data move may form spills 
checking operands uses eliminated lvs 
uses live values remaining sequence frts considered register allocator 
case values live basic block subsequent basic blocks kept lvs 
mechanism provides flexible data routing leaves freedom subsequent decisions possible 
locations reduced necessary 
location current location operand sufficient reduce locations domain achieved equality constraint 
holds inserted transfer operation 
result data routing technique yields set alternative data routes 
specific data routing 
required sr due multiple uses 
entry lvs may occur 
may support paths common prefixes paths transfer operations 

spilling new live range inserted lvs checked sr capacities exceeded rfs 
spilling live value lvs performed 
fixed assignment values srs capacities exceeded determined simply counting values sr determine necessary spilling extended notion interference known graph coloring register allocators 
say live values interfere overlapping life times intersection domains locations empty 
interfering live values assigned different registers 
insert new live range nlr necessary condition spilling number interfering members satisfies condition jdom nlr new live value fig 
interfere live value lvs intersection domains empty locations reduced register 
second example live values interfere reduced different srs 
order guarantee inequality constraint generated live values 
example spilling performed substitution locations result identical locations 
set live values interfere new live value called set spill candidates 
necessary spilling condition holds apply strategies 
reduction necessary condition spilling enforce spilling 
situations spilling prevented means reducing domains locations 
try reduce domains locations spill candidates necessary condition spilling violated reducing number interfering live values 
try reduce domain location new live value necessary condition spilling violated 
select spill candidates multiple entries lvs live values 

spilling reduction performed select spill candidate lv spill spill location generate spill code 
spilling necessarily performed memory free registers spilling 

interference live values ar af ax ay ar af ar af ar af ax ay ar af ar af ar af ar af ar af spilling 
prevention spilling reduction ar af ar ax ar ax ay ar af ar ax ar af ax ar af ax ar af ar af ar af ar af reduction reduction ax ay ax ax 
reduction strategy basic idea reduction strategies reduce domains live values intersection domains empty 
leads reduction interfering live values may violate necessary condition spilling 
try reduction strategies new live value lv ffl strategy applies exists spill candidate lv dom lv ae dom lv 
case reduce domain corresponding spill candidate difference dom lv dom lv 
example shown fig 
reduction 
ffl second strategy applies exist spill candidates lv dom lv ae dom lv 
case reduce domain new live value lv 
example shown fig 
reduction 
ffl select live value cse multiple entries lvs required locations 
strategies select candidate reduction simple 
candidate list spill candidates domain reduced selected 
applies multiple lvs entries 
development powerful selection functions potential improvements 
backtracking guarantees strategies applied automatically tried 
furthermore code generation process subsequent phases fails backtracking enforces selection alternative strategy 

spilling strategy selection spill candidate driven order criteria 
select candidate required locations uses 
case overhead produced candidates transfer operation necessary anyway 

select candidate latest occurrence remaining sequence frt frts 

select candidate smallest number remaining uses frt spilling necessarily performed memory 
factorised transfer operation inserted denoting possible locations reached actual location lr spill move fig 

spilling rfs advantage transfer operation saved spill location operand satisfy condition advantages mentioned section 
spilling may induce spilling values 
order spill required operands provide mechanism prevent certain live values lvs spilled 
case spilling impossible due constraints locking live values backtracking enforced leading selection new spill candidates 
generation certain transfer operations rejected 

spill routes ar ar ay ay frts ira ar ar ax ay af ar ax ay af ira ax ay mx ar lvs ar lvs ax ax mx ar ar ar ax ay af ar ax ay af ira lvs ar ar ax ay ar lvs ar frt ar frt spill transfer operation ar 

live values interference graph assume insertion live values performed require spilling values 
decisions spilling performed advance 
inserting new live value lv location lvs implies generating constraint intf ln location interfering live value lv lvs 
constraints considered implicit representation interference graph 
constraints ensure number interfering live values exceed available register resources 
reduction strategies described integrated constraint order enable satisfaction constraints cf 
remarks complexity section 
mentioned ira classes deadlocks occur 
deadlocks caused situations exists labeling domain variables constraints fulfilled 

deadlocks due data routing mentioned 
examples deadlocks spilling values required located srs spilling impossible sr mf 
prevent deadlocks due constraints met perform relaxation constraints 
delete interference constraints perform reallocation spill code inserted corresponding values 
deadlocks due data routing solved backtracking 
allow backtracking decisions single frt context ira decisions iteration main loop 
currently developing deadlock model identify deadlock conditions certain machine classes 
goal definition constraints prevent occurrence deadlocks means reducing certain potential srs denote deadlock candidates 
developed set constraints prevent deadlocks classify set deadlocks may occur 
encounter deadlocks practical benchmarks considered far 

example ira example frt sequence generated ira contains large amount flexibility 
example shows generated frt sequence example generated frt sequence shown fig 
ar ax ay ar ax ay af ar ax ay ar ax ay ar ar ax ay ar ax ay af ar ax ay ar ax ay ar ar af af ar tmp af ar tmp sequence represents set possible sequences 
contains transformed optimally compacted sequence machine instructions 
insertion frt af lead reduction live value node ar preventing spilling live value 
result labeling lead feasible sequence rts ar ay af ar ay ar ay ar ar ay ar ar tmp af tmp 
results ira techniques data routing consider different data routes definitions uses order prevent spilling 
method data routing frts 
domains locations represent alternative routes 
case inserted data moves spill code 
furthermore alternative routes kept long possible yield freedom subsequent decisions 
spilling strategy propose necessarily spills values memory free registers 
result reduction data transfers shown section 
advantages implied reduction memory accesses ffl amount required memory reduced certain values exclusively kept registers 
ffl reducing amount memory accesses general leads reduced power dissipation 
ffl amount code needed memory address computations reduced 
introducing flexible spilling data routing register allocator code improved compared code generated optimal covers flexibility 
combined data routing spilling strategy reduced amount memory accesses drastically 
results ira table 
results columns show lengths generated frt sequences ira applied optimal cover spilling memory schedule frts data routing flexible spilling respectively 
columns mem mem represent transfer operations accesses memory columns rt rt represent transfer operations memory accesses 
columns time time run times sparc cpu seconds approaches shown compare analysis worst case complexity section 
table 
results ira source mem mem rt rt time time complex multiply complex update iir filter lattice filter section consider integration code selection register allocation instruction scheduling phase 
phase ilp taken account optimization 

integrated instruction scheduling iis iis denotes integration code selection register allocation instruction scheduling 
goal exploitation potential ilp reduce amount instruction cycles basic blocks prevent unnecessary generation spill code 
approach list scheduling extended integration data routing spilling techniques integrated register allocation 
iis algorithm maps dfg frt sequence machine instructions 
list scheduling algorithms iis data ready set dr selection functions choosing candidate scheduled 
selection candidate goal minimizing spill code 
predicates compatible frt mi denotes compatibility frt frt machine instruction mi 
spilling frt lv denotes frt requires spill code new live value definition inserted lvs 
predicate fails reduction section feasible 
resources free mi denotes resources machine instruction consumed set frts 
iis algorithm informally fig 


compatibility frts machine instructions concept factorised rts extended factorised machine instructions 
machine instructions represented set frts 
constraints frts machine instruction guide correct reduction frts order meet ilp constraints target processor 
new constraint ilp frt mi generated new frt inserted machine instruction 
test new frt compatible mi performed constraint ilp cf 
section 
concept factorised machine instructions permits postpone assignment 
iis algorithm ffl input dfg frt initial live value set lvs 
ffl output machine instruction sequence mis 
ffl algorithm dr initial set frts data ready mi new machine instruction dr fg resources free mi append mi mis generate new empty machine instruction mis mis mi mi new machine instruction scheduling 
select compatible rt dr induces spilling iff frt dr compatible frt mi uses ready rt lv spilling frt lv insert frt mi generate constraints update lvs 

generate compatible data moves select frt ready generate transfer operations insert dr iff frt dr uses ready rt lv select required spill candidate ready insert dr iff frt dr spilling frt lv frt dr spilling required frt lv 
generate new machine instruction mis mis mi mi new machine instruction certain machine instruction type 
leaves freedom subsequent decisions 

selection compatible frt dr select compatible frt dr scheduled current instruction cycle 
frt selected induces spilling 
comprises frts reduced reduction strategies section 
frt longest path dfg selected 
insertion frt current machine instruction mi yields new machine instruction mi tasks performed 
mi mi generate new ilp constraint 

eliminate uses frt lvs insert new live value lvs 

insert frt dr data ready due insertion lvs 

generating compatible data moves compatible spill free frts data ready set dr free resources transfer operations mi try generate transfer operations data ready ready frts 

generate moves ready frts frt data ready ready selected 
compatible transfer operations generated means data routing introduced section 
generated moves inserted dr selected iteration main loop iis algorithm 
frt longest path dfg selected 

generating required spill code spilling prevented scheduling non compatible frt machine instruction frt spilling performed anyway transfer operation spilling generated 
conditions generating spill code 
ready frts frt dr imply spilling frt lv 
exists frt frt dr spilling performed 
spilling strategies ira 

machine instruction sequence example example iis generates sequence machine instructions running example retains certain amount freedom instr 
typ typ rls cycle ax ay ax ay instr 
typ typ rls alu cycle ax ay ax ay ar ax ay ax ay instr 
typ instr typ typ typ rls alu cycle af ax ay ax ay instr 
typ instr typ typ typ typ rls alu cycle ar tmp af tmp 
results iis table number generated machine instructions set benchmarks shown 
numbers machine instructions benchmarks hand crafted code optimal neglecting address computations 
small running example obtain optimal result shown row 
run times iis column sparc cpu seconds 
run times internal benchmarks minute 
subsection comprises analysis worst case complexity iis 
section results executable code including address computations shown 
table 
results iis source instructions runtime complex multiply complex update iir filter lattice filter example ira allow constraints violation prevent deadlocks due constraints met 
far benchmarks internal test cases case occur 

remarks complexity iis section informally analyze worst case complexity scheduling approach iis 
essential parameters worst case analysis table 
analysis sizes sets dr lvs approximated worst case complexity iis wc table 
essential parameters complexity analysis number main loop iterations worst case complexity possible backtracking steps single main loop iteration cc worst case complexity constraint re activations number dfg nodes vmax maximum number variables occurring constraint cmax maximum number constraints generated dfg node drc number register cells target architecture fu number fus 
main loop iterations assume loop terminates iterations iteration node scheduled new data move nodes generated 
amount generated data moves finite generally proportional 
backtracking ira iis comprise complete backtracking 
allow backtracking possible solutions single main loop iteration iis worst case effects backtracking may result testing maximal number solutions possible ffl selecting candidate scheduling dr check uses ready lvs 
complexity solutions sj approximated 
ffl data routing frts ready search dr uses ready lvs 
worst case complexity 
ffl selecting spill candidate depends complex strategy current version iis 
total complexity backtracking results 
re activations constraints section reduction strategy introduced order prevent generation spill code 
strategy integrated constraints intf similar reduction strategy incorporated constraint ilp 
assume reduction strategy disabled 
non disjunctive constraints generated system 
resume complexity analysis covering section total number possible re activations constraints occurring dfg 
holds reasons ffl number new constraints limited maximum generated constraints constant scheduled node constraints intf ilp generated 
new generated data moves matching constraints described section generated 
ffl complexity generated constraints intf ilp dependents drc complexity reactivation intf worst case rc fu ilp 
affect complexity re activations drc constant target architecture 
enable reduction strategies intf ilp disjunctive lead exponential run times max drc possibilities reducing variables node 
reduction strategy may indicate reactivation reductions may yield possible combinations reduction tried due failure backtracking constraints 

total complexity reduction strategy disabled worst case get run time 
exponential run times possible worst case case occurred experiments 
concerning reactivation constraints constraints reactivated failures detected early 
holds reduction strategy general feasible reduction failure reduction early 
experiments show approach practicable real life examples large basic blocks reduction activated 

complexity labeling labeling serves purposes 
yield final code frt machine instructions means final resource binding 
second goal check global feasibility final schedule generated constraints guarantee local feasibility 
labeling succeeds know exists feasible solution 
case feasible solution exists problem feasibility check np complete problem may cause exponential run times 
experiments labeling procedure fail far labeling fast second 
prevent cases exponential run times user defined time outs possible labeling 
labeling fails allow certain constraints violated 
strategies select constraints simple far necessity apply 
repair code inserted form extra spill code splitting mis set sequential mis 

concluding remarks complexity case proposed strategies fail due unacceptable run times time outs provide standard techniques order yield code source program 
considering modern compiler technology compilers incorporate strategies usage alternative optimization strategies parallel select set best results 
context think techniques may fail certain cases normally lead strongly improved code quality permissible constitute real enrichment compilation system 

post processing results final phase code generator generation executable code post processing phases cf 
fig 

insertion code needed memory address computations code generation values bound specific memories fixed addresses 
due specialized architecture address generation units dsps assignment variables memory addresses performed carefully 
goal address assignment maximize utilization auto increment auto decrement agu operations address computations 

post compaction agu operations inserted code generated dfg computations post compaction step required parallelize dfg computations agu operations obtain final machine code 
simultaneously post compaction phase exploits code selection freedom left generated factorised machine instructions 
alternative instruction associated binary encoding opcode 
alternative opcodes post compaction selects ones permit optimum parallelization generated agu operations 
address generation post compaction currently reuse techniques developed record compiler 
table shows experimental results set benchmarks 
entry gives number generated machine instructions including address computations 
column shows results obtained gnu adsp compiler 
column lists results obtained record compiler column gives length hand written code benchmarks 
results code generator icg shown column 
table 
comparison generated code benchmarks source gnu record hand written code icg complex multiply complex update iir filter lattice filter compared examples optimizations loop unrolling software pipelining larger code size lead higher performance 
smaller code sizes indicate higher performance 
gnu compiler showed overhead average compared hand written code code generated record showed average overhead 
analysis code proved overhead due data moves registers poor exploitation potential parallelism 
seen columns icg achieved code quality hand written code benchmarks table 
due address optimization techniques additional overhead induced address computations 
compilation speed approach comprising phases order generated instructions cpu second 

processors embedded system design demands high level language compilers capable generating efficient machine code 
current compilers hardly meet demand 
main reason poor performance current compilers embedded processors irregularities processor architectures presence special purpose registers fus combination restricted instruction level parallelism 
type architecture frequently fixedpoint dsps 
exemplified standard dsp tight coupling code generation phases necessary overcome problem 
phase coupled approach code generation requires higher compilation times general purpose computing 
tight code size speed constraints embedded processors cases higher compilation times acceptable 
proposed novel constraint driven approach code generation embedded dsps 
approach significant advantages compared previous heuristics firstly need designing specific optimization algorithms capable obeying constraints arise due irregularities ilp 
machine code constructed obtained successive reduction solution space constraints imposed target processor 
efficient uniform constraint satisfaction approach implemented constraint logic programming guarantees constraint violated emitted code 
secondly approach achieves tight coupling main code generation phases code selection register allocation instruction scheduling 
result possible generate machine code high quality comes close hand written assembly code 
demonstrated benchmarks standard dsp 
improvements approach concern intelligent functions selecting candidates reduction spilling 
achieved consideration larger search spaces global interference graph augmented information parallelism 
replace post processing current version integrated techniques generation executable code 
approach achieves tight coupling phases points heuristics decisions 
plan eliminate heuristics step step replace labeling optimization strategies clp system 
allow study problem complexity globally optimal code generation dfg possible reasonable amount computation time 
furthermore application algebraic rules code generation potential area improvements 
notes 
numbering types corresponds adsp user manual 

summary approaches grammars attributed grammars specifying code selectors 

notion tree reduction rules reflects view tree covering process reduction certain input tree certain nonterminal rules tree grammar rewriting rules 
pattern detected input tree replaced substituted nonterminal left hand sight corresponding rule 

labeling may consume exponential run times solution exists specify timeouts feasibility checks 

holds compared code examples include software pipelining loop unrolling optimizations 

instruction types differ slightly ones introduced 

chained operations order occurrence expression left right 

chained patterns split set frts follows cf 
tree automaton construction sub pattern new virtual resource inserted frts match sub operations extended corresponding virtual resource 
mac operation modeled inserting sr definition operation operation frt reduces mac operation costs set corresponding operand frt constrained correct costs reflected frt 

tree grammars special case context free grammars 
rule tree grammar associated sequence rts action part 
approach sequence restricted single rt 
style chosen better understanding algorithms readers familiar clp 
enables conversion non clp constraint systems 
consider rfs capacity 
inequality constraint locations sufficient approach constraint extended take account indices srs 
generate constraint denote domain variables possible set indexes addressing srs 
exists feasible solution certain iteration due constraints met strategy allow violation certain constraints 
repair code inserted post processing phase 
benchmarks tested case didn occur far 
wolfgang anton ertl felix beer andreas krall 
dependence conscious register allocation 
juergen gutknecht editor programming languages system architectures volume pages 
lncs series springer verlag zurich switzerland march 

alfred aho mahadevan ganapathi steven tjiang 
code generation tree matching dynamic programming 
acm transactions programming languages systems october 

alfred aho johnson 
optimal code generation expression trees 
journal acm 

guido araujo sharad malik 
optimal code generation embedded memory non homogeneous register architectures 
intl 
symp 
system synthesis isss 

guido araujo sharad malik mike tien chien lee 
register transfer paths code generation heterogeneous memory register architectures 
rd design automation conference dac 


alfred aho sethi ullman 
compilers principles techniques tools 
addison wesley new york 

preston briggs keith cooper linda torczon 
improvements graph coloring register allocation 
acm transactions programming languages systems may 

balachandran biswas 
efficient retargetable code generation bottom tree pattern matching 
comput 
lang 
vol 


david susan eggers robert henry 
integrating register allocation instruction scheduling 
proceedings fourth international conference architectural support programming languages operating systems pages santa clara california 

david berson rajiv gupta mary lou soffa 
resource framework integrating register allocation local global schedulers 
working conf 
parallel architectures compilation techniques august 

david robert henry susan eggers 
marion system retargetable instruction scheduling 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 

david 
retargetable instruction scheduling pipelined processors 
phd thesis dept computer science univ washington 

thomas phillip 
craig practical framework combining instruction scheduling register assignment 
pact 

chaitin auslander chandra cocke hopkins 
register allocation coloring 
computer languages january 

ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficiently computing static single assignment control dependence graph 
acm transactions programming languages systems october 

analog devices 
adsp user manual 
analog devices 

ellis 
bulldog compiler vliw architectures 
mit press cambridge mass 

helmut friedrich wilhelm rudolf landwehr 
beg generator efficient back ends 
sigplan notices july 
proceedings acm sigplan conference programming language design implementation 

andreas mueller 
global code selection directed acyclic graphs 
peter fritzson editor compiler construction volume lncs pages 
springer verlag april 
th international conference cc 

fraser henry todd proebsting 
simple efficient code generator generator 
acm letters programming languages systems september 

fraser henry todd proebsting 
burg fast optimal instruction selection tree parsing 
sigplan notices april 

stefan freudenberger john 
phase ordering register allocation instruction scheduling 
robert giegerich susan graham editors code generation concepts tools techniques proceedings international workshop code generation dagstuhl germany may workshops computing pages 
springer verlag 
isbn 

christian ferdinand helmut seidl reinhard wilhelm 
tree automata code selection 
acta informatica springer verlag pages 


efficient model dsp code generation performance code size estimated energy 
th international symposium system synthesis isss 


mahadevan ganapathi fisher hennessy 
retargetable compiler code generation 
computing surveys october 

goodman hsu 
code scheduling register allocation 
proceedings acm sigplan conference programming language design implementation 

graham 
new method compiler code generation 
conference record fifth annual acm symposium principles programming languages pages 

hartmann 
combined scheduling data routing programmable asic systems 
proceedings pages march 

werner heinrich 
formal parallel computer architectures basis optimizing code generation 
phd thesis tu munich 

henry 
algorithms table driven code generators tree pattern matching 
technical report computer science department university washington seattle wa usa 

henry 
encoding optimal pattern selection table driven bottom tree pattern matcher 
technical report computer science department university washington seattle wa usa 

henry 
performance table driven code generators tree pattern matching 
technical report computer science department university washington seattle wa usa 

pascal van hentenryck 
constraint satisfaction logic programming 
mit press 

george srinivas devadas 
aviv retargetable code generator isdl 
proc 
th dac 

dirk marco gert goossens hugo de man data routing paradigm efficient data path synthesis code generation 
proc 
th ieee acm int 
symp 
high level synthesis may 

stan liao srinivas devadas kurt steve tjiang 
instruction selection covering code size optimization 
international conference cad iccad 

rainer leupers 
retargetable code generation digital signal processors 
kluwer academic publishers 

leupers marwedel 
algorithms address assignment dsp code generation 
iccad 

leupers marwedel 
time constrained code compaction dsps 
ieee transactions vlsi systems vol 


leupers marwedel 
retargetable code generation structural processor descriptions 
design automation embedded systems vol 


moon ebcioglu 
efficient resource constraint global scheduling technique superscalar vliw processors 
micro december 

peter marwedel gert goossens editors 
code generation embedded processors 
kluwer academic publishers 

kim marriott peter stuckey 
programming constraints 
mit press 

bart jef van jess jochen constraint analysis dsp code 
proc isss 

steven muchnik 
advanced compiler design implementation 
morgan kaufmann publishers 

steven alexandru nicolau 
hierarchical approach percolation scheduling 
technical report tr irvine university august 

steven alexandru nicolau 
mutation scheduling unified approach compiling fine grain parallelism 
pingali banerjee gelernter nicolau padua editors languages compilers parallel computing volume lncs pages 
springer verlag ithaca ny usa august 

cindy norris 
scheduler sensitive global register allocator 
proceedings supercomputing 

cindy norris 
register allocation program dependence graph 
sigplan notices 
proceedings acm sigplan conference programming language design implementation 

cindy norris 
register allocation sensitive region scheduling 
international conference parallel architectures compilation techniques pact 

alexandru nicolau wang 
register allocation renaming impact parallelization 
languages compilers parallel computing volume 
lncs series springer verlag 

ic parc 
homepage 
www ic ac uk eclipse 

paulin 
trends embedded systems technology sami de micheli eds hardware software codesign industrial perspective 
kluwer academic publishers 

pinter 
register allocation instruction scheduling 
proceedings acm sigplan conference programming language design implementation pages 

eduardo susan graham 
optimal code generation expression trees application burs theory 
conference record fifteenth annual acm symposium principles programming languages pages san diego california january 

paulin may 
flexible firmware developement embedded systems 
marwedel goossens chapter pages 

rimey hilfinger 
lazy data routing greedy scheduling 
micro volume pages 


marino jef van jochen jess stefan note 
efficient code generation house dsp cores 
proc 
ed tc 

marino jef van jochen jess 
conflict modelling instruction scheduling code generation house dsp cores 
proc 
nd dac 

vegdahl 
local code generation compaction optimizing compilers 
phd thesis carnegie mellon university pittsburgh 

mark wallace 
constraint programming 
contact address ic parc william laboratory imperial college london sw az email doc ic ac uk sep 
publications www ic ac uk 

wilson 
ilp approach code generation 
marwedel goossens chapter pages 

mark wallace stefano joachim 
ecl ps platform constraint logic programming 
contact address ic parc william laboratory imperial college london sw az email doc ic ac uk aug 
publications www ic ac uk 

yamaguchi takashi 
binding scheduling algorithms highly retargetable compilation 
proc 
asp dac 

meyr 
dsp oriented benchmarking methodology 


