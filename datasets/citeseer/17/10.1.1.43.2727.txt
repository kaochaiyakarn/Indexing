extending smodels system cardinality weight constraints ilkka niemel patrik simons helsinki university technology department computer science engineering laboratory theoretical computer science box fin hut finland email niemela patrik hut 
smodels system state art implementations stable model computation normal logic programs 
order enable realistic applications basic modeling language normal programs extended new constructs including cardinality weight constraints corresponding implementation techniques developed 
summarizes extensions included system demonstrates provides basic application methodology illustrates current level performance system compares state art satis ability checkers 
logic programs stable model semantics emerged novel paradigm applying declarative logic programming techniques 
call paradigm answer set programming term coined vladimir lifschitz 
nicely captures main idea approach solutions answers represented sets objects 
furthermore logic programs answer set semantics gl generalization stable model semantics handle programs classical negation seen instance approach 
answer set programming proposed methodology solving combinatorial graph planning problems lif mt nie 
developing implementation stable model semantics normal logic programs called smodels system available www tcs hut fi software smodels 
working applications observed applicability system widened extending underlying language normal rules expressive constructs representing choices restrictions ii extensions supported ecient implementation techniques 
purpose summarize extensions included system demonstrate provide basic application methodology illustrate current level performance system 
start explaining basic ideas answer set programming approach applying logic programs stable model semantics 
details mt nie 
answer set programming problem solved devising logic program stable models program provide answers problem implementation stable model semantics compute answer stable model resulting program 
example consider coloring problem problem nding assignment colors vertex graph vertices connected edge color 
graph build program vertex graph take rules left edge rules right stable models sets ground atoms instance rst rule left says stable model rules left force stable model contain vertex graph 
rst rule right excludes stable models containing atoms similarly rules 
rules right exclude stable model having atoms edge graph 
implies stable model program gives legal coloring graph node colored color included stable model 
normal logic programs provide framework variety combinatorial constraint satisfaction planning problems handled nie 
conditions hard capture normal programs 
typically related choices cardinality costs resources 
consider example vertex cover problem task nd subset vertices size edge vertices included cover 
suitable notion cardinality constraints vertex covers captured graph follows 
edge graph rule fv ug included integrity constraint type rule fv added fv set vertices graph 
rst rule expresses choice cardinality constraint saying point edge selected second rule states cardinality restriction saying cover size cover contains vertices acceptable 
choice rule expressible normal rules introducing new atoms program normal rules stable models subset minimal stable model proper subset stable model 
rules cardinality constraints possible 
furthermore compact encoding cardinality restriction normal rules 
cardinality constraints appear useful extension normal logic programs 
general constraints needed representing conditions resources costs 
example consider knapsack problem set items values weights need choose subset weight limit exceeded value limit achieved 
constraints captured generalizing cardinality constraints 
idea cardinality constraint atom treated having weight natural generalization allow arbitrary weights 
knapsack problem captured rules fi wn fi rst rule expresses selection subset items fi sum weights selected items second rule states constraint eliminating subsets items sum values weight constraints provide expressive uniform framework handling large classes combinatorial problems 
smodels system takes weight constraints basic building blocks rules considers weight rules form cn weight constraint form fa wn wn am wm atomic formula 
generalization normal logic program rules literal atomic formula negation weight rules declarative nonmonotonic semantics nss extends stable model semantics normal logic programs gl generalizes propositional choice rules sn 
number approaches priorities preferences costs probabilities certainty factors associated rules see mt ns lns 
di erent weight rules aim provide relatively simple way associating weights costs atoms representing constraints weights 
approaches np spec constraint logic programs clp jl constraint satisfaction problems tsa stable model semantics include default negation 
addition semantics weight rules treats constraints rules choices uniformly clp np spec approaches 
related stable models 
example blr priorities added integrity constraints 
done express weak constraints possible satis ed weight constraints satis ed 
gre types aggregates integrated datalog framework stable models order express dynamic programming optimization problems logic programs strati ed negation choice constructs 
disjunctive logic programs allow rules disjunctions heads rules close rules cardinality constraints 
weight rules general disjunctive rules allow cardinality weight constraints head body rule 
fundamental di erence semantical basis main semantics disjunctive programs built paradigm minimal models 
means model program proper subset model 
exception possible model semantics si non minimal models allowed 
weight rules may non minimal models rules possible model semantics seen simple subclass rules cardinality constraints sn 
number implementations declarative semantics logic programs available 
example xsb system wam full logic programming system supporting founded semantics ldl deductive database system stable model semantics supporting strati ed programs choice constructs user de ned aggregates 
systems supporting full stable model semantics 
system originally developed system computing extensions reiter default logic includes tools tuned computing stable models normal logic programs 
dlv smodels systems developed specially computing stable models logic programs 
main di erences dlv handles disjunctive logic programs considerable emphasis integrating deductive database techniques dlv evaluating eciently recursive strati ed programs 
smodels system handle disjunctive rules supports normal programs recursive database query evaluation techniques included smodels 
smodels extended support cardinality weight constraints rules variables built functions 
constructs solving optimization problems added 
rest organized follows 
start discussing underlying stable model semantics weight rules illustrate basic constructs number examples 
simple generate test method starting point developing applications 
method demonstrated examples propositional satis ability hamiltonian cycles 
section brie explain techniques developed implementing weight rules 
show results experiments propositional satis ability hamiltonian cycle problems smodels system compared dlv state art propositional satis ability checkers 
weight rules stable model semantics section explain stable model semantics weight rules cn originally introduced nss steps 
discuss ground rules rules variables allowed 
start original stable model semantics normal rules constraint literal 
move rules constraints cardinality constraints 
provides suitable setting explaining basic intuition extending stable model semantics 
show generalize semantics weight constraints 
discuss constructs provided solving optimization problems nally method integrating variables built functions smodels system 
normal rules stable model semantics gl generalizes minimal model semantics de nite programs normal logic program rules bm cn negative body literals allowed 
variable free ground program stable models de ned follows 
reduct program respect set atoms program obtained deleting rule negative literal body negative literals remaining rules 
reduct seen set potentially applicable rules stable model rules negative body literals satis ed model 
note reduct negative body literals potentially applicable rules removed rules de nite 
idea stable model justi ed sense atom model consequence potentially applicable rules consequence potentially applicable rules included model 
atomic consequences set de nite rules captured deductive closure rules de ned way 
set atoms closed set rules rule satis ed atom set body atoms set head atom 
set de nite rules unique smallest set atoms closed call deductive closure denote cl 
uniqueness implied fact de nite rules monotonic body rule satis ed model satis ed superset note closure constructed iteratively starting empty set atoms iterating set rules updating set atoms head rule satis ed unsatis ed rules left 
example consider de nite program cl fp rg set atoms closed rules 
closure constructed forward chaining manner starting empty set including head rule set body contained set 
way cl constructed including rst followed de nition ground program 
set ground atoms stable model cl 
example program stable model fr pg cl reduct rules addition model stable model fs qg veri ed similarly constructing reduct closure 
cardinality constraints consider rules constraints cardinality constraints form fa integers giving lower upper bound constraint respectively 
cardinality constraint denote lit corresponding set literals fa idea constraint satis ed model cardinality subset literals satis ed model integers allowed omit bounds case missing lower bound taken upper bound 
write rule fa fnot fc says missing stable model included fc subset fa contained model 
note empty set possible choice subset 
notice cardinality constraint rules seen generalization normal rules special case cardinality constraints form flg literal 
example normal rule seen cardinality constraint rule fag fnot bg 
semantics cardinality constraint rules generalization stable model semantics normal logic programs terms models sets atoms 
de ne model satis es rule concept notion stable models 
model set atoms notation de nition set atoms satis es cardinality constraint form jfl lit number literals satis ed rule cn satis ed cn satis es satis es cn allow integrity constraints rules head constraint satis ed body constraints cn 
example consider rule fa bg fa cg constraint body satis ed model fa bg fa cg fa bg satis ed model fag 
rule satis ed fag satis ed fa bg constraint head satis ed fa bg 
integrity constraint fa bg fa cg satis ed models fa bg fag model fa cg 
case constraints body satis ed fa cg 
stable model normal rules set atoms satis es rules justi ed rules sense coincides closure reduct rules 
justi cation property essential applications solutions contain unnecessary ed elements 
devising semantics rules cardinality weight constraints aim preserve justi ability property suitably generalizing concepts reduct deductive closure introduced previous section normal programs 
cardinality weight rules reduct turns set rules special form cn ground atom constraint contains positive literals lower bound condition 
call rules horn constraint rules 
deductive closure cl set horn constraint rules de ned unique smallest set atoms closed way de nite rules 
uniqueness implied fact horn constraint rules monotonic body rule satis ed model satis ed superset recall closure constructed iteratively forward chaining manner starting empty set including head rule set body contained set 
example consider set horn rules fag fb dg fb ag deductive closure set atoms fbg constructed iteratively starting empty set realizing empty body second rule satis ed empty set added closure 
set closed rules 
rule fa cg added closure fb cg 
introduce reduct steps 
de ne reduct constraint generalize rules 
reduct constraint form set atoms constraint fa lit 
reduct negative literals upper bound removed lower bound decreased number negative literals satis ed account contribution negative literals satisfying lower bound 
example set fqg constraint fnot pg reduct fpg negative literals constraint satis ed reduct program set atoms set horn constraint rules contains rule atom head rule appears head upper bounds constraints body satis ed body obtained reduct constraints body formally reduct de ned follows 
de nition ground program set ground atoms 
reduct de ned fp cn lit constraint form fa mg ug idea follow case normal programs de ne stable model program atom set satis es rules deductive closure reduct role reduct provide possible justi cations atoms atom stable model justi ed program sense derivable reduct 
de nition set ground atoms stable model program conditions hold ii cl 
example consider program fa observe stable model program subset atoms appearing heads rules program 
atom reduct contain horn rule atom head atom deductive closure reduct stable model 
stable model subset fa empty set stable model similarly subset having atoms 
fa stable model satis es rule reduct fa fa fa closure 
fact stable models fa fa fa expect 
notice fa fa bg stable model 
instance fa stable model reduct fa fa bg deductive closure 
program fa subsets fa stable models 
demonstrates stable models necessarily subset minimal 
weight constraints turn extending stable model semantics handle weight constraints 
generalization explained considering connection cardinality constraints linear inequalities 
cardinality constraint fa seen linear inequality 

variables values variable generalized allowing arbitrary coecient variable leading linear inequalities form 

bm coecient variable seen weight corresponding atom 
considering constraints form fa bm weight atom denote lit set literals weight constraint numbers give lower upper bounds constraint respectively 
denote local weight function gives weights literals weights bounds arbitrary real numbers 
current implementation allows integers 
restriction adopted order avoid complications arising nite precision real number arithmetic standard programming languages 
stable model semantics cardinality constraints generalized weight constraints straightforward way 
basic idea generalize notion weight constraint model cardinality constraint weight de ned number literals satis ed corresponds case literal weight equal 
obvious generalization case arbitrary weights allowed take sum weights literals satis ed weight constraint weight lit sj satis ability weight constraint weight rule de ned cardinality constraints de nition 
example consider weight constraint fa fa cg fag 
fa cg fag notion satis ability rule clear deductive closure horn constraint rules form ground atom weight constraint contains positive literals lower bound condition 
example consider set horn constraint rules fa fb fb fb deductive closure fbg 
rule fa added closure fb cg 
rules negative weights stable models de ned straightforward generalization reduct cardinality constraints 
negative weights allowed tricky guarantee justi ability models 
negative weights negative literals closely related 
turns replace inessential available 
order avoid unnecessary complications assume weights non negative negative literals allowed 
semantics weight constraint rules case 
show transform rule negative weights equivalent rule positive weights 
suppose weight rules negative weights 
notion reduct cardinality constraints easy extend handle weight constraints reduct weight constraint obtained removing negative literals upper bound lower bound de ned lit sj re ect fact arbitrary weights allowed 
stable model set weight rules non negative weights de ned de nition notion reduct de nition 
example consider program fb fnot cardinality constraints justi ability models guarantees stable model weight program subset atoms appearing heads rules program subset fb cg case 
empty set stable model holds fbg reduct empty upper bound body exceeded 
fcg stable model cl fcg fc fb gg 
fact fcg stable model weight constraints negative weights transformed constraints non negative weights simple linear algebraic manipulation translates constraint fa bm equivalent form non negative weights wa jw jw fa wa jw jw wa wa jw jw negative weight complemented corresponding literal sum absolute values negative weights added bounds 
equivalence shown linear inequality eliminate negative weight adding jw jw inequality 
leaves term jw middle corresponding weighted literal jw similarly negative weights eliminated 
example consider rule fa fa eliminate negative weights body method 
resulting rule fa fnot fag 
reduct resulting rule fa fb gg deductive closure 
stable model rule 
fact rule stable models 
notice weight programs extend normal logic programs considerably computational complexity remains una ected stays np 
due fact candidate model checked polynomial time stable model program holds reduct constructed polynomial time ii deductive closure cl computed iteratively polynomial time 
theorem nss problem deciding ground weight program stable model np complete 
optimization capabilities solving optimization problems smodels system provides constructs minimizing maximizing function linear sum weights literals 
example minimization statement minimize fa wn wn am wm speci es model solution stable model program smallest value sum sj fa am example consider vertex cover problem optimization task nd vertex cover minimum size 
order take rules replace rule optimization statement 
minimize fv vn fv set vertices graph 
multiple minimization maximization statements allowed 
semantics statements order models lexicographically weights statements rst statement signi cant 
example consider statements minimize fa 
minimize fan order models solution model containing stable model exists model containing model exists 
notice semantics multiple minimization statements weak constraints blr closely related 
hand weak constraints express lexicographic minimization principles previous example hand weight rules minimization statements implementing weak constraints 
rules variables considered ground rules rules literals constraints variable free 
applications impractical error prone manually write required ground rules order capture solutions 
consider rules coloring problem rules node rules edge graph 
usually possible produce set ground rules automatically requires programming maintaining revising programs harder 
useful employ rules variables functions 
semantics rules variables obtained considering ground instantiation program respect herbrand universe nss 
normal logic programs stable model semantics highly undecidable function symbols allowed 
practical approach employed smodels system extending weight rules allow variables built functions limited way guarantees decidability adequate practical applications 
start introducing basic subclass rules supported smodels system called domain restricted rules 
discuss useful extensions conditional literals built functions 
domain restricted program proper function symbols allowed 
program thought divided parts defs de nes domain predicates cs contains rules 
rules defs domain predicates non recursive normal logic program rules rules domain restricted sense variable rule appear domain predicate appears positively body rule 
notice domain restricted programs possible de ne new domain predicates previous ones unions intersections complements joins projections relations 
demonstrated example 
example consider setting set ground facts form 
predicate appears head rule ground facts quali es immediately domain predicate 
suppose solve coloring problem graph de ned relation edge graph holds 
problem formalized domain restricted program includes facts rules col col col edge vertex edge vertex edge color color vertex edge color color col term upper case letter variable terms constants 
defs includes facts rules domain predicates col edge vertex 
observe rule domain restricted body literal col removed variable appear predicate color domain predicate 
smodels system subclass domain restricted programs chosen compromise 
hand enables simple ecient phase implementation technique rst grounding phase rules variables compiled ground variable free rules processed second phase ecient method computing stable models ground programs 
hand non recursive domain predicates allow fair amount modeling power de ning domains variables 
brie explain domain restricted programs variables compiled ciently set ground rules typically considerably smaller herbrand instantiation program exactly stable models 
introduce useful extensions language conditional literals built functions 
details implementation techniques section 
ecient compilation possible properties domain restricted programs domain rules defs unique stable model computed database techniques rules de ning domain predicates seen view de nitions 
ii model holds stable models pd pd contains ground instances rules ground instance domain predicate 
iii pd computed eciently processing rule time 
obvious extension allow recursive domain predicates programs part defs strati ed 
means transitive closure tc domain predicate de ned domain predicate rules tc tc tc notice tc rules serve domain predicate programs second rule recursive 
order transform rule new domain predicate variable needs added 
straightforward way de ne domain predicate rule 
applications recursive strati ed rules extensively bene recursive domain predicates allowed corresponding techniques evaluating recursive rules incorporated grounding phase 
done dlv system 
smodels system focus deductive database applications techniques handling recursive rules grounding phase included 
conditional literals order able compactly write sets literals needed constraint expressions introduced notion conditional literals form literal conditional part domain predicate 
require rules conditional literals domain restricted sense variable rule appears domain predicate positive body predicate conditional part conditional literal rule 
conditional literals need distinguish local global variables rule 
idea global variables quantify rule scope local variable single conditional literal 
introduce notation distinction explicit convention variable local conditional literal appears literal rule variables global rule 
example rule col vertex variable local conditional literal head global variable 
semantics domain restricted rules conditional literals de ned regarding rule conditional literals shorthand set ordinary ground rules way 
consider domain restricted program conditional literals parts set non recursive normal rules defs de ning domain predicates cs containing rules 
denote unique stable model defs rule conditional literals corresponding set ground rules contains ground rule obtained steps 
global variables eliminated 
means global variable rule substituted ground term condition holds proper domain predicate body rule conditional literal resulting ground instance included example consider rule 
vertex rule col vertex possible resulting rule eliminating global variable fact possible resulting rule form ground term vertex second step eliminate conditional literals follows 
original rule domain restricted elimination global variables leads rules containing local variables conditional literal variable appears conditional literal taken sequence ground instances literal ground instance example conditional literal color col corresponds sequence literals color color color contains facts col col col 
stable models program conditional literals de ned stable models ground program consists union sets corresponding ground rules rule example conditional literals rewrite rule available colors changed giving corresponding set facts col 
example facts col col colors ground instantiation coloring program ground rule color vertex term vertex stable model defs built functions straightforward extend domain predicates built functions arithmetic 
domain rules guarantees built functions evaluated domain predicates variable built function domain variable ranges restricted domain predicates problems avoided 
smodels system includes extension integer arithmetic available mechanisms providing user de ned built functions 
allows rules area width length area ag area domain predicate de ned domain predicates width length giving width length circuit built function integer multiplication 
second rule speci es choice subset circuits sum areas 
implementation allows expressing weights rules involving domain predicates example 
application methodology section straightforward application methodology rules stable model semantics works surprising practice 
approach idea dividing program parts generator part tester part stable models generator corresponds possible candidate solutions problem tester eliminates candidates non valid ones 
examples similar technique applying disjunctive logic programs elm 
choice constructs expressible cardinality weight constraints straightforward devise generators 
tester integrity constraints provide powerful simple technique prune unwanted stable models integrity constraints introduce new stable models eliminate 
proposition program ic set integrity constraints 
stable model ic stable model demonstrate basic application methodology examples 
propositional satis ability consider rst satis ability problem set clauses set formulae form 

bm idea construct program models stable models coincide 
generator easy write potential solutions truth assignments set atoms fa appearing correspond subsets fa giving atoms assigned true 
program having subset fa stable models easy write single rule fa rule fa atom tester straightforward needs specify clause condition clause satis ed truth assignment 
done integrity constraint example consider set clauses corresponding program fa bg stable models fg fa bg models involved example constructing tester part problem consider satis ability general propositional formulae constructed connectives 
propositional formula construct program lp models stable models program correspond 
program lp models satis ability subformula de ned recursively follows lp fs lp lp fs lp lp lp fs fs lp lp lp fs 
fnot lp lp lp lp lp lp ffs atom 
atoms new atoms representing fact subformula satis able 
stable model represents possible truth assignment true atoms atoms stable model atom propositional formula 
addition stable model contains information truth values subformulae truth assignment speci ed stable model 
extra information easy write tester exclude models false propositional formula satis able lp stable model 
example consider formula 
lp fs fs fs hamiltonian cycles demonstrated rules capture propositional satis ability problems 
ecient standard techniques solving satis ability problems represented clauses conjunctive normal form 
furthermore rule representation set clauses er essential advantages far compactness representation concerned 
subsection demonstrate rules enable succinct representations discussing problem challenging propositional logic 
example consider hamiltonian cycle problem undirected graphs problem nding path graph visits vertex graph exactly returns starting vertex 
cardinality constraint rules enable straightforward direct encoding problem shown 
logic program encodings hamiltonian cycle problem directed graphs lif mt nie 
problem challenging propositional logic conceptually computationally 
illustrate section encoding hamiltonian cycles propositional logic compared experimentally logic program encodings 
logic program encoding assume graph represented set facts including vertex vertex graph edge edge fu vg graph 
simplicity suppose facts edge edge included edge fu vg program hamiltonian cycles constructed ideas 
hamiltonian cycle represented atoms form hc stable models hamiltonian cycles correspond 
fact hc stable model program says edge fu vg belongs corresponding hamiltonian cycle 
generator part program selects edges way vertex exactly edges fv ug fw vg facts hc hc stable model 
models represent cycles separate cycle 
eliminate models devise tester additional concepts take arbitrary vertex initial vertex fact added de ne predicate capture fact vertex reachable chosen edges initial vertex 
tester says simply vertices reachable initial vertex 
considerations lead program edge hc edge vertex hc edge hc edge vertex rst rule provides generator rest rules de ne tester 
notice conditional literals compact method represent set literals needed generator rule domain predicate edge guarantee domain rules de ning implementation techniques smodels system implements stable model semantics domain restricted rules cardinality weight constraints variables built functions 
basic function smodels compute stable models program 
done phases rst phase implemented program syr compiles logic program set primitive ground rules second phase stable models computed davis putnam procedure sim implemented program smodels sim 
functions front smodels program creates primitive rules wants compute stable models smodels library 
describe phases brie details sim nss 
phase rst phase implemented steps 
rst step program parsed domain predicates automatically detected 
domain predicates evaluate databases techniques building strati cation rules de ning domain predicates evaluating stratum time starting lowest strata 
program gives unique stable model part defs domain predicate rules 
ground instances pd rules computed rule time essentially evaluating relational joins domain predicates program domain restricted 
process conditional literals extended corresponding sequences ordinary literals built functions evaluated 
result rst step set ground rules built functions conditional literals 
second step rst phase ground rules compiled types ground primitive rule forms basic choice constraint weight rules 
particular primitive forms chosen easily eciently implemented rules input second phase smodels procedure 
basic rule normal logic program rule form choice rule fh limited form cardinality constraint rule primitive constraint rule fa mg 
primitive weight rule fa bm restrict positive integer weights 
rule negative weights translated rule positive weights described section 
illustrate translation constraint weight rules primitive rules way example 
complete description translation nss 
example want translate rule fh fa fb wm primitive rules 
creating rules constraint encoding lower bound satis ed upper bound respectively 
constraint fh translated rules fh fh new atoms 
way second constraint fa translated rules fa fa weight constraint fb wm translated fb wm fb wm lets capture truth value body weight rule rule encode original rule fh course important atoms program 
second phase second phase davis putnam procedure computes stable models set primitive rules 
procedure backtracking search procedure nds stable models program assigning truth values atoms program 
uses properties stable model semantics infer propagate additional truth values 
propagation founded semantics normal programs extends handling new primitive edge edge edge vertex edge edge vertex arc arc arc vertex arc arc vertex encoding hamiltonian cycle problem dlv rules primitive choice constraint weight rules back propagation lookahead techniques 
procedure employs dynamic application independent search heuristic idea assign truth values atoms order attempting minimize remaining search space 
details procedure sim 
procedure ect traversing binary search tree number nodes search space worst case order taken number atoms appear constraint head rule appear negative literal recursive loop program 
means example want nd satisfying assignment general propositional formula search space encoding section restricted atoms original formula 
experiments section demonstrate current level performance smodels system 
compare dlv system advanced implementation stable model semantics state art propositional satis ability checkers complete checkers sato zha satz la walksat skc local search 
satis ability checkers provide interesting systems employed basic inference engines advanced reasoning systems sato mcc checkers planning system blackbox ks 
tests random sat problems hamiltonian cycle problems 
sat problems chosen clause atom ratio number atoms particular ratio determines region hard satis ability problems ca 
hamiltonian cycle problem planar graphs created plane function stanford knu builds planar graph inserting number random points plane constructing delaunay triangulation points 
sat problems encoded logic programs method section 
dlv generator part includes atom set clauses rule new atom program 
hamiltonian cycle problems encoded smodels described section cardinality constraints 
dlv support cardinality constraints modi ed encoding translation 
idea hamiltonian cycle represented facts 
rst rules guarantee stable model vertex reachable initial vertex chosen edges model 
rules exclude stable models vertex neighbors cycle 
predicate arc symmetric closure edge order achieve compact encoding 
rules exclude models vertex neighbors 
challenging devise compact encoding hamiltonian cycles propositional logic 
translate hamiltonian cycle problem set clauses pap quadratic number atoms number vertices graph 
translation encodes total order vertices graph way edge pair vertices adjacent order 
vertices vn atom encode vertex position clauses 
position position 
vertex position position 
deny orders correspond hamiltonian cycles modn fv edge graph 
problem size generate sets rules clauses 
set randomly shu ed run times 
shu input particular ordering help algorithms avoid backtracking giving skewed picture behavior 
try lessen impact lucky choices 
durations tests seconds represent time nd solution time decide solutions 
tests run linux mhz pentium iii computers mb memory 
tested system standard settings tuning versions smodels smodels dlv release sato satz walksat 
walksat local search parameters chosen settings suggested ks best noise cuto 
results sat tests shown giving maximum average minimum running times 
test walksat sat problems walksat incomplete procedure sat test cases solution 
hamiltonian cycle test cases solution case walksat 
results hamiltonian cycles tests 
running times include preprocessing time translate graph set propositional clauses ground rules 
clausal translation done special purpose program rule translation program 
means execution time dlv smodels measured ground program produced input 
order study eciency cardinality constraints smodels system run encoding cardinality constraints obtained dlv encoding replacing rst rule edge results encoding denoted smodels 
smodels system scales way satis ability checkers random sat problems average fty times slower fastest checker 
comes hamiltonian cycle problems situation reversed 
smodels system scales better faster satis ability checkers 
di erence attributed compact logic program encoding hamiltonian cycle problem search heuristic smodels procedure 
smodels system extended cardinality weight constraints order enable realistic applications 
constructs important product con guration planning constraint satisfaction represent di erent kinds cardinality cost resource constraints 
enable compact natural easy maintain representations seconds vertices maximum running time sato dlv smodels satz seconds vertices average running time sato dlv smodels satz seconds vertices minimum running time sato dlv smodels satz experimental results sat problems seconds vertices maximum running time sato walksat satz dlv smodels smodels seconds vertices average running time sato walksat satz dlv smodels smodels seconds vertices minimum running time sato walksat satz dlv smodels smodels experimental results hamiltonian cycle problems involved problems 
extension done way basic computational complexity ected deciding ground weight program stable model remains np complete normal programs 
corresponding reasoning tasks closely related semantics disjunctive programs typically complete problems second level polynomial hierarchy 
developed phase implementation technique new constraints 
rst phase rules variables built functions compiled ground weight rules set primitive rules second phase answers stable models computed stable models primitive rules 
implementation handles subclass rules ones enable ecient compilation method database techniques 
second phase davis putnam backtracking search procedure ecient pruning techniques search heuristics developed 
comparisons state theart satis ability checkers show implementation techniques quite competitive 
acknowledgments support academy finland project gratefully acknowledged 
second author supported helsinki graduate school computer science engineering 
authors tommi developing implementing procedure 
gerhard brewka thomas eiter 
preferred answer sets extended logic programs 
cohn schubert shapiro editors proceedings sixth international conference principles knowledge representation reasoning pages trento italy june 
morgan kaufmann publishers 
blr leone 
strong weak constraints disjunctive datalog 
dix furbach nerode editors proceedings fourth international conference logic programming non monotonic reasoning pages dagstuhl castle germany july 
springer verlag 
ca crawford auton 
experimental results crossover point random sat 
arti cial intelligence 
marco cadoli luigi andrea schaerf domenico 
np spec executable speci cation language solving problems np 
gupta editor proceedings international workshop practical aspects declarative languages pages san antonio texas january 
springer verlag 
eiter gottlob 
computational cost disjunctive logic programming propositional case 
annals mathematics arti cial intelligence 
eiter gottlob mannila 
disjunctive datalog 
acm transactions database systems 
elm thomas eiter nicola leone gerald pfeifer francesco 
kr system dlv progress report comparisons benchmarks 
cohn schubert shapiro editors proceedings sixth international conference principles knowledge representation reasoning pages trento italy june 
morgan kaufmann publishers 
gl gelfond lifschitz 
stable model semantics logic programming 
proceedings fifth international conference logic programming pages seattle usa august 
mit press 
gl gelfond lifschitz 
logic programs classical negation 
proceedings seventh international conference logic programming pages jerusalem israel june 
mit press 
gre greco 
dynamic programming datalog aggregates 
ieee transactions knowledge data engineering 
jl ja ar jean louis lassez 
constraint logic programming 
michael donnell editor conference record th annual acm symposium principles programming languages pages munich frg january 
acm press 
knu knuth 
stanford 
labrea stanford edu pub 
ks kautz selman 
unifying sat graph planning 
dean editor proceedings th international joint conference arti cial intelligence pages stockholm sweden july august 
morgan kaufmann publishers 
leone dlv disjunctive datalog system 
www dbai tuwien ac proj dlv 
la li anbulagan 
look ahead versus look back satis ability problems 
smolka editor proceedings third international conference principles practice constraint programming pages linz austria october november 
springer verlag 
lif lifschitz 
answer set planning 
de schreye editor proceedings th international conference logic programming pages las cruces new mexico december 
mit press 
lns james lu anil nerode subrahmanian 
hybrid knowledge bases 
ieee trans 
knowledge data engineering 
mcc mccain 
causal calculator 
www cs utexas edu users mccain cc 
mt marek truszczy nski 
logic programming costs 
manuscript available www cs engr edu papers html 
mt marek truszczy nski 
stable models alternative logic programming paradigm 
apt marek truszczynski warren editors logic programming paradigm year perspective pages 
springer verlag 
nie niemel logic programming stable model semantics constraint programming paradigm 
annals mathematics arti cial intelligence 
ns raymond ng subrahmanian 
stable semantics probabilistic deductive databases 
information computation 
nss niemel simons soininen 
stable model semantics weight constraint rules 
gelfond leone pfeifer editors proceedings fifth international conference logic programming nonmonotonic reasoning pages el paso texas usa december 
springer verlag 
pap papadimitriou 
computational complexity 
addison wesley publishing 
si sakama inoue 
alternative approach semantics disjunctive logic programs deductive databases 
journal automated reasoning 
sim simons 
extending stable model semantics expressive rules 
gelfond leone pfeifer editors proceedings fifth international conference logic programming nonmonotonic reasoning pages el paso texas usa december 
springer verlag 
sim simons 
smodels procedure computing stable models ground programs 
www tcs hut 
software smodels 
skc selman kautz cohen 
noise strategies improving local search 
proceedings th national conference arti cial intelligence pages seattle wa july 
aaai press 
sn soininen niemel developing declarative rule language applications product con guration 
gopal gupta editor proceedings international workshop practical aspects declarative languages pages san antonio texas january 
springer verlag 
syr 
procedure grounding domain restricted logic programs 
www tcs hut 
software smodels 
truszczynski default reasoning system 
www cs engr edu ai html 
tsa tsang 
foundations constraint satisfaction 
academic press london 
warren xsb programming system 
www cs sunysb edu xsb page html 
zaniolo ldl second generation deductive database system 
www cs ucla edu ldl 
zha zhang 
sato ecient propositional prover 
mccune editor proceedings th international conference automated deduction pages north queensland australia july 
springer verlag 
index answer set programming blackbox built function cardinality constraint lower bound satisfaction upper bound closed set rules conditional literal constraint logic programming constraint satisfaction problem davis putnam procedure deductive closure default logic de nite program disjunctive logic program dlv domain predicate domain restricted rule global variable graph coloring hamiltonian cycle horn constraint rule integrity constraint knapsack ldl literal local variable maximization statement minimization statement normal logic program np spec optimization problems possible model semantics propositional satis ability reduct rule body rule head sato satz smodels stable model stable model semantics stanford transitive closure vertex cover walksat weak constraint weight constraint local weight function lower bound satisfaction upper bound weight rule computational complexity satisfaction founded semantics xsb 
