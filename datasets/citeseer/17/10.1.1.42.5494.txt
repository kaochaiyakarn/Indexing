aspect oriented compilers oege de moor simon peyton jones eric van wyk oxford university computing laboratory microsoft research cambridge 
aspect oriented programming provides programmer means cross cut conventional program structures particular class hierarchies object oriented programming 
studies aspect orientation structuring syntax directed compilers implemented attribute grammars 
specifically describes method specifying definitions related attributes aspects treating class objects stored manipulated combined 
hoped embedding aspect oriented programming style haskell provides stepping stone general study semantics aspect oriented programming 
compilers structured recursion syntax source language 
production syntax defines function specifies construct translated 
method structuring compilers syntax directed manner underlies formalism attribute grammars 
provide convenient notation specifying functions deal production rules syntax 
compiler writer need concern partitioning compiler number passes order computation derived automatically 
way achieving ordering compute attribute values demand driven fashion 
attribute grammars viewed particular style writing lazy functional programs :10.1.1.47.8549
unfortunately compilers written attribute grammars suffer lack modularity 
pure form way attribute grammars decomposed production 
possible separate single semantic aspect environment productions add separate entity code written 
compiler writer forced consider semantic aspects simultaneously option separating concerns 
specialised attribute grammar systems offer decomposition aspect syntactic level semantic 
particular aspects parameterised compiler writer define new ways combining old aspects new 
purpose define aspect set definitions related attributes 
proposes implementation aspects independent semantic units parameterised manipulated compiled independently 
proposed compiler aspects implemented variant programming language haskell augmented extensible records 
highly flexible type system allows give type aspect 
particular ensures attribute defined precisely important feature attribute grammars composed multiple components 
assumed reader familiar programming haskell 
concepts dependent haskell language language independent form 
hope concrete implementation available web encourage explore aspect oriented compilers 
source executable haskell program 
lines preceded symbol haskell program 
note portions program code appear comments visible printed version 
polymorphic type system extensible records shall trex extension haskell provides rich set record operations 
variant haskell record fields called may written abc 
type expression rec int char string 
field name selection function named prefixing 
example abc evaluates 
records extended new fields 
function abc adds new field named argument 
type reflects function applied record field named 
rec 
rec string row fields lacks maps record fields record field value string 
record extended natural consider starting point extensions empty record written type rec 
motivating example algol scope rules contrast successors algol clear uniform scope rules 
simplification scope rules favourite example illustrate attribute grammars 
definition identifier visible smallest enclosing block exception inner blocks contain definition shall study scope rules toy language example program syntax example local dec dec dec type prog block type block stat data stat string dec string local block aim translate programs sequence instructions typical stack machine 
type instructions data instr enter int int exit int ref int int block entry exit marked lexical level 
entry marked number local variables declared block 
applied occurrence identifier mapped level displacement pair consisting lexical level identifier declared displacement number declarations preceding level 
wit wish program function trans prog 
instr instance trans example enter ref ref enter ref ref exit ref exit traditional compiler proceed write program trans traditional attribute grammar style especially suggested :10.1.1.47.8549:10.1.1.30.4121
means concerned slicing computations minimal number passes syntax division passes comes free virtue lazy evaluation 
section reviews existing techniques writing attribute grammars write trans extensible record notation set stage section extensible records key component new modular approach defining attribute grammars 
provide context free grammar source language program prog 
block list block 
slist stat 
string slist slist 
local stat 
block dec stat 
string slist slist 
stat slist context free grammar close type definitions stated earlier 
roughly speaking types correspond nonterminals constructors correspond production rules 
note explicitly written productions statement lists productions explicit type definitions 
standard strategy writing attribute grammar consists steps definition semantic domains semantic functions translators 
semantic domains nonterminal symbol define corresponding semantic domain 
compiler map values type values type 
types include generated code type prog rec code instr defined record types fields represent various aspects semantics 
grammar symbols mere record type suffice semantics depends context occur 
motivates semantic domains functions record types input record describes attributes context called inherited attributes output record describes resulting attributes grammar symbol called synthesized attributes 
example type slist rec level int env 
rec code instr locs string lexical level environment maps identifiers level displacement pairs statement list yield code list instructions list local variable names called locs 
remains define semantic domain blocks statements happens statement lists type block rec level int env 
rec code instr type stat slist semantic functions define semantic functions compiler need primitive operations manipulating environments 
environment association list identifiers level displacement pairs shall write type environments 
operations apply add defined environments types apply 
string 
int int add int 
string 


function apply finds occurrence returns corresponding level displacement pair 
shall build environment adding local definitions lexical level 
purpose function add takes level list local definitions environment adds local definitions environment 
position define semantic functions 
production 
define semantic function 

combines semantic values appropriate type 
example define binary semantic function slist stat 
slist 
slist takes translations statement statement list produces translation composite statement list 
arguments result appear reverse order compared production slist 
type list obtained reversing sides corresponding production rule yield list slist 
block list slist code enter level length locs code exit level level level env add level locs 
env slist worthwhile note circularity argument result slist 
definitions acceptable lazy evaluation 
programmed computation strict language remove pseudo circularities introducing multiple passes syntax 
definition list illustrates traditional approach writing attribute grammars different aspects defined single location 
aspects split apart forcing compiler writer consider semantic aspects simultaneously 
deficiency aim remedy 
definitions semantic functions similar omit details 
avoid confusion mention notion semantic function different attribute grammar literature 
semantic function understood right hand side definition single attribute call semantic function simply termed production 
translators nonterminal define translator type 
maps values type corresponding semantic domain 
example function translates programs type prog 
prog translator statement lists type slist 
slist 
assuming existence semantic function production define translator type syntax program list slist ss slist ss dec dec local local aspect oriented compiler aim embed attribute definition language combinator library haskell 
extent previous section obtain truly modular design propose making nonterminals attribute definition rules semantic functions aspects class objects 
polymorphic operations extensible records give types objects combining forms objects 
shall see problem find appropriate type attribute definition rules 
traditional approach define translator trans type trans prog 
instr trans example evaluates result trans example 
section trans defined collection translators production syntax 
semantic functions translators named semantic functions program list traditional approach extracted fields attribute grammar named ag 
example translator function production program defined program ag 
ag record field syntax production contains semantic function 
fields record names types semantic functions traditional approach 
important distinction semantic functions ag built aspect oriented approach 
constructed grouping attribute definitions aspect production 
dummy argument ag constructs required technicality haskell type system known monomorphism restriction 
combining aspects example aspects named levels codes define respectively attributes lexical level environment local variables target code 
aspects combine attribute grammar ag way ag knit levels cat cat cat codes knit cat functions combining aspects attribute grammars defined 
framework clear write new aspects add attribute grammar combinators 
aspect definitions semantic function production define synthesised attributes parent inherited attributes children section 
refer attributes output attributes 
produce output attributes semantic function takes arguments input attributes synthesised attributes children inherited attributes parent 
trouble traditional approach forced define output attributes simultaneously just look definition list section 
new modular approach express semantic function composition rules 
rule production defines subset output attributes implemented function takes input attributes parent children context free grammar rule grammar record fields consist rules production 
monomorphism restriction mentioned define aspect function dummy argument returning rule grammar 
aspects involve tiny subset productions 
think example operator priorities affect productions expressions 
rule grammar involves productions definition 
definitions aspects written rules defined aspect explicitly written default rules provided rest 
concrete example aspect lexical level 
level attribute inherited explicitly defined productions program local levels program 
level local 
level level grammar level 
program local grammar see default behaviour rules inherited attributes copy parent attribute value children 
don write explicit rules productions 
accomplished phrase program local grammar fills fields grammar program local default copy rules pulled identity rule grammar named 
defaults added definitions rules program local create complete rule grammar 
rules written lambda expressions read functions take input attributes held child argument parent argument return tuple adds attribute level inherited attributes child adds new synthesized attributes parent parameters pair inherited synthesized attributes symbol type nonterminal type nt ai rec rec ai rec note arguments type definition ai row variables 
fields rows attributes 
record generated rule keeps track attribute definitions far adding level attribute definition attribute definitions block definition rule local override default definition level removing function adding fresh level field 
apart fact definition levels re usable find easier read flow level computation syntax tree clear glance especially default copy rules allow leave irrelevant detail 
local variables aspect compiler records local variables declared lexical level 
locs attribute synthesised adjoined rules 
locs synthesised rely default copy rules aspect somewhat complex previous dealt inherited attributes 
slist locs slist 
locs locs union locs 
locs dec 
locs local locs grammar slist slist dec local grammar see dec special functions take string yield rule arity 
usual way dealing grammar symbols identifiers fall outside attribute grammar 
attribute definition rules show development rules compose semantic functions 
type rule alluded function maps subset productions input attributes subset output attributes 
section provide precise definition rules 
build semantic function composing rules 
compose rules type system ensure attribute defined twice assert composition rules defines complete semantic function type system ensure attribute defined 
example able construct list semantic function section list knit cat cat cat list level rules cat composes rules knit transforms composed rule semantic function 
suffixes refer fact list production just child define variants knit cat productions different number children 
seek mechanism composing rules semantic functions allows default rules seen shorten clarify aspect definitions 
record concatenation operator type systems polymorphic extensible records 
reasons concatenate records generated rules solution suggested emy compose functions build records 
apply emy technique particular example attribution rules rule takes input existing output attributes passed rule nonterminal symbols 
rule return fixed records defined attributes transforms existing definitions adding new fields new attribute definitions replacing field values new values 
done overwrite default rules 
example consider rule list level 
level level rule overwrites definition level inherited attributes child leave synthesised attributes parent unchanged 
type unary rule type rule child parent child 
parent 
rec rec child parent understood nonterminals row variables 
type list level level level 
rule nt level int nt level int level int definition rules straightforward define concatenation operator suggested emy cat rule nt ci cs nt pi ps ci ps 
rule nt ci cs nt pi ps ci ps 
rule nt ci cs nt pi ps ci ps cat ci ps ci ps definition encodes sequential composition rule followed lifted version combinator named cat takes rule grammars records rule production concatenates corresponding fields 
concatenation operator course identity element rule leaves attribute definitions unchanged rule nt ci cs nt pi ps ci ps lifted version similar cat record fields production contains identity rule appropriate arity 
semantic functions defined requisite attribute values composing rules turn composite rule semantic function 
effect conversion involves connecting attribute definitions attribute applications 
shall call conversion 
type semantic functions arity type rec 
rec 
rec 
rec operation knit takes rule yields semantic function 
function results knit takes semantics child type rec ci 
rec cs inherited attributes parent value type rec pi 
produce synthesised attributes achieved applying rule builds synthesised attributes starting empty record builds inherited attributes starting inherited attributes implies inherited attributes copied specified 
default behaviour synthesised attributes 
knit rule nt pi cs nt pi ci ps 
ci cs pi ps knit rule pi ps ci ps rule pi cs pi cs ci type knit shows rule required yield synthesised attributes ps starting empty record 
furthermore rule transform inherited attributes pi inherited attributes ci child 
shows child parent inherited attributes input rule type pi 
definition shows parent inherited attributes pi default values child inherited attributes application rule 
rule redefine child inherited attributes default behavior copy parent 
resulting semantic function applied semantics child inherited attributes parent pi returns synthesised attributes ps 
inherited attributes ci child synthesised attributes ps joint result applying rule 
completes set basic combinators manipulating rules semantic functions arity 
similar combinators arities omit details 
discussion aspect oriented programming aop inability separate aspects exclusive area compiler writing received considerable attention areas programming 
gregor kiczales team xerox initiated study aspect oriented programming general terms notion adaptive object oriented programming karl lieberherr shares goals 
don batory team uta studied ways describe aspects software generators cut traditional object class boundaries 
modest contribution developments showing compilers structured aspect oriented style 
hopeful techniques employed applied writing aspect oriented programs problem domains 
worthwhile point deviations kiczales original notion aop 
notion aspect highly restrictive covers examples weaving aspects existing code purely name dependent sophisticated program analyses 
example kiczales framework aspect maintains invariant relationship variables updated invariant restored making appropriate change variable 
weave aspect existing code find places changed techniques say sophisticated aspects 
fact avoid forms program analysis require original attribute grammar written rule grammar form 
difference style 
aop traditional method composing programs replaced complemented aspects 
example misleading took extreme approach sliced original attribute grammar completely terms aspects abandoning primary composition method 
done purely expository purposes reason write rule grammar traditional style add aspects 
norm writing larger attribute grammars 
suggest production method composition replaced aspect simply augmented 
aspects useful tool creating attribute grammars instances superior composition production 
summary expect techniques relevant applications aspect oriented programming problem domains weaving purely name 
definitions simple functional programming language view contribution step semantics aspects 
attribute grammar systems obvious objection attribute grammar compiler generators offer factorisation seek purely syntactic level 
programmer attribution rules order preprocessor rearranges group rules production 
situation akin dichotomy macros procedures applications procedures coded macros concept procedure useful important 
contrast macros procedures offer sound type checking independent entities stored compiled manipulated program 
benefits deriving having aspects explicit class entities programming language 
adams proposes similar decomposition method lacks type checking aspects possible 
ganzinger giegerich modularize attribute grammars decomposing translation process phases 
coarser decomposition proposed method decompose specifications phases aspect production 
type system guarantees attributes defined defined 
guarantees course ensured specialised attribute grammar systems 
systems usually test cycles attribute definitions 
moving dedicated attribute definition language general programming language analysis feature give 
cycle checks approximation inevitably rule attribute grammars evaluated problems 
investigating additional advanced features systems mimicked setting companion presents substantial case study shows technique admits concepts local attributes higher order attribute grammars natural manner 
attribute grammar production language complete semantics completed confident certain method scale handle larger attribute grammars 
ultimate aim provide suitable meta language rapid prototyping domain specific languages intentional programming system development microsoft research different attribute grammar systems faces issues modularity evaluation schemes specification language choice 

adams 
modular grammars programming language prototyping 
phd thesis department electronics computer science university southampton uk 

aho sethi ullman 
compilers principles techniques tools 
addison wesley 

batory singhal thomas 
genvoca model software system generators 
ieee software 

bird 
formal development efficient compiler 
science computer programming 

bird 
functional programming haskell 
international series computer science 
prentice hall 

de moor 
class attribute grammars 

draft available url www comlab ox ac uk users oege homepage htm 
jourdan 
attribute grammars definitions systems bibliography volume 
springer verlag 

ganzinger giegerich 
attribute coupled grammars 
proceedings acm symposium compiler construction 
published acm sigplan notices 

jones 
polymorphic type system extensible records variants 
technical report tr department computer science university nottingham uk 
available url www cs nott ac uk department staff mpj html 

gray levi sloane waite 
eli complete flexible compiler construction system 
cacm 

johnsson 
attribute grammars functional programming paradigm 
kahn editor functional programming languages computer architecture volume lncs pages 
springer verlag 

jourdan 
strongly non circular attribute grammars recursive evaluation 
sigplan notices 

jourdan parigot juli le 
design implementation evaluation fnc attribute grammar system 
conference programming languages design implementation pages 
published acm sigplan notices 

kastens 
attribute grammars compiler construction environment 
proceedings international summer school attribute grammars applications systems volume lncs pages 

kastens zimmermann 
gag practical compiler generator volume lncs 
springer verlag 

kastens waite 
modularity reusability attribute grammars 
acta informatica 

kiczales 
aspect oriented programming 
acm computing surveys 
see www parc xerox com spl projects aop 

knuth 
semantics context free languages 
mathematical systems theory 

kuiper swierstra 
attribute grammars derive efficient functional programs 
computing science netherlands csn 
see ftp ftp cs ruu nl pub ruu cs cs ps gz 

kuiper 
lrc generator incremental language oriented tools 
koskimies editor th international conference compiler construction pages 
volume lncs 
springer verlag 

lieberherr 
adaptive object oriented software demeter method propagation patterns 
pws publishing 

ohori 
polymorphic record calculus compilation 
acm transactions programming languages systems 

emy 
typechecking records variants natural extension ml 
proceedings acm symposium principles programming languages popl pages 
acm press 

emy 
typing record concatenation free 
gunter mitchell editors theoretical aspects object oriented programming types semantics language design foundations computing series 
mit press 

reps teitelbaum 
synthesizer generator system constructing language editors 
springer verlag 


attribute evaluator haskell 
technical report manchester university 
see url www inria fr oscar www fnc ag html 


intentional programming innovation legacy age 
ifip working group 
available url www research microsoft com research ip 

swierstra 
designing implementing combinator languages 
swierstra editor rd international summer school advanced functional programming volume lncs 
springer verlag 
see url www cs uu nl groups st software index html 

wand 
type inference record concatenation multiple inheritance 
information computation 
