backtracking constraint satisfaction problems rina dechter daniel frost department information computer science university california irvine irvine california usa performance backtracking algorithms solving nite domain constraint satisfaction problems improved substantially look back look ahead methods 
look back techniques extract information analyzing failing search paths terminated dead ends 
look ahead techniques constraint propagation algorithms avoid dead ends altogether 
survey describes number look back variants including backjumping constraint recording recognize avoid unnecessary explorations search space 
portion gives overview look ahead methods forward checking dynamic variable ordering discusses combination backjumping 
key words constraint satisfaction backtracking backjumping pacs email address dechter uci edu frost uci edu rina dechter daniel frost 
supported part nsf iis muri onr award 
preprint submitted elsevier science december constraint paradigm useful studied framework expressing problems interest arti cial intelligence 
constraint networks proven successful modeling mundane cognitive tasks vision language comprehension default reasoning abduction specialized reasoning tasks including diagnosis design temporal spatial reasoning 
presents survey search solving constraint satisfaction problems emphasis look back enhancements 
provide detailed exposition algorithm theoretical underpinnings relationships similar algorithms 
worst case bounds time space usage developed algorithm 
look back backjumping schemes fresh exposition comparison primary variants gaschnig backjumping graph backjumping con ict directed backjumping 
complexity algorithms function parameters constraint graph explicated 
include complexity backjumping function depth dfs traversal constraint graph complexity learning algorithms function induced width complexity look ahead methods partial lookahead function size cycle cutset constraint graph 
remainder organized follows 
section de nes constraint framework provides overview basic algorithms solving constraint satisfaction problems 
exposition applicable general non binary csp de nition 
section backtracking algorithm 
sections survey analyze look back methods backjumping learning schemes section surveys look ahead methods 
section describes look back look ahead approaches integrated provides comparison selected algorithms heuristics covers 
section brief historical review eld 
previous surveys constraint processing backtracking algorithms relevant overviews 
constraint framework de nitions constraint satisfaction problem csp constraint network consists set variables fx set nite value domains unary constraint binary constraints ft ft ft ft ft fig 

constraint graph constraint relations scheduling problem example 
fd set constraints relations fr value domain nite set values assigned corresponding variable 
constraint relation de ned unique subset variables called constraint scope 
tuple relation denotes legal combinations values variables 
constraint scope subset cartesian product domains variables constraints described mathematical expressions computable procedures indicate valid invalid assignments 
constraint arity number variables scope unary constraint applies single variable binary constraint arity 
binary csp constraints unary binary 
constraint graph associates vertex variable edge vertices associated variables appear constraint scope 
example 
constraint framework useful expressing solving scheduling problems 
consider problem scheduling tasks takes hour complete 
tasks may start 
number tasks executed simultaneously subject restrictions start start execute time start 
tasks time slots model scheduling problem creating variables task giving variable domain 
equally valid approach create variables starting time give variables domain power set ft 
adopting rst approach problem constraint graph shown 
case problem unary binary constraints 
constraint relations shown right gure 
example tuple constraint ft indicates starting task task permitted de nition relation tasks 
variable called instantiated assigned value domain uninstantiated 
denote variable instantiated value domain 
describing algorithm indicates act assigning value variable partial instantiation partial assignment subset fx tuple ordered pairs frequently abbreviated 
denote consecutive set instantiated variables denote assignment arbitrary subset variables 
notations mixed set variables instantiation variables constraint scope denote tuple consisting values assigned variables satis es violated consistent satis es applicable constraints constraints consistent partial instantiation called partial solution 
solution consistent instantiation variables 
nogood assignment values arbitrary subset variables part solution see de nition 
assignment con icts partial solution consistent see de nition 
example 
refering csp partial solution relevant constraints violated partial instantiation 
partial solution extended include 
violates unary constraint values con ict partial solution violates constraint violates constraint 
solution problem 
constraint algorithms problem interest formulated constraint satisfaction problem solution general purpose constraint algorithm 
constraint satisfaction problems np complete 
csp algorithms principles search deduction 
section brie summarize eld csp algorithms 
search backtracking term search characterize large category algorithms solve problems guessing operation perform action take possibly aid heuristic 
guess results new state nearer goal 
operation result progress goal may apparent search operation retracted guess 
csps search exempli ed backtracking algorithm 
backtracking search uses operation assigning value uninstantiated variable extending current partial solution 
explores search space depth rst manner 
acceptable value previous assignment retracted called backtrack 
worst case backtracking algorithm requires exponential time number variables linear space 
backtracking algorithm rst described century ago reintroduced times 
deduction constraint propagation solve problem deduction apply reasoning transforms problem equivalent explicit form 
csp framework frequently type deduction known constraint propagation consistency enforcing algorithms 
procedures transform constraint network deducing new constraints tightening existing constraints removing values variable domains 
general consistency enforcing algorithm partial solution subnetwork extendible surrounding network guaranteeing certain degree local consistency de ned follows 
constraint network consistent values domain variable satisfy network unary constraints 
network consistent consistent partial instantiation distinct variables exists consistent instantiation single additional variable 
terms node arc path consistency correspond consistency respectively 
ordering variables network directional consistent subset variables consistent relative single variable succeeds variables ordering 
problem consistent called globally consistent 
variety algorithms developed enforcing di erent levels local consistency called constraint propagation :10.1.1.29.597
example arc consistency algorithms delete values domains variables ensure value domain variable consistent value domain variable 
path consistency achieved introducing new constraints nogoods disallow certain pairs values 
relational consistency enforcing algorithms allow exible extensions consistency algorithms constraint variable 
constraint propagation csp solution procedure 
problem consistent solutions easily transformed problem backtracking 
enforcing consistency requires general exponential time exponential space practice bounded local consistency enforcing algorithms 
example 
example enforcing consistency network result value removed domain value incompatible unary constraint 
enforcing consistency cause domain values removed 
instance constraint implies scheduled possible time occur 
arc consistency algorithm actions remove domain 
algorithms enforce local consistency performed preprocessing step advance search algorithm 
cases backtracking eciently representations explicit possible having high level local consistency 
extreme preprocessing alternative adaptive consistency technique adjusts level enforced consistency node node basis 
ordered constraint graph processed adaptive consistency solved backtracking search 
space time complexity adaptive consistency exponential parameter ordered graph called see de nition 
value computed advance linear time ordering value tradeo ort spent pre processing reduced ort spent search assessed experimentally dependent character problem instance solved 
varying levels consistency enforcing interleaved search process 
primary way consistency enforcing techniques incorporated backtracking search constraint programming languages 
constraint algorithms structure driven algorithms may employ search components emerge studying topology constraint problems tractable 
tractable classes constraint networks generally recognized realizing problems enforcing low level consistency polynomial time guarantees global consistency solution problem 
basic graph structure supports tractability tree 
particular enforcing consistency tree structured binary csp network ensures solution dead ends recognizable ordering variables 
popular class incomplete algorithms stochastic methods typically move hill climbing manner augmented random steps space complete instantiations 
techniques guaranteed solve problem instance 
csp community interest stochastic approaches sparked success gsat algorithm variants 
backtracking backtracking algorithm backtracking primary search algorithm constraint problems 
traverses search space partial instantiations depth rst manner 
algorithm maintains partial solution denotes state search space 
backtracking phases forward phase variable selected current partial solution extended assigning consistent value exists variable backward phase consistent solution exists current variable focus returns previous variable assigned 
describes basic backtracking algorithm 
description backtracking repeatedly calls selectvalue subprocedure nd value current variable consistent current partial instantiation selectvalue turn relies consistent subprocedure returns true current partial solution consistent candidate assignment variable 
selectvalue succeeds nding value backtracking proceeds variable selectvalue nd consistent value dead occurs backtracking looks new value previous variable algorithm terminates variables assignments proven values lead solution problem unsolvable 
presentation backtracking stops single solution easily modi ed return solutions desired number 
backtracking procedure employs series mutable value domains holds subset procedure backtracking input constraint network 
output solution noti cation network inconsistent 
initialize variable counter copy domain instantiate selectvalue null value returned backtrack step forward return inconsistent return instantiated values fx procedure subprocedure selectvalue return value consistent empty select arbitrary element remove consistent return return null consistent value procedure fig 

backtracking algorithm 
examined current partial instantiation earlier variables 
sets needed values mapped contiguous set integers considered ascending order case single integer marker divide values considered 
sets describe backtracking increased generality consistent portrayal complex algorithms 
selectvalue consistent separated main backtracking routine clarity 
access local variables parameters main procedure 
consistent handles general binary non binary constraints implementation specify depends constraints represented computer program 
consistent subprocedure description algorithms 
example 
consider coloring problem 
assume backtracking search solution possible orderings search spaces orderings portions explicated backtracking left right depicted respectively 
legal states partial solutions depicted gure 
complexity consistent selectvalue determined premise constraints stored tables 
number constraints problem maximum number tuples constraint 
maximum size domain maximum constraint arity constraints organized permit nding tuple constraint worst case logarithmic time log log log variable may participate constraints worst case time complexity consistent log bounded log 
selectvalue may invoke consistent times worst case time complexity selectvalue log log 
special case binary csp practical store constraints table boolean values indexed variables values 
tentative instantiation checked earlier variables ectively yielding complexity consistent nm complexity selectvalue 
consistent performs computations table lookups complexity course dependent nature computations 
summary proposition general csps constraints stored tables having variables constraints constraint arity bounded number tuples constraint bounded values variable time complexity consistent log log time complexity selectvalue log log 
binary csps complexity selectvalue nm 
improvements backtracking constraint satisfaction decade devoted improving performance backtracking search 
backtracking usually su ers thrashing rediscovering inconsistencies partial successes search 
performance backtracking improved reducing size search space determined algorithm control strategy constraints inherent level local consistency order variable instantiation single solution suces order values red blue green blue green red blue blue green red green red blue red blue fig 

coloring problem variables 
domain variable written inside corresponding node 
arc represents constraint variables connects assigned di erent colors 
assigned variable 
addressing factors researchers developed procedures types employed performing search bounding size underlying search space dynamically search decide parts search space visited 
commonly pre processing techniques arc path consistency algorithms heuristic approaches determining xed variable ordering 
procedures dynamically improving pruning power backtracking conveniently classi ed look back schemes look ahead schemes accordance backtracking main phases going forward assemble solution going back case dead 
look back schemes invoked algorithm preparing backtrack encountering dead 
schemes perform functions deciding far backtrack 
analyzing reasons deadend irrelevant backtrack points avoided algorithm goes back directly source failure just immediately preceding variable ordering 
procedure referred backjumping 
recording reasons dead form new constraints con icts arise search 
terms describe function constraint recording learning 
look ahead schemes invoked algorithm preparing assign value variable 
frequently schemes discover restricted amount constraint propagation current decisions variable value selection impact search 
information ways 
fig 

backtracking search orderings example instance 
intermediate states indicated lled ovals dead ends lled rectangles solutions empty ovals 
colors considered order blue green red abbreviated rst letters 
thick lines denote portion search space explored backtracking stopping rst solution 
decide variable instantiate order predetermined 
generally advantageous rst instantiate variables maximally constrain rest search space 
selecting variable number values domain constraint propagation tends minimize size search tree 
decide value assign variable 
generally searching single solution attempt assign value maximizes number options available assignments 
sections describe detail principle look back schemes section provide overview look ahead methods including combination look ahead look back methods 
backjumping backjumping schemes primary tools reducing backtracking undesirable tendency rediscover dead ends 
value variable backtracking returns suppose new value exists constraint dead encountered value values exhausted 
instance problem dead assignment red blue blue blue green red 
backtracking return instantiate dead encountered backjumping algorithms identify culprit variable responsible dead jump back immediately culprit variable instantiating chronologically previous variable repeatedly 
identi cation culprit variable notion con ict sets 
con ict sets dead state level search tree indicates current partial instantiation con icts values 
called dead state called dead variable 
may con ict going back changing value resolve dead variable general tuple dead may contain con ict partial instantiation part solution 
backtracking control strategy may retreat alternately variable resolving con ict sets 
result dead guaranteed recur 
going previous variable algorithm jump back dead state variable contains con ict sets dead variable turns identifying culprit variable fairly easy 
de nition con ict set consistent instantiation arbitrary subset variables variable instantiated 
value domain consistent say con ict set con icts variable addition contain con icts called minimal con ict set de nition leaf dead variable ordering tuple consistent 
con ict called leaf dead 
de nition nogood problem partial instantiation appear solution called nogood 
minimal nogoods nogood 
con ict set clearly nogood nogoods con ict sets single variable 
may con ict variables simultaneously 
example 
consider csp variable ordering 
partial instantiation blue blue dead con ict set variable 
blue blue nogood instantiation consistent values backjumping discovers dead jump far back possible skipping potential solutions 
intuitively issues safety jumping maximality magnitude jump need de ned relative information recorded algorithm 
safe maximal style backjumping may safe maximal especially engaged di erent levels information gathering 
discuss styles backjumping gaschnig backjumping graph backjumping lead di erent notions safety maximality 
de nition safe jump leaf dead state 
say jumping safe partial instantiation nogood extended solution 
words know value changed solution missed 
de nition culprit variable leaf dead 
culprit index relative de ned con icts de ne culprit variable notions culprit tuple culprit variable interchangeably 
de nition con ict set minimal relative pre tuples associated pre subset ordered variables 
claim jumping back safe maximal safe extended solution maximal jumping back earlier node risks missing solution 
proposition leaf dead discovered backtracking culprit variable safe destination 
proof de nition culprit con ict set nogood 
consequently jumping changing value consistent value exists result skipping potential solution 
prove maximality observe jumping farther back earlier node risks skipping potential solutions 
speci cally algorithm jumps de nition culprit variable con ict set may part solution 
note may may nogood original problem nogood subproblem de ned fx backjumping algorithm determine safe information 
variants backjumping 
gaschnig backjumping implements idea jumping back culprit variable leaf deadends 
graph backjumping extracts information irrelevant backtrack points exclusively constraint graph 
introduces notion jumping back internal dead ends leaf dead ends 
con backjumping combines maximal leaf internal dead ends 
gaschnig backjumping wait dead occur gaschnig backjumping records information generating uses information determine dead culprit variable gaschnig backjumping algorithm subprocedure selectvalue identi es records culprit variable 
originally described gaschnig algorithm handled binary csps 
version straight forward extension high arity constraints 
variable associated number latest points dead variable latest predecessor tested incompatibility possible instantiation binary csp say concretely letting latest binary constraint prohibiting current instantiation consistent consistent value relative dead variable latest assigned value 
gaschnig backjumping jumps leaf dead inconsistent back latest culprit dead variable proposition gaschnig backjumping implements safe maximal leaf dead ends 
procedure gaschnig backjumping input constraint network 
output solution decision network inconsistent 
initialize variable counter copy domain latest initialize pointer latest instantiate selectvalue null value returned latest latest return inconsistent return instantiated values fx procedure subprocedure selectvalue empty select arbitrary element remove consistent true consistent latest latest records latest latest variable checked consistency consistent consistent false consistent return return null consistent value procedure fig 

gaschnig backjumping algorithm 
proof leaf dead algorithm partial instantiation 
latest algorithm jumps back tuple clearly con ict show minimal 
latest domain exhausted dead happen previously earlier con ict set culprit variable de ned de nition 
proposition follows algorithm safe maximal 
example 
problem dead red blue blue blue green red latest red ruled red blue ruled blue variable examined 
returning algorithm nds values try 
latest variable examined demonstrate algorithm ability leaf dead ends 
subsequent dead ends goes back preceding variable 
gaschnig backjumping jump leaf dead 
children node search tree lead dead ends happens red green node called internal dead 
algorithm graph backjumping implements jumps internal dead ends leaf dead ends 
graph backjumping graph backjumping extracts knowledge possible con ict sets constraint graph exclusively 
graph need represent binary csp 
dead occurs partial solution extended variable algorithm jumps back variable adjacent constraint graph values internal dead algorithm jumps back time variable connected 
second jumps jumps internal dead ends 
precompiled information encoded graph algorithm avoids computing latest consistency test 
graph backjumping uses subset earlier variables adjacent constraint graph approximation minimal con ict set constraint exists variables particular value currently assigned may con ict potential value importance graph backjumping studying algorithms procedure graph backjumping input constraint network 
output solution decision network inconsistent 
compute anc see de nition text initialize variable counter copy domain anc initialize induced ancestor set instantiate selectvalue null value returned latest fx merge update anc return inconsistent return instantiated values fx procedure subprocedure selectvalue backtracking empty select arbitrary element remove consistent return return null consistent value procedure fig 

graph backjumping algorithm 
performance tied constraint graph leads graph theoretic complexity bounds graph heuristics aimed reducing bounds 
bounds applicable algorithms re ned run time information gaschnig backjumping con ict directed backjumping 
particular show depth rst search ordering variables graph backjumping simple implement allows complexity bound function depth constraint graph depth rst search spanning tree 
introduce graph terminology ahead 
fig 

ordered constraint graphs problem induced graph dfs spanning tree ordering de nition ancestors parent constraint graph ordering nodes ancestor set variable denoted anc subset variables precede connected parent denoted latest variable anc 
leaf dead equate anc anc 
example 
consider ordered graph ordering example anc fx parent leaf dead blue green red red blue red parent easy show leaf dead jumping back safe 
graph information utilized culprit variables computed gaschnig backjumping unsafe jump back 
facing internal dead may safe jump parent example demonstrates 
example 
consider constraint network ordering ordering parent assume deadend occurs node algorithm returns values try perfectly safe jump back parent consider di erent scenario 
algorithm encounters dead leaf jumps back internal dead control returned internal dead jumping unsafe change value undo dead started latest retreat 
dead variable initiated latest retreat safe jump far back encountering internal dead clearly encountering internal dead matters node initiated retreat 
show graph culprit variable determined induced ancestor set current session 
de nition session say backtracking processes coming variable earlier ordering 
session starts ends retracting variable precedes constraint network searched backtracking backjumping algorithm current session set variables algorithm latest de nition induced ancestors induced parent variable internal dead 
subset variables consisting dead ends current session denote anc anc 
induced ancestor set relative union ancestors restricted variables precede formally anc fx induced parent relative latest variable 
theorem dead leaf internal set dead variables leaf internal current session graph information earliest safe variable jump 
proof de nition variables participate constraint dead variables current session 
consequently change value variables perturb nogoods caused dead skipped 
show algorithm jumped variable earlier solutions skipped 
rst dead variable connected argue way graph information rule possibility exists alternative value may lead solution 
assigned value moment dead occurred 
variable leaf dead internal dead 
leaf dead ancestor constraint scope contains current assignment restricted extended legal value clearly value changed current assignment may extendible legal tuple dead may occurred 
possibility solution alternative value ruled 
case internal dead means values consistent extended solution 
ruled graph di erent values attempted permit new values solution exist 
example 
consider ordered graph dead variable 
leaf dead fg sole member induced ancestor set 
algorithm may jump safely internal dead fx induced ancestor set fx fx algorithm safely jump fx corresponding induced parent set fx fx encountering dead algorithm retract internal dead algorithm retracts fx fx fx dead encountered dead jump back go forward jump back jump fx fx algorithm retracts dead retract fx fx algorithm graph backjumping implements principles graph backjumping 
jumps maximal culprit variables leaf internal dead ends 
variable algorithm maintains induced ancestor set relative dead ends current session 
con ict directed backjumping ideas jumping back variable instantiated con ict current variable jumping back internal dead ends integrated single algorithm con ict directed backjumping algorithm 
algorithm uses scheme outlined graph backjumping relying graph information exploits information gathered search 
variable algorithm maintains induced set 
dead tuple de ne set variables participating earliest minimal con ict set 
rst de ne ordering constraints 
scope denote scope constraint de nition earlier constraint ordering variables constraint problem say constraint earlier constraint latest variable scope scope precedes latest variable scope scope 
instance variable ordering scope constraint scope constraint earlier precedes ordering variables earlier relation de nes total ordering constraints de nition earliest minimal con ict set problem ordering variables dead tuple dead variable earliest minimal con ict set denoted emc generated follows 
consider constraints fr scopes fs order de ned de nition 
exists violated constraint earlier violated var emc var emc emc containing just variable value pairs variable var emc 
de nition set set dead de ned include var emc dead ends occurred current session formally fvar emc dead var emc plays role ancestors graphical scheme plays role induced ancestors 
elicited graph dependent particular value instantiation uncovered search 
set variables var emc subset set graph variables anc 
variables graphbased anc included var emc participate irrelevant constraints exclude value relative current instantiation relevant super uous rule values eliminated earlier constraints 
consequently similar arguments graph case possible show proposition dead tuple latest variable set earliest variable safe jump 
proof sketch latest variable set dead graph case jumping back variable remove nogoods active causing dead dead recur 
show jump back earlier need show generate var emc set looking earliest constraints rst possible exists alternative set constraints dead set yields earlier culprit variable 
possible changing value yield solution solution missed jumped earlier variable 
algorithm conflict directed backjumping 
computes sets variable uses determine variable returns dead 
proposition algorithm con ict directed backjumping jumps back latest variable dead set safe maximal 

example 
consider problem ordering 
dead assignment blue green red red blue red emc set blue red accounts eliminating values algorithm con ict directed backjumping jumps internal dead var emc set fx set includes just algorithm jumps time back complexity backjumping return graph backjumping show graph information yield graph complexity bounds relevant variants backjumping 
implementation graph backjumping requires general careful maintenance variable induced ancestor set orderings facilitate particularly simple rule determining variable jump 
graph depth rst search dfs ordering generated dfs traversal graph 
traversal ordering results dfs spanning tree graph includes arcs graph traversed forward manner 
depth dfs spanning tree number levels tree created dfs traversal see 
procedure conflict directed backjumping input constraint network 
output solution decision network inconsistent 
initialize variable counter copy domain initialize con ict set instantiate selectvalue cbj null value returned index variable fx merge con ict sets step forward reset mutable domain reset con ict set return inconsistent return instantiated values fx procedure subprocedure selectvalue cbj empty select arbitrary element remove consistent true consistent consistent earliest constraint causing con ict add variables scope consistent false consistent return return null consistent value procedure fig 

con ict directed backjumping algorithm 
arcs dfs spanning tree directed higher indexed node 
node neighbor dfs tree preceding ordering called dfs parent 
graph backjumping dfs ordering constraint graph nding maximal graph back jump destination requires simple rule dead leaf internal occurs variable go back dfs parent example 
consider csp 
dfs ordering corresponding dfs spanning tree dead occurs node algorithm dfs parent summary theorem dfs ordering constraint graph denotes dfs parent dead graph culprit variable leaf internal dead ends 
proof dfs ordering corresponding dfs tree show dead internal leaf latest induced ancestors clearly appear induced ancestor set connected precedes ordering 
variables appear session descendents dfs subtree rooted dead variable session easy see ancestors precede lie path root coincide appear 
rst graph related bounds complexity backjumping 
theorem graph backjumping performed dfs ordering constraint graph complexity steps bounds branching degree dfs tree associated ordering depth domain size 
proof node dfs spanning tree dfs subtree depth stands maximal number nodes search tree rooted maximum number nodes visited session assignment value generates subtrees depth solved independently obeys recurrence 

solving recurrence yields worst case time complexity graph backjumping terms number nodes visited 
notice tree balanced internal node exactly child nodes bound improved 
bound suggests graph ordering heuristic dfs ordering having minimal depth 
unfortunately nding minimal depth dfs tree np hard 
knowing minimizing may lead useful heuristics 
shown graph backjumping bounded larger class variable orderings dfs ones 
graph concepts introduced 
de nition width tree width graph nodes fx ordering width node ordered graph number earlier neighbors 
width ordering maximal width nodes ordering width graph minimum width orderings 
induced ordered graph denoted ordered graph obtained connecting earlier neighbors going reverse order induced width ordered graph denoted maximal number earlier neighbors node minimal induced width graph orderings induced width related known parameter called tree width graph identical induced width 
information see 
example 
consider graph ordered width ordering width node hand width ordering just width ordering just 
induced graph 
added arcs connecting earlier neighbors going denoted broken lines 
note induced width node changes 
induced width ordering remains 
shown dfs orderings induced graphs allow bounding backjumping complexity function depth corresponding dfs tree 
ordering dfs ordering induced graph dfs tree depth 
theorem depth dfs tree traversal induced graph dfs ordering complexity graph backjumping ordering exp 
proof uses somewhat di erent terminology derivation 
virtue theorem allowing larger set orderings yielding bound backjumping performance function dfs tree depth considered 
dfs ordering dfs ordering induced graph added induced arcs back arcs dfs tree dfs orderings subset dfs orderings induced graphs 
may lead better orderings having better bounds backjumping 
backjumping notion con ict set simple restriction identify con icts single variable 
lift restriction look little ahead 
example backtracking instantiates variables forward phase happens instantiates variables time 
section discuss various techniques looking ahead 
point wish mention restricted type look ahead incorporated naturally backjumping 
de ne set parameterized backjumping algorithms called backjumping algorithms indexes number variables consulted forward phase 
algorithms jump back maximally leaf internal dead ends follows 
ordering variables instantiate time con ict directed backjumping note con ict directed backjumping backjumping 
selecting new value variable sure new value consistent past instantiation consistently extendable variables 
computation performed node exploited generate re ned con ict sets backjumping con ict sets nogoods con ict variables 
leads concept level con ict sets 
tuple level con ict set consistently extendable variables 
dead identi ed backjumping associated con ict set level con ict set 
algorithm assemble earliest level con ict set jump latest variable set exactly done backjumping 
balance computation overhead node savings node generation course studied empirically 
learning algorithms earliest minimal con ict set de nition nogood explicated search guide backjumping 
nogood may rediscovered algorithm explores di erent paths search space 
making nogood explicit form new constraint sure algorithm rediscover 
doing may prune remaining search space 
technique called constraint recording learning learning algorithms described section 
opportunity learn new constraints backtracking algorithm encounters dead current instantiation con ict set problem included explicit constraint prohibiting con ict set dead reached 
learning procedure records new constraint explicit incompatibility existed implicitly set variable assignments 
point recording stage con ict set constraint backtracking control strategy current state recur 
contains subsets con ict recording smaller con ict sets constraints may prove useful continued search states may contain con ict sets exclude larger con ict sets 
goal speeding search target learning identify con ict sets small possible minimal 
noted obvious candidate earliest minimal con ict set identi ed anyway con ict directed backjumping 
alternatively graph information graph con ict set identi ed recorded 
extreme option learn record minimal con ict sets associated current dead 
learning algorithms savings possibly reducing amount search nding earlier path lead solution balanced costs processing node generation extensive database constraints 
learning algorithms may characterized way identify smaller con ict sets 
learning deep shallow 
deep learning records minimal con ict sets 
shallow learning allows con ict sets recording constraint may useful initial set constraints expected queried 
assumption computer program represents constraints internally storing invalid combinations 
increasing number stored nogoods increases size data structure slows retrieval 
recorded 
learning algorithms may characterized bound arity constraints recorded 
constraints involving variables frequently applicable require additional memory store expensive consult constraints having fewer variables 
algorithm may record single nogood multiple nogoods dead may allow learning leaf dead ends internal dead ends 
types learning graph learning deep learning learning 
restricted bounding scope size constraints recorded referred bounded learning 
algorithms exemplify main alternatives numerous possible variations 
graph learning graph learning uses methods graph backjumping identify nogood information con icts derived constraint graph 
leaf dead values assigned ancestors graph identi ed included con ict set recorded 
example 
consider problem searching solutions 
presents search space explicated naive backtracking backtracking augmented graph learning 
branches cut lines generated 
leaf dead ends numbered dead appear search learning numbered 
dead search learning record new constraint 
dead consistent value exists ancestor set fx graph learning records nogood green blue blue red 
nogood reappears search subtree rooted prune search dead numbered 
dead ends labeled occur consistent value ancestor set fx nogoods blue red red blue recorded graph learning ect creating equality constraint 
dead ends involve nogoods graph backjumping backtracking dead ends avoided 
learned constraint prunes remaining search times 
additional nogoods recorded graph learning indicated dead ends green red red blue blue green red red green blue green blue blue green red red 
fig 

search space explicated backtracking csp variable ordering value ordering blue red green 
part shows constraint graph part illustrates search space 
cut lines indicate branches explored graph learning 
note dead ends occur learning learning 
complexity learning dead graph learning variable connected earlier variables 
augment graph backjumping graph learning need add line bold face graph backjumping fig 
dead encountered instantiate selectvalue null value returned record constraint prohibiting corresponding values algorithm continues fig 
recording new constraint may require adding new relation list constraints constraint scope exists may necessary remove value tuple constraint 
deep learning identifying recording minimal con ict sets constitutes deep learning 
discovering minimal con ict sets means acquiring possible information dead 
problem ordering example rst dead deep learning record minimal con ict set green blue red green blue red non minimal con ict set including recorded graph learning 
deep learning informative cost prohibitive want minimal con ict sets worst case exponential size initial con ict set 
cardinality graph con ict set envision worst case subsets size minimal con ict sets dead variable 
number minimal con ict sets amounts exponential time space complexity dead 
discovering minimal con ict sets implemented enumeration rst recognize con ict sets element elements 
general graph learning records largest size constraints deep learning records smallest ones 
noted backjumping virtues graph learning mainly theoretical see section advocate algorithm practice learning superior 
recommend deep learning cost usually prohibitive 
learning avoid explosion time space full deep learning may settle identifying just con ict set minimal relative pre con ict sets 
obvious candidate set leaf internal dead ends explicated con ict directed backjumping 
learning uses set values assigned variables con ict set learned 
con ict set calculated underlying backjumping algorithm time complexity dead learning storing con ict set 
graph learning modi cation required augment conflict directed backjumping learning algorithm minor specifying con ict set recorded nogood dead 
instantiate selectvalue cbj null value returned record constraint prohibiting corresponding values algorithm continues fig 
example 
problem ordering example rst deadend learning record nogood green blue red tuple includes variables set bounded learning relevance bounded learning learning algorithm compounded restriction size con icts learned 
con ict sets size greater ignored result order graph learning order learning order deep learning 
restricting arity recorded constraint bounded learning algorithm overhead complexity time space exponentially bounded alternative bounding size learned nogoods bound learning process discarding nogoods appear longer relevant measure 
de nition relevant nogood relevant di ers current partial assignment variable value pairs 
de nition th order relevance bounded learning th order relevance bounded learning scheme maintains learned nogoods relevant 
dynamic backtracking algorithm employs similar notion retaining learned nogoods consulted near search :10.1.1.27.4126
nonsystematic randomized backtracking learning learning incomplete search algorithms complete guaranteed terminate solution proof solution exists 
consider backtracking algorithm xed number dead ends restarts terminated normally di erent randomly selected variable value ordering 
study approach motivated observing performance incomplete greedy local search algorithms outperform traditional algorithms 
problem randomization search algorithm incomplete 
completeness guaranteed randomization nogoods discovered recorded consulted subsequently search including randomized restarts 
randomized learning algorithms complete reach dead discover record new con ict set 
number con ict sets nite algorithms complete guaranteed nd solution prove solution exists 
subsection argument bound complexity learning algorithms 
complexity backtracking learning graph learning yields useful complexity bound backtracking performance parameterized induced width introduced de nition 
graph learning conservative learning algorithm excluding arity restrictions complexity bound applicable corresponding variants learning discussed 
theorem ordering constraint graph induced width 
backtracking algorithm ordering graph learning space complexity nk time complexity nm number variables bounds domain sizes 
proof graph learning correspondence deadends con ict sets 
backtracking graph learning records con ict sets size dead variable connected earlier variables original constraints recorded ones 
number dead ends bounded number possible nogoods size yielding space nk deciding dead occurred requires testing constraints de ned dead variable prior variables constraints checked dead yielding time complexity bound nk 
recall time complexity graph backjumping bounded exp depth dfs tree corresponding ordered induced graph algorithm requires linear space 
clearly 
shown graph log 

reduce time bound graph backjumping factor log need invest exp space augmenting backjumping learning 
look ahead strategies turn attention look ahead methods designed improve forward phase backtracking algorithms 
combining backtracking constraint propagation way csp search algorithms combine backtracking local constraint propagation applying consistency enforcing procedure current subproblem 
combination known looking ahead decision accept reject value current variable impact assignment constraint propagation applied set uninstantiated variables 
partial instantiation may induce constraints remaining variables making constraints explicit may reveal useful information reduce amount backtracking search subsequently required 
course actions conditioned partial instantiation retracted partial instantiation longer current due backtracking 
example 
consider coloring problem assume variable rst ordering assigned value red 
lookahead procedure note value red domains incompatible partial instantiation provisionally remove values 
extensive look ahead procedure may note connected left incompatible values variable domain problem red arc consistent 
implication assigning red inevitably lead dead assignment rejected 
look ahead strategies incur extra cost instantiation provide bene ts 
removing variable domain values consistent partial instantiation procedure backtracking lookahead input constraint network output solution noti cation network inconsistent 
copy domains initialize variable counter instantiate selectvalue xxx null value returned backtrack reset value instantiated remove constraints added instantiated step forward return inconsistent return instantiated values fx procedure fig 

common framework look ahead search algorithms 
replacing selectvalue xxx selectvalue forward checking forward checking algorithm obtained 
similarly selectvalue arc consistency yields algorithm interleaves arc consistency search 
eliminate need test values current variable consistency previous variables 
corollary bene values uninstantiated variable removed look ahead procedure current instantiation part solution algorithm backtrack 
consequently dead ends occur earlier search smaller search spaces typically result look ahead employed 
general stronger level constraint propagation look ahead smaller search space explored higher computational overhead 
bene look ahead sizes uninstantiated variable domains guide selection variable value choose return topic section 
look ahead algorithms algorithm backtracking lookahead presents framework look ahead algorithms specialized level constraint propagation expressed speci selectvalue subprocedure employed 
backtracking lookahead initially sets subprocedure selectvalue forward checking empty select arbitrary element remove empty domain false values consistent remove empty leads dead empty domain true empty domain don select reset status selected return return null consistent value procedure fig 

selectvalue subprocedure forward checking algorithm 
sets equivalent sets selectvalue subprocedure propagates current instantiation remove values sets 
backtracking backtracking lookahead resets sets order modi cations contingent longer current partial instantiations 
look ahead selectvalue restore sets leaf dead necessary backtracking lookahead perform reset action internal dead ends 
programmers usually copies set level search tree permit reset action performed eciently 
forward checking forward checking uses selectvalue forward checking limited form constraint propagation 
variables instantiated subproblems created combining instantiated variables uninstantiated variable constraints interest subproblem scope subset fx fx enforcing consistency subproblem achieved removing domain values con ict forward checking treats subproblems independently removing values sets necessary 
domain variables empty partial instantiation extended variable part solution 
value current variable considered 
complexity consistent log number constraints maximum number tuples constraint selectvalue forward checking complexity nm log number cardinality largest domain 
loop executed times outer inner loops bounded respectively 
interesting relationship forward checking simplest form backjumping proposition variable ordering gaschnig backjumping explores node explored forward checking 
look ahead forward checking done instantiation look ahead algorithms enforce arc consistency uninstantiated variables assignment value current variable 
variable domain empty process enforcing arc consistency current value rejected 
selectvalue arc consistency implements approach 
repeat loop subprocedure essentially arc consistency algorithm called ac 
long history arc consistency algorithms ac earliest simplest certainly ecient 
ecient arc consistency procedures dubbed ac ac selectvalue subprocedure 
optimal time complexity arc consistency procedure em number constraints subproblem cardinality largest domain largest arity constraints 
algorithms forward checking enforcing arc consistency level search full looking ahead partial looking ahead 
full looking ahead algorithm single pass variables ect repeat un til selectvalue arc consistency removed 
partial looking ahead full looking ahead addition removing repeat loop selectvalue arc consistency partial looking ahead replaces 
variables compared 
applying arc consistency highly successful class vision instances varieties look ahead forward checking regarded useful 
may due part subprocedure selectvalue arc consistency empty select arbitrary element remove repeat removed value false value value consistent remove removed value true removed value false domain empty don select reset value selected return return null consistent value procedure fig 

selectvalue subprocedure arc consistency ac algorithm 
prematurely negative full looking ahead reached checks units discover inconsistencies justify large number tests required 
subsequent experimentation larger problems justi ed value interleaving arc consistency enforcing procedures search 
search algorithm enforce higher degree consistency arcconsistency instantiation 
doing entail deleting values domains adding new constraints may retracted 
shown larger dicult problems experimented higher levels look ahead useful 
balance overhead pruning constraint propagation studied :10.1.1.37.7424
experiments conducted larger harder problems look ahead path consistency cost ective 
section presenting relationship structure subprocedure min jd nd size smallest domain select arbitrary uninstantiated variable jd rearrange variables ith variable subprocedure fig 

subprocedure employs heuristic sets choose variable instantiated 
constraint graph forms look 
de nition cycle cutset undirected graph subset nodes graph called cycle cutset removal results graph having cycles 
proposition constraint problem graph cycle cutset size solved partial looking ahead algorithm time 

proof variable instantiated ow interaction variable terminated 
expressed graphically deleting corresponding variable constraint graph 
set variables forms cycle cutset instantiated remaining problem perceived tree 
tree solved directional arc consistency partial looking ahead performing directional arc consistency node guaranteed solve problem cycle cutset variables initiate search ordering 
possible instantiations cutset variables remaining tree solved consistency checks complexity follows 
details see 
look ahead variable value selection variable ordering tremendous ect size search space 
empirical theoretical studies shown ective static orderings result smaller search spaces 
dynamic variable ordering dvo usual objective known fail rst select variable predicted heuristic smallest search tree 
factors equal variable smallest number values current domain fewest subtrees rooted values smallest search space 
common heuristic size sets determine variable 
example subprocedure 
routine particularly simple relies purely size smallest domain breaks ties arbitrarily 
sophisticated dvo schemes proposed 
backtracking lookahead modi ed employ dynamic variable ordering calling initialization step forward step 
fc cbj algorithm discussed illustrates invoked 
example 
consider example 
initially variables domain size 
suppose dvo scheme selects domain size green 
forward checking propagation choice remove green domains variables domains size suppose selected assigned blue 
impact restrict domains single values 
dvo selects possible value red considered 
propagating assignment results empty domain red rejected algorithm backtracks information gleaned look ahead phase guide value selection :10.1.1.37.7424:10.1.1.37.7424
course look ahead algorithms perform coarse version value selection reject values shown lead dead re ned approach ranks values current variable shown useful 
look ahead value ordering lvo algorithm forward checking :10.1.1.37.7424
accepting rst value current variable shown lead dead lvo tentatively instantiates value current variable examines ects forward checking style lookahead domains variables 
tentative instantiation ects retracted instantiation 
lvo uses heuristic function transform information ranking values 
experimental results indicate cost performing additional lookahead justi ed smaller easier problems extremely useful particularly hard problems :10.1.1.37.7424
integration comparison algorithms integrating backjumping look ahead complementary enhancements backtracking integrated single procedure 
look ahead strategies discussed combined backjumping variants described section 
additionally combined algorithm employ learning dynamic variable value ordering heuristics look ahead information 
combination con ict directed backjumping forward checking level look ahead dynamic variable ordering 
integrated algorithm fc cbj figures 
main procedure fc cbj closely resembles conflict directed backjumping 
recall cbj maintains set variable selectvalue cbj adds earlier instantiated variables reaching dead algorithm jumps back latest variable cbj combined look ahead sets way built di erent manner 
selecting value cbj puts possibly variables precede non binary constraints sets uninstantiated variables value con ict value assigned reaching dead variable follows instantiated identi ed partially responsible dead 
fc cbj derived conflict directed backjumping making modi cations 
rst sets initialized reset dead manner backtracking lookahead 
selectvalue fc cbj look ahead relies accurate current 
second modi cation call initialization phase step forward 
calls removed algorithm revert modi cation static variable ordering 
look ahead performed purposes rejecting inconsistent values little additional cost performing practice heuristic ective reducing size search space 
comparison algorithms faced variety backtracking algorithms associated heuristics natural ask ones superior performance 
performance assessed theoretical analysis worst average case behavior experimentally benchmark instances suites problems possibly randomly generated 
criteria frequently measured cpu time size generated search tree calls common subroutine consistent 
shows relationships algorithms discussed worst case performance measured size search space equivalent number calls selectvalue subprocedure 
summarizes results experimental comparisons backtracking constraint algorithms 
algorithms incorporate procedure fc cbj input constraint network 
output solution decision network inconsistent 
initialize variable counter call determine rst variable copy domains initialize con ict set instantiate selectvalue fc cbj null value returned highest index fx reset value instantiated step forward call determine variable return inconsistent return instantiated values fx procedure fig 

main procedure fc cbj algorithm 
ward checking level look ahead dynamic variable ordering scheme similar described 
names abbreviated table fc refers forward checking fc ac refers forward checking arc consistency enforced instantiation fc cbj refers con ict directed backjumping forward checking fc cbj lvo adds value ordering heuristic fc cbj fc cbj plus th order learning fc cbj lvo fc cbj lvo learning 
columns labeled set set report averages randomly generated binary csp instances 
instances variables element value domains number constraints selected generate approximately solvable problems 
number variables number valid relations constraint set set set 
algorithm bt run sets 
rightmost columns gure show results speci problems second dimacs implementation challenge ssa ssa 
details experiments see 
subprocedure selectvalue fc cbj empty select arbitrary element remove empty domain false values consistent earliest constraint causing con ict add variables scope remove empty leads dead empty domain true empty domain don select reset status selected reset status selected return return null consistent value subprocedure fig 

selectvalue subprocedure fc cbj 
interleaving arc consistency procedure search generally quite effective studies learning value ordering 
interesting observation nature constraints sets random problems 
set constraint variables domains size permitted combinations set set 
problems restrictive tighter constraints sparser constraint graphs 
tight constraints di erence performance algorithms problems tighter constraints 
enforcing arc consistency learning new constraints ective sparser graphs tight constraints 
procedures able exploit local structure problems 
empirical results shown examples typical experimental comparisons algorithms 
unfortunately similar studies necessarily possible conclude algorithms perform problems having di erent structural properties 
forward checking cbj backtracking gaschnig backjumping conflict directed backjumping graph backjumping cbj learning cbj arc consistency cbj forward checking fig 

relationships selected backtracking algorithms 
cbj abbreviation con ict directed backjumping 
arrow indicates problem variable value orderings number nodes search tree greater equal number nodes 
algorithm set set set ssa ssa fc fc ac fc cbj fc cbj lvo fc cbj fc cbj lvo fig 

empirical comparison selected csp algorithms 
see text explanation 
column numbers rst number indicates number nodes search tree rounded nearest nal omitted second number cpu seconds 
historical remarks current improving backtracking algorithms solving constraint satisfaction problems reingold formulation algorithm 
early uential ideas improving backtracking performance constraint satisfaction problems introduced waltz 
waltz demonstrated constraint propagation form arc consistency applied dimensional interpretation problem solved encountering dead ends 
led development various consistency enforcing algorithms arc path consistency 
golomb may rst informally describe idea 
waltz montanari seminal constraint networks mackworth detailed speci algorithms node arc possibly augmented backtracking search interleaved backtracing search 
consistency techniques alice system 
explicit algorithms employing idea gaschnig described backtracking algorithm incorporates arc consistency mcgregor described backtracking combined forward checking truncated form arc consistency haralick elliott added various look ahead methods nadel discussed backtracking combined variations partial arcconsistency 
gaschnig compared waltz style look ahead backtracking look back improvements introduced backjumping backmarking 
haralick elliot done relatively comprehensive study late randomly generated instances variables queens problems ranging 
compared performances various look ahead look back methods 
empirical evaluation concluded forward checking algorithm uses weakest form constraint propagation superior 
maintained mid larger dicult problem classes tested :10.1.1.37.7424
studies forward checking lost superiority problem instances full looking ahead stronger looking ahead variants 
empirical evaluation backtracking dynamic variable ordering queens problem reported 
researchers logic programming community tried improve backtracking algorithm interpreting logic programs 
improvements known umbrella name intelligent backtracking focused limited amount backjumping constraint recording 
systems area contributed improving backtracking 
stallman sussman rst mention nogood recording idea gave rise look back type algorithms called dependency directed backtracking algorithms include backjumping nogood recording 
context solving propositional satis ability logemann davis loveland introduced backtracking algorithm dll uses lookahead variable selection form unit resolution similar arc consistency 
date algorithm perceived successful procedures task 
analytical average case analysis backtracking algorithms pursued satis ability constraint satisfaction 
value look back improvements solving propositional satis ability initially largely overlooked researchers focused look ahead improvements dll 
changed signi cantly bayardo schrag 
showed algorithm relsat incorporates learning backjumping outperforms best backtracking sat solvers available time hard benchmarks 
subsequently smart implementations look back sat solvers grasp developed 
freuder dechter pearl introduced graph methods improving look ahead look back methods backtracking 
particular advice generation look ahead value selection method prefers value leads solutions estimated tree relaxation proposed 
dechter described graph variant backjumping followed con ict directed backjumping introduced prosser 
graph methods include graph learning constraint recording cycle cutset scheme 
complexity methods bounded graph parameters dechter pearl developed induced width bound learning algorithms dechter showed cycle cutset size bounds look ahead methods 
quinn noted dependence backjumping performance depth dfs tree constraint graph bayardo improved complexity bound 
subsequently clear backtracking improvements largely orthogonal look back methods look ahead methods researchers systematically investigated various hybrid schemes attempt exploit virtues method 
dechter evaluated combinations graph backjumping graph learning cycle cutset scheme emphasizing additive ect method 
evaluation hybrid schemes carried prosser combined known look ahead look back methods ranked combination average performance primarily zebra problems 
dechter meiri evaluated ect pre processing consistency algorithms backtracking backjumping 
improvements hardware recognition empirical evaluation may best way compare various schemes come substantial increase empirical testing 
cheeseman kanefsky taylor observed randomly generated instances phase transition easy hard researchers began focus testing various hybrids algorithms larger harder instances 
addition closer examination various algorithms uncovered interesting relationships 
instance noted dynamic variable ordering performs function value selection variable selection order variables xed forward checking eliminates need backjumping leaf nodes done gaschnig backjumping 
idea non systematic complete backtracking introduced makoto yokoo rst observe learning context distributed version search maintains completeness 
idea caught community sat solver developers 
current solution methods combine di erent algorithms exploit randomized version backtracking search random restarts randomizing backtrack points 
constraint processing techniques augmented constraint logic programming clp languages 
inference engines languages constraint solver traditional logic programming inference procedures 
addition employing general constraint techniques enforcing arc consistency languages gain eciency collection specialized constraint propagation algorithms frequently constraints di erent 
peter van beek helpful comments particularly useful suggestions section covering historical perspectives roberto bayardo javier larrosa perceptive comments rish gures lastly michelle dedicated editing earlier version 
arnborg 
ecient algorithms combinatorial problems graphs bounded decomposability survey 
bit 
bacchus van run 
dynamic variable ordering csps 
principles practice constraint programming cp france 
available lecture notes cs vol pp 
baker 
hazards fancy backtracking 
proceedings national conference arti cial intelligence aaai 
baker 
intelligent backtracking constraint satisfaction problems experimental theoretical results 
phd thesis graduate school university oregon eugene 
bayardo miranker 
complexity analysis space bounded learning algorithms constraint satisfaction problem 
aaai proceedings thirteenth national conference arti cial intelligence pages portland 
bayardo jr miranker 
space time trade solving constraint satisfaction problems 
fourteenth international joint conference arti cial intelligence ijcai pages 
bayardo jr schrag 
csp look back techniques solve real world sat instances 
aaai proceedings fourteenth national conference arti cial intelligence 
bessi ere 
arc consistency arc consistency 
arti cial intelligence 
bessi ere freuder 

constraint metaknowledge reduce arc consistency computation 
arti cial intelligence 
reingold 
backtrack programming techniques 
communications acm 
bruynooghe 
solving combinatorial search problems intelligent backtracking 
information processing letters 
cheeseman kanefsky taylor 
really hard problems 
proceedings twelfth international joint conference arti cial intelligence ijcai pages 
chen peter van beek 
con ict directed backjumping revisited 
journal arti cial intelligence research 
cooper 
optimal consistency algorithm 
arti cial intelligence 
crawford auton 
experimental results crossover point satis ability problems 
aaai proceedings eleventh national conference arti cial intelligence pages 
davis logemann loveland 
machine program theorem proving 
communications acm 
dechter 
enhancement schemes constraint processing backjumping learning cutset decomposition 
arti cial intelligence 
dechter 
constraint networks 
shapiro editor encyclopedia arti cial intelligence nd edition pages 
john wiley sons 
dechter meiri 
experimental evaluation preprocessing algorithms constraint satisfaction problems 
arti cial intelligence 
dechter pearl 
network heuristics constraint satisfaction problems 
arti cial intelligence dec 
dechter pearl 
tree clustering constraint networks 
arti cial intelligence pages 
dechter van beek 
local global relational consistency 
theoretical computer science pages 

graph algorithms 
computer science press 
freuder 
synthesizing constraint expressions 
communications acm 
freuder 
sucient condition backtrack free search 
journal acm 
freuder quinn 
linear spanning trees represent constraint satisfaction problems 
technical report university new hampshire durham 
frost dechter 
dead driven learning 
proceedings twelfth national conference arti cial intelligence aaai pages 
frost dechter 
search best constraint satisfaction search empirical evaluation 
aaai proceedings twelfth national conference arti cial intelligence pages seattle 
frost dechter :10.1.1.37.7424
look ahead value ordering constraint satisfaction problems 
proceedings international joint conference arti cial intelligence ijcai pages 
frost dechter 
looking full look ahead 
proceedings second international conference constraint programming cp 
frost 
algorithms heuristics constraint satisfaction problems 
phd thesis information computer science university california irvine ca 
garey johnson 
computers intractability guide theory np completeness 
freeman 
gaschnig 
experimental case studies backtrack vs waltz type vs new algorithms satis cing assignment problems 
proceedings second canadian conference arti cial intelligence pages toronto ont 
gaschnig 
performance measurement analysis search algorithms 
technical report cmu cs carnegie mellon university 

dual viewpoint heuristics binary constraint satisfaction problems 
proceedings th european conference arti cial intelligence ecai pages vienna 
gent macintyre prosser smith walsh 
empirical study dynamic variable ordering heuristics constraint satisfaction problem 
principles practice constraint programming cp pages 
gent macintyre prosser walsh 
search 
aaai proceedings thirteenth national conference arti cial intelligence portland 
ginsberg :10.1.1.27.4126
dynamic backtracking 
journal arti cial intelligence research 
golomb 
backtrack programming 
journal acm 
gomez selman kautz 
boosting combinatorial search randomization 
fifteenth national conference arti cial intelligence aaai 
haralick elliot 
increasing tree search eciency constraint satisfaction problems 
arti cial intelligence 
ja ar lassez 
constraint logic programming survey 
journal logic programming 
david johnson michael trick editors 
cliques coloring sati ability volume dimacs series discrete mathematics theoretical computer science 
american mathematical society providence rhode island 
van beek 
theoretical evaluation selected backtracking algorithms 
proceedings international joint conference arti cial intelligence ijcai 
van beek 
theoretical evaluation selected algorithms 
arti cial intelligence 
kumar 
algorithms constraint satisfaction problems survey 
ai magazine 

language program stating solving combinatorial problems 
arti cial intelligence 
mackworth 
consistency networks relations 
arti cial intelligence 
mackworth 
constraint satisfaction 
shapiro editor encyclopedia arti cial intelligence nd edition pages 
john wiley sons 
mackworth freuder 
complexity polynomial network consistency algorithms constraint satisfaction problems 
arti cial intelligence 
marques silva 
grasp search algorithm propositional satis ability 
ieee transaction computers pages 
kim marriott peter stuckey 
programming constraints 
mit press 
mcallester 
truth maintenance 
aaai proceedings eighth national conference arti cial intelligence pages 
mcgregor 
relational consistency algorithms application nding subgraph graph isomorphisms 
information science 
miguel shen 
solution techniques constraint satisfaction problems advanced approaches 
arti cial intelligence review 
miguel shen 
solution techniques constraint satisfaction problems foundations 
arti cial intelligence review 
minton johnston philips laird 
solving large scale constraint satisfaction scheduling problems heuristic repair method 
proceedings eighth national conference arti cial intelligence aaai pages boston mass 
mohr henderson 
arc path consistency revisited 
arti cial intelligence 
montanari 
networks constraints fundamental properties applications picture processing 
information science 
nadel 
constraint satisfaction algorithms 
computational intelligence 
nadel 
applications constraint satisfaction problem 
aaai workshop constraint directed reasoning working notes boston mass 

principles arti cial intelligence 
tioga palo alto ca 

consistent labeling problems algorithms theory heuristics 
arti cial intelligence 
pearl 
heuristics intelligent search strategies 
addison wesley 
perlin 
arc consistency factorable relations 
arti cial intelligence 

hybrid search architecture applied hard random sat low autocorrelation binary sequences 
principles practice constraint programming cp pages 
prosser 
forward checking backmarking 
technical report university strathclyde 
prosser 
hybrid algorithms constraint satisfaction problems 
computational intelligence 
purdom jr search rearrangement backtracking polynomial average time 
arti cial intelligence 
francesca rossi 
constraint logic programming survey research applications 
apt kakas rossi editors new trends constraints pages 
springer 
sabin freuder 
contradicting conventional wisdom constraint satisfaction 
proceedings european conference ai ecai pages amsterdam 
norman sadeh mark fox 
variable value ordering heuristics activity job shop scheduling 
proceedings fourth international conference expert systems production management pages 
selman levesque mitchell 
new method solving hard satis ability problems 
proceedings tenth national conference arti cial intelligence aaai pages 
barbara smith stuart 
trying harder fail 
proceedings european conference ai ecai pages 
stallman sussman 
forward reasoning dependency directed backtracking system computer aided circuit analysis 
arti cial intelligence 
stone stone 
ecient search techniques empirical study queen problem 
technical report rc ibm watson 
tsang 
foundation constraint satisfaction 
academic press 
van hentenryck 
constraint satisfaction logic programming 
mit press 
van hentenryck deville 
teng 
generic arc consistency algorithm specializations 
arti cial intelligence 
waltz 
understanding line drawings scenes shadows 
winston editor psychology computer vision pages 
mcgrawhill 
yokoo 
asynchronous weak commitment search solving distributed constraint satisfaction problems 
international conference constraint programming france 

