cssv realistic tool statically detecting buffer overflows dor tel aviv university post tau ac il michael rodeh ibm research lab haifa rodeh il ibm com mooly sagiv tel aviv university post tau ac il erroneous string manipulations major source software defects programs yielding vulnerabilities exploited software viruses 
string static cssv tool statically uncovers string manipulation errors 
conservative tool reports errors expense generating false alarms 
fortunately small number false alarms reported proving statically reducing software vulnerability achievable 
cssv handles large programs analyzing procedure separately 
procedures contracts allowed veri ed tool 
implemented cssv prototype verify absence errors real code airbus 
applied commonly string intensive application cssv uncovered real bugs false alarms 
categories subject descriptors software engineering software program veri partially supported ministry science israel rtd project ist european fp programme 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june san diego california usa 
copyright acm 
cation assertion checkers reliability validation logics meanings programs specifying verifying reasoning programs assertions preand post conditions logics meanings programs semantics programming languages operational semantics program analysis general terms algorithms reliability experimentation security languages veri cation keywords error detection interpretation static analysis bu er ow contracts 
string manipulation errors common source software defects lead security vulnerabilities 
cert advisories report security holes resulting bu er ow updates bounds bu er 
furthermore unix failures reported fuzz study due runtime string manipulation errors bu er ow access bounds string misuse null termination byte 
goal perform static analysis detects string runtime errors just false alarms 
false alarm reported error occur runtime 
goal ambitious 
existing methods errors lclint claire ii yield false alarms iii handle com aspects multilevel pointers structures 
cost static analysis considered prohibitive comes large programs 
presents string static cssv short tool demonstrates uncovering string problems achievable 
cssv capable analyzing realistic procedures produces precise results 
conservative static analysis tool runtime string error 
guarantees absence errors expense generating false alarms 
procedure cssv allows programmer provide contract including precondition ii postcondition iii potential side ects procedure 
contracts may refer normal expressions including pointers refer properties number allocated bytes de ned instrumented concrete semantics 
analysis string errors cssv fig 
shows cssv operates 
procedure analyzed separately 
rst phase source source semantic preserving transformation applied analyzed procedure transformation exposes behavior procedures invoked essentially inlining contracts 
generated program yields runtime error contract violated 
addition inliner normalizes code include statements subset called simpli es task implementing cssv 
second phase cssv analyzes pointer interactions 
conducting pointer analysis language nontrivial task 
dicult programmers de ne contracts regarding pointer behavior 
fortunately ow insensitive algorithms shown run applications considerable size 
cssv require contract information pointers 
cssv applies program ow insensitive pointer analysis detect statically pointers may pointto base address 
cssv applies algorithm extracts procedural points information analyzed procedure algorithm bene ts fact memory locations reachable visible variables ect postcondition cases allows subsequent analyses perform strong updates analyzing procedure body 
compute certain aliases improve precision global ow insensitive pointer analysis 
procedural points information improve cost precision interprocedural analysis 
third phase procedure code points information fed ip transformer 
ip generates procedure manipulates integers 
ip guarantees runtime string manipulation error procedure invocation procedure precondition hold invocation ii assert statement resultant integer program violated corresponding input 
addition ip checks pointer assertions speci ed contracts 
fourth phase resultant integer program analyzed conservative integer analysis algorithm determine potential violations assert statements 
integer pointer analyses sound contracts veri ed call sites procedural level string errors reported 
particular integer analysis reports error speci ed postcondition guaranteed hold 
minimizing number false alarms cssv uses precise integer analysis represents linear relationships integer variables 
nal result list potential errors 
error counter example generated assist programmer determining message real error false alarm 
false alarms may occur due erroneous overly weak contracts ii abstractions conducted ip iii imprecision pointer integer analyses 
opposed alternative interprocedural program analy program inliner annotated program pointer analysis procedural points ip integer program integer analysis potential errors contracts high level structure cssv 
sis techniques cssv approach important advantages potentially recursive procedure analyzed separately exactly tool applicable source code available library functions 
ii contracts er user control way similar design contract 
particular enables cssv ectively locate actual source location error occurs 
iii contracts improve precision analysis providing information hard statically infer interprocedural analysis 
iv contracts analyze procedure calls cssv applies precise intraprocedural algorithm reduce false alarms 
burden contracts contracts exert additional burden programmer 
case cssv de ciency minimized pre post conditions need describe procedure complete behavior 
particular pointer information automatically collected cssv contracts usually omit information pointers 
tools claire lclint cssv require annotations code loop invariants 
unsound approaches cssv sound contract runtime errors go undetected 
depending contracts errors identi ed analyzing body procedure procedure invocations 
course procedure code omitted case library functions cssv assume contract correct verify 
interprocedural modi cation side ect analysis algorithms exist 
generate automatically modify clause 
possible run cssv vacuous contracts including side ect true pre post condition 
presents preliminary algorithms automatically strengthening pre post conditions 
ectiveness algorithms measured comparing number false alarms obtained vacuous contracts ii automatically derived contracts iii manually provided contracts 
derivation procedure uses forward sound algorithm called compute approximation strongest postcondition integer program 
similarly backward sound integer analysis algorithm called compute approximation weakest liberal precondition 
generated postcondition precondition necessarily strongest information lost static integer analysis 
yield integer conditions 
process repeated iteratively running derivation process generated integer conditions restricting existing precondition postcondition conservative method uses procedural points information convert integer expression postcondition precondition expression strengthen initial contract 
main results contributions summarized follows conservative static analysis algorithm detecting string runtime errors 
algorithm reduces problem checking string manipulation checking integer manipulations problem known solutions exist 
comparison previous algorithm handles full spectrum language constructs including dynamically allocated structures multilevel arrays multilevel pointers function pointers casting 
addition algorithm order magnitude better asymptotic time space requirements 
preliminary program analysis algorithms strengthening pre post conditions 
algorithms reduce burden programmer 
analyze input procedure existing potentially vacuous contracts yield new restrictive contract procedure 
implemented cssv ast golf pointer analysis polyhedra integer analysis 
applied implementation real life programs 
cssv veri ed intricate string library airbus yielding false alarms 
application part web cssv uncovered errors false alarms 
implemented derivation algorithms applied automatically generate pre post conditions 
results show cases derived contracts equivalent manually speci ed ones 
outline rest rest organized follows section introduces contract language running example instrumented concrete semantics 
section describes cssv 
section describes contract derivation algorithms 
section describes prototype implementation experimental results 
section discusses related section concludes 

background subset restrictions control ow statements goto break continue ii expressions side ect free nested iii assignments statements iv declarations initializations address formal variables allowed 
algorithm transforming programs 
program generates equivalent program adding new temporaries 
cssv de ned implemented 
rest contracts contracts describe expected inputs side ects expected output functions 
write contracts style larch 
implementation supports general executable language similar include loops 
contracts speci ed le 
prototype declaration function form 
requires hei modi es hei hei hei ensures hei de ning precondition required hold invoked side ects function objects may modi ed invocations postcondition guaranteed hold modi ed objects 
hei expression function calls global variables arguments allow attributes form de ned table displayed fig 

designated variable return value denotes return value special syntax denotes value hei invoked 
required contract mechanism enables specifying pointer values 
addition shorthand expressions allowed string arg indicating arg points null terminated string ii bounds arg indicating arg points bounds bu er 
attribute intended meaning exp base base address exp exp set set exp exp exp base exp nullt exp pointing null terminated string 
exp strlen length string pointed exp exp alloc number bytes allocated exp table attributes contract language 
exp offset exp strlen exp alloc exp base exp graphical representation attributes 
running example version function rtc si airbus short shown fig 

inserts newline characters starting location pointed ptrendtext appends null termination character sets ptrendtext point string 
contract shown fig 

precondition demands entry ptrendtext points bounds bu er allocation space location ptrendtext greater zero 
function may modify ptrendtext pointer bu er pointed ptrendtext 
postcondition indicates ptrendtext points string length zero value advanced bytes 
due multi level pointer indirections destructive updates pointer arithmetic challenging verify absence errors function 
cssv able verify statically absence string errors function reporting false alarm 
toy main procedure shown fig 
calls insert newline character reads input int char ptrendtext int char loop goto loop ptrendtext nn ptrendtext goto loop loop ptrendtext void main char buf size char buf size stdin strlen string manipulation function airbus toy main function 
dard input concatenates additional newline calling 
procedure error 
case user input length size buf full space additional newline 
cssv detects error main reporting false alarm 
strong correlation contracts messages reported 
errors go undetected 
example omitting precondition yields error message analysis 
message indicates postcondition ptrendtext may hold 
interestingly counter example produced cssv message shows postcondition hold value negative 
providing stronger precondition weakest precondition yield error messages procedure invocation 
example requiring ptrendtext points void int char ptrendtext requires bounds ptrendtext ptrendtext alloc modi es ptrendtext strlen ptrendtext nullt ptrendtext ensures ptrendtext nullt ptrendtext strlen ptrendtext contract 
null terminated string cause error message regarding call line main 
instrumented concrete semantics programming language de ne semantics programs 
ansi standard informal notion de ned unde ned behavior 
exact behavior change implementation compiler 
due features language trivial de ne semantics address operation enables change variable value assigning variable 
pointers invisible variables 
allocation dynamic static routines provide unformatted contiguous memory locations semantic point view hierarchy objects object may contain objects different types 
objects type providing exibility location accessed di erent types 
causes de ning checking legitimacy accesses 
big values operations enables read write number primitives type operand 
pointer arithmetic frequently de ned result 
checking validity impossible additional instrumented information 
cast operation de ned feature unclear outcomes 
single location accesses read written di erent types 
section sketch instrumented operational semantics veri es absence bound violations allowing pointer arithmetic destructive updates casting 
general idea de ne non standard low level semantics explicitly represents base address memory location allocated size starting base address 
soundness cssv proved respects operational semantics 
semantics provides foundation cssv interpretation 
definition 
concrete state procedure tuple state ba loc st base nite set static stack dynamically allocated locations 
ba set base addresses ba de nes allocation size bytes memory region starting base address 
loc ba maps variables assigned global stack locations base address 
st val de nes memory content val unde primitive set possible values 
value uninit represents uninitialized values unde ned represents results illegal memory accesses primitive refers set primitive type values 
de nes location number bytes value stored starting location 
base ba maps location base address 
uninit ptrendtext 
buf size concrete state arising entry invoked second call main 
clarity allocation size buf shown symbolically 
concrete state arises entry invoked second call main shown fig 

box represents allocated memory region starting 
draw contiguous memory locations boxes display allocation sizes underneath boxes 
assume integers pointers byte long character byte long 
draw variable box base address loc 
value inside box shows corresponding store content 
pointer values drawn edges 
intuitively state keeps track set allocated locations 
origin location memory region guaranteed contiguous ba base mappings allows semantics validate pointer arithmetic dereferences bounds 
order handle destructive update variable address operation loc represents address variables st maps locations values 
example pointer described pointer location loc 
concrete example contains interesting mappings st loc ptrendtext loc loc ptrendtext st loc buf loc buf indicating ptrendtext points stack location byte value second byte buf contains character 
association number bytes locations enables handle cases location accessed di erent types 
speci cally writing location type reading di erent size type results unde ned value 
definition 
concrete state ba loc st base admissible location st unde ned st unde ned st unde ned admissible state contain overlapping contents 
semantics yields admissible states 
achieved de ning semantics assignments set unde ned mapping overwritten 
values values expressions de ned straightforward structural induction 
particular pointer variable de ne value value denoted rp respectively follows state def loc rp state def st state st loc de ne function index reason displacement location base 
formally index index def base additional information base value attribute easily de ned 
particular value attribute offset index rp state 
concrete states represent structures sets base addresses 
eld associated unique base size eld 
abstracting semantics cssv veri es accesses pointer arithmetic cross eld bounds 

cssv cssv analyzes procedure separately 
refer analyzed procedure cssv checks kinds errors ansi violations related strings access bounds 
ii violations pre post conditions procedures required provided contracts 
procedure invoked callee precondition checked 
postcondition checked 
iii analysis checks certain conditions correspond programming style 
particular validates accesses null termination byte exists 
technical overview pointers integers interact non trivial way especially programming language 
example non trivial check safety expression ptrendtext nn line pointer ptrendtext bounds 
cssv infers relationships set ptrendtext allocation size base address integer variables needed verify safety destructive update 
shall see algorithm statically veri es inequalities combining pointer analysis algorithm detects pointers base address integer analysis algorithm detects set relationships pointers 
set pointer index location points 
course contrast concrete semantics semantics summarizes concrete locations single location 
maintains potential points addresses 
cssv applies program ow insensitive pointer analysis detect statically pointers may point base address 
particular function provides summary calling contexts 
principle conservative analysis utilize information analyze function possible calling contexts 
yield false alarms 
example program analysis yields ptrendtext may point conservatively analyzing function body calling contexts requires treating updates integer properties set ptrendtext weak updates 
analysis fail show postcondition holds 
result false alarm issued 
cssv avoids false alarm performing strong updates certain cases 
main idea precompute procedural points information guarantees strong updates set ptrendtext performed 
general guarantees behaved programs direct updates formal parameters interpreted strong updates 
procedural points information ip generate integer program 
integer constraint variables summarize semantic properties allocated size represented locations 
conservative integer analysis determines potential values semantic properties veri es constraints 
rest section organized follows section describes procedure inlines contracts section formalizes procedural points information section describes ip transformation applied section sketches integer analysis algorithm 
exposing procedures behavior rst step cssv takes input program provided set contracts generates new procedure inline exposing contracts invoked procedures 
inline contains assert statements verify contracts behavior inline di ers behavior inputs violating contracts 
inputs inline behave 
statements remain intact 
table shows scheme translating ected statements 
add syntactic extensions construct assume hei indicates hei holds statement hei hold execution aborted message 
re ect commitments procedures 
ii additional temporary variables named hei store value subexpression procedure entry 
iii contract language attributes de ned meaning instrumented concrete semantics 
procedure entry encountered rst executable statement 
case additional variables initialized precondition veri ed 
designated variable return value set return statement 
exit point including return postcondition veri ed 
call verify precondition holds assume postcondition holds 
original call emitted code 
essential inline behave pointer analysis second step cssv computes abstraction potential pointer relationships locations concrete states may occur execution 
locations accessed execution interest 
de ne notion reachable locations 
definition 
concrete state location reachable exists visible variable store contents indirectly include expression value 
infer pointer relationships reachable locations computing procedural pointer information aims representing single location formal points procedure entry 
section describes state representing pointer relationships algorithm compute state 
procedural points state formalize state regards pointer relationships reachable locations follows definition 
procedural points state ppt quadruple bap pt smp bap set locations represent reachable concrete base addresses 
ba maps variables set locations representing variable global stack locations 
pt bap ba possible pointers 
concrete pointer represented pt relationship locations representing base addresses pointer source target location 
smp bap count number concrete base addresses represented location sm ba ba may represent base address concrete store guaranteed represent base address 
location having sm summary location 
summary locations represent unbounded sets base addresses 
say ppt bap pt smp sound approximation concrete state ba loc st base procedure exists function ba bap satisfying requirements base reachable ba bap stack loc loc 
pointer reachable satisfying st base pt base 
event emitted code entry fn post assume pre return hei return hei exit assert post hei am post assert pre am return am assume post am hei return table emitted code ected statements 
notation pre em stands precondition procedure formal replaced expression expression post obtained similar pre expression replaced variable 
return designated variable representing return value postcondition procedure summary bap smp ba having definition 
sound approximation sound approximation concrete states may arise execution values values generalized return sets locations 
particular visible pointer variable state def rq state def lq state pt loc pt constructing procedural information cssv computes sound approximation stages program analysis applied compute global points state program ba loc pt sm ba includes locations 
loc var ba pt ba ba sm ba 
global state guaranteed sound approximation procedures 
second global state construct sound approximation possible solutions ptrendtext buf ptrendtext program points information running example ppt 
exist 
decided bias precise representation formal parameters intention conduct strong updates properties cases 
fig 
demonstrates process 
possible denote locations values value rbuf pointer 
see new location rp represents unique concrete location holds value ptrendtext 
global pointer state program ba loc pt sm construct ppt bap pt smp 
mapping computed projecting loc visible variables similarly bap smp computed including locations reachable visible variables initial value pt obtained projection 
running example yields state global points information shown fig 
buf location 
aim potentially precise boolean parameterizable ppt formal bap pt smp value smp return false fl mg pt values smp return false remove pt edges pt resultant points map 
exists reachable node pt return false concrete locations pointed reachable concrete state represented return true algorithm conservatively check concrete location represented set pointed formal parameter representation 
conservative algorithm check sound merge nodes pointed formal creating new summary node fig 

algorithm checks concrete store concrete location represented set locations pointed formal parameter 
correctness algorithm established 
permitted merge done replacing single non summary location 
ii setting pt rf pt 
may improve precision destructive updates may decrease precision updates 
ip ip transformation takes inline procedure ppt input produces integer program ip short output 
generated ip tracks string integer manipulations invoked procedures 
ip nondeterministic re ecting fact values known 
symbol unknown stands undetermined value 
particular expressions unknown assigns value 
unknown true false branch taken 
semantics assume construct integer program restrict behavior nondeterministic programs 
clarity mathematical constructs ip 
ip includes constraint variables denote interesting semantic properties sets 
ip generates update statements assigning new values constraint variables re ecting changes semantic properties 
assert statements constraint variables generated checking safety basic expressions verifying contracts 
addition ip validate pointer assertions speci ed contracts 
due ow insensitivity pointer analysis capability weak terms precision 
precondition may hold error message reported 
constraint variables location ip generates constraint variables val represent potential primitive values stored locations represented set represent potential sets pointers represented set conservatively represents index st location represented nullt len describe allocation size base address contains null terminated string length string excluding null byte locations represented translating statements transforming expressions involves querying ppt obtain locations pointer may point 
simplicity subsection assume pointer may point single non summary location 
exp generated ip condition set rp nullt set rp len rp nullt set rp set val set val rp table asserted ip conditions expressions 
representing global stack location rp representing location pointed singletons pointer section handling arbitrary ppt discussed 
safety checks 
basic expression condition veri es validity expression 
table lists generated assert expressions 
dereference address check address bounds generated 
upper bound checked depending bu er null terminated 
dereferenced location checked null termination byte 
cssv follows pp checks result pointer arithmetic rst location upper bound 
update statements 
ip generates statements re ect semantic changes regarding properties tracked 
table displays generated statements transforming statements conditional expressions involving pointers bu ers interesting part ip 
allocation resultant pointer points base address 
set zero 
set allocation size location represents newly allocated location 
destructive updates separated cases assignment null character sets bu er null terminated string 
length string location rst zero byte 
ip generates check dereferences null termination byte exists 
safely assume assigning null termination byte rst 
ii assignment non zero character checked null termination byte overwritten 
generated ip contain function calls 
ip transforms inline procedure pre postconditions invoked procedure transformed 
call procedure needs analyzed conservatively 
ip converts call modify clause substitutes actual formal parameters 
modify clause interpreted assignments unknown constraint variables locations represent potentially modi ed objects 
increase precision certain program conditions interpreted 
second part table shows interpreted conditions 
checking null termination ip replaces condition condition constraint variables track length existence null character 
pointer comparisons replaced expressions compute expression appropriate offset eld 
ease contract language allows specifying attributes pointers base addresses 
example alloc represents allocation size starting location pointed part table lists transformation contract attributes constraint variables referring locations pointed speci ed pointer 
constructs 
points graph contains may information representing fact pointer may may point speci location 
furthermore pointers summary location may pointers 
re ect fact base address represented may may modi ed ip generates update statement shown table nondeterministic assignment unknown statement 
hand conservative analysis take account possible values pointer verify expressions possible pointer values 
done generated assert statements program conditions 
handle casting unions ip generates assignment type constraint variable assignments unknown constraint variables 
example assignment integer concrete location represented location yields assignment val addition ip generates assignment set unknown 
particular cast pointer type conservatively handled assignment unknown 
pointer analysis determines functions may invoked call statement function pointer 
cssv generates non deterministic statement selects arbitrary function call 
dicult write general contracts format functions sprintf printf 
format functions ip generates automatically pre post condition exact calling context 
cssv warns cases format parameter constant 
complexity ip 
number constraint variables ip number variables allocation sites program 
pointer may point locations translation expression contains pointer generates ip statements 
size ip number expressions 
order magnitude improvement transformation generates variables statements 
integer analysis nal step cssv analyzes ip reports potential assert violations 
theory sound integer analysis 
tracked semantic properties external procedure application essential track relationships constraint variables just possible values 
furthermore conditions infer involve construct ip statements alloc set rp val rp nullt false set set val rp len set rp nullt true rp nullt set rp len nullt unknown rp nullt set rp len val val unknown am mod am rp nullt rp len set set set alloc rp set set set nullt rp nullt strlen rp len set table generated transformation statements conditional expressions contracts attributes 
variables type pointer char 
variables int type 
alloc memory allocation routine malloc alloca 
properties postcondition regarding new set ptrendtext 
goal possible false messages apply linear relation analysis algorithm discovers linear inequalities numerical variables 
method identi es linear inequalities form integer variable constants 
case constraint variables 
termination integer analysis information control ow node conservatively represents inequalities guaranteed hold control reaches respective point 
reader referred information integer analysis 
assert checking integer analysis assert statement veri ed 
done checking asserted integer expression implied linear inequalities hold corresponding control ow node 
implied rbuf size rbuf len rbuf rbuf len set rbuf len require rbuf set error require may violated rbuf buf len report error line main 
derived inequalities execution line main counter example 
counter example generated 
counter example describes values constraint variables string error program may arise 
fig 
demonstrates static integer analysis algorithm identi es error call line main 
algorithm yields inequalities shown fig 
hold execution line equality shown fig 
holds violation precondition occurs 

deriving contracts section presents integer analysis algorithms strengthen pre post conditions 
process applied procedure 
compute side ect information 
run inliner ip vacuous true pre post condition produces integer program ip 
run forward integer analysis ip computes safe approximation strongest postcondition 
obtain new ip program ip strengthening postcondition set linear inequalities generated integer analysis procedure exit 

run backward integer analysis ip computes approximation weakest liberal precondition 
obtain new ip program ip strengthening precondition set linear inequalities generated analysis procedure entry 

writeback ppt convert pre post conditions ip expressions formal parameters global variables derivation process start manually contracts 
applications acyclic call graphs process automatically applied bottom fashion starting leaf procedures 
integer analysis algorithm essentially algorithm section reporting false alarms 
computes linear inequalities hold exit point 
local variables eliminated 
resulting inequalities added input postcondition 
improve ectiveness derivation inliner phase allowed add designated variables record values properties may modi ed potentially modi ed integer property expressed expression hei inline procedure includes new variable hei additional statement assume hei hei writeback process variable replaced appropriate expression postcondition 
example ptrendtext may modi ed variables record properties 
particular variable rp set records value expression rp set entry 
linear relationships obtained applied running example true precondition nullt true len set rp set rp set val existence null termination byte new length base address points ptrendtext computed precisely 
nds relationship old new sets ptrendtext 
relationship weaker manually provided inequality equality 
may lose information due joins control ow paths due widening operation 
similar forward algorithm sense uses domain operations 
main di erence treatment assignments handled substitutions 
write back pre post conditions generated converted expressions formal parameters global variables expressions added input contracts logical operator 
obtaining postconditions recall integer analysis computes properties locations 
location corresponds set value expressions global formal variables consider location assume simplicity unique expression say value case constraint variable inequalities occur exit replaced substituting occurrence designated formal parameter hei replaced semantic properties converted contract language attributes 
equations writeback algorithm yields ptrendtext nullt ptrendtext strlen ptrendtext set ptrendtext location corresponds set lvalue expressions generate weaker postcondition logical operator 
alternative ignore expressions may lead false alarms procedure analyzed cssv 
obtaining preconditions generating expressions preconditions entry inequalities similar process generating postcondition 
main di erence logical logical multiple expressions correspond location 

empirical results implementing cssv tool non trivial complicated aspects program analysis 
implemented prototype cssv signi cant help semantics tools group microsoft research tel aviv university 
compiler built ast toolkit 
cssv uses golf ow insensitive context sensitive points analysis technique underlying program pointer analysis 
golf uses ow edges represent assignments 
partial information pointer aliases extracted edges 
integer analysis automatic derivation pre post condition implemented poly library 
applied cssv procedures string manipulation library airbus total lines procedures 
ii part web converter tex related web programs consist lines procedures 
manually written contracts analyzed procedures 
table describes benchmark characteristics analysis results 
column loc displays number source lines original source 
column sloc dis plays number source lines source source transformation 
contract column investigates dif culty manually providing contract 
characters follows simple speci cation string bounds specifying boundaries bu ers integer relations 
need provide pointer speci cation analyzed code 
columns ip vars ip size report number variables statements integer program produced ip 
columns cpu space display running time total allocated space cssv 
measurements done mhz intel pentium iii cpu mb memory running windows 
msg columns classify messages reported cssv 
messages classi ed errors cases input application error occurs 
errors detected due unsafe calls library functions strcpy unsafe assumptions input contains speci character unsafe pointer arithmetic 
false messages airbus code 
program destructively assigns non zero character certain place bu er 
cssv fails infer character non zero 
function skip balanced safely assumes input parameter contains balanced number parentheses 
veri ed function called prior skip 
example demonstrates cases hard separate safety correctness 
show function safe need verify correctness implementation correctly checks input string contains balanced number parentheses 
fortunately analyzed examples case safety depend correctness 
deriving columns provides information ectiveness algorithms 
trivial measure result terms precision 
new contract function change result analysis procedures invoking provide simple measurement independent calling context 
run generate postcondition generate precondition run cssv 
columns cpu space display running time total allocated space 
column vacuous displays number false alarm messages reported cssv vacuous contract analyzed procedure provided 
column auto displays number false alarms reported cssv automatically derived contracts 
average manually provided contracts reduce number false alarms compared vacuous contracts false alarms automatic derivation algorithm reduces number message 
derived preconditions cases weaker manually provided ones 
initial study indicates happens integer analysis joins di erent procedure behaviors 
potential remedy imprecision sets linear inequalities allow precisely represent logical 

related static detection string errors problem string manipulation safety checking verify accesses bounds domain string programs requires analysis capable tracking features programming language handling standard functions strcpy strlen perform unbounded number loop iterations ii statically estimating length strings addition sizes allocated base addresses length dynamically changed index rst null character iii simultaneously analyzing pointer integer values required precisely handle pointer arithmetic destructive updates 
academic projects produce unsound tools statically detect string manipulation errors 
extension lclint 
uses unsound lightweight app 
function source code cssv msg deriving loc sloc contract ip vars ip size cpu sec space mb false errors cpu sec space mb vacuous auto airbus rtc si sbi rtc se sb rtc si rtc si find si rtc si sbi rtc si sbi rtc si sb rtc si er sbi rtc se si remove newline insert long sb join sb skip balanced sb bare table experimental results 
techniques heuristics code annotations check bu er ow vulnerabilities 
claire tool esc java check security holes programs translating subset guarded commands 
annotation language similar sense cssv 
wagner algorithm statically identi es string errors performing ow insensitive unsound analysis 
main disadvantage unsound tools errors cssv error 
furthermore track ects pointer arithmetic widely method string manipulation 
sound algorithm statically detecting string errors 
handle particular multi level pointers structures 
far know cssv rst sound tool handle precise manner 
automatic derivation process houdini annotation derivation tool tries esc java di erent annotations 
approach inadequate case number potential annotations unbounded 
contrast derive contract forward backward analyses integer program 

bu er ow harmful source defects programs 
software vulnerable hacker attacks 
believe cssv provides evidence sound analysis applied verify statically absence string errors realistic applications 
acknowledgments das providing assisting ast toolkit golf 
bertrand nicolas halbwachs providing polyhedra library support 
assistance prototype implementation technical insights 
seth hallem roman tom reps reinhard helpful comments 

bodik gupta sarkar 
abcd eliminating array bounds checks demand 
sigplan conf 
prog 
lang 
design impl 
chess 
improving computer security extended static checking 
ieee symposium security privacy 
cousot halbwachs 
automatic discovery linear constraints variables program 
symp 
princ 
prog 
lang 
das 
uni cation pointer analysis directional assignments 
sigplan conf 
prog 
lang 
design impl 
das ahndrich rehof 
estimating impact scalable pointer analysis optimization 
static analysis symp 
deutsch 
interprocedural may alias analysis pointers limiting 
sigplan conf 
prog 
lang 
design impl pages new york ny 
acm press 
dijkstra 
discipline programming 
prentice hall 
dor 
statically detecting bu er ows phd thesis univ tel aviv israel 
preparation 
dor rodeh sagiv 
checking string manipulations programs integer analysis 
static analysis symp 
flanagan rustan leino 
houdini annotation assistant esc java 
formal methods increasing software productivity volume lecture notes computer science 
halbwachs 
static analysis linear properties invariantly satis ed numeric variables program 
phd thesis grenoble university 
halbwachs veri cation real time systems linear relation analysis 
formal methods system design 
heintze 
ultra fast aliasing analysis cla lines code second 
sigplan conf 
prog 
lang 
design impl 

new polka library 
available www irisa fr bertrand html 
kernighan ritchie 
programming language 
prentice hall englewood cli nj usa 
wolfe 
elimination redundant array subscript range checks 
acm sigplan notices 
landi 
interprocedural aliasing presence pointers 
phd thesis dept comp 
sci rutgers univ 
evans 
statically detecting bu er ow vulnerabilities 
th usenix security symposium 
leavens baker 
enhancing pre postcondition technique expressive speci cations 
formal methods 
liang harrold 
ecient computation parameterized pointer information interprocedural analyses 
static analysis symp 
marlowe ryder 
ecient hybrid algorithm incremental data ow analysis 
symp 
princ 
prog 
lang 
microsoft 
ast toolkit 
available research microsoft com sbt ast asp 
miller koski lee murthy natarajan 
fuzz revisited re examination reliability unix utilities services 
available www cs wisc edu bart fuzz fuzz html 
morgan 
programming speci cations 
prentice hall 
myers 
precise inter procedural data ow algorithm 
symp 
princ 
prog 
lang 
rinard 
symbolic bounds analysis pointers array indices accessed memory regions 
sigplan conf 
prog 
lang 
design impl 
ryder landi stocks zhang 
schema interprocedural modi cation side ect analysis pointer aliasing 
acm transactions programming languages systems 
simon king 
analyzing string bu ers international conference algebraic methodology software technology 
wagner foster brewer aiken 
rst step automated detection bu er overrun vulnerabilities 
symp 
network distributed systems security 

simpli er 
www cs tau ac il htm 
