modeling analyzing software behavior uml ivan permission faculty chemical engineering abo university public criticisms turku finland november noon 
department computer science abo university supervised professor ralph back department computer science abo university turku finland reviewed professor michael butler declarative systems software engineering group university southampton southampton bj united kingdom professor wang yi department computer science uppsala university box se uppsala sweden isbn issn oy turku finland family heart gold drive powerful unpredictable ship existence 
couldn provided knew exactly improbable thing wanted 
douglas adams hitch guide galaxy thesis product single person 
years making am really glad able everybody contributed way thesis 
think researching similar experience steering douglas adam heart gold impossible provided know exactly really want 
fortunately supervisor professor ralph johan back helping task 
constant source advice guidance support time 
want professor michael butler university southampton united kingdom professor wang yi university uppsala sweden kindly reviewed thesis 
provided constructive comments improve hope able follow integrate suggestions manuscript 
damon patiently corrected beautiful english language 
ideas thesis appeared initial form conference proceedings journal publication 
publications coauthored professor ralph johan back professor johan lilius petre 
collaboration scientifically fruitful warm personal experience 
colleagues abo university help greatly research 
christina professor hannu toivonen professor von wright provided interesting comments enlightening discussions topics discussed thesis 
robert built hardware digital sound recorder validation design possible 
turku centre computer science department computer science provided excellent working environment generous financial support 
want express sincere colleagues contributing inspiring working atmosphere 
dr mats provided reliable answers diverse questions 
dr martin chi dr anna dr leonid excellent role model follow 
wish fellow phd 
students specially dag bj franck course christina best studies 
want family friends specially asa continuous unconditional love support am 
turku october ivan ii contents 
uml 
semantics uml 
formal semantics 
quality uml models 
analyzing uml models 
analyzing cases 
analyzing statecharts 
hybrid statecharts 
list publications 
modeling uml 
object oriented software development 
uml 
ocl 
tool support 
profiles 
uml just modeling language 
requirements sound recorder 
analysis object structure 
identifying objects 
building class diagrams 
analysis defining object behavior 
user interface 
architectural design 
architectural patterns 
concurrency design 
mechanistic design 
iii collaboration hardware reactive objects 
collaboration reactive objects user interface 
pattern reactive subject 
scheduler 
changing time 
playing message 
detailed design 
objects modeling hardware 
sound compression algorithm 
direct memory access channels 
memory allocation 
comments implementation 

analyzing case models contracts 
cases 
cases 
contracts 
example library 
analysis 
proving properties 
related 

statecharts 
structure state machines 
dynamics state machines 
calculation step 
run completion step 
model elements interaction diagrams particular comments semantics related verification collaborations statecharts modeling concurrent systems statecharts describing properties model iv collaboration objects vuml tool open models structure promela model verification spin representation counter examples example production cell modeling press modeling robot verification related evaluation tool related real time hybrid behavior statecharts hybrid statecharts action systems continuous action systems semantics continuous action systems systems differential equations real time systems composition continuous action systems statecharts continuous action systems transitions examples safety properties proving safety press related vi list figures example concrete syntax statecharts 
example syntax statecharts 
external appearance sound recorder 
context level diagram 
case diagram 
user interface mock 
playing message scenario 
alarm playing message scenario 
entering stand mode scenario 
sound recorder main class diagram 
subsystems sound recorder 
audio subsystem class diagram 
representation sound messages 
play message sequence diagram 
message memory class diagram 
alarm clock class diagram 
user interface subsystem class diagram 
behavior 
statechart 
statechart 
hardware architecture digital sound recorder 
task diagram 
event proxy class diagram 
scheduler class diagram 
collaboration scheduler clients 
model view controller collaboration 
collaboration user interface audio controller recording audio block 
recording compressed audio 
case diagram 
vii formal specification syntax 
library class diagram 
complete definition class book 
complete definition class 
library class diagram operations 
library contract 
weakest precondition case 
result weakest precondition case result wp computation 
librarian result wp computation 
example statechart 
history states 
replacing history states 
translation state machine 
translation join fork vertices 
translation junction vertices 
version run completion step final version run completion step collaboration objects machine able observe execution order machine deadlock vuml class diagram dining philosophers behavior forks top philosophers bottom temporal requirements embedded statecharts class diagram dining philosophers constraints dinner sara move dinner suddenly example necessary separate selection firing vuml window showing counter example icons showing event deferred dispatched top view production cell robot press class diagram press controller press model plant press press collaboration diagram behavior robot controller detailed behavior robot controller detailed behavior robot controller cont 
viii hybrid statechart saw evolution hybrid statechart saw continuous action system saw vertical position press hybrid statechart press version press continuous action system 
final version press continuous action system 
ix list tables external event list 
operations play record message 
classification uml diagrams 
case borrow book 
case renew loan 
case return book 
case pay fee 
performance vuml tool xi xii chapter software 
computers integral part society economy software larger complex day 
software development difficult activity software projects take longer expected large operational failures simply cancelled 
problems main concerns software engineer community 
proposed way reduce complexity software development build software models 
model simplification reality retains elements relevant problem 
purpose software model represent convey important requirements design decisions software system 
model explain concepts easy way ignore unimportant details 
detail unimportant example known members development team easily inferred rest model 
software model described modeling language 
currently widespread software modeling language unified modeling language uml 
uml widely accepted industry standard language software analysis design 
uml graphical language 
software concepts represented visually icons 
harel interesting arguments favor visual representation software development 
uml model usually composed diagrams 
division model different diagrams important mechanism manage software complexity 
diagram represents different aspect view system 
see examples diagrams sound recorder case study complete uml model chapter 
case study performed help johan lilius publication number 
uml models created software development process 
start drawing uml diagrams initial planning analysis stages clear idea system look 
refine create diagrams concrete design 
software constructed model 
quality final software depends quality model model contains wrong design decision actual program code built decision 
thesis different analysis methods assure quality uml model 
analyzing uml model asking answering questions 
safety critical systems life persons risk software behave expected obvious candidates software analysis techniques 
economic argument applied software development uml models created early stages development process correction mistakes analysis design phases achieved cheaply rapidly implementation software deployed 
principle holds evolutionary spiral software processes design precedes coding 
uml models usually simpler implementation 
analyzing uml model simpler cheaper analyzing implementation java program 
development team concerned final quality software interested verifying validating software models early software process possible 
uml unified modeling language standardized notation modeling documenting object oriented software business processes result fusion best practices software modeling visual notations constant evolution 
origins previous booch rumbaugh jacobson 
object management group omg currently charge maintenance revision 
large group companies universities members group may propose vote enhancements corrections omg specification 
adoption single standard modeling language provides benefits software developers 
training simplified just language learn 
simplifies communication development teams exchange models common language 
large user base enables market sophisticated tools training consultancy services attracts attention scientific community works improvement language 
benefits uml idea standard language modeling needs 
unified language important shortcoming uml complex 
beginners find uml large tools support features language 
uml models usually composed different diagrams 
uml diagrams show static structure software system 
example class diagram shows collection classes types interfaces associations 
class diagram show operations class describe actual behavior operations 
behavioral diagrams sequence diagrams statecharts describe dynamics model 
diagrams describe happens invoking operation lifetime object 
complete uml model contains structural behavioral diagrams describing static dynamic aspects system 
thesis focused study behavioral diagrams 
semantics uml definition uml covered document named omg unified modeling language specification 
document contains definition elements form uml language 
large version march pages 
document oriented tool developers software scholars average uml practitioner 
uml computer languages defined elements concrete syntax syntax semantics 
uml notation guide chapter describes concrete syntax graphical representation model element 
syntax described uml metamodel 
uml metamodel uml model describing valid uml model 
enumerates model elements attributes relationships model elements 
uml metamodel uses class diagrams constraints object constrain language ocl 
ocl textual language annotating constraining model elements 
expression language free side effects 
uses syntax similar object oriented programming languages replaces mathematical symbols words english forall exists 
semantics uml natural language 
purpose behavior model element concise times confusing explanations plain english 
example shows concrete syntax elements initial state composite state state transition final state example concrete syntax statecharts notation uml statecharts 
final state statechart depicted black dot inside circle 
uml metamodel elements shown 
diagram shows state special kind state vertex 
state vertex incoming outgoing transitions 
states internal transitions 
kind states simple states composite states contain state vertices final states 
diagram annotated ocl expressions 
case final states constraint indicating final states outgoing transitions words number outgoing transitions zero 
write constraint ocl context outgoing size meaning model element defined plain english 
semantics final state uml standard special kind state signifying enclosing composite state complete 
enclosing state top state means entire state machine completed 
uml specification document ambiguous uml explained plain english uml 
fails give precise meaning uml model element explain interactions model elements 
fact possible create metamodel uml subset uml interesting shows power language absolutely help define dynamics 
ambiguous semantics lead situation member team free interpret uml model different way 
programmer interprets model different way designer programmer implement system container state source outgoing target incoming example syntax statecharts transition internal correspond design 
benefits standardized language lost 
ambiguous semantics prevent construction utilization advanced tools code generation model animation validation 
formal semantics remove ambiguities language remedy previous situations authors working formal semantics uml 
formal semantics give unambiguous interpretation uml mathematical formalism enable static behavioral analysis uml models 
give formal semantics uml introducing mapping uml diagrams established formal method software development 
examples approach formalizations uml object vdm 
uml model translated specification formal language analysis manipulations performed formal specification 
clear advantage approach possible reuse previous formal method analyzing uml models 
authors formalization uml directly mathematical theory set theory category theory 
advantage approach mathematical theory usually imposes fewer restrictions formal method specifically designed uml 
quality uml models clear understanding uml language uml models develop different techniques assure improve quality model 
techniques important uml user quality final software depends quality software models 
classify techniques syntax checking type checking metrics full behavioral verification full validation 
syntax type checking issue address analyzing model uml model 
uml model legal syntactically correct conforms uml notation guide uml metamodel 
expect tools claim uml compliant produce syntactically correct uml models 
interesting question uml model type consistent 
clark type system class diagrams ocl expressions ensures illegal field values supplied basic operations contained operation domain 
metrics critics uml tools calculate various metrics model 
metrics provide hints quality model 
example diagram classes difficult understand class attributes certain candidate refactoring 
designer responsible deciding 
tools argo uml implement critics automatic auditors 
critic program detect common design errors model class constructor statechart initial state 
critic enforce style guidelines capitalization letter class name avoiding program keywords names 
critics heuristics ensure final correctness fitness design help designer improve quality model 
full verification demanding type analysis uml model full formal verification 
formal verification mean mathematical proof uml model satisfies certain property 
able express uml model requirements mathematical formalism theorem prover model checking tool obtain proof 
validation verification answers question building model right 
validation answers question building right model 
validation performed requirements final customer application 
context tools animating rapid prototyping uml models great help 
example tool validating uml models 
create object diagrams class diagrams evaluate ocl constraints 
logix uml tool animates statecharts 
software model tool features automatic prototype generation uml models including persistence user interface 
analyzing uml models main contribution thesis collection verification techniques case diagrams collaborations statecharts 
order develop techniques need formalize aspects uml language 
purpose different formal methods refinement calculus model checking 
refinement calculus refinement calculus framework developed back von wright stepwise software development 
key characteristic refinement calculus formal refinement specifications 
software modeled imperative state specification language 
specification stepwise refined better concrete specification preserves original correctness requirements 
refinement steps develop software initial requirements final implementation correct construction 
semantics specification language dijkstra weakest precondition semantics programs 
weakest precondition predicate transformer computes weakest initial predicate guarantees postcondition achieved specification 
mathematical foundations refinement calculus lattice theory higher order logic 
allows prove correctness specifications rigorous manner 
refinement calculus formalized theory hol theorem prover 
computer tool perform proofs 
higher order logic extension simply typed lambda calculus 
functions defined abstraction explicit definition naming 
example function calculates successor natural number defined 
denote application function argument 

binary relation considered function pb mapping elements sets elements refinement calculus defines hierarchy specification languages 
thesis specification languages action systems contracts 
action system construction refinement calculus model concurrent distributed systems 
action system formalism introduced back kurki 
action system defined finite set guarded actions updates finite set shared attributes 
action atomic executed soon guard enabled 
expressive specification language refinement calculus language contracts 
contract specification binding behavior multiple agents 
define agent entity free 
computation seen number agents programs modules systems users 
carry actions contract statement advance 
model checking model checking search complete state space model incorrect behavior 
model checking successfully applied industrial verification projects mainly hardware communication protocols 
prevents applying technique uml model 
model checking requires model expressed finite automaton 
possible behavior model corresponds possible run automaton 
property verified expressed formula temporal logic 
thesis propositional linear temporal logic ltl 
linear temporal logic include operators read read eventually model system executions 
example ltl formulae button press interpreted true press button elevator eventually arrives floor 
possible convert ltl formula automaton 
applies negation ltl formula 
intersect automaton representing model automaton representing negation property obtain new automaton represents runs violate property 
approach model checking tool verify behaviors model automatically 
model satisfies property correct result intersection empty automaton 
new calculated automata produce counter examples 
counter example run model violates property verify 
studying counter examples fix model repeat process model correct 
main challenge application model checking state space explosion problem 
modern model checkers apply optimizations partial order reduction fly verification reduce memory needed speed verification 
possible perform approximated verification possible behaviors explored 
case control measure coverage verification 
analyzing cases analysis case diagrams main topic chapter 
case diagram specifies required functionality system showing collaboration set actors perform certain tasks revealing internal structure system 
case diagrams model context requirements system development 
context system defines environment system lives includes actors system 
actors entities free certain goals fulfill 
impose functional requirements system 
consider case models informal contracts system actors 
actors behave described case system promises deliver functionality described case 
behaved system carry required cases predictably reliably 
complement case diagrams providing formal documents similar specifications programs called contracts regulate behavior actors involved 
contract written refinement calculus analyzed mathematically 
particular check specific actor achieve goals contract spite possibly conflicting behavior actors 
order analyze contract define precise meaning statement weakest precondition predicate transformers 
example show model analyze simple case model library system 
create contract case model analyze compute conditions member library system borrow book 
performed collaboration ralph johan back petre publication number 
analyzing statecharts statechart describes behavior model element changes internal state result receiving external stimuli 
statecharts introduced harel quickly adopted visual notation design concurrent reactive systems 
statecharts concept finite state machine notation includes new features hierarchical concurrent states model complex behaviors concisely 
uml statecharts harel include new concepts important differences dynamics models 
uml variant geared software implementation object oriented programming language 
assumes large system modeled collaboration objects defined statecharts 
discuss complete formalization semantics uml statecharts chapter 
formalization terms operational semantics basis code generation simulation verification tools uml statecharts diagrams 
formalization parts formalization structure behavior 
reasons distinction model elements composing statechart syntactic sugar explained terms simpler elements 
possible define different semantics different application domains structure statecharts 
fact chapter dynamic model includes real time hybrid statecharts 
chapter discusses problems associated standard definition statecharts 
formalization statecharts vuml tool tool modelchecking uml models 
vuml tool supports concurrent distributed models containing active objects synchronous asynchronous communication objects 
vuml behavior object specified statechart 
vuml tool introduces new stereotypes constraints describe behaviors satisfied model 
designer uses stereotypes add extra information design tool extract properties verified 
new stereotypes part uml standard introduced allow designer describe safety liveness requirements having learn temporal logic 
internally tool uses spin model checker perform verification 
design tool emphasis put usability designer know spin promela language 
error verification tool creates uml sequence diagram showing reproduce error uml model 
vuml tool study model production cell case study 
production cell standard example evaluating methodologies designing embedded systems 
performed collaboration johan lilius publications 
hybrid statecharts real time system system perform right thing right time 
hybrid system models continuous processes controlled discrete computations 
real time hybrid systems useful study systems computer supervises controls physical phenomena real world movement elevator chemical plant 
uml standard support real time hybrid systems 
ongoing effort create extension language modeling real time systems uml 
time writing text extension presents new model elements precise model time models 
solve situation chapter extension uml statecharts useful model real time hybrid systems 
extension consists just new model element continuous action 
continuous action model real time clock physical behavior described function time 
formalize continuous actions action systems language refinement calculus 
show new formalism analyze safety properties hybrid statecharts 
example show analyze hybrid model press production cell verify press moves bounds 
performed collaboration ralph johan back petre publication number 
list publications thesis publications 
ivan johan lilius digital sound recorder case study designing embedded systems uml notation tucs technical report january 

johan lilius ivan vuml tool verifying uml models 
proceedings automatic software engineering conference ase october cocoa beach fl usa 
ieee computer society 

ralph johan back petre ivan analysing uml cases contracts 
france rumpe eds 
uml unified modeling language october fort collins usa 
lecture notes computer science vol 
pp 


johan lilius ivan formalising uml state machines model checking 
france rumpe eds 
uml unified modeling language october fort collins usa 
lecture notes computer science vol 
pp 


johan lilius ivan production cell exercise formal verification uml model proceedings th hawaii international conference system sciences hicss 
january maui hi usa 
ieee computer society 

ralph johan back petre ivan continuous action systems model hybrid systems 
nordic journal computing vol pp 
spring 
chapter modeling uml chapter brief unified modeling language uml standardized notation modeling software intensive systems 
review origins goals uml show applied software project complete case study uml 
uml large complex includes different concepts types diagrams 
uml responsibility designer source confusion beginner decide type diagram fits best design concept 
hope case study help understand apply uml project requirements detailed design 
case study presents complete design digital sound recorder 
target application simple basically just records plays back speech 
challenging exercise uml 
data modeling plays relatively small role design compared importance capturing real time behaviors user interaction 
digital sound available market 
model described designed specifications commercial product known manufacturer 
design validated implementing programming language custom board bit embedded controller 
design created software process targeted realtime embedded systems 
software process iterative fact ran iterations process obtaining current design 
design sequential fashion tasks described waterfall process 
reason believe easier understand finished design way 
felt unnecessary show mistakes produced iteration process 
proceed follows 
origins uml current status language reviewed sections 
section introduces case study developed rest chapter 
fifth section discusses object model system presents main class diagram 
section continues object oriented analysis focusing internal behavior object 
section deals architectural design 
show hardware architecture sound recorder concurrency model assign object execution thread 
design continues definition collaborations different objects 
done section design patterns glue classes defined analysis phase 
specific design issues discussed section 
section briefly discusses implementation 
object oriented software development roots uml object oriented software paradigm 
concept object oriented programming introduced dahl nygaard simula 
alan key consolidated ideas smalltalk programming language 
objects combine attributes representing storing data operations manipulate attributes 
object oriented programs constructed collection objects collaborate exchanging messages 
object oriented programming languages oop objective self eiffel 
ideas introduced oop languages generalized software engineering principles 
term object oriented design booch 
booch began refer approach object oriented development 
object oriented software development advocates objects software development cycle 
main activities software development analysis design implementation testing 
objectoriented analysis define analysis objects capture problem domain 
problem domain reusable description problem solve context 
object oriented design proposes solution problem domain creating combining design objects 
design realized program objects object oriented programming language 
activities orchestrated software process 
software process describes manage software project 
defines series tasks phases performed sequence 
large projects run years require skilled planning 
software process contains knowledge needed run projects 
process method presents unique way building software trying maximize probability success project optimizing resources minimizing risks 
example waterfall software process advocates complete analysis problem domain starting design phase 
coding starts design complete code tested program implemented 
main drawback idealized process validate complete detect analysis errors final test step 
contrast spiral process recommends interleaving analysis design coding testing succession small steps validating project step 
complete software methods appeared period booch coad yourdon fusion coleman omt rumbaugh oose jacobson mellor 
method unique strength share common concepts practices 
method introduces differences deliverables produced analysis design phases 
deliverables usually combination textual descriptions graphical models 
model simplification reality contains elements relevant problem 
analysis model represents simplification problem domain design model represents particular solution problem 
models detailed programs 
program implementation design model detailed computer execute 
contrast model simpler easier understand 
find analogy software models architectural floor plans 
floor plan contains important directions needed build building place doors windows contains small details position individual brick 
software models show general floor plan program show local variable program statement 
unfortunately previous software methods uses different notation documenting project describing models 
basic design concepts represented complete different ways depending process build software 
example booch represents class cloud oose represents rectangle 
differences modeling notations restricted methods fragmented objectoriented market complicated development computer aided software engineering case tools 
situation booch rumbaugh jacobson started working unification methods 
june released version unified modeling language uml language combining strong points methods 
surprisingly idea combining methods probably come authors 
rosenberg scott claim working unified object modeling approach methodology combining strongest point approaches 
currently adopted uml notation 
uml unified modeling language standardized notation modeling documenting object oriented software business processes 
result fusion best practices software modeling visual notations 
uml constant evolution 
object management group omg currently charge maintenance revision 
large group software companies universities members group may propose vote enhancements corrections omg specification 
adoption single standard modeling language provides benefits software developers 
training simplified just language learn 
simplifies communication development teams exchange models common language 
large user base enables market sophisticated tools training consultancy services attracts attention scientific community works improvement language 
benefits uml idea standard language modeling needs 
unified language important shortcoming satisfy needs application domains language large difficult learn 
ocl element uml specification object constraint language ocl 
ocl textual language annotating constraining model elements 
expression language free side effects 
introduced ibm limited revision uml 
common uses ocl include constraining associations objects defining postcondition operation defining class invariants 
ocl uml diagram 
example invariant states possible employees name context inv self employee forall implies name name expression invariant model element 
denoted context inv keywords 
invariant condition hold 
operator navigate association case relationship employees 
forall universal quantification implies logical implication stands inequality 
interpret invariant way employees employees names different 
tool support uml computer support pencil generic drawing program 
need tools specific support uml large software projects 
tools allow draw fancy uml diagrams additional features support software development 
uml tools available market 
currently tools prices range zero usd user 
classify functionality provided uml tools large groups diagram editing code generation model extraction model verification validation model management 
commercial uml tools implement kind functionality areas 
uml diagram editor helps user create edit print uml models 
ideally diagram editor allow user create legal uml diagram legal uml diagrams 
legal mean diagrams conform uml syntax specification 
unfortunately time writing tool complete support uml standard 
situation aggravated trying specific uml extension 
case generic drawing program useful full featured uml case tool 
group include drawing aids electronic white board handwriting recognition uml symbols 
code generation module creates program source code uml model 
power utility code generator depends supported uml model elements target languages 
code generation tools produce skeleton program structure described class diagrams 
advanced tools generate full behavioral code statecharts 
code generators support java programming languages tools support scripting languages python 
model extractor creates uml model reverse engineering program source code 
code generation combined model extraction leads roundtrip engineering model converted back forth program 
advanced form conversion models code synchronized editing uml diagrams program code edited simultaneously different windows application 
model verification validation tools help designer ensure final quality model 
discussed tools chapter verification tool statecharts chapter 
group comprises tools model management 
adoption diagrammatic modeling languages means ascii text longer primary form describing software 
standard tools manipulating program text diff patch suitable graphical models 
group include tools version control visual differencing web publishing uml models 
profiles uml expressive rich language different application domains business software embedded systems 
possible applications uml varied language may cover possible needs particular software designer 
provision extending language stereotypes tagged values 
stereotype classification model elements 
mark model element stereotype special iconic representation stereotype just name stereotype matching name 
chapter stereotypes indicate model elements represent disallowed behaviors 
mark elements invalid stereotype 
tagged value piece additional data add model element 
tagged value pair composed name tag value string 
uml give interpretation tagged values 
example tool tagged values track author revision number model element 
stereotypes tagged values new model elements collected profile 
profile customization uml specific application domain 
think profile appendix uml standard 
profiles uml corba scheduling real time applications 
profiles combining uml modeling languages uml sdl profile 
variety published house profiles authors consider uml single language family languages 
standard uml maintained omg common uml profiles 
uml just modeling language important realize uml software process visual programming language 
uml specifies notation modeling software describe build models 
goals uml standard language software process 
uml better suited case driven architecture centric software process 
adoption uml standard language spawned multitude software processes design methods 
rational unified process catalysis octopus uml examples post uml software processes 
uml intended visual programming language 
modeling completely different task programming 
model describe key elements system abstracting specific details 
theory programming language implement uml model practice obtain best results tool support class object oriented programming language java 
requirements sound recorder section digital sound recorder case study develop rest chapter 
digital sound recorder consumer electronic appliance designed record play back speech 
messages recorded built microphone stored digital memory 
user quickly play back message moment speaker placed front device 
small light easy operated small battery 
shows sound recorder look hand held unit flat display fairly large buttons 
main features product consider design digital memory different messages 
length message limited available memory 
direct access message 
full function lcd display 
easy screen menus 
display shows clear indications doing 
alarm clock 
alarm beeps seconds user presses button 
current date time shown display 
battery level indicator 
system beeps battery low 
external appearance sound recorder stand mode 
battery power 
normal operation resumed user presses key 
sound quality 
sound processed khz bits sample 
external events embedded system constantly interacting environment 
stage analysis consider system black box reacting messages environment 
environment composed actors 
actor interacts system different purpose exchanges different set messages 
context level diagram shows actors interact sound recorder 
identified actors user battery time 
consider battery time actors control 
battery unexpectedly run power way user press button moment 
time actor sends message system time passes 
represents source messages second hour 
context level diagram shows interfaces sensors actuators allow system actors exchange messages 
messages requests actors system responses services system actors 
sensors input user microphone buttons 
actuators user speaker display 
battery level meter senses state battery crystal measures time 
event significant message environment 
real time reactive system react external events bounded time 
enumerate external events occur system table 
direction event system response dir second update internal clock check alarm update clock display playing recording update progress sample play record sample period button press update user interface start user request low battery alarm warn user current task resume stand leave stand mode 
table external event list event environment system system environment 
arrival pattern periodic event occurs fixed time basis episodic arrival time random 
response time sets upper bound system response actions 
system behave incorrectly react response time 
cases cases describe functionality system user point view 
user may person machine 
case different way system completion case produces different result 
system main different cases represented fig 

order describe cases need define human machine interface device 
includes external appearance mock ups graphical user interface 
interaction user menu driven display shows current menu 
top line shows current time date alarm time 
bottom short help message user 
main cases systems select play record delete message set time date display time wake alarm 
playback message user selects message slot message menu presses play button 
message slot contains recorded message system plays speaker user presses button 
case includes select message case 
select message user selects message option main menu buttons 
user presses button user time battery user key presses sound graphical user interface second sample low battery resume keyboard microphone speaker display clock battery meter digital sound recorder analog digital converter digital analog converter display controller context level diagram play message record message delete message wake alarm display time digital sound recorder includes includes includes includes includes case diagram select message set time set date system user interface mock system shows contents message memory 
user selects message slot buttons 
record message user selects message slot message menu presses record button 
message slot contains message deleted 
system starts recording sound microphone user presses button memory full 
case includes select message case 
delete message user selects message slot message menu presses delete button 
message slot contains message deleted memory 
case includes select message case 
wake alarm user selects alarm option main menu buttons 
user presses button system shows contents alarm menu 
user options alarm menu switch alarm set time alarm sound 
wake alarm beeps seconds user presses button 
case includes set time case 
set time user set hour minute clock 
clock represent current time time wake alarm 
button alternately selects hour minute field 
button increases value selected field button decreases 
user stops modifying time pressing buttons 
display time system constantly shows current time display 
user set clock time date options clock menu 
case includes set time set date cases 
set date user set day month year system date 
button alternatively selects day month year fields 
button increases value selected field button decreases 
user quits case pressing buttons 
usage scenarios scenarios describe interaction active external actors user battery time system 
scenario shows happens actors behave way 
example shows scenario play message case 
scenario starts user pressing play button play message 
scenario battery interact system 
example scenario describing main course action case 
scenario happens expected user 
case includes alternative scenarios describing possible outcomes interaction system 
describing possible scenarios complex cumbersome task 
role actor usually clear difficult study possible interactions actors system 
better resolve interactions early design process possible 
example study happens battery goes low system playing message alarm sounds system recording message 
shows happen alarm sounds user wants play message 
conflict uses cases 
possible carry play message wake alarm simultaneously 
decided give priority alarm sound 
shows scenario system enters stand mode woken alarm clock 
battery warning enters stand mode 
system switch screen back light microphone speaker 
elements considerable amount battery power system save energy increase battery life switching 
battery meter warn system energy 
analysis object structure requirement analysis stark propose continuing domain analysis phase 
phase analyze requirements time user second play message display progress display clock display progress system speaker start playing sound playing sound playing message scenario time user second alarm play message display progress display clock display progress alarm indicator system speaker start playing message playing message start playing alarm playing alarm alarm playing message scenario battery time power second alarm system speaker enter stand mode switch amplifier exit stand mode switch amplifier start playing alarm playing alarm enter stand mode switch amplifier entering stand mode scenario class diagram general description problem 
domain diagram shows main classes system relationships omits interfaces 
step building class diagram identifying objects involved system classification classes 
identifying objects task enumerate objects things related project 
trying discover objects participating model need describe exact properties objects 
objects identified section analysis objects 
objects implemented objects programming language 
objects implemented hardware objects just intellectual artifacts needed analysis design realized program code 
active objects message player recorder alarm clock services battery level sensor measures remaining battery power level analog digital converter interface microphone processor digital analog converter interface processor speaker screen controller generates image lcd screen 
real world items date time speech sound physical devices microphone speaker battery keyboard buttons screen key concepts speech sampling sound sample study discrete digital system capture process analog continuous sound signal sound message persistent objects collection recorded messages current time date alarm time visual elements menu menu option menu selection clock date alarm indicator status bar task progress indicator building class diagrams sound recorder class diagram user interacts system display keyboard 
passive objects decided add user interface object manages interaction user 
user interface class relies audio controller record play sound 
audio controller core sound subsystem executes tasks suggested user interface 
audio controller uses audio input audio output classes process sounds 
classes related microphone speaker hardware wrapper 
hardware wrappers simple objects piece hardware battery display user interface keyboard microphone speaker sound recorder main class diagram message design program object 
sound messages stored message memory 
class keeps directory containing recorded messages allocates space new messages deletes old ones 
alarm clock updates internal clock checks alarm 
case notifies event user interface 
time user interface responsible showing indication display playing alarm sound help audio controller 
battery periodically measures battery power level 
battery goes low reports event user interface 
shows main class diagram digital sound recorder 
class diagram provides general overview system abstracting details class 
divided class diagram different subsystems alarm clock battery user interface memory audio subsystem 
division represented 
sections study develop subsystem detail 
audio subsystem class diagram audio controller main element audio subsystem 
plays records complete messages 
message composed audio alarm clock battery user interface memory audio subsystems sound recorder granularity play record sound sample speaker microphone th second block th second message variable length table operations play record message block objects block composed sound samples 
audio controller uses help audio input audio output process messages 
audio input class knows record single audio block 
uses microphone class hardware wrapper physical microphone 
microphone record sound sample time 
audio output speaker classes play block speaker similar fashion 
shows breakdown message audio blocks sound samples 
shows class responsible playing element 
table shows responsibilities operations classes 
questioned need different classes just play message 
answer playing recording message complex task requires precise timing interaction hardware 
think splitting representation messages streaming increase flexibility design 
design easily extended stereo messages channels audio blocks pipelined compression sound compressed recorded 
microphone message selected alarm sound generator samples audio subsystem class diagram speaker message length time recorded time delete ordered bool ordered plays plays plays speaker representation sound messages shows messages exchanged order play message 
shows real time constraints audio subsystem 
play message response time time period elapses user presses play button sound starts playing 
response time period elapses user presses button sound stops 
audio output plays block user detect delay blocks large 
block gap period elapses consecutive audio blocks 
time constraint affects sound quality 
gap large audible reproduction message silences clicking sounds 
message memory subsystem class diagram message memory class manages storage space sound recorder keeps directory recorded messages allocates space new messages 
class diagram memory subsystem shown alarm clock class diagram alarm clock keeps current time date alarm time 
uses timer measure passage 
responsibility updating internal representation time second 
purpose uses operation time class 
operations adds second time object carry 
example 
object wraps date updated method 
user play message response time response time message block block block block play message sequence diagram block gap bool message length time recorded time delete message memory class diagram time date get set alarm today get set alarm clock class diagram methods edit time 
methods increase current hour minute carry 
example 
class diagram alarm clock subsystem shown 
user interface class diagram user interface class manages interaction actors 
receives input events user keyboard time actor alarm clock battery battery hardware wrapper 
kinds events modal modeless 
system reacts way modeless event interpretation modal event depends system 
example keyboard events modal 
user presses button system select option menu system menu mode decrease current time edit clock mode 
modeless events managed directly user interface 
modal events forwarded generic user interface event handler concrete user mode object 
user interface provides feedback user graphic display 
display class interface hardware display 
switched order save energy 
graphic context abstraction 
provides basic drawing primitives drawing points current activate deactivate update battery userinterface view update keyboard bright user interface subsystem class diagram lcd font clear lines text strings filling rectangular regions flat color 
graphic context represents rectangular area display 
graphic context manages geometry transformation local coordinate system global 
view classes graphic primitives render application objects current time user menu 
view uses different graphic context draw 
menu user mode menu view classes allow user choose different options screen menu 
edit date edit clock user modes allow user change current date time 
date view time view render date time screen 
idle playing recording alarm behavior analysis defining object behavior class diagram presents static view system 
understand behavior system create new diagrams showing dynamic aspects design 
task uml behavioral diagrams activity statechart collaboration message sequence diagrams 
audio controller audio controller object referee sound channels 
sound channel record message play message play alarm sound 
playing alarm priority playing recording sound messages 
fact represented statechart shown 
see audio controller main states playing message playing alarm recording message idle 
initial state idle 
audio controller playing recording message switch alarm state operation invoked 
see delete messages audio controller idle 
design decision taken simplify design audio subsystem 
necessary mechanism prevent possible race condition user interface tries delete message played audio controller 
detected situation performing concurrency design section 
user interface menu user mode menu user mode main mode user interface 
buttons allow user navigate menus invoke desired menu option 
buttons select previous menu option 
button invokes option button go previous menu 
behavior user mode represented statechart shown 
edit clock user mode edit clock user mode change current time alarm time 
buttons switches active field minute hour field 
buttons modify active field 
behavior user mode represented statechart 
edit date user mode edit date user mode change current date 
button switch active field day month year field 
buttons modify active field 
behavior similar mode 
architectural design section describe hardware resources allocated design 
final product design hardware important software 
hypothetical customer buy program hardware device product containing elements 
try optimize hardware sound recorder 
example processor currently powerful needed 
probably expensive bigger needs energy powerful processor 
extra processor power allows focus design ignore implementation issues optimization techniques particular architecture 
main processor hitachi sh running mhz kb chip ram 
embedded processor built processor core built peripherals 
processor core conventional risc integer pipeline task execute machine code instructions 
built peripherals consist analog digital converter timer counter units dma channels watchdog 
manual describes instruction set processor core 
hardware built peripherals described activate menu user mode inactive main menu message menu option alarm menu option clock menu option set alarm time option set alarm option set alarm option menu user mode active alarm menu message menu alarm menu clock menu userinterface alarm statechart edit clock user mode inactive activate deactivate edit clock user mode active edit minute edit hour statechart lcd lcd controller rom ram system bus analog input clock clock processor core bus controller microphone ad converter io port da converter speaker io port io port keyboard battery meter hardware architecture digital sound recorder 
shows deployment diagram proposed architecture 
prototype version contains memory debugger serial ports downloading debugging software 
architectural patterns software sound recorder special safety reliability requirements 
architecture support hardware fault tolerance 
probably user damage unit dropping floor spilling liquid hardware wears 
watchdog restart system case sporadic fault 
watchdog resets processor message memory lost 
wrapped embedded solution sound recorder communication link systems 
necessary provide communication link testing diagnosing faults system quite simple tested indications display 
designed repaired 
peripherals accessed memory address space processor 
tightly coupled require special communication patterns 
system concurrency design reactive subject task diagram user interface concurrency model specifies different execution threads communication mechanism threads 
design execution threads user system thread 
shows interaction diagram tasks system 
user thread interactive thread manages interaction user trough display buttons 
thread real time requirements 
system thread manages real time objects system 
activated processor acknowledges interrupt request 
system thread priority preempt user thread 
scheduler object running context system thread schedules execution reactive objects battery 
objects share thread return control scheduler soon possible 
objects running different threads communicate reactive subject pattern described 
mechanistic design section discuss different software objects collaborate achieve objectives 
section internal behavior individual object 
described state object changes receives message 
focus objects exchange messages describe software patterns 
software pattern description design problem general solution context 
software patterns allow reuse needed put large software system 
patterns important capture expose important design object structure system 
section patterns gamma introduce new pattern deal forces embedded systems 
collaboration hardware reactive objects 
hardware device requests interrupt wants communicate event running program 
point processor acknowledge interrupt current program flow call interrupt service routine isr 
routine process hardware request return soon possible allow normal program execution continue 
unfortunately isr object method 
isr context information associated carry self pointer required object oriented languages 
need build mechanism transforms hardware interrupt requests messages objects 
wrapped mechanism class called isr 
subclass isr implement interrupt service routines normal method 
collaboration reactive objects user interface keyboard battery level meter alarm clock audio controller collaborate user interface reactive subject pattern 
reactive objects send events event proxy wait user interface acknowledge 
user interface constantly checks new events event proxy 
finds new event delegates responsibility view controller objects 
pattern reactive subject problem reactive real time object wants communicate event interactive non real time object 
context combining interactive reactive objects program interactive object needs updated state information reactive object 
reactive objects usually implement core embedded system 
interactive objects implement user interface system monitoring data logging tasks 
forces 
embedded real time systems complete tasks strict deadlines 
interactive systems restrictions 
usually easier design implement 
reactive initiator reactive interactive subject observer getstate event proxy class diagram 
reactive part assumptions response time interactive part 

applications interactive part needs process full sequence events sent reactive part cases interactive part just needs produced event carries updated information 
solution reactive object posts events event proxy object 
event proxy stores presence event plus object 
operation done blocking reactive object 
interactive object periodically polls event proxy check presence event method event proxy 
event event proxy returns stored interactive object 
event event proxy returns null 
interactive object uses returned query state object getstate method 
step interactive object blocked trying get state information 
event proxy provides method checks event erases event table 
rationale pattern extensively system decoupling reactive control oriented part software interactive objects 
allow benefits design objects know address existence partners 
possible reactive object initiator post event containing reactive object subject state information 
second objects share execution thread need block interfere timer scheduler period attach detach isr battery tasks observer update scheduler class diagram keyboard execution 
possible implement event proxy way need mutual exclusion mechanism preventing race conditions 
requires system able write read object atomically 
simplest way implement storing event table array objects indexed event type 
example collaboration alarm clock time view described example reactive subject pattern 
scheduler scheduler provides accurate timing time dependent objects alarm clock keyboard battery meter 
alarm clock subscribes scheduler initialization 
second scheduler notifies alarm clock second elapsed 
keyboard uses scheduler poll physical keyboard times second 
battery level meter measures voltage supplied battery seconds 
shows scheduler periodically wakes reactive objects system 
changing time edit time user mode alarm clock keyboard clock view objects follow model view controller pattern 
alarm clock provides model clock view object renders time display 
user mode objects control interaction user 
alarm clock timer scheduler attach period ms update keyboard event attach period ms update time collaboration scheduler clients reactive object clock view interactive collaborate reactive subject pattern 
keyboard object uses reactive subject pattern report key presses 
shows sequence messages produced user presses button current user mode 
playing message user interface audio controller reactive subject pattern 
audio controller message audio input audio output collaborate observer pattern 
shows sequence messages sent play message 
order simplify diagram message composed just audio block 
collaboration complex supports playing recording different messages simultaneously stereo sound message composed streams audio blocks 
detailed design objects modeling hardware hardware wrapper software object representing hardware device 
interface application objects physical devices 
constructor method hardware wrapper initializes hardware device 
object methods wrapper configure operate device reading writing directly registers device 
usually wrapper attributes state wrapper function state hardware device 
detailed design implementation hardware wrapper requires precise knowledge hardware device 
design speaker microphone timer battery meter keyboard objects reactive subject userinterface proxy observer keyboard subject initiator userinterface time update key update model view model view controller controller model view controller collaboration observer reactive subject proxy initiator subject set play display message speaker collaboration user interface audio controller examples hardware wrappers 
sound compression algorithm requirements specifies sound recorded khz bit samples 
means need kb memory storing second sound 
order reduce amount memory apply compression algorithm input signal 
chosen adaptive delta pulse code modulation adpcm compression algorithm implementation simple 
adpcm low cpu overhead 
direct memory access channels record sound audio input object needs move samples microphone audio block second 
ways perform task 
option scheduler time task 
timer activates scheduler times second scheduler activates audio input object transfers sample 
clearly cpu cycles wasted just transferring sample 
second option new timer activate directly audio input object 
case cpu usage lower considerable interrupt service routines great impact performance risc processors 
third alternative direct memory access channel 
hardware component transfer words memory positions devices cpu intervention 
design transfer samples microphone audio block audio block speaker 
unit registers control behavior 
important registers source address target address transfer count operation flags 
flags indicate things source target addresses incremented transfer transfer unit word byte 
perform transfers fast possible synchronize activity timer 
record sound program address converter source address 
target address points internal buffer set flag auto increment target address transfer 
transfer unit byte size sample 
timer programmed generate interrupt times second initiate transfer 
unit start byte transfer time timer requests interrupt 
samples recorded buffer unit generates interrupt request 
audio input attends compresses da converter microphone notify wakeup 
timer isr copies samples generating interrupt recording audio block stores input buffer block 
shows sequence messages needed record block 
sequence repeated block message 
mechanism acceptable processor compress expand audio blocks quickly 
user able hear glitch reproduction audio blocks 
problem solved optimizing transfer single audio block optimizing streaming blocks 
cpu parallel compress audio block recording 
shows mechanism 
diagram starts recording second block compressing 
design issue size audio blocks 
blocks small cpu expend significant amount time dispatching methods objects synchronizing activity 
messages composed integer number audio blocks 
length seconds size bytes message multiple length size audio blocks 
blocks big memory wasted system loses responsiveness 
constraint size blocks imposed memory manager explained 
notify buffer transfer completed buffer compression time transfer completed buffer discards buffer transfer completed recording compressed audio block length block gap memory allocation message memory responsible allocating freeing memory space store messages 
available memory quite limited system lacks virtual memory design mechanism ensures optimal system memory 
includes avoiding wasting space memory fragmentation object aligning 
message memory object created pre allocates array audio block objects 
avoid memory fragmentation pre reusing blocks creating destroying time message recorded deleted 
usually memory allocation function able allocate memory blocks aligned certain value 
size audio block object multiple alignment factor memory allocation function system ensures single byte wasted 
comments implementation consider final deliverable embedded system application source code non volatile memory containing program 
linker statically link libraries program allocate program symbols absolute memory addresses 
program include code initialize check hardware rearrange executable program ram 
includes initializing processor stack copying initialized variables read memory ram setting uninitialized variables zero 
prototype version target usually rom memory small debugger 
debugger activated system switched waits host computer upload main program communication link serial cable network connection 
program downloaded executed debugged 
software completely developed tested recorded non volatile memory 
memory inserted target replace debugger 
stand target switched executes application directly 
chosen programming language implementing system 
choosing programming language embedded system affected availability tools target architecture 
current implementation software comprises lines code lines legacy code lcd display 
software built host computer cross compiler downloaded prototype recorded rom 
code uses kb rom kb ram plus storage space sound 
implemented prototype version hardware digital sound recorder 
board includes analog components amplifier speaker microphone low pass filter 
description hardware components scope chapter uml notation 
play big role quality sound user appreciation system 
chapter origins objectives unified modeling language 
shown apply language complete case study 
case study identified analyzed designed main elements small embedded system 
uml graphical notation document artifacts design shown different types uml diagrams describe different aspects system 
summarize different kind diagrams main purpose uml 
probably popular uml diagram class diagram 
class diagram shows structure system collection classes relationships 
contrast object diagram shows instance class diagram 
build deploy binary components component deployment diagrams 
behavioral diagrams show dynamics system 
case diagrams show functionality system black box revealing internal structure 
introduced uml jacobson 
semantics analysis case diagrams main topic chapter 
interaction diagrams show different objects exchange messages order perform task 
kinds interaction diagrams sequence collaboration diagrams 
sequence diagrams focus ordering exchanged messages 
implicit time line flows top bottom diagram 
sequence diagrams similar message sequence charts graphical languages sdl 
collaboration diagrams interaction diagrams focus relationships objects 
messages include sequence numbers possible order sequence time requires reader 
uml adopted collaboration diagrams booch oose methods 
statecharts model behavior single model element reaction external events 
harel introduced statecharts quickly adopted visual formalism design concurrent reactive systems 
study uml statecharts thoroughly chapters 
activity diagrams model workflow series steps follow diagram kind problem case design detailed case class object sequence collaboration statechart activity component deployment behavioral structural structural behavioral behavioral behavioral behavioral structural structural domain model model design table classification uml diagrams order perform task operation 
data flow diagrams dfd 
table different types uml diagrams 
column table indicates diagram shows structural static view model behavioral dynamic view model 
columns indicate development artifact diagram created 
create diagram useful remainder project 
table absolute classification 
prevents type diagram stage software project 
distinction behavioral structural diagrams categorical class diagrams mainly structural diagrams describe behavior methods properly annotated 
uml includes types diagrams equally rich expressive 
think component deployment diagrams poor little activity diagrams superseded statecharts 
reducing number diagrams simplify training tools 
uml application domains situations diagrams great importance designer 
uml built best practices software engineering perfect 
language different model elements seldom confuse beginner 
uml tool needed keep source code uml models documentation text synchronized manual synchronization cumbersome unproductive 
split model diagrams size manageable maintaining consistency 
uml semantics provide mechanism ensure diagrams consistent describe system 
drawback uml way enforce design 
systematic approach translating diagrams uml design executable program 
hope designs contain uml diagrams fewer textual descriptions 
achieve need ready software patterns uml including patterns real time embedded systems 
textual descriptions just explain tailor certain software patterns build design 
uml support real time systems quite poor 
time writing ongoing effort create standard profile modeling real time systems uml 
study problem chapter propose model time uml statecharts 
model real time hybrid behaviors real time constraints audio subsystem digital sound recorder 
consider main drawback uml lack systematic method validate models 
uml tool allow create models syntactically correct formed models elements uml language 
case uml language little importance 
fact model syntactically correct mean implemented contains user requirements tries solve user problem 
rest thesis try overcome problems proposing rigorous methods study assure quality uml model 
case study describe functionality system case diagrams 
cases describe 
chapter show formalize analyze cases mathematically prove actors system achieve goals 
important case driven software process rest uml models source code created order satisfy stated case models 
case model inconsistent incomplete final software satisfy needs users 
design sound recorder uses statechart collaboration diagrams describe behavior objects 
diagrams describe expected behavior system 
chapter show statechart easily describe undesired behaviors system example deadlocks 
chapter show detected kinds errors automatically verification tool 
chapter analyzing case models contracts towel says massively useful thing hitch 
partly great practical value wrap bound cold moons beta lie brilliant sea sleep beneath stars shine desert world sail mini slow heavy river wet hand hand combat wrap round head ward avoid gaze beast stupid animal assumes see see brush wave towel emergencies distress signal course dry clean 
douglas adams hitch guide galaxy uml case diagram shows interaction system external entities called actors 
describe functionality system black box revealing internal structure 
cases describe system supposed revealing system 
uml applied case driven software engineering process 
kind process cases primary artifact capturing functional requirements establishing desired external behavior system verification validation system design implementation communication device different stakeholders project 
rational unified process catalysis examples case driven software engineering processes uml 
cases introduced jacobson developed 
time considered informal simple 
simplicity popular accessible 
case diagrams model context requirements system development 
context system defines environment system lives includes actors system 
actors entities free certain goals fulfill 
impose functional requirements system 
case diagrams considered informal contracts system actors 
actors behave described case system promises deliver functionality described case 
behaved system carry required functionality predictably reliably 
notion contract literature 
paradigm design contract contract attached class consists class invariant pre postconditions method class known example contracts software engineering 
paradigm comes program correctness checking assertions programs :10.1.1.116.2392
contract specification binding parties introduced constrain collaborations different objects 
idea developed instance 
contracts context software components 
components clients developed mutual ignorance contract common ground successful interaction 
researches studied contracts components 
take view contracts proposed back von wright 
computation involves number actors carry actions formalized contract laid advance 
contract defined contract statement 
contract statement describes ways actors modify state system 
properties contract statements state formalized refinement calculus 
provides rigorous mathematical foundation contracts tools analyze manipulate contracts 
particular contract analyzed check actor achieve specific goal contract 
state contract models problem domain system contract expresses functional requirements system 
refinement calculus notion contracts gives formal semantics uml case diagrams case models 
contracts meant replacement case diagrams currently formal complement 
cases contracts created different phases software engineering process 
cases developed analysis phase contracts intermediate step informal specification system detailed design implementation 
cases informal view functional requirements system contracts express requirements precise form 
chapter structured follows 
section review case notation example develop chapter 
section notion contracts provided refinement calculus 
formal specification case study contracts described section 
section presents analysis method propose cases applies example 
related research discussed section 
summarize main contributions chapter section 
cases cases introduced jacobson follows case sequence transactions system task yield measurable value individual actor system 
addition wrote set case descriptions specifies complete functionality system 
actor coherent role played user system 
actor certain goals fulfill system 
system described cases 
collection cases logically decomposes functionality system case involves certain requirements system 
behavior case described plain english interaction diagrams unstructured text expressions formal language layouts tables 
uml relationships actors cases represented association relationships 
different cases related generalization include extend dependencies 
shows case diagram example develop chapter 
example system managing loans library 
members library borrow books renew loans return books deadline 
fee paid book returned deadline 
fee unit day late 
members borrow book renew existing loan debts pay 
books freely available books mainly books restricted 
usually restricted books borrowed remain library premises 
special cases extended holiday librarian allow reliable members borrow restricted books 
case librarian decides possible borrow restricted books 
possible renew loan restricted book 
simplicity assume set members set books constant system 
requirements system illustrated fig 
cases 
members library librarian charge system form context system 
actors represent user roles 
member borrow book renew loan return book 
tasks include payment fee performed help librarian 
describe behavior cases library example tables tables 
section table describes aspect case 
case section shows name diagram actors section describes actors involved 
summary row gives brief description case 
precondition section describes conditions fulfilled actors attempting case 
effect case system described postcondition row 
description section contains detailed description sequence actions take place case 
exceptions row lists possible deviations behavior description row 
includes section lists cases included case described table 
heuristics describing behavior case interesting 
instance obvious determines separation precondition description case 
example borrow book book borrowed member debts library 
logical conditions stated book lent restricted 
conditions fulfilled order borrow book 
reason stated precondition section checked carrying case 
cases 
constructing cases advantages 
create cases identify different goals individual actors 
capture context system supposed live functionality required external actors 
understand problem domain candidate objects problem domain proposed solution provide model final system design checked 
private library borrow book include pay fee member include librarian include return book renew loan case diagram case borrow book actors member librarian summary member borrows book library 
precondition description member chooses book lent 
librarian updates library card member assigns member borrower book sets deadline returning book 
postcondition member successfully borrowed book 
exceptions 
member debts pay member pay see pay fee case try 

book lent 

book restricted librarian allow borrow 
includes pay fee table case borrow book case renew loan actors member librarian summary member loan book 
precondition description member chooses book borrowed 
librarian assigns new deadline returning book 
postcondition member successfully renewed loan 
exceptions 
member debts pay member pay see pay fee case try 

member borrow book 

book restricted 
includes pay fee table case renew loan case return book actors member librarian summary member returns book library 
precondition member borrowed book 
description member debts pay member pay see pay fee case 
book returned member borrower book 
postcondition member successfully returned book 
exceptions 
member borrow book 

book returned 
includes pay fee table case return book case pay fee actors member librarian summary member pays certain amount debts library 
precondition member debts library 
description member chooses certain amount debt pay 
librarian subtracts sum member debts 
postcondition member successfully paid sum 
exceptions member debts pay 
table case pay fee create informal contract users developers 
cases number shortcomings informal 
advantage development process informal requirements easily misinterpreted 
difficult impossible check system provides functionality expected actors difficult ensure actors achieve goals system 
essentially functional character uml develop object oriented systems 
missing connection control oriented case diagrams object oriented class diagrams 
missing features constitute starting point approach 
want express information captured cases precisely consistent syntax defined precise semantics regulating allowed activities actors system 
propose complement case diagrams formal contracts refinement calculus 
contracts advantages rigorous formalism 
interpretation contract unambiguous 
analyzed mathematically 
prove correctness contracts 
state space contract described terms uml class diagram 
contracts connect functional requirements system object oriented description problem domain 
main contribution chapter show uml case diagrams fig 
completely described contract refinement calculus 
show analyze contract order check actor achieve goals 
section describes contracts detail 
contracts case diagram fact informal model computation required system development 
computation carried collection actors system 
identify notions actor system uml notion agent refinement calculus formalism 
agent entity identified name free 
computation seen number agents programs modules systems users 
carry actions document specification program advance 
reasoning computation view document contract agents involved 
describe notion contract put forward back von wright 
refinement calculus higher order logic extension simply typed lambda calculus 
functions defined abstraction explicit definition naming 
example function calculates successor natural number defined 
denote application function argument 
binary relation considered function pb mapping elements sets elements world contract talks described state 
state space set possible states 
state observed collection attributes xn observed changed independently 
attribute associated non empty set values called type set attribute 
attribute takes values say type write 
consider predefined types real set non negative real numbers bool truth values date integer natural string 
attribute type really pair functions value function update function setx 
function returns value attribute state function setx returns new state specific value values attributes unchanged 
assume attributes partitioned objects 
instance attributes name name age age author title group attributes objects 
object attributes name age object attributes name age object attributes title author 
may attributes part object represent local information contract 
simplify presentation assuming constant collection objects systems model 
restriction excludes dynamic creation destruction objects 
formalism extended handle issues focus analysis cases dynamic collections objects excluded 
usual rules arrays reason dynamic collections objects 
grouping attributes objects just logical partition set attributes reason sequel state flat collection attributes 
state observed different combinations attributes 
expression function states 
evaluating expression state gives value 
expressions observe properties state 
expressions modify state assignments assignment denotes state changing function updates value value expression 
setx function maps states states assignment called state transformer 
predicates relations states 
state predicate boolean function bool state 
boolean expression expression ranges truth values bool describe predicates state 
instance boolean expression stating state 
state relation bool relates state state holds 
permit generalized assignment notation relations 
instance relates state state value greater sum values attributes unchanged 
notation generalizes ordinary assignment updates state usually performed behalf certain agent 
allowed behavior restricted contract described contract statement 
syntax contract statements follows list attributes list expressions state predicates list values agent name denotes recursion variable statement agents carry contract statement follows 
assignment statement sets simultaneously values attributes list values expressions list evaluated initial state 
assertion requirement agent satisfy state 
expresses sum values attributes state zero guaranteed agent assertion holds contract carried state unchanged 
assertion hold agent contract execution contract aborted 
non deterministic assignment contract statement permits agent choose final values related initial value final value exists agent contract 
instance contract statement agent chooses value larger current value changing values attributes 
sequential composition statement carried followed 
agent choose carrying 
agent free choose alternative 
binary choice extends directly choice finite set alternatives 
recursive contract interpreted contract statement occurrence variable statement treated recursive invocation contract 
assume recursion done behalf agent responsible termination recursion 
nontermination infinite unfolding means agent breaches contract 
programs seen special cases contracts exactly agents involved user computer system 
simple batch oriented programs choices computer system resolves internal choice manner unknown user system nondeterminism 
general contracts game interpretation 
operational semantics contract statements encodes rules game 
contract statement encodes play execution game agents involved players 
try achieve goal rules game 
agent try win game 
agent breaches contract contract aborted agents released carrying obligations stated contract statement 
easily extend simple language contracts include program constructs abort skip statements conditionals iteration 
abort statement explained abort false user 
executed means user contract releasing agents system obligations carry rest contract 
introduce contract skip leaves state unchanged 
define skip id id identity function 
conditional contract stands contract fi system system system computer system choose options 
assume agent want breach contract wants win game 
agent choose alternative guarding assertion true choosing alternative breach contract 
contract statement fi interpreted shortened form skip fi 
iteration defined terms recursion od skip fi interpretation means consider nontermination loop error user try avoid 
final extension language contracts introduce procedures 
qa 
qa stands procedure call done agent procedure declaration proc pre introduces procedure named precondition body procedure called usually agent responsible call 
procedure call interpreted agent responsible precondition satisfied entry procedure 
agent called procedure state satisfy precondition contract 
procedure precondition proc interpreted precondition true 
value variable parameters procedure calls specified keywords val var respectively procedure parameters called formal parameters substituted actual parameters way takes parameter passing mechanisms account 
preconditions verify parameters passed procedure body 
procedure requires parameters refer different objects aliasing add precondition pre 
objects structure behavior belong class 
instance objects mentioned belong class person attributes name age 
agent modify attributes belonging object invoking method object 
fig 
shows specification class denotes list public attributes declared types list initial values list operations 
initial values specified attribute init section initialization missing attribute gets arbitrary value type set 
operations class public procedures 
act attributes class parameters 
basic model classes objects describing simple case models lacks advanced features inheritance 
class classname attr init proc contract agent var proc syntax class syntax contract formal specification syntax intention formalize features uml class diagrams analyze cases 
fig 
shows specification contract stands list agents involved local attributes list procedures contract body contract 
specification forms fig 
section 
example library section show express library case model section contract 
main tasks process 
model state contract 
create class diagram describing objects involved cases 
step translate informal description behavior case series contract statements 
state contract models problem domain system graphically represented uml class diagram 
class diagram library example shown fig 

essentially need model notions system library cards books 
identification construction classes description cases 
classes relationships expressed format shown fig 

representations problem domain equivalent refinement calculus description allows behavior operations classes defined precise way 
shows attributes book 
book borrowed attribute stores deadline returning 
name book author stored attribute author 
attributes restricted status reader 
restricted stores book restricted status free lent reader denotes book fine natural restricted bool author string reader loans date class attr loans set book fine natural init loans fine class book attr date author string restricted bool status lent ree reader init status reader ree library class diagram instance library card borrow book 
initially book lent status free reader attribute value reader book 
stated init section class 
class attributes 
attribute loans stores books borrowed person 
attribute fine represents debts member pay library 
initially loans member pay 
agents involved contract member librarian 
represents actions member library models reaction computerized library system 
cases involve objects library card member book member wants borrow return 
refer specific objects card book 
creating formal contract informal case trivial task 
example show translate step step borrow book case contract 
sentence case states member chooses book lent 
model selection object set non deterministic assignment 
example agent member choose book restricted status attribute free book book restricted status free know librarian allows borrow restricted book 
specify choice binary choice statement book book restricted status free book book status free second sentence indicates assigns member borrower book states deadline returning book 
part sentence states create link book card objects 
perform assignments book reader card card loans card book update status book deadline book status lent book weeks exceptions section table states members borrow book debts pay 
group previous assignments fi statement occur debt annotated card zero card fine book reader card card loans card book book states lent book weeks fi member opportunity pay fee card fine fi define case 
statements involve borrow book case order exact sequence 
step important clear check possible exceptions normal behavior case 
example decided arrange contract follows book book restricted status free book book status free card fine fi card fine book reader card card loans card book book states lent book weeks fi contract formalizes behavior borrow book case 
large design involves cases idea encapsulate contract procedure 
idea avoid updating attributes objects directly 
create new operations classes representing state contract 
final version borrow book contract follows proc book book restricted status free book book status free card fine fi card fine book card card book fi proceed similar way formalized cases contracts 
formalize operations objects observing different cases manipulate attributes objects 
example class book attr date author string restricted bool status lent ree reader init status reader ree proc val card pre status free reader status card lent weeks proc pre status lent reader status free proc weeks proc rice var sum natural sum sum fi complete definition class book define operations set attributes book object loan performed canceled 
existing loan extended attribute modified method 
fee book computed method price fee zero deadline day day transaction 
fee computed described 
debt object modified method class 
operations properly setting attributes object loan performed canceled 
shows complete definition book class shows class 
describe main statement case allow member choose library card invoke available cases card shows complete contract library system 
local attribute contract amount cases 
main statement contract shown clause contract 
class attr loans set book fine natural init loans fine proc val book book pre book loans loans loans book proc val book book pre book loans loans loans book proc val diff integer pre fine diff fine fine diff complete definition class fine natural reader loans book restricted bool author string date price library class diagram operations contract library agent var book book card amount natural proc book book restricted status free book book status free card fine fi card fine book card card book fi proc book book restricted card loans card fine fi card fine book fi proc book book card loans book rice amount card amount card fine fi card book book proc card fine amount pay pay card fine card amount card library contract preconditions operations class constrain attributes modified values assigned attributes 
preconditions refer exclusively respective class express logical preconditions requirements cases call operations 
class descriptions domain case study specify entire functionality system contract fig 

embeds cases pictured diagram fig 
captures requirements described section 
cases involve cards books express requirement case operations classes book 
operations treat case requirement perspective correspondent class 
formal model contracts describing functionality system suits object oriented methodologies developing systems 
case diagrams created phase typical development process analysis phase 
class diagram classes specified figures cases contract fig 

artifacts belong design phase 
contract embeds case diagram class diagram precise form allowing analysis system performed 
verify actor meet goals precondition fulfill sufficient meeting goals 
aspects form subject section 
analysis contract describes precise manner information contained case diagram 
think contracts formalization case diagrams 
intend formalization prove actors goals certain case analyzing contract 
order analyze contract need define precise meaning statement need define semantics contract statements 
basic language semantics refinement calculus weakest precondition predicate transformers 
statement postcondition predicate wpa denotes weakest precondition agent achieve goal executing wpa wpa wpa wpa wpa wpa wpa wpa wpa wpa wpa basic set preconditions deduce formulas statements 
wpa abort true false wpa skip wpa fi wpa wpa wpa pb wpa wpa proc pre procedure 
procedure parameters actual values substituting formal parameters body formula weakest precondition recursive statement expressed fixpoint notation 
details definitions studied 
proving properties wp predicate transformer verify agent achieve goal certain contract 
goal modeled predicate contract contract statement 
weakest precondition determines initial states agent reach goal wpa calculates conditions fulfilled agent order achieve goal contract contract interpreted terms games 
agent achieves goal contract winning strategy establish contract matter agents behave 
example analyze conditions member library borrow book written certain author 
agent member gets library card invokes case 
agent successfully borrow book written say steven king library card book author card loans holds invoking case 
determine weakest precondition achieve goal computing wpm book author card loans obtain predicate different false shown contract member borrow new book authored steven king specific library card certain condition 
applying rules weakest predicate transformer result obtained wpm book author card loans book restricted status free author book author card loans book restricted status free interpret result way 
member perspective borrow book written certain author certain library card exist library free non restricted book written author restricted status free author 
alternative way satisfy goal book written author borrowed member executing case 
case exist free book library 
condition intended 
translating cases designing classes contract get unexpected results due errors analysis design proof 
error easy detect member forced choose book 
improved design case avoids error proc case borrow book card fine fi card fine book book restricted status free book book status free book card card book skip show detailed calculation wp revised contract fig 

figures new format performing derivations 
format structured calculational proof 
basically outline showing formulas statements avoiding parentheses sequential composition conjunction disjunction signs 
precisely predicate wp subformulas statement postcondition 
statement shown bold face formulas normal face 
subsequent lines indentation level denote sequential composition statement conjunction formulas 
disjunction formulas non deterministic choice statement preceded keywords indexed case name agent responsible choice 
conditional shown format condition implication keywords 
existentially universally quantified formulas header quantification body written subformula 
subformula indented respect parent 
format extended cover constructs language contracts 
applying weakest precondition rules revised case postcondition book author card loans structure similar initial contract obtained shown fig 

result computation simplifications shown fig 

result interpreted follows 
member perspective order borrow book written steven king exist non restricted free book library written author book restricted book status free book author 
alternatively book written respective author borrowed member executing case 
computed weakest precondition reaching goal contract agents operate 
agents said form coalition represented agent name say result computation fig 

note case possible achieve goal borrowing restricted book 
surprise member librarian allies person librarian allow member borrow restricted books 
interesting check weakest precondition reaching goal contract librarian perspective 
means compute conditions book written certain author borrowed member action 
question interesting 
librarian manage lend book steven king member wpm card fine card fine book book restricted status free orl book book status free book card card book orm skip book author card loans applying wp rules contract card fine book book book restricted book status free book card loans book author card loans book card fine book book book restricted book status free book card loans book author card loans book book author card loans weakest precondition case book book book restricted book status free book author book author card loans result weakest precondition case wpm card fine card fine book book restricted status free orm book book status free book card card book orm skip book author card loans applying wp rules contract book book book status free book author book author card loans result wp computation card fine card fine book book restricted status free orl book book status free book card card book orm skip book author card loans applying wp rules contract book author card loans librarian result wp computation member want 
result computation shown fig 
interpreted follows librarian really force member borrow book member option borrow book skip statement 
way ensure librarian goal member book 
example shown contracts means precisely describing cases connecting functional object oriented views system sections analysis tool 
computing weakest precondition agent achieve certain goal contract prove condition fulfilled corresponding agent goal achieved actors collaborate task 
computing weakest precondition different agents check system different actors initial conditions reaching certain goals actors 
formulas weakest precondition predicate transformers derivations long complex 
example derivation shown 
switching outline format easier carry derivations hand shows similarity structure contract structure computed weakest precondition 
analysis properties stated proved similar manner 
state properties invariants different classes contract 
candidate conditions invariant cardinalities relationships classes 
state invariant class book status free reader 
calculating weakest preconditions check invariants preserved contract statements 
weakest precondition semantics contract statements proves powerful tool analyzing properties system development 
related roots contracts formal expressions analyzing software consist notion assertions 
notion thought alan turing conference cambridge check large routine sense right 
programmer number definite assertions checked individually correctness program easily follows 
ideas developed floyd hoare dijkstra 
continuing direction notion contracts meyer paradigm design contract 
approach contract consists set assertions contract clauses attached class class invariant pre postconditions attached method class 
paradigm builds principle software development reliability built afterthought 
notion contracts presumes class methods equipped preconditions postconditions effect method call described statement postcondition non deterministic assignments 
add invariant class check state change induced procedure call keep invariant true 
important feature object oriented systems consists collaboration distinct objects order accomplish certain tasks goals 
feature captured helm notion contracts proposes shift class design interaction case design 
contracts specify precise manner collaborations obligations participant objects 
behavior specified contract contracts relationships refinement inclusion 
way class implementation meets obligations objects participating contract specified conformance declaration 
instantiation contracts discussed 
approach chapter resembles contracts helm emphasize collaborations agents obligations collaborations objects 
treat problem domain vocabulary constrain ways formalizing behavior uml actors captured uml cases 
approach specify cases procedures procedure calls body contract model case instances involved agents 
way contracts formal assertions specifying collaborations objects 
methodology di refers entire software development process language framework 
logical language expressed terms temporal logic formulas denotes properties requirements system model oriented language expressed synchronized petri nets describes models implementations system 
contract expressed terms logical properties added model oriented specification describes essential properties 
software development process evolves new models derived previous ones refinement contracts 
order new model correct refinement old contract attached old model refined contract attached new model 
approach resembles approach contracts emphasis refinement 
intend contracts stepwise refined correct implementation system basic methods refinement calculus 
evolution contract done verifying certain conditions relate old new contract 
conditions expressed framework refinement calculus contracts 
particular weakest precondition mechanism refining contracts analyzing contrast language framework 
contracts software engineering terms context component software 
components specified interfaces provided clients 
contracts specify obligations component providers meet expectations component clients may 
specify component services offers components services requires components 
services usually specified contracts parts 
reuse contracts extension lamping specialization clauses defined developed enhanced interface descriptions sets collaborating participant components 
hierarchies components contracts defined order check component behavior 
feature important due late integration components 
context component unknown integrity satisfy high standards 
differentiating basic behavioral synchronization quality service contracts helps improving integrity components 
method designing contract components 
method proposes regard contracts stereotyped uml interfaces extended protocols modeling coordination synchronization aspects design phase 
uml interfaces specify interaction steps protocols describe supported interaction orders 
approach notion contracts similar describe active behavior components contrast purpose uml interfaces 
formalization structure uml cases discussed authors show analyze cases 
ocl textual language part uml standard constrain behavior uml elements 
unfortunately ocl specifications capture interaction actors expressive contracts 
chapter analysis method uml cases 
analysis method notion contract understood formal specification behavior uml case 
interpretation contract terms weakest precondition operator unambiguous 
intention enhance informal case diagrams providing contracts formal counterpart 
contract rigorous analyzable description case diagram case diagram diagrammatic representation contract 
shown approach functional object oriented views system integrated analyzed uniform way goals agents preconditions cases described terms objects problem domain 
importantly shown analyze case diagrams 
particular check system provide functionality described cases 
formal approach proposed especially helpful development systems correctness central concern 
contract intermediate document informal specifications case diagram design artifacts class diagram final program 
novelty approach fact contract allows analysis implementation analysis ways program potential users agents 
fact contracts look programs easier programmers preciseness contracts allows rigorous analysis properties 
chapter statecharts statechart describes behavior model element changes internal state result receiving external stimuli 
statecharts introduced david harel quickly adopted visual notation design concurrent reactive systems 
statecharts concept finite state machine notation includes new features hierarchical concurrent states model complex behaviors concisely 
uml includes variant statecharts behavioral diagrams 
uml terminology statechart graphical representation state machine 
uml state machine describe behavior classifier class behavioral feature example operation class 
statechart associated classifier defines life instances creation destruction 
statechart associated operation describes execution operation 
uml notation statecharts semantics state machines described 
semantics context slightly misleading uml semantics natural language uml 
clearly possible analyze uml model containing statecharts concrete detailed semantics 
chapter discuss formalization uml state machines precise semantics statecharts compatible uml metamodel 
develop semantic interpretation verification tool believe description needed model implementing tools code generation simulation analysis uml statecharts 
formalization consists parts formalization structure state machines formalization semantics 
important reasons presenting semantics way 
model elements composing statechart syntactic sugar explained terms simpler elements 
possible define different semantics different application domains structure statecharts 
chapter semantics state machines discrete systems chapter extension semantics suitable real time hybrid systems 
important issue defining semantics uml statecharts define actions guards 
contrast harel statecharts uml define standard language guards actions 
chapter just assume languages exist semantics defined independently semantics statecharts 
require language guards free side effects subset language actions 
consider different application domains may require different action languages definitions independent definitions statecharts 
proceed follows 
section shows formalization structure state machines section discusses dynamics 
section discusses collaboration objects defined statecharts 
related section 
structure state machines uml statechart diagram represents hierarchical state machine 
hierarchical state machine includes composite states contain states creating tree structure 
child state active parent state active 
composite states contain orthogonal regions 
orthogonal regions directly composite state active container state active 
allows model concurrent behaviors states active simultaneously 
hierarchical states orthogonal regions simplify representation large state machine simpler statechart visual elements 
state configuration assume state machine sm 
set states state machine partitioned disjoint sets composite states cs simple states ss final states fs history states cs ss fs 
states marked initial 
call set initial states subset 
final history states usually names graphical representation shall default naming scheme ps psn example statechart fs 
composite state contains states orthogonal regions 
assume composite state contains states machine 
call state top state 
state state machine may entry exit activity action associated 
shall assume defined language la requirement language actions la include skip action 
concepts discussed detail context operational semantics 
state machine represented running example 
sets ss cs fs ps 
top state machine state configuration current state uml state machine defined tree states starting single top state root individual simple states leaves 
state called state configuration 
encode state configurations terms signature interpret sets cs ss fs operator symbols 
arity composite state defined number orthogonal regions contained 
arity state composite state 
example arity countable set variables th 

set symbols form set linear terms smallest set satisfying standby power power mode radio cd mode history states 
ss fs 
op tn op cs arity op tn 
var condition restricts set terms variable occurs 
define state configuration state machine sm term 
called set linear ground terms simply denoted 
shall term shorthand linear term 
need set symbols symb term 
mode tape symb iff ss fs symb sn symb si history states allow return previous configuration composite state 
history states special attributes 
deep attribute indicates state deep shallow history state 
deep history states remember active configuration composite state nested substates shallow history states remember states directly composite state 
stores transition taken event previous history information history state 
shows statechart containing history state 
statechart describes operation modes home stereo 
modes cd player tape radio 
initially stereo switched turned pressing power button 
case stereo return previous mode history state 
information previous state default transition select cd state 
history states absolutely necessary 
obtain behavior introducing new simple states act history information 
example shows equivalent statechart home stereo system standby power power power power mode radio power cd mode power mode tape replacing history states history states 
statechart contains states transitions probably difficult understand 
find pattern features statechart 
example possible remove orthogonal state performing regions 
cause explosion number model elements statechart affect legibility model 
transitions transition uml state machine consists elements source originating state vertex target target state vertex trigger event fires transition guard predicate true order fire transition 
defined language predicates lp effect optional action performed transition fires 
defined language actions la state machines communicate sending events 
shall assume global set events set trigger events state machine sm union trigger events appearing transitions state machine 
uml standard allows transitions 
transitions called completion transitions implicit trigger completion event generated transition entry actions activities currently active state completed 
completion events create hc ps translation state machine 
special priority events implemented semantics assigning special completion trigger transitions 
set completion trigger events ec set events state machine esm ec 
shows transition trigger emanating state labelled hc example 
discuss generation completion events detail 
shall assume completion transitions labelled corresponding completion event 
define transition follows transition tuple source target states event trigger lp guard la action execute firing transition 
set transitions state machine denoted 
assume define projections source target trigger guard effect notation transitions usually represent guard true action skip 
shows encoding transitions example 
transition associated initialization state machine explained 
completion transition completion event hc trigger mark fact fired activities state finished 
notation states hierarchical relationship states explicit 
fact lives orthogonal component explicit fact variable appears left hand side right hand side position 
means firing change state component orthogonal region 
definition state machine summarize different elements compose state machine assume language describing actions la language describing predicates lp set events uml state machine tuple activity deep source target trigger guard effect set states state machine 
entry action associated state function la exit action function la activity activity function la deferred set deferred events default transition history state deep state deep history bool set transitions esm lp la source left projection target right projection trigger trigger event guard guard transition lp default guard true effect action side effect transition function la uml standard defines initial join vertices fork vertices junctions 
vertices statechart typically connect multiple transitions complex state transition paths 
extensions uml state machine syntax primitive constructs rich express desired behavior 
turns formalization allows directly express constructs extensions 
give explicit translation features just indicate directly expressed formalization 
initial states treat initial states requiring transitions go boundary composite states translated way explicitly initial state 
example see transitions 
initial states initialization state machine 
translation assume top state active add special transition called initial transition 
initial transition goes top state machine initial configuration 
uml standard trigger initial transition create call event context statechart classifier 
statechart behavioral feature operation initial transition triggered invocation feature 
shows creation transition example transition 
join fork vertices join vertex merge transitions emanating source vertices different orthogonal regions causing execution synchronize fork vertices serve split incoming transition transitions terminating orthogonal target vertices 
join fork vertices translated making source target vertices explicit translation 
example 
junction vertices generalization join fork vertices number transitions may enter exit vertex 
transitions may contain guards 
deal junction vertices explicitly translated simpler constructs logically combining optional guards transitions cf 

dynamics state machines section attempt formalize informal description execution semantics statecharts section 
assume statechart describe behavior classifier 
execution semantics uml state machine defined terms hypothetical machine key components event queue holds incoming event instances dispatched event dispatch mechanism selecting de queueing event instances event queue event processor processes dispatched events 
translation join fork vertices object execute algorithm run completion rtc step dispatches executes events event queue top state generates completion event state machine finishes 
standard define semantics input queue stated kinds events completion events priority 
shall implement event queue data type operations enqueue element element dequeue queue 
priority elements dequeued queue 
denote empty queue 
main task event processor find transitions enabled fired event queue 
set transitions grouped step 
transitions step executed sequence event processor consider event queue transitions step fired 
calculation step need determine transitions source term matches current state configuration 
call transitions active active source substitution called mode transition auxiliary function mode denote 
pair called transition instance translation junction vertices example lets assume active configuration statechart shown 
case transition active exists substitution source state transition equals active state configuration 
example mode 
definitions determine conflicts transitions section 
event dequeued called current event 
current event need find transitions active trigger matches guard evaluates true 
transition enabled current event matches trigger guard holds enabled trigger guard set transitions enabled current event denoted function enabled 
current event clear context write enabled 
conflicts transitions uml state machine enabled state conflict iff intersection set states corresponding transition instances exit non empty 
example transitions conflict state transition instance transition instance state exit simple state define conflict relation need calculate set states exited firing transition instance 
assume transition enabled state mode 
set states exited set states entered firing mode exit symb symb entry symb history symb iff sn si conflict operation enabled transitions defined conflict exit mode exit mode transitions conflict iff conflict 
transitions conflict conflict transitions conflict transitions conflict state resolve conflict help priority relation 
uml standard defines priority transition source state 
transition source transition source direct transitively nested substate higher priority state configuration priority difference 
intuition give priority transitions start lower hierarchy 
example conflict resolved favor starts border clearly higher hierarchy hand conflict resolved start states substates 
relation direct transitively nested substate translated notion covering terms cover covers iff find substitution allows transform example source state covers state source substituting transform 
hand look conflict see covers term covers term conflict resolved 
relation priority denoted cover cover 
define static priority relation transitions running example current state current event transitions enabled conflict 
covers fire 
hand resolve conflict 
define rule calculating step transitions fire state assuming current event state set conflict enabled set transition instances conflict set transitions ordered relation resolve conflicts priority 
denote set conflicting transition instances priority conflict 
formally conflict conflict conflict conflict conflict set fireable transition instances obtained deleting transitions fire priority relation fireable enabled conflict step maximal conflict free set transitions fireable conflict fireable conflict run completion step idea run completion step ensure event dequeued dispatched previous current event fully completed 
configuration state machine step computed sequential composition nextstate function defined nextstate mode target mathematical tools proceed give version algorithm implements run completion step defined uml semantics 
algorithm shown 
version wait event arrive queue calculate enabled transitions execute step 
transitions enabled step empty implements implicit consumption semantics mandated uml semantics 
uml semantics defines number notions overlooked previous discussion 
include different actions associated state entry actions exit actions activities different events completion events deferred events call events time events internal transitions history states 
full rtc algorithm 
rtc algorithm loop executed top state state machine completed 
shall discuss extensions individually 
state actions activities completion events state entered entry action executed prior action 
analogously state exited exit action executed final step leaving state 
case nested states entry actions executed outside entry action outermost state executed 
exit actions executed opposite order 
state may include activity 
action forked concurrent task just entry action completed 
true queue queue dequeue enabled enabled select step def 
newstate newstate nextstate newstate execute effect newstate version run completion step activity continues executing object remains state 
assume action executed activity generation completion event 
event priority added input queue operation 
state associated activity exited activity ends activity aborted exit action executed 
case completion event generated 
completion events generated subregions composite state reach final state 
formalize condition function finished finished cs symb cs fs execution step check subregions reached final state push corresponding completion event front queue 
start rtc loop top state finished 
deferred events usually event enable transition discarded 
useful keep event waiting state 
event called deferred event 
define set events individual state machine 
set events state configuration union events active states 
modify transition selection mechanism necessarily discard current event 
current event enable transitions rtc finished top queue dequeue enabled enabled enabled deferred enqueue select step def 
newstate exit outside order composite state history state completion event history configuration deep history exit inside order abort activity execute newstate nextstate newstate execute effect effect method call wait return corresponding call event entry outside order execute start activity call event send return event newstate subregion reached final state push corresponding completion event front queue enabled queue enabled call event protocol statechart send return event final version run completion step belongs events current state configuration pushed special list main loop run 
loop insert deferred event back input queue 
fired event changed object state 
go infinite loop deferred event enable events put input queue dispatch 
check condition testing set enabled nonempty 
internal transitions state may number internal transitions transitions source target state 
definitions entry exit functions firing internal transition cause exit entry actions executed cause state activity restarted 
history states history information history state stored attribute named history 
updated time composite state containing history state exited 
exited completion transition history information reset default history 
store current configuration state history attribute 
definition entry special case handle history states transition leading history state enters states history 
call events final touch rtc step treatment call events lines lines 
call events special events represent synchronous invocation specific operation 
call event generated method call action 
standard explicit assumed call event corresponding return event 
level single state machine method call executed action transition step completed invoked objects complete run completion steps 
line caller waits method calls 
line callee finished rtc step send corresponding return events 
uml semantics define implicit consumption events fire transition 
uml semantics special rule concerning call events statechart describing protocol 
protocol statechart describes states acceptable invoke operation classifier describe outcome operations 
case event consumed implicitly caller continue operation 
implement behavior rtc algorithm lines rtc loop 
model elements model elements directly supported semantics chapter synch states choice points 
synch state state incoming arrows region outgoing arrows orthogonal region 
synch state belongs common ancestor source target regions 
synch state associated attribute named bound 
attribute defined uml semantics maximal difference number times incoming outgoing transitions synch state fire 
positive integer unlimited bound 
synch states elementary model elements include rtc algorithm 
approach presents problems 
exposition explaining feature seldom 
second unbound synch states definition infinite state space verified model checker 
chapter prefer consider synch special state just simple state special entry exit actions 
define synch state attributes count bound 
entry action associated state counts min counts bounds 
outgoing transitions synch state guarded condition counts exit action state counts counts 
exact definition actions depends action language 
model element supported directly choice point 
choice point introduces intermediate edge transition actions decisions taken firing transition 
formalization choice points require macro micro steps rtc algorithm 
complicates implementation algorithm know states exit enter firing transition finish firing 
interaction diagrams previous sections studied semantics single statechart 
non trivial designs interested studying interaction statecharts precisely interaction model elements behavior described statechart 
simplify exposition assume statechart describes behavior object 
assume object interaction diagram runs process 
process instance run completion step scheduled asynchronously 
objects communicate sending events links 
events directed single specific object broadcast events object object role role collaboration objects events sent environment 
link introduce arbitrary delays transmitting event lose events 
main design decision semantics interaction diagrams consider atomic step rtc algorithm 
ideally step rtc algorithm atomic call events require synchronization processes 
chosen split rtc algorithm atomic blocks 
block contains lines deals selection transitions exiting current states 
second block contains lines deals execution action 
third block contains lines deals executing entry actions 
particular comments semantics point problematic situations may arise due way uml standard decided interpret orthogonality 
example concerns situation 
objects object object linked shown 
assume object receives event enables transitions orthogonal region corresponding effects executed 
order execution orthogonal region rtc step defined sequential object object able distinguish different implementations behavior 
example order execution behavior fires left transition machine behavior state result case state result 
problem may arise uses orthogonality synonym concurrency 
important distinction orthogonality concurrency true concurrent system able observe interleavings orthogonality observe 
interestingly places uml state machines differ substantially harel statecharts 
harel statecharts events generated step available receiver time problem occur 
may cause confusion users harel statecharts model may contain implicit dependencies order evaluation extremely difficult find simulation 
fortunately possible detect situation verification tool 
second example concerns call events 
circular chain behavior role role behavior result result machine able observe execution order behavior behavior role role machine deadlock call events object back object may block 
trivial case situation object wants execute call action 
illustrate complex situation consider example 
assume object object receives event triggers sending call event object sends call event back event acted second orthogonal region semantics uml forbids deadlock 
solution problem interpret rtc step recursively instantiate concurrent instances rtc loop orthogonal region 
call finish system block 
point actions contain side effects allowed change attributes object orthogonal regions may necessarily independent interact local attributes 
related chapter proposed formalization structure behavior uml state machines 
formalization attempts clarify ambiguities definition statecharts uml specification 
foundation construction tools code generation animation verification uml statecharts 
uml statecharts classical statecharts harel include additions object oriented variant statecharts defined room modeling language 
important realize uml statecharts substantially different dynamics harel statecharts uml events queued dispatched 
events carry parameters 
negated events transition fired event dispatched 
zero time assumption event wait queue undefined amount time processed 
transitions different orthogonal regions fired sequentially 
changes allow statecharts describe behavior objects systems facilitate implementation statechart designs software 
semantics statecharts proposed literature example statemate semantics proposed harel compositional semantics smolka pnueli shalev approaches focused verification levi :10.1.1.126.4135
concerned defining semantics harel statecharts statemate tool 
point view interesting compare 
authors discuss formalization uml state machines takes hierarchical automata basis 
authors ignore particular features uml state machines 
section vuml tool model checking uml models formalization statecharts 
vuml tool spin model checker 
sara formalization thesis verification uml state machines 
implemented verification component implements semantics acf framework 
chapter verification collaborations statecharts statecharts expressive concise notation describing behavior reactive objects 
previous chapter studied structure dynamics statecharts formalization behavior completion algorithm 
apply knowledge construction methods tools analyzing behavior objects collaborations objects defined statecharts 
statechart defines behavior single object single behavioral feature object 
uml model complex systems collaboration objects 
behavior object defined independently different uml diagram 
collaboration model concurrent systems containing active objects 
active object thread control evolves independently objects 
tools logix automatically generate complete implementation collaborations objects defined statecharts java programming languages 
uml models statecharts highly descriptive easy understand uml models verified may exhibit behaviors expected designer 
propose model checker verify exhaustively collaborations objects behavior described statecharts 
model checker tool automatically searches complete set states model incorrect behavior 
model checking cf 
survey successfully applied large industrial verification projects 
verifying uml model ensure software free design errors implementing 
chapter vuml realization tool 
target user tool designer object oriented software systems 
main goal vuml automatic easy possible 
try achieve hiding inner workings tool designer 
internally tool uses spin model checker holzmann perform verification 
designer know spin promela language 
model checking customary kind temporal logic describe properties verify 
vuml take alternative approach 
vuml tool introduces new stereotypes constraints describe behaviors satisfied model 
designer uses stereotypes add extra information design tool extract properties verified 
new stereotypes part uml standard introduced allow designer describe safety liveness requirements having learn temporal logics 
shows normal session vuml 
creating model designer invokes vuml verify 
tool automatically converts uml model promela specification invokes spin 
verification performed spin interaction designer 
verification fails generates counter example shows reproduce error model 
vuml converts counter example new uml sequence diagram 
designer study diagram fix error verify model 
model correct designer try introduce new correctness requirements model verify confident model 
proceed follows 
section shows model concurrent systems uml introduces new stereotypes model correctness requirements 
section explain vuml tool works demonstrate case study section 
discuss related chapter section 
modeling concurrent systems statecharts section show model concurrent distributed objectoriented systems uml 
basic uml element modeling concurrent systems active object 
active object maintains thread control runs concurrently active objects 
example simple concurrent model discuss standard example dining philosophers 
class diagram philosophers forks 
philosophers eat think usual pick forks left right starting eat 
philosopher user requirements uml editor uml counter example uml model specification generator error analyser vuml modelling verification manual modeling step designer automatic verification step performed tool vuml promela model spin model checker promela counter example class marked active objects instantiated class run concurrently 
example statechart diagram describe behavior instances fork shown 
behavior fork object different states available fork table taken fork hand philosopher 
fork reacts call events get release 
call events synchronous caller blocked consumed receiver 
behavior fork object follows fork dispatches get event available state switches taken state 
fork active eat think right left fork get release class diagram dining philosophers thinking left release available get release left get taken defer get right get releasing eating right release behavior forks top philosophers bottom switch back available state dispatches release event 
get event received fork taken event deferred 
placed special queue dispatched fork available 
diagram right shows behavior philosopher class 
philosopher initially thinking state 
finished thinking completion transition fires philosopher attempts get left fork 
completion transition transition trigger fired activity associated source state completed 
section contains detailed description call events deferred events completion transitions 
describing properties model goal vuml tool automatic transparent designer possible 
designer add extra information design tool extract temporal properties verify 
vuml tool uses new stereotypes define behavioral constraints satisfied model progress invalid stereotypes 
stereotypes part uml standard may help designer introduce safety liveness requirements model complex formula temporal logic 
meaning stereotypes follows state mark invalid interpreted linear temporal logic ltl formula square symbol read previous formula read 
progress stereotype interpreted 
diamond read eventually 
formula read object eventually state eventually different state 
example consider error model philosopher tries release fork taken 
model condition adding transition invalid state shown leftmost diagram 
introduce liveness requirement philosopher eat infinitely times marking eating state progress state 
possible define constraint class association classes 
constraint class usually called class invariant restricts behavior instances class 
constraint association restricts combined behavior objects linked 
constraints predicates attributes states instances class 
constraint syntax constraint constraint thinking left release releasing available release invalid released get release left get right release taken defer get right get progress eating temporal requirements embedded statecharts active eat think philosopher eating right taken right philosopher eating left taken left fork get release class diagram dining philosophers constraints constraint constraint constraint constraint constraint constraint constraint role state expression expression expression expression expression expression role attribute number constraint form role state true state state active object associated role role 
expression form role attribute evaluated current value attribute object associated role role 
constraint interpreted ltl formula verification 
example constrain philosopher fork classes requiring philosopher state eating left right fork taken 
constraints shown associations classes 
implications trivially true eating state progress state eventually active 
collaboration objects uml statechart describes behavior objects created class create objects 
collaboration diagram create link objects model 
objects collaboration diagram interact exchanging messages 
message displayed link source target object 
sequence numbers order messages chronologically 
john philosopher sara philosopher right fork fork left fork fork left right right fork fork left dinner anna philosopher left fork fork right peter philosopher shows collaboration diagram philosophers sharing forks 
objects initial state messages exchanged 
objects collaboration diagram reside processor different nodes distributed system 
modify interpretation collaboration diagram semantics assumption concerning speed links processors 
easy determine messages exchanged order active objects appear collaboration diagram 
collaboration diagram show behaviors system exclude possible behaviors expected designer 
example philosopher class designed carefully intentionally careless objects collaboration diagram easily arrive deadlock objects progress 
shows collaboration diagram derived philosopher holds left fork waiting right fork available 
behavior described state machines happen philosophers arrived deadlock 
section describe vuml tool uses spin capture kinds errors model 
john philosopher left get anna philosopher left get sara philosopher right fork fork left fork fork left right right fork fork left left get left get left fork fork right peter philosopher sara move dinner suddenly vuml tool basically vuml model generator front spin model checker 
tool semantic formalization previous chapter 
vuml spin impose restrictions analyzable uml models 
vuml tool promela language actions guards constraints uml models 
activities supported tool generated completion events associated activities 
class may define set attributes type attributes restricted integer 
restriction imposed spin 
designer attributes sparingly increase memory needed verification 
tool supports signals call events deferred events completion events 
events may parameters type parameters restricted integer 
dispatching event actual parameters copied local variables process parameters share properties attributes object 
order reduce size verification problem tool assumes communication queues fixed size event dispatching policy fifo 
time events supported 
time events constraints implementation model 
information performance final system estimate time event occur 
simple timeout transition emulated completion transition 
case activity state acts timer 
activity completed timeout transition fires 
open models models need external stimuli proceed task 
external events generated class actor collaboration diagram 
model activity carried state 
case model generate completion event associated activity 
states may refined composite state designer deems necessary 
open models react messages sent external model elements directly verified model checker 
vuml convert open model closed external event instances needed external events carry parameters 
vuml determines source event defined model creates event generator events 
model contain information generation events event generator nondeterministic 
vuml automatically discards events directed missing link 
example philosopher state machine fig 
completion transitions activities associated completion transitions described 
model open specify completion events generated 
event generator generates events trying reveal error model 
key characteristics event generator eventually produces event send event object event trigger transition 
constraint ensures model deadlock event generator decided send event object 
second constraint introduced speed verification 
defined semantics state object change object receives unexpected event 
sending events fire transition reduce verification problem avoid possible livelock situation event generator floods object unexpected events 
event generator handle external events carrying parameters 
event generator events create state space explosion verification 
models kind event verified directly vuml 
structure promela model section explain structure promela models generated vuml tool 
assume reader familiar promela language 
promela non deterministic language loosely dijkstra guarded command language notation 
includes basic data types input output operations hoare csp language 
basic syntax promela similar syntax programming language 
vuml maps uml class promela process type 
instance process type process uml object collaboration diagram mapped promela process 
promela processes run concurrently scheduled nondeterministically 
achieve semantics collaboration diagrams described section atomic statement ensures promela block executed atomically 
promela models generated vuml tools include print statements describing behavior model 
print statements ignored spin performing verification 
interpreted simulation reconstructing counter example 
way vuml trace activity model generate counter examples knowing internals spin 
process variables store active configuration statechart attributes object internal variables calculate rtc step 
promela object oriented language store variables global arrays 
arrays indexed unique object id integer passed parameter promela process 
possible store state object local variables process 
encapsulation mechanism promela prevent implementing constraints objects 
define orthogonal region composite state different variable storing state configuration 
states encoded binary size state variables byte 
arrangement works best statecharts states state containers composite states orthogonal regions 
statecharts states container better bit fields store state configuration 
current implementation constraints translated promela share syntax semantics promela expressions 
constraint refer state statechart attribute object uml name 
case tool silently translates uml name corresponding internal representation promela model 
example philosophers define array bytes store active configuration fork objects 
name state variables created concatenation class name container name suffix st actual promela code follows define max inst fork byte fork top st max inst fork define constants enumerate different events transitions state names order improve readability generated code 
example define constants define event get define event release constants class fork define fork trans define fork trans define fork state available define fork state taken define variable orthogonal region store transition selected firing 
fire transitions step fire transition orthogonal region 
enumerate transitions encode binary 
consider top state region 
selection variables string fire suffix byte fork top fire max inst fork selection top region process variable store current input event parameters attributes represented object 
variables external event generator deferred event queue explained 
parameter process type object id index arrays containing state object 
parameters channel receive input events channel synchronization mechanism call events 
proctype fork byte id chan input chan xr input promela optimization local variables byte event current event chan cb parameters current event bit rtc bit defer current event queue deferred events action promela process execute initial transition 
initial transitions objects executed sequentially arbitrary order 
process waits uml objects initialized proceeding run completion step 
fork object initial transition enters available states 
atomic zero transition selection variables fork top fire id enter top enter available fork top st id fork state available printf vuml state fork available id wait objects constructed proper run completion step divided parts obtaining current event selecting transitions fire firing transitions dealing special cases deferred events completion transitions 
mechanism obtain current event varies depending statechart reacts external events 
statechart react external event obtain current event just reading input queue 
statechart contains transitions fired external events set flag variables indicating fire transition event queue external event 
promela create non deterministic statement input event parameters event event 
event en fi en external events flag indicating transition fired internal event flag indicates transition fired external event ei 
flags updated accordingly step fires transition 
selection mechanism definitions previous chapter 
vuml resolves static priorities transitions generating code 
example promela code implements selection transitions fork statechart selection transition event event get fork top st id fork state available fork top fire id fork trans fi selection transition event event release fork top st id fork state taken fork top fire id fork trans fi transitions selected fired sequentially 
effect transition send call event process blocked receiver consumes event 
objects synchronized rendez vous channel passed parameter call event copied variable named cb 
code implements firing transitions fork 
action includes print statements indicate call event dispatched fork object id state machine changes new state 
fire transition fork top fire id fork trans printf vuml rc fork get id cb cb return call event enter taken fork top st id fork state taken printf vuml state fork taken id fi fire transition example necessary separate selection firing fork top fire id fork trans printf vuml rc fork release id cb cb return call event enter available fork top st id fork state available printf vuml state fork available id fi separate selection transitions firing process actions associated transitions entered exited states affect guards enabled transitions 
example consider statechart shown 
states active equals event transitions fired step uml semantics 
transitions modifies value guard second transition holds event dispatched false middle step 
step states active equal independently order firing transitions 
strategies implement behavior option split step phases shown 
alternative perform selection firing step temporary variables store attributes modified actions 
example transitions modify temporary copy named 
step temporary variables copied actual attributes 
split selection actual firing need extra variable store selection orthogonal region 
temporary variable method need double amount space store attributes plus linear time increment update attributes 
alternatives increase size state vector promela model optimal approach varies model model 
fire transition current event check defer 
promela model know selected transition selection variables equal constant 
case check current states defers current event 
checks positive place deferred event promela channel list 
fire transitions current step channel containing deferred events empty put back contents input channel process processed iteration rtc loop 
verification spin generating promela model vuml invokes spin model checker perform verification 
mechanisms introduce correctness requirements spin claims hold times verification process assertions checked process executes assert statement 
vuml implement correctness requirements uml models spin claims process assertions 
vuml requirements temporal propositions states uml statecharts promela model implementing rtc step statechart 
distinction important constraints involving objects 
case constraint may hold objects executing run completion step hold objects stable state 
spin detected error types uml model deadlocks reaching invalid state constraint violations sending event terminated object queue overruns livelocks 
deadlocks deadlock produced possible dispatch event object 
error detected automatically spin model checker promela model 
reaching invalid state verification fail state machine reaches invalid state 
implement condition promela false assertion entry action state 
constraint violations constraint predicate attributes active configurations set objects 
constraint implemented promela assertion evaluated run completion step objects involved 
sending event terminated object error send events terminated object 
catch error adding code classname input printf vuml id assert promela process jumps section code top state ends 
statement blocks process event received input queue object 
case assert statement evaluated verification fail 
input queue overrun object finite input queue 
sending event full queue produces error 
models need bigger queue sizes default provided tool 
size queues defined parameter invoking vuml 
increasing size queues consider error concealing livelock 
queue overruns detected automatically spin promela model 
defer event queue overrun object finite input queue store deferred events 
queue full verification fails 
error occurs machine blocked state defers events 
livelocks object contains livelock states marked progress stereotype visited infinitely normal execution model 
check error implemented progress label spin 
tool check kinds errors simultaneously livelocks 
looking livelocks report kinds errors 
representation counter examples verification model fails spin finds previous errors model 
case spin generates error trace showing reproduce error 
error trace contains output generated print statements model 
vuml analyzes lines contain prefix vuml order reconstruct activity statechart represent counter example uml sequence diagram 
tool uses collaboration diagram starting point verification uses sequence diagram representing counter example explicitly show time dimension 
sequence diagrams easier understand collaboration diagrams large number messages exchanged 
graphical front spin generates sequence diagrams error traces 
unfortunately spin sequence diagrams reflect activity promela model containing uml model run step 
counter examples generated larger difficult understand ones generated vuml 
vuml window showing counter example shows example error vuml 
tool verify collaboration diagram dining philosophers example deadlock situation described 
diagram shows requests getting right forks granted queued late processing 
diagram philosopher objects blocked 
example infinite number sequence diagrams lead deadlock 
shown shortest generated special command line invoking tool 
new icons showing sequence diagram event deferred dispatched 
icons defined uml standard 
deferring event internal operation state machine necessary know happens order understand sequence diagrams 
shows new icons relative position sequence diagram 
example production cell section describe larger example model verify concurrent system vuml 
studied system production cell dispatching deferred event deferring event icons showing event deferred dispatched deposit belt feed belt robot arm arm elevating table top view production cell press standard example evaluating methodologies designing embedded systems 
top view production cell 
model includes machines coordinated order forge metal blanks 
machines avoid dropping blanks floor colliding 
conveyor belt feeds blanks rotary table 
table rotates lifts blanks picked robot 
robot arms feeding press blanks extract forged blanks press 
robot arm place forged blank deposit belt arm carries new blank press 
loading pressing unloading robot press active forge unloaded modeling press active engine class diagram press decided model central element system press 
task press forge metal blanks 
mobile part press initially middle position robot places blank press 
press loaded press moves upwards blank forged moves downwards unloading position 
robot gets forged piece cycle starts 
represents steps graphically 
decided split model press parts plant controller 
elements represented classes 
class diagram press 
factory similar presses modeled object instances classes 
instances active objects 
shows statechart diagram controller press 
pressing forge plant engine loading enter plant engine robot going middle plant engine unloaded plant controller press going bottom plant engine progress unloading enter robot action performed controller enter loading state 
entry action associated state 
time controller enters state action executed 
case informs robot press ready loaded 
robot places new blank press sends forge event press controller 
forge event trigger transition loading state pressing state 
press dispatches forge event leaves loading state enters pressing state 
transition contains action commands plant start engine lift press 
pressing state exited mobile part press arrives top 
controller switches state commands engines go 
mobile part bottom press controller enters unloading state 
stops engine signals robot indicate press ready unloaded 
forged blank robot sends unloaded event press move loading position 
adding user requirements model unloading state marked progress stereotype 
time machine processed piece controller enters state 
stereotype indicates fact object unit 
press fed unlimited amount blanks controller enter exit unloading state infinite amount times 
engine engine engine ctrl engine engine ctrl engine ctrl engine engine ctrl engine model plant press invalid invalid shows model plant press 
plant receives event mobile part start moving eventually enter state 
mobile part top position engine receives event press break moving plate past physical limit 
modeled state marked invalid stereotype 
stereotype capture safety requirement invalid state entered 
complete requirement press class unloading unloading 
ensure press right position load unload phases avoid collision robot arms 
property involves objects press robot state constraint link 
formulate requirement constraint ctrl loading ctrl unloading 
simple collaboration diagram showing instance press controller plant 
shows collaboration initial state objects exchanged messages 
vuml press collaboration diagram tool automatically generate possible evolutions collaboration diagram check model holds safety liveness requirements introduced 
active objects 
means thread control evolves independently asynchronously objects collaboration delays communication dispatching event 
example state dispatches event state machine switch state send event instantaneously 
exist arbitrary delay communication event 
delay represents inter object communication synchronization 
event queue arbitrary delay event dispatched 
delay produced events queue simply receiver scheduled execution 
asynchronous behavior acceptable designer synchronous call events inter object communication 
important note collaboration diagram include object representing robot 
press controller sends link named robot expects forge unload events links 
modeled robot 
model open 
vuml tool detects condition creates event generator forge unloaded events 
allows verify composition press controller plant abstracting robot 
modeling robot complex object production cell robot 
robot controller coordinate execution activity objects model 
observe fig 
controller robot controller press synchronize operation loading unloading phases order avoid collision 
normal design requirement models containing active objects evolve independently 
synchronize activity objects call events deferred events 
press sends event robot indicate effectively press ready unloaded 
robot unloading table unloading press loading deposit belt loading press behavior robot controller process request press piece table event deferred 
robot coordinate activity table deposit conveyor belt 
shows statechart diagram describing behavior controller robot 
divided main composite states corresponding main tasks robot described 
composite state refined substates 
controller robot starts unloading table state 
immediately entering state enters moving state robot rotates arm points table 
activity inside composite state reaches final state completion transition fires object leaves composite state 
case robot leave unloading table state enter unloading press 
verification show statechart representing behavior table conveyor belt conceptually similar ones representing press robot 
complete model open model object modeling feed belt expects reception environment event 
event indicates arrival new metal blank production cell 
safety requirement states moving enter plant turn right retracting arm arm retracted plant arm table unloaded moving enter plant turn left retracting arm arm retracted plant arm press unloaded plant turn left unloading table defer plant turn arm extended plant plant arm retract unloading press defer plant turn arm extended plant plant arm retract waiting table plant arm extend extending arm waiting press unloading plant arm extend extending arm detailed behavior robot controller moving enter plant turn left retracting arm arm retracted plant arm belt loaded moving enter plant turn left retracting arm arm retracted plant arm press forge loading deposit belt defer plant turn arm extended plant plant arm retract loading press defer plant turn arm extended plant plant arm retract waiting belt plant arm extend extending arm waiting press loading plant arm extend extending arm detailed behavior robot controller cont 
model states memory time press safety mb press livelocks mb complete safety mb table performance vuml tool metal blank conveyor belt maximum 
verify model vuml event generator generate events feed belt accept empty 
verify complete model looking safety properties 
table shows memory time verification 
measures collected pentium ii computer running mhz mb ram partial order reductions optimized code generation 
moment able verify complete model livelocks state space explosion 
related chapter methodology verify collaborations statecharts prototype tool supporting methodology 
tool formalization uml statecharts previous chapter 
discussed case study show viability approach need tool vuml clear 
section seen semantics uml state machines non trivial 
manual conversion uml models promela specification state formalisms petri nets difficult cumbersome error prone task 
requires deep knowledge uml model checker 
vuml designer need know prepare input model interpret counter examples produced model checker 
evaluation tool important aspects consider evaluating verification tool notation express models tool fits design process different correctness requirements verified computational resources needed perform verification 
notation vuml uses uml input language models 
behavior objects model described graphically uml state chart diagrams 
uml standard accepted expect designers familiar uml formalisms promela petri nets communicating automata 
vuml uses promela language describing guards actions standard syntax elements uml 
design process uml models describe software construction 
vuml tool able verify open models environment completely specified objects contain states 
feature allows designer vuml tool design process 
vuml iterative incremental design process model constructed verified continuously complete correct 
verification process automatic repeated times needed little effort designer 
vuml large projects 
easy split large model different diagrams verify model parts assuming environment sends expected events 
possible object oriented semantics uml state machines vuml option close automatically model 
verification designer include constraints define safety properties model 
vuml checks model violations constraints different kinds errors including deadlocks livelocks 
vuml directly support linear temporal logic formulas 
spin supports ltl properties express ltl formula uml diagram open problem 
order keep model checking process transparent possible designer decided verify ltl formulas version tool 
ocl constraints vuml model 
requires complete formalization ocl language translation promela 
performance verification models containing uml features call events deferred events completion transitions increases complexity specification resources needed verification 
problem introduced semantics uml vuml 
spin excellent model checker process model completely different uml statecharts model 
run completion step uml class coded promela 
spin verify model run completion step 
promela model uses auxiliary variables increase size state vector 
vuml tool development 
currently tool uses proprietary input format uml models plan support standard xmi format 
urgent development point reduction state space 
want study generation efficient promela models 
interested improve representation counter examples uml 
exploring ways show internal external activity object diagram methods automatically group counter examples lead error 
furthermore looking possibility filtering events counter example contribute error 
related find interesting contributions production cell case study 
think uml notation cases intuitive scales better graphical formalisms notion hierarchy petri nets 
uml design partitioned classes behavior class represented hierarchy states sub behaviors 
think helps designer create understand large designs 
compared chapter uml approach completely graphical verification model automatic 
combine approaches model system uml verify vuml translate statecharts specification refined executable program 
tools similar vuml 
tool verifying statecharts uses spin model checker 
statemate semantics statecharts verify uml statecharts 
furthermore verifies single statechart vuml verifies collaboration objects 
possible compare performance vuml directly results reflect differences code generated tools differences uml harel statecharts 
chapter real time hybrid behavior statecharts answer orange oranges lose oranges lemon left huh ok think time flows way 
interesting douglas adams harmless hybrid systems model continuous processes controlled discrete computations 
useful study systems computer supervises controls physical phenomenon real world movement elevator chemical plant 
processes evolve real time state best represented continuous mathematical equations discrete data types 
uml general purpose modeling language facilities modeling real time hybrid systems standard uml 
possible extend existing uml diagrams purpose 
tool vendors proposed extensions language ongoing effort create standard profile modeling real time systems uml 
chapter show extension uml statecharts model real time hybrid phenomena 
think key missing element uml defined model time behavioral diagrams sequence collaboration activity statechart diagrams 
new general formalism analyze real time continuous behavior statecharts 
call formalism continuous action systems previous discrete action systems 
action systems successfully model discrete systems systems discrete control discrete state space 
original purpose model concurrent distributed systems 
sections show action system model easily adapted model hybrid systems including hybrid statecharts 
important advantage adaptation standard proof techniques developed ordinary action systems reused reason hybrid statecharts 
model hybrid systems new approach describe state system 
essentially attributes range functions time just values 
allows attribute capture value history values attribute default values attribute receive 
updating attribute restricted behavior changed past behavior 
continuous action systems inspired differ extension action systems hybrid systems described 
proofs action system properties refinement calculus 
action systems intended stepwise development correctness refinement steps verified refinement calculus 
get implicit notion refinement continuous action systems 
refinement hybrid systems scope thesis approach adopt hybrid systems fits refinement calculus framework systems correctness central concern 
proceed follows 
introduce notion hybrid statechart section 
action system model briefly described section 
continuous action systems described section 
semantics defined explaining translate ordinary action systems 
section shows represent hybrid statecharts continuous action systems 
section show proof safety properties 
comparisons related section 
hybrid statecharts section introduce notion hybrid statechart diagram modeling hybrid behavior 
define hybrid statechart statechart containing continuous attributes 
continuous attribute attribute classifier stores function time 
represents continuous behavior de time 
example model balance saving account function time 
law defining balance constant value changes day month 
function defining continuous attribute constant function obtain usual behavior attribute 
continuous attributes significant element hybrid statechart evaluated guard transition updated effect transition action related statechart example entering exiting state 
important uses continuous attributes define activities clocks 
continuous attribute clock measure passage time 
clock reset effect transition entry exit actions state 
clocks evaluated guards transitions model real time behaviors guard hold time unit clock reset 
convenience designer assume state statechart clock named ins measures long state active 
state active value associated clock undefined 
continuous attributes associated activities 
notion activity standard concept uml definition 
activity performed object state 
starts object enters state stops machine leaves state 
continuous activity activity defined tuple continuous attributes 
example state continuous activity model variation temperature attribute 
heating activity temperature activity states continuous attribute temperature set initial value increase linearly rate state heating active 
temperature function time instant obtain different value attribute 
model real time hybrid behavior combining clocks continuous activities statechart 
example diagram 
initially state active clock reset attribute follow value clock 
machine state instant guard transition true 
instant change event fire transition machine switch state start decreasing function 
enter reset clock activity activity hybrid statechart saw represent values attributes time diagram 
fig 
shows attribute time domain points time transition fired 
final states statechart evolution attributes continues forever 
sections continuous action system formalism explain behavior hybrid statecharts precise way 
action systems start giving brief overview action systems formalism 
action system essentially collection attributes updated discrete control mechanism 
define finite set attr attribute names 
attribute attr type really pair functions value function update function setx 
function returns value attribute state function setx returns new state specific value values attributes unchanged 
attribute system explained detail section 
action system consists finite set attributes finite set actions act attributes 
set actions models control clock evolution hybrid statechart saw mechanism system 
action system form var am od xn local attributes system statement initializes attributes ai gi si actions system 
gi known guard action ai si body action 
attributes yk defined environment action system 
say imported attributes 
attributes may exported sense read written read written environment actions 
case decorate respectively 
action form guarded statement executed loop od enabled evaluates actions executed loop long enabled actions 
loop just dijkstra guarded iteration statement 
guard action just ordinary boolean expression 
body statement defined simple syntax abort skip fi list attributes corresponding list expressions list logical variables standing unknown values relation specified terms intuitively skip stuttering action isa multiple assignment fi conditional composition statements sequential composition statements 
relation list attributes denote non deterministic assignment value effect abort ifr 
action abort fails model disallowed behaviors 
semantics actions language defined terms weakest preconditions similar way language contracts page 
case agent game user system need denote agent calculating wp transformer 
predicate define wp abort wp skip wp wp wp wp wp wp fi wp wp fi stands substitution free occurrences attribute predicate execution action system follows 
initialization set attributes specific values sequence possibly nondeterministic assignments 
initialization actions may enabled chosen executed 
chosen actions change values attributes way determined action body 
actions enabled time case chosen execution nondeterministic way 
computation terminates action enabled 
termination action system means termination control system means fixing final values attributes forever 
actions systems model parallel execution interleaving atomic actions nondeterministic fashion 
action system usually regarded isolation part complex system 
rest system environment communicates action system shared imported exported attributes referred global attributes 
model means communication action systems framework 
large action system constructed smaller ones parallel composition 
define parallel composition action systems var gm sm od var od action system defined var gm sm od assume attributes disjointed 
initializations may refer respective attributes order initializations executed matter 
imported attributes union attributes imported component action systems exported attributes systems 
actions union actions component systems 
section extend action system formalism adding notion time show model attributes functions time 
extensions formalism define new model hybrid systems 
continuous action systems continuous action system consists finite set time dependent attributes range discrete continuous value domains finite set actions act attributes 
form var real gm sm od intuitively execution continuous action system proceeds follows 
implicit attribute shows time 
initially 
initialization assigns initial time functions attributes xn 
time functions describe default behavior attributes values may change progress time 
system start evolving functions time measured moving forward continuously 
guards actions may refer value may expressions action bodies initialization statements 
soon conditions gm true system chooses enabled actions say gi si execution 
choice nondeterministic action 
body si action executed 
execution atomic instantaneous 
usually change attributes changing behavior 
attributes changed behave 
changes stipulated si saw var clock real real real bool clock od continuous action system saw system evolve time instance actions enabled process repeated 
time instance action enabled may previous time need progress execution enabled actions 
usually case system doing discrete logical computation determine proceed 
computation take time 
possible certain time instance actions enabled anymore 
just means time instance system continue evolve forever functions assigned attributes 
example continuous action system consider system fig 

write assignment emphasize behavior attribute changed function past behavior unchanged 
system behavior statechart fig 

initialization statement corresponds initial transition statechart actions correspond transitions states 
explain translate statechart action system section 
main advantages model hybrid computation discrete continuous behavior described way 
particular attributes assigned constant functions obtain discrete computation 
semantics continuous action systems continuous action system 
explain meaning translating ordinary action system 
semantic interpretation action system explicit model time var real real gm sm od attribute declared initialized updated explicitly 
models time moments interest system starting time succeeding moments action enabled 
value updated statement gg gg gm disjunction guards actions defined min gg gg gg 
function models moments time action enabled 
moments behavior attributes modified 
action enabled second branch definition followed attribute denote moment time discrete action executed 
case discrete control terminates attributes evolve forever functions assigned 
assume minimum definition exists guard enabled 
continuous action systems satisfy requirement considered ill defined 
minimum definition calculated strict inequalities time dependent guards 
system ill defined 
bad update defined var real real od fi instance consider update clock 
clock clock clock clock clock fi clock clock fi behavior clock changed assignment 
important note attributes continuous action system functions time 
example statement updates default increasing function updates constant function 
explanation continuous action system means essentially collection time functions xn non negative reals defined stepwise manner 
steps form sequence intervals interval ik left closed interval form ti ti closed interval form ti ti point 
action system determines family functions xn stepwise defined sequence intervals points 
extremes intervals correspond control points system digital discrete action performed 
example fig 
sequence intervals 
continuous action system best understood limit sequence approximations time functions xn defined successively longer longer intervals ti 
looking example way sequence initial segments 
approximations defined successively attribute defined history past interval value point default 
execution action modify value attribute default past 
important note definition necessarily determine single function attribute xi 
non deterministic choices involved collection function tuples allowed continuous action system know system follows 
system behavior may determined certain tolerance system behavior limits possible 
important observation regards possibility zeno behavior 
definition guarantee sequence generated intervals cover non negative reals 
cover initial segment 
case limit point time action system reaches number iterations reaches infinity 
systems defined simple explication behavior hybrid system sufficient 
case assume system restarted limit point repeat process 
meaningful attribute values converge defined value limit 
restart carried times needed 
continuous action system may multiple limit points execution 
standard action system semantics allow multiple limit points point semantics really extended 
simplicity assume sequel zeno behavior single limit point sufficient 
absence zeno behavior means action system define values attributes domain real 
simple way reaching limit point control computation time advance terminate 
means continuous behavior system stuck time instance reached 
nontermination control computation certainly undesired unintended 
means prove control computations time advance terminate 
systems differential equations behavior dynamic system described system differential equations 
allow kind definition introducing shorthand assign time function satisfies differential equation function continuous example constant value reader find complete model differential equations including proofs safety properties 
real time systems clocks timers measure passage time correlate execution action time 
clock attribute attribute measures time elapsed set zero 
assume attribute type real 
definition resetting clock reset clock just regular attribute define clocks need reset independently 
possible arithmetic operations clocks time constraints guards refer past values attribute hold time unit holds 
composition continuous action systems order model complex systems different subsystems components evolve concurrently need formally define composition continuous action systems 
actions systems communicate means shared variables 
cases may need hide certain attributes component describing complex systems ignore aspect brevity 
define parallel composition continuous systems essentially method composing ordinary action systems 
continuous action systems var real gm sm od var real od parallel composition continuous action system defined var real real gm sm od assume attributes disjoint 
need combine continuous action systems translate discrete action systems local attribute appears combining continuous action systems ensure combined system uses single variable checked actions components 
parallel composition essentially combines attributes component systems continuous evolution 
actions parallel composition combined actions systems discrete changes usually occur frequently 
note action system may depend attribute system may modified actions system 
means behavior system parallel composition usually different behavior system 
statecharts continuous action systems section show translate hybrid statecharts continuous action systems 
translation objectives give formal unambiguous semantics hybrid statecharts allow mechanical analysis safety properties hybrid statecharts 
translation definitions chapter 
order simplify exposition translation basic model elements statechart notation 
reuse definitions structure statecharts chapter need update dynamics statecharts include notion continuous attributes 
mentioned main components defining dynamics statechart event queue dispatching mechanism run completion step 
chapter model run completion step continuous action system 
main reason event queue dispatching mechanism discrete components benefit approach 
assume language define guards actions statechart language action systems 
difference statecharts program notation functions temp action systems lambda calculus notation temp 
steps translation hybrid statechart continuous action system 
encode attributes states statechart attributes action system 
second define initialization statement action system 
initialization statement models initial transition statechart 
translate transition statechart corresponding action 
translation obtain continuous action system describes behavior hybrid statechart analyzed mechanically 
encoding attributes events states map concepts clocks continuous attributes statechart directly attribute model continuous action system 
attribute type statechart define attribute action system name type real update statement assign new values attributes 
need special attribute keep event dispatched machine 
imported attribute defined dispatching mechanism 
type real set possible events machine 
events dispatched interested current event event 
need special attributes keep active state configuration statechart 
section actual representation state configuration defining functions manipulate active enter leave 
active function evaluates true state active enter function adds state active configuration leave removes state 
main strategies encoding states statechart 
option single attribute stores state configuration active 
statechart contains hierarchical states orthogonal regions definition active enter leave functions trivial 
main advantage approach representation state compact 
reduces memory needed tool represents state model explicitly model checker animation tool 
possible definition state handling functions hierarchical states follows active enter leave state state state constant indicate state active statechart represented variable state 
occurs transition observable 
approach boolean attribute state 
way state statechart attribute real bool 
case operations states trivial say state active expression true 
entering state means setting attribute true leaving state means setting attribute false 
active enter leave approach suitable theorem proving tool reasoning states reduced reason simple boolean expressions 
transitions translate transition statechart different action 
assuming transition gt translate action ga sa 
guard action ga conjunction conditions needed fire transition source states active active symb current event matches trigger event event change event check change condition holds 
guard transition holds gt holds 
conflict transition higher static priority 
transition translated action fire guard action association hold body action sa perform steps described lines rtc algorithm see fig 

activity defined continuous attributes assigning constant function current value activity non deterministic function 
reset clocks associated entering states 
initialization statement initialization statement represents initial transitions statecharts 
defines behavior machine time instant action fired 
carry steps add initial states active state configuration 
execute entry actions initial states 
start activities initial states 
translation hybrid statechart continuous action system elaborate process resolve priorities transitions statically 
translation performed automatically tool guards actions statechart language action systems user provides suitable set functions encode state configuration 
section presents example translate hybrid statechart continuous action system 
examples saw statechart 
translated action system fig 
previous template 
transitions saw statechart triggered change event need add attribute keep current event 
interesting example press production cell 
previous chapter discrete model press fig 

model identified stable positions plate press plate bottom middle top travel 
model real movement plate switched state instantaneously 
chapter want model actual movement plate want prove controller force movement plate bounds 
press works follows 
initially lower part middle position 
robot feeds metal blank press sends forge event vertical position top middle bottom vertical position press press 
lower part press raised top position blank forged 
press move bottom position forged blank retrieved robot 
press unloaded signaled unloaded event lower part raised middle position ready loaded 
statechart describing behavior press continuous attributes 
previous chapter different objects model controller plant press 
design single hybrid statechart describing behavior continuous movement plate discrete control 
hybrid statechart similar statechart discrete controller addition continuous attribute model vertical position plate 
translate hybrid statechart press continuous action system shown previous pattern 
please note transitions fired dispatching external events forge unloaded fired change events 
shows refinement press action system replaced functions handling states concrete version 
decided single attribute named state keep active configuration statechart 
hierarchical orthogonal states set reset state configuration just assigning constant representing state state attribute 
removed consecutive assignments state variable body action 
refinement rule states assignments reduced single assignment occur free 
discuss refinement action systems thesis reader find complete discussion topic 
section show prove safety properties con pressing activity middle forge loading enter middle middle going middle activity bottom unloaded top going bottom activity top bottom unloading hybrid statechart press press var real real inp real real real real reset middle enter loading active loading event forge leave loading reset inp middle inp enter pressing active pressing top leave pressing reset top enter active bottom leave reset bottom enter unloading active unloading unloaded leave unloading reset bottom enter active middle leave reset middle enter loading od event version press continuous action system 
press var real real inp real real real real state real loading pressing unloading reset middle state loading state loading event forge reset inp middle inp state pressing state pressing top reset top state state bottom reset bottom state unloading state unloading unloaded reset bottom state state middle reset middle state loading od event final version press continuous action system 
action systems corresponding representation hybrid statecharts 
safety properties prove property continuous action system proving property holds corresponding discrete action system 
special proof theory continuous action systems standard proof theory action systems suffices exception may need consider multiple limit points mentioned earlier 
chapter concentrate safety properties cases kinds properties want establish initially hybrid systems 
common characterization safety property bad happens lifetime system 
put way safety property property holds establish property action system proving property invariant corresponding discrete action system 
implies safety property provided system zeno behavior go infinity system 
means safety property hold system started initial state satisfies conditions satisfied wp gi wp si proving safety press consider example press 
want study safety properties 
want prove movable plate press pass limits machine 
formally expressed bottom top vertical position plate 
proofs assume bottom middle top 
second want prove continuous function real 
need choose invariant allows establish safety property bottom top continuous real proof rule 
conjunct safety property invariant form bottom top sufficient 
prove global continuity property need stronger invariant ensures press remains correct position loading unloading states 
invariant sufficient establishing required safety property bottom top state loading middle state unloading bottom proof establish invariant satisfied initialization moment moment action enabled time elapsed execution actions 
show prove initialization statement establishes invariant 
main calculating weakest precondition invariant way avoids formula large 
applying simplifications intermediate state possible 
wp reset middle state loading substitute gg wp reset middle state loading min state loading forge state pressing top state bottom state unloading unloaded state middle continuous bottom top state loading middle state unloading bottom wp rule sequential composition splitting ranges predicate calculus wp reset middle min loading loading forge loading pressing top loading bottom loading unloading unloaded loading middle continuous bottom top state loading middle loading loading middle state unloading bottom loading unloading bottom predicate calculus wp reset middle min forge continuous bottom top state loading middle middle state unloading bottom wp rule sequential composition update wp reset min forge middle continuous bottom top bottom middle top state loading middle middle middle state unloading bottom bottom middle top assumption model predicate calculus wp reset min forge middle continuous bottom top state loading middle state unloading bottom definition update wp wp reset min forge middle fi continuous bottom top state loading middle state unloading bottom appear postcondition wp rule assignment min forge middle fi continuous bottom top state loading middle state unloading bottom assume predicate calculus min forge middle continuous middle constant function continuous step proof assumes minimum exists 
event forge eventually true 
assume system non zeno established means 
proof shows invariant satisfied initialization moment moment action enabled 
proving initialization system consider system behaves correctly execution action 
compute weakest precondition action assuming invariant system guard action hold 
proof action follows 
continuous bottom top state loading middle state unloading bottom state loading forge wp reset inp middle inp state pressing substitute gg wp rule sequential composition wp reset inp middle inp wp state pressing min state loading forge state pressing top state bottom state unloading unloaded state middle continuous bottom top state loading middle state unloading bottom wp rule sequential composition splitting ranges predicate calculus wp reset inp middle inp min pressing loading forge pressing pressing top pressing bottom pressing unloading unloaded pressing middle continuous bottom top state loading middle pressing loading middle state unloading bottom pressing unloading bottom predicate calculus wp rule seq 
composition wp reset inp wp middle inp min top continuous bottom top state loading middle state unloading bottom invariant assumption wp reset inp wp middle inp min top continuous bottom top rule update wp reset inp min middle inp top middle inp continuous bottom top bottom top invariant assumption wp reset inp min middle inp top middle inp continuous bottom top reset inp inp min middle top middle fi continuous bottom middle top computing min function min middle top assumption top middle top middle top middle middle fi continuous bottom middle top point rule middle fi top middle continuous top middle bottom middle top assumptions bottom middle top real analysis properties middle fi top middle continuous 
middle limt middle show proofs actions follow similar pattern proofs far 
related definition uml include facilities modeling real time hybrid systems 
time writing text open request proposals profile scheduling performance time uml 
proposed submission enumerates new model elements define precise semantics new elements 
chapter shown simple extension language allows model real time hybrid behaviors statecharts 
think necessary add new model elements icons model concepts uml define dynamics existing model elements including precise model time 
formal methods models describe hybrid systems attracted quite lot attention years number different models formalisms proposed literature see :10.1.1.48.8089
concept hybrid statechart introduced pnueli 
pnueli model hybrid statecharts statecharts harel formalized phase transition systems 
activities represented statechart combined single activity phase transition system 
formalized hybrid statecharts introducing notion continuous action systems 
attributes continuous action systems functions time updated way changes behavior 
essentially amounts extending notion state history default generalizing classical action systems approach handles state 
extension allows model systems combine discrete control continuous behavior defined explicit functions time differential equations 
shown prove safety properties continuous action systems classical invariant method 
shown continuous action system model provides simple way defining parallel composition hybrid systems communication means shared variables 
reader find elaborated case study continuous action systems 
idea extending existing formalism model real time systems introducing variable representing time abadi lamport 
follow approach extending existing formalism handle hybrid systems creating new formalism specific systems 
provides clear advantage apply previous results action systems study real time hybrid models 
ravn proposed model combining action systems continuous behavior called hybrid action systems 
model continuous evolution variable modeled special kind atomic action 
atomic action interrupted bounds specified advance 
affects parallel composition systems different simultaneous actions combined sequence atomic actions 
worst case parallel composition systems actions leads system actions 
implicit notion time approach intended modeling real time systems 
model parallel composition systems gives continuous action system actions 
advantages exist comparing formalism hybrid automaton 
number states parallel composition hybrid automata product number states original automata 
note hybrid automata formalism transitions fired synchronously action system formalism actions selected executed asynchronously 
continuous action system formalism allows explicit failure system modeled abort statement allows historical values attributes guards expressions 
compared hybrid automata model allows attributes selectively updated attributes changed need mentioned action 
translation statecharts continuous actions systems trade expressiveness tool support 
previous chapter seen model checker verify collaboration objects defined statecharts 
model checker allows study joint behavior objects easily practical limitations description attributes objects 
chapter seen analyze statecharts complex attributes including attributes ranging infinite types 
allows model complex dynamic behaviors prevents automatic model checker verify models 
remedy situation partially theorem prover support higher order logic theory real numbers isabelle perform proofs mechanically 
solution restrict model hybrid statecharts analyzed tool hybrid automata hytech 
chapter thesis different methods analyzing uml models refinement calculus model checking 
uml models created software development process diagrams describing design system fair level detail long start implementing software 
methods analyze assure quality models detect design errors line code written 
topics software quality correctness validation heavily studied computer science community exist methods enable creation software correct construction verify satisfies correctness requirements 
methods require starting point formal specification software 
unfortunately software developers familiar formal specification languages willing learn 
software development teams constrained deadlines lack qualified personnel see useful specification language directly build software 
situation changing advent widespread usage uml mature graphical languages sdl 
currently modeling languages part undergraduate courses software engineering software developers constructing software models just task perform everyday software development process 
software models precise comparable software specifications 
challenge show transform model expressed graphical modeling language software specification expressed formal language explain benefits doing 
find precise mapping subset modeling language formal specification language fact promoting models written language formal specifications 
specifications analyzed proven correct wrong mathematical computer tools supporting specification method 
thesis tackles challenge shows transform cases statecharts formal specifications shows formalization allows analyze models 
main problem face formalizing language uml validate 
precise formalization uml useless formal semantics differ considerably intuitive understanding uml community language 
formalization cover feature language 
approach problem create non trivial examples explain allow uml designer validate 
validation hands final user case uml community 
tried formalize diagrams model elements uml language single formal language 
focus behavioral diagrams consider aspect uml studied 
chosen diagrams consider key describing behavior uml model 
case diagrams behavioral diagrams show system black box point view system 
statechart diagrams consider single object model white box describe internal behavior full detail 
formalize diagrams different formal methods refinement calculus model checking 
refinement calculus contract language suited describing cases behavior actors incorporate concept free formalism 
model checking tools allow analyze automatically statecharts diagrams 
surprise uml statecharts model checking tools founded concept finite state machine 
model checking tools limited size state space model 
shown refinement calculus model analyze real time hybrid behaviors statecharts intractable model checking tool 
case purpose formalization clear allow analysis uml models 
show weakest precondition predicate transformer case model prove actor achieve goal system 
give formal semantics uml state machines show model checker tool verify simple temporal properties models 
propose model time statecharts show prove safety properties models 
hope analysis methods contribute improve quality uml models 
uml large language study tion goes effort single person research team 
reason chosen different formalisms 
expect long run different verification validation methods tools different subsets dialects uml different formalisms 
uml designer free choose method methods better suit model problem needs solved 
thesis refrained extending uml proposing new model elements situations unavoidable 
add new stereotypes represent temporal properties statecharts proposed concept continuous actions model real time hybrid actions statecharts 
addition allows express temporal properties simple way 
second addition covers big deficiencies uml support real time hybrid systems 
cases give precise explanation new model elements rigorous formalism 
plan continue line research 
want continue moving modeling languages formal methods intention allowing average software developer profit vast research results produced formal methods community 
step provide automation tool support possible knowledge needed analyze models embedded software tool installed workstation uml designer 
bibliography abadi lamport 
old fashioned recipe real time 
acm transactions programming languages systems 
alur courcoubetis henzinger ho 
hybrid automata algorithmic approach specification verification hybrid systems 
grossman nerode rischel editors hybrid systems volume lecture notes computer science pages 
springer verlag 
ziegler 
octopus object oriented technology real time systems 
prentice hall 
back 
correctness preserving program refinements proof theory applications 
mathematical centre tracts vol 
mathematical centre amsterdam 
back 
modeling verifying temperature control system hybrid action systems 
proc 
th int 
workshop formal methods industrial critical systems 
back grundy von wright 
structured calculational proof 
technical report turku center computer science november 
back kurki 
decentralization process nets centralized control 
nd symp 
principles distributed computing volume lecture notes computer science pages 
acm sigact sigops 
back petre 
analysing uml cases contracts 
france rumpe editors uml unified modeling language 
standard 
second international conference fort collins usa october 
proceedings volume lecture notes computer science 
springer 
back 
stepwise refinement parallel algorithms 
science computer programming pages 
back 
action systems modular systems 
formal methods europe fme volume lecture notes computer science pages 
springer verlag 
back von wright 
doing high school mathematics carefully 
technical report turku center computer science november 
back von wright 
refinement calculus systematic 
springer verlag 
back von wright 
contracts games refinement 
technical report turku centre computer science november 
plouzeau watkins 
making components contract aware 
ieee computer 
boehm 
spiral model software development enhancement 
ieee computer 
booch 
describing software design ada 
sigplan notices september 
booch 
object oriented design 
ada letters march april 
booch 
object oriented development 
ieee transactions software engineering se february 
booch rumbaugh jacobson 
unified modelling language user guide 
addison wesley 
branicky 
general hybrid dynamical systems modeling analysis control 
alur henzinger sontag editors hybrid systems iii volume lecture notes computer science pages 
springer verlag 
jonsson 
tutorial object oriented software engineering 
tutorial notes oopsla 
tony clark 
type checking uml static diagrams 
france rumpe editors uml unified modeling language 
standard 
second international conference fort collins usa october 
proceedings volume lecture notes computer science pages 
springer 
clarke kurshan 
computer aided verification 
ieee spectrum 
coad yourdon 
object oriented analysis 
yourdon press prentice hall 
coleman contributor arnold contributor 
object oriented development fusion method 
prentice hall 
cook kleppe mitchell rumpe warmer wills 
defining uml family members 
ieee editor tools 
dahl nygaard 
simula 
technical report oslo 
damm hansen thomsen 
creative object oriented modelling support intuition flexibility collaboration case tools 
elisa bertino editor ecoop object oriented programming number lecture notes computer science pages 
dijkstra 
discipline programming 
prentice hall international 
douglass 
real time uml developing efficient objects embedded system 
addison wesley 
souza alan wills 
objects components frameworks uml catalysis approach 
addison wesley 
rumbaugh object oriented modeling design 
prentice hall 
floyd 
assigning meanings programs 
proceedings american mathematical society symposium applied mathematics volume pages 
fowler 
refactoring improving design existing code 
addison wesley object technology series 
france petrie 
exploring semantics uml type structures bowman derrick editors proc 
nd ifip conf 
formal methods open object distributed systems 
chapman hall london 
di 
formal development validation java dependable distributed systems 
proceedings fifth ieee international conference engineering complex computer systems 
gamma helm johnson vlissides 
design patterns 
addison wesley 

structured systems analysis 
prentice hall 
gibbs 
software chronic crisis 
scientific american pages september 

contract component system design 
proceedings hicss rd hawai international conference systems sciences 
ieee press 
goldberg kay 
smalltalk instruction manual 
xerox parc 
harel 
statecharts visual formalism complex systems 
science computer programming june 
harel 
visual formalism 
communications acm 
harel naamad 
statemate semantics statecharts 
acm transactions software engineering methodology oct 
henzinger ho wong toi 
hytech model checker hybrid systems 
software tools technology transfer 
hoare 
axiomatic basis computer programming 
communications acm 
hoare 
emperor old clothes turing award lecture 
communications acm pages 
holzmann 
design validation computer protocols 
prentice hall englewood cliffs 
holzmann 
model checker spin 
ieee transactions software engineering vol 
may 
de hondt lucas steyaert 
reuse contracts component interface description 
proceedings second international workshop component oriented programming number tucs general publications pages 
turku centre computer science 
international telecommunication union 
recommendation bits sample embedded adaptative differential pulse code modulation adpcm 
itu 
itu recommendation specification description language sdl 
itu geneva 
itu ts 
itu ts recommendation message sequence chart msc 
itu ts geneva september 
jacobson 
object oriented development industrial environment 
proceedings oopsla special issue sigplan notices volume pages 
jacobson jonsson 
object oriented software engineering case driven approach 
addison wesley 
jacobson ericsson jacobson 
object advantage business process reengineering object technology 
addison wesley 
soon carrington 
formalizing uml class diagram object 
france rumpe editors uml unified modeling language 
standard 
second international conference fort collins usa october 
proceedings volume lecture notes computer science pages 
springer 
soon carrington 
integrated framework uml object developing precise specification 
proceedings 
ieee computer society 
kent evans rumpe eds 
uml semantics faq 
available www univ pau fr oopsla pdf 
kesten manna pnueli 
verification clocked hybrid systems 
lectures embedded systems volume lecture notes computer science pages 
springer verlag 

modeling components frameworks uml 
communications acm october 

rational unified process 
addison wesley 
lamping 
typing specialization interface 
proceedings oop sla pages 
acm sigplan notices 
diego 
formal operational semantics uml statechart diagrams 
rd international conference formal methods open object oriented distributed systems boston 
kluwer academic publishers 
levi 
verification temporal real time properties statecharts 
phd thesis university pisa genoa udine pisa italy 
lewerentz lindner 
formal development reactive systems case study production cell volume lecture notes computer science 
springer verlag 
lilius sara 
analyzer component framework 
aiken cs abo fi acf 
lilius 
semantics uml state machines 
technical report turku centre computer science 
hitachi hitachi single chip risc microcomputer sh sh hardware manual 
hitachi 
hitachi sh programming manual 
hitachi 
de marco 
structured analysis systems specifications 
yourdon 
meyer 
object oriented software construction 
prentice hall second edition edition 

model checking statecharts 
www informatik uni kiel de erm 
lakhnech siegel 
hierarchical automata model statecharts 
rd asian computing science conference asian volume lecture notes computer science pages berlin 
springer 
lakhnech siegel holzmann 
implementing statecharts promela spin 
workshop industrial strength formal specifications techniques boca raton fl usa 
ieee computer society press 
nerode kohn 
models hybrid systems automata topologies controllability observability 
grossman nerode rischel editors hybrid systems volume lecture notes computer science pages 
springer verlag 
omg 
omg unified language specification 
version march available www omg org 

formal approach cases 
uml international workshop notation lecture notes computer science pages 
springer verlag 
paulson 
isabelle manual 
university cambridge computer laboratory 
www tum de 
pnueli 
temporal logic programs 
proceedings th ieee symposium 
foundations computer science pages pp 

pnueli shalev 
step semantics statecharts 
theoretical aspects computer science volume lecture notes computer science berlin 
springer verlag 
holland helm 
contracts specifying behavioral compositions object oriented systems 
proceedings oopsla ecoop pages 
acm sigplan notices 
richters gogolla 
validating uml models ocl constraints 
evans kent editors proc 
rd int 
conf 
unified modeling language uml 
springer 
robbins redmiles hilbert 
software architecture critics argo 
international conference intelligent user interfaces san francisco ca usa january 
ravn 
action systems continuous behaviour 
antsaklis kohn nerode sastry editors hybrid systems volume lecture notes computer science pages 
springer verlag 

refinement continuous behaviour 
hybrid systems computation control volume lecture notes computer science pages 
springer verlag 
rosenberg scott 
case driven object modelling uml 
object technology 
addison wesley 
sara 
verification component uml state machines 
master thesis department computer science 
abo university april 
stark 
reliable object oriented software 
sigs 
editors 
program development refinement 
springer verlag 
selic ward 
real time object oriented modeling 
john wiley sons new york 
mellor 
object oriented systems analysis modelling data 
computer series 
yourdon press englewood cliffs nj 
smith 
uml formalization transformation 
phd thesis northeastern university college engineering usa december 
software 
uml profile scheduling performance time 
available www omg org uml 
szyperski 
component software object oriented programming 
addison wesley 
smolka 
compositional semantics statecharts labeled transition systems 
jonsson parrow editors con cur concurrency theory number lecture notes computer science uppsala sweden 
springer verlag 
valmari 
stubborn attack state 
proc 
nd workshop computer aided verification volume lecture notes computer science pages 
springer 
valmari 
state space explosion problem 
advances petri nets 
springer verlag 
van den berg verhoef 
formal specication auctioning system vdm uml 
fitzgerald larsen editors vdm practice 
van der schumacher 
hybrid dynamical systems volume lecture notes control information sciences 
springer verlag 
von wright 
program refinement theorem prover 
th refinement workshop london lecture notes computer science 
springer verlag 
warmer kleppe 
object constraint language precise modeling uml 
addison wesley 

inheritance contracts object composition 
proceedings second international workshop component oriented programming number tucs general publications pages 
turku centre computer science 

