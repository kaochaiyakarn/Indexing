random subsets build scalable network services rodriguez albrecht amin vahdat argue broad range large scale network services benefit scalable mechanism delivering state random subset global participants 
key approach ensuring membership subset changes periodically uniform representation participants 
random subsets help overcome inherent scaling limitations services maintain global state perform global network probing 
improve routing performance peer peer distributed hash tables locating topologically close nodes 
presents design implementation evaluation ransub scalable protocol delivering state 
demonstration ransub utility construct saro scalable adaptive application layer overlay tree 
saro uses ransub state information locate appropriate peers meeting application specific delay bandwidth targets dynamically adapt changing network conditions 
large scale evaluation overlay nodes participating emulated node wide area network topology demonstrate adaptivity scalability terms node state network overhead ransub saro 
existing streaming media server distribute content saro running top planetlab internet testbed 
distributed services track characteristics subset peers 
information failure detection routing application layer multicast resource discovery update propagation 
ideally size research supported part national science foundation eia itr hewlett packard ibm intel microsoft 
albrecht supported nsf graduate fellowship vahdat supported nsf career award ccr 
department computer science duke university razor albrecht vahdat cs duke edu subset equal number global participants provide node highest quality information 
unfortunately approach breaks tens nodes wide area encountering scalability limitations terms node state network overhead 
suggests building scalable distributed systems top location infrastructure node quickly steps locate remote node maintaining local state 
approach holds promise scaling distributed systems consisting millions participating nodes 
existing techniques track characteristics fixed set nodes hypothesis significant additional benefits periodically distributing different random subset global participants node 
ensuring received subsets uniformly representative entire set participants frequently refreshed nodes eventually receive information regarding large fraction participants 
consider applicability mechanism application classes adaptive overlays number efforts build overlays adapt dynamically changing network conditions probing peers 
instance narada ron maintain global group membership periodically probe participants determine appropriate peering arrangements limiting system scalability 
presence mechanism deliver random subsets node allow overlay participants learn remote nodes suitable peering time periodically learning new information adapt dynamically changing network conditions 
parallel downloads effort suggests perpendicular downloads popular content set peers receiving erasure coded content 
nodes receive data source peers received data source peer 
unresolved challenge approach locating peers available bandwidth diversity set received data items 
random subsets provide convenient mechanism locating peers 
related approach number efforts reliable multicast propose peers multicast tree data repairs avoid scalability issues root 
random subsets likewise provide convenient mechanism locating nearby peers share bottleneck link chance containing lost data 
peer peer systems locality peer peer systems desire multiple potential choices hop source destination :10.1.1.111.1818:10.1.1.140.3129:10.1.1.28.5987
changing random subset participating nodes enable nodes insert entries routing table locality properties adapt dynamically changing network conditions 
content distribution networks cdns objects stored multiple sites spread network 
important challenges client perspective include resource discovery determining replicas store objects request routing sending request replica deliver best performance current load levels network conditions 
random subsets allow cdns track state subset global replicas 
number earlier studies indicate making decisions random subset global information performs comparably maintaining global system state 
epidemic algorithms classic application random subsets epidemic algorithms nodes transmit updates random neighbors 
high probability nodes performing anti entropy converge see set updates communication steps 
random subsets pro vides convenient mechanism locating neighbors biasing communication nearby sites 
view scalable mechanism delivering uniformly random subsets global participants fundamental broad range important network services 
presents design implementation ransub protocol 
ransub utilizes overlay tree periodically distribute random subsets overlay participants 
leverage number existing techniques provide infrastructure :10.1.1.16.8178:10.1.1.1.4196:10.1.1.19.7440:10.1.1.11.1973
demonstrate key benefits ransub support adaptive overlay construction design evaluation saro scalable adaptive randomized overlay 
saro uses random subsets build overlays meet application specified targets delay bandwidth ii match characteristics underlying network iii adapt changing network conditions 
ransub key goal saro scalability node tracks characteristics remote participants node probes peers time period configurable epoch 
saro requires global coordination locking perform overlay transformations 
special instance ransub ensures total ordering participants simultaneous transformations introduce loops overlay 
completed implementation saro ransub conducted number large scale experiments 
show node instance saro running emulated node network model net quickly converges user specified performance targets low overhead node probing ransub operation 
subject prototype live runs planetlab testbed demonstrating similarly low convergence times ability stream live media overlays publicly available media servers :10.1.1.109.4681
remainder organized follows 
section presents ransub algorithm distributing random subsets 
section details saro scalable adaptive overlay uses random subsets conform underlying topology dynamically adapt changing network conditions 
section evaluates prototype behavior variety network conditions 
section places context related efforts section presents 
random subsets desirable properties details design implementation discuss desirable properties random subset tool 
ideally system offer 
customization applications determine size random subsets delivered 
size depend application specific actions formed nodes receiving random subset 
example parallel download application may wish initiate data transfer small constant number peers system may wish probe nodes 

scalability system support large scale services posing burden underlying network terms control overhead 
additionally correct system operation depend system size application able request random subset size 
scalability implies required node state network communication overhead grow sub linearly number participants 

uniform changing subsets envision tool repeatedly invoked retrieve snapshots global participants different points time 
snapshot random subset consist nodes uniformly distributed global participants remote node appears delivered subset equal probability 
desired invocation tool return participant different random subset independently chosen participants 
similarly invocations participant receive probabilistically different subsets correlation invocations 
way time node exposed wide variety global participants 
certain applications may desire nonuniform distribution example favors nearby nodes functionality layered top baseline system 

frequent updates support network services system adapt changing network conditions system offer frequent distribution random subsets 

resilience failures system preserve properties face failures 
failed nodes appear random subsets short bounded amount time 

resilience security attacks attack malicious users system maintain properties uniform distribution degrade performance gracefully unable defend massive attack 
overview goals described describe ran sub scalable approach distributing random subsets ransub distribute distribute sets ds overlay tree ransub operation 
ransub collect collect sets containing nodes uniformly spread participants 
purposes discussion assume presence scalable mechanism efficiently building maintaining overlay tree 
number techniques exist section describe saro technique building overlay ransub functionality provides necessary overlay infrastructure :10.1.1.16.8178
summarizes ransub operation 
ransub distributes random subsets collect messages propagate tree leave state node 
distribute messages traveling tree soft state previous collect round distribute uniformly random subsets participants 
ransub distributes subset participants node configurable epoch 
epoch consists phases distribute phase data transmitted root overlay tree participants data distributed tree second collect phase participant successively propagates parent random subset called collect set cs containing nodes subtree roots data aggregated tree 
distribute phase node sends children uniformly random subset called distribute set ds remote nodes 
contents distribute set constructed collect sets gathered previous collect phase 
distribute message reaches leaf ransub tree triggers collect phase node sends parent subset descendants collect set metadata 
process continues root tree reached 
collect phase complete root received collect sets children 
root signals new epoch distributing new distribute set children point entire process begins 
length epoch configurable requirements applications running top ransub 
lower bound length epoch determined worst case root leaf leaf root transmission times overlay 
collect distribute node participating ransub overlay maintains state address parent overlay list children sequence number current epoch 
addition maintains soft state collect set number subtree descendants children distribute set total number overlay participants 
describe ransub uses information maintains decentralized manner 
collect phase goal collect message node compose collect sets constructing distribute set subsequent distribute phase ii determine total number participants local subtree 
collect phase begins leaves tree response reception distribute message 
table describes fields collect messages left half table 
collect message sequence number triggering distribute message 
leaves number descendants set collect set contains leaf node 
parent receives collect messages children propagates collect message parent 
nodes collect set selected randomly collect sets received children form subset configurable size default 
node stores collect set aid construction distribute sets distributed children subsequent distribute phase 
key challenge ensure membership collect set propagated node parent random uniformly representative members sub tree rooted achieve ransub operation takes input multiple subsets total population represented subset 
outputs new subset properties group membership randomly chosen input subsets ii target size constraint 
achieved building output set incrementally 
randomly choose input subset population represents 
randomly choose member subset selected add output set 
consider case performed subsets contain members represents population represents population 
choose members add output set probability 
output set members uniformly represent population expected member ship members members note able properly weigh subset part collect distribute node learns total number nodes subtree rooted children 
distribute phase new epoch root received collect message children previous epoch 
actual length epoch determined individual application requirements 
right half table describes fields contained distribute message 
parent constructs distribute sets child manner 
recall node stores collect set received child previous collect phase 
children particular node maintains recall collect set consists nodes selected uniformly randomly subtree rooted node parent node constructs distribute set child information saved preceding collect phase 
information includes collect set child node distribute set 
application ransub offers choices regarding contents distribute sets ransub suitable application requires uniformly random subsets nodes system 
flavors option 
identical delivers distribute set nodes overlay 
distribute set created root compact operation represents subtree rooted child root numbered 
potentially useful construct evident option delivers different distribute sets collect distribute sequence sequence number current epoch sequence sequence number current epoch collect set uniformly random subset nodes distribute set uniformly random subset sender subtree lay participants descendants estimate number nodes participants estimate total number nodes sender subtree overlay flag determines children ordered new total ransub created node 
case node receives distribute message parent containing constructs collect sets stored children manner forwards child note root parent 
ransub case node receive random subset consisting nodes descendants 
appropriate application layer multicast structure participants probing better bandwidth latency root tree 
case considering node descendants introduce cycle overlay tree 
child numbered parent node constructs manner ransub ordered type distribute set calculation imposes total ordering participating nodes 
node receives distribute set containing random nodes come total order ing 
child numbered parent node constructs manner table contents collect distribute messages 
sample application adaptive application layer multicast overlay uses ransub ordered ensure simultaneous transformations tree structure introduce loops discussed section 
assume ransub ordered remainder 
discussion limitation ransub ordered child particular node smaller set potential nodes choose th 
fact child distribute set restricted relatively small subset global nodes 
ransub ordered violates goal distributing random subsets nodes uniformly chosen global participants single epoch 
take step ensure node receives uniformly random subset multiple invocations ransub ordered 
configurable epochs root overlay periodically sets flag distribute message signaling overlay participants randomly children lists 
allows children total ordering received nodes distribute sets chance move total ordering receive information nodes 
summarizes operation phases ransub protocol 
simplicity include results appropriately reduce size subsets application specified size constraint 
collect phase example node constructs collect set composed union members collect sets received children 
receives collect set children uniformly representative subtrees rooted respectively 
node determines collect sets compose distribute set children 
distribute phase node constructs union node turn constructs union distribute set previous collect phase 
gets lucky ordering node total ordering cs cs csd cse csf csg ds ds ds ds example scenario depicting phases ransub protocol collect phase traveling overlay left panel distribute phase traveling overlay right panel 
receives distribute set representative entire topology recall omitting compact operation throw appropriate set elements maintain size constrained sets 
node get unlucky receive distribute set consisting node total ordering 
children lists resulting total ordering random walk tree node visited yielding entirely different new total ordering 
note complexity children needed total ordering required 
comparison ideal random subset primitive believe ransub closely approximates ideal properties outlined section 
uses tree propagate sublinear sized collect distribute sets parents children imposes low overhead underlying network 
efficient overlay structure ensures epochs short 
instance find node system network diameter ms epochs short seconds 
absence node failure ransub delivers random subsets close uniformly distributed 
key achieving uniformity accounting nodes represented random sample time protocol execution 
achieve running protocol tree straightforward node estimate number descendants 
includes adapting ransub function meshed overlays just trees 
ransub uniformity suffer nodes join leave system 
provide guarantee nodes random subset active considered nodes 
ransub mechanism snapshot live tree participants uniformly random samples 
strength approach require separate group membership mechanism 
node alive receives collect message may included distribute sets nodes 
node fails soon snapshot may unavailable considered nodes 
node joins collect phase previous epoch completed snapshot 
ransub time node failure detection order small number seconds 
nodes point failure rejoin tree current participants previously received distribute sets 
node failure detection interval reduced underlying tree support application layer multicast 
case absence data hundreds milliseconds signify disconnection parent 
essence application layer data may serve heartbeat mechanism failure detection 
ransub assumes trust overlay participants resilient internal attacks 
example malicious node alter contents collect distribute sets 
investigating techniques address limitation 
instance approach involves sending subsets multiple tree cross links allow identification confinement damage caused malicious users 
cross links help reliability tree 
multiple paths tree means single failure may disconnect nodes tree 
saro overview discussed earlier distributing uniformly random subsets global participants applicable broad range important services 
section describes saro scalable adaptive randomized overlay application ransub 
ransub saro circular example 
saro uses random subsets probe peers locate neighbors meet performance targets adapt dynamically changing network conditions 
time ransub uses saro overlay efficient distribution collect distribute messages 
goal saro construct overlays scalable ii degree constrained iii bandwidth constrained iv adaptive selforganizing 
scalability enforce rules 
node track remote nodes 

node perform network probes time period epoch 
application configure number probed nodes effect tradeoff network overhead adaptivity agility overlay 

global locking required transform overlay 
achieve goals distribute sets ransub transmits node epoch 
saro node performs probes members subset determine remote node exists deliver better delay bandwidth descendants 
attempts move motivate third requirement consider node decides move underneath remote node system introduce loop ancestor simultaneously decides move descendant naive approach avoiding loops requires locking number nodes wide area avoid simultaneous overlay transformations 
may appropriate small number nodes lan settings process scale large overlays 
impose total ordering nodes provided ordered flavor ransub ensure simultaneous moves epoch introduce saro loop 
epoch node distribute set contains remote nodes come current total order 
recall ransub periodically changes total ordering nodes random membership delivered distribute sets 
node tracks probes remote nodes epoch ransub ensures makeup distribute set changes probabilistically time node quickly probes potential parents 
size random subset effects tradeoff scalability measured state network probing overhead convergence time amount time takes build overlay achieves delay bandwidth targets changing network conditions 
saro requires additional information distributed ransub see table 
general applications may wish piggyback different state information existing collect distribute messages 
ransub layer designed manner extensibility straightforward detailed description scope 
table describes additional information transmitted saro collect distribute messages 
probing overlay transformations recall length epoch random subsets distributed epoch determined applicationspecific requirements 
shorter epochs provide information longer epochs incur overhead 
saro goal quickly converge overlay matches underlying topology adapts dynamically changing network characteristics 
implementation evaluation pessimistic run constant epoch length seconds cases 
plan investigate setting epoch length adaptively overlay characteristics network conditions 
example saro matched underlying topology network characteristics changing rapidly common case internet system afford longer epoch length 
envision reducing system overhead running saro short epoch length initial self organization response large changes network conditions running long epoch common case 
key saro ability converge bandwidth delay maximum delay root overlay participants targets lies localized tree transformations 
dur collect distribute delay delay estimate furthest de tree height estimate actual highest leaf latency tree delay gain estimate delay gain mov root delay estimate recipient delay ing best alternative parent root table additional fields collect distribute messages required saro 
ing epoch nodes measure delay bandwidth members distribute set 
probes consist small number packets inter spaced target application bandwidth loss rate probes specified threshold probing node calculates average round trip time 
goal locate new parent deliver better delay better bandwidth descendants 
better parent located child attempts move 
migrating node issues add request potential parent waits response 
request accepted notifies old parent communicates new delay root children notifies new parent furthest descendant updating parent state epoch 
general goal saro achieve lowest delay configuration maintains target bandwidth root 
epoch nodes information probes perform types transformations bandwidth delay bandwidth 
nodes reached bandwidth target may perform band width transformation improve bandwidth root means increasing delay 
de lay bandwidth transformations allow nodes rotate new parent improves nodes delay root maintaining improving bandwidth 
dynamic node addition failure recovery point discussion assumes static set nodes dynamically self configuring match changing network conditions 
general set overlay participants changing 
node performing saro join simply needs contact existing member overlay 
initial bootstrapping parent may sub optimal perspective bandwidth delay 
currently assume overlay traffic relatively small portion traffic bottleneck 
leave accurate stable tcp friendly probing 
general higher accuracy probes inherently incur higher overhead issue orthogonal 
node receiving random subsets part collect distribute process associated random subsets probe superior parents process described 
bootstrapping parent node fail additional assumption node aware root tree 
incoming node bootstrapping parent similar overcast replicate root improve root availability 
sake scalability allow nodes contact root absolutely necessary original bootstrapping parent failed 
bootstrapping parent slots children list accept joining node redirects incoming node randomly parent children 
similarly incoming node violate delay bound bootstrapping parent redirects parent 
node redirected times joins tree available point tries improve position 
handling node failure simplified periodic distribution collect distribute messages implicitly act heartbeat messages 
parent waits collect messages children 
message received multiple subtree height parent assumes children failed excludes participating epoch sending distribute message child 
node proceed collect message parent detects failure ensure failure low tree cascade way back tree 
node similarly detect failure parent receive distribute message multiple delay target 
case send dummy distribute message empty distribute set children 
empty distribute message signals descendants probing overlay transformations performed epoch 
attempts locate new parent information note current maximum node leaf delay serves convenient baseline complex process determining appropriate timeouts 
previous distribute sets appropriate 
failure entire subtree rooted able rejoin overlay single transformation forcing nodes rejoin separately 
certain circumstances greedy nature saro lead sub optimal overlays 
consider situation 
node particular degree bound full complement children 
node overlay achieve bandwidth target child children best served able achieve bandwidth target child fourth node described far saro stuck local minimum situation 
address situation introducing wean operations 
high level goal ensure parent leaves number slots open possible address condition 
node approaches degree limit send wean message children 
subsequent epochs child move new parent find suitable location meets bandwidth requirement delay may increased 
wean may may succeed appropriate alternate parent may exist wean operation expires configurable number epochs 
difficulty choosing child wean 
ideally parent wean child lose delay bandwidth achieving targets 
approximate manner 
epoch nodes maintain information best alternate parent respect delay bandwidth 
information propagated parents collect phase see table parents determine wean target 
evaluation completed implementation ransub saro described previous sections 
wrote code compatibility layer allows evaluate working system ns packet simulation environment live networks 
brevity omit majority results detailed simulation evaluation 
focus behavior system running live modelnet internet emulation environment internet planetlab testbed :10.1.1.109.4681
modelnet experiments saro runs ghz pentium iii running linux interconnected mbps gbps ethernet switches 
multiplex instances saro linux nodes total nodes self organizing form overlays 
validated modelnet results ns experiments identical topologies communication patterns 
modelnet packet transmissions routed core responsible emulating hop hop delay bandwidth congestion target network topology 
experiments single ghz pentium iii running freebsd core 
core gbps connection rest cluster 
core bottleneck cpu bandwidth experiments 
earlier shows wide area topology modelnet accurate ms target toend packet transmission time including cpu utilization packets sec gbps assuming packets bytes average 
modelnet scale capacity additional core nodes necessary experiments 
modelnet emulates packet transmission hop hop including queue sizes queuing disciplines target network 
packet delay accounts congestion hop queuing propagation transmission delay 
default core emulates characteristics random node inet generated topology 
randomly assign nodes act clients connected degree stub nodes topology 
participants randomly selected act root saro tree 
classify network links client stub stub stub bandwidth mbps transit stub bandwidth mbps transit transit mbps 
calculate propagation delays nodes relative placement nodes plane inet 
baseline diameter network approximately ms results restricted single topology results additional experiments simulations show qualitatively similar behavior 
ransub uniformity verify ransub distributes uniformly random subsets nodes complete ransub prototype create saro overlay emulated nodes described 
convergence experiment run total epochs tracked cumulative number unique remote peers ransub distributes node time 
configured ransub distribute average number nodes learned time pure uniform ransub epoch average number nodes nodes learns function number epochs optimal pure uniform case ransub 
random participants epoch 
plots average number peers node exposed axis function time progressing epochs axis 
vertical bars represent standard deviation 
show best case simulate pure uniform random subsets random number generator ransub implementation 
ransub delivers random subsets essentially optimal uniformity 
saro overlay convergence delay maximum saro delay ms target maximum saro delay ms target maximum saro delay ms target time delay convergence function time different delay targets 
shows convergence time saro overlays running maximum degree random subsets size 
nodes join overlay sequentially random point network seconds experiment nodes second time random subsets probe parents deliver appropriate delay target bandwidth targets kbps easily achieved experiment 
effect experiment pessimistically create overlay random interconnectivity 
observe behavior system different delay targets ms ms ms ms delay target quite difficult achieve topology degree bound 
plots achieved worst case delay relative delay target function time progressing axis 
saro uses random subsets converge specified delay target cases convergence time varying seconds seconds cases depending tightness delay target 
note convergence times random subsets comparable number smaller scale overlay construction techniques maintain global state information perform global probing 
effects random subset size convergence time control overhead random subset size delay convergence time resulting node probing overhead function size random subset 
quantify effects size random subsets saro convergence time 
general information random subset increases convergence time nodes spend time find appropriate parent 
information decrease convergence time cost increased network probing overhead 
maximum node degree measure time node saro tree converge ms delay target function size random subsets 
shown increase size random subset axis plot resulting convergence time left hand axis 
convergence time decreases approxi node control overhead bps delay mately seconds seconds 
plots associated tradeoff node control overhead accounting ransub collect distribute messages probing overhead 
expected probing overhead right hand axis grows linearly size random subset manageable bytes sec random subset size grows probing overhead 
note benefits increasing random subset size diminishes rapidly 
course point diminishing returns vary topology delay target 
experimented dynamically increasing decreasing random subset size real time measurements overlay convergence leave 
adaptivity maximum saro delay th percentile saro delay th percentile saro delay time adaptivity saro tree response pronounced change network delay 
important aspects saro ability dynamically react changing network conditions 
evaluate ability subject steady state node saro tree widespread sustained change network characteristics 
seconds increase propagation delay randomly chosen network links link original delay 
idea experiment determine happens overlay network continuously degrades conditions worse typically internet 
shows results experiment plotting delay function time th percentile th percentile worst case node overlay function time progressing axis 
note th percentile indicates saro nodes delay better indicated value 
set delay target ms experiment degree cdf runs bound size random subset 
intentionally set target delay value relatively difficult achieve degree bound face highly variable network conditions 
overlay initially takes approximately seconds converge delay target 
perturb network conditions manner described time continuing seconds 
nodes able maintain delay target network perturbation takes saro seconds network perturbation link delays remain elevated levels bring nodes delay bounds 
include results experiment quantify level adaptivity saro deliver 
additional experiments indicate network conditions perturbed longer period time number links magnitude change frequency change saro unable achieve delay target 
perturbation relaxed delay target saro typically quickly recovers changes network conditions 
planetlab deployment conv 
cdf target ms conv 
cdf target ms convergence time cdf convergence time planetlab nodes node acting root turn different delay targets 
evaluate utility approach evaluated behavior saro running subset planetlab nodes september :10.1.1.109.4681
ran saro planetlab times separate run different planetlab node root overlay 
measure convergence time different delay targets ms ms 
set maximum node degree random subset size 
plots result experiment 
find relatively relaxed delay target ms nodes converge seconds 
tightening delay bound ms increases typical convergence time approximately minute worst case convergence minutes 
note reported values worst case convergence time node meet delay target 
streamed live audio saro integrating proxy separate thread saro address space depicted 
publicly available server stream mp encoded 
instantiate saro process node server act root overlay tree 
saro node root instructs associated proxy establish connection parent receive streaming data 
node able stream content local winamp players children overlay 
time saro node locates better parent instructs proxy reestablish connection new parent 
winamp proxy saro proxy saro proxy saro winamp winamp streaming live media saro planetlab 
configuration successfully stream mp files kbps existing servers nodes emulation environment planetlab testbed 
shows results minute experiment streaming saro nodes spread planetlab testbed 
set delay target ms size random subsets maximum node degree 
plots cdf percent bytes received nodes 
byte loss rates vary 
note measure loss rate saro self organizing experiment 
vast majority losses came time 
verified correctness experiment connecting individual saro nodes winamp media player playback stream 
fraction nodes cdf planetlab percentage bytes received distribution percent packets received minute experiment streaming kbps saro running planetlab 
related ransub shares design goals gossip dissemination protocols lbp cast 
operates tree ransub offers uniformly random subsets relative earlier efforts 
ransub require minimum random subset size correct operation 
combination saro ransub allows predictable time updates epoch 
saro builds number efforts application layer multicast nodes spread internet cooperate deliver content hosts 
edges overlay tcp connections ensuring congestion control reliability hop hop manner 
closely related effort space narada builds mesh interconnecting participating nodes runs standard routing protocol top overlay mesh 
relative narada nodes maintain global knowledge group participants 
comparison ransub layer maintain information probabilistic subset global participants making applications built top ransub including saro scalable 
saro bears similarity banana tree protocol host multicast tree protocol 
approaches attempt provide delay bandwidth guarantees considers metric network design 
protocols idea tree transformations local knowledge obtained limited network probing improve tree quality 
implements restrictive policy choosing potential parent called switch hop considers grandparents immediate siblings 
introduce loops requires loop detection requires knowledge ancestors 
offers bounds tree height message size required state unbounded rendering approach potentially unscalable 
evaluated changing network conditions 
yoid shares design philosophy tree built directly participating nodes need build underlying mesh 
yoid describe scalable mechanism conforming topology underlying network subjected detailed performance evaluation contains loop detection code opposed approach avoiding loops 
almi uses pairs probing cost transmits changing connectivity information centralized node calculates appropriate topology overlay 
rmx faces similar scalability limitations 
overcast nodes join root migrate point tree able maintain minimum level bandwidth 
relative effort overcast focus providing delay guarantees focus bandwidth intensive applications 
convergence time limited probes immediate siblings ancestors 
nice uses hierarchical clustering build overlays match underlying network topology 
relative approach nice focuses low bandwidth delay optimized applications requires loop detection code 
believe variety existing overlay construction techniques including yoid almi rmx overcast nice benefit availability ransub layer 
number efforts propose building application layer multicast top scalable peer peer lookup infrastructures 
projects demonstrate possible probabilistically achieve delay relative native ip multicast unable provide performance bounds probabilistic nature underlying peerto peer system 
systems focus metric network optimization delay bandwidth 
best knowledge approaches largely evaluated simulation subjected live internet conditions 
argues generalized mechanism periodically distributing state random subsets global participants large scale network services 
sample applications include epidemic algorithms reliable multicast adaptive overlays content distribution networks peer peer systems 
contributions design implementation scalable protocol ransub distributes state uniformly random subsets configurable size application specific epoch 
argue utility generality infrastructure evaluation saro scalable adaptive overlay construction protocol 
saro able match underlying networking topology adapt dynamically changing network conditions sampling members random subset configurable epoch 
large scale evaluation saro nodes emulated node network topology confirm scalability adaptivity approach 
existing streaming media player transmit live streaming media saro running top planetlab internet testbed 
acknowledgments shepherd steve gribble helping refine david becker help modelnet 
rebecca anonymous reviewers helpful comments 
ganesh kermarrec massoulie 
peer peer lightweight membership service largescale group communication 
proceedings rd international workshop networked group communication 
david andersen hari balakrishnan frans kaashoek robert morris 
resilient overlay networks 
proceedings sosp october 
banerjee bobby bhattacharjee christopher 
scalable application layer multicast 
proceedings acm sigcomm august 
kenneth birman mark hayden zhen xiao mihai budiu yaron minsky 
bimodal multicast 
acm transaction computer systems may 
john byers jeffrey considine michael mitzenmacher rost 
informed content delivery adaptive overlay networks 
proceedings acm sig comm august 
chang ramesh govindan sugih jamin scott shenker walter willinger 
capturing representative level internet topologies 
proceedings acm sigmetrics june 
chawathe steven mccanne eric brewer 
rmx reliable multicast heterogeneous networks 
infocom pages 
frank dabek frans kaashoek david karger robert morris ion stoica 
wide area cooperative storage cfs 
proceedings th acm symposium operating systems principles sosp october 
michael dahlin 
interpreting stale load information 
th ieee international conference distributed computing systems icdcs may 
alan demers daniel greene carl hauser wes irish john larson scott shenker howard sturgis daniel swinehart douglas terry 
epidemic algorithms replicated database maintenance 
operating systems review 
eugster guerraoui kermarrec 
lightweight probabilistic broadcast 
proceedings international conference dependable systems networks dsn 
paul francis 
yoid extending internet multicast architecture 
technical report icsi center internet research april 
david sugih jamin 
host multicast communication protocols 
global peer peer computing large scale distributed systems 
yang hua chu sanjay rao hui zhang 
case system multicast 
proceedings acm sigmetrics international conference measurement modeling computer systems june 
yang hua chu sanjay rao srinivasan seshan hui zhang 
enabling conferencing applications internet overlay multicast architecture 
proceedings acm sigcomm august 
john jannotti david gifford kirk johnson frans kaashoek jr james toole 
overcast reliable multicasting overlay network 
proceedings operating systems design implementation osdi october 
brian noble nguyen randy katz 
trace mobile network emulation 
proceedings sigcomm september 
network simulator ns 
www isi edu nsnam ns 
dimitrios shi dinesh verma marcel waldvogel 
almi application level multicast infrastructure 
rd usenix symposium internet technologies systems usits 
larry peterson tom anderson david culler timothy roscoe :10.1.1.109.4681
blueprint introducing disruptive technology internet 
proceedings acm hotnets october 
sylvia ratnasamy mark handley richard karp scott shenker 
application level multicast content addressable networks 
third international workshop networked group communication november 
sylvia ratnasamy paul francis mark handley richard karp scott shenker 
content addressable network 
proceedings sigcomm august 
rowstron 
kermarrec castro druschel 
scribe design large scale event notification infrastructure 
third international workshop networked group communication november 
antony rowstron peter druschel 
pastry scalable distributed object location routing large scale peer peer systems 
middleware november 

www com 
ion stoica robert morris david karger frans kaashoek hari balakrishnan 
chord scalable peer peer lookup service internet applications 
proceedings sigcomm august 
douglas terry marvin theimer karin petersen alan demers mike spreitzer carl hauser 
managing update conflicts bayou weakly connected replicated storage system 
proceedings fifteenth acm symposium operating systems principles december 
amin vahdat ken kevin walsh mahadevan jeff chase david becker 
scalability accuracy large scale network emulator 
proceedings th symposium operating systems design implementation osdi december 
zhang sugih jamin lixia zhang 
host multicast framework delivering multicast users 
proceedings infocom 
ben zhao john kubiatowicz anthony joseph 
tapestry infrastructure fault tolerant wide area location routing 
technical report ucb csd uc berkeley april 
shelley zhuang ben zhao anthony joseph randy katz john kubiatowicz 
bayeux architecture scalable fault tolerant wide area data dissemination 
proceedings eleventh international workshop network operating system support digital audio video 
