improving dependency pairs jurgen giesl rene thiemann peter schneider kamp stephan informatik ii rwth aachen 
aachen germany giesl thiemann informatik rwth aachen de spf informatik rwth aachen de 
dependency pair approach powerful techniques termination innermost termination proofs term rewrite systems trss 
trs generates inequality constraints satisfied weakly monotonic founded orders 
improve dependency pair approach considerably reducing number constraints produced innermost termination proofs 
extend transformation techniques manipulate dependency pairs simplify innermost termination proofs significantly 
order fully automate dependency pair approach show transformation techniques search suitable orders mechanized ciently 
implemented results automated termination prover evaluated large collections examples 
traditional methods prove termination trss automatically simplification orders term greater proper subterms 
numerous important trss simply terminating termination shown simplification orders 
dependency pair approach developed allows application simplification orders non simply terminating trss :10.1.1.23.3044
way class systems termination provable mechanically increases significantly 
example 
trs simply terminating quot rule left hand side embedded right hand side instantiated 
classical approaches automated termination proofs fail example easy handle dependency pairs 
minus quot minus minus quot quot minus sect 
recapitulate dependency pair approach termination innermost termination proofs 
show approach improved significantly reducing constraints termination sect 
innermost termination sect 

sect 
introduces new conditions transforming dependency pairs order simplify innermost termination proofs 
automated innermost termination proofs constraints generated dependency pair approach pre processed argument filtering tries solve standard simplification orders 
proceedings th int 
conference logic programming artificial intelligence reasoning lpar lnai springer verlag 
algorithm generate argument filterings improved dependency pair approach sect 
discuss heuristics increase ciency sect 

improvements algorithms implemented termination prover 
give empirical results show extremely successful practice 
contributions helpful tools dependency pairs cime ttt conjecture approaches termination trss aspects common dependency pairs :10.1.1.43.3953
dependency pairs combined termination techniques integrated dependency pairs size change principle termination analysis functional logic programs 
system uses dependency pairs termination proofs logic programs 
improving dependency pairs useful termination analysis kinds programming languages 
proofs details experiments 
dependency pairs briefly dependency pair approach arts giesl refer refinements motivations :10.1.1.23.3044
assume familiarity term rewriting see 
trs signature defined symbols root symbols left hand sides rules constructors restrict finite signatures trss 
set tuple symbols arity write 
write 

definition dependency pair 
subterm defined root symbol rewrite rule called dependency pair set dependency pairs denoted dp 
dependency pairs trs ex 
minus minus quot minus quot quot minus dependency pairs innermost termination proofs need notion innermost chains 
assume di erent occurrences dependency pairs variable disjoint consider substitutions domains may infinite 
denotes innermost reductions 
definition chain 
sequence dependency pairs 
chain exists substitution consecutive pairs sequence 
chain innermost chain normal form theorem termination criterion 
terminates infinite chain 
innermost terminating infinite innermost chain 
estimate dependency pairs may occur consecutively innermost chains builds called innermost dependency graph nodes dependency pairs arc innermost chain 
example dependency graph innermost dependency graph arcs 
undecidable dependency pairs form innermost chain construct estimated graphs cycles real graph cycles estimated graph 
cap result replacing variables subterms defined root symbol di erent fresh variables 
multiple occurrences variable replaced fresh variable multiple occurrences subterm defined root replaced pairwise di erent fresh variables 
ren result replacing occurrences variables di erent fresh variables ren linear term 
instance cap quot minus quot cap quot quot ren quot quot 
estimated dependency graph arc ren cap unifiable 
estimated innermost dependency graph arc cap unifiable general unifier mgu normal form 
cap defined cap subterms defined root occur replaced new variables 
ex 
estimated dependency estimated innermost dependency graph identical real dependency graph 
alternative approximations dependency graphs see 
set dependency pairs called cycle pairs non empty path graph traverses pairs example cycles 
regard finite trss infinite innermost chain dependency pairs corresponds cycle innermost dependency graph 
show innermost termination proves absence infinite innermost chains separately cycle 
generates sets constraints satisfied reduction pair consisting order reflexive transitive monotonic stable closed contexts substitutions stable founded order compatible 
note need monotonic 
essentially constraints termination cycle ensure rewrite rules dependency pairs weakly decreasing dependency pair strictly decreasing 
innermost termination usable rules weakly decreasing 
ex 
usable rules empty usable rules minus rules 
definition usable rules 
rls root 
term usable rules smallest set rules 
rls rls 
set dependency pairs define 
want standard techniques synthesize reduction pairs satisfying constraints dependency pair approach 
existing techniques generate monotonic orders 
need monotonic quasi order monotonic 
called weak mono 
reason synthesizing suitable order arguments function symbols eliminated notation 
definition argument filtering 
argument filtering signature maps ary function symbol argument position 
possibly empty list 
argument positions signature consists function symbols 
arity argument filtering induces mapping denoted defined variable 



argument filtering called collapsing 
technique automating dependency pairs formulated follows 
argument filterings signature theorem automating dependency pairs :10.1.1.23.3044
trs terminating cycle estimated dependency graph reduction pair argument filtering dependency pair dependency pairs innermost terminating cycle estimated innermost dependency graph reduction pair argument filtering dependency pair dependency pairs ex 
obtain constraints termination 
reduction pair argument filtering cycle 
minus minus quot quot minus minus minus minus quot quot quot minus filtering minus replaces terms minus minus 
filtering satisfied lexicographic path order lpo precedence quot minus 
termination trs proved 
innermost termination obtain constraint cycle usable rules 
constraints necessary quot rules usable right hand side dependency pair 
general constraints innermost termination subset constraints termination 
classes trss innermost tion implies termination non overlapping trss approach innermost termination proving termination 
shown implement thm 
compute cycles maximal cycles strongly connected components sccs contained cycles 
solving constraints thm 
scc strict constraint may satisfied dependency pairs scc 
subcycles scc containing strictly decreasing dependency pair considered anymore 
solving constraints initial sccs strictly decreasing dependency pairs removed builds sccs remaining dependency pairs improved termination proofs technique thm 
termination proofs improved 
automation usually uses quasi simplification order monotonic stable 

term symbol 
observed constraints thm 
imply termination trs terminating terminating fresh function symbol occurring showed dependency pairs modular termination proofs hierarchical combinations terminating trss 
results integrate consideration cycles estimated dependency graphs required dependency pairs strictly decreasing 
thm 
extends modularity results combining cycles 
way obtains improvement termination proofs dependency pairs trss general 
advantage set constraints thm 
reduced significantly 
crucial idea consider recursion hierarchy function symbols 
function symbol depends symbol denoted exists symbol occurs rule depends define means mutually recursive 

rn rls rls call 
rn separation extend sets defining rls rls denote rules depends dr clearly cycle consists dependency pairs thm 
regard cycles pairs dp 
detect cycles regard dependency graph trs reason consider chains just chains 
thm 
states requiring rules su ces demand rules depends rules termination proof ex 
required see consider toyama trs 
dependency graphs empty dependency graph cycle 
considers graphs falsely prove termination 
quot rules regarding cycle minus minus 
improvement sound quasi simplification order 
theorem improved termination proofs dps 

rn separation terminating cycle estimated dependency graph dp reduction pair quasi simplification order argument filtering dependency pair dependency pairs example 
trs shows thm 
increases ciency leads powerful method 
int computes 
nil empty list cons represents list insertion 
intlist nil nil int nil int cons nil intlist cons cons intlist int intlist int int cons int trs separated intlist rules int rules constraints thm 
termination intlist cons intlist solved reduction pairs simplification orders 
contrast thm 
weakly decreasing examining constraints satisfied embedding order argument filtering cons intlist intlist 
constraints cycle rules oriented lpo filtering cons int 
part proof requires consideration cycles estimated dependency graph 
reason argument filtering simplification order dependency pairs strictly decreasing 
considers cycles uses modularity result ex 
fails simplification orders 
refinements combined thm 

improved innermost termination proofs innermost termination easier prove termination innermost dependency graph arcs dependency graph require usable rules 
sect 
showed termination su ces require rules current cycle consists dependency pairs 
superset usable rules 
improvement thm 
innermost termination reduce usable rules 
idea apply argument filtering determine usable rules 
collapsing argument filterings destroys soundness technique 
consider non innermost terminating trs double double double double su ces extendable reduction pair 
cycle double argument filtering double results 
filtered dependency pair contains defined symbols conclude cycle usable rules 
easily orient resulting constraint cycle falsely prove innermost termination 
note elimination double term double due outer function symbol due collapsing argument filtering double 
reason defined symbol double may ignored occurrences positions filtered away function symbols 
cap build usable rules subterms right hand sides dependency pairs occur corresponding left hand side 
definition usable rules argument filtering 
argument filtering 
ary symbol set os regarded positions 


term usable rules smallest set 
rls rls 
term subterm 
rls rls 
set dependency pairs 
refine innermost termination technique thm 
set usable rules reduced significantly 
theorem improved innermost termination dps 
innermost terminating cycle estimated innermost dependency graph reduction pair argument filtering dependency pair dependency pairs example 
trs list reversal shows advantages thm 

rev nil nil rev cons cons rev rev rev nil rev cons rev rev nil nil rev cons rev cons rev rev innermost termination thm 
cycle rev rev dependency pairs get inequalities dependency pairs rules rules usable 
standard reduction pairs recursive path orders possibly status rpos knuth bendix orders kbo polynomial orders satisfy constraints argument filtering 
contrast thm 
filtering cons rev rev rev rev obtain constraints rev rules filtered constraints oriented embedding order 
experiments system show thm 
improve thm 
practice increasing power particular reduction pairs simple fast orders embedding order reducing runtimes particular reduction pairs complex orders 
transforming dependency pairs increase power dependency pair technique dependency pair may transformed new pairs narrowing rewriting instantiation :10.1.1.23.3044
term narrowing mgu non variable subterm unifies left hand side variable renamed rule mgu distinguish variants termination innermost termination speak narrowing resp 
instantiation 
definition transformations 
trs set pairs terms narrows 
sn 
mgu 
unify variable renamed left hand sides pairs linear 
narrows 
sn 
mgu 
normal form 
unifies variable renamed lefthand side mgu terms normal form 
rewrites non overlapping position redex 
instantiated mgu ren cap 
instantiated mgu cap normal forms 
theorem narrowing rewriting instantiation 
dp result dp narrowing instantiation termination resp 
rewriting instantiation innermost termination 
dependency pair constraints innermost termination satisfiable dp innermost terminating 
certain reduction pairs argument filterings satisfy constraints dp reduction pairs argument filterings satisfy constraints dp estimate innermost dependency graphs sect 
computing constraints 
thm 
transformations complicate termination proofs may increase number constraints producing similar constraints solved argument filterings reduction pairs 
hand transformations crucial success proof 
example 
trs minus rules ex 
extended le true quot le le false true quot minus le le false trying prove innermost termination simplification order satisfies constraints thm 
cycle 
quot le true quot minus intuitively minus satisfied le reduces true 
argumentation simulated transformations 
narrowing perform case analysis le term evaluated 
narrowing instantiated 
results pair quot false cycle 
narrowing quot le forms new cycle 
perform instantiation see form 
replaced new pair true quot minus forms cycle 
rewriting step obtain true quot minus constraints resulting cycle cycles solved minus quot embedding order 
innermost termination def 
thm 
extend results permitting transformations larger set trss :10.1.1.23.3044
narrowing pair permitted unifies left hand side dependency pair 
rewriting dependency pairs allowed usable rules current cycle non overlapping 
instantiating dependency pairs contrast cap instantiation narrowing dependency pairs consider instantiations turn left hand sides dependency pairs normal forms 
crucial problem transformations may applied infinitely times 
developed restricted safe transformations guaranteed terminate 
experiments collections examples show proof succeeds narrowing rewriting instantiation applying safe transformations su cient :10.1.1.31.9447
narrowing instantiation step safe reduces number pairs cycles estimated innermost dependency graph 
set pairs scc denotes set maximal cycles built pairs transformation safe scc decreases 
considered safe transformation step descendants original dependency pair disappear cycles 
pair denotes original dependency pair repeated transformation led transformation safe scc decreases 
example 
estimated dependency graph cycle 
instantiation transforms second pair 
cycle anymore instantiation step safe 
pair single narrowing instantiation step satisfy requirements considered safe 
narrowing instantiation steps ex 
safe 
termination innermost termination proofs benefit considering recursion hierarchy 

rn separation trs show absence innermost chains built dp dealing dp 
innermost rewriting dependency pair 
safe performed rules depend rules 
reason innermost termination verified proving innermost termination ex 
proving innermost termination quot cycle may assume innermost termination minus rewrite step safe 
definition safe transformations 
result set pairs terms transforming def 

transformation safe transformed narrowing instantiation scc scc scc scc transformed innermost rewriting rule root root transformed narrowing previous steps transformed narrowing steps transformed instantiation previous steps transformed instantiation steps theorem termination 
separation 
rn dp 
infinite innermost chains dp repeated application safe transformations terminates 
transformation current cycle scc estimated innermost dependency graph re computed 
re computation regard neighbors transformed pair old graph 
neighbors may arcs new pairs resulting transformation 
regarding neighbors graphs su ces performing unifications required narrowing instantiation 
way transformations performed ciently 
recall regards sccs builds new sccs remaining pairs strictly decreasing sect 

course pairs may transformed innermost termination proof scc 
approach advantage repeats transformations dependency pairs 
computing argument filterings dependency pair approach may apply argument filtering orienting constraints reduction pairs 
exponentially argument filterings show search suitable filterings ciently 
cycle compute small sets containing filterings possibly satisfy constraints termination innermost termination respectively 
corresponding algorithm termination proofs thm 

develop algorithm improved dependency pair approach thm 

particular thm 
algorithm considerably involved set constraints depends argument filtering 
treating constraints separately process cient depth strategy 
rp class reduction pairs rp may contain arbitrary precedences 
set dependency pairs denotes set argument filterings dependency pair strictly decreasing remaining ones weakly decreasing reduction pair rp referring dependency pairs permit pairs resulting dependency pairs narrowing rewriting instantiation 
approach consider partial argument filterings filterings defined subset signature 
example term determine occurrences filtered away 
leave argument filterings undefined possible permit application term defined function symbols needed 
partial argument filterings define dom dom dom 
contain minimal elements contain define superset argument filterings constraints termination cycle satisfied reduction pair rp argument filterings regarded automating thm 

extend partial argument filterings 
definition ex 
ex consists minimal argument filterings rp rls 
set filterings ex ex 
originates dp narrowing instantiation defined symbols ex fk ex 
compute depth search 
start extend minimal rules weakly decreasing 
extended rules weakly decreasing considered element check constraints thm 
satisfiable case success compute elements 
determine element advantage approach usually small contains argument filterings satisfy strict inequality 
innermost termination set constraints satisfied depends argument filtering 
orienting rules necessarily orient rules occurrences rules may deleted argument filtering cf 
thm 

extend os partial argument filterings defining os dom 
defined partial filterings simply disregarding subterms function symbols defined 
partial argument filtering rls included usable rules cycle relation extend order rules weakly decreasing 
label argument filtering set function symbols rules guaranteed weakly decreasing 
definition 
argument filtering labelled set denote labelled argument filtering sets labelled argument filterings define relation ex rls 
note confluent founded labellings increase step 
nf denote normal form define nf 
compute start 
rls extended rules weakly decreasing 
extension rules usable extend ex thm 
states resp 
obtains argument filterings possibly solve dependency pair constraints 
way set argument filterings reduced dramatically ciency increased 
example trs ex 
computing quicksort reduces number argument filterings obtain reduction 
theorem 
cycle 
constraints thm 
termination satisfied reduction pair rp argument filtering 
constraints thm 
innermost termination satisfied reduction pair rp argument filtering 
technique section extended storing argument filterings corresponding parameters order sets ex 
example rp set contain minimal pairs argument filterings precedences lpo resp 
lpo holds extending argument filterings extend corresponding precedence 
course extension permitted extended precedence irreflexive founded 
resp 
non empty constraints innermost termination satisfiable computing resp 
checking orders constraints necessary anymore 
variant particularly suitable orders parameters lpo 
heuristics heuristics improve ciency approach 
concern search argument filterings sect 
base orders sect 

contrast improvements preceding sections heuristics ect power method exist examples innermost termination longer proved heuristics 
type inference argument filterings natural examples termination function usually due decrease arguments type 
course type may di erent di erent functions trs 
type inference algorithm transform trs sorted trs trs rules typed terms type 
heuristic reduce set possible argument filterings require symbol argument position eliminated non eliminated argument positions type 
experiments show examples collections solved lpo base order solved heuristic :10.1.1.31.9447
embedding order dependency pairs increase ciency depth algorithm sect 
successful heuristic embedding order orienting constraints dependency pairs constraints rules may apply complex quasi orders 
advantage smaller 
experiments show due improvements sect 
heuristic succeeds examples full lpo successful reducing runtimes :10.1.1.31.9447
bottom heuristic determine argument filterings sect 
start dependency pairs treat constraints rules rules considered rules contrast suggest bottom approach starts determining argument filtering constructors moves upwards recursion hierarchy treated sect 
determined sets argument filterings determine single argument filtering ones possible 
obtain cient technique backtracking takes place point selects wrong argument filtering proof fail 
precisely guess argument filtering defined constructors 
ary constructor define 
filter away argument type result 
function symbol try extend rules consider functions recursion hierarchy extending defined extensions permit orientation rules choose eliminates arguments possible 
able orient rules mark orientable 
filtering extended tuple symbols trying orient dependency pairs dependency pair strictly decreasing 
termination proofs orientable symbols dependency pairs resulting orientable 
innermost termination proofs orientable symbol depends orientable extend argument filtering way occurrences rules eliminated 
similarly dependency pairs orientable argument filtering eliminates occurrences bottom approach advantage know certain argument positions eliminated extending argument filtering new function symbols 
algorithm modified determining argument filtering reduction pair step step 
example successful option linear polynomial orders coe cients 
bottom algorithm reduces search space enormously 
number trss bottom algorithm succeeds number achieved full dependency pair approach lpo runtime reduced :10.1.1.31.9447
implementation system improvements dependency pair approach significantly reduce sets constraints termination innermost termination proofs 
extended applicability dependency pair transformations developed criterion ensure application terminating compromising power approach examples 
implement approach gave algorithm computing argument filterings tailored improvements 
developed heuristics increase ciency proved successful large case studies 
implemented results system automated program verification environment available www informatik rwth aachen 
de 
tool written java proofs performed fully automated interactive mode graphical user interface 
combine heuristics sect 
scc ers combination algorithm uses heuristics pre processing step calls full dependency pair approach cycles heuristics fail 
safe transformations cases def 

bottom heuristic sect 

heuristics sect 
sect 
lpo base order 
remaining safe transformations def 

transformation applied go back 
full dependency pair approach rpo base order constraints scc solved algorithm called recursively sccs remaining pairs weakly decreasing 
tested combination algorithm collections trss termination trss innermost termination :10.1.1.31.9447
system succeeded innermost termination examples including examples termination 
automated proof collection took seconds innermost termination seconds termination 
results indicate contributions useful practice 

arts 
system description dependency pair method 
proc 
th rta lncs pages 

arts giesl 
termination term rewriting dependency pairs 
theoretical computer science 

arts giesl 
collection examples termination term rewriting dependency pairs 
technical report aib rwth aachen 

baader nipkow 
term rewriting 

univ pr 

ferreira rubio 
complete monotonic semantic path orderings 
proc 
th cade lnai pages 


cime version 
available cime lri fr 

dershowitz 
termination rewriting 
symbolic comp 

dershowitz 
examples termination 
proc 
french spring school theoretical computer science lncs pages 

dershowitz lindenstrauss sagiv 
general framework automatic termination analysis logic programs 
applicable algebra engineering communication computing 

kirchner 
induction proof tool termination strategies 
proc 
th ppdp pages 
acm 

giesl arts 
verification erlang processes dependency pairs 
appl 
algebra engineering communication computing 

giesl arts ohlebusch 
modular termination proofs rewriting dependency pairs 
journal symbolic computation 

giesl thiemann schneider kamp 
improving dependency pairs 
technical report aib rwth aachen germany 

gramlich 
proving termination innermost termination 
proc 
th rta lncs pages 

middeldorp 
automating dependency pair method 
proc 
th cade lnai 

middeldorp 
tsukuba termination tool 
proc 
th rta lncs pages 

huet 

proofs induction equational theories constructors 
journal computer system sciences 

nakamura toyama 
argument filtering transformation 
proc 
st ppdp lncs pages 

lee jones ben 
size change principle program termination 
proc 
popl pages 

middeldorp 
approximating dependency graphs tree automata techniques 
proc 
lnai pages 

ohlebusch 
hierarchical termination revisited 
ipl 

ohlebusch 
tool termination analysis logic programs 
proc 
th rta lncs pages 

steinbach 
automatic termination proofs transformation orderings 
proc 
th rta lncs pages 
full version appeared technical report sr universitat kaiserslautern germany 

steinbach 
simplification orderings history results 
fund 


thiemann giesl 
size change termination term rewriting 
proc 
th rta lncs pages 

toyama 
counterexamples termination direct sum term rewriting systems 
information processing letters 


automated incremental termination proofs hierarchically defined term rewriting systems 
proc 
lnai pages 
available aib informatik rwth aachen de 
