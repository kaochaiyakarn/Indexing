streaming dummies stan zdonik peter alexander victoria philip montgomery turner john alexander derek snyder mark humphrey charles williamson may despite years continuing development rising prominence public eye today databases continue human new ways process information 
databases continue serve reliable platform transaction operations traditional relational database management systems come short new class data management problems 
provides overview problems examines traditional relational systems inadequate deal identifies new class data processing currently known data stream management systems dsms designed handle 
provide overview current status field focus prototypical systems 
motivating examples commercial examples cause difficulties traditional database systems 
network security monitoring intrusion detection traffic monitoring stock assembly lines sources streaming data 
commercial lans wans essential business operation intrusion detection network monitoring critical application 
single compromised node corrupt entire system systems collect information network traffic efficient way process information 
scanning network logs onerous useless task loading logs traditional database 
united states european highways suffer congestion 
urban planners seeking efficiently route traffic 
solution gained popularity variable rate toll current volume traffic 
implementing system requires continuous feedback state traffic particular road segments 
running examples examples streaming data range needs implementations 
consider main examples common threads tutorial 
illustrate different challenges faced dsms researchers 
stock market monitoring stocks example class problem data dropped 
data arrival vary steady stream large influx data occurs tokyo stock market closes 
tuples come stock ticker form time symbol price exchange trades form time symbol quantity buy sell 
addition streaming data system able interface persistent storage holds status market 
queries database streaming trade information get sells ibm minutes 
section discuss precisely query mean see express query formally 
military sensors second example consider technological bottlenecks 
consider scenario soldiers equipped number wireless sensors monitoring heart rate temperature respiratory rate location 
sensors transmit hub speaks intermediate stations vehicles transmit medic call 
bandwidth serious consideration vehicle medic rate transfer high hub vehicle rate moderate sensors hub rate low 
battery power issue considering sensors naively run power just hours 
military scenario individual sensors readings consisting tuples form sensor type sensor id time value 
sensor transmits summary time interval hub hub sends summaries id vehicle 
medic query scenario get location soldiers trouble 
challenges see common challenges examples discussed 
data sources unbounded obvious division blocks 
database gracefully handle unreliable data sources 
database cope transient spikes activity 
examples tends time critical nature queries system latency managed 
unbounded input obvious partition streams tuples unbounded applications 
instance soldier pulse monitor return data long soldier pulse 
furthermore obvious division pulse monitor data stream 
divide hour chunks fifteen minute chunks 
unboundedness problematic relational algebra traditional dbmss assumes finite sets tuples 
example unbounded sequences tuples sense join join completed 
uncontrolled input rates unreliable data sources periods high traffic critical times want database 
times tuples data sources late may dropped 
sensor networks military remote triage applications sensor batteries fail case sensor cease send tuples 
need database deal cases gracefully report soldier died pulse rate sensor failed 
financial applications extreme activity data certain events happen 
nyse opens morning high volume trading minutes 
policy makers alan greenspan announce cuts increases interest rate trading activity spike immediately 
tokyo stock exchange closes day exchange available history trades executed day causes surge trades information trade history 
general database assumptions regarding regularity data sources 
turn defining behavior database difficult 
choose tradeoff exact blocking operations stall waiting tuples arrive late approximate non blocking operations 
latency frequent assumption monitor oriented applications tuples report current status valuable older tuples little value 
latency answer stream continuous query want optimize application specific metrics quality service qos useful 
suppose application monitoring stock ticker feeds monitoring trades compliance 
trade respect certain constraints contents portfolio percent holdings tied options 
investment firm best interest application operate low latency quicker trade executed intended effect 
conventional database systems conventional databases quite certain applications designed fixed semi permanent data 
applications banking business traditional inventory management common uses traditional database data mirrors real world items changes state relatively infrequently compared processing speed computer 
years distinction blurred databases deal continuous queries modifications frequent queries modifications 
emerging class problems data management streaming data data traditional databases 
infinite chaotic varying size reliability 
traditional databases deal new type data 
historical research shows current implementations traditional relational systems scale continuously expanding data continuously expanding queries large numbers triggers active table 
problem hardware engineering way system thinks data 
data stream management system requirements viable dsms deal unbounded streams return meaningful results having seen part stream 
mentioned volume unboundedness streams limits persistent storage 
addition monitor oriented applications need information old tuples 
case processing continuous queries source data reasonable solution high volumes data solution 
dsms deal unreliable data sources due instance delay failing sensors mis ordered tuples 
operators need timeout mechanism non blocking order perform 
tuples arrive late dsms policy deal 
strategy acceptable cases drop late tuples 
major systems consider main dsms groups course tutorial discuss compare various features addressing problems facing dsmss 
groups aurora brown university stream stanford telegraphcq berkeley aurora brown university aurora project allows stream processing 
aurora provides applications means specifying qos functions 
application designers gui boxes arrows representation system 
aurora number operators boxes filtering mapping windowed aggregate join 
help scheduling ordering constraints windows aurora timeout slack parameter window allow waiting tuples 
aurora allows user defined aggregates filters mapping operators 
system aurora group provides distributed dsms 
telegraph berkeley telegraphcq consists set composable data flow modules produce consume records manner analogous operators traditional dbms types modules 
ingress caching interface external data sources 
second query processing routing tuples query modules pipelined nonblocking versions standard relational operators 
telegraphcq uses called state module temporary storage tuples 
third adaptive routing telegraphcq routing plan able re optimize plan query running 
eddies decide routing plan tuple tuple basis 
stream stanford stream system uses traditional relational operators streaming setting 
system considers stream unbounded append bag tuple timestamp relation 
stream defines semantics streams relations classes operators stream relation relation relation stream relation 
cql continuous query language streams extension sql standard 
language operators fundamental notion stream time stamped tuple 
ordering tuples differentiates stream relational set data 
result notion timestamp graphical representation stream system 
aurora telegraph timestamp classification clock time logical time assigned source explicit dsms implicit logical classification timestamps creation tuple injection streaming database fundamental influences definitions operators languages interact systems 
discussion define different types timestamps referring 
may classified assigned source dsms clock time logical time 
focus cases refer 
implicit timestamp defined provided system arrival time 
explicit timestamp ordinary attribute tuple embedded data stream assume clock time data source need 
notice clock time may measured greater granularity process generates stream number tuples assigned timestamp 
transmission delays lack clock synchronization imply originated source ordered time arrives dsms stream may longer ordered explicit timestamp 
addition assume tuples effectively stamped logical clock tuples assigned consecutive integer values distinct value receipt system possibly operator input queue 
tuples globally ordered explicitly assigning unique sequence number tuple locally ordered implicitly manner tuples placed various input queues system 
notice case user perspective ordering non deterministic choice 
example data generated sensor contributing stream may processed follows 
data items generated respectively 

sensor clock resolution minutes explicit timestamp sent tuples 
tuples arrive database respectively 

system clock resolution minutes receive implicit timestamp tuples system logically adds 
internally system represents ordered list tuples data items give rise stream tuples queue representing notice implicit logical timestamps metadata considered part data tuples 
logical timestamps may stored explicitly stream tuples may implied relative position queue 
shall see notions timestamps may processing stream 
key technologies stream sources streaming database systems comprised streams persistent data stored tables data model slightly different 
semantically streams thought sequence timestamped insertions tuple 
stream database systems consume streams typically produce new streams result 
able rely data preexisting internal format available request streaming systems cope heterogeneous environment 
data streams may originating sensors lack resources implement sophisticated protocol leaving server handle burden interpreting data 
example telegraphcq restrictions data format custom wrappers handle processing arriving data 
may multiple devices pushing data stream 
streams created dropped ddl statements similar fashion relational databases allow user interact schema definitions 
detail noteworthy declaration exist exactly column act timestamp stream 
timestamps issue different systems different approaches handling 
considering single stream data situation appears unambiguous complications arise multiple streams combined 
timestamp resulting stream assume 
combining streams join tuple corresponding timestamp immediately available 
implicit timestamps provide useful information exact times required 
providing just ordering allow notions older represented lack information correlating data streams 
explicit timestamps semantically meaningful represent true time data recorded 
result correlate different streams meaningful way 
implicit timestamp correlation streams may inaccurately joined depending delays receiving data different sources 
explicit timestamps introduces complications 
relinquishing control timestamp data source guarantee timestamps arrive order 
ordering requirements operations computing aggregates require method dividing stream finite sequences computation complete finite amount time utilize finite amount memory 
shall see section commonly accomplished windowing operators require time stamp attribute tuples ordered 
data unordered number tuples stored length time needed accurately compute window grow bound 
means assumptions data willing tolerate certain level approximation results 
problems particular 
ordering timestamp time tuple generated explicit timestamp time arrived implicit timestamp 

react tuple arrives order ordering attribute consistent logical timestamp 
example query operates tuples 
arrival time imposes assumption tuples arrived order took negligible amount time arrive 
soon system clock reaches operation performed safe knowledge tuples relevant computation 
interested time stamp marked tuple generated 
assume tuples arrive perfect order 
soon tuple time stamp received operation performed 
strict assumption tuple generated arrive option ignore 
instructive compare ordering timestamps handled differently telegraphcq aurora stream 
telegraphcq define stream terms logical implicit timestamps 
provides operators converting stream notion time 
limitation useful consequence streams automatically ordered timestamp 
contrast aurora supports types 
see section explicit timestamps assumes stream approximately ordered 
stream takes middle road 
supports types timestamps preprocesses stream entering system insure ordered timestamp 
constraints previous section mentioned aurora may assume stream approximately ordered explicit timestamp 
specifically assumes parameter bounds maximum number tuples time order tuples 
say stream may require system approximate stream dropping tuples 
adheres ordered arrival constraint parameter 
precisely stream ordered attribute adherence tuples stream tuples arrive tuples value tuples arrive order tuples 
notice implies strict ordering 
computing window just type stateful operation constrain ordered arrival just corresponding parameterized constraints commonly referred 
example grouping join operations lead similar problems unbounded space time requirements 
corresponding constraints clustered arrival referential integrity 
clustered arrival constraint stream parameter specifies maximum number tuples differing attribute values arrive tuples value particular attribute 
specifically stream clustered attribute adherence tuples stream value tuples non values occur 
words cluster value interrupted non tuples 
type constraint referential integrity bounds delay arrival tuple stream arrival unique tuple joined stream 
parameter represent number tuples time arrivals tuples joined 
example tuples time symbol quantity buy sell joined symbol order find matching buy sell orders define referential integrity constraint minutes 
essentially put minute window length trade query 
desirable instances stock prices fluctuate quickly 
punctuation simply making assumptions contents stream technique stream assumes data source includes additional information stream enable efficient processing 
punctuation predicate tells system input tuples match predicate 
example punctuation received predicate matching tuples received particular date indicate dsms tuples date 
multiple ways implement punctuation 
example niagara query engine punctuation represented data consisting series patterns corresponding tuple attribute 
patterns defined niagara 
name pattern match condition wildcard true constant range list 

empty false illustrate consider stock market example represent stream xml tuples form ticker example similar published www cse ogi edu html 
time time symbol symbol price price exchange exchange ticker xml data represent punctuation matches quotes symbol ibm exchange nyse time ticker time time symbol ibm symbol price price exchange nyse exchange ticker dsms system receives punctuation assume receive matching tuples 
signal calculate average prices time period output results 
general notion punctuation gives robust language describe stream 
provides way data source assert properties stream requiring system assumptions observations 
disadvantage course relies external sources generate 
windowing operators recall query section return sells ibm minutes stream infinite computable qualify query limit scope way 
limitation stream finite subset commonly referred window 
modifier minutes serves purpose 
notice query executed continuously meaning phrase changes time 
really specified series windows moment time applying window stream lead sequence tables wt results query reflect sequence sql queries select wt symbol ibm buy sell sell conceptually sequence wt result applying windowing operator stream 
may view sequence wt series snapshots finite time varying buffer tuples 
notice discussing window operators clear distinguish window operator particular window contents window applied particular stream 
example window operator minutes 
specifies series individual windows 
applying window stream give set tuples corresponding trades 
general window operator specified predicates determine tuples added buffer tuples removed buffer times specific snapshot wt passed subsequent processing 
addition order produce semantically coherent sequence tuples output operator parameterized intuitive manner 
section discuss windowing operators general specific windowing operators commonly implemented 
fall general categories tuple time value windows 
tuple windows simplest case window tuples 
window time includes tuples timestamp excludes logical timestamp maximum logical timestamp set 
snapshot wt window contents passed clock tick 
note choice timestamp logical implicit explicit ambiguous different systems allow different choices 
tuple window provided existing stream processing systems 
example stream uses continuous query language cql express window operator applied stream rows :10.1.1.3.7362
telegraphcq express window st true assumed defined terms logical time contrast aurora independent window operators implicitly specified arguments operators require windowed input aggregate join resample 
tuples window applied input stream aggregate correspond arguments order size advance 
notice aurora allows query access logical timestamp virtual attribute tup 
observe meanings tuple windows slightly different stream telegraphcq aurora 
stream version implicit timestamps system time telegraphcq aurora require extent advance window specified terms single notion time case logical timestamp 
particular stream window specified systems vice versa 
difference observable scenario 
assume series trades decreasing quantity occur sec 
sec slowing sec 
second yielding stream omitted irrelevant attributes 
assuming implicit time granularity seconds cql query select max quantity trades rows st refers time query registered 
input output implicit aurora timestamp quantity stream telegraphcq tuple windowed query initially gives subset results corresponding aurora telegraphcq queries shown 
stream window advances new window defined applied stream create snapshot second stream advances tuple systems 
notice tuples guaranteed unique implicit timestamps snapshots types windows comparable 
time contents stream window changes new tuple arrived contents corresponding telegraphcq aurora window change 
part previous example demonstrates may reverse problem 
systems stream pass identical snapshots window clock tick contents changed new tuples arrived 
example common window operators practice defining predicates window parameterized continuous queries concerned time varying data quite natural 
assume tuples arrive timestamp order difficult specify points take snapshots 
wait guaranteed seen tuples timestamp take tth snapshot 
may able guarantee general tuples approximately ordered tth snapshot time give reasonable approximation 
called timeout parameter represents amount time wait late tuples arrive 
example aurora allows specify timeout value optional argument previous example 
observe previous example logical timestamp contents window non deterministic 
example tuples arrive dsms simultaneously determined logical timestamp 
assigned internally dsms user perspective chosen randomly 
time windows alternatively wish specify window tuples minutes 
assume implicit time measured dsms clock granularity seconds 
window time include tuples timestamp exclude tuples timestamp depends system time called time window 
note general requires timeout parameter 
type window widely supported 
similar tuple window expressed cql range 
specification telegraphcq exactly conversion minutes seconds long insure defined terms implicit time 
aurora simply change order attribute arguments order ime size min advance sec 
notice aurora provides access implicit timestamp specify units time measurement 
extent advance window measured time units windows generate comparable results systems 
stream may generate duplicate tuples see natural way eliminate duplication systems generate identical streams 
aurora allows windows fixed size stream allows special type window dynamic extent referred landmark window 
operator range unbounded specifies time window opens instant query registered closes time instant clearly expressed telegraphcq st true st apparent telegraphcq specify windows quite generally long open close times computable functions st value windows additionally wish specify window tuples values 
generally specify values ai ai increasing sequence ai 
note stream includes explicit timestamp system allows window operators access implicit timestamp includes time windows 
way obtain value window 
need mechanism knowing may compute value window stream wt 
intuitively want guaranteed tuples interest longer values interval ai ai interval ai ai timeout parameter sufficient tuples approximately ordered specify essentially dynamic timeout parameter values specifying slack parameter means window includes tuples value ai excludes tuples value ai take snapshot see tuple value ai advancing counter note order avoid storing entire stream ai increasing function stream telegraphcq provide value windows aurora provide limited support direction 
example passing aggregate arguments order slack size advance effectively computing sliding window ai 
stream aurora provide additional value windowing constructs 
allow window defined treating sets tuples single tuple 
stream employ dynamic system generated slack parameter ordering stream explicit times described section optional partition 
specification tuple window stream allows count set tuples equal values 
single logical tuple 
optional groupby argument aurora similar effect creating aggregate windows 
windows joins aurora implicitly define window specifications provided stream telegraphcq systems window explicitly tied aggregate operator 
window operation implicitly specified inputs join value precise semantics quite previous examples 
window specification input stream depends values attribute input stream 
specifically join streams aurora requires stream identify attribute approximately ordered corresponding slack specification say respectively 
attributes measured comparable units window stream effectively computed terms magnitude difference view aurora stream join terms applying ordinary join output windowed snapshots input streams corresponding windowing operator take streams input generate sequences snapshots coordinated fashion 
contrast stream telegraphcq apply window operators independently input stream 
windows punctuation may assume stream includes punctuation may define punctuation windows 
may open close windows seeing certain punctuation stream 
approach considerably succinct mentioned far 
single window operator automatically gives rise sequence snapshots 
achieve effect punctuation require sequence stream generate snapshot 
see section punctuation lower level windows directly notify dsms may purge buffer tuples 
window stream operators related windowing reverse problem convert results applying aggregate join operators sequences snapshots back stream 
variety possible approaches 
assuming timestamp values individual results aggregate join defined snapshot wt gives rise set timestamped tuples ot 
may simply concatenate results system time order 
ot ot 
obtain output stream 
large number duplicate tuples produced method may useful consider differences 
ot ot ot ot 
possible take differences reverse order 
ot ot ot ot 
notice tuples ot unordered randomly ordered system placed output queue operator cf logical timestamps 
stream reverse windowing operators called rstream istream respectively 
aurora telegraphcq implicitly istream operator 
sql compatibility suggested example section stream query language cql simply extension sql include windowing operators reverse windowing operators rstream istream 
telegraphcq likewise uses sql language augmented window specifications 
contrast aurora uses novel query language called 
mentioned previous section windowing operators tightly integrated aggregate join operators 
provides basic functionality sql packages functionality quite differently 
provides novel features 
highlight similarities differences 
example sql allows functions applied resulting attributes query select floor quantity trades symbol ibm buy sell sell support different functional expressions large limited 
contrast provides flexible map operator transform attributes stream supports arbitrary user defined functions 
sql provides order clause sort results query respect attribute 
contrast provides operator improves stream degree guarantee completely sorted results stream adheres ordered arrival constraint parameter note implicitly uses tuple window size sql provides clause acts relational select operator 
goes step filter operator 
filter split single stream streams values number predicates 
stateless processing operators naturally fall categories stateless stateful 
stateful operators discussed section 
stateless operators operators maintain internal state 
stateless operator consists function operates tuple time position query network 
moving stateless operator remote location matter moving function network 
filter filter operator similar clause sql 
allows specifying boolean predicate filter incoming stream 
tuple satisfies predicate passed downstream tuple fails predicate dropped sent alternative output 
aurora filter multiple outputs predicate 
filter split stream multiple substreams 
put filter context running example consider military sensors example 
interest saving power decide transmit abnormal data heart rate high low 
filter operator check heart rate tuple forward ones fall outside specified normal range 
map map provides functionality similar select clause sql 
maps input tuples output tuples specified function 
tuple separate function applied field resulting new tuple sent downstream 
continuing military sensors example consider soldier reporting position map 
position sent compressed binary form 
map function convert position report human readable form 
union union merges multiple input streams single stream 
tuples forwarded downstream immediately received 
resulting output order depends precise arrival times nondeterministic 
stateful processing stateful operators considerably complicated compared stateless 
runtime maintain internal state consists tuples meta data 
functions stateful operators execute apply window tuples incomplete windows stored filled 
need store window management data example part window processed 
having internal state creates opportunities sharing results intermediate computations 
aggregates aggregate operator computes composite data stream window partition 
aggregate function takes window tuples produces single tuple window sees 
typical aggregate functions average min max 
stock market example aggregate function order compute average price ibm minute window 
note output aggregate box different characteristics input stream 
output schema include fields input stream 
output stream rate proportional input rate window specified number tuples independent input rate window specified time period 
internal state aggregate exact opposite 
aggregate tuple window compute hard bound internal state need store time window results practically unbounded potential state limited input throughput capacity 
expected output rate input rate ratio selectivity amount stored internal state important issues predicting system behavior optimizing performance 
expected amount internal state stored operator determines amount space required operator serialization 
issue come moving operator distributed system recovering network crash 
depending particular aggregate function internal state may represented compact state 
example computing maximum window chose store largest value number tuples seen point 
drastically reduces stored state limits ways 
data processed operator eliminated changes applied processed stream 
reason meta data share operators 
issues covered detail 
optimizations possible predefined aggregate functions 
easy way reduce internal state aggregate function custom built 
joins join correlates input streams field producing single output stream 
tuples join satisfy join predicate arrive window bound 
output stream type join restricted compared aggregate 
output subset fields input streams join introduce new fields 
case aggregate window specification type allows bound output rate internal state size 
interesting point note join output rate easily exceed combined rate input streams 
tuple potentially join tuple window producing output tuple time joins 
join limited ability eliminate internal state needs store 
tuple old join newly arriving ones falls outside join window may eliminated 
stored arriving tuple may potentially join tuple populating window 
order speed matching process need compute hash index tuples stored join operator 
time single new tuple arrives access tuple respective join window 
sharing stateful operators compute meta data arrange stored data way access efficient 
hash index join inputs probing stored tuples example metadata 
indexing jobs performed allow operators benefit 
capability widespread support existing streaming systems 
instances state sharing considered implementation 
aurora implement indexing tuple queues allow common queue sharing 
queue feeds operator stored 
responsibility aurora engine maintain minimum necessary set tuples queue 
stream goes step supports complex meta data sharing 
example queue simultaneously operators benefit tuple indexing indexing shared 
query engine builds index queue available operators 
operators benefit hash index include join aggregate functions 
integrating persistent storage operations data streams continuously flow newer data replacing old 
nature streaming data transient need permanently stored 
storing data memory disk allows faster access 
result streaming engines discuss utilize persistent storage operation 
persistent storage eliminated completely 
example queries utilize streaming data persistent data disk 
ability analyze historical data similarly ability recover failed query network requires persistent storage 
amount memory tends orders magnitude smaller disk space 
system high data rate processing overflow available memory spill disk 
rollback logging streaming system environment defined notion transaction 
applications content current data gap due failure 
query expected represent current state system meet latency constraints 
example temporary outage military sensor example want current results connection restored 
primarily concerned current needs soldiers stale data pertaining outage period 
critical systems financial analysis systems backup done hot swap server 
primary server performs operations duplicated secondary server takes primary fails 
involved ways achieving reliability discussed 
best fall back checkpoint recreate state 
reason perform rollbacks operators non deterministic irreversible 
order rollback operators record tuple processed 
correctness stream databases focus traditional acid semantics define clear idea transaction result worth asking valid results come database 
particular correctness defined 
differentiates answer poor answer 
answer different different scenarios 
example scenario soldiers deployed field medic may want monitor sudden drops blood pressure 
historical information doesn matter current information 
user wants soldiers low blood pressure lower values interesting high values 
relational database streaming database designed pass information fulfil users queries 
resource constrained environment deployed soldiers system efficient 
additionally system prepared able keep amount data collected 
current values useful system afford get backlogged 
result heavy load streaming systems may forced produce results amount approximation 
lines earlier question exact answer feasible constitutes best answer 
ideally define user cares ensuring results line user interest 
stream group proposed assigning weights different queries 
prioritizing scheduler decisions ensure interesting queries produce accurate answers interesting queries 
sample specification qos function relating metric utility aurora flexible approach taken user provides definition quality service 
quality service qos defined set relationships parameters outputs usefulness utility 
qos definition may rate outputs useful allowing system decisions encourage results reach output 
manner simulate assigning static weights query assigning constant weights values outputs 
additionally expressive say larger values interesting smaller ones express high latency acceptable queries 
qos formally defined function mapping metrics utility 
returning example medic asking low blood pressure define qos definitions provided aurora 
shedding load obviously impact accuracy output queries 
shedding load result high latency bursts data queued processed completion 
results inherent trade accuracy latency 
allowing user define utility function latency user tune tradeoff aligned interest 
notion qos extremely powerful descriptive defining parameters output direct useful approach easily utilized 
earlier execution plan changes shed load effective changes 
difficult reason data backwards operator 
needs able decisions early stream 
decision harder reason impact changes final result 
result proposed qos better defined incoming streams making easier determine data valuable 
actual mechanics data selected sampled dropped covered resource management 
resource management resources important challenge database management systems optimally utilize resources order maximize performance time balancing factors recoverability reliability 
remains true streaming databases different emphasis 
streaming databases deal push sources feed streams continuous query registered system 
usefulness result depends quickly produced 
means minimizing latency maximizing throughput typically important making highly desirable minimize cpu memory usage 
techniques accomplish range shedding tuples order reduce load system scheduling operator queues order optimally reduce amount tuples needed system 
techniques load shedding fundamentally affect accuracy query essence changing 
necessary develop approximation techniques measures performance balance performance versus accuracy give guarantee certain level accuracy 
nature applications dsms lends distributed implementation resources power network bandwidth considered 
example think dsms composed thousands small sensors relatively small battery life military example 
reduce amount bandwidth streams sensors distributed dsms may slide operator sensor level 
may conserve bandwidth additionally reduce load dsms sensor level may put additional power strain sensors 
introduces additional level complexity non distributed case various needs component system considered managing resources 
operator scheduling conventional dbms queries run datasets finite change queries executing 
goal query optimizer systems usually minimize average time required execute query 
streaming data system queries run indefinitely process datasets constantly growing 
system schedule execution query operators intelligently backlog tuples operators may exhaust available memory 
mentioned conserving memory important stream system reduces demands system resources 
dsms intelligent operator scheduling critical effective resource management 
just create bunch threads 
na approach operator scheduling create single thread execution operator stream manager 
advantage approach implementation simpler modern operating systems sophisticated mechanisms scheduling execution threads 
creating thread operator problem scheduling essentially delegated operating system 
problems approach 
problem doesn scale 
data stream application contain thousands query operators 
operating systems handle arbitrarily large number threads 
operating system handle large number threads able switch efficiently 
thread scheduler may scan active threads performs context switch 
case time complexity thread scheduler linear number threads 
large number threads time overhead required scheduling unwieldy 
second problem na approach operating system isn aware quality service qos requirements application 
example consider stream queries running military sensors application 
queries plain english follows query minutes report average foot speed soldiers unit 
query report id number soldier health risk 
obviously latency requirements stricter query query operating system responsible scheduling tend allocate roughly equal amounts processor time operator 
needed centralized scheduler information qos requirements queries system 
third problem na approach operating system doesn know stream operators manage resources effectively 
custom stream scheduler hand certain types information minimize total resource usage 
techniques doing described section 
scheduling algorithms scheduler dsms take advantage types information minimize resource usage 
type information non linearity processing time operator 
operator may able execute efficiently processing input tuples batches trains 
reason order execute operator system perform certain tasks directly related function operator 
task fetching tuples processing 
task switching operator 
amount cpu time required tasks tends linear function number tuples processed 
processing tuples trains system reduce time cost tuple 
turn reduces memory usage time input stream tuples accumulate operator queues 
second type information scheduling algorithm exploit selectivity operators 
operator selectivity number tuples outputs period time divided number tuples receives period time 
selectivity operator produces fewer tuples consumes 
usually case selection filter operators 
selectivity greater operator produces tuples consumes 
true join operators 
practice selectivity estimated value various heuristic techniques 
selectivity account scheduling algorithm reduce memory requirements stream application 
example consider query streaming data application 
query consists operators 
operator selectivity operator selectivity 
assume time cost tuple operators 
scheduling algorithm didn consider selectivity process tuples operator move operator different query 
tuples left waiting queue operator operator 
number tuples queue twice number input tuples processed operator 
executing operator stream manager increased total number tuples system 
input stream operator queue operator queue operator operator selectivity selectivity operator queue simple query 
scheduler optimize resources account selectivity operators 
better approach treat operator operator single unit pipelining output operator operator 
combination operators effectively creates new operator selectivity 
advantage combined operator selectivity produces fewer tuples consumes 
words combined operator time slice tend reduce total number tuples system 
technique combining operators selectivity called chain scheduling 
dynamic tuple routing far assumed query plans static 
requirement 
possible stream manager reorder operations fly queries executing 
advantageous streaming data application queries run indefinitely stream properties change time 
telegraph system dynamic query optimization accomplished modules called eddies 
role eddy route tuples various processing modules routing policy 
processing module tuple system estimates benefit cost sending tuple module 
eddy decides send tuple cost benefit analysis 
current progress tuple specifically operations performed far stored tuple 
operation benefit significantly dynamic routing join 
typically join data sources implemented follows tuple probe matching tuple match output tuples 
dynamic routing join operation decoupled symmetric operations called half joins 
half join operates single stream 
telegraph half joins implemented modules called state modules stems 
stem accepts types request tuples build tuples probe tuples 
stem receives build tuple adds tuple lookup table 
stem receives probe tuple outputs tuples lookup table match probe tuple 
join implemented eddy route input tuples stem 
shows join operation implemented telegraph system 
advantage telegraph approach flexible scheduling input tuples routed stems order 
stem busy system decide run time route tuples stem 
stem stem build probe match eddy match input input probe build output join implemented telegraph system 
constraints punctuation performing continuous aggregate join queries streams require prohibitive amount state stored may require system block compute results query 
possible store state disk performance reasons desirable memory 
memory far limited disk techniques employed limit amount state stored 
dsms produce results timely fashion blocking undesirable 
devices constraints punctuation employed handle time space issues 
mentioned section constraints measure degree data ordered clustered attribute single stream degree streams correlated joining 
constraints may enforced user query may inferred system observing stream time 
example slack parameter aurora value window may viewed parameter ordered arrival constraint 
tuples adhere constraint simply dropped 
stream satisfies constraint give exact results 
degree fails adhere constraint results approximate 
pointed section constraint serves allow aggregate computed window blocking 
mentioned section stream timestamp orders streams entry system 
non blocking manner limited memory likewise utilize ordering constraint 
aurora collects statistics stream dynamically estimate appropriate value may lead degree approximation input constraint buffer output ordering stream ordered arrival constraint 
controlled system space limitations 
example shows stream approximately ordered ordered buffer size 
similarly clustered arrival constraint limits buffer processing grouped aggregate 
example assume stream pushing tuples schema time symbol price exchange adheres clustered arrival constraint time 
assume average stock prices calculated daily basis currently tuples time streamed 
tuples arrived time assumed tuples time average computed state flushed 
section indicated punctuation limit computation 
punctuation part stream query operators extended specify handle punctuation 
particular operator know time state purge pass partial results 
niagara implements allowing definition pass purge propagation rules 
specifically pass defines results passed purge discards state propagation determines punctuation passed additional operators 
approximation techniques consider dsms total memory units accepts incoming tuples rate second 
processed dsms tuple consumes memory unit 
means dsms hold tuples memory time 
takes seconds process tuple start finish see problem definitely arise 
tuples arrive twice fast processed 
condition memory eventually saturate dsms longer able handle incoming tuples 
addition input overload imagine query processing resource bottleneck 
example take query selects distinct ticker symbols trades stream involved shares 
select distinct trades qty interesting query order select distinct trade tuples dsms need remember tuple seen 
tuples accumulate operator queues available memory exhausted 
finite system resources saturate face infinite data stream 
mitigate potential harm similar situations may cause dsms approximation techniques 
degrade system performance respect providing user application results close completely accurate 
provide approximate answers queries 
subsections delve prevalent approximation techniques describe details 
load shedding easiest way dsms deal resource bottleneck simply disregard certain tuples 
referred load shedding 
example tuple overload scenario described dsms choose ignore incoming tuple 
guarantee tuple load line system resources 
implementing load shedding strategy main questions answered 
probably important shed load 
regard options 
dsms shed load deterministically random 
input tuples relatively uniform simply dropping tuples random suffice load shedding solution 
referred sampling data stream 
wide variations data values dropping tuples random significantly skew approximation 
illustrate distinction military sensor example application 
suppose body temperature sensor sends tuples hub worn soldier minute 
tuples form sensor type sensor id time value 
job hub forward tuples intermediate station forwarded medic 
case soldiers squad sending tuples intermediate station 
intermediate station located running battery power 
body temperature generally constant station decides sample body temperature tuples receives 
randomly selects tuples minute forwards medic base station 
imagine soldiers wounded 
body temperature suddenly vital statistic medic call want observe possible body temperature values soldiers squad 
danger wounded soldiers body temperature tuples potentially sampled stream station 
situation worsen tuples wounded soldier sampled course consecutive minutes 
potentially life saving information disregarded 
clearly sampling sensitive extreme sudden changes data stream values 
contrast dropping tuples random deterministic load shedding filters tuples values fall outside specified range 
continuing body temperature example save battery power decide forward tuples values fall outside range 
idea medic really needs receive information things go wrong 
hub drop body temperature tuples arrival value falls save battery power 
example may bit contrived illustrates basic point 
nature streaming data considered determine effective load shedding strategy 
single chain operators balanced query processing tree issue address deciding shed load 
dsms able detect system overload react accordingly 
straightforward way statistics 
test run dsms gather profile system resource statistics heavy load 
define value represents buffer maximum operational conditions complete resource saturation 
dsms value live environment determine close overloaded 
example assume tuple load processing times available memory cpu resources dsms define cost function uses function identify optimal operating conditions occur value complete system saturation occurs value range values live environment current operational costs approach breach range dsms proactively shed load degrade performance qos expectations 
third aspect load shedding policy decided finding best location query processing tree shed load 
involves tradeoff processing cost query accuracy 
shedding tuples early avoids wasted processing 
undesirable tuple operated early query processing tree dropped farther line 
hand dropping tuple early adversely effect processing 
especially true operator fan high 
fan refers number operators immediately follow operator query processing tree 
tradeoff best illustrated example 
consider 
tuple arrives operator processed sent processed sent similarly situation tuple dropped best enters operator saving cost performed operators 
consider 
single operator chain immediately follow root separate query processing tree 
fan operator 
dropping tuple leaves adversely impact answer provided trees rooted general rule farther query processing tree tuples dropped account impact subtrees better 
final component load shedding policy determining tuples drop 
case random drops means deciding percentage tuples dsms sees disregard 
case deterministic load shedding amounts linking percentage tuples filter predicate 
case answer usually application specific depends stream rates query processing costs available system resources 
histogram means approximation available dsms histogram 
histogram summarization technique capture data value distribution 
formally stream property stream histogram distribution 
vn fn vn represents value fn represents frequency value 
put way domain partitioned number buckets bucket stores summary value distribution 
varying number buckets vary granularity approximation 
types histograms considers specific type demonstrates dsms 
equi width histogram number possible values partitioned buckets bucket value range 
example assume stream reports rate squad soldiers course hours involved combat 
tuple sent hub worn soldier intermediate station seconds 
rate vital heart rate blood pressure approximated peak load 
easy assume range reported rates 
divide range buckets bucket contains values 
bucket store reported frequencies values second 
bucket stores boundary values sum frequencies values 
consider list bucket number left represents rate number right reported frequency course hours 
boundaries bucket 
query select count value value value overloaded dsms bucket provide approximate answer 
computes total frequencies appropriate bucket case 
assumes equal distribution frequencies bucket members 
values 
clearly correct answer serve rough estimate 
worth mentioning addition equi width histograms equi height optimal max diff histograms 
space considerations details algorithms omitted timeout imagine query computes average rate squad soldiers members 
query executed wait member squad report rate executing 
optimal conditions sensors worn tuples emit rate seconds 
rate dsms execute query twice minute 
happens sensors worn soldier fails 
dsms tuples blocked waiting th 
dsms block forever final tuple may arrive 
precisely reason need timeout mechanism apparent 
described earlier timeout parameter time windowing operation maximum period wait late tuples arrive 
window operation emitted result tuple time dsms execute query tuples currently disregard tuple belonging computation arriving 
timeouts query processing clearly provides dsms tunable approximation parameter 
see consider query registered intermediate station computes average rate soldier half hour 
select avg value range min timeout min stream sends rate tuple individual soldier intermediate station seconds 
assume soldiers separated unit period minutes 
separation causes soldier tuples duration lost 
timeout min clause query tuples arrived intermediate station remain additional minutes 
consume space memory waiting lost tuples arrive 
imagine timeout value query set 
minute window expired dsms immediately execute query releasing tuples destination 
counteract system overload save memory dsms decrease timeout values window operations 
slack related timeout notion slack 
slack bound disorder expected stream 
measures far place data item correct position 
instance suppose tuples fictional stream arrive dsms tuple integer field slack value stream set values places order 
similar ordered arrival constraint described earlier 
timeout higher slack value resources needed accommodation 
conversely slack whatsoever allowed resources conserved tuple arrives order simply disregarded 
imagine series trade tuples arriving dsms ibm nasdaq ibm nasdaq ibm nasdaq ibm nasdaq ibm nasdaq ibm nasdaq ibm nasdaq tuple familiar schema time symbol price exchange 
addition consider query select avg price trades range min symbol ibm slack slack value tuple arrives dsms free compute average stream result 
tuple arrivals listed result approximation tuples included computation 
clause query changed slack tuples included computation 
means held operator queue main memory longer period time 
reductions simply reducing size window operation form approximation 
computing average window tuples time span seconds reduce window size tuples time seconds 
allows dsms hold fewer tuples memory obviously represents comprehensive precise calculation 
window size timeout slack query constructs generally specified users applications represent stress relief points dsms 
consideration qos requirements overloaded system proactively manage constructs step graceful performance degradation 
performance measurements attempting develop set performance evaluation criteria data stream management system problematic 
metrics valued systems application dependent 
subsection explores criteria common dsmss discusses specific situations applied 
linear road basic measure performance system exhibits behavior characteristics dsms 
software system support continuous queries windowing operations really dsms 
exactly role linear road benchmark 
defined researchers mit linear road hypothetical road traffic management system measure performance data stream management systems illustrate performance matched traditional dbms re engineered handle streaming data 
briefly linear road application uses variable adaptive real time computation vehicle tolls traffic conditions regulate vehicular traffic system highways 
vehicle equipped sensor continuously relays position speed central server 
server aggregates information received vehicles highway system computes tolls real time transmits tolls back vehicles sensor network 
evaluate performance responsiveness implementing software system linear road specifications state run single processor linux box 
number highways scenario increased system longer keep input data stream 
output software system number highways run scenario 
terms performance linear road specifies metrics implementing software system adhere 
set acceptable outputs 
set queries defined benchmark various tuple loads system produce correct output correct format error bound 
second metric set quality service requirements queries 
qos requirements simply response times exceeded 
information linear road visit www cs brown edu research aurora linear road benchmark homepage html quality service way measure dsms performance considering quality service 
stated previously quality service specifications measured number ways including response times tuple drops accuracy 
qos viewed perspective application user perspective 
just seen linear road benchmark system design qos set standards aspects dsms apply 
considering qos user application point view things bit concrete 
nature application really defines qos requirements 
example stock market example application strict requirements regarding tuple drops accuracy latency 
specifically tuple drops intolerable accuracy close possible little latency 
hand due uncertain nature streaming data remote military triage application qos requirements relaxed redefined 
tuples definitely lost load vary sensor batteries die bandwidth insufficient 
type unpredictable environment left users application define reasonable performance requirements 
regardless application easy see performance dsms judged user defined qos expectations 
throughput latency throughput dsms refers speed tuples processed 
general throughput comparison metric tuple load queries data may compare relative throughput dsmss 
related idea throughput latency 
latency dsms responsiveness 
tuple arrivals dsms operator latency measure long take produce result 
latency throughput measure speed important note difference 
latency measure amount time start action completion throughput total number actions amount time 
illustrate difference suppose different operators compute average 
operators resides separate dsms 
operator system computes average tuples takes seconds 
operator system computes average tuples takes seconds 
effectively operator system computes average tuples second throughput tuple stays operator seconds latency 
contrast operator system computes average tuples second tuples leave operator sooner seconds 
fluid non blocking nature dsms latency better gauge system performance throughput 
infinite streaming data sources responsiveness system key 
better know answer approximate answer query soon possible processing greater number tuples time period 
accuracy final performance metric discuss accuracy 
described section dsms system produce results consistent current load 
system ample resources process incoming tuples tuples arrive anticipated rates reasonable expect perfect answers 
described case 
dsms approximation techniques conserve system resources distort accuracy query results 
accuracy query answers considered context system load 
answers accurate indication problem system 
just stated dsms overloaded 
bottleneck 
system resources 
query processing module holding things 
hand problem data sources 
streams failed outside interference increased transmission latency source 
short query accuracy serves prominent metric user application gauge dsms performance 
distributed operation settings point detailed design architecture aspects data stream management system 
done assumption system components reside machine 
small scale streaming applications may suffice larger applications require resources machine provide 
example need group machines acting concert handle query processing load 
want remotely deploy aspects dsms perform specific task small group related tasks 
imagine wireless pc pda allows users query system filter tuples 
general types environments distributed dsms architecture clustered server wide area wireless 
course distributed architecture combine environments 
environments examined detail 
incorporate diverse participants physically connected stream processing nodes aforementioned wireless devices networks sensors provide input streams 
clustered server clustered server environment group machines operating single domain 
may take number forms assumption traditional shared architecture duplicated high performance disks processors connected high speed communication link 
essentially distributed architecture single point failure 
characteristics clustered server environment worth noting 
single node dsms system administrator access control entire distributed environment 
free configure optimize system way chooses 
case wide area wireless environments 
secondly clustered server environment uses distributed query plan 
distributed resources process queries query plan partitioned nodes 
gives rise interesting challenges regard load sharing operator splitting shifting tuple routing 
clustered server environment coordinator node maintains global view system state 
allows act intelligent load balancing mechanism routing tuples machines load query processing requirements system 
wide area distributed resources provided clustered server environment address needs larger streaming applications class applications sufficient 
streaming services weather forecasting road traffic management gather process data different autonomous domains handled clustered server dsms 
specifically clustered sever dsms suited coordinate resources query processing organizational administrative boundaries 
general imagine federated dsms participating organization contributes modest amount computing communication storage resources 
allow high degree resource multiplexing sharing enabling large time varying load spikes handled 
helps improve fault tolerance resilience denial service attacks 
meant wide area environment 
distributing stream processing nodes single domain distributed domains 
distributing processing fashion pose problems 
chief coordination 
wide area dsms incorporate heterogeneity systems resources motivations process query 
note inclusion motivations previous sentence 
performance system resources participant acceptable participants participants need sufficient motivation process portions queries 
put way participating system organization reason process query portion thereof receive benefit result 
additionally performance reasons applications may want queries processed specified set acceptable domains 
see example stock market application 
stated section application strict performance requirements 
reason want system requirements lower process parts queries 
increase latency times 
introduce tuple loss bursty data flow completely unacceptable nature stock market application 
wireless stepping away physically connected world dsms deployed remotely 
exactly situation military sensors example 
soldiers wear sensors monitor vital statistics hubs communicate stations vehicles 
vehicles modified pda pc allows receive tuples run queries 
instance want filter tuples report normal vital statistics forward tuples squad members vital statistics fall outside specified range 
single limiting resource working wireless environments power consumption 
nodes deployed remotely run battery power 
definition battery limited lifespan storage capacity 
simply transmitting receiving bytes information nodes diminish power supply 
conserve battery power nodes want send receive information little absolutely necessary 
power conservation techniques addressed greater extent section 
challenges benefits distributed environment come new set challenges 
foremost issue scalability 
continual heavy load easy integrate new resources system 
distributed dsms accommodate geographically disparate systems 
issue administrative scalability 
distributed dsms administratively scalable 
dsms fact scale questions distributed resources immediately arise 
concern particular load balancing 
distributed dsms define policy balance load nodes 
respect take account load balanced entire system locally group nodes 
distributed dsms define load balancing semantics 
option move operators overloaded machines idle ones 
incur high communication cost translate wide area environment 
alternatively distributed dsms employ similar rpc providing nodes api instantiate remote operators help query processing 
dsms want replicate functionality nodes split streams re route tuples 
qos specifications difficult define single node pose significant challenge distributed setting 
specifically difficult ensure qos output streams interior intermediate operators unaware qos guidelines 
difficulty increases trying reason qos administrative domains 
considering distributed architectures issues correctness reliability addressed 
transactions define correctness dbms determined op op op op op op machine machine op op op op op machine op op machine examples moving operators 
dashed lines indicate operator moved 
case dsms 
transient nature dsms blocking time requirements transactions preclude inclusion 
eventually machines fail 
policy established handle eventuality 
includes exploring recovery re incorporation mechanisms failed machine 
deploying dsms wireless environment presents challenges 
previously mentioned processing algorithms modified account power conservation 
related issue sensor failure temporary disconnection obviously impact tuple routing query processing 
sections follow delve detail specific approaches addressing aforementioned challenges 
load sharing describes techniques distributed dsms employ balance load nodes system 
load sharing mechanics moving operators common implementation decisions order perform kind operator migration 
need sort protocol specifies perform operator migration nodes 
develop heuristic determine move operators 
heuristic global information local information 
related issue moving single operator lightly loaded machine want machines operate parallel 
dsms heuristic decide move operator 
define boundary operator operator lies directly attached input stream node directly linked output stream node 
example machine operators 
simple strategy node ask neighbors take boundary operator node overloaded 
local uses neighborhood information information system operators load 
appeal truly distributed rarely optimal 
strategy employ planner node collects statistics nodes network decisions relocate operators accordingly 
centralized introduces single point failure yield better plans information available 
move operator dsms perform steps 
nodes agree move operator node 
node start buffering stream 
second node pack operator interchange format xml aurora send receiving node 
operator state complicated issue discussed 
receiving node set operator sending node start sending contents buffer processed 
upstream node notified start sending tuples receiving node original node 
step needed operator occurs boundary 
show different operator movement scenarios 
scenario move boundary operator adjacent machine second move interior operator machine incurs higher bandwidth costs send queries machine receive results back machine 
stateful versus stateless operators moving operators maintain state requires additional consideration stateless case 
simplest situation state maintaining operator moved entirety node requiring state transferred 
cost terms bandwidth memory moving state factored rebalancing decision 
complex situation splitting stateful operator multiple nodes middle continuous query 
require moving specific portion total state 
natural application computation aggregate combination groupby clause 
example computation average price stock grouped symbol 
balance load average computation particular symbol ibm split node 
require state associated average aggregate particular group moved 
current implementation special operator allows rebalancing stateful operators called flux fault tolerant load balancing exchange 
operator provides data partitioning buffering reordering deal short term local imbalances online partitioning lookup operator state handle long term system wide imbalances 
central functioning flux operator repartitioning mechanism divides state operator numerous smaller partitions 
allows finer control rebalancing state movement helping reduce chance thrashing 
operator splitting load sharing run operations parallel 
particular need able take operator machine split copies means divide stream smaller streams feed operators 
merge output filter splits filter filter filter example filter split 
operators 
process implemented aurora called box splitting 
difficulty doing lies modifying operator network altering intended meaning 
complicated operator state associated 
ideally output pair split operators merged identical output single operator 
issue address split stream smaller disjoint streams 
start add filter output stream tuples satisfy predicate second stream tuples don satisfy predicate 
predicate application specific 
predicate provided system time stamps places sequence numbers tuples 
predicate fine machine computing half query split 
different machine loads upstream operators affect traffic pattern data coming filter 
designing optimal filter non trivial 
second issue merge output streams split operator 
simple filter union sufficient 
aggregates complicated operations performed 
furthermore merge operations vary depending operator splitting 
issues deciding move operators apply box splitting 
shared state distributed environment sharing data operators introduces additional complexity 
uncommon operators working input stream 
single system environment possible encapsulate stream table structure share data operators require 
operators balanced multiple nodes distributed system input tuples state stored locally node may need accessed nodes 
mean replicating tuples remotely accessing tuples nodes required depending resource management needs 
require extensions aurora shared queues stream synopses deal complexity distributed environment introduces 
bandwidth considerations transferring state machines bandwidth limitations taken consideration 
node overloaded due insufficient outgoing bandwidth 
case remedy requires significant bandwidth situation worse 
want wait load shedding mechanisms kick resolve situation 
optimizer decides state movement necessary streaming engine take bandwidth 
rely load maintain reasonable latencies getting rid traffic 
union bandwidth link individual nodes serves single union box 
multiple streams merge spread cross link 
know exact link capacity cost sending individual tuple size 
power management tinydb consider streaming sensor model wireless sensors soldiers wear 
model problems power consumption arise 
remote wireless sensor network system limited power perform tasks located infeasible frequently change batteries 
sensors power drained days constant smart techniques power management sensors months years 
berkeley tinydb handles streaming data different way previously discussed dbmss 
utilizes query processing order minimize power consumption 
tinydb sensor nodes modes life mode power consumption minimal sensor just waiting timer external event processing mode query results generated locally processing receiving mode results collected node neighbors transmitting mode results query delivered node parent 
tinydb concepts common dsmss allows user defined aggregates landmark queries sliding window queries 
disallows blocking operations windows 
mode system gives rise different set challenges 
having constantly streaming data sensors append new tuples sample intervals epochs query 
select nodeid temp sensors sample interval says sensor report id temperature readings second seconds 
event queries tinydb allows event queries system starts processing query ends query certain event occurs 
bounds microprocessor technology allows sensor dormant needed 
lifetime queries feature tinydb stems desire get information possible requiring certain sensor life query specifies network run days sampling quickly possible fulfilling lifetime requirement 
tinydb performs lifetime estimations sensor network knowledge power consumption 
knowing time node transmitting node mode needs able transmit user required lifetime 
select nodeid accel sensors lifetime days semantic routing trees limit required processing time sensors tinydb system ordered semantic routing trees semantic similarity reliable connection 
see exactly semantic routing tree built see 
nodes time synchronized parent asleep child transmitting data 
prioritizing data delivery network ready deliver tuple tinydb desires result sent improve quality answer user sees obvious correlation previously mentioned quality service 
tinydb considered prioritization schemes decided delta scheme tuples assigned scores point time tuple highest score delivered 
queue overflows tuple lowest score dropped 
global vs local distributed system load balancing policy may global local 
global policy load balancer uses status available nodes 
local policy nodes partitioned smaller groups consisting node group nearest neighbors 
calculating implementing redistribution workload factors consider cost communication additional messaging required gather necessary statistics 
cost synchronization delay necessary synchronize entire system 
operations frozen order migrate node 
optimality increase efficiency system 
local optimization 
local optimizer may shift operators neighboring machines 
machine experiencing overload communicate neighboring upstream downstream sites attempt migrate operations 
costly terms communication synchronization 
immediate neighborhood sufficient resources resolve bottleneck overload persist 
global optimization 
global policy able consider status nodes network produce optimal re distribution 
cost communication machine system high 
additionally significant migration operators causes greater delay implementing new policy 
practice system may employ load resorting costly global balancing bottleneck resolved local balancing 
qos management qos management distributed systems provides challenges dsms 
qos generally specified respect output streams ones user receiving 
operators irreversible non deterministic reasoning qos throughput query network difficult 
example change applied input stream reversed cancelled downstream operators 
reasoning qos single node difficult distributed system lot complicated 
distributed system qos specified output 
intermediate nodes qos specifications 
addition trying push qos input single node provide derived qos upstream nodes guideline 
derivation introduce uncertainties performed 
different qos measurements user care latency throughput value 
measurements increasing challenges dsms 
latency additive measurement 
change latency nodes reflected change latency 
throughput reasoned way latency changes different places network different effect 
throughput change cascade way output 
value changes unpredictable effects downstream depending operators 
easy way tell result value change downstream node 
reliability correctness criteria time critical nature streaming data applications reliability usually key concern 
especially true distributed stream manager computing node inter node network path point failure 
considerations reliability 
correctness 
distributed stream manager means system allow hardware failure latency cause incorrect answers returned 
unfortunately requirement difficult define precisely clear particular answer correct 
second consideration availability 
ensuring high availability means maximizing percentage time system operational 
world traditional databases correctness usually defined terms transactions 
transaction sequence update operations user wants treat single operation 
responsibility dbms appear user transaction atomic meaning effects transaction applied aren transactional model correctness criteria dbms defined follows 
results query executed dbms show effects uncommitted transaction 
conversely query executed dbms reflect effects transactions committed far 
furthermore effects committed transactions transactions executed serial order 
unfortunately notion transactions easily adapted world streaming data systems 
problem semantics input data different 
traditional database application typically sense user group sequence operations form single operation 
streaming data application semantic model usually doesn sense 
example consider application input stream sequence stock prices 
isn really natural way group multiple stock prices single unit 
alternative treat tuple transaction 
approach creates set problems 
input tuple transaction stream manager process tuples order violating serializability constraint imposed transactional model 
order tuples input stream usually significant approach impose sufficiently strong correctness constraint 
problem transactions streaming data application queries operate data constantly changing 
traditional database application underlying data query change query running 
queries stream application run indefinitely system able process updates query running 
reason transactional model streaming data application 
general major obstacle defining correctness criteria streaming data application temporal variability input 
transactional dbms system guarantees transactions executed serial order 
generally sufficient relatively orderings possible 
example transactions submitted time orderings possible streaming data application tuples entering system different streams assurance related tuples arrive time 
causes stream operators non deterministic 
example union merge operator outputs tuple received input streams 
order tuples operator depends entirely arrival times tuples input streams 
operators non deterministic difficult define correct answer stream query 
problem non determinism complicated fact application qos constraints usually require query results returned timely manner 
constraints cause load shedding occur turn change answers queries 
correctness criteria allow possibility approximate answers 
high availability traditionally high availability fault tolerance achieved process pairs model 
redundant server kept synchronized event failure second server continue synchronization point 
non acid nature systems may able take advantage simpler recovery scheme 
simplest requires synchronization follow policy amnesia 
systems older values important sensor systems doesn need worry reconstructing state information lost server 
applications sufficient eventually correct values generated bounded amount time failure 
alternatively take advantage streaming nature systems 
aurora example queries distribute multiple servers working piece stream feed new stream subsequent server 
buffering data streamed server utilize information resume seamlessly 
downstream server fails operations server migrated new buffered tuples replayed reconstruct lost state 
similar way telegraphcq achieves fault tolerance additions flux operators servers 
flux responsibilities load balancing fault recovery 
partitioning dataflow operator includes state movement protocol 
migrating load recovery fault flux operator migrate state server 
case failure partitioning reconfigured data failed node redirected available 
reliability recovery fortunately significant amount analyzing reliability cousin main memory databases 
referred realtime systems operate exact way disk resident databases standard database management system qualifications mmdb database reside main memory able achieve significantly higher throughput 
suffer problems data held volatile storage susceptible loss way data held stable storage systems 
elements providing reliable system event failure logging checkpointing recovery 
logging commits workings database disk 
checkpointing periodically stores parts database stable storage 
recovery procedure log checkpoint bring database back online 
recovery schemes built transactions need significant conceptual reworking theory apply data streaming 
practically feasibility modification depends specifics sdms system 
throughput rate incredibly high overhead induced forms reliability control significant 
tightly integrated interface persistent storage due transactional nature research needed interface persistent storage concluded techniques safely copied 
daniel abadi don carney gur mitch cherniack christian convey lee michael stonebraker tatbul stan zdonik 
aurora new model architecture data stream management 
vldb journal august 
arvind arasu babu jennifer widom 
cql continuous query language semantic foundations query execution 
technical report stanford university october 
brian babcock babu datar rajeev motwani thomas 
operator scheduling data stream systems 
technical report stanford university october 
babu srivastava jennifer widom 
exploiting constraints reduce memory overhead continous queries data streams 
acm transactions database systems september 
don carney gur alex stan zdonik mitch cherniack michael stonebraker 
operator scheduling data stream manager 
vldb conference berlin germany september 
chandrasekaran deshpande franklin hellerstein hong krishnamurthy madden raman reiss shah 
telegraphcq continuous dataflow processing uncertain world 
cidr conference january 
mitch cherniack hari balakrishnan balazinska don carney gur ying xing stan zdonik 
scalable distributed stream processing 
cidr conference asilomar ca jan 
personal communication don carney may 
stream group 
stream stanford stream data manager 
ieee data engineering bulletin 
jeong hwang balazinska alexander gur michael stonebraker stan zdonik 
comparison stream oriented high availability algorithms 
technical report cs department computer science brown university october 
samuel madden michael franklin joseph hellerstein wei hong 
design query processor sensor networks 
acm sigmod conference june 
raman deshpande joseph hellerstein 
state modules adaptive query processing 
technical report ucb csd university california february 
tatbul gur stan zdonik mitch cherniack michael stonebraker 
load shedding data stream manager 
vldb conference berlin germany september 
peter tucker david maier tim sheard leonidas fegaras 
exploiting punctuation semantics continuous data streams 
ieee transactions knowledge data engineering 

