copyright ieee 
published proceedings iwpc ieee computer society press los alamitos ca isbn pp 

personal material permitted 
permission reprint republish material advertising promotional purposes creating new collective works resale redistribution servers lists reuse copyrighted component works obtained ieee 
contact manager copyrights permissions ieee service center lane box piscataway nj usa 
role concepts program comprehension rajlich department computer science wayne state university detroit mi usa rajlich cs wayne edu presents overview role concepts program comprehension 
discusses concept location implementation specific concept located code 
process common precedes large proportion code changes 
discusses process learning domain code prerequisite code reengineering 
notes similarities overlaps program comprehension human learning 

program comprehension essential part software evolution software maintenance software comprehended changed 
fields software documentation visualization program design forth driven need program comprehension 
program comprehension provides motivation program analysis refactoring reengineering processes 
importance program comprehension studied intensely problems unresolved 
earliest results classic theories program comprehension called top bottom theories 
top theory explains program comprehension way programmer trying comprehend program certain hypotheses confirms rejects evidence socalled beacon code 
confirmed hypotheses retained part ieee norman wilde department computer science university west florida fl usa edu program comprehension rejected hypotheses discarded 
bottom theory program comprehension chunking 
chunks parts code programmer recognizes 
chunk specific meaning name 
large chunks contain smaller chunks nested 
programmer pieces understanding program combining chunks increasingly large chunks 
top bottom program comprehension theories complementary combined unified models 
want different view program comprehension rely top vs bottom dichotomy role concepts 
programs larger feasible achieve complete comprehension 
experienced programmers tend needed strategy attempt understand certain specific concepts reflected code 
seek minimum essential understanding particular software task hand 
concepts play important role illustrate case studies summarized 
noted concepts fundamental building blocks human learning perspective disciplines program comprehension human learning intriguing similarities overlaps 
role concepts software comprehension described section 
illustrate role concepts describing process concept location section related case studies section 
section explores problem learning domain code section contains related case study 
section discusses approaches problem section contains summary 

concepts role software engineering processes complete comprehension program unnecessary impossible 
change requests formulated terms domain concepts example add credit card payment point sale system 
important task understand relevant concepts implemented code 
concept location starting point desired program change 
concept location process assumes programmer understands concepts program domain know code located 
example want change external viewer web browser find location external viewers implemented 
understand concept external viewer external viewers browser 
aware simplified definitions concept appear literature 
popular idea concepts equivalent objects object oriented program 
true structured object oriented program class represents concept external viewer credit card opposite true 
concepts program domain trivial class 
example concept payment may implemented single integer class sale having class 
concepts spread classes 
example look feel application user interface implemented classes 
similarly programmers increasingly design patterns typically involve collaborations related classes implement concept 
locate distributed concepts requires locating marking classes participate 
concept going change classes group may change 
simplified notion concept originates birkhoff popular 
definition fixed set attributes concept specific subset attributes 
subsets constitute lattice concepts constitute lattice 
notion cover full range concepts encountered programmer certain cases useful 
aware notion concept involved see discussion 
concept defined perceived regularity events objects records events objects designated label 
working definition concepts units human knowledge processed human mind short term memory instance 
include definition domain concepts familiar user credit card payment related high level design concepts iterator pattern list credit card holders important error conditions user may aware network error validating credit card 
note set concepts particular program fixed 
specification may set additional concepts may added design detailed concepts error conditions may emerge programming 
interesting aspects software maintenance way new concepts emerge software unexpected ways 
lexicon describe concepts may vary users designers programmers maintainers different words describe essentially similar concepts 
concepts important part human learning 
constructivist theory human learning humans actively construct knowledge 
pre existing knowledge extend new facts 
assimilation process new facts incorporated changing pre existing knowledge 
accommodation fits new facts requires reorganization preexisting knowledge 
theory directly applicable program comprehension 
programmers pre existing knowledge process comprehension possible 
assimilate new facts easily fit pre existing knowledge 
faced facts fit accommodate 
programming knowledge components important ones domain concepts implementation code 
gaps knowledge filled program comprehension 

concept location frequently program comprehension programmer understands domain concepts code 
knowledge domain concepts program easier acquire knowledge code 
example word processor user learns cut paste fonts concepts domain knows implementation concepts program 
source knowledge domain concepts user manual 
original knowledge basis learning concept implementation 
domain concepts map fragments code 
process concept location process finds code 
concept location needed change 
change requests formulated terms domain concepts 
example error trying paste text consisting capital letters please correct order required change user find code locations concepts paste capital letters located start change 
concept location traditionally intuitive process greatly facilitated experience programmer 
example software engineering masters students university west florida maintenance project observed experienced students may locate code changed minutes thrash hours know 
experienced students may difficulty explaining exactly answer obvious 
intuition experience fail provide immediate answer programmers systematic locate needed concepts 
widely technique string pattern matching uses similarity program identifiers concept names 
example searching location cut paste programmer may want search identifiers cut cut 
appropriate identifier programmer studies surrounding code decide truly location implements concept similarity names just coincidental correspondence 
full extent concept location established 
concept implemented place identifier previous statements variables statements 
known example string pattern matching utility grep available unix systems technique called grep technique 
spite wide acceptance serious deficiencies 
correspondence programmer name concept identifier code 
homonyms synonyms create problems 
technique fails particularly concepts hidden implicitly code programmer unable guess program identifiers 
intuitive approach grep technique depend heavily hints program original developers 
naming conventions clearly encode domain concepts 
structured program concepts identified code meaningful consistent names 
previously mentioned key problem especially cycles maintenance diverse programmers vocabulary describe software may longer creation 
intuition grep technique useful older heavily maintained code 
difficulties motivated search alternative methods locating concepts 
approach dynamic search method called software reconnaissance 
idea programming concepts selectable execution depends specific input sequence 
example cut paste selectable user word processor select 
selectable program concepts called features 
code implements features executing program twice feature marking parts program executed time second time 
parts near code implements feature 
order find parts executed test cases additional instrumentation statements indicate parts functions branches statements executed added program 
code instrumented test cases run appropriate code feature marked programmer reads relevant code order understand program plans related feature 
lakhotia formalized extended method show adequate test data feature identified grammar program inputs 
technique concept location search static code 
search follows control flow data flow dependencies program components 
typical scenario search goes topdown control flow dependencies described way functionality program summarized top function main top class program 
top class delegates parts functionality classes 
top class implement sought concept implemented classes functions called 
called classes functions specialized usually easy decide contain sought concept 
moving call graph specialized functions classes programmer ultimately finds classes functions participate concept 
origin destination data sought programmer follows data flows control flows 
static search results previous techniques fail sharpened 
employing technique functions classes concept implementation understood functions classes search path 
understanding additional components accurate understanding components participate concept implementation 

case studies concept location performed number case studies concept location try clarify relationships concepts code comprehension 
systematic studies applied static search technique ncsa mosaic web browser 
change request extend mosaic able handle new type audio files 
task locate code type incoming file mapping external viewer determined 
task decomposed subtasks 
subtask find function opens new window 
new window browsing functionality old mappings copied immediately opening 
adopted top strategy started function main steps located function mo open window opens new window 
second subtask find mappings copied 
done window opens document loaded 
continued top strategy starting mo open window steps functions copy mappings 
functions global variables 
needed know values variables come third subtask 
strategy follow backward data flow source values 
ultimately reached variable home location defaults location changes 
location process case study resulted partial comprehension system 
functions mosaic visited code provided sufficient comprehension able locate concept start required change 
case studies dynamic search software reconnaissance technique described previous section 
study intended provide analysis domain concepts appear program user documentation clarify user level domain concepts map code 
system studied analysis part test coverage monitor developed bellcore telcordia 
program approximately lines code raw line count distributed code files header files 
user documentation consisted extensive unix style man page different testable concepts identified 
total test cases written mark code concept 
interesting result shows concepts commonly delocalized code 
table shows concepts code source files indicating maintainer trying understand concept integrate information different distant code fragments 
hand study showed regularities design especially naming functions data may greatly facilitate concept location 
example test coverage tool programs provides users information test set covers functions basic blocks decisions data flows uses 
domain concepts function block decision 
table feature code number files containing marked code number concepts total concepts code places program designed source file concentrates displaying information concept 
file names give important clues concept localization 
file contains function concept named block concept concept uses uses different kinds data flows data flow testing 
variable predicate statement 
variable computation assignment statement 

naming convention obviously letter concept 
similar regularities names functions files 
kind parallel name structure maintainer quickly learn different concepts located 
concepts understood fall quickly place 
presumably regularities designed code allow experienced software engineers successful intuitive approach described section 
obviously methods break regularity broken loosely coordinated design team ill informed maintenance 

learning domain programs software engineering situations programmer knowledge domain incomplete programmer may learn domain program 
process rarer process concept location important especially reengineering 
known legacy programs contain business rules domain information may available 
may algorithms formulas solve problems successfully algorithms formulas recorded code 
example wilde mention legacy system major insurance 
rules calculating insurance subject differing state laws slight variations accumulated years 
variations undocumented discovered analysis system code 
programmers asked reengineer re implement program scratch need knowledge contained old program 
order recover knowledge programmers rebuild hierarchy domain concepts details implementation old program 
methodology described 
methodology starts study user manuals similar documents creates approximate version domain model 
concepts domain located code details studied 
accurate comprehension domain emerges 
comprehension reengineering 

case study learning domain example learning domain code case study reengineering convert program 
convert part geometric modeling system models solid objects primitives triangles spheres cylinders boxes wedges rods 
united states air force uses model impact explosions targets vehicles aircraft convert transforms models triangles required programs 
written fortran consists lines 
convert long maintenance history going back original program 
time ported hardware platforms including cray mp digital equipment vax 
lately convert ported personal computers 
reengineering code desirable prolonged maintenance structure convert obsolete hard maintain 
poor modularity large subroutines 
data held large common blocks referenced subroutines 
control flow tangled large unstructured loops created backward branching goto statements 
obsolete program plans necessary early operating systems 
example batching input output blocks records greater efficiency scratch files avoid overflowing fixed size arrays packing multiple control flags single integer save memory 
program contains valuable knowledge domain great value user 
knowledge preserved reengineering 
step reviewed convert user manual created tentative domain class model 
extracted initial list convert features 
documents represent initial understanding program domain 
step location features code 
dynamic search software reconnaissance 
test cases identified feature feature similar test case feature 
total code parts blocks function entries instrumented 
initial tests covered code fairly typical number functional test set 
common code executed invocation 
study revealed common code convert reads column records geometric model 
remaining common code performs initializations opening files setting parameters analyzing common code located learned details individual features time 
features understood assigned classes domain class model adjusting model necessary accommodate increased understanding application 
example discovered additional features mentioned user manual missed reading error checks 
features added list added corresponding test cases 
final products process included uml class diagram test set descriptions features 
documents starting point program reengineering 

threads research software engineering practice mentioned context concept location 
change impact analysis 
impact analysis long established field software maintenance attempts identify impacts ripple effects change part program may 
possible give complete survey field 
reader referred excellent set papers bibliography 
impact analysis traditionally focused code approaches take account range documents form part software system including specifications design 
case impact analysis blends concept traceability ability trace specification design design code 
impact analysis tool provides traceability information may possible trace specification concepts relevant code 
traceability undoubtedly useful note limitations point view concept location 
maintaining traceability information system life cycle usually requires considerable manual time pressures associated software development maintenance 
second traceability information certainly expressed set concepts perceived specification time 
noted section concept set lexicon describe change substantially life system 
second thread related concept location fault location 
researchers working improved debugging techniques evolved techniques locating software faults comparing execution slices different test cases 
techniques quite similar dynamic search method described section 
fault considered unwanted concept 
possible completely survey fault location literature 
earliest topic cousin instrumented decision decision paths order locate faults seeded pascal programs 
includes 
relationship human learning program comprehension noted 

explored domain concepts role program comprehension 
open problems research 
location techniques mentioned need additional refinement 
static technique program analysis 
open problems static program analysis starting algorithms pointer aliasing discovery hidden dependencies 
software reconnaissance method relies instrumentation recompilation program followed execution instrumented version feature tagged data 
steps may awkward time pressures commercial production environment smoother tool support useful 
interest integrated software tool combine capabilities techniques concept location pattern matching static search dynamic search allow programmer appropriate specific situation 
interesting set problems arises similarity process constructivist human learning program comprehension 
theory human learning conceptual maps describe human knowledge 
speculate approaches applied program comprehension may offer additional interesting insights techniques 
attractive aspect field fact research identification location domain concepts software promises improvements programming productivity time provides significant research challenges 
agrawal horgan london wong fault localization execution slices dataflow tests proc 
sixth international symposium software reliability engineering ieee computer society oct pp 
biggerstaff webster program understanding concept assignment problem acm may birkhoff lattice theory american mathematical society providence ri arnold software change impact analysis ieee computer society los alamitos ca 
brooks theory cognitive processes computer programming int 
man machine studies vol pp chen rajlich case study feature location dependence graph proc 
international workshop program comprehension ieee computer society press pp 
cousin automatic software fault location decision decision path analysis proceedings national computer conference pp 

lakhotia formalism automate mapping program features code proceedings th international workshop program comprehension iwpc ieee computer society los alamitos ca june pp 

gamma helm johnson vlissides design patterns elements reusable object oriented software addison wesley 
wilde casey locating features software reconnaissance case study gte government systems report serc tr software engineering research center university florida gainesville fl march 
horgan london lyu achieving software quality testing coverage measures ieee computer vol 
september pp 

jones harrold stasko visualization fault localization proceedings workshop software visualization may www cs brown edu research contents ht url current january 
jones aitken convert user manual asi systems international fort walton beach fl march koenemann robertson expert problem solving strategies program comprehension proceedings conference human factors computing systems chi acm press pp may 
wilde re engineering transaction systems software maintenance vol 
pp 

lakhotia understanding code analysis experience systems software pp 
letovsky cognitive processes program comprehension empirical studies programmers eds 
soloway iyengar pp letovsky soloway delocalized plans program comprehension ieee software vol 
may pp 

lindig snelting assessing modular structure legacy code mathematical concept theory proceedings international conference software engineering ieee computer society press von mayrhauser vans program comprehension tool requirements industrial environment proc 
nd workshop program comprehension july pp novak learning creating knowledge lawrence erlbaum associates mahwah nj piaget 
construction reality child 
new york basic books 
rajlich program comprehension domain concepts donovan ed proc 
st conference software ergonomics isbn limerick institute technology press 
wilde software reconnaissance mapping features code software maintenance wilde casey case studies software reconnaissance report serc tr software engineering research center university florida gainesville fl may 
wilde rajlich dynamic analysis methodology reengineering fortran published wittgenstein philosophical investigations mcmillan publishing new york yu rajlich hidden dependencies program comprehension change propagation proc 
international workshop program comprehension ieee computer society press 
