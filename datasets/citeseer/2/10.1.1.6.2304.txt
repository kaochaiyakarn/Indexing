system design kahn process networks compaan laura approach alexandru bart ed leiden embedded research center leiden institute advanced computer science leiden university netherlands date paris feb new emerging embedded system platforms realm multimedia imaging signal processing consist multiple microprocessors reconfigurable components 
major problems program platforms systematic automated way satisfy performance need applications executed platforms 
system design approach efficient solution programming problem 
show application written matlab kahn process network specification automatically derived systematically mapped target platform composed microprocessor fpga 
furthermore illustrate mapping approach applied real life example jpeg encoder 

new emerging embedded system platforms realm multimedia imaging signal processing consist multiple microprocessors reconfigurable components 
satisfy performance needs applications emerging platforms leverage task level parallelism microprocessors reconfigurable components run concurrently 
execute application platforms platforms programmed implies writing software microprocessors languages writing hardware descriptions languages vhdl configure reconfigurable components 
concurrency available platforms need program way exploit distributed control distributed memory 
distributed control means individual components platform proceed autonomously time interference components 
distributed memory means exchange data contained communication structure individual components pooled large global memory 
distributed memory control key requirements take advantage new emerging platforms observe imperative programming languages java matlab preferred way write applications execute platforms 
imperative model computation easy reason program single thread control needs considered 
memory global data comes memory source 
precisely single memory single thread control imperative model computation contradictory need distributed control memory 
programming new platform tedious error prone time consuming process 
believe appropriate model computation kahn process network model inherently expresses applications terms distributed control memory 
said applications written imperative model computation 
facilitate migration imperative application kpn specification developed compaan laura approach 
approach allows parts application written subset matlab converted automatically com 
conversion fast correct construction 
obtained processes kpn subsequently mapped software hardware laura 
system design approach centered exploiting kahn process network model characteristics 
approach illustrating map jpeg application written matlab target architecture consists cpu fpga 
design approach consists major steps 
step convert matlab specification jpeg kpn specification 
second step map process hardware fpga whilst remaining processes mapped software cpu 
explain approach detail look kpn model specific characteristics 
kahn process networks kpn model computation assumes network concurrent autonomous processes communicate point point fashion unbounded fifo channels blocking read synchronization primitive 
process network specified sequential program executes concurrently processes 
kpn favorable characteristics kpn model deterministic means irrespective schedule chosen evaluate network input output relation exists 
gives lot scheduling freedom exploit mapping processes hardware software 
inter process synchronization done blocking read 
simple synchronization protocol realized easily efficiently hardware software 
processes run autonomously synchronize blocking read 
mapping processes hardware fpga get autonomous islands fpga synchronized blocking reads 
control completely distributed individual processes global scheduler 
consequence partitioning kpn number reconfigurable components microprocessors simple task 
exchange data distributed fifos notion global memory accessed multiple processes 
resource contention occur 
compaan laura system design approach centered compaan laura tools developed facilitate approach 
compaan compiler introduced developed fully automates transformation matlab code kahn process network kpn specifications 
applications compaan handle specified parameterized static nested loop programs subset matlab language 
compaan consists tools 
tool transforms initial matlab code single assignment code sac resembles dependence graph dg initial nested loop program 
second tool converts sac polyhedral reduced dependence graph data structure compact mathematical representation dg terms polyhedra 
third tool converts process network associating process node 
parallel processes communicate data dependency dg 
laura maps kpn specification hardware example fpgas 
laura tool operates back com compiler 
kpn specification converted functionally equivalent network virtual processors called hardware model 
platform independent step information target platform taken account 
second platform specific information added ip cores hardware model leading network synthesizable processors 
hardware model converted synthesizable vhdl code 
related mapping applications mpeg jpeg codecs target architecture consisting cpu fpga central question hardware software decade 
researchers mapped successfully multi media applications kind platforms systematic way 
retargetable automatically compiles system level applications specified target architecture combined cpu fpga 
compiler exploits instruction level parallelism ilp loops task level parallelism 
loops executed purely sequentially original specification mapped fpga acceleration 
reconfigurable logic processor attached cpu 
processor typically speeds certain instructions cpu 
related mentioned exploits ilp loops mapped fpga runs mutually exclusive cpu 
show systematic automated approach map application cpu fpga way cpu fpga run concurrently exploiting task level parallelism 
efforts mapping applications cpu connected reconfigurable logic fpgas exploiting task level parallelism led approaches related approach 
gokhale developed compiler takes stream application specified streams generates synthesizable hardware fpgas multithreaded software program control cpu 
stream programming task level model csp model computation 
presents approach map applications specified csps platform consists cpu fpga 
conceptually approach differs approaches sense kahn process network kpn model specifies naturally efficiently compared csp task level parallelism stream applications 
uc berkeley project score developed stream compute model virtualizes reconfigurable computing resources compute storage communication dividing computation fixed size pages time multiplexing virtual pages available physical hardware 
specific language tdf specify applications score model 
stream model similar kpn model 
approaches mentioned input application analyzed specified manually terms concurrent task level model computation specific languages stream handle tdf 
time consuming error prone process system designer manually dependence analysis learn specific description language 
contrast approach relies compiler fully automatically derives kpn specifications form applications described common languages matlab 
design flow illustrate design approach centered kpn model computation show integrate tools compaan laura developed system design flow tools order map automatically application target platform architecture 
design flow specific demonstrate evaluate design flow context case study map jpeg application platform consists microprocessor fpga running parallel communicating shared memory banks 
organized way 
give brief description jpeg application target platform section 
followed step step description system design flow section 
section results obtained 
section concludes 
jpeg platform architecture application consider modified motion jpeg jpeg encoder 
chosen application real life application complicated features illustrate usefulness design flow 
traditional jpeg encoders modified jpeg encoder compresses sequence video frames applying jpeg compression frame video sequence 
jpeg motion pictures compression mpeg inter frame predictive coding 
modified jpeg encoder refer jpeg operates video data yuv format process incoming video frame different set quantization huffman tables depending output bit rate accumulated statistics previous video frames 
jpeg encoder application depicted block diagram 
video stream yuv format observed bitrate jpeg encoding jpeg application pci bus microprocessor pentium iv jpeg encoded video stream host interface hw design fifo fifo vp multiplexer fifo fifo vp vp vp memory banks virtex ii fpga adm board target platform architecture block diagrams jpeg target platform map run jpeg application target platform architecture depicted 
platform architecture consists microprocessor pentium iv running windowsnt connected pci bus adm board manufactured alpha data parallel systems 
adm ii board high performance pci card designed supporting development applications xilinx virtex ii series fp gas 
board consists virtex ii fpga memory banks size bit 
mapping system design flow maps application target platform systematic automated way number steps 
illustrate steps mapping jpeg application platform 
central system design flow compaan laura tools shown 
shows applica workload analysis sw implementation kpn yapi code yapi multi threading environment microprocessor bus compiler yapi executable application described matlab compaan compiler library ip cores bank sp bank compaan compiler sp hw implementation kpn subnetwork process sp laura sp synthesizable vhdl vhdl synthesizer fpga target platform system design flow 
tion written subset matlab converted kpn specification compaan 
workload analysis candidate processes specification selected mapping hardware fpga 
remaining processes mapped cpu software 
kpn written particular format called yapi 
standard compiler processes compiled run cpu top lightweight multi threading package 
processes need mapped hardware processed com obtain hierarchical subnetwork 
subnetwork kpn compiled hardware laura tool 
commercial synthesizers obtain bitstream map processes fpga 
communication fpga cpu automatically generated laura 
look various steps detail see apply jpeg application 
step input design flow application described subset matlab 
debugged easily functional correctness application easily verified 
jpeg application started public domain jpeg codec implementation 
extracted encoder part implementation modified obtain jpeg application 
structured jpeg code set routines functions called matlab code shown 
matlab program convenient way describe jpeg application 
program reveal inherent task level parallelism available jpeg due parameter parameter parameter block block dct block block block packets block bitrate packets bitrate task level specification jpeg application matlab 
sequential nature program 
step system design flow convert sequential program executable parallel specification case kahn process network kpn 
general deriving executable kpn specification hand application difficult time consuming 
relay compaan compiler convert fully automatically jpeg matlab program kpn specification shown 
compaan generates kahn process network code chart applications programmers interface yapi 
yapi process modeled light weight thread communicates data threads processes unbounded fifo channels 
channels accessed primitives read write read write data fifo channels 
read primitive blocks execution process current channel process reads data empty 
write primitive non blocking 
blocking read mechanism accomplishes inter process synchronization 
dct quantizer variable length encoding processes form central data flow processing jpeg encoding algorithm 
processes take care quantization huffman tables adaptation 
process receives statistics process incoming block current frame processed 
frame sends process global statistics frame compression bit rate 
statistics bit rate computes sends updated quantization huffman tables process process respectively 
obtain specification exploits distributed memory shared variables matlab code shown replaced struct block int block pixels int block pixels int block pixels int block pixels block block block packets dct dct subnetwork pixel pixel pixel pixel source sink jpeg network bitrate hierarchical kpn jpeg application 
fifo channels kpn shown 
example shared distributed fifo channels called block 
type data communicated fifo channels type shared variables channels originate 
instance type variable block date communicated channels name block structure shown left corner 
step design flow obtained executable specification jpeg application kpn yapi code 
specification executed yapi code generates statistics computational communicational workload application 
information perform manual hw sw partitioning application 
identify computational intensive process candidate want put hardware speedup computation 
done step system design flow 
kahn process network shown computational intensive process dct performs discrete cosine transform incoming block pixels 
rest processes network implemented software mapped microprocessor 
step processes selected put software need execute microprocessor target platform 
purpose yapi multi threading environment light weight multithreading environment 
standard compiler compile yapi code processes 
processes jpeg kpn mapped microprocessor dct process mapped fpga 
integrate execution dct process hardware software processes microprocessor small piece interface code needs execute microprocessor 
code 
void dct main int int int read dct write interface code yapi format connect software processes hardware implementation dct 
line code yapi primitive read get data input fifo channel connected dct process 
data read channel stored variable 
type variable data structure shown left corner 
structure consists pixel blocks 
blocks luminance component chrominance component 
similarly line yapi put data stored variable output fifo channel con nected dct process 
type type 
line called 
function executes discrete cosine transform dct task implemented hardware fpga component shown 
data stored input uploaded memory bank memory block shown 
done pci bus host interface 
hw design block executes dct task stores data memory bank 
data downloaded memory bank returned output function line 
step performing workload analysis identify candidate process computational intensive process kpn 
typically code process nested loop program 
want implement process hardware running fpga hw design block target platform 
purpose developed laura tool generates synthesizable vhdl code kpn specification 
vhdl code suitable mapping fpgas 
case candidate process dct process kpn 
initially candidate dct process specified kpn 
compaan derive kpn process 
kpn shown hierarchical subnetwork jpeg 
hierarchical subnetwork generate synthesizable vhdl 
creating subnetwork exploit efficiently parallelism available inside dct process 
apply automatic type conversion hierarchical input output dct subnetwork data type block 
inside subnetwork converted streams pixels integers 
moving streams pixels get fine grained communication mapped efficiently fpga 
type conversion automatically handled compaan 
generation hardware dct process starts converting code function call dct line kahn process network specification 
done compiler compaan step 
code dct function call described matlab shown 
pixel source pixel pixel block pixel block dct block pixel block sink pixel matlab code dct process 
kahn process network kpn generated compaan corresponds matlab code dct depicted 
shows kpn subnetwork implements dct process jpeg network 
subnetwork consists processes 
source sink processes serve hierarchical interfaces jpeg network 
source process transforms incoming block data structures pixels distributes pixels corresponding luminance components process preprocessing pixels corresponding chrominance components go directly process 
process executes dct transformation 
sink process groups stream pixels comes process block data structures 
step step design flow shown tool laura transforms kpn specification generated step predefined ip cores synthesizable vhdl code 
example provide laura kpn specification dct 
generation vhdl code kpn takes place number steps 
laura creates platform independent hardware model hm kpn dct 
obtained hardware model depicted 
consists concurrent virtual processors vp vp vp vp connected network communicate data asynchronously fifo buffers 
topology hm network topology input kpn shown laura performs mapping 
virtual processors vp vp vp vp implement processes source sink respectively 
vp source fifo fifo fifo vp ip vp ip op laura hardware model dct subnetwork 
second step laura hardware model annotated additional information target platform 
information ip cores virtual processors bit width communicated data type data 
size hardware fifo buffers specified 
furthermore notion clock event taken consideration 
step laura synthesizable vhdl code generated describes annotated hardware model hm 
implemented laura software procedure called vhdl visitor generates hardware component correct vhdl syntax 
simply implementing visitor procedures generate code formats example verilog systemc 
step step design flow commercial tools synthesize map vhdl code generated step fpga shown 
synthesis tool placement routing generation configuration file fpga ise foundation package provided xilinx 

experiments results section results obtained mapping jpeg application target platform system design flow section 
input system design flow application described subset matlab 
started publicly available sequential code jpeg codec 
code modified structured hand meet subset matlab design flow accepts match features jpeg application 
reason matlab compaan uses simple matlab parser 
fifo vp sink model computation matlab read time speak matlab 
writing matlab code took days functional testing debugging 
preparation time effort started mapping jpeg application system design flow 
experiment measure time takes map jpeg application target platform system design flow 
table shows processing times step flow 
column shows time needed table processing times hh mm ss 
compaan laura tools manually total step step step step step step finish 
time design flow jpeg experiment hours minutes 
column manually indicates manual manipulations 
example step manual hw sw partitioning took minutes 
step download internet modify add ip cores library components took hours 
ip cores library manual manipulations step disappear 
results show mapping jpeg application target platform done short amount time hours 
main reason great time performance tools compaan laura 
compaan derives fully automatically kpn jpeg minute day preparation described 
comparison kpn jpeg encoder derived hand took weeks 
laura converts fully automatically kpn dct process synthesizable vhdl code seconds 
comparison hand design kpn vhdl take days 
second experiment design flow evaluate performance kahn process network dct mapped fpga 
measured time needed fpga implementation process single datum type block 
took micro seconds clock frequency mhz 
contrast execution dct process running program microprocessor clock frequency ghz took micro seconds 
conclude got speedup fpga 
improve speedup high level transformations toolbox step 
performing unfolding unrolling skewing re timing transformations expect obtain speedup 
mapping kpn dct efficient terms resource usage 
table shows fpga resource utilization 
table dct kpn device utilization fpga resource utilization number mult number number slices number numbers table show average fpga resources taken ip cores taken fifos distributed control generated laura integrate ip cores kpn dct process 
suggests map fpga dct process processes jpeg network shown 
final experiment measured performance complete system jpeg kahn process network running target platform 
looked throughput system measured frames second 
frames cif format pixels throughput system frames second 
standard minimum real time throughput cif frames second 
problem output design flow slow communication data microprocessor fpga 
bottleneck bit width pci bus operating mhz 
switching pci bus bits frequency mhz increase communication speed approximately times 
consequence system able process frames second cif format pixels 

presents system design flow application written subset matlab mapped target platform composed cpu fpga systematic automated way 
novelty flow cpu fpga run concurrently exploiting efficiently task level parallelism 
central flow kahn process network model computation 
model inherently expresses applications terms distributed control memory 
required get efficient mapping cpu fpga 
realizing flow developed compaan laura tools 
tools allow quickly go application specification matlab implementation application running target platform 
hardware mapping shows laura capable generating efficient implementations 
com laura subject research tools results efficient design flow systems execute high performance real time signal processing multimedia applications 
demonstrated system design flow mapping jpeg application platform consists cpu fpga 
flow general systematic mapping applications multiple cpus fpgas 
main reason kahn process network kpn model computation flow 
control memory distributed kpn global scheduler needed 
partitioning kpn number cpus fpgas easily done 
system design flow standard compiler simple research multi threading environment simple target platform obtained results promising 
better results achievable employing example optimized robust commercial solutions 

acknowledgments research partly supported progress program dutch technology foundation stw 
vladimir contribution rewriting structuring original jpeg code 

gilles kahn semantics simple language parallel programming proc 
ifip congress 
north holland publishing edward lee thomas parks dataflow process networks proceedings ieee vol 
pp 
may 
bart edwin ed compaan deriving process networks matlab embedded signal processing architectures proc 
th international workshop hardware software codesign codes san diego ca usa may 
alexandru bart storage management process networks lexicographically maximal preimage proceedings ieee th int 
conf 
application specific systems architectures processors asap hague netherlands june 
alexandru bart ed technique determine inter process communication polyhedral model proceedings th international workshop compilers parallel computers cpc amsterdam netherlands january 
bart ed laura leiden architecture research exploration tool proc 
th int 
conference field programmable logic applications fpl 
wayne wolf decade hardware software codesign ieee computer vol 
pp 
apr 
li callahan harr hardware software design embedded reconfigurable architectures proc 
th design automation conference dac los angeles ca june pp 

timothy callahan john hauser john wawrzynek garp architecture compiler ieee computer pp 
april 
suresh improving software performance configurable logic kluwer journal design automation embedded systems vol 
pp 
nov 
vinod aditya robert schreiber bob rau pico automatically designing custom computers ieee computer vol 
sept 
gokhale stone arnold stream oriented fpga computing stream high level language proc 
ieee symposium field programmable custom computing machines fccm april 
hoare communicating sequential processes prentice hall 
eric von neumann machine communication driving design paradigm mp soc software hardware networks chips axel jantsch hannu eds pp 

kluwer academic publishers 
stream computations organized reconfigurable execution score proc 
th int 
conference field programmable logic applications fpl aug 
image video compression standards algorithms architectures kluwer academic publishers 
mitchel fogg mpeg video compression standard chapman hall 
www alpha data com adm ii html alpha data parallel systems de kock yapi application modeling signal processing systems proc 
th design automation conference dac los angeles ca june pp 

jpeg codec portable video research group stanford university 
www com products index html www xilinx com ise design tools index htm xilinx paul pieter van der wolf ed system level design spade jpeg case study proc 
int 
conference computer aided design iccad san jose ca usa nov pp 

bart ed algorithmic transformation techniques efficient exploration alternative application instances proc 
th int 
symposium hardware software codesign codes estes park usa may pp 

