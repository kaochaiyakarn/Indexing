journal artificial intelligence research submitted published cient solution algorithms factored mdps carlos guestrin guestrin cs stanford edu computer science dept stanford university daphne koller koller cs stanford edu computer science dept stanford university ronald parr parr cs duke edu computer science dept duke university venkataraman cs cmu edu computer science dept carnegie mellon university addresses problem planning uncertainty large markov decision processes mdps 
factored mdps represent complex state space state variables transition model dynamic bayesian network 
representation allows exponential reduction representation size structured mdps complexity exact solution algorithms mdps grow exponentially representation size 
approximate solution algorithms exploit structure factored mdps 
approximate value function represented linear combination basis functions basis function involves small subset domain variables 
key contribution shows basic operations algorithms performed ciently closed form exploiting additive context specific structure factored mdp 
central element algorithms novel linear program decomposition technique analogous variable elimination bayesian networks reduces exponentially large lp provably equivalent polynomial sized 
algorithm uses approximate linear programming second approximate dynamic programming 
dynamic programming algorithm novel uses approximation max norm technique directly minimizes terms appear error bounds approximate mdp algorithms 
provide experimental results problems states demonstrating promising indication scalability approach compare algorithm existing state art approach showing problems exponential gains computation time 

years markov decision processes mdps basic semantics optimal planning decision theoretic agents stochastic environments 
mdp framework system modeled set states evolve stochastically 
main problem representation virtually real life domain state space quite large 
large mdps significant internal structure modeled compactly structure exploited representation 
factored mdps boutilier dearden goldszmidt approach representing large structured mdps compactly :10.1.1.158.8490
framework state implicitly described assignment set state variables 
dynamic bayesian network dbn dean kanazawa allow compact representation transition model exploiting fact transition variable depends small number ai access foundation morgan kaufmann publishers 
rights reserved 
guestrin koller parr venkataraman variables 
furthermore momentary rewards decomposed sum rewards related individual variables small clusters variables 
main types structure simultaneously exploited factored mdps additive context specific structure 
additive structure captures fact typical large scale systems decomposed combination locally interacting components 
example consider management large factory production cells 
course long run cell positioned early production line generates faulty parts factory may ected 
quality parts cell generates depends directly state cell quality parts receives neighboring cells 
additive structure reward function 
example cost running factory depends things sum costs maintaining local cell 
context specific structure encodes di erent type locality influence part large system may general influenced state part system point time small number parts may influence directly 
factory example cell responsible may receive parts directly cell factory 
order cylindrical part may restrict dependency cells lathe 
context producing cylindrical parts quality parts depends directly state cells lathe 
large mdp represented compactly example factored representation solving exactly may intractable typical exact mdp solution algorithms require manipulation value function representation linear number states exponential number state variables 
approach approximate solution approximate value function compact representation 
common choice linear value functions approximation value functions linear combination potentially non linear basis functions bellman sutton tsitsiklis van roy 
builds ideas koller parr factored linear value functions basis function restricted small subset domain variables 
presents new algorithms computing linear value function approximations factored mdps uses approximate dynamic programming uses approximate linear programming 
algorithms factored linear value functions highly expressive function approximation method 
representation allows algorithms take advantage additive context specific structure order produce high quality approximate solutions ciently 
capability exploit types structure distinguishes algorithms di er earlier approaches boutilier exploit context specific structure 
provide detailed discussion di erences section 
show factored mdp factored value functions various critical operations planning algorithms implemented closed form necessarily enumerating entire state space 
particular new algorithms build novel linear programming decomposition technique 
technique reduces structured lps exponentially constraints equivalent polynomially sized ones 
decomposition follows procedure analogous variable elimination applies additively efficient solution algorithms factored mdps structured value functions value functions exploit context specific structure zhang poole 
basic operations planning algorithms implemented ciently size state space grows exponentially number variables 
method approximate linear programming algorithm schweitzer 
algorithm generates linear approximate value function solving single linear program 
unfortunately number constraints lp proposed schweitzer grows exponentially number variables 
lp decomposition technique exploit structure factored mdps represent exactly optimization problem exponentially fewer constraints 
terms approximate dynamic programming twofold contribution 
provide new approach approximately solving mdps linear value function 
previous approaches linear function approximation typically utilized squares norm approximation value function 
squares approximations incompatible convergence analyses mdps max norm 
provide mdp solution algorithms value iteration policy iteration linear max norm projection approximate value function directly optimizing quantity appears provided error bounds 
second show exploit structure problem apply technique factored mdps leveraging lp decomposition technique 
approximate dynamic programming currently possesses stronger theoretical guarantees experimental results suggest approximate linear programming alternative 
tends generate better policies set basis functions due simplicity computational advantages approximate linear programming add basis functions obtaining better policy requiring computation approximate dynamic programming approach 
experimental results comparing approach boutilier 
illustrating tradeo methods 
particular problems significant context specific structure value function approach faster due cient handling value function representation 
cases significant context specific structure problem value function algorithm requires exponentially large value function representation 
classes problems demonstrate value function exploits additive context specific structure algorithm obtain polynomial time near optimal approximation true value function 
starts presentation factored mdps approximate solution algorithms mdps 
section describe basic operations algorithms including lp decomposition technique 
section algorithms approximate linear programming algorithm factored mdps 
second algorithm approximate policy iteration max norm projection section 
section describes approach ciently computing bounds policy quality bellman error 
section shows extend methods deal context specific structure 
concludes empirical evaluation section discussion related section 
guestrin koller parr venkataraman greatly expanded version published guestrin 
guestrin 


factored markov decision processes markov decision process mdp mathematical framework sequential decision problems stochastic domains 
provides underlying semantics task planning uncertainty 
concise overview mdp framework describe representation factored mdps 
markov decision processes briefly review mdp framework referring reader books bertsekas tsitsiklis puterman depth review 
markov decision process mdp defined tuple finite set states finite set actions reward function xa represents reward obtained agent state action markovian transition model represents probability going state state action assume rewards bounded exists max max example consider problem optimizing behavior system administrator sysadmin maintaining network computers 
network machine connected subset machines 
various possible network topologies defined manner see examples 
simple network connect machines ring machine connected machines 
example assume addition subtraction performed modulo 
machine associated binary random variable representing working failed 
time step sysadmin receives certain amount money reward working machine 
job sysadmin decide machine reboot possible actions time step reboot machines machine rebooted time step 
machine rebooted working high probability time step 
machine small probability failing time step 
neighboring machine fails probability increases dramatically 
failure probabilities define transition model particular assignment describing machines working failed current time step sysadmin choice machine reboot resulting state time step 
assume mdp infinite horizon rewards discounted exponentially discount factor 
stationary policy mdp mapping action agent takes state computer network problem possible configuration working failing machines policy tell sysadmin machine reboot 
policy associated value function discounted cumulative value agent gets starts state follows policy 
precisely value state efficient solution algorithms factored mdps network topologies tested status machine influence status parent network 
policy random variable representing state system steps 
running example value function represents money sysadmin expects collect starts acting network state value function fixed policy fixed point set linear equations define value state terms value possible successor states 
formally define definition dp operator stationary policy 
value function policy fixed point operator optimal value function describes optimal value agent achieve starting state 
defined set non linear equations 
case value state maximal expected value achievable policy starting state 
precisely define definition bellman operator max 
optimal value function fixed point value function define policy obtained acting greedily relative words state agent takes action maximizes step guestrin koller parr venkataraman utility assuming represents long term utility achieved state 
precisely define greedy arg max 
greedy policy relative optimal value function optimal policy greedy 
factored mdps factored mdps representation language allows exploit problem structure represent exponentially large mdps compactly 
idea representing large mdp factored model proposed boutilier 

factored mdp set states described set random variables 
takes values finite domain dom 
state defines value dom variable general upper case letters denote random variables lower case denote values 
boldface denote vectors variables values 
instantiation dom subset variables denote value variables instantiation factored mdp define state transition model dynamic bayesian network dbn dean kanazawa 
denote variable current time variable step 
transition graph dbn layer directed acyclic graph nodes 


denote parents graph parents 
simplicity exposition assume parents arcs dbn variables consecutive time slices 
assumption expository purposes intra time slice arcs handled small modification section node associated conditional probability distribution cpd parents 
transition probability defined value variables parents 
example consider instance sysadmin problem computers labelled 
unidirectional ring topology shown 
task modeling problem factored mdp define state space machine associated binary random variable representing working failed 
state space represented random variables 
task define transition model represented dbn 
parents time step variables depend network topology 
specifically probability machine fail time step depends working current time step status direct neighbors parents topology network current time step 
shown parents example cpd false false high probability efficient solution algorithms factored mdps xx xx xx action reboot machine machine factored mdp example network topology obtain factored mdp representation cpds described 
failures tend persist 
true noisy parents unidirectional ring topology parent failure neighbors independently cause machine fail 
described represent factored markovian transition dynamics arising mdp dbn directly addressed representation actions 
generally define transition dynamics mdp defining separate dbn model action example system administrator example action rebooting machines default action doing 
transition model described corresponds action 
transition model di erent transition model variable true probability regardless status neighboring machines 
shows actual cpd entry assignment state variables action fully specify mdp need provide compact representation reward function 
assume reward function factored additively set localized reward functions depends small set variables 
example reward function associated machine depends sysadmin paid machine basis time step receives money machine working 
formalize concept localized functions definition function scope scope dom scope shorthand part instantiation corresponds variables guestrin koller parr venkataraman characterize concept local rewards 

set functions scope restricted variable cluster 

reward action state defined example reward function associated machine depends depend action choice 
local rewards represented diamonds usual notation influence diagrams howard matheson 

approximate solution algorithms algorithms compute optimal policy mdp 
commonly value iteration policy iteration linear programming 
key component algorithms computation value functions defined section 
recall value function defines value state state space 
explicit representation value function vector values di erent states solution algorithms implemented series simple algebraic steps 
case implemented ciently 
unfortunately case factored mdps state space exponential number variables domain 
sysadmin problem example state system assignment describing machines working failed state assignment random variable number states exponential number machines network 
representing explicit value function problems machines infeasible 
tempted believe factored transition dynamics rewards result factored value function represented compactly 
unfortunately trivial factored mdps guarantee structure model preserved value function koller parr 
section discuss approximate value function admits compact representation 
describe approximate versions exact algorithms approximate value functions 
description section somewhat specify basic operations required algorithms performed explicitly 
sections elaborate issues describe algorithms detail 
brevity choose focus policy iteration linear programming techniques easily extend value iteration 
linear value functions popular choice approximating value functions linear regression proposed bellman 

define space allowable value functions set basis functions definition linear value function set basis functions 
function written coe cients 
define linear subspace spanned basis functions useful define matrix columns basis functions viewed efficient solution algorithms factored mdps vectors 
compact notation approximate value function represented hw 
expressive power linear representation equivalent example single layer neural network features corresponding basis functions defining features defined optimize coe cients order obtain approximation true value function 
view approach separating problem defining reasonable space features induced space problem searching space 
problem typically purview domain experts focus analysis algorithmic design 
clearly feature selection important issue essentially areas learning approximation 
er simple methods selecting features mdps section goal address large important topic 
chosen linear value function representation set basis functions problem finding values weights hw yield approximation true value function 
consider approaches approximate dynamic programming policy iteration approximate linear programming 
section approaches 
section show exploit problem structure transform approaches practical algorithms deal exponentially large state spaces 
policy iteration exact algorithm exact policy iteration algorithm iterates policies producing improved policy iteration 
starting initial policy iteration consists phases 
value determination computes policy value function finding fixed point equation unique solution set linear equations policy improvement step defines policy greedy 
shown process converges optimal policy bertsekas tsitsiklis 
furthermore practice convergence optimal policy quick 
approximate policy iteration steps policy iteration algorithm require manipulation value functions policies represented explicitly large mdps 
define version policy iteration algorithm uses approximate value functions basic idea restrict algorithm value functions provided algorithm takes step results value function outside space project result back space finding value function space closest precisely guestrin koller parr venkataraman definition projection operator mapping said projection norm hw arg minw hw 
linear combination basis functions closest respect chosen norm 
approximate policy iteration algorithm performs policy improvement step exactly 
value determination step value function value acting current policy approximated linear combination basis functions 
consider problem value determination policy point useful introduce notation rewards function state action choice policy fixed rewards function state denote 
similarly transition model 
rewrite value determination step terms matrices vectors 
view vectors matrix equations system linear equations equation state solved exactly relatively small goal provide approximate solution precisely want find arg min hw hw arg min approximate policy iteration alternates steps arg min hw hw greedy hw 
max norm projection approach lines described various papers theoretical algorithmic results schweitzer tsitsiklis van roy van roy koller parr 
approaches su er problem call norm incompatibility 
computing projection utilize standard euclidean projection operator respect norm weighted norm 
hand convergence error analyses mdp algorithms utilize max norm 
incompatibility di cult provide error guarantees 
tie projection operator closely error bounds projection operator norm 
problem minimizing norm studied optimization literature problem finding chebyshev solution 
weighted norm projections stable meaningful error bounds weights correspond stationary distribution fixed policy evaluation value determination van roy stable combined gordon stable non expansive require mixture weights determined priori 
general minimize error 

chebyshev norm referred max supremum norms minimax solution 
efficient solution algorithms factored mdps overdetermined linear system equations cheney 
problem defined finding arg min cw 
algorithm due stiefel solves problem linear programming variables 
minimize subject ij ij 
constraints linear program imply ij equivalently cw objective lp minimize 
solution linear program solution equation projection error 
projection context approximate policy iteration obvious way 
implementing projection operation equation projection equation minimization solved linear program 
key point lp variables 
constraints impractical large state spaces 
sysadmin problem example number constraints lp exponential number machines network total constraints machines 
section show factored mdps linear value functions constraints represented ciently leading tractable algorithm 
error analysis motivated max norm projection approximate policy iteration algorithm compatibility standard error analysis techniques mdp algorithms 
provide careful analysis impact error introduced projection step 
analysis provides motivation projection step directly minimizes quantity 
acknowledge main impact analysis motivational 
practice provide priori guarantees projection outperform methods 
goal analyze approximate policy iteration terms amount error introduced step projection operation 
error zero performing exact value determination error accrue 
error small get approximation accurate 
result follows analysis 
precisely define projection error error resulting approximate value determination step hw hw note max norm projection finding set weights exactly minimizes step projection error choosing best guestrin koller parr venkataraman possible weights respect error measure 
furthermore exactly error measure going appear bounds theorem 
bounds step tight possible 
show projection error accrued step bounded lemma value determination error bounded exists constant max iterations algorithm 
proof see appendix 
due contraction property bellman operator accumulated error decaying average projection error incurred iterations definition discounted value determination error iteration defined 
lemma implies accumulated error remains bounded approximate policy iteration bound loss incurred acting policy generated approximate policy iteration algorithm opposed optimal policy theorem approximate policy iteration algorithm policy generated iteration furthermore actual value acting policy 
loss incurred policy opposed optimal policy value bounded 
proof see appendix 
words equation shows di erence approximation iteration optimal value function bounded sum terms 
term standard policy iteration goes zero exponentially fast 
second discounted accumulated projection error lemma shows bounded 
second term minimized choosing minimizes hw hw exactly computation performed max norm projection 
theorem motivates max norm projections minimize error term appears bound 
bounds provided far may fairly trivial provided strong priori bound fortunately factors bounds interesting despite lack priori guarantees 
approximate policy iteration converges occurred experiments obtain tighter bound policy convergence step max norm projection error associated estimating value 
max norm projection operation provides easily obtain efficient solution algorithms factored mdps posteriori bound part policy iteration procedure 
details provided section 
rewrite bound theorem terms worst case projection error worst projection error cycle policies approximate policy iteration gets stuck cycle 
formulations closer analysis bertsekas tsitsiklis proposition 
consider case policies policies final cycle low projection error policies approximated projection operation large step projection error 
worst case bound loose dictated error di cult policy approximate 
hand discounted accumulated error formulation errors introduced policies hard approximate decay rapidly 
error bound represents average case analysis decaying average projection errors policies encountered successive iterations algorithm 
convergent case bound computed easily part policy iteration procedure max norm projection 
practical benefit posteriori bounds give meaningful feedback impact choice value function approximation architecture 
explicitly addressing di cult general problem feature selection error bounds motivate algorithms aim minimize error approximation architecture provide feedback useful orts automatically discover improve approximation architectures 
approximate linear programming exact algorithm linear programming provides alternative method solving mdps 
formulates problem finding value function linear program lp 
lp variables 
vn represents value starting ith state system 
lp variables 
vn minimize subject state relevance weights positive 
note exact case solution obtained positive weight vector 
interesting note steps simplex algorithm correspond policy changes single states steps policy iteration involve policy changes multiple states 
practice policy iteration tends faster linear programming approach puterman 
approximate linear program approximate formulation lp approach proposed schweitzer restricts space allowable value functions linear space spanned basis functions 
approximate formulation variables 
weights basis functions 
lp guestrin koller parr venkataraman variables 
minimize subject 
words formulation takes lp substitutes explicit state value function linear value function representation compact notation replaced hw 
linear program guaranteed feasible constant function function constant value states included set basis functions 
approximate linear programming formulation choice state relevance weights important 
intuitively constraints lp binding constraints tighter states 
state relevance weight indicates relative importance tight constraint 
exact case solution obtained may di er di erent choices positive weight vector 
furthermore general guarantee quality greedy policy generated approximation hw 
de van roy provides analysis error relative best possible approximation subspace guidance selecting improve quality approximation 
particular analysis shows lp provides best approximation hw optimal value function weighted sense subject constraint hw hw weights norm state relevance weights 
transformation exact approximate problem formulation effect reducing number free variables lp basis function coe cient number constraints remains 
sysadmin problem example number constraints lp number machines network 
process generating constraints solving lp unmanageable machines 
section discuss structure factored mdp provide compact representation cient solution lp 

factored value functions linear value function approach algorithms described section apply choice basis functions 
context factored mdps koller parr suggest particular type basis function particularly compatible structure factored mdp 
suggest value function typically structured cases close structured 
linear combination functions refers small number variables 
precisely define definition factored linear value function linear function basis set 
scope restricted subset variables value functions type long history area multi attribute utility theory keeney rai 
example basis function efficient solution algorithms factored mdps machine indicating working 
basis function scope restricted represented diamonds time step 
factored value functions provide key performing cient computations exponential sized state spaces factored mdps 
main insight restricted scope functions including basis functions allow certain basic operations implemented ciently 
remainder section show structure factored mdps exploited perform crucial operations ciently step lookahead backprojection representation exponentially constraints lps 
basic building blocks formulate cient approximation algorithms factored mdps self contained section approximate linear programming factored mdps section approximate policy iteration max norm projection section 
step lookahead key step algorithms computation step lookahead value action necessary example computing greedy policy equation 
consider computation function represents expected value agent obtains action current time step receiving long term value 
function computed 
current reward plus discounted expected value 
notation express greedy policy greedy max 
recall estimating long term value policy set basis functions 
rewrite equation 
size state space exponential computing expectation infeasible 
fortunately discussed koller parr expectation operation backprojection performed ciently transition model value function factored appropriately 
linearity value function permits linear decomposition summand expectation viewed independent value function updated manner similar value iteration procedure boutilier 

recap construction briefly defining 
compute expectation basis function separately guestrin koller parr venkataraman weight obtain total expectation 
intermediate function called backprojection basis function transition model denote note factored mdps transition model factored represented dbn basis functions scope restricted small set variables 
important properties allow compute backprojections ciently 
show restricted scope function basis functions backprojected transition model represented dbn scope restricted goal compute define backprojected scope set parents transition graph parents 
intra time slice arcs included parents 

change algorithm definition backprojected scope definition includes direct parents variables 
ancestors exist directed path 
backprojected scope may larger functions factored 
show scope restricted backprojection scope restricted parents 
furthermore backprojection computed enumerating settings variables settings variables value term sum probability distribution complete domain 
see function scope restricted 
note cost computation depends linearly dom depends scope complexity process dynamics 
backprojection procedure summarized 
returning example consider basis function indicator variable takes value ith machine working 
scope restricted backprojection scope restricted parents 
representing exponentially constraints seen section approximation algorithms require solution linear programs lp approximate policy iteration lp approximate efficient solution algorithms factored mdps basis function scope define scope backprojection parents 
assignment 
return backprojection basis function linear programming algorithm 
lps common characteristics small number free variables basis functions free variables approximate policy iteration approximate linear programming number constraints exponential number state variables 
factored mdps lp constraints useful property functionals constraints restricted scope 
key observation allows represent constraints compactly 
observe constraints linear programs form 
free variables lp ranges states 
general form represents type constraint max norm projection lp approximate linear programming formulation 
insight construction replace entire set constraints equation equivalent non linear constraint max 
second insight new non linear constraint implemented set linear constraints construction follows structure variable elimination cost networks 
insight allows exploit structure factored mdps represent constraint compactly 
tackle problem representing constraint equation steps computing maximum assignment fixed set weights representing non linear constraint small set linear constraints construction call factored lp 
maximizing state space key computation algorithms represent non linear constraint form equation ciently small set linear constraints 
presenting construction consider simpler problem fixed weights compute maximization max state 
complementary constraints formulated analogous construction section changing sign 
approximate linear programming constraints formulated form show section 
guestrin koller parr venkataraman di erence maximal 
explicitly enumerate exponential number states compute di erence 
fortunately structure factored mdps allows compute maximum ciently 
case factored mdps state space set vectors assignments state variables 

view cw functions state variables di erence 
define function 

note executed representation shift viewing function variables parameterized recall size state space exponential number variables 
goal section compute max explicitly considering exponentially states 
solution fact factored representation 
precisely cw form subset example takes value states true false 
similarly vector case sum restricted scope functions 
express sum may may depend drop superscript clear context 
compact notation goal simply compute max max find state maximized 
recall 
maximize function enumerating state non serial dynamic programming 
idea virtually identical variable elimination bayesian network 
review construction central component solution lp 
goal compute max 
main idea summing functions doing maximization maximize variables time 
maximizing summands involving participate maximization 
example assume 
wish compute max 
compute maximum functions irrelevant push 
get max max 
result internal maximization depends values introduce new function value point value internal max expression 
problem reduces computing max efficient solution algorithms factored mdps 
fm set functions maximized stores elimination order 
number variables select variable eliminated 
select relevant functions 

functions scope contains maximize current variable define new function max note scope scope 
update set functions 
update set functions 

functions empty scope sum maximum value fm return maximum value variable elimination procedure computing maximum value restricted scope function 
having fewer variable 
eliminate variable say resulting expression reducing max max 
define max 
result point number desired maximum 
naive approach enumerating states requires arithmetic operations variables binary variable elimination need perform operations 
general variable elimination algorithm described 
inputs algorithm functions maximized 
elimination ordering variables returns ith variable eliminated 
example variable eliminated select relevant functions 
scope contains functions removed set introduce new function max point scope functions longer depends eliminated 
procedure repeated variables eliminated 
remaining functions empty scope 
desired maximum sum remaining functions 
computational cost algorithm linear number new function values introduced elimination process 
precisely consider computation new function scope compute function need compute dom di erent values 
cost algorithm linear number values introduced execution 
shown dechter cost exponential guestrin koller parr venkataraman induced width cost network undirected graph defined variables 
edge xm appear original functions complexity algorithm course dependent variable elimination order problem structure 
computing optimal elimination order np hard problem arnborg corneil elimination orders yielding low induced tree width exist problems 
issues confronted successfully large variety practical problems bayesian network community benefited large variety heuristics developed variable elimination ordering problem reed becker geiger 
factored lp section planning algorithms new general approach compactly representing exponentially large sets lp constraints problems factored structure functions constraints decomposed sum restricted scope functions 
consider original problem representing non linear constraint equation compactly 
recall wish represent non linear constraint max equivalently max generating constraint state equation 
new key insight non linear constraint implemented construction follows structure variable elimination cost networks 
consider function including original scope 
assignment introduce variable value represents linear program 
initial functions include constraint 
linear constraint linear lp variables 
consider new function introduced eliminating variable 
functions extracted scope resulting introduce set constraints 
function generated elimination recall scope empty 
single variable en introduce additional constraint en complete algorithm divided parts generate equality constraints functions depend weights basis functions 
second part add equality constraints functions depend weights target functions 
equality constraints away di erences types functions manage unified fashion third part algorithm 
third part follows procedure similar variable elimination described 
standard variable elimination introduce new function max factored lp procedure introduce new lp variables enforce definition maximum introduce new lp constraints equation 
example understand construction consider simple example assume want express fact max 
introduce set efficient solution algorithms factored mdps 
ck set basis functions 

bm set target functions 
stores elimination order 
return polynomial set constraints equivalent data structure constraints factored lp 
data structure intermediate functions generated variable elimination 
generate equality constraint away basis functions 
scope 
assignment create new lp variable add constraint 
store new function variable elimination step 
generate equality constraint away target functions 
scope 
assignment create new lp variable add constraint 
store new function variable elimination step 
contains functions involved lp constraints represent compactly variable elimination procedure 
number variables select variable eliminated 
select relevant functions 

functions scope contains scope 
introduce linear constraints maximum current variable define new function scope represent max add constraints enforce maximum assignment update set functions 
update set functions 

variables eliminated functions empty scope 
add constraint return factored lp algorithm compact representation exponential set constraints guestrin koller parr venkataraman variables instantiation values variables binary variables 
introduce constraint defining value appropriately 
example similar variables constraints value note constraints simple equality constraint involving numerical constants weight variables introduce variables intermediate expressions generated variable elimination 
example eliminating introduce set lp variables set constraints value similar set constraint terms note constraint simple linear inequality 
prove factored lp construction represents constraint non linear constraint equation theorem constraints generated factored lp construction equivalent non linear constraint equation 
assignment satisfies factored lp constraints satisfies constraint equation 
proof see appendix 
returning original formulation cw original set constraints 
new set constraints equivalent original set max equation turn equivalent exponential set constraints equation 
represent exponential set constraints new set constraints lp variables 
size new set variable elimination exponential induced width cost network total number variables 
section new general approach compactly representing exponentially large sets lp constraints problems factored structure 
remainder exploit construction design cient planning algorithms factored mdps 
factored max norm projection procedure representing exponential number constraints equation compactly compute cient max norm projections equation arg min cw max norm projection computed linear program 
sets constraints lp ij ij sets instance constraints equation just addressed previous section 
basis functions restricted scope function target function sum restricted scope functions factored lp technique represent constraints max norm projection lp compactly 
correctness algorithm corollary theorem efficient solution algorithms factored mdps corollary solution linear program minimizes subject constraints elimination order satisfies arg min cw min cw original max norm projection lp variables constraints state number constraints exponential number state variables 
hand new factored max norm projection lp variables exponentially fewer constraints 
number variables constraints new factored lp exponential number state variables largest factor cost network exponential total number state variables 
show section exponential gain allows compute max norm projections ciently solving large factored mdps 

approximate linear programming simplest approximate mdp solution algorithms approximate linear programming formulation section 
basic operations described section formulate algorithm simple cient 
algorithm discussed section approximate linear program formulation linear programming approach solving mdps section 
approximate version restrict space value functions linear space defined basis functions 
precisely approximate lp formulation variables 
weights basis functions 
lp variables 
minimize subject 
words formulation takes lp substitutes explicit state value function linear value function representation 
transformation exact approximate problem formulation ect reducing number free variables lp basis function coe cient number constraints remains 
sysadmin problem example number constraints lp number machines network 
algorithm representing exponentially large constraint sets compactly able compute solution approximate linear programming algorithm closed form exponentially smaller lp section 
consider objective function lp 
naively representing objective function requires summation exponentially large state space 
rewrite objective obtain compact representation 
reorder terms guestrin koller parr venkataraman factored transition model 
set factored reward functions 
discount factor 
set basis functions 
hk 
stores elimination order 
state relevance weights 
return basis function weights computed approximate linear programming 
cache backprojections basis functions 
basis function action 
compute factored state relevance weights 
basis function compute factored state relevance weights equation generate approximate linear programming constraints 
action 

far constraints guarantee satisfy approximate linear programming solution add final constraint 

obtain solution weights solving lp 
solution linear program minimize subject constraints return factored approximate linear programming algorithm 
efficient solution algorithms factored mdps 
consider state relevance weights distribution states 
backprojections write represents marginal state relevance weights domain dom basis function example uniform state relevance weights experiments marginals rewrite objective function basis weight computed shown equation 
state relevance weights represented marginals cost computing depends exponentially size scope exponentially number state variables 
hand state relevance weights represented arbitrary distributions need obtain marginals may cient computation 
greatest ciency achieved compact representation bayesian network state relevance weights 
second note right side constraints lp correspond functions 
cient backprojection operation factored mdps described section rewrite functions backprojection basis function transition model discussed scope restricted restricted scope function 
precompute backprojections basis relevance weights approximate linear programming lp written variables 
minimize subject 
rewrite lp constraints form equation variables 
minimize subject max 
factored lp construction section represent non linear constraints compactly 
basically set factored lp constraints action specifically write non linear constraint form equation expressing functions 
restricted guestrin koller parr venkataraman scope function scope restricted scope restricted means scope restricted 
target function reward function assumption factored 
constraint equation free variable 
hand lp maximum right hand side zero 
final condition achieved adding constraint 
algorithm generates set factored lp constraints action 
total number constraints variables new lp linear number actions exponential induced width cost network total number variables 
complete factored approximate linear programming algorithm outlined 
example complete example operations required approximate lp algorithm solve factored mdp shown 
presentation follows steps problem representation basis function selection backprojections lp construction 
problem representation fully specify factored mdp model problem 
structure dbn shown 
structure maintained action choices 
define transition probabilities action 
actions problem reboot machines network 
cpds actions shown 
define reward function 
decompose global reward sum local reward functions machine reward machine working 
specifically true false breaking symmetry setting true 
discount factor 
basis function selection simple example simple basis functions 
include constant function 
add indicators machine take value machine working true false 
backprojections algorithmic step computing backprojection basis functions defined section 
backprojection constant basis simple indicator basis functions efficient solution algorithms factored mdps true false true restricted scope function 
cpds specify reboot true false true false reboot true false true false lp construction illustrate factored lps constructed algorithms define constraints approximate linear programming approach 
define functions shown equation 
example functions constant basis indicator bases reboot true false true false reboot true false true false definition approximate linear programming constraints max 
lp construction actions reboot 
analogous constructions actions 
set constraints away di erence rewards basis functions introducing lp variables equality constraints 
reward functions represent equality constraints functions reboot action 
note appropriate basis function weight equation appears constraints guestrin koller parr venkataraman new lp variables lp constraint equation reboot action max ready variable elimination process 
illustrate elimination variable max max represent term maxx set linear constraints assignment new lp variables represent maximum eliminated variable global non linear constraint max eliminate variable new lp constraints variables form removing global non linear constraint max efficient solution algorithms factored mdps factored constraints number constraints lp generated explicit state representation versus factored lp construction solution ring problem basis functions single variables approximate linear programming solution algorithm 
eliminate generating linear constraints global non linear constraint involves max variable eliminated scope new lp variable empty linear constraints state variables eliminated turning global non linear constraint simple linear constraint completes lp description approximate linear programming solution problem 
small example state variables factored lp technique generates total equality constraints inequality constraints lp variables explicit state representation equation generates inequality constraints lp variables 
problem size increases number constraints lp variables factored lp approach grow explicit state approach grows exponentially 
scaling ect illustrated 
approximate policy iteration max norm projection factored approximate linear programming approach described previous section elegant easy implement 
general provide strong guestrin koller parr venkataraman guarantees error achieves 
alternative approximate policy iteration described section er certain bounds error 
shall see algorithm significantly complicated requires place additional restrictions factored mdp 
particular approximate policy iteration requires representation policy iteration 
order obtain compact policy representation additional assumption action ects small number state variables 
state assumption formally 
show obtain compact representation greedy policy respect factored value function assumption 
describe factored approximate policy iteration algorithm max norm projections 
default action model section factored mdp model action associated factored transition model represented dbn factored reward function 
di erent actions similar transition dynamics differing ect small set variables 
particular cases variable default evolution model changes action ects directly boutilier 
type structure turns useful compactly representing policies property important approximate policy iteration algorithm 
section restrict attention factored mdps defined default transition model koller parr 
action define ects variables state local probability model di erent variables parents parents 
example system administrator example action rebooting machines default action doing 
transition model described corresponds action default transition model 
transition model di erent transition model variable true probability regardless status neighboring machines 
example ects transition dynamics define notion default reward model 
case set reward functions associated default action addition action reward function 
extra reward action scope restricted rewards 

total reward associated action note factored linear combination smaller terms compact representation 
build additional assumption define complete algorithm 
recall approximate policy iteration algorithm iterates steps policy improvement approximate value determination 
discuss steps 
computing greedy policies policy improvement step computes greedy policy relative value function greedy 
efficient solution algorithms factored mdps recall value function estimates linear form hw 
described section greedy policy type value function greedy hw arg max represented 
attempt represent policy naively faced problem exponentially large state spaces 
fortunately shown koller parr greedy policy relative factored value function form decision list 
precisely policy written form 
assignment values small subset variables action 
greedy action take state action corresponding event list consistent 
completeness review construction decision list policy 
critical assumption allows represent policy compact decision list default action assumption described section 
assumption functions written scope restricted function default action just 
set linear functions implicitly describes policy 
immediately obvious functions result compactly expressible policy 
important insight components weighted combination identical equal intuitively component corresponding backprojection basis function di erent action influences variables formally assume ects 
case variables transition model words ith component function irrelevant deciding action better default action define components relevant set indices ects 
indices basis functions backprojection di ers example dbn actions basis functions involve single variables consider impact action default action define impact di erence value ia 
analysis shows function scope restricted ia 
guestrin koller parr venkataraman qa set functions action return decision list policy 
initialize decision list 

compute bonus functions 
action default action compute bonus action equation 
note scope restricted equation 
add states positive unsorted decision list 
assignment add branch decision list 
add default action unsorted decision list 

sort decision list obtain final policy 
sort decision list decreasing order element 
return 
method computing decision list policy factored representation functions 
example dbn 
intuitively situation baseline value function defines value state action changes baseline adding subtracting amount state 
point amount depends states variables take values 
define greedy policy relative functions 
action define set conditionals assignment values variables 
sort conditionals actions order decreasing 

consider optimal action state get largest possible bonus default value 
consistent clearly take action gives bonus try get check consistent take procedure compute policy associated linear estimate value function 
complete algorithm computing decision list policy summarized 
note number conditionals list dom turn depends set basis function clusters intersect ects size policy depends natural way interaction structure efficient solution algorithms factored mdps process description structure basis functions 
problems actions modify large number variables policy representation unwieldy 
approximate linear programming approach section appropriate cases require explicit representation policy 
value determination approximate value determination step algorithm computes arg min hw hw rearranging expression get arg min equation instance optimization equation 
factored conclude matrix columns correspond functions 
specifically backprojection basis function transition model described section 
target corresponds reward function moment assumed factored 
apply factored lp section estimate value policy unfortunately transition model factored decision list representation policy general induce transition model represented compact dbn 
generate compact lp exploiting decision list structure policy 
basic idea introduce cost networks corresponding branch decision list ensuring additionally states consistent branch considered cost network maximization 
specifically factored lp construction branch 
ith cost network considers subset states consistent ith branch decision list 
set states event decision list consistent 
state consistent consistent recall equation lp construction defines set constraints imply state separate set constraints states subset state know action taken 
apply construction transition model factored assumption place non factored similarly reward function subset states 
issue guarantee cost network constraints derived transition model applied states specifically guarantee applied states consistent states consistent guarantee condition simply instantiate variables take values specified cost network considers variables guestrin koller parr venkataraman max factored transition model 
set factored reward functions 
discount factor 
set basis functions 
hk 
stores elimination order 
bellman error precision 
tmax maximum number iterations 
return basis function weights computed approximate policy iteration 
initialize weights 
cache backprojections basis functions 
basis function action 
main approximate policy iteration loop 

repeat policy improvement part loop 
compute decision list policy iteration weights 

value determination part loop 
initialize constraints max norm projection lp 

initialize indicators 

branch decision list policy generate relevant set constraints update indicators constraint state space branches 
branch decision list policy instantiate variables assignment instantiate set functions 
partial state assignment store instantiate target functions partial state assignment store instantiate indicator functions partial state assignment store generate factored lp constraints current decision list branch 


update indicator functions 
update indicators obtain new set weights solving lp corresponds max norm projection 
solution linear program minimize subject constraints 

hw max return factored approximate policy iteration max norm projection algorithm 
efficient solution algorithms factored mdps 
computes maximum states consistent guarantee second condition ensure impose constraints states associated previous decisions 
achieved adding indicators previous decision weight 
specifically function takes value states consistent zero assignments constraints ith branch form defines assignments consistent indicators causes constraints associated trivially satisfied states note indicators restricted scope function handled fashion terms factored lp 
decision list size factored lp contains constraints cost networks 
complete approximate policy iteration max norm projection algorithm outlined 
comparisons instructive compare max norm policy iteration algorithm projection policy iteration algorithm koller parr terms computational costs iteration implementation complexity 
computing projection requires things series dot product operations basis functions backprojected basis functions 
expressions easy compute refers transition model particular action policy represented decision list result policy improvement step step complicated 
particular branch decision list pair basis functions assignment variables scope scope requires solution counting problem complete general 
koller parr show computation performed bayesian network bn inference algorithm requires bn inference assignments branch decision list 
algorithm di cult implement ciently practice 
max norm projection hand relies solving linear program iteration 
size linear program depends cost networks generated 
discuss cost networks needed point decision list 
complexity cost networks approximately bn inferences counting problem projection 
branch decision list total inferences opposed assignment scope scope pair basis functions max norm policy iteration algorithm substantially complex computationally approach projection 
furthermore linear programming allows rely existing lp packages cplex highly optimized 
interesting compare approximate policy iteration algorithm approximate linear programming algorithm section 
approximate linear programming algorithm need compute decision list policy 
policy represented implicitly functions 
algorithm guestrin koller parr venkataraman require explicit computation manipulation greedy policy 
di erence important consequences computational terms generality 
having compute consider decision lists approximate linear programming faster easier implement 
algorithm generate single lp cost network action need compute decision list policy 
hand iteration approximate policy iteration needs generate lps branch decision list size usually significantly longer total cost networks 
terms representation require policies compact need default action assumption 
approximate linear programming algorithm deal general class problems action independent dbn transition model 
hand described section approximate policy iteration stronger guarantees terms error bounds 
di erences highlighted experimental results section 
computing bounds policy quality algorithms computing approximate solutions factored mdps 
algorithms generate linear value functions denoted resulting basis function weights 
practice agent define behavior acting greedy policy greedy 
issue remains policy compares true optimal policy actual value policy compares section showed priori bounds quality policy 
possible procedure compute posteriori bound 
resulting weights compute bound loss acting greedy policy optimal policy 
achieved bellman error analysis williams baird 
bellman error defined greedy policy greedy analysis provides bound 
bellman error evaluate quality resulting greedy policy 
note computing bellman error involves maximization state space 
complexity computation grows exponentially number state variables 
koller parr suggested structure factored mdp exploited compute bellman error ciently 
show error bound computed set cost networks similar construction projection algorithms 
technique represented decision list depend algorithm determine policy 
apply technique solutions determined approximate linear programming action descriptions permit decision list representation policy 
set weights bellman error efficient solution algorithms factored mdps factored transition model 
set factored reward functions 
discount factor 
set basis functions 
hk 
stores elimination order 
weights linear value function 
return bellman error value function cache backprojections basis functions 
basis function action 
compute decision list policy value function 
initialize indicators 

initialize bellman error 

branch decision list policy generate relevant cost networks solve variable elimination update indicators constraint state space branches 
branch decision list policy instantiate variables assignment instantiate set functions 
partial state assignment store instantiate target functions partial state assignment store instantiate indicator functions partial state assignment store variable elimination solve cost network update bellman error error branch larger 
max 
variable elimination solve second cost network update bellman error error branch larger 
max 
update indicator functions 
update indicators return 
algorithm computing bellman error factored value function guestrin koller parr venkataraman max max max rewards transition model factored appropriately compute max variable elimination cost network described section 
decision list policy induce factored transition model 
fortunately approximate policy iteration algorithm section exploit structure decision list perform maximization ciently 
particular approximate policy iteration generate cost networks branch decision list 
guarantee maximization performed states branch relevant include type indicator functions force irrelevant states value guaranteeing point decision list policy obtain corresponding state maximum error 
state largest bellman error maximum ones generated point decision list policy 
complete factored algorithm computing bellman error outlined 
interesting note concerns approximate policy iteration algorithm projection section 
experiments algorithm converged iterations 
convergence occurs objective function linear program iteration equal bellman error final policy lemma approximate policy iteration max norm projection converges iteration max norm projection error iteration equal bellman error final value function estimate hw proof see appendix 
bound loss acting final policy substituting bellman error bound corollary approximate policy iteration max norm projection converges iterations final value function estimate associated greedy policy greedy loss acting optimal policy bounded actual value policy 
approximate policy iteration converges obtain bound quality resulting policy needing compute bellman error explicitly 
efficient solution algorithms factored mdps 
exploiting context specific structure far suite algorithms exploit additive structure reward basis functions sparse connectivity dbn representing transition model 
exists important type structure exploited cient decision making context specific independence csi 
example consider agent responsible building maintaining house painting task completed plumbing electrical wiring installed probability painting done contexts plumbing electricity done independently agents action 
representation far table represent type function 
table exponentially large number variables scope function ignores context specific structure inherent problem definition 
boutilier 
boutilier dearden boutilier boutilier dean hanks boutilier developed set algorithms exploit csi transition reward models perform cient approximate planning 
approach successful problems value function contains su cient context specific structure approach able exploit additive structure real world problems 
section extend factored mdp model include context specific structure 
simple ective extension algorithms exploit csi additive structure obtain cient approximations factored mdps 
extend factored mdp representation include context specific structure show basic operations section required algorithms performed ciently new representation 
factored mdps context specific additive structure representations context specific functions 
common decision trees boutilier algebraic decision diagrams adds hoey st aubin hu boutilier rules zhang poole 
choose rules basic representation main reasons 
rule representation allows fairly simple algorithm variable elimination key operation framework 
second rules required mutually exclusive exhaustive requirement restrictive want exploit additive independence functions represented linear combination set non mutually exclusive functions 
describing rule representation lines zhang poole presentation probabilistic transition model particular cpds dbn model 
roughly speaking rule corresponds set cpd entries associated particular probability value 
entries value referred consistent contexts definition dom 
say consistent dom assignment variables probability consistent contexts represented probability rules guestrin koller parr venkataraman electrical electrical plumbing electrical plumbing electrical electrical plumbing electrical plumbing painting electrical plumbing painting example cpds variable painting true represented decision trees action paint action paint 
cpds represented probability rules shown respectively 
definition probability rule function context dom consistent equal 
case convenient require rules mutually exclusive exhaustive cpd entry uniquely defined association single rule 
definition rule conditional probability distribution rule cpd function composed set probability rules 
contexts mutually exclusive exhaustive 
define unique rule consistent 
require 
define parents union contexts rules 
example cpd represented set probability rules shown 
rules represent additive functions reward basis functions 
represent context specific value dependencies value rules efficient solution algorithms factored mdps definition value rule function consistent 
note value rule scope important note value rules required mutually exclusive exhaustive 
value rule represents weighted indicator function takes value states consistent context states 
state values zero rules consistent state simply added 
example construction example set rules plumbing done electricity done painting done action plumb 
summed define reward function general reward function represented rule function definition rule function composed set rules 

manner basis functions represented rule function 
notion rule function related tree structure functions boutilier 
substantially general 
tree structure value functions rules corresponding di erent leaves mutually exclusive exhaustive 
total number di erent values represented tree equal number leaves rules 
rule function representation rules mutually exclusive values added form function value di erent settings variables 
di erent rules added di erent settings fact rules easily generate di erent possible values demonstrated section 
rule functions provide compact representation richer class value functions 
rule representation exploit csi additive independence representation factored mdp basis functions 
show basic operations section adapted exploit rule representation 
adding multiplying maximizing consistent rules table algorithms relied standard sum product operators applied tables 
order exploit csi rule representation redefine standard operations 
particular algorithms need add multiply rules ascribe values overlapping sets states 
start defining operations rules context guestrin koller parr venkataraman definition rules context define rule product rule sum 
note definition restricted rules context 
address issue moment 
introduce additional operation maximizes variable set rules share common context definition variable dom 

rule form 
rule function define rule maximization max max operation maximized scope function operations just described applied sets rules satisfy stringent conditions 
set rules amenable application operations need refine rules 
define operation definition rule variable 
define rule split split variable follows scope split split dom split rule variable scope context generate new set rules assignment domain general purpose rule splitting extend context rule coincide context consistent rule naively take variables scope scope split recursively 
process creates unnecessarily rules variable scope scope split dom new rules generated remain consistent assignment consistent rule needs split 
define recursive splitting procedure achieves parsimonious representation definition rule context dom 
define recursive rule split split context follows 
consistent 
scope scope 
split split variable scope scope definition variable scope scope leads generation dom rules step split 
rules recursive step consistent size split set simply scope scope dom 
size independent order variables split operation 
efficient solution algorithms factored mdps note rules split consistent context want add consistent rules need replace rules set split split simply replace resulting rules sum 
multiplication performed analogous manner 
example consider adding set consistent rules 
rules context context rules consistent split perform addition operation split 
likewise split 
result adding rules 
rule step lookahead compact rule representation able compute step lookahead plan ciently models significant context specific additive independence 
section table case rule function represented sum reward function discounted expected value state 
due linear approximation value function expectation term turn represented linear combination backprojections basis functions 
exploit csi representing rewards basis functions rule functions 
represent rule function su cient show represent backprojection basis function rule function 
rule function written form rule restricted scope function simplify backprojection guestrin koller parr venkataraman dom 

select set relevant probability rules parents consistent 
remove assignments context rules multiply consistent rules consistent rules replace rules replace rules set split split 
generate value rules rule update backprojection 
return rule backprojection 
term written rule function 
denote backprojection operation 
backprojection procedure described follows steps 
relevant rules selected cpds variables appear context select rules consistent context rules play role backprojection computation 
second multiply consistent probability rules form local set mutually exclusive rules 
procedure analogous addition procedure described section 
represented probabilities ect mutually exclusive set simply represent backprojection product probabilities value 
backprojection rule function rule mutually exclusive probability rules context new value rule value product probability value 
example example consider backprojection simple rule painting done cpd paint action paint paint efficient solution algorithms factored mdps painting paint painting painting painting done note product simple rules equivalent decision tree cpd shown 
product equal contexts example electricity done time product non zero context context associated rule express result backprojection operation rule function single rule paint plumbing electrical 
similarly backprojection action paint represented single rule paint plumbing electrical painting 
algorithm write backprojection rule basis function sum rule functions rule function 
simplicity notation refer definition backprojection 
notation write rule function 
rule maximization state space second key operation required extend planning algorithms exploit csi modify variable elimination algorithm section handle rule representation 
section showed maximization linear combination table functions restricted scope performed ciently non serial dynamic programming variable elimination 
exploit structure rules algorithm similar variable elimination bayesian network context specific independence zhang poole 
intuitively algorithm operates selecting value rules relevant variable maximized current iteration 
local maximization performed subset rules generating new set rules current variable 
procedure repeated recursively variables eliminated 
precisely algorithm eliminates variables elimination process performs maximization step variable domain 
suppose eliminating collected value rules lead rule function involves additional variables set scope 
need compute maximum value choice dom 
denote procedure takes rule function returns rule function guestrin koller parr venkataraman 
add completing rules 
summing consistent rules consistent rules replace rules replace rules set split split 
maximizing variable repeat empty rules dom remove rules add rule max select rules consistent identical replace split split return maximizing variable rule function max 
procedure extension variable elimination algorithm zhang poole zhang poole 
rule variable elimination algorithm maintains set value rules initially containing set rules maximized 
algorithm repeats steps variable variables eliminated 
collect rules depend remove rules 
perform local maximization step 
add rules eliminated 
cost algorithm polynomial number new rules generated maximization operation 
number rules larger cases exponentially smaller complexity bounds table maximization section turn exponential induced width cost network graph dechter 
computational costs involved managing sets rules usually imply computational advantage rule approach significant problems possess fair amount context specific structure 
remainder section algorithm computing local maximization 
section show ideas applied extending algorithm section exploit csi lp representation planning factored mdps 
procedure divided parts consistent rules added described section variable maximized 
maximization performed generating set rules assignment contexts assignment variables definition 
set substituted single rule assignment context value equal maximum values rules original set 
note simplify efficient solution algorithms factored mdps algorithm initially need add set value rules value guarantee rule function complete rule consistent context 
correctness procedure follows directly correctness rule variable elimination procedure described zhang poole merely replacing summations product max products products sums 
conclude section small example illustrate algorithm example suppose maximizing set rules 
add completing rules get 
part algorithm need add consistent rules add remains unchanged combine split context get inconsistent set rules adding consistent rule split split split 
note rules value generated shown added rules consistent contexts 
move second stage repeat loop 
remove maximize give 
select rules split split empty set changed 
maximizing rules get 
left maximized counterpart gives 
notice maximization split variable giving distinct rules final result 
possible table representation functions variables entries 
guestrin koller parr venkataraman rule factored lp section showed lps algorithms exponentially constraints form substituted single equivalent non linear constraint max 
showed variable elimination represent non linear constraint equivalent set linear constraints construction called factored lp 
number constraints factored lp linear size largest table generated variable elimination procedure 
table algorithm exploit additive independence 
extend algorithm section exploit additive context specific structure rule variable elimination described previous section 
suppose wish enforce general constraint max rule 
table version superscript means depend specifically comes basis function multiplied weight rule reward function 
rule factored linear program generate lp variables associated contexts call lp rules 
lp rule form associated context variable linear program 
transforming original rules lp rules follows rule form comes basis function introduce lp rule equality constraint form comes reward function introduce lp rule form equality constraint lp rules need represent constraint max 
represent constraint follow algorithm similar variable elimination procedure section 
main di erence occurs operation 
generating new value rules generate new lp rules associated new variables new constraints 
simplest case occurs computing split adding lp rules 
example add value rules original algorithm perform operation associated lp rules lp rules replace new rule associated new lp variable context value enforce value constraint simply add additional constraint lp similar procedure followed computing split 
interesting constraints generated perform maximization 
rule variable elimination algorithm maximization occurs replace set rules dom new rule max process lp rule summation maximizing dom generate new lp variable associated rule 
add nonlinear constraint max add set equivalent linear efficient solution algorithms factored mdps constraints simple operations exploit structure rule functions represent nonlinear constraint max lp rule generate 
final constraint implies representing exactly constraints equation having enumerate state 
correctness rule factored lp construction corollary theorem correctness rule variable elimination algorithm zhang poole corollary constraints generated rule factored lp construction equivalent non linear constraint equation 
assignment satisfies rule factored lp constraints satisfies constraint equation 
number variables constraints rule factored lp linear number rules generated variable elimination process 
turn number rules larger exponentially smaller number entries table approach 
illustrate generation lp constraints just described small example example set lp rules depend variable maximized 
rule associated lp variable 
set note rules consistent 
combine generate rules 
constraint similarly may combined resulting 
constraint inconsistent rules maximization 
maximization procedure pair rules eliminated right away split generate rules 
guestrin koller parr venkataraman maximize resulting rule constraints respectively likewise maximizing get completes elimination variable rule factored lp 
algorithm exploiting additive context specific structure lp construction steps planning algorithms 
rule factored lp approach applied directly approximate linear programming approximate policy iteration algorithms sections 
additional modification required concerns manipulation decision list policies section 
approximate linear programming require explicit policy representation default action model approximate policy iteration require represent policy 
fortunately major modifications required rule case 
particular conditionals decision list policies context specific rules 
policy representation algorithm section applied directly new rule representation 
complete framework exploiting additive context specific structure cient planning factored mdps 

experimental results factored representation value function appropriate certain types systems systems involve variables strong interactions variables fairly sparse decoupling influence variables induce unacceptable loss accuracy 
argued herbert simon architecture complexity complex systems nearly decomposable hierarchical structure subsystems interacting weakly 
evaluate algorithm selected problems believe exhibit type structure 
section perform various experiments intended explore performance algorithms 
compare factored approximate linear programming lp approximate policy iteration pi algorithms 
compare projection algorithm koller parr 
second evaluation compares table implementation rule implementation exploit csi 
comparisons approach algorithms boutilier 

approximate lp approximate pi order compare approximate lp approximate pi algorithms tested sysadmin problem described detail section 
problem relates system efficient solution algorithms factored mdps administrator maintain network computers experimented various network architectures shown 
machines fail randomly faulty machine increases probability neighboring machines fail 
time step sysadmin go machine reboot causing working time step high probability 
recall state space problem grows exponentially number machines network problem machines states 
machine receives reward working ring machine receives reward introduce asymmetry zero reward faulty machines discount factor 
optimal strategy rebooting machines depend topology discount factor status machines network 
machine machine faulty benefit rebooting weighed expected discounted impact delaying rebooting successors 
topologies rings policy may function status single machine network 
basis functions included independent indicators machine value working zero restricted scope function single variable constant basis value states 
selected straightforward variable elimination orders star legs topologies eliminated variables corresponding computers legs center computer server eliminated ring started arbitrary computer followed ring order ring star ring machines eliminated center ring rings topology eliminated computers outer rings ones inner ring 
implemented factored policy iteration linear programming algorithms matlab cplex lp solver 
experiments performed sun mhz mb ram 
evaluate complexity approximate policy iteration max norm projection algorithm tests performed increasing number states increasing number machines network 
shows running time increasing problem sizes various architectures 
simplest star backprojection basis function scope restricted variables largest factor cost network scope restricted variables 
di cult bidirectional ring factors contain variables 
note number states growing exponentially indicated log scale running times increase logarithmically number states polynomially number variables 
illustrate behavior fit rd order polynomial running times unidirectional ring 
note size problem description grows quadratically number variables adding machine network adds possible action fixing machine 
problem computation cost factored algorithm empirically grows approximately problem variables opposed exponential complexity poly explicit algorithm 
evaluation measured error approximate value function relative true optimal value function note possible compute small problems case able go machines 
comparison evaluated error approximate value function produced projection guestrin koller parr venkataraman running times policy iteration max norm projection variants sysadmin problem fitting polynomial running time ring topology 
algorithm koller parr 
discussed section projections factored mdps koller parr di cult time consuming able compare algorithms smaller problems equivalent projection implemented explicit state space formulation 
results algorithms showing relative error approximate solutions true value function increasing problem sizes 
results indicate larger problems max norm formulation generates better approximation true optimal value function projection 
types basis functions single variable functions pairwise basis functions 
pairwise basis functions contain indicators neighboring pairs machines functions variables 
expected pairwise basis functions resulted better approximations 
efficient solution algorithms factored mdps relative error optimal value function comparison projection ring large models measuring bellman error convergence 
small problems compare actual value policy generated algorithm value optimal policy 
value policy generated algorithm closer value optimal policy error implied di erence approximate value function example star architecture server clients approximation single variable basis functions relative error policy generated value optimal policy 
case true policy generated projection 
unidirectional ring machines pairwise basis relative error approximation resulting policy loss optimal policy 
problem approximation value function error true policy loss 
words methods induce policies lower errors errors approximate value function small problems 
algorithm continues outperform algorithm respect actual policy loss 
large models longer compute correct value function evaluate results computing hw fortunately discussed section bellman error provide bound approximation error computed ciently exploiting problem specific structure 
shows bellman error increases slowly number states 
valuable look actual decision list policies generated experiments 
noted lists tended short length final decision list policy grew approximately linearly number machines 
furthermore policy fairly intuitive 
ring star architecture example decision list says server faulty fix server machine faulty fix 
far scaling results running times approximation error approximate pi approach 
compare algorithm simpler approximate guestrin koller parr venkataraman approximate lp versus approximate pi sysadmin problem ring topology running time estimated value policy 
lp approach section 
shown approximate lp algorithm factored mdps significantly faster approximate pi algorithm 
fact approximate pi single variable basis functions variables costly computationally lp approach basis functions consecutive triples variables 
shown singleton basis functions approximate pi policy obtains slightly better performance problem sizes 
increase number basis functions approximate lp formulation value resulting policy better 
problem factored approximate linear programming formulation allows basis functions obtain resulting policy higher value maintaining faster running time 
results simpler implementation suggest practice may try apply approximate linear programming algorithm deciding move elaborate approximate policy iteration approach 
comparing table rule implementations evaluation compares table representation exploits additive independence rule representation section exploit additive context specific independence 
experiments implemented factored approximate linear programming algorithm table rule representations cplex lp solver 
experiments performed sun ultrasparc ii mhz gb ram 
evaluate compare algorithms utilized complex extension sysadmin problem 
problem dubbed process sysadmin problem contains state variables machine network load status selector computer runs processes receives rewards processes terminate 
processes represented load variable takes values idle loaded success computer receives reward assignment load success 
status variable efficient solution algorithms factored mdps running time process sysadmin problem various topologies star ring reverse star fit function 
guestrin koller parr venkataraman fraction total running time spent cplex process sysadmin problem ring topology 
representing status machine takes values faulty dead value faulty processes smaller probability terminating value dead running process lost load idle 
status machine faulty eventually dead random machine receives packet dead machine probability status faulty dead increases 
selector variable represents communication selecting neighbors uniformly random time step 
sysadmin select computer reboot time step 
computer rebooted status probability running process lost load variable idle 
problem sysadmin balance conflicting goals rebooting machine kills processes rebooting machine may cause cascading faults network 
furthermore sysadmin choose machine reboot imposes additional tradeo selecting potentially faulty dead machines network reboot 
experimented types basis functions single includes indicators joint assignments load status selector pair addition includes set indicators status status selector neighbor machine network 
discount factor 
variable elimination order eliminated load variables followed patterns simple sysadmin problem eliminating status selector machine eliminated 
compares running times table implementation ones rule representation topologies star ring reverse star 
reverse star topology reverses direction influences star central machine influencing machines topology machines influence central 
topologies demonstrate di erent levels csi efficient solution algorithms factored mdps star topology factors generated variable elimination small 
running times polynomial number state variables methods representation significantly faster rule due overhead managing rules 
ring topology illustrates intermediate behavior single basis functions induce relatively small variable elimination factors table approach faster 
pair basis factors larger rule approach starts demonstrate faster running times larger problems 
reverse star topology represents worst case scenario table approach 
scope backprojection basis function central machine involve computers network machines potentially influence central time step 
size factors table variable elimination approach exponential number machines network illustrated exponential growth 
rule approach exploit csi problem example status central machine status depends machine value selector selector exploiting csi solve problem polynomial time number state variables seen second curve 
instructive compare portion total running time spent cplex table compared rule approach 
illustrates comparison 
note amount time spent cplex significantly higher table approach 
reasons di erence due csi lps generated rule approach smaller table ones second rulebased variable elimination complex table due overhead introduced rule management 
interestingly proportion cplex time increases problem size increases indicating asymptotic complexity lp solution higher variable elimination suggesting larger problems additional large scale lp optimization procedures constraint generation may helpful 
comparison closely related line research began boutilier 

particular approximate algorithm hoey 
uses analytic decision diagrams adds represent value function strong alternative approach solving factored mdps 
discussed detail section algorithm successfully exploit context specific structure value function representing set mutually exclusive exhaustive branches add 
hand approach exploit additive context specific structure problem linear combination non mutually exclusive rules 
better understand di erence evaluated rule approximate linear programming algorithm problems linear designed boutilier 
illustrate respectively best case worst case behavior algorithm 
experiments web distributed version hoey st aubin hu boutilier running locally linux pentium iii mhz gb ram 
guestrin koller parr venkataraman comparing rule approximate linear programming linear problems 
problems involve binary variables 
deterministic actions 
reward variables true 
problem discounted factor 
di erence linear problems transition probabilities 
linear problem action sets variable true succeeding variables false 
state space linear problem seen binary number optimal policy set repeatedly largest bit variable preceding bits set true 
add optimal value function problem represented linear space leaves boutilier 
best case algorithm compute value function quite ciently 
compares running time algorithms indicator basis functions pairs consecutive variables 
note algorithms obtain policy polynomial time number variables 
structured problems cient implementation add package faster problem 
hand problem illustrates worst case 
problem action sets variable true preceding variables true preceding variables false 
state space seen binary number optimal policy goes binary numbers sequence repeatedly setting largest bit variable preceding bits set true 
due discounting optimal value function assigns value jth binary number value function contains exponentially di erent values 
add optimal value function problem requires exponential number leaves boutilier illustrated exponential running time 
value function approximated compactly factored linear value function basis functions indicator variable constant base 
shown representation factored approximate linear programming algorithm computes value function polynomial time 
furthermore efficient solution algorithms factored mdps comparing rule approximate linear programming single basis functions process sysadmin problem ring topology running time value resulting policy star topology running time value resulting policy 
policy obtained approach optimal problem 
problem ability exploit additive independence allows cient polynomial time solution 
compared rule approximate linear programming algorithm process sysadmin problem 
problem significant additive structure reward function factorization transition model 
type structure exploited directly add approximation steps performed algorithm principle allow find approximate solutions problem 
spent significant amount time attempting find best set parameters problems 
settled sift method variable reordering round approximation method size maximum add size criteria 

grateful jesse hoey robert st aubin assistance selecting parameters 
guestrin koller parr venkataraman allow value function representation scale problem size set maximum add size network machines 
experimented variety di erent growth rates maximum add size parameters selected choice gave best results 
compared parameters rule approximate linear programming algorithm single basis functions pentium iii mhz gb ram 
results summarized 
small problems machines performance algorithms fairly similar terms running time quality policies generated 
problem size grows running time increases rapidly significantly higher algorithm furthermore problem size increases quality policies generated deteriorates 
di erence policy quality caused di erent value function representation algorithms 
adds represent di erent values leaves forced di erent states represent single value 
smaller problems agglomeration represent policies 
unfortunately problem size increases state space grows exponentially policy representation inadequate quality policies decreases 
hand linear value functions represent exponentially values basis functions allows approach scale significantly larger problems 

related closely related line research began boutilier 

address comparison separately section broader background 
approximate mdp solutions field mdps popularly known formalized bellman 
importance value function approximation recognized early stage bellman 
early mdp framework recognized ai researchers formal framework address problem planning uncertainty dean kaelbling kirman nicholson 
ai community value function approximation developed notion value function representations markov chains 
sutton seminal temporal di erence learning addressed value functions prediction planning assumed general representation value function noted connection general function approximators neural networks 
stability combination directly addressed time 
important developments gave ai community deeper insight relationship function approximation dynamic programming 
tsitsiklis van roy independently gordon popularized analysis approximate mdp methods contraction properties dynamic programming operator function approximator 
tsitsiklis van roy established general convergence result linear value function approximators td bertsekas efficient solution algorithms factored mdps tsitsiklis unified large body approximate dynamic programming name neuro dynamic programming providing novel general error analyses 
approximate linear programming mdps linear value function approximation introduced schweitzer approach somewhat deprecated fairly due lack compelling error analyses lack ective method handling large number constraints 
de van roy started address concerns new error bounds constraint sampling methods 
approach sampling constraints utilizes structure model value function represent constraints compactly 
factored approaches shachter considered additive decomposition value nodes influence diagrams 
number approaches factoring general mdps explored literature 
techniques exploiting reward functions decompose additively studied meuleau 
singh cohn 
factored representations dynamic bayesian networks pioneered boutilier 
developed steadily years 
methods rely context specific structures decision trees analytic decision diagrams adds hoey represent transition dynamics dbn value function :10.1.1.111.5793
algorithms dynamic programming partition state space representing partition tree structure branches state variables assigns values leaves 
tree grown dynamically part dynamic programming process algorithm creates new leaves needed leaf split application dp operator states associated leaf turn di erent values backprojected value function 
process interpreted form model minimization dean givan 
number leaves tree represent value function determines computational complexity algorithm 
limits number distinct values assigned states leaves represent partitioning state space state maps exactly leaf 
recognized early trivial mdps require exponentially large value functions 
observation led line approximation algorithms aimed limiting tree size boutilier dearden limiting add size st aubin hoey boutilier 
kim dean explored techniques discovering tree structured value functions factored mdps 
methods permit approximate solutions large mdps complexity determined number leaves representation number distinct values assigned states limited 
tadepalli ok apply linear value function approximation factored mdps 
linear value function approximation potentially expressive approximation method assign unique values state mdp requiring storage space exponential number state variables 
expressive power tree leaves captured linear function approximator basis functions basis function indicator function tests state belongs guestrin koller parr venkataraman partition leaf set value functions represented tree leaves subset set value functions represented value function basis functions 
experimental results section highlight di erence showing example problem requires exponentially leaves value function approximated linear value function 
main advantage tree value functions structure determined dynamically solution mdp 
principle value function representation derived automatically model description approach requires insight user 
problems value function approximated relatively small number values approach provides excellent solution problem 
method linear value function approximation aims address believe common case large range distinct values required achieve approximation 
note schuurmans earlier max norm projection cost networks linear programs independently developed alternative approach approximate linear programming cost network 
method embeds cost network inside single linear program 
contrast method constraint generation approach cost network detect constraint violations 
constraint violations new constraint added repeatedly generating attempting solve lps feasible solution 
interestingly approach schuurmans uses multiple calls variable elimination order speed lp solution step successful time spent solving lp significantly larger time required variable elimination 
suggested section lp solution time larger table approach 
schuurmans constraint generation method probably successful table problems rule ones 

new algorithms approximate linear programming approximate dynamic programming value policy iteration factored mdps 
algorithms leverage novel lp decomposition technique analogous variable elimination cost networks reduces exponentially large lp provably equivalent polynomial sized 
approximate dynamic programming algorithms motivated error analyses showing importance minimizing error 
algorithms cient substantially easier implement previous algorithms projection 
experimental results suggest perform better practice 
approximate linear programming algorithm factored mdps simpler easier implement general dynamic programming approaches 
policy iteration algorithm rely default action assumption states actions ect small number state variables 
algorithm theoretical guarantees max norm projection approaches empirically favorable option 
experiments suggest approximate policy iteration tends generate better policies set basis functions 
due computa efficient solution algorithms factored mdps tional advantages add basis functions approximate linear programming algorithm obtaining better policy maintaining faster running time approximate policy iteration 
previous approaches algorithms exploit additive structure factored mdp model 
typical real world systems possess types structure 
feature algorithms increase applicability factored mdps practical problems 
demonstrated exploiting context specific independence rule representation standard table yield exponential improvements computational time problem significant amounts csi 
overhead managing sets rules suited simpler problems 
compared approach boutilier 
exploits context specific structure 
problems significant context specific structure value function approach faster due cient handling add representation 
problems significant context specific structure problem representation value function require exponentially large adds 
problems demonstrated linear value function algorithm obtain polynomial time near optimal approximation true value function 
success algorithm depends ability capture important structure value function linear factored approximation 
ability turn depends choice basis functions properties domain 
algorithms currently require designer specify factored basis functions 
limitation compared algorithms boutilier 
fully automated 
experiments suggest simple rules quite successful designing basis 
ensure reward function representable basis 
simple basis addition contained separate set indicators variable quite 
add indicators pairs variables simply choose dbn transition model indicator added variables variables parents representing step influences 
procedure extended adding basis functions represent influences required 
structure dbn gives indications choose basis functions 
sources prior knowledge included specifying basis 
general algorithm choosing factored basis functions exist 
potential approaches problems csi apply algorithms boutilier iterations generate partial treestructured solutions 
indicators defined variables backprojection leaves turn generate basis set problems 
second bellman error computation performed ciently shown section provide bound quality policy actual state error largest 
knowledge create mechanism incrementally increase basis set adding new basis functions tackle states high bellman error 
possible extensions 
pursued extensions collaborative multiagent systems multiple agents act simultaneously maximize global reward guestrin factored pomdps guestrin koller parr venkataraman full state observed directly indirectly observation variables guestrin koller parr :10.1.1.19.9428
settings remain explored 
particular hope address problem learning factored mdp planning competitive multiagent system 
additionally tackled problems induced width cost network su ciently low possess su cient context specific structure allow exact solution factored lps 
unfortunately practical problems may prohibitively large induced width 
plan leverage ideas loopy belief propagation algorithms approximate inference bayesian networks pearl yedidia freeman weiss address issue 
believe methods described significantly extend ciency applicability general usability factored models value functions control practical dynamic systems 
grateful craig boutilier dirk ormoneit uri lerner useful discussions anonymous reviewers detailed thorough comments 
jesse hoey robert st aubin alan hu craig boutilier distributing algorithm useful assistance selecting parameters 
supported dod muri program administered ce naval research air force contract darpa task program sloan foundation 
author supported scholarship 
appendix proofs proof lemma exists setting weights zero setting yields bounded projection error policy max 
max norm projection operator chooses set weights minimizes projection error policy projection error low zero weights bounded 
error remains bounded iterations 
proof theorem need bound approximation hw hw hw hw triangle inequality hw hw hw contraction 
moving second term right hand side dividing obtain hw hw hw 
efficient solution algorithms factored mdps part proof adapt lemma bertsekas tsitsiklis lemma fit framework 
manipulation lemma reformulated hw 
proof concluded substituting equation equation induction proof theorem note equality constraints represent simple change variable 
rewrite equation terms new lp variables max assignment weights implies assignment stage lp variables 
remains show factored lp construction equivalent constraint equation 
system variables 
assume loss generality variables eliminated starting prove equivalence induction number variables 
base case functions equation empty scope 
case equation written 
case transformation done constraint equivalence immediate 
assume result holds systems variables prove equivalence system variables 
system maximization decomposed terms factors depend irrelevant maximization term factors depend decomposition write equation max max max 
point define new lp variables corresponding second term right hand side constraint 
new lp variables satisfy constraint max 
guestrin koller parr venkataraman new non linear constraint represented factored lp construction set equivalent linear constraints 
equivalence non linear constraint equation set linear constraints equation shown considering binding constraints 
new lp variable created new constraints created value assignment lp variables right hand side constraint equation constraints relevant 
maximal corresponds maximum value assignment achieves maximum constraints corresponding maximizing assignments binding 
equation equation equivalent 
substituting new lp variables equation get max depend anymore 
equivalent system variables concluding induction step proof 
proof lemma note iteration objective function max norm projection lp hw hw convergence value function estimates equal iterations hw hw operator notation term equivalent hw hw note greedy hw definition 
hw hw substituting previous expression obtain result hw hw efficient solution algorithms factored mdps arnborg corneil 

complexity finding embeddings tree 
siam journal algebraic discrete methods 
becker geiger 

su ciently fast algorithm finding close optimal clique trees 
artificial intelligence 
bellman 

polynomial approximation new computational technique dynamic programming 
math 
comp 
bellman 

dynamic programming 
princeton university press princeton new jersey 


dynamic programming 
academic press new york 
bertsekas tsitsiklis 

neuro dynamic programming 
athena scientific belmont massachusetts 
boutilier dean hanks 

decision theoretic planning structural assumptions computational leverage 
journal artificial intelligence research 
boutilier dearden 

approximating value trees structured dynamic programming 
proc 
icml pp 

boutilier dearden goldszmidt 

exploiting structure policy construction 
proc 
ijcai pp 

boutilier dearden goldszmidt 

stochastic dynamic programming factored representations 
artificial intelligence 
cheney 

approximation theory nd edition 
chelsea publishing new york ny 
de van roy 

linear programming approach approximate dynamic programming 
submitted operations research 
de van roy 

constraint sampling linear programming approach approximate dynamic programming 
appear mathematics operations research 
dean kaelbling kirman nicholson 

planning deadlines stochastic domains 
proceedings eleventh national conference artificial intelligence aaai pp 
washington aaai press 
dean kanazawa 

model reasoning persistence causation 
computational intelligence 
dean givan 

model minimization markov decision processes 
proceedings fourteenth national conference artificial intelligence aaai pp 
providence rhode island oregon 
aaai press 
dearden boutilier 

abstraction approximate decision theoretic planning 
artificial intelligence 
guestrin koller parr venkataraman dechter 

bucket elimination unifying framework reasoning 
artificial intelligence 
gordon 

stable function approximation dynamic programming 
proceedings twelfth international conference machine learning pp 
tahoe city ca 
morgan kaufmann 
guestrin koller parr 

max norm projections factored mdps 
proceedings seventeenth international joint conference artificial intelligence ijcai pp 
seattle washington 
morgan kaufmann 
guestrin koller parr 

multiagent planning factored mdps 
th neural information processing systems nips pp 
vancouver canada 
guestrin koller parr 

solving factored pomdps linear value functions 
seventeenth international joint conference artificial intelligence ijcai workshop planning uncertainty incomplete information pp 
seattle washington 
guestrin venkataraman koller 

context specific multiagent coordination planning factored mdps 
eighteenth national conference artificial intelligence aaai pp 
edmonton canada 
hoey st aubin hu boutilier 

spudd stochastic planning decision diagrams 
proceedings fifteenth conference uncertainty artificial intelligence uai pp 
stockholm sweden 
morgan kaufmann 
hoey st aubin hu boutilier 

stochastic planning decision diagrams implementation 
www cs ubc ca spider spudd 
howard matheson 

influence diagrams 
howard matheson 
eds readings principles applications decision analysis pp 

strategic decisions group menlo park california 
keeney rai 

decisions multiple objectives preferences value tradeo wiley new york 
kim dean 

solving factored mdps non homogeneous partitioning 
proceedings seventeenth international joint conference artificial intelligence ijcai pp 
seattle washington 
morgan kaufmann 


triangulation graphs algorithms giving small total state space 
tech 
rep tr department mathematics computer science aalborg denmark 
koller parr 

computing factored value functions policies structured mdps 
proceedings sixteenth international joint conference artificial intelligence ijcai pp 

morgan kaufmann 
koller parr 

policy iteration factored mdps 
proceedings sixteenth conference uncertainty artificial intelligence uai pp 
stanford california 
morgan kaufmann 
efficient solution algorithms factored mdps meuleau hauskrecht kim peshkin kaelbling dean boutilier 

solving large weakly coupled markov decision processes 
proceedings th national conference artificial intelligence pp 
madison wi 
pearl 

probabilistic reasoning intelligent systems networks plausible inference 
morgan kaufmann san mateo california 
puterman 

markov decision processes discrete stochastic dynamic programming 
wiley new york 
reed 

finding approximate separators computing tree width quickly 
th annual symposium theory computing pp 

acm 
schuurmans 

direct value approximation factored mdps 
advances neural information processing systems nips pp 
vancouver canada 
schweitzer 

generalized polynomial approximations markovian decision processes 
journal mathematical analysis applications 
simon 

sciences artificial second edition 
mit press cambridge massachusetts 
singh cohn 

dynamically merge markov decision processes 
jordan kearns solla 
eds advances neural information processing systems vol 

mit press 
st aubin hoey boutilier 

approximate policy construction decision diagrams 
advances neural information processing systems proceedings conference pp 
denver colorado 
mit press 
stiefel 

note jordan elimination linear programming approximation 
numerische mathematik 
sutton 

learning predict methods temporal di erences 
machine learning 
tadepalli ok 

scaling average reward learning approximating domain models value function 
proceedings thirteenth international conference machine learning bari italy 
morgan kaufmann 
shachter 

dynamic programming influence diagrams 
ieee transactions systems man cybernetics 
tsitsiklis van roy 

feature methods large scale dynamic programming 
machine learning 
tsitsiklis van roy 

analysis temporal di erence learning function approximation 
technical report lids laboratory information decision systems massachusetts institute technology 
van roy 

learning value function approximation complex decision processes 
ph thesis massachusetts institute technology 
guestrin koller parr venkataraman williams baird 

tight performance bounds greedy policies imperfect value functions 
tech 
rep college computer science northeastern university boston massachusetts 
yedidia freeman weiss 

generalized belief propagation 
advances neural information processing systems proceedings conference pp 
denver colorado 
mit press 
zhang poole 

role context specific independence probabilistic reasoning 
proceedings sixteenth international joint conference artificial intelligence ijcai pp 

morgan kaufmann 

