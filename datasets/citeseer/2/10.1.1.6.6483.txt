typability type checking system equivalent undecidable wells hw ac uk www hw ac uk heriot watt university dept computing electrical engineering edinburgh eh scotland october girard reynolds independently invented system second order polymorphically typed lambda calculus handle problems logic computer programming language design respectively 
viewing curry style associates types untyped lambda terms raises questions typability type checking typability asks term exists type 
type checking asks particular term type term type 
decidability problems settled restrictions extensions related systems complexity lower bounds determined typability report rst resolve problems decidable system report proves type checking undecidable reduction cation typability undecidable reduction type checking 
easy reduction typability type checking problems equivalent 
reduction type checking typability uses novel method constructing lambda terms simulate arbitrarily chosen type environments 
results hold calculus 
background summary report divided non technical technical 
section non technical portion 
sections technical 
problems 
years numerous type systems devised church calculus generally extensions simply typed calculus 
particularly important type system secondorder polymorphically typed calculus independently invented girard reynolds years ago gir rey 
girard developed system named chance system prove properties second order logic called second order calculus reynolds wanted express polymorphic typing programming explicitly 
girard reynolds formulated church style types embedded terms longer terms pure calculus 
curry style type information kept distinct terms meaningful ask arbitrarily chosen term earlier versions material wel wel 
partly supported nsf ccr ccr epsrc gr 

typing exist assumptions type derivable 

particular type particular type assumptions arbitrarily chosen derivable 
call rst problem typ typability second problem tc type checking problem type inference problem nding types type assumptions allow typability type checking 
type system indicated names typ tc refer problems system prior research 
research devoted determining typ tc decidable related systems 
research focused directly system leivant rst curry style rst attempt answer question decidability typ lei 
rst interesting lower bound computational complexity typ henglein hm hm showed typ dexptime hard dexptime means dtime 
done embedding turing machine computations types term 
research considered typ tc various restrictions extensions system related problems 
multiple strati cations proposed restrict parameter derivations nite values depth bound type variable binding quanti er number generations instantiation quanti ers introduced instantiation lei rank polymorphic types introduced lei studied mcc kt kw 
urzyczyn showed typ undecidable powerful extension system allows types contain functions types types 
proof reduces halting problem turing machines typ establishes recursive inseparability typable terms terms normal forms 
proofs undecidability problem partial polymorphic type inference church style boe pfe related typ problem conditional type inference related tc 
fraction research years mentioned 
despite intensive research program decidability typ tc remained embarrassing open problems system 
problems proven undecidable article 
implications 
theoretical considerations part motivation determining decidability typ tc 
type systems calculus result extending simply typed calculus combination universal recursive intersection types equivalence approximation rules decidability typ tc remained unknown depicted table gure rst appeared bar 
typability called type reconstruction type inference 
type checking called derivation reconstruction 
church style type checking usually means checking derivation valid nding derivation 
robin milner winner turing award quoted henk barendregt bar 
gure inh stands inhabitation problem asks type exist derivable 
equivalence rule extends type system typing typing see bar explanation approximation rule 
constructors rules tc typ inh tc type checking problem typ typability problem inh type inhabitation problem plus equivalence rule plus approximation rule trivially decidable rule proved proved article decidability various type system problems 
type systems barendregt cube bar considered curry style distinct sets typable pure closed terms corresponding simply typed calculus 
depicted gure 
known typ decidable simply typed calculus hin undecidable answer unknown 
determining decidability typ tc completes knowledge problems wide variety calculus type systems 
question decidability typ theoretical interest prime motivation solving problem practical implications 
design functional computer programming languages calculus ability perform type inference system better extension highly desirable 
primary reason types functional programming languages usual desire rule nonsensical computations 
types prevent undesirable run time operations occurring types rule application true true 
operations unsafe require run time coercions 
functional programming languages type systems related system designers strongly typed functional programming languages ml mth miranda tur haskell hw chosen hindley milner type system core coincides fragment various programming languages type systems variations 
quest car leap pl 
choice type system similar portion real world programming languages reasons 
minimal requirement type system rules nonsense computations 
achieved considerations 
software engineering viewpoint programmers wish reuse program fragments duplicating 
choice type system determines easily programmers reuse code 
worst case simply typed calculus requires simple function identity represented term duplicated type 
compiler enforce redundancy programming language type system 
avoid chosen type system generally supports kind polymorphism allows giving function polymorphic generic type represents nite nite collection types 
system exhibits kind polymorphism called parametric polymorphism meaning 

simply typed calculus curry church style type system correspondence 
term operates way range types particular type instance determined type parameter 
hindley milner type system supports weak restriction parametric polymorphism allows polymorphic function passed parameter single predetermined non polymorphic function 
polymorphic function monomorphic arguments 
full system polymorphic function passed parameter non predetermined polymorphic function passed parameter functions 
exibility re ected fact system types terms hindley milner type system 
fact computable function provably total second order peano arithmetic representable term typable system glt 
reason system related system computations typable terms guaranteed halt 
practice general purpose programming languages add features allow non termination property helpful compiler handling subexpressions non terminating features 
special purpose programming languages take advantage property system important criterion choosing type system functional programming language desire typing done automatically compiler programmer 
function application central construct functional programming language strict typing involves assigning type identi er fragment program 
nature functional types grow large requiring programmer specify tiny fraction types term unwieldy user unfriendly 
reasons contribute desire type inference procedure provide typing term typable halt return error message 
part ensuring programs portable di erent versions language compiler type inference algorithm compiler nd type ideally general type program fragment possible 
type inference algorithm guaranteed halt program fragment untypable 
compiler choose arbitrarily point halted impatient user impede program portability di erent compiler versions 
typ decidable type system automatic type inference portability programs achieved 
system nice properties desired type system functional programming language problematic language automatic type inference typ decidable 
unfortunately article proves typ undecidable system article contribute 
main contribution report proving undecidability typ tc system 
rst prove problem semi uni cation reduced tc simple encoding 
semi uni cation undecidable ktu tc 

reduce tc typ novel method building terms simulate arbitrarily chosen type environments 
proof begins showing exists typable term typing bound variable assigned type yy yz kx xv ww building term contexts terms holes constructed simulate complex type environments 
terms force particular bound variables assigned particular types type derivation 
method require subterms certain positions term typable speci arbitrarily chosen type environment order entire term typable 
desired type environment may simulated allowing instance tc simulated instance typ 
establishes undecidability typ 
results calculus calculus bound variable occurs scope binding 
reduction typ tc known bar reductions calculus conclude system typ tc equivalent undecidable calculi 
showing problems undecidable mentioned earlier question decidability typ tc variety type systems completely answered 
result table gure lled completely addition result type inhabitation intersection types undecidable 
important practical implication results functional programming language type system fully automatic type inference 
focus research restrictions entirely di erent approaches 
results implications practical theoretical interest 

methods article show undecidability tc typ restrictions extensions system symbol name type system results restricting system types nite rank notion introduced leivant lei 
methods show undecidability typ tc kw 
methods extended show undecidability typ system result extending rule subject reduction equivalent extending mitchell subtyping wel wel 

methods article show di erences sets terms typable various restrictions extensions easily exhibit terms typable subsystem typable tm tm sup ca sub tc tc tc typ typ fch typ typ wells wells hooper minsky urzyczyn schubert schubert wells wells jim goldfarb special comment partial undec 
folk result trivial known report tc type checking system typ typability plus rule halting prob 
fch church style ca counter automata nd order unif 
tm turing machine sup semi uni sub mitchell subtyping undecidability reductions related system typable extension example show types terms arbitrarily chosen rank term constructed typing contain type rank 
similarly force typings contain types arbitrarily chosen height level strati cation system types larger set terms previous level 
nal example slight modi cation term strongly normalizing typable system rst term yy yz kx xv ww diagrams relationships various undecidable problems related systems arrow indicating problem reduction 
dotted arrows trivial reductions light dashed arrow folk result reported indicated authors double lines indicate results report 
heavy dashed line indicates part problem reduced show undecidability 
diagram problems tm tm ca sup sub respectively halting problem problem turing machines hoo halting problem counter automata min second order uni cation problem gol semi uni cation problem mitchell subtyping relation mit tu wel jim 
diagram system fch church style presentation system binding occurrences variables annotated types 
schubert discovered surprising result typability system undecidable sch 
note reduction ca sub tu prove undecidable fragment sub matches partial reduction tc typ wel wel contribute proving typ undecidable 
similarly goldfarb original proof undecidability second order uni cation contribute proving typability undecidable church style system helped happen 
author ph student boston university supported research assistant nsf ccr ccr 
nal revision done author researcher university glasgow heriot watt university supported epsrc gr 
time author advisor kfoury provided vital support encouragement 
results achieved jerzy tiuryn valuable suggestions notation organization proofs urzyczyn drafts pointed numerous improvements 
anonymous referees helpful suggestions 
basic de nitions notation section presents basic de nitions notation nomenclature standard concepts 
de ne untyped calculus system curry style 
state precisely problems typability typ type checking tc semi uni cation sup 
general notation small roman letters middle alphabet metavariables ranging natural numbers 
say character metavariable set applies superscripted subscripted variations 
kind entity notation denotes sequence 
notation denotes natural number unspeci ed clear context 
notation may stand set fx comma separated sequence depending context 
function may partial expression dom denotes domain de nition ran denotes range injective function expression denotes inverse functions expression denotes de ned function exists set function application denotes set denotes restriction function de ned dom sequence writing denotes sequence 

set expression jsj gives cardinality written size 
terms notation calculus generally follows barendregt bar 
set terms built countably nite set term variables application abstraction speci ed grammar small roman letters alphabet metavariables ranging capital roman letters middle alphabet metavariables ranging 
writing terms omitted parentheses inferred rule application associates left scope binding extends far right possible mnp mn mn mn 
notation stands 
appropriate allow terms obey restriction variable bound variable occurs bound free 
symbol denotes standard combinator 
expressions fv bv denote respectively free bound variables term fv bv 
term open bound variables closed free variables 
terms means syntactically identical need conversion terms article 
statement denotes proper subterm includes possibility grammar terms extended possibility distinguished symbol called hole yield notion context 
contexts hole allowed 
range contexts 
term denotes result replacing hole including possible capture free variables bindings context de ne subset bound variables bv scope includes hole notions de ned terms automatically extended contexts 
hole context considered contain variables free bound 
term variable renaming bijective mapping renaming di ers identity nitely variables may speci ed nite mapping dom ran automatically extended identity dom 
application renaming term carried replacing variable bound free 
note substitution conversion de ned terms report 
terms de ned far belong usual calculus called calculus 
calculus similar forbids binding variables bound occurrences 
set terms calculus de ned terms subterms form fv 
types set type expressions exp built countably nite set type variables type constructors speci ed grammar exp vj exp exp exp small greek letters alphabet metavariables small greek letters alphabet metavariables exp writing type expressions omitted parentheses inferred rule arrows associate right scope binding extends far right possible 

expression ftv denotes free type variables type expression type expression open bound type variables closed free type variables 
type expression quanti ers adjacent type expression ftv redundant quanti er 
set types obtained exp quotienting exp operations conversion reordering adjacent quanti ers inserting deleting redundant quanti ers 
set obtained exp quotienting exp conversion considering operations 
example reordering conversion type expressions denote member denote member example insertion deletion redundant quanti ers type expressions denote member speci ed type expressions report denote types 
operations types speci ed type expressions represent types 
type expressions quanti ers identi ed corresponding type 
usual de nition system uses see section proof signi cant di erence 
type type variable type type 
capital roman letters blackboard bold style xand metavariables subsets set types notation ftv denotes ftv 
notation stands 
turn stands 

symbol shorthand notation means ftv 
convention 
type expressions written specify types default meaning type expression report conversion assumed variable bound bound type variables type expressions distinct bound type variables type expression distinct free type variables type expression 
substitution partial function range substitutions 
type substitution automatically extended function standard way extended identity variables domain de nition simultaneously substitutes free occurrences renaming bound variables necessary avoid capturing free variables 
substitution may speci ed usual ways writing partial functions 
addition notation may abbreviated denotes substitution 
application nameless substitution written substitution right named substitution written left 
type variable renaming bijective substitution dom ran guarantees extended identity variables dom extended function bijection 
renaming partial function renaming term variables renaming type variables 
applied term applied type 
notation means type properly embedded type relation transitive closure smallest relation exist 
de nition bit unusual 
notation includes possibility type inference pair tis called type assumption 
nite set type assumptions fx associates type term variable type environment 
assume variable bound twice term viewing type environment set causes problems 
type environment viewed function denotes unique type expression ftv denotes ftv ran 
type environment de ne renaming de ne expression type environment term sequent 
assume sequent case bound type variables named distinctly bound free type variables overlap satis ed conversion 
derivation consists nal sequent zero subderivations rule nal sequent valid rule nal sequents type assumption called declaration type assignment type statement 
type environment called type assignment basis environment context term context usually indicates ordered 
sequent called assertion type assignment formula judgement typing 
var app abs fx dom inst gen ftv type inference rules system subderivations premises 
may write hr di 
extend renamings derivations hr di hr 
part gen global type environment 
due assumption variable bound term de ned type environment 
nal derived type subterm occurrence fdt outermost sequent mention subject 
derivation clear context discussion fdt fdt 
inference rules system gure 
speci ed derivations report system name gen stands collection gen type variables typing term derivation nal sequent type environment type term typable typing de nition typ 
typability problem arbitrarily chosen term typable 
de nition tc 
type checking problem arbitrarily chosen term type environment type derivation nal sequent 
semi uni cation convenience de ne semi uni cation rst order signature containing single binary function symbol case pairs terms 
general de nition semi uni cation reducible special case ktu proof semi uni cation undecidable special case ktu 
notion completely de ned may multiple occurrences subterm distinct typings 
pose problem report clear context discussion subterm occurrence meant 
set algebraic terms de ned grammar 
de nition chosen allows mapping terms types 
fact 
instance semi uni cation set pairs open substitution substitution ran contains open types 
open substitution solution instance semi uni cation exist open substitutions 
de nition sup 
semi uni cation problem arbitrarily chosen instance semi uni cation solution 
properties derivations system section proves useful properties derivations system properties easier reason manipulate derivations 
basic properties de nition inst gen property 
derivation satis es inst property premise inst rule gen rule 
lemma 
derivation sequent derivation sequent satis es inst gen property 
proof 
immediate consequence restatement theorem direct consequence normalization property second order deductions pra 
de nition gen distinct derivations 
derivation gen distinct subderivation gen case type variable appear free subderivation lemma 
derivation gen distinct derivation nal sequent rule tree structure proof 
set strings range denote empty string 
denote concatenation 
injective function type variables appear de ne function derivations follows di 
hr hr 

fvar abs app pairs written symbol 
avoid symbol frequent denoting subtyping relationships 
possible de ne semi uni cation requirement solution open dropped 
de nition proof undecidability ktu necessary prove problems equivalent 


type variable renaming swaps fresh type variable identity variables appearing checked gen distinct derivation nal sequent rule tree structure 
lemma henceforth assumed speci ed derivations gen distinct 

church style presentation system inst gen property expressed notion normal form respect type level reduction 
gen distinct property expressed notion distinct type level abstractions binding distinct type variable names 
lemma specialized version standard weakening lemma 
version interested nal result weakened derivation necessary alter internal structure derivation get result 
lemma weakening 
derivation sequents type environment dom dom 
set type variables generalized type variable renaming type variable occurring fresh mentioned maps ftv fresh names 
derivation sequents proof 
induction length de nition 
de nition range types sets types type environments 
relation dom ftv ftv ftv 
relation dom ftv 
lemma initial final derived types 
typing subterm occurrence 
subderivation idt fdt 
furthermore satis es inst gen property idt fdt 
proof 
induction derivations 
lemma inst gen generation 
derivation satisfying inst gen property 

nal sequent 
nal sequent mn contains subderivation form 

app mn 
nal sequent ftv contains subderivation form 
fx abs proof 
lemma rules system gure 
lemmas implicitly proofs rest reader needs remember 
adjacent redundant quanti ers section shows report convention freely allowing reordering adjacent quanti ers types adding removing redundant quanti ers types ect set terms typable system negligible ect derivable typings 
de nition canonical type expressions 
function de ned follows ftv members order left right leftmost occurrences extend type environments 
type canonical ran 
de ned way system de nition system derivation canonical types appearing canonical 
lemma 
derivable system canonical derivation 
proof 
induction structure derivations 
hr derivation system cases rule 
cases var abs app omitted simple 
interesting cases gen inst 
suppose gen step looks gen induction hypothesis canonical derivation 
cases 
suppose ftv 

desired derivation 
suppose ftv 
type 
observe 
observe ftv 
conversion take ftv 
multiple uses inst starting sequent derivable multiple uses gen derive resulting derivation satis es claim lemma 

suppose inst 
step looks inst induction hypothesis canonical derivation 
cases 
usual de nition system fact suppose ftv 

desired derivation 
suppose ftv 
type 
conversion take ftv ftv distinct 
observe 
multiple uses inst starting sequent derivable inst sequent derivable multiple uses gen sequent derivable observe occurrence root immediately 
checked resulting derivation satis es claim lemma 
undecidability type checking system section proves tc undecidable system proof works reducing sup problem tc problem 
theorem sup tc 
sup single binary function symbol pairs problem instance reducible tc system furthermore reduction works system restricted terms calculus 
proof 
consider instance sup form free type variables contained pick fresh type variables construct instance tc sup instance construct term depend construct type environment depends 

free type variable type typable type environment bound type variables correspond directly variables occurring semi uni cation instance bound type variables care types instantiated long match needs matched 
bound type variable require nal derived type equal assigned type easy see term term calculus 
left show solution derivation system nal sequent directions proved separately rest proof 
suppose solution open substitutions 
derivation follows 
type environment fx sequents clearly derivable merely var inst rules 

form solution sequents derivable preceding sequents app abs rules cx 
assume loss generality range open substitutions mention type variable sequent derivable gen rule uses abs var inst app rules straightforward 

nal sequent derivation desired 
proof direction complicated 
suppose derivation ends sequent lemma assume satis es inst gen property de nition 
analysis shows solution semi uni cation instance derivation type environment deriving type 
type assumed fx sequent produces nal derived type sequent 

substitution represents ects inst rule type variable loss generality assume type range free type variables contained set ftv applied nal derived type outermost quanti ers 
inst gen property uses gen rule shape nal derived type lacks embedded quanti ers particular positions nal derived type occurrence type 
sequent produces nal derived type rst occurrence exactly app rule produce sequent cx 
cx applied nal derived type cx outermost quanti ers 
quanti ers introduced gen removed inst 
invoking inst gen property gen rule sequent premise 
second occurrence sequent producing nal derived type exactly point app rule produce sequent number uses gen rule result sequent looks subset inst gen property uses inst rule point 
step derivation abs produce consider sequent producing nal derived type look 
derivation type application 
observing shape nal derived type shows nal derived type outermost quanti ers 
inst gen property gen rule sequent premise 
sequents combined app rule produce sequent expected type derived exactly order app rule way case types equal new knowledge type assigned sequents producing nal derived types rst second occurrences exactly equations substitutions identity type variable substitutions represent ects inst rule 
recall sequents 
sequents identical likewise sequents equalities hold quite solution semi uni cation instance di erence ranges may include types bound type variables 
de ne open substitutions form solution pick type variable arbitrarily 
de ne function erase erase quanti ers type follows erase erase erase erase erase erase de ne behavior erase erase erase 
identity variables 
observation case erase erase erase shows equalities hold 
solution derivations invariant type assumptions section establishes machinery section chain number results 
de ne notion invariant type assumption means set types induce set types 
de nition invariant type assumption 
invariant type assumption type assumption bound variable essentially type derivations particular term 
notion de ned precisely follows 
term bound variable type type environment dom fv 
say induce invariant type assumption properties hold 
derivation type 

derivation type exists type variable renaming 
remember denotes global type environment derivation 
section prove type environments terms induce various desired invariant type assumptions constructed 
achieving main result need way chain results express number invariant type assumptions induced simultaneously 
accomplish de nition provides similar notion terms contexts type environments 
di erence complexity de nition de nition due de nition need impose invariant type assumptions arbitrary terms handle simultaneous constraints deal extra term variables 
simultaneous constraints requirements contexts chained invariant type assumptions imposed outer context successfully passed inner context 
extra term variables construction invariant type assumption types variables constrained 
de nition 
type environment context fv dom bv dom dom dom 
statement type environment context induce type environment holds term type environment term fv dom dom dom bv ftv ftv ftv properties hold 
type derivable exists type type environment dom dom derivation containing sequents 
type derivation containing exists type type environment dom dom type variable renaming satisfying contains sequent type environment covers extra free variables handled bindings types invariant 
necessary support chaining contexts induce simultaneous constraints 
type variables di erence ftv ftv need discharged gen rule course typing mentioned type environment covers extra variable bindings scope includes hole types need invariant bindings types 
particular choice context term variables mentioned type environments unimportant 
de nition abstracts away details 
de nition xi 
xand type sets 
algorithm type environment input returning type environment context output witness statement xi set types set types non empty type environment ran holds ran ftv ran ftv ftv ran statement xi exists witness 
lemma properties 
subsets 
renaming 


ftv ftv ftv dom dom bv 
type environment term induce invariant type assumption type ftv ftv ran 
xi type variable renaming 
xi xi 
xi xi 
ftv ftv ftv 
xi yi xi 
xi xi ftv ftv ftv xi proof 
decidable sets term variables rx term variable renaming swaps members variables outside chosen deterministic manner identity 
rx rx 
property proved separately 

statement depend particular variable names involved variable names di erent 
applying renaming ect holds holds 

inspection de nition 
inspection de nition 

ftv ftv ftv dom dom bv checked prove satis es property definition 
term fv dom dom dom bv ftv ftv ftv 
derivable 
de nition extra type environment ftv ftv ftv type type environment derivation containing sequents 
derivation exactly necessary 
type derivation contains de nition interpreting extra type environment ftv ftv ftv exist type type environment type variable renaming satisfying contains 
subderivation exactly needed 

term induce invariant type assumption 
holds context term kn 
checked fx witness ran de ned di erent ways follows 
suppose type 
de ne 

dom yg dom dom checked witness ran 
suppose ftv ftv 
de ne 

dom yg dom dom renames bv fresh names renamed 
checked witness ran 
witness xi 
checked witness 

witness xi yg 
de ne dom dom argument shows witness xi ran de ned algorithm computing 
hard check ran ftv ran ftv ftv ran 
remains show holds 
property proved fact holds 
checked ftv ran ftv ran ftv ran fact ran xand de nition 
property proved 
property proved exactly desired result 

witness xi holds trivially witness xi 
witness ftv ftv ftv checked witness 
witness xi witness yi algorithm de ned follows dom bv bv dom rx rx argument shows witness xi ran de ned algorithm computing 

checked ran xand ftv ran ftv ftv ran 
thing remaining shown de nition holds property proved fact rx holds property proved de nition holds property proved checked property proved sucient show property proved implies argument shows observe checked type environment fv dom bv dom dom dom 
term type environment term fv dom dom dom bv ftv ftv ftv 
observe ftv ftv ftv ftv ftv 
observe ftv ftv ftv ftv ftv 
property de nition shown separately 
part proves def 
prop 
holds 
derivable 
def 
prop 
type type environment derivation containing sequents 
def 
prop 
type type environment derivation containing sequents existence quite show desired result subderivation inside subterm necessarily type environment satis es def 
prop 

merely standard notion weakening splice result weakening standard notion weakening preserve internal structure derivation properly 
sophisticated notion weakening lemma 
rst establish preconditions lemma 
pick type variable renaming swaps ftv ftv ftv fresh names identity 
derivation contains sequents construct variation weakening spliced 
set type variables generalized want show ftv 
suppose ftv fresh suppose ftv 
ftv ftv 
gen distinct standard assumption means lemma derivation containing sequents 
form derivation splicing derivation appropriate place 
holds contains desired result 
part proves def 
prop 
holds 
type derivation containing def 
prop 
exist type type environment type variable renaming satisfying contains sequent fact directly 
renaming applied rst match type variables sequent 
type variable renaming swaps ftv ftv fresh type variables identity type variables lemma prop 
holds 
ftv ftv fresh variables holds ftv ftv ftv ftv ftv 
observe 
def 
prop 
interpreting extra type environment exist type type environment type variable renaming satisfying contains sequent observe 
note 

sequent may rewritten desired result 

xi xi ftv ftv ftv 
lemma holds lemma holds lemma holds xi lemma holds xi lemma holds xi de nition 
inspection proof lemma reveals proof property constructive content algorithms take witnesses algorithms various statements return witnesses new statements 
support building larger algorithms algorithms identi ed 
alt algorithm proof property witness ftv ftv ftv alt witness 
algorithm proof property witness type variable renaming witness 

self algorithm proof property witness self witness 
chain algorithm proof property witness witness chain witness lemma 
nite sequence nite decidable type sets approximating 
computable function witness xi witness xi xi follows xi proof 
witness xi ran checked witness xi undecidability typability section uses machinery section prove tc reducible typ proving typ undecidable 
de nition height 
auxiliary metric height measures height type viewing tree ignoring quanti ers letting single type variable height 
metric measures heights parameter subtypes type 
type 
de ne maximum height 
de nition 
de nitions number sets types rest section 
vg tand open tg set basis long chain results culminating theorem 
set universal types set closed types 
subsets respectively contain types observe lemma 
term type environment induce invariant type assumptions 
proof 
techniques proving lemma required lemmas thorough explanation aid understanding 
proof view parse tree notation types interchangeable regular notation simple correspondence 
view type symbol internal tree node children quanti cation node label 
left going path tree path containing branches descend right 
left path type unique left going path root type leaf 
quanti er labelling tree node owns path type reached path node quanti er exactly quanti ed variable 
indicate presence node specifying internal node leaf 
term follows yy yz kx xv ww easy check typing global type environment fv 

discover useful fact 
case derivations term variables assigned essentially types 
words invariant type assumptions variables 
analysis proof leads 
assume typing prove desired properties 
order subterm ww typed left path nal derived type rst occurrence edge longer left path nal derived type second occurrence left path assumed type length type variable leaf path free quanti ed position root type length leftmost path derived type left path assumed type owned quanti er root type 
holds due subterm yy 
depicted follows arrow indicates existence variable points left going path abstraction applied abstraction type assumed height larger depicted combining diagrams gives result type assumed equal nal type derived kx xv 
way quanti cation root nal derived type abstraction gen rule applied type derived abstraction abs rule outermost quanti ers 
earlier type derived abstraction looks free variable kx xv temporarily suppose type assumed match pattern type variable free type assumption depicted hold type variable leftmost path assigned type closed type 
case derived type depicted happen 
depict type assumption derivation 
due subterm xv type assumed height larger type assumption matches pattern considering type assumed type embedded type assumed shows consider subterm yz 
types assumed instantiated left subtree instantiation type matches instantiation type instantiation type match pattern type assumed type assumed instantiated match pattern suppose leftmost path type assumed edges long words suppose case instantiation type assumed match pattern quanti er owning leftmost path inserted necessary spot type instantiation 
leftmost path type exactly edges long leftmost path type edge long 
type assumptions hold type free subterm xv nal derived type xv exactly type assumed match patterns free suppose second third case 
type assumed match patterns subterm yy typed 
type assumptions hold exactly typings left show type 
type assumed subterm xv nal derived type exactly subterm yy nal derived type type 
possible assumed type yield derived types 
desired result 
lemma 
calculus 
term calculus type environment induce invariant type assumptions 
proof 
term de ned follows hx hx gx gx ha grr inspection reveals term calculus variable bound occurs subterm 
inspection reveals closed term free variables occur domain type environment 
checked term typable global type environment 
turns little variation possible types just 
types assigned variables vary possible variations type environment naming free variables may renamed manner types assigned bound variables quanti ers type variables may occur position scope encloses depicted position 
term empty type environment induce desired invariant type assumption explanation limited range possible variation proceeds follows 
base construction context simply variation term lemma works calculus 
triple nesting contexts gives invariant type assumptions type variables distinct gen rule separate places 
context uses types constrain size type force certain leaves type mention type variable 
context re nes type type troublesome quanti er rightmost position 
context xes desired type variable note stage types ensure type constructed go control unwanted inst 
proofs various facts just mentioned similar reasoning proof lemma left reader 
worth observing reduction application kmn inserted inside context eventually replaced term rm rn 
type abstraction substituted reduction 
application kmn type reduce adapting proofs calculus 
lemma alternative lemma perform proofs entirely calculus 
important thing note invariant type assumption allows simulate combinator far typability concerned 
replacing combinator proofs free variable assigned type proofs adapted calculus 
adaptation left reader perform involves steps 
contexts de ned proof lemma 
di ers presence hole occurrence shown fk entire sequence proofs sections theorem shows replayed free variable type place show tand key point yield witness produces contexts bound variable occurrence regardless placed hole 
lemma 
type environment fx term xv induce invariant type assumption 
proof 
trivial 
lemma 

empty set types induces set types proof 
enumeration observe chain reasoning lemma lemma lemma lemma lemma lemma lemma lemma lemma lemma witness type variable renaming swaps alt 
lemma properties holds witness witness invoking lemma yields witness lemma 
type exist type environment ran term fv dom term variable bv induce invariant type assumption 
proof 
proof long take pages set number nested claims somewhat self contained arguments interleave main course argument 
type 
set type variables ftv 
may need extra type variable sto meet requirement 
observe closed type open types 
type environment term having desired properties constructed 
course de nition number types sets types terms sets terms de ned 
de ne sets types xg sequence members properties 
mentions member times may mention type second subsequence exactly subsequence exactly subsequence exactly third hold 
ensures initial subsequence overlap nal subsequence claim 
holds proof claim 
remember de nitions height de nition 
arbitrarily chosen type hold height 
sucient show height 
holds 
de nition holds height 
member member xit holds height 
de nition type holds height 
type environment de ned term variables 
rg de ne terms type follows 

claim 
holds ran 
proof claim 
observe cases de nition handled separately 
rst case second case 
de nition fact holds 
claim holds contradiction 
holds 
turn implies 
de ne pieces term term de ned 
de nition function natural numbers de ned mod 
mod directly set indexed starting 
claim 
extension type environment holds fdt 

note identity substitution 
proof claim 
recall rst elements elements second elements elements 
consider case 
clear gen inst rules open fdt 
checked type speci ed claim 
second consider case 
remember 
just shown fdt loss generality assume subderivation subterm obeys gen property 
typing inst rule eliminate quanti ers 
gen rule prevent typing application 
subsequent uses gen inst violating gen property 
hold fdt 
substitution possible achieve result de ne set terms arbitrarily chosen enumeration pieces term 
de ne term subterms de ned 
variables free subterms captured bindings free variables subterms free yq xq kz ap ub 
va am 
inspection reveals fv fa dom 
help readers including author 
better remember de nitions list de nitions natural numbers hard nd details largest index components mentioned proof belong set index rightmost component parameter limits value members range type environment belong largest index set sof bound type variables largest index special enumeration types largest index enumeration type environment term de ned shown fv dom ran 
type variable renaming maps members sto fresh names 
easily checked typable type environment global type environment including additional type assumptions 
rest proof lemma shows nal condition necessary induce invariant type assumption typing nal type environment holds type variable renaming fact renaming necessary type closed 
rest proof consider arbitrarily chosen typing term type environment term variable occurs term remember stands type assumed derivation 
refer subterm typability mean typed type assumptions 
claim 
types closed 
furthermore quanti ers embedded types left arrow right arrows case case quanti er right resp 
left arrow inside right left argument arrow 
proof claim 
consider case uses exactly reasoning 
impossible free type variable type position exactly right arrows yq type yq untypable 
observe rg claim nal derived types open zero bound variables match position 
suppose free type variable component right arrows 
free type variable fdt yq typable contradiction 
suppose quanti er properly inside root component right arrows 
quanti er fdt yq typable contradiction 
suppose quanti er free type variable component reached going right arrows left arrow application subterms yq typed contradiction 
loss generality assume subderivation subterm satis es inst gen property de nition 
harm proof nal sequent new subderivation old subderivation 
type proved constrained type assumption ect binding occurs separate part term claim 
holds fdt 
sequences type variables proof claim 
closed assumed type nal derived type subterm type inference rules system shape allow impose general constraints shape type fdt 
inst gen property assumed subderivation deduce inst rule typing subterm kz ap nishing subderivation claimed shape follows 
substitution 
claim 
holds ran proof claim 
observe typing subterm requires tree type larger tree type 
claim type larger tree claims type open clear variable rest proof proceeds induction size base case consider ng 
de nition 
de nition subterms identical members types question open know uses inst gen typing subterms 
base case done 
induction case consider 
type decomposed way closed type components 
type 
subterms induction hypothesis 
inst gen typing subterms 
claim 
holds fdt 

proof claim 
show gen inst rules may certain positions subderivation subterm type environment fz initial sequent derivation subterm look type environment clear ftv ftv gen rule sequent 
inst rule open type 
nal sequent subterm nal derived type subterm type matter 
similar reasoning gen inst ect portions type equal 
initial nal derived type subterm kz ap exactly 
consider subterm kz ap 
simple induction shows initial nal derived types subterms gen inst rules subterms 
gen rule point free type variables quanti ed subderivation base case shown 
consider case induction abs rule initial sequent subterm look type environment kz ap 
holds ftv ftv ftv fg ftv 
free type variables ftv 
free type environment type completely open gen inst rules subterm induction complete 
rest proof follows earlier claims 
claim 

substitution 
proof claim 
suppose 
corresponding positions type variable 
typing yq subterms type contradicting fact fdt fdt claim 
shown substitution conclude type shape 

type closed set type variables contain member set type variables 
conversion types claim obtain type may written follows holds 

point know type possible 
time consider type desire show exactly type recall subterm ya 
term copies subterm 
remember recall type assumed subterm take derived type 
nal derived type subterm ya 
equals type look 
substitution dom ftv ftv ran closed claim 
recall case type 
claim 
subderivation subterm xq holds fdt 
substitution proof claim 
loss generality assume subderivation subterm satis es inst gen property 
applied subterm typed var followed uses inst gen 
fdt 
substitution known shape 
claim holds fdt prove induction cg fdt xq 
base case subterm xq simply result fdt 
clear typing application requires induction case induction hypothesis app rule idt xq 

type outermost quanti ers uses inst gen nal derived type 
holds reason base case 
claim 
holds ran proof claim 
claim holds subterm xq fdt 
substitution impossible ftv 
shows ng fgg 
consider subderivation subterm ub 
va holds open quanti ers embedded positions preventing typing subterm ub 
furthermore tree may larger type subterm va hold fdt va type variable type sequence type variables order type application xa 
considering hold fdt xa 
considering subderivation xa 
similar reasoning proof claim hold fdt xa 
happen claim 

proof claim 
claim holds subterm xq fdt 
substitution suppose 
consider cases 
consider rst case fi jg 
loss generality consider case reasoning identical 

holds ftv cg 
furthermore implies identity ftv 
implying implies fdt xq con icts fdt claim contradiction 
case fi jg uses similar reasoning simpler 
results far obtain conversion types type may written follows 
comparing de nition reveals desired result nishes proof lemma 
lemma 
set types induces set types proof 
proof lemma yields method constructing term type environment types induce invariant type assumption 
proof lemma prop 
method mentioned allows constructing algorithm witness 
enumeration observe witness observe witness chain self 
invoking lemma yields witness lemma 
type exist type environment ran term fv dom term variable bv induce invariant type assumption 
proof 
type 
type variable occurrence sequence type variables 
set type variables non decreasing function natural number hold 


holds 
note may allow hold 
set function choosing appropriate representative equivalence class case free type variables ftv 
type environment term having desired properties constructed 
course de nition functions sets type variables terms de ned 
de ne type environment follows 
function natural numbers de ned mod 
add type assumptions 





rst case needed avoid requiring environment type 
add type assumptions add type assumptions 


checked range type environment lies set 
de nitions pieces assembled form term de ne terms 
pt 

aq av 
de ne inspection reveals fv dom 
type environment term de ned shown fv dom ran 
type variable renaming maps members fresh names 
easily checked typable type environment global type environment including additional type assumptions 


prove type environment term induce invariant type assumption remains shown particular derivation ends sequent type type variable renaming 
closed derivation type 
loss generality assume subderivation contain binding satis es inst gen property 
type variable renaming type assumptions derived types occur denotes unknown type matter fdt 
fdt 
fdt 


occur 
fdt 
explanation facts proceeds follows 
places types shape 
formed type interest 
construction prevent outermost quanti ers altered 
second subterm provide type subject particular renaming 
parameterized di erently renamed versions di erent places 
third application join types outermost quanti ers protected technique 
fourth constraints imposed av ensure types distinct type variables 
fifth application temporarily exposes root type constructed allow gen rule 
constraints imposed aq ensure necessary uses gen occur uses inst occur merely rename variables distinctly 
application move types appropriately 
details various technique omitted techniques similar lemma 
result lemma necessary main result theorem necessary simulate instances tc universal types prove undecidability typ 
simple check type exactly desired result 
lemma ui 
set types induces set types proof 
proof proceeds lemma lemma lemma 
lemma 
type exist type environment ran term fv dom term variable bv induce invariant type assumption 
proof 
arbitrarily chosen type ftv de ne 
de ne type environment follows 
de ne de ne 
de ne 
clear ran de ne term cb 
checked type environment term induce invariant type assumption 
lemma 
set types induces set types proof 
proof proceeds lemma lemma lemma proof bit simpler 
theorem 

empty set types induces set types proof 
lemmas lemma prop 

theorem tc typ 
tc reducible typ proof 
sentences describe method constructing instance typ instance tc 
consider instance tc asked sequent derived type environment fz fresh variable 
theorem de nition construct ectively context loss generality assume bv 
show tc reduced typ sucient show derivable zm typable 
direction checked separately 
suppose derivable 
zm derivable 
de nition prop 
zm derivable type 
suppose zm derivable type environment type 
zm derivable fv zm 
de nition prop 
holds zm derivable type variable renaming type environment type 
fv zm dom derivation zm 
step 
app zm fv derivation 
result applying valid derivation ends theorem main result 
typ tc system equivalent diculty undecidable 
proof 
recall typ easily reduces tc bar sup undecidable ktu 
result follows theorem theorem bar barendregt 
lambda calculus syntax semantics 
northholland revised edition 
bar barendregt 
lambda calculi types 
abramsky gabbay maibaum eds handbook logic computer science vol 
chapter pp 

oxford university press 
boe 
boehm 
partial polymorphic type inference undecidable 
th ann 
symp 
foundations comput 
sci pp 

ieee oct 
car cardelli 
typeful programming 
formal description programming concepts 
springer verlag 
dec src research report 
giannini honsell ronchi della rocca 
strongly normalizable term having type system second order calculus 
univ di torino 
giannini honsell ronchi della rocca 
type inference results problems 
fund 
informa sept oct 
gir 
girard 
interpr etation elimination des coupures de arithm etique ordre sup erieur 
th ese etat universit de paris vii 
glt 
girard lafont taylor 
proofs types 
number cambridge tracts theor 
comp 
sci 
cambridge univ press 
gol goldfarb 
undecidability second order uni cation problem 
theor 
comp 
sc 
giannini ronchi della rocca 
characterization typings polymorphic type discipline 
proc 
rd ann 
symp 
logic computer sci pp 
edinburgh scotland july 
giannini ronchi della rocca 
type inference polymorphic type discipline 
theoretical aspects comput 
softw 
int conf vol 
lncs pp 

springer verlag 
hin hindley 
principal type scheme object combinatory logic 
trans 
ams 
hm henglein mairson 
complexity type inference higherorder typed lambda calculi 
conf 
rec 
th ann 
acm symp 
principles programming languages pp 
jan 
expanded version appeared hm 
hm henglein mairson 
complexity type inference higher order typed lambda calculi 
funct 
prog 
appeared hm 
hoo hooper 
undecidability turing machine problem 
symbolic logic 
hw hudak wadler 
report functional programming language haskell 
technical report yaleu dcs rr yale university 
jim jim 
type inference system plus subtyping 
manuscript dec 
kt kfoury tiuryn 
type reconstruction nite rank fragments second order calculus 
inf 
comput june 
ktu kfoury tiuryn urzyczyn 
undecidability cation problem 
inf 
comput jan 
kw kfoury wells 
direct algorithm type inference rank fragment second order calculus 
proc 
acm conf 
lisp funct 
program 
lei leivant 
polymorphic type inference 
conf 
rec 
th ann 
acm symp 
principles programming languages pp 

lei leivant 
finitely strati ed polymorphism 
inf 
comput july 
lics proc 
th ann 
ieee symp 
logic computer sci 
mcc mccracken 
typechecking programs implicit type structure 
semantics data types int symp vol 
lncs pp 

springerverlag 
min minsky 
recursive unsolvability post problem tag topics theory turing machines 
annals math 
mit mitchell 
polymorphic type inference containment 
inf 
comput feb mar 
mth milner tofte harper 
de nition standard ml 
mit press 
pfe pfenning 
undecidability partial polymorphic type reconstruction 
fund 
informa sept oct 
pl pfenning lee 
leap language eval polymorphism 
proc 
rd int joint conf 
theory practice software development 
springer verlag 
pra prawitz 
natural deduction proof theoretical study 
number stockholm studies philosophy 
almqvist wiksell stockholm 
ak 
uni cation problem related kreisel conjecture 
mathematicae 
prague czechoslovakia 
rey reynolds 
theory type structure 
symposium programming vol 
lncs pp 
paris france 
springer verlag 
sch schubert 
second order uni cation type inference church style polymorphism 
conf 
rec 
popl th acm symp 
principles prog 
languages 
tu tiuryn urzyczyn 
subtyping problem second order types undecidable 
tech 
rep univ warsaw nov 
tu tiuryn urzyczyn 
subtyping problem second order types undecidable 
proc 
th ann 
ieee symp 
logic computer sci 
shorter proceedings version tu 
tur turner 
miranda non strict functional language polymorphic types 
ifip int conf 
funct 
program 
comput 
arch vol 
lncs 
springerverlag 
urzyczyn 
emptiness problem intersection types 
technical report inst 
informatics univ warsaw poland nov 
urzyczyn 
type reconstruction 
undecidable 
proc 
int conf 
typed lambda calculi applications pp 

urzyczyn 
emptiness problem intersection types 
lics lics pp 

urzyczyn 
type reconstruction 
math 
struc 
comp 
sc 
wel wells 
typability type checking second order calculus equivalent undecidable 
lics lics 
wel wells 
undecidability mitchell subtyping relation 
tech 
rep comp 
sci 
dept boston univ dec 
wel wells 
typability undecidable eta 
tech 
rep comp 
sci 
dept boston univ mar 
wel wells 
type inference system eta rule 
ph thesis boston univ 

