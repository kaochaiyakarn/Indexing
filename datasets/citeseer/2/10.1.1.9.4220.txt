ecient path conditions dependence graphs software safety analysis gregor snelting torsten robschink jens krinke universit passau new method software safety analysis combines program slicing constraint solving 
path conditions generated slice chop represent precise necessary conditions information ow program points 
constraint solvers solve path conditions program input variables 
solved path conditions may act witnesses safety violations information ow program points incompatible security level useful legal matters 
contribution recapitulate basic properties path conditions extensions dealing real programs 
show path conditions large systems 
aggressive engineering interval analysis bdds shown overcome potential combinatorial explosion 
case studies empirical data demonstrate usefulness path conditions practical program analysis 
particular demonstrate illegal uences safety critical computations discovered analyzed 
categories subject descriptors software engineering software program veri cation validation reliability logics meanings programs semantics programming languages specifying verifying reasoning programs logics meanings programs semantics programming languages program analysis general terms algorithms reliability security veri cation theory additional key words phrases safety analysis program slicing path conditions 
safety critical software applications guaranteed critical computations unduly uenced internal external agents 
obvious examples include software actuators automobiles aircraft rockets guaranteed critical computations position aircraft uenced external software manipulation example internet port speci signals input devices 
spectacular economically relevant example consider professional measurement systems systems guaranteed data path physical sensors displayed measurement values manipulated 
done formal security models order control external uences critical computations 
classical model bell la introduces di erent security levels demands subjects may read objects documents higher security level may preliminary version parts article appeared proceedings acm ieee international conference software engineering robschink snelting 
supported deutsche forschungsgemeinschaft sn 
authors addresses fakult ur mathematik und informatik universit passau 
passau germany 

snelting robschink krinke write objects lower security levels 
goguen meseguer introduced noninterference model partitions system nite number security domains domain user le program program statement 
noninterference means certain domain uence observational behaviour domain approach presents noninterference criterion determines system safe respect noninterference relation 
goguen meseguer noninterference practical software certi cation processes 
example german technische tasks responsible commercial measurement systems demands software systems partitioned domains called calibration path contains data ow sensor value display rest system contains user interface code 
noninterference means calibration path displayed measurement value may unduly uenced user input 
checking measurement software fact motives described article 
development new safety critical systems guidelines common criteria common criteria project sponsoring organizations mantel allow achieve speci level security 
existing software systems developed security criteria mind program analysis order check criteria bell la goguen meseguer met 
particular determined program parts uence critical program points analysed uences legitimate safety violations 
rst part task known method exists program slicing 
slicing rst introduced weiser weiser determines statement program parts uence statement program parts de nitely uence statement 
codesurfer teitelbaum krinke snelting system dependence graph ottenstein ottenstein ferrante horwitz order determine statement statements may uence appendix explains relationship slicing goguen meseguer noninterference 
slicing today reasonably fast deal real programs written real languages 
language features hard deal pointer arithmetic safety critical context features disallowed programming standards 
unfortunately best known algorithms slicing quite imprecise practice slices bigger expected big useful bent 
furthermore slicing gives binary information decide statement may uence statement de nitely case slicing say strong uence circumstances happen 
proposed combine slicing path conditions constraint solving snelting krinke snelting path system dependence graph necessary condition ecient path conditions dependence graphs 
fig 

user interface pc determined hold order information ow path possible 
generation simpli cation pc fed constraint solver 
solver hopefully solve path condition program input variables 
resulting values constraints input variables necessary sucient conditions program input hold order uences input values satisfying conditions program pc satis ed uence visible 
case safety violations inputs serve witnesses illegal behaviour 
snelting fundamental formulae theorems de nition simpli cation path conditions 
back implementation empirical data 
contribution current threefold recapitulate computation path conditions program dependence graphs demonstrate interval analysis bdds path conditions scale case studies illustrate path conditions safety analysis 

snelting robschink krinke described implemented top slicer 
slicer ansi uses variety techniques handle full language including side ects procedures libraries pointers unstructured control ow krinke snelting 
particular uses context free language reachability reps interprocedural slicing 
build dependence graph lines minutes 
forward backward slices chops interactively computed visualized dependence graph source text 
presents snapshot source code dependency graph displayed slice highlighted source le graph 
contribution organized follows 
recapitulate basic facts dependence graphs program slicing introduce basic de nitions properties path conditions dependence graphs 
chapter small analysis examples demonstrate generate path conditions programs simple variables programs arrays programs containing arbitrary data structures multi threaded programs 
chapter show break complexity barrier utilizing binary decision diagrams interval analysis dependence graph chapter presents empirical performance data 
chapter presents case study analysis safety critical real time system 
chapter discusses related chapter presents 

background foundations assume reader basic knowledge program slicing see tip 
section review notation fundamental properties path conditions 
dependences slices chops say statement uences statement equivalently dependent values computed mere execution depend values computed weiser original slicing de nition notion uence precise demanding program fragment consisting uencing produces ects original program 
write uences note general 
slicing computes conservative approximation slices de ned system dependence graph ottenstein ottenstein ferrante horwitz 
graph sdg contains nodes statement expression program edges represent control data dependences 
consists various kinds nodes statements expressions parameters control predicates 
comprises data dependence edges control dependence edges summary edges 
write bs backward slice consists nodes dependence graph reached 
forward slice denoted fs chop nodes denoted ch 
consider slice chop subgraph sdg edges slice chop nodes considered part chop 
intraprocedural case chop de ned ch bs fs bs fs ch holds 
interprocedural slicing context free language reachability ecient path conditions dependence graphs 
simple graph reachability set operations reps reps reps slicing chopping precise keeping track procedure calling context 
comparison various context sensitive slicing chopping algorithms krinke 
usually bs contains statements uence fundamental property bs converse implication general hold 
practice question slicing precision important course demand implication equivalence bs small possible 
slices quite imprecise realistic languages programs best known algorithms 
original motivation compute path conditions 
control conditions rst step path conditions introduce explicit notation control dependencies control predicates 
control predicates denoted typically condition statement governing execution statements 
set control dependence edges denoted subgraph sdg called control dependency graph 
control predicate evaluate true speci value order execution proceeds control dependence edge formalized notion control condition 
control condition form true false labelled speci value switch expression switch statement 
sdg start node start statement main function control dependent start order characterize control dependencies deeper sdg introduce notion control dependency chop chop control predicates start cp fy start xg consider cp subgraph edges connecting cp considered part cp 
note general cp ch start 
case control ow structured tree cp single path 
practice unstructured control ow rare tree cp single path start path conditions path condition pc condition program variables necessary uence pc 
path condition satis ed pc false de nitely uence example simple path condition consider program fragment 
snelting robschink krinke order uence necessary pc satis able 
path conditions general consist control predicates resp 
control conditions example pc contains 
may contain additional constraints concerned data structures arrays example constraint 
satis ability means program variables path conditions implicitely existentially quanti ed 
example holds path condition satis able 
line replaced resulting path condition pc unsatis able line uence line 
may assignments variable variables may di erent values di erent program points programs transformed static single assignment form ssa cytron rst 
ssa form assignment variable 
necessary distinguish di erent ssa variants program variable additional indices 
example consider fragment ssa distinguishes de ned de ned 
example executed information ow data dependencies 

possible condition pc ssa form condition pc necessary condition uence 

basic formulae path conditions path conditions de ned respect chops sdg ch 
ch consist necessarily disjoint paths ch 
fundamental formula strong necessary path condition introduced snelting pc ch explanatory examples line numbers ssa indices fact sdg node numbers 
ecient path conditions dependence graphs 
formula relies execution conditions 
statement ch execution condition necessary condition execution order uence path exercised statements path executable conjunction execution conditions taken path chop disjunction individual path conditions 
determined control predicates control path start node cp control conditions path start satis able executed 
case unstructured control ow control path start node exist disjunction corresponding conditions taken 
mentioned ssa form generate correct path conditions 
ssa uses functions order describe situations di erent ssa variants variable may reach program point 
additional constraints generated represent functions 
di erent ssa variants variable function generates additional constraints 
example function translates additional constraint pc constraint globally valid ssa generated 
set globally valid constraints denoted 
speci data dependency edge de nition variable corresponding constraint written 
example global constraints constraints relevant path assumed part path condition conjunctively added pc 
equation fact reads pc ch usually omit treat global constraints implicit background knowledge 
path conditions extended capture properties arrays data types 
simple example condition involving array indices details described 
equation way de ne path conditions 
fact may di erent path conditions 
path condition pc stronger pc pc pc 
nite set path conditions forms preorder factored logical equivalence order obtain true partial order 
path conditions de ned contain equivalence transforming path conditions minimal conjunctive disjunctive normal form 
case conditions pc path index index set combine stronger condition 
snelting robschink krinke building conjunction 
path conditions closed arbitrary conjunctions pc implies pc 
particular strongest path condition pc fpc pc strongest path condition computed nite conjunction pc 
goal construct path conditions strong possible necessary sucient 
path condition imposes constraints program variables probability high bs implies 
imposes constraints probability low uences pc false uence bs 
pc true probability extremely high bs implies 
note probabilities explicitely computed compared ordered strength path conditions 
path conditions de ned equation necessarily strongest path conditions examples show quite strong practice hard see generate stronger conditions source text 
slicing precision uence path conditions 
chops precise generates stronger path condition ch ch implies path ch path ch 
ch ch disjunction runs paths 
decomposition path conditions snelting shown simplify path conditions structured control ow 
typically levels nested disjunctions resp 
conjunctions equations reduced levels 
general decomposition properties exploited 
note leave global constraints equations valid constraints included 
proofs see appendix essentially 
dominator ch 
pc pc pc just dominating nodes path contain pc pc pc assume path pass subgraph entered entry points reached exit points entry exit points need necessarily ecient path conditions dependence graphs 
disjoint 
pc pc pc pc particular simple case general statement occurs consists entry exit nodes predecessors pc pred pc symmetric formula valid pc succ pc important theorem rst proved snelting states cycles ignored 
set paths chop nite 
cycle 
pc ch equation fundamental equation cycle back edge excluded path cycle left 
equation states computation pc cycle ignored 
theorem due fact path cycle path condition stronger stronger cancelled outer disjunction equation due absorption law 
note equation apply non overlapping cycles cycles overlap just ignoring paths generate path condition strong necessary anymore 
chapter explains handle overlapping nested cycles 
add remarks execution conditions 
equation structurally identical equation decompositions equations derived execution conditions 
omit corresponding equations 
note equations path conditions de ned respect chop ch corresponding equations execution condition de ned respect cp 
control ow structured cp tree outer disjunction equation disappears fact computed start true father father interprocedural path conditions reps reps algorithms precise interprocedural slicing chopping keep track calling context dependencies procedure body 
algorithms understood instance context free language reachability reps 
reps technique constraints possible paths slice chop order capture 
snelting robschink krinke correct context procedure calls 
furthermore parameter passing assumed value result modelled additional assignments 
eligible paths interprocedural chop conditions generated standard formula 
interprocedural chop contains summary edge represents transitive dependencies procedure body pc computed procedure body actual node variable actual node variable corresponding formal nodes corresponding formal parameters 
pc pc constraints bind actual formal parameters seen additional constraints parameter edges path conditions formal parameters computed stored reused calling contexts 
pc needed context parameter edges bind actual parameters previously computed pc reused di erent constraints pc pc note parameter constraints globally valid ssa generated ones valid just speci calling context speci chop 
presence recursion generated path conditions recursive equation mounts unfolding path conditions procedure bodies 
problem circumvented lowering precision setting pc true summary edges due nested recursive calls 
generally pc true unfolding procedure calls exceeds certain depth 
ect procedure unfolding cut certain depth calling context 
solving path conditions eventually path conditions simpli ed fed constraint solver tries solve program input variables 
remember program variables path conditions existentially quanti ed constraint solvers elimination sturm sturm particularly suitable 
illustrating example elimination pc ac bc input variables free parameters auxiliary variable want eliminate solve elimination transforms standard assumption program analysis quite realistic programs exploit aliasing 
case special means available outside scope 
ecient path conditions dependence graphs 
condition theory guarantees formulae equivalent respect satis ability 
solve path condition pc eliminating yields eliminating yields just true 
solving pc yields just false 
note elimination due decidability problems restricted various kinds arithmetic formulae 
solving techniques may kinds formulae 
matter outside scope see benhamou colmerauer marriott stuckey 
path conditions solved solved conditions act witness path input values provided satisfy solved pc statements sdg path executed illegal uence visible 
feature valuable legal matters lawsuit software vendor 
note occasional false alarm possible path conditions necessary sucient slicing path conditions stick principle conservative approximation 
safety analysis appropriate live rare false alarms accept potential misses illegal uences 

basic analysis explain path conditions scale small examples order explain basic machinery 
introduce extensions arrays pointers data types multi threaded programs 
analysing data ow example presents mergesort program parts sdg particular essential dependences chop ch constant line array temp line 
dashed arcs control dependence edges normal arcs data dependence edges 
global variables transformed additional procedure parameters additional dependences global array data 
dotted arcs part sdg represent points sdg computation path conditions explained 
order generate path condition pc execution conditions statements path control conditions generated 
example index mid index condition gure data index data index condition 
constraints considered 
fact constraints stronger substituting right hand side de nition left right 
snelting robschink krinke int data int temp void move int fromlist int int int tolist int index tolist index fromlist void merge int int mid int int index index index index index index mid index data index temp index data index temp index data index index mid move data index temp index move data index mid temp index move temp data void mergesort int left int right int left right left mergesort left mergesort right merge left right int main int data data data data data mergesort printf data printf return left right global constraints multiple data dependency propagation global variable fig 

mergesort program part sdg omit formal de nition constraints enhanced substitutions assignment right hand sides see snelting just mention decomposition equations section remain valid 
note substituting right sides done cyclic substitutions introduced cyclic assignments recursive function calls 
path condition generator check ecient path conditions dependence graphs 
condition substitute right sides possible usually path conditions stronger 
example just assignment constraint contain disjunctions de facto acts constant propagation 
proceed compute pc 
order keep illustrating example simple demonstrate ects constraints substitutions compute path condition speci path ch chop leave dependencies recursive calls line formal parameters line 
compute path condition data ow dependencies 
note equations apply parts chop speci path course deliver condition information ow program points necessary condition ow speci path 
compared condition full chop conditions speci path stronger path condition full chop 
exploiting formal actual constraints merge call line obtain mid right condition 
fragments index index data index data index computed 
similarly call site merge determined lef condition formal actual constraints mergesort call line simpli es true note just merge call mergesort just mergesort call main program 
cases actual formal constraints contain disjunctions act constant propagation 
shown global constraints substitution right sides full constant propagation automatically built path conditions making conditions stronger 
initial path condition pc index index data index data index remember program variables necessary condition existentially quanti ed 
furthermore path conditions basic form equations treat arrays scalar variables array elements distinguished 
elimination generates true quite obvious course nd values index index data pc true 
index index data input variables values input variables witness data ow visible fact program gure input variables 

snelting robschink krinke void main int int int int int fig 

array uses high probability information ow line line recursive mergesort call value eventually assigned temp array 
note due coarse grained array treatment path condition weak 
means pessimistic path condition indicates probability uence high 
example shows basic path conditions necessary conditions stronger 
arrays array elements distinguished additional constraints index expressions generated data dependencies concerning array 
seen constraint section 
general data dependence edge exp exp generates constraint exp exp path sdg constraints edges conjunctively added path condition 
general formula pc ch true array dependence edge note equations valid easy extend proofs appendix 
resulting path conditions may contain complex conditions index values known arbitrary constraints integers solved 
solvers deal constant linear index expressions presburger arithmetic pugh wonnacott 
case de nitions array element may reach program point situation complex dependence edges modi ed order take care possible aliases 
example consider ecient path conditions dependence graphs 
standard approach agrawal assume assignments array elements non killing de nitions previous assignment killed 
generates data dependence edges path condition pc 
problematic path conditions knowledge execution order available control data dependences knowledge may kill de nition 
fact de nition killed pc evaluate false condition weak 
order path conditions strong possible assume assignments array elements killing modi cations assignment array element uses complete array speci ed element de ned 
approach change bs assignment array element 
example data dependence edges edge going de nition de nition going de nition 
constraints edges going de nition de nition negations conditions array element de ned source target array indices 
equation valid standard approach 
precise variant constraints complex need additional notation write dd sdg edge connecting array de nitions write du sdg edge connecting array de nition array write array index expression node constraints valid speci path examination follow backwards dd edges de nitions array elements pc ch dd dd du maximal subpath note maximal subpath equation uniquely determined 
dd edges equations reduce equation 
example equations generate pc clear information ows kill de nition stronger condition obtained standard approach 
chop lines gure generates path condition heavily relies equations constraints substitutions right hand sides 
snelting robschink krinke pc simpli ed pc condition clear closer look program line data dependent line line control dependent line dependent line 
line particular dependent line 
usage array line creates dependence constraints acting constant propagation imply line possible value 
line depends line 
applying improved array conditions pc gure ect 
conditions constrain variable small discrete interval automatically translated disjunction possible values 
example index translated index index index 
disjunctions multiply data index data index resulting data data data data data data 
constraints acting constant propagation replace array elements values lines 
nally reduces resulting constraint true condition simplistic array treatment 
ne grained array analysis ect con dence fact uence 
increases 
pointers exception array dependencies data dependence leads de nition variable usage introduces globally valid constraint presence pointers may contain complex pointer expressions 
consider fragment data dependence introduces scalar global constraint exist data dependences due pointer dereferencing 
order handle pointer expressions ecient path conditions dependence graphs 
introduce straightforward extension constraints allow constraints data dependences computed points alias analysis implementation technique similar burke 
path conditions stronger introducing additional constraints represent additional requirements aliasing 
example valid equation holds data dependence due pointer usage di erent constraint expression equations handle subset possible pointer expressions 
handled true path conditions correct precise possible 
data types programs rely arrays kinds standard datatypes lists stacks queues demonstrate precision path conditions increased account algebraic semantics data types 
order apply technique assume datatype program equational speci cation 
order operationally exploit speci cations standard assumption bergstra consider equations oriented left right rewrite rules assume normalizing rewrite system results equational speci cations exploited path condition contains term built signature speci cation 
write reduced unique normal form term containing variable written 
example consider program gure uses stack 
assume standard equations stacks isempty true isempty push element stack false top error top push element stack element pop error pop push element stack stack order see equations exploited consider code fragment stack push stack stack push stack 
top stack case techniques knuth bendix completion outside scope 
see baader nipkow 

snelting robschink krinke typedef enum minus eos precedence struct adt stack stack char expr precedence get token char symbol int symbol expr switch symbol case return plus case return minus case return eos default return operand int eval void precedence tok char symbol int op op int tok get token symbol tok eos tok operand stack push symbol stack op top stack stack pop stack op top stack stack pop stack switch tok case plus stack push op op stack break case minus op stack push stack stack push op op stack break tok get token symbol return top stack int main stack expr printf results dnn expr eval return fig 

desk calculator program data dependencies 
constraints stack line obtain top push stack top push stack stack equations constraints simpli ed conditions equation conditions generalized arbitrary data types just dependencies array elements 
example illustrates technique possible sources data dependencies variable occuring term rewritten called rewriting modulo data dependencies 
note rewriting steps intertwined way ecient path conditions dependence graphs 
similar paramodulation resulting normal forms additional constraints assignments treatment path conditions proceeds equation 
case constraint contains disjunctions multiply reduction inference rules nondeterministic contain disjunctions 
gure compute path condition underlined expressions main 
stack equations computes path condition tok eos tok operand tok eos tok operand tok plus tok eos tok operand tok minus remarkable presents minimal syntactic requirements input order result eval dependent input 
fact valid syntactic pre xes determined 
stack equations obtain stronger condition 
nal result tok eos tok operand symbol top tok eos tok operand tok plus top top top tok eos tok operand tok minus top top top top tok eos tok operand tok minus top top valid pre xes inferred actual numerical relationships stack entries 
example lines path condition treat unary minus distinguish cases rst operand unary minus zero resp 
nonzero resulting stack computations 
remember quite confusing ssa indices practice dealt cross source text available mouse click 
assertions engineer doing safety analysis background knowledge extracted source code help analysis considerably 
order improve path conditions exploiting knowledge assertions 
ordinary assert statements generate corresponding control condition path conditions stronger 
furthermore provides special assertions allow ne grained control specifying boolean formula allows specify scope assertion 
usually scope list statements procedure body scopes may nested 
assertions assumed valid ssa variants variable occuring scope acting scope invariant 

snelting robschink krinke define true define ctrl define pb define pa void printf void main int ab int cd char puf int int idx float kg float kal kg kal kg idx true ab ctrl ab pb unsigned int ab pa kg float kal kg cd ctrl idx idx idx idx puf idx puf idx puf idx char cd pa cd ctrl puf idx kal kg puf idx kal kg puf idx printf kg puf kg fig 

simple measurement system software including assertion shows simple measurement system software discussed snelting program allows manipulate displayed weight value keyboard input 
source text contains nested assertions assertions contain variable idx 
outer assertion ects idx ssa variant comes loop initialization inner assertion acts idx idx coming loop variable incrementation idx sdg part loop body 
assertions just extracted source code appropriate ssa indices added ssa variant ected assertion assertion duplicated ssa variant 
assertion conjunctively combined path condition fed minimizer 
assertions path conditions stronger reduce path conditions dramatically 
practice assertions focus speci region chop providing assertion excludes data ow paths 
gure original path condition chop keyboard input variable cd line displayed value printf statement line ssa indices pc ab cd idx cd puf idx ab cd idx cd puf idx puf idx indicating safety violation mentioned 
assume engineer knows hardware keyboard input deliver capital letters special characters 
expressed condition puf idx second assertion conjunctively added pc 
result ecient path conditions dependence graphs 
false primitive hardware safety violation possible 
example demonstrates erroneous assertions generate false safety statements 
multi threaded programs path conditions described far handle sequential programs 
section describe path conditions generalized multithreaded programs 
method describe krinke slicing algorithm multi threaded programs krinke 
note approach limited intraprocedural slicing implementation multithreaded path conditions 
multi threaded programs important describe basic technique 
main problem analyzing multi threaded programs presence interference 
interference data ow variables shared parallel executing statements 
node called interference dependent node variable def de ned ref referenced may potentially executed parallel 
threaded program dependence graph extended pdg interference dependence edges added 
technique calculate edges scope calculated standard algorithms knoop 
straightforward approach assumes existence boolean function parallel returns true possible nodes execute parallel see mcdowell helmbold overview avrunin algorithm 
interference dependence edge id inserted variable de ned referenced parallel true 
interference dependencies transitive striking contrast normal data dependencies 
transitivity data control dependencies obvious de nition composition sdg paths results path 
statement interference dependent statement interference dependent dependent possible execution statement executed 
assume interference dependencies transitive fact introduce possibility time travel krinke 
order compute path conditions replace interference dependence edges normal data dependence edges compute path conditions usual 
resulting path conditions correct replacement interference dependency data dependency conservative approximation resulting path condition necessary condition information ow 
resulting path conditions weak allow transitive paths time travel 
example consider fragment thread thread 
snelting robschink krinke impossible executed due interference dependences exists path interpreting 

ordinary data dependency edges path condition computes pc 
weak path condition indicates may travel backward time executed 
possibility eliminate time travel compute precise path conditions compute precise chops 
unfortunately precise threaded chops compute precise slices technique krinke intersection forward backward slices sequential intraprocedural programs 
example intersection includes precise chop contain execution executed 
intersection threaded slices basis path conditions equation time travelling excluded di erent means notion threaded witness 
threaded witness witness possible program execution presents statement execution sequence free time travel consistent execution order thread 
formally sequence hn nodes threaded witness parallel cfg means nodes thread reachable predecessors execute parallel assumes simple model parallel execution similar structured cobegin coend parallelism 
assumption path decided threaded witness general equation pc ch threaded witness fact de nition threaded witness implies 
decompositions section applied multi threaded version omitted due lack space 

scaling path conditions introduced sections scale 
practice sdgs thousands thousands nodes chops thousands paths hundreds cycles 
furthermore naive generation path conditions easily cause exponential blowup size 
order overcome obstacles apply techniques 
interval analysis performed sdg identifying hierarchy reducible loops irreducible loops acyclic subgraphs 
ordered binary decision diagrams obdds avoid blowup path conditions 
de nition di erent krinke precise general applicable 
ecient path conditions dependence graphs 
binary decision diagrams path conditions typically contain execution conditions control conditions mounted substantial heaps conjunctions disjunctions 
binary decision diagrams bdds bryant data structure choice multitude complex boolean formulae high potential structure sharing 
particular exponential blowup path conditions avoided boolean operations eciently implemented 
bdds standard instrument model checking allow compact representation automaton state space 
bdd package buddy lind nielsen 
control conditions broken atomic terms containing conjunctions disjunctions elementary simpli cations performed 
atomic control conditions get unique identi er attached execution conditions path conditions 
execution conditions cached statement appear path conditions 
bdds advantage conjunctions disjunctions performed polynomial time negations tests true false run constant time 
high degree shared subexpressions bdds normally prevents combinatoric explosion empirical evaluation section demonstrates bdds key factor making path conditions scale large programs 
interval analysis practice chop contains backward edges typically half belong reducible loops 
striking contrast control ow graphs irreducible loops rare practice 
perform interval analysis order obtain hierarchy nested cycles 
interval analysis introduced tarjan tarjan technique identify nested loops reducible control ow graphs 
extended authors sreedhar order cope irreducible loops sreedhar 
sreedhar gao lee sgl algorithm separates graph nested strongly connected components sccs 
sccs reducible loop entry node back edges return entry node 
sccs irreducible case unique entry point identi ed 
nested hierarchy sccs connected acyclic set skeleton edges 
sgl algorithm rst computes dominator tree deals nodes dominator tree bottom fashion 
dominator potential loop entry depth rst search performed identify reducible irreducible sccs 
lengauer tarjan algorithm lengauer tarjan ecient computation dominator tree 
note sgl algorithm implemented quasi linear time ramalingam 
presents example sgl decomposition sdg 
egg strongly connected component hatched reducible loop example outermost loop happens reducible 
equation cycles ignored overlap 
particular reducible loops back edges go back entry point ignored equation guarantees removing back edges change 
snelting robschink krinke start fig 

left example sreedhar gao lee sdg decomposition 
right irreducible graph dominator tree strongly connected components 
dg dg fig 

bottom treatment nested loops path condition 
paths overlapping cycles ignored 
example consider gure right part cycle free paths fourth lost back edge eb removed 
demonstrates presence overlapping cycles cycle free paths start target node enumerated general generate number paths exponential size graph 
exploiting interval analysis interval analysis avoids enumerating paths solves problem overlapping cycles 
sgl algorithm determines hierarchy reducible irreducible loops 
advantage determining reducible loops just ecient path conditions dependence graphs 
nested sccs back edges reducible loops completely ignored computing path conditions 
irreducible loops back edges generate additional path conditions 
path enumeration limited irreducible egg gure number paths decreases dramatically 
nested sccs path conditions inner sccs outer sccs equation 
sccs processed bottom 
detail path conditions computed follows 
reducible scc entry point exit points 
backward arcs go back entry point ignored due equation path conditions computed topological order scc back edges cycle free 
node pc computed equation 
necessary execution conditions computed needed equation 
case structured control ow scc outer disjunction equation redundant control dependencies form tree 
execution conditions eciently computed equation 
execution conditions cached sdg nodes 
control ow structured topological ordering path conditions execution conditions touches individual 
eventually topological order reaches pc collected time jlj 
note time constructing path conditions include time bdd operations typically complexity jlj resulting total jlj 
irreducible scc entry points exit points entry exit points need disjoint 
cycle free paths generated depth rst search starting pc computed equation common pre xes paths automatically factored 
computation execution conditions reducible case 
complexity 
jlj number paths counting bdd operations 
pc computed sccs certain level conditions exploited level applying equations 
purpose path conditions sccs lower level treated collapsed execution path conditions exploited due equation 
note entry exit points sccs needed equation propagated level 
scc upper level time computing path conditions time inner sccs bdd operations jl reducible 
jl irreducible example consider gure displays simple sdg bottomup generation path conditions 
solid arcs sdg edges dashed arcs dominator edges sdg 
sgl algorithm discovers innermost cycle reducible loop back edge ignored 
snelting robschink krinke pc pc 
cycle collapsed bottom strategy identi es scc dg 
time irreducible scc entry points dg exit point equation pc dg pc pc pc pc dg collapsing sgl step identi es scc 
path condition pc pc pc dg step computes nal path condition pc pc substituting intermediate path conditions equations lead blowup formula ect fortunately avoided bdds 
note hierarchical sgl decomposition avoids explosion number paths enumeration paths limited local sccs certain level bottom process 
total complexity depends structure chop consideration 
sgl decomposition produces small nested sccs complexity path condition generation bottom level scc bounded constant standard divide conquer analysis results complexity 
ln 
chop just huge non decomposable scc number paths exponential making path conditions unfeasible 
implementation performance system generate path conditions full ansi pointer arithmetic setjmp longjmp 
section particular deal interprocedural analysis extending reps technique context free language reachability sdgs corresponding path conditions 
path condition generator implemented top slicer 
implemented lengauer tarjan fast dominator algorithm sgl generalized interval analysis 
core condition generator implemented section 
path conditions handled buddy bdd package bdds conditions cached corresponding sdg nodes 
nal path conditions extracted bdd fed standard quine minimizer order obtain minimal disjunctive normal form 
needed displaying path conditions prevents subsequent constraint solvers huge formulae 
note computing dnf exponential time complexity posed problem practice 
interface solver implemented interfaces solvers preparation 
solved conditions eventually example additional constraints left 
ecient path conditions dependence graphs 
sdg nodes edges loc calls mergesort calculator triple des ctags assembler agrep ex patch bison sdg depth maxn maxn mergesort calculator triple des ctags assembler agrep ex patch bison table sdg size structure various programs displayed user textual form 
comprises lines path condition generation simpli cation bdd package 
table presents data size sdg size number function de nitions calls dominator tree depth number reducible irreducible loops number nodes biggest reducible irreducible scc set benchmark programs 
relatively high number sdg nodes edges stems fact uses ne grained sdg expression level order cope side ects 
data clearly show high number nested sccs 
large amount caused ne grained expressions involve lot small loops sdg 
table ii presents running times memory requirements path condition examples 
number nodes edges arbitrarily selected chops dominator tree depth number reducible irreducible sccs 
path condition generated chop characterised number conjunctions disjunctions negations minimal dnf number numbers section di er numbers robschink snelting computed active points analysis improved interprocedural chopping algorithm 

snelting robschink krinke chop nodes edges depth mergesort calculator triple des ctags assembler agrep ex ex ex patch bison chop conj disj neg bdd sec mb mergesort calculator triple des ctags assembler agrep ex ex ex patch bison table ii 
chop structure bdd size performance various path conditions nodes resp 
variables bdds nally important data time space needed generate path condition 
determined ghz pc 
displays relationship scc size number sccs chops table ii 
data show sgl decomposition generates small sccs big sccs usually sccs higher levels sgl hierarchy lower part gure 
runtimes dominator computation sgl decomposition second irrelevant compared time path conditions 
analysing data rst point selection chops biased easy generation path conditions done quasi random super cial understanding source text 
programs chop selected 
clearly time space requirements path conditions strongly uenced number edges ecient path conditions dependence graphs 
cycle size mergesort calculator triple des ctags assembler agrep flex flex flex patch bison dominator level mergesort calculator triple des ctags assembler agrep flex flex flex patch bison fig 

number sccs vs scc size scc size vs dominator depth chop 
ultimate uence performance exercised decomposition properties chop 
example sreedhar decomposition ex resulted just big non decomposable scc time compute path condition hours 
comparison chop ex decomposable path condition computed faster number edges ex ex similar 
patch chop contains high number irreducible loops damages performance 
bison chop moderate size quite decomposable computation path condition took long time heuristics variable orderings obdd package example 
special case chop path condition determined minute 
transformation dnf ran memory example computing dnf caused exponential blowup 
usually computation dnf poses problems fails bdd allows eciently answer central questions question 
snelting robschink krinke fig 

real time system path condition false 
path conditions table moderate time space requirements 
viewpoint waiting hours path condition acceptable safety critical software 
furthermore suspect sreedhar decomposition hampered interprocedural paths situations decomposition improved considerably case data indicate program size limiting factor structure particular chop determine ort path condition 
demonstrates path conditions scale islands bad structure dicult generate path conditions practice 

case study system developed student project real time controllers 
ball maze moved target 
achieve maze rotated vertical angle orthogonal axes rotation controlled step motor 
stereo camera maze determine position ball 
software reads camera input computes ball position way target determines horizontal vertical angle maze sends corresponding signals step motor gure 
setup really nuclear power plant characteristics safety critical embedded systems 
source le loc ansi computation sdg took seconds 
library functions concerned camera motor control stubs provided simulate function behaviour respect data control dependencies parameters global variables 
experiment wanted check step motor uenced outside agent functions called times di erent places inhibit dominator relationships sdg decrease ect sreedhar decomposition 
show behaviour improved 
providing stubs popular precise way deal libraries quite expensive practice 
ecient path conditions dependence graphs 
weg ans line weg ans alter weg ans root weg weg ans root nicht ret ret nicht continue abs abs nicht continue nicht weg ans weg ans root alter alter nicht free alter line 
fig 

source code central loop determine witnesses suspicious behaviour 
displays central loop source code 
function names german gure displays functional structure system columns correspond function nestings 
ball reach target ball position read camera converted maze coordinates function line 
function computes euclidian distance intermediate ball position function uses neural net compute 
snelting robschink krinke receive computed path optical unit loop ball reaches destination read focal point ball ball lost alignment table wrong 
terminate program compute destination stage ball compute speed ball compute motor steps neuronal net compute navigation vectors motor send navigation vectors motor update alignment table update focal point ball compute horizontal alignment table compute navigation vectors motor compute euclidean distance actual position destination compute destination generate destination stages distance windows small compute length path receive path convert hardware software point write motor steps register run motor selection axes dist speed alignment table dist compute intersection distance window compute point scale values compute level neuron compute results time delayed neuronal network compute gate neuron train fuzzy net emulates fuzzy control considering alignment table axes selection compute target values net gates scale values compute results time delayed neuronal network train net adjust weights algorithm back propagation time delayed neuronal nets convert software step requests hardware sequences send navigation vectors motor write motor steps register run motor fig 

functional decomposition software rotation maze 
function transforms information control vector sent motor line maze angles adjusted accordingly 
displays path condition chop line line necessary condition uence motor camera 
atomic conditions path condition source le source line 
path conditions xed automatically constraints disjunctions simple value propagations automatically substituted complex constraints shown request 
ssa indices program variables italic font function return values bold font usually shown back unique assignment source code 
condition fed constraint solver solved form 
performance data chop table ii line 
condition surprisingly small compared program size quite clear look source code determining source positions ssa indices 
rst part condition requires target reached ball de nite position vertical angels maze direction exceed value steps intermediate target ball de ned euclidian distance ball intermediate target exceed maximum value 
inner disjunction demands ball velocity bounded intermediate target target reached condition neural network satis ed 
understandable path condition directly source code reveals number ring neurons distinguishes various cases angles target distance ball velocity 
part program needs closer examination far hints illegal motor manipulations observed 
obviously understanding path conditions requires knowledge program path conditions complex expect 
experiment asked programmers introduce safety violation manipulating motor keyboard 
fact keyboard path section di er slightly path conditions robschink snelting computed active points analysis improved interprocedural chopping leading smaller chops precise path conditions 
ecient path conditions dependence graphs 
pc nicht true calloc calloc calloc true sqrt root calloc root calloc root calloc root calloc max calc max max root neuronal neuronal neuronal neuronal fig 

path condition step motor input bu er variable taste key german declared easy spot 
programmers taste debugging version taste removed 
existing program sdg path initialization def taste visible gure motor control call line trivially pc def taste false 
manipulation path condition pc def taste computed 
result longer false condition gure computation path condition took seconds 
know possible uence keyboard step motor 
path condition contains various constraints similar gure atomic control 
snelting robschink krinke pc def taste jm jm calc neuron id neuronal ping neuronal possible manipulation nicht true calloc calloc calloc true neuronal neuronal neuronal calc neuron id neuronal ping ping ping ping ping ping ping taste taste real de nition neuronal fig 

path condition revealing safety violation condition ping 
global constraints displayed path condition state ping memory cell referred ping pointer chain ultimately states pointer equal taste ssa indices back source text taste def taste ping formal parameter 
see step motor manipulated keyboard input variable ping 
programmers le variable added declaration extern int ping le added declaration int ping 
le added statement ping int taste 
deeply hidden inside neuronal added statement ping increases scale factor neural net see gure right column ecient path conditions dependence graphs 
pc actual ball position intersection distance window fuzzy control optimization zl zl akt pos akt pos pos pos fig 

path condition ball position input angle target value th bit ping taste set 
interestingly variable occur path condition control condition 
ssa index ping witness condition links back source immediately identi es malicious statement 
note constructed manipulation obvious manipulation lines manipulative statements distributed various source les 
human expert hard time discover manipulation 
nal example consider path condition gure 
path condition necessary information ow ball position input comes camera value angle target 
value course depends ball position legal information ow 
compared path conditions gures condition quite di erent smaller 
example shows structure path conditions quite simple complex programs 

related similar spirit constraint test data generation gupta demillo ut 
methods test data generation control ow graph generate constraints enforce speci control ow 
generate constraints data ow essential analysis purposes 
furthermore methods 
snelting robschink krinke applied small programs contribution centers scaling 
heuristics obey principle conservative approximation required safety analysis 
restricted speci domains specialized solving techniques approach provide ecient general path condition generator connected specialised solvers 
commercial pre tool bush analyses control ow builds memory model order discover bugs memory leaks dangling 
generate simple path conditions bugs conditions control ow data ow 
pugh pugh wonnacott uses presburger arithmetic solving constraints concerning array dependencies 
pugh goal automatic parallelization loops describes dedicated constraints solving techniques 
array constraints fact subset pugh constraints strong furthermore employ presburger solver 
principle possible plug sophisticated analysis techniques 
reps reps investigated data types dependence graphs 
extends earlier technique context free language reachability order model equations types 
turns connection interprocedural dependencies data dependence 
approach hand rewriting modulo data dependences mechanism completely orthogonal dependence analysis 
precise avoids problems completely decoupled rest path condition generator 
smith volpano type system imperative language threads check bell la condition smith volpano 
type implementation approach denning denning denning security domains form lattice non standard denotational semantics simple imperative language order determine information ow di erent security levels 
compared slicing path conditions denning original approach smith volpano method precise type systems ignore control ow information slices chops 

path conditions dependence graphs valuable tool various kinds program analysis program understanding safety checks 
contribution concentrated fundamental techniques practical possibilities path conditions 
results summarized follows path conditions helpful reduce imprecision slicing demonstrate slices fact impossible subsequent constraint solving generate witnesses speci data ow particular illegal uences safety critical computations naive generation path conditions scale interval analysis bdds key devices taming complexity improved path condition generator produced witness safety violation medium sized program minute 
ecient path conditions dependence graphs 
course nished point 
particular want path conditions chops edges minutes hours 
rst step better scale improve sreedhar decomposition interprocedural case 
studies way order compare behaviour various solvers mathematica pugh omega test constraint logic programming 
fact path conditions classi ed syntactic criteria best solver selected automatically 
issue adaption extension java requires static approximation dynamic lookup behaviour slicing generation corresponding path conditions 
highest priority application path conditions dependence graphs case studies 
particular hope obtain commercial programs discover hidden trapdoor system prove exist 
making path conditions scale possible earlier slicing algorithms points analysis analysis bdds constraint solvers collectively researchers involved topics 
funded deutsche forschungsgemeinschaft dfg sn sn 
agrawal demillo spafford 
dynamic slicing presence pointers arrays records 
proceedings acm fourth symposium testing analysis veri cation tav 
acm press new york 
baader nipkow 
term rewriting 
cambridge university press 
bell la 
secure computer systems mathematical foundations 
mitre technical report benhamou colmerauer 
constraint logic programming selected research 
mit press 
bent atkinson griswold 
comparative study program tech 
rep cs university california san diego computer science engineering 
bergstra heering klint 
algebraic speci cations 
acm press addison wesley 

software merging slicing 
ieee computer society press los alamitos 
bryant 
graph algorithms boolean function manipulation 
ieee transactions computers 
burke carini choi hind 
flow insensitive interprocedural alias analysis presence pointers 
lecture notes computer science nicolau padua eds 
springer verlag 
bush pincus 
static analyzer nding dynamic programming errors 
software practice experience 
common criteria project sponsoring organizations 

common criteria information technology security evaluation 
iso iec 
snelting robschink krinke cytron ferrante rosen wegman zadeck 
eciently computing static single assignment form control dependence graph 
acm transactions programming languages systems 
demillo 
constraint automatic test data generation 
ieee transactions software engineering 
denning denning 
certi cation programs secure information ow 
communications acm 
sturm 
computer algebra meets computer logic 
acm bulletin 
ferrante ottenstein warren 
program dependence graph optimization 
acm trans 
program 
lang 
syst 
july 
goguen meseguer 
inference control unwinding 
proc 
symposium security privacy 
ieee 
botella 
automatic test data generation constraint solving techniques 
proc 
international symposium software testing analysis 
acm 
gupta mathur soffa 
automated test data generation iterative relaxation model 
proc 
international symposium foundations software engineering 
acm 
horwitz reps binkley 
interprocedural slicing dependence graphs 
acm trans 
program 
lang 
syst 
jan 
knoop steffen 
parallelism free ecient optimal bitvector analyses parallel programms 
acm trans 
program 
lang 
syst 

krinke 
static slicing threaded programs 
proceedings sigplan sigsoft workshop program analysis software tools engineering 
krinke 
evaluating context sensitive slicing chopping 
proceedings international conference software maintenance 
krinke snelting 
validation measurement software application slicing constraint solving 
information software technology 
special issue program slicing 
lengauer tarjan 
fast algorithm nding dominators 
acm transaction programming languages systems 
lind nielsen 
buddy binary decision diagram package 
tech 
rep university copenhagen 
www itu dk buddy 
mantel stephan vogt 
ur die und pr im von und common criteria 
tech 
rep ur der und deutsches forschungszentrum ur intelligenz 
version 
marriott stuckey 
programming constraints 
mit press 
mcdowell helmbold 
debugging concurrent programs 
acm computing surveys 
avrunin 
conservative data ow algorithm detecting pairs statements may happen parallel 
sixth acm symposium foundations software engineering fse 

ottenstein ottenstein 
program dependence graph software development environment 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments 
vol 


pugh wonnacott 
constraint array dependency analysis 
acm transaction programming languages systems 
ramalingam 
identifying loops linear time 
acm transactions programming languages systems 
reps 
program analysis graph reachability 
information software technology 
special issue program slicing 
ecient path conditions dependence graphs 
reps 
context sensitive data dependence analysis 
acm transactions programming languages systems 
reps horwitz sagiv 
speeding slicing 
sigsoft proceedings second acm sigsoft symposium foundations software engineering 
acm press new york 

reps 
precise interprocedural chopping 
sigsoft proceedings third acm sigsoft symposium foundations software engineering 
washington dc 
robschink snelting 
ecient path conditions dependence graphs 
proceedings international acm ieee conference software engineering icse 
orlando fl 
smith volpano 
secure information ow multi threaded imperative language 
proceedings fifth acm symposium principles programming languages 
san diego ca 
snelting 
combining slicing constraint solving validation measurement software 
proc 
static analysis symposium 
lncs vol 


sreedhar gao lee 

identifying loops dj graphs 
acm transactions programming languages systems 
sturm 
computational geometry problems 
automated deduction geometry 

tarjan 
testing ow graph reducibility 
journal computer system sciences 
teitelbaum 
code surfer user guide 
tech 
rep tech product documentation 
www com doc manual html 
tip 
survey program slicing techniques 
journal programming languages sept 
weiser 
program slicing 
ieee trans 
softw 
eng 
july 
republished 

simulation optimization quanti er elimination 
journal symbolic computation 

mixed real integer linear quanti er elimination 
issac proceedings acm international symposium symbolic algebraic computation 

appendix slicing goguen meseguer interference appendix rely notation goguen meseguer mantel 
assume nite set security domains fd set actions case set program statements precise set nodes sdg 
actions modify program state set program states denoted run state executing initial state output visible ect action statement sequence dynamically possible control ow graph run nal state executing statements initial state dom security domain action noninterference relation speci es security domains uence 
complement interference relation assumed re exive transitive 
statement sequence security domain function purge removes statements uence security level purge ha dom ha dom di 
system considered safe goguen meseguer noninterference 
snelting robschink krinke criterion possible statement sequences nal statements output run output run purge dom nal program output unchanged statement uence action security level deleted 
condition sati ed action produces di erent output actual run run supposedly uential statements removed uence statement forbidden due dom dom 
see notion safety observational behaviour source code 
statement 
bs potentially uence observational behaviour program state 
order prove safety assume dom dom bs 
hand statement supposed uence dom dom hold 
proposition 
dom dom bs 
safety criterion satis ed proof 
output run output run hs bs output run hs dom dom output run purge dom bs contains dom dom safety guaranteed 
practice slicing bs contain dom dom uence better slicing algorithms avoid including bs path conditions weaken premise dom dom bs pc false safety checks variant proposition practical typically want show certain subsystem set statements uence demand dom dom check bs dom dom check satis ed safety violation inside bs 
theorem guarantees software safe uence appendix proofs proof equation path go pc pc ch ch ch ch ch ch pp ch pc ecient path conditions dependence graphs 
proof equation write ch jz ch containing paths containing pc jz path condition equation applied ch jz 
pc ch ch jz pc jz pc pc equation dominator ch jz proof equation pc ch ch je pc je pc pc pc pc jo pc pc pc dominator ch jo proof equation pc ch pred ch jz pred pc jz pred pc pc pred pc pred pc conjunctively added pc 
proof equation 

snelting robschink krinke proof equation cycle 
pc ch ch ch ch ch fx ch fx fx ch fx ch ch cycle excluded pc back edge excluded 
