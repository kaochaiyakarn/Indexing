remote code update mechanism wireless sensor networks john heidemann technical report center embedded networked sensing ucla department computer science usc information sciences institute wireless sensor networks consist collections small low power nodes interface interact physical environment 
ability add new functionality perform software maintenance having physically reach individual node essential service limited scale current sensor networks deployed 
tinyos supports single hop air reprogramming today need reprogram sensors multihop network particularly critical sensor networks mature move larger deployment sizes 
multihop air programming moap code distribution mechanism specifically targeted mica motes 
discuss analyze design goals constraints choices optimizations focusing particular dissemination strategies retransmission policies 
implemented moap mica motes evaluate implementation emulation testbed experiments 
show dissemination mechanism obtains performance improvement terms required transmissions compared flooding 
show simple windowed retransmission tracking scheme nearly effective arbitrary repairs better suited energy memory constrained embedded systems 
increasing research attention directed wireless sensor networks 
large numbers small inexpensive devices integrate sensing computation communication monitoring environmental changes water contamination seismic activity structural integrity buildings cs ucla edu isi edu cs ucla edu deborah estrin devices quite heterogeneous multiple constraints limited cpu power ranging micro controllers basic microprocessors narrow bandwidth short range low power wireless radios limited energy budget 
deployed sensor nodes expected operate extended periods time human intervention 
fact deployment scenarios physically reaching nodes impractical nodes detrimental sensing process nodes inside nests 
spite difficulties real need add upgrade software running nodes post deployment 
sensor network users need remote programmability order add new functionality nodes especially knowledge environment complete predicting complete set actions node perform deployment impossible 
sense remote programmability extends usefulness network 
helpful dealing software maintenance situ debugging 
addition removing human programming loop expect automate process support large network sizes 
large networks multihop dissemination mechanism needed 
multihop code distribution mechanism considered special case reliable data dissemination 
need distribute large volume data nodes network means apply traditional approaches problem developed reliable multicast :10.1.1.121.1027
time application includes strict notion reliability internet real time audio video streaming received 
specific nature sensor networks requires mechanism operate low power unreliable radios limited memory stor age 
multihop code distribution adds exploration sensor network design space reliable communications 
tinyos developers anticipated remote programming requirements included support single hop air programming release 
single hop programmability limited usage especially network sizes grow reach single radio 
multihop air programming moap 
moap code distribution mechanism specifically targeted mica mote platform 
explore design goals questions related building mechanism 
terms resources focus energy consumption memory usage latency 
analyze design alternatives areas dissemination protocols retransmission policy storage management 
emulation actual standalone mote implementation show moap results reduction transmissions compared flooding 
result represents point design space balances complexity efficiency neighborhood neighborhood transport mechanism simple sliding window method tracking retransmissions 
modest terms storage consumption requiring approximately bytes ram kbytes program memory 
related looked main areas related code distribution sensor networks reliability protocols sensor networks multicast reliability data dissemination sensor networks code distribution sensor networks tinyos included network programming support mica motes release 
mechanism single hop basestation source transmits code capsules nodes broadcast domain 
entire image transmitted basestation polls node missing capsules 
nodes scan contents eeprom find gaps reply nacks necessary 
basestation unicasts missing capsules required 
order reduce energy consumption code distribution authors propose mechanism sending entire image differences new old code sent 
optimizations address shifts padding address patching mechanism able substantially reduce size updates especially differences small 
ideal choice incremental updates bug fixes 
difference creation mechanism developed moment distribution part uses point point communications 
code distribution mechanism targets mica motes includes support multiple concurrent versions 
nodes keep catalog objects available download periodically updated advertisements 
applications request content catalog updated versions code 
methods similar node requests content repairs immediate neighborhood moves source called sensor access point local retrieval fails 
addition includes duplicate suppression mechanisms similar srm 
completely different approach code distribution 
mate successor stack virtual machine 
includes execution contexts stacks context 
programs consist capsules capsule having instructions 
current implementation allows capsules 
includes special instructions forward capsules nodes 
nodes install capsule newer version number currently 
repeatedly forwarding instructions new capsule reach entire network 
reliability sensor networks reliability integral part moap code images delivered entirety nodes 
sensor network reliability protocols proposed 
pump slowly fetch quickly hop hop reliable transport protocol 
characterized phases low rate data distribution phase pump high rate nack error recovery phase 
data distribution phase controlled flooding algorithm data cache suppress duplicates 
moap generated nacks strictly local single hop 
uses broadcast repair requests suppression mechanisms similar srm reduce number duplicates 
mechanisms effective induce substantial overhead terms complexity 
reliable multi segment transport transport layer protocol designed run conjunction directed diffusion 
primary goal reliable delivery large pieces data subscribed sinks 
nack places responsibility loss detection receivers intermediate nodes actual sinks 
missing fragments requests unicast sink source 
caches intermediate nodes allow fast recovery 
worst case repair request needs travel way source 
moap similar uses unicast repair requests moap repairs local dissemination mechanism guarantees source hop away 
event sink reliable transport congestion control protocol tries meet reliability requirements set application conserving energy 
receiver driven guarantee delivery rate making problematic code distribution mechanism 
operates adjusting reporting frequency sending nodes achieve optimal operating point low congestion high reliability 
aspect explicit retransmission scheme 
mechanism edges sources sink 
dependent control messages rate adjustment information pushed way sources 
multicast reliability data dissemination sensor networks design moap repair suppression mechanisms influenced architectural choices scalable reliable multicast protocol srm :10.1.1.121.1027
srm imposes minimal requirements reliable multicast guarantees eventual delivery data group members delivery order 
srm places responsibility loss detection recovery receiver nack 
damping mechanisms avoid control packet repair request implosion hosts wait time transmitting request repeat requests overheard neighbors 
opportunistic listening addition control overhead srm direct port sensor net domain problematic 
aspects dissemination methods moap influenced directed diffusion 
diffusion known data dissemination mechanism sensor networks main aspects include routing network aggregation data naming 
implements publish subscribe interface having sinks send interest packets 
sources data matches interest reply sending data packets sink 
interests exploratory data reinforce particular path disseminated flooding 
induce significant overhead sinks network code distribution case 
new variants proposed push diffusion optimized receivers senders phase pull designed reverse case 
moap diffusion variant directly designed independent routing protocol includes similar interface 
problem description section describe code distribution problems terms requirements properties resource 
requirements properties code distribution code distribution mechanism designed fulfill 
complete image starting specific points network reach nodes 
requirement 
consider extended problem reaching subset nodes 

image fit single packet placed stable storage transfer complete point node safely reprogrammed 
required property 

lifetime network severely affected distribution operation 
desirable property 

memory storage requirements mechanism high limit available space normal application 
property desirable 
required properties necessary order ensure correctness mechanism 
desirable properties required ensure correctness overlooked systems intended practical 
fact complete image reach nodes code distribution special case multicast reliability 
reliability mechanism required ensure entire code transferred nodes presence link losses multiple hops 
mechanism handle disconnected nodes long permanent network partitioning 
resource prioritization satisfying desirable properties overly complex sensor nodes relatively powerful terms computation power memory embedded pcs connected solar panels 
hand target platform severely device mica mote careful planning necessary 
mote target platform consider resource prioritization fundamental design goal code distribution mechanism 
limited important resource mote energy 
operations require finite amount available possible equip motes solar panels replace batteries 
energy intensive operation mote radio usage particular packet transmission cc radio consumes ma transmit mode ma receive mode 
significant energy consumer stable storage eeprom access 
write operation needs average approximately eighth amount energy required transmitting number bytes 
reads significantly cheaper write order magnitude flash optimized read operations 
due nature code distribution code segment stored eeprom number write significant factor energy consumption 
immediately energy terms importance memory usage 
memory primarily refer amount static ram 
limited amount sram available mote platform conjunction increasing complexity mote applications main memory highly resource 
addition code distribution primary application mote 
thought part operating system utility service needs share memory real application 
considering current lack dynamic memory allocation motes mechanism memory usage needs modest 
evident main goal limit energy consumption particular packet transmissions possible 
optimizations aren free traded reduced energy usage 
particular application latency candidate 
sensor net applications code distribution need respond real time phenomena 
isn sensing physical world doing large data transfer 
addition assume code updates don shouldn occur frequently 
reasons assume latency important resource traded serious consequences 
design choices alternatives requirement section states data reach nodes 
intuitively suggests inherent broadcast capability wireless medium order reach large subset nodes transmission 
broadcasts don solve multi hop issue appropriate dissemination protocol needed 
requiring data node means reliability mechanism needed order ensure packet delivery presence lossy links 
second requirement implies form code segment management receiver 
needs consider design questions dissemination protocol data propagated 
reliability mechanism responsible initiating repairs 
scope 
scheme ack nack 
segment management segments stored retrieved indexed 
detect missing segment 
dissemination protocol common approach disseminate data deliver data nodes time 
traditional ip multicast protocols constructing trees rooted source rendezvous point 
nodes need reached case tree needs span entire network just subset 
addition protocol tolerant route link failures happen wireless domain 
state requirements multicast protocols direct porting sensor network world impractical 
routing protocols directed diffusion mote implementation tiny diffusion reduce memory requirements advantage soft state 
abstractions diffusion support communication tiny diffusion optimized disseminating data nodes nodes 
concurrent delivery mechanisms flooding 
flooding expect nodes reached state requirements minimal 
course penalty energy consumption considerable amount transmissions fact duplicates 
approach dissemination problem transfer data neighborhood neighborhood basis 
essence implies single hop mechanism recursively extended multi hop 
neighborhood small subset preferably nodes source rest receivers 
receivers entire image sources neighborhoods range original source 
mechanism required prevent nodes sources source neighborhood 
done publish subscribe interface 
sources publish newer version code image interested nodes subscribe 
source subscribers silent 
hopes take full advantage nature broadcast medium transmission reach nodes range absence losses 
long network partition nodes eventually receive full image 
mechanism call ripple ripple propagation property advantage guarantees data transmission progress source hop away 
nodes full image sources repairs local 
potential traffic reduction comes price increased latency 
data delivered nodes time anymore require full image sources operation definitely slower concurrent delivery approach 
requirement node needs entire image source strict 
possible nodes sources percentage image 
adds additional complexity system impractical device mote 
decoupling senders receivers forcing node state trading complexity memory latency 
ripple consistent resource prioritization section mainly trades latency energy 
reliability mechanism sensor network applications packet loss tolerated code distribution afford lose data complete image required 
approach reliability forward error correction send packets 
long packets received full image reconstructed 
traditional choice retransmission mechanism 
purpose code distribution scheme focus retransmission approach 
question needs answered responsible detecting loss 
sender responsible receivers sender needs keep state 
hand receiver needs keep state node sender 
minimize required sender state nearly ip multicast mechanisms receivers responsible detecting losses initiating repairs 
consequently repair mechanism nack positive acknowledgment schemes imply loss detection repairs done sender 
extra benefit nack approach significant reduction control traffic requiring ack packet sent potentially high energy overhead 
question concerns scope repairs 
far path source need inquire missing 
missing segment hops away number transmissions required repair considerable 
srm suggests repairs local possible :10.1.1.121.1027
require nodes eventually entire image safely assume time missing packet hop away 
impose restriction repairs local 
intuitively provide considerable reduction energy consumption complexity repair requests replies don need routed potentially long multihop path 
cost latency 
need choose retransmission policy 
particular need answer question repair requests broadcast unicast 
broadcasting requests gives higher probability requester receive reply potentially nodes neighborhood honor request 
cause excessive number duplicates subject implosion effects suitable suppression mechanism required 
non issue unicast considered extreme duplicate suppression mechanism 
hand probability receiving reply reduced node honoring request 
addition node fails disconnected requester way recovering remaining segments source discovery mechanism applied 
segment management second requirement section place segments image stable storage order reconstruct transfer complete 
important know segment order ask retransmissions honor repair requests 
simple method just read corresponding eeprom address check segment 
involves operation read consumes energy 
want find missing segments need potentially read span entire segment address range 
avoid expensive operations keeping record bitmap successfully received segments 
code images large storing bitmap ram consume considerable amount memory 
problem augmented lack dynamic memory allocation motes need keep bitmap store maximum size code image actual image smaller maximum 
reserving large amount memory potentially 
observations lead consider treating ram eeprom memory hierarchy explore properties hierarchical data structure 
parts bitmap reside ram placed stable storage swapping done required 
clearly approach saves ram usage consumes energy eeprom access involved 
completely different approach complex segment management sliding window 
point receiver knows successfully received packets window base 
receive successfully store retrieve size window offset 
similar small map size hierarchical case important difference receiver receive random segment store anymore 
segment fall inside window discarded 
segments smaller base problem duplicates segments larger offset aren advantage approach involve extra eeprom disadvantage tolerance previous mechanisms 
explore differences costs approaches section 
analysis comparison enumeration choices previous section means exhaustive 
believe represent considerable part design space 
proceed analyze compare subset choices resource prioritization goals energy memory representing complexity latency baseline 
section compare neighborhood neighborhood dissemination ripple concurrent delivery flooding simplified model 
ripple vs flooding basic assumptions analysis original source 
packet reception fixed probability failure link quality 
probability nodes transmissions 
assumption realistic simplifies analysis considerably 
transmission rate constant 
neighborhood set nodes broadcast domain 
neighborhoods overlap 
repairs assumed local 
addition definitions number total segments transmitted data rate number nodes neighborhood oi number sources neighborhood ki hop dist node original source hi total number nodes total number neighborhoods expected number transmissions needed nodes receive code image expected amount time needed nodes receive code image ime flooding probability node belonging neighborhood receiving packet average oi node neighborhood forward packet 
packet transmitted oi oi times neighborhood 
sum nodes neighborhoods expected number transmissions entire network oi second term total number retransmissions required network 
average time takes node distance hi source receive entire image expected number retransmissions required particular node 
note expected time independent distance original source assuming zero forwarding delay 
behavior expected concurrent nature flooding 
case ripple packet gets transmitted ki ki times neighborhood total number transmissions ki ki value ki depends amount overlap neighborhoods 
ripple property potential source silent subscribers 
oi nodes total neighborhood worst case ki oi 
absence losses observation means ripple fewer transmissions flooding 
note network density increases reduction traffic pronounced ki fact reduced 
limit fully connected network diameter course trivial case ripple requires transmissions flooding requires presence losses things favorable ripple 
ki oi loss probability higher flooding 
expect ripple require retransmissions 
link loss rate sufficiently high sending packets normal flooding 
loss model take collisions account real channel lead substantial number losses 
expect average number collisions ripple flooding contention channel 
average time takes node distance hi source receive entire image ripple hi note ripple delay directly proportional distance node original source equivalent flooding delay independent distance 
equations apparent ripple suitable sparse networks large diameter number transmissions approximately equal flooding delay max hi times 
retransmission policy broadcast vs unicast characterized reliability mechanism local scoped nack 
explore implications choosing retransmission policy specifically unicast broadcast requests asking retransmission 
broadcast request lead excessive amount replies suppression mechanism required 
consider different suppression mechanisms broadcasts addition case 
different design options investigate 
broadcast rreq repair request suppression nodes reply 

broadcast rreq nodes choose randomized interval snoop channel transmissions reply interval expires replied 
suppression mechanism introduced :10.1.1.121.1027

broadcast rreq nodes reply fixed static probability 

broadcast rreq nodes reply adaptive probability metric neighborhood size case ripple node source subscribers 

unicast rreq source replies 
situations original source fails handled requester doing sort source discovery 
randomized interval algorithm theoretically efficient suppression mechanisms randomization interval large 
trade optimality reduction complexity 
appropriate ripple clear distinction nodes active sources nodes aren option static probability generating reply dependent network dynamics 
lead expensive retransmission policy 
option tries better estimation function example neighborhood size 
assuming links uncorrelated loss probability requesting node sends rreq triggers reply probability getting missing packet simplifying assumption ignores collisions multiple nodes reply time biased favorably broadcasting schemes 
ripple set nodes honor repair request split parts policy expected number latency complexity replies broadcast request nodes reply broadcast request neighborhood size random interval estimation suppression timers broadcast request depends nodes reply selection static probability broadcast request depends neighborhood size nodes reply selection estimation adaptive probability unicast request considerable link publisher replies publisher fails table comparison different retransmission policies terms packets generated latency complexity 
subset nodes subscribers definition ki subset nodes image subscribers 
case flooding distinction doesn exist 
expected number packets get sent requesting node option 

randomization interval 

statically assigned probabilities 
flooding 
dynamically assigned probabilities 
flooding 
rreq required 
indicates potential duplicates generated 
option best terms reducing duplicates worst 
option statically assigned probabilities flexible large values degenerate option 
success suppression mechanisms depends largely correct estimation values especially ripple 
probabilistic techniques affected directly option depends number nodes capable replying immune 
options don involve estimation algorithm space complexity 
nodes picking reply interval uniformly range discrete slots slot picked average nodes 
reply duplicates 
complexity neighborhood size estimation subsequent parameters 
option requires software timers 
terms latency option fastest replies generated immediately 
option zero latency assuming source doesn fail 
source fails source discovery mechanism needs triggered 
incur considerable delay 
latency option depends randomization interval fact 
options latency zero probability max probability max reality methods create abundance duplicates having considerable latency due increased probability collisions 
essence channel operating capacity large number transmissions fail 
increases probability replies making back requester turn sends repair request adding latency 
sense duplicate suppression congestion control method 
comparative results options shown table 
segment management hierarchical data structures vs sliding window identified segment management alternatives categorized technique determine presence absence segment 

indexing data structure indicate presence segments eeprom 
find segment missing need read corresponding entry eeprom 
segment ram tx cost rx cost gap detection order management bytes cost tolerance indexing complete full indexing segment complete typical missing kr entry empty partial indexing ks kr kr complete typical segment missing minimum bitmap entry full hierarchical entry empty full indexing typical segment missing complete sliding window bitmap size typical table comparison different segment management techniques terms ram usage transmission reception gap detection cost order tolerance 
denotes read represents write 

full indexing entire segment bitmap kept ram 
entry segment toone full mapping 
find segment missing need just look entry 
partial indexing entry bitmap represents set consecutive segments 
entry full corresponding segments empty 
find segment missing need look entry div entry full segment need sequential read determine status 
hierarchical full indexing similar full indexing bitmap stored levels ram eeprom 
bottom level kept eeprom full indexing subset code image call page 
page size arbitrary ease analysis consider equivalent size physical eeprom page 
complete record pages kept ram top level 
pages relatively large ram usage method minimal 
find segment missing need associate page entry div number bits page look particular page entry mod 
sliding window bitmap segments kept ram starting segment successfully received order 
find segment missing check segment 
check bitmap see segment received 
segment considered missing order tolerance approach limited 
interested analyzing approaches terms eeprom access directly translates energy usage terms ram cost 
define tx cost cost terms eeprom transmitting segment 
receiving segment need determine duplicate case discard case store 
rx cost 
define cost finding missing segment ask retransmission gap detection cost 
method doesn require memory ram cost zero 
full indexing needs entry segment 
total image size bytes segment contains bytes ram required maximum value mote kb bytes typical value packet size kept small ram cost full indexing quarter total ram available current generation motes 
partial indexing keeps segments bitmap entry cost ks bytes 
hierarchical full indexing requires bytes ram page size bytes 
page size equivalent physical page size value bitmaps levels ram cost bytes 
sliding window method ram requirements window size 
typical values bytes corresponding window sizes 
transmission cost methods read transmit segment need read corresponding eeprom entry assuming course segment terms rx cost method requires read write way knowing segment duplicate 
full indexing sliding window method write segment missing zero cost terms eeprom partial indexing needs read corresponding entry empty order determine segment missing 
need pay cost segments missing received segment duplicate 
segment course write 
bitmap entry full cost zero 
hierarchical full indexing requires read determine segment duplicate assuming top level record indicates incomplete page 
segment missing need write update bottom level bitmap eeprom write segment 
top level record indicates page full cost zero 
terms gap detection cost method needs read eeprom entries sequentially find missing segment doesn bitmap 
means read time segment missing 
full sliding window gap detection cost zero 
partial indexing needs read find missing segment minimum read 
hierarchical full indexing needs read locate missing segment bitmap fetched eeprom 
table shows results analysis 
easily discern having record quite expensive terms energy memory usage zero 
different indexing schemes trade memory usage hierarchical full indexing lowest memory usage requires write new segment received 
quite expensive considering cost write order magnitude higher cost read 
partial indexing consumes energy hierarchical full indexing small cost memory 
sliding window method best combination energy memory cost trades order tolerance 
link losses high lead increase energy consumption due unnecessary retransmissions 
link losses probability receiver losing synchronization sender receiving packets outside window small sliding window method appropriate choice 
implementation design goals priorities described previous sections implementation choices moap ripple dissemination protocol unicast retransmission policy sliding window segment management 
energy consumption remains primary constraint ram program memory usage important 
process programming mote air follows 
programmer builds new code standard tinyos tools 
binary image passed divides motorola format binary actual segments 
segment byte address field indicating address program memory byte data field 
current version moap packet contains segment 
mote attached pc original source basestation 
sends publish messages advertising new version code 
nodes check version number send subscribe messages smaller advertised versions 
nodes link statistics mechanism subscribe sources lossy intermittent unreliable links 
original source receives subscribe message waits small amount time allow nodes send subscriptions starts data transfer 
ripple suggests mote complete image stored eeprom send publish messages secondary source 
doesn receive subscribe messages specific amount time commits invokes transfer code eeprom program memory restart mote new code 
active sources don stay active forever commit 
transmitting entire code image waiting predetermined amount time order handle potential retransmissions segments commit 
eventually assuming network partition nodes basestation commit new code 
node detects lost segment sliding window method ask source retransmission unicast packet 
retransmission requests higher priority regular packets source honor retransmission requests resume regular data transfer 
sources suppress duplicate requests nodes request segment time period source transmit 
nodes keep track sources activity keepalive timer 
keepalive timer dual purpose solves packet problem inherent nack schemes contingency mechanism case source dies receiver loses connection 
certain amount time receiver hasn heard source transmit broadcast repair request 
sources range reply node select new source configurable properties link statistics technique subscribe previous source 
sources range mote continues send broadcast repair requests 
maximum number reached node perform abort reset moap relevant state erase segments eeprom 
wait new neighbor source case subscribe continue invoke late joiner mechanism 
purpose late joiner mechanism allow nodes disconnected just recovered failure way detached code transfer operation receive new image 
requires nodes periodically send publish messages advertising version 
node detects version mismatch version number smaller send publish message 
new packet send byte version number piggyback existing periodic messages neighbor beacons neighbor discovery protocol interests tiny diffusion 
current version moap piggybacking 
ram footprint moap currently approximately bytes rom program memory footprint approximately kbytes 
careful optimization reduce ram usage 
potential caveat lies fact memory optimizations example multiplexing single timer increase rom footprint additional control instructions required 
increasing rom footprint leads increased energy consumption 
entire moap code needs transferred retain ability reprogram new code image include moap 
problem solved extent difference techniques 
current version moap successfully repeatedly reprogram motes hops away basestation code images various sizes ranging bytes 
evaluation analysis moap section provides steadystate performance estimations assumptions 
evaluate real world performance various design choices implemented moap em star emulation environment 
focused validating subset choices native mote implementation 
number nodes neighborhood power setting neighborhood size mean neighborhood size different power settings 
increasing power results linear increase neighborhood size 
highest power setting approximately network connected 
emulation emstar running bit platform dynamic memory support methods full indexing expensive mote case 
real radio channel allows evaluate different dissemination methods retransmission policies 
mote dependent details eeprom management writing program memory abstracted away functionality emstar implementation provides identical code running real motes 
emstar experimental setup consisted mica motes placed ceiling laboratory 
placement nodes fixed attached serial cables emstar node changed radio power order capture effects variable density 
average neighborhood size indication network density different power levels experiments shown 
setup nodes considered neighbors bidirectional loss rate provided link statistics mechanism 
neighborhood size increases linearly power settings increase 
result figures just reporting power settings 
addition subsequent figures data points taken averaging experimental runs power setting error bars represent confidence intervals 
transmitted code image consisted segments segment packet 
methods sliding window window size bits 
experiments ran node received image entirety 
mean transmissions node packets power setting flooding ripple full indexing ripple sliding window mean packets transmitted node versus radio power different network density flooding sliding window ripple full indexing ripple sliding window 
network density increases energy savings obtained ripple profound 
file size segments segment packet 
window size bits 
energy consumption order determine energy consumption different dissemination strategies compared ripple sliding window flooding sliding window ripple sliding window ripple full indexing 
full indexing identical indexing methods portrayed section terms order tolerance expect methods exhibit behavior terms packets transmitted 
average number packets transmitted node including retransmissions different power settings shown 
flooding transmissions close nodes ends forwarding entire file 
changes different power settings small 
contrast ripple variants quite sensitive changes network density 
network connectivity sparse incur average reduction traffic opposed flooding 
difference pronounced neighborhood size increases 
relatively dense networks ripple result order magnitude reduction traffic leading substantial energy savings 
results match simple models section 
flooding results show little fluctuation number retransmissions flooding minimal redundancy repairs rarely needed 
ripple full indexing performs average better sliding window counterpart 
difference primarily due limited outof order tolerance sliding window mechanism results retransmissions 
mean time required dissemination mins power setting flooding ripple full indexing ripple sliding window mean time required entire file reach nodes versus radio power flooding sliding window ripple full indexing ripple sliding window 
ripple variants approximately times slower flooding 
high density networks differences large warrant incurring cost indexing method sliding window better alternative 
latency energy savings ripple free 
shows average time required code image reach nodes transmission rate packets second 
transmission rate quite modest implementation increase times expect utilize channel ripple 
flooding different excessive number transmissions saturate channel quickly 
substantially increase number retransmissions needed collision probability large 
rate experiments ripple variants significantly slower flooding 
results consistent analysis section 
ripple latency reduced higher densities flooding extensively affected 
full indexing performs better sliding window requiring average time 
reason increased number retransmissions 
retransmission policies ripple sliding window variant compared unicast retransmission mechanism mote implementation broadcast scheme 
results terms total number retransmissions performed network different power settings shown 
unicast broadcast leads total number packets retransmitted unicast repair requests broadcast repair requests power setting total number packets transmitted versus radio power retransmission policies broadcast suppression unicast 
unicast results massive gains terms duplicate suppression energy savings 
significant reduction packets retransmitted especially higher power settings correspond larger densities better links 
advantage unicast requests broadcast pronounced mac provides link level retransmissions mac unicast reliability substantially higher 
implementations currently mac planning releases moap 
mote implementation conducted experiments actual implementation moap order evaluate target platform 
setup consisted mica motes 
file size segments segment packet bit window 
shows average number transmissions node ripple sliding window described section 
don currently tinyos implementation flooding ripple full indexing comparative results methods mote version 
addition fewer power settings mote experiments level nodes broadcast domain 
powerful reliable cc radio mica motes opposed rfm radio mica results better link qualities fewer retransmissions rapid change neighborhood size 
number transmissions node significantly fewer corresponding emulation graph 
trend ripple preserved higher network density leads reduction transmissions 
mean transmissions node packets power setting ripple sliding window mean packets transmitted node versus radio power ripple sliding window standalone motes 
powerful reliable cc radio mica motes main reason reduction transmissions compared 
experimental results flooding standalone motes safely assume close emulation case small number retransmissions 
reason nature flooding node network forward packets 
important features improve performance functionality moap sending differences versions 
results shown sending differences versions entire new version result order magnitude decrease size transferred 
perform image reconstruction directly mote program memory help transfer code image eeprom construct new image 
approach complementary moap mechanism lead greater reduction energy usage 
support selective node updates 
currently moap tries update node version code 
isn desirable 
selective updating possible don require node commit new code receiving 
intermediate nodes interested new version act ripple sources 
nodes need update dense significant energy penalty 
small sets nodes topologically distant dissemination techniques required 
sensor networks mature grow larger size remote programmability critical system service 
moap multihop air programming mechanism specifically targeted large networks mica motes 
moap designed energy memory efficient expense increased latency 
design choices focused areas dissemination protocol retransmission mechanism storage management code segments 
analyzed array different options simple models evaluated implementation results emulation mote testbed 
reliability mechanisms moap help explore design space reliable communications 
ripple dissemination protocol moap achieves significant reduction transmitted traffic opposed flooding ranging 
accomplishes selecting small subset nodes broadcast domain act sources code image publish subscribe interface 
simple sliding window scheme repair mechanism 
limited order tolerance showed performs adequately compared substantially complex schemes 
showed unicast retransmission policy effective suppressing duplicates 
mote implementation successful reprogramming motes hops away basestation 
months expect deploy improved version moap field 
acknowledgments moap possible support darpa ed national science foundation cooperative agreement ccr supporting center embedded networked sensing 
john heidemann partially supported national science foundation nsf number ani mac protocols specific sensor networks 
crossbow providing source code david culler jason hill making valuable comments helped improve functionality moap 
sally floyd van ching gung liu lixia zhang :10.1.1.121.1027
reliable multicast framework light weight sessions application level framing 
proceedings acm sigcomm conference pages cambridge ma usa august 
acm 
schulzrinne casner frederick jacobson 
rtp transport protocol real time applications 
internet draft ietf avt rtp new txt 
jason hill robert szewczyk alec woo seth hollar david culler pister 
system architecture directions networked sensors 
proceedings ninth international conference support programming languages operating systems asplos ix pages cambridge ma usa november 
acm 
crossbow technology mote programming user webs cs berkeley edu tos tinyos doc pdf 
crossbow technology mica wireless measurement system datasheet www com products product pdf files wireless mica pdf 
niels koen langendoen 
efficient code distribution wireless sensor networks 
proceedings nd acm international conference wireless sensor networks applications pages 
acm press 
vladimir hull kyle jamieson rost hari balakrishnan 
reliable data dissemination wireless sensor networks 
poster sosp october 
philip levis david culler 
mate tiny virtual machine sensor networks 
proceedings th international conference architectural support programming languages operating systems asplos pages 
acm press 
wan campbell 
reliable transport protocol wireless sensor networks 
proceeedings acm international workshop wireless sensor networks applications wsna atlanta georgia usa september 
acm 
fred john heidemann 
reliable data transport sensor networks 
proceedings international workshop sensor net protocols applications page appear anchorage alaska usa april 
usc information sciences institute ieee 
heidemann silva intanagonwiwat govindan estrin ganesan 
building efficient wireless sensor networks low level naming 
sosp lake louise banff canada october 
zg ian akyildiz 
event sink reliable transport wireless sensor networks 
proceedings mobihoc annapolis maryland usa june 
acm 
john heidemann fabio silva deborah estrin 
matching data dissemination algorithms application requirements 
technical report isi tr usc information sciences institute april 
james kurose keith ross 
computer networking 
addison wesley 
elson bien cerpa ganesan girod greenstein estrin 
emstar environment developing wireless embedded systems software 
technical report tr march 
deepak ganesan bhaskar krishnamachari alec woo david culler deborah estrin stephen wicker 
complex behavior scale experimental study low power wireless sensor networks 
technical report ucla csd tr 
ye heidemann estrin 
mac protocol wireless sensor networks 
proceedings ieee infocom 
