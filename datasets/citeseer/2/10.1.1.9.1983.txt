evolutionary concept learning federico elena marchiori computer science dept vrije universiteit amsterdam netherlands cs vu nl inductive learning order logic fol hard task due prohibitive size search space computational cost evaluating hypotheses 
introduces evolutionary algorithm concept learning fragment fol 
algorithm evolves population horn clauses repeated selection mutation optimization clauses 
main novelty respect previous approaches stochastic search biases reducing complexity search process clause tness evaluation 
experimental evaluation algorithm indicates ectiveness learning short hypotheses satisfactory accuracy short amount time 
learning examples fol known inductive logic programming ilp constitutes central topic machine learning relevant applications problems complex domains natural language molecular computational biology 
learning viewed search problem space possible hypotheses 
fol description language express possible hypotheses background knowledge set positive examples set negative examples nd hypothesis covers positive examples negative ones cf 

problem np hard language represent hypotheses propositional logic 
fol hypotheses complexity searching combined complexity evaluating hypotheses 
popular fol learners foil progol adopt progressive coverage approach 
starts training set containing positive negative examples construct fol rule covers positive examples removes covered positive examples training set continues search rule 
process terminates maximum number iterations positive examples covered resulting set rules reviewed eliminate redundant rules 
algorithms di erent greedy methods heuristics information gain cope complexity search 
fol learners genetic algorithms act clauses time 
systems gil steps encoding chromosome represents set rules 
ga systems sia net dogma chromosome represents clause 
case non redundant hypothesis extracted nal population evolutionary process 
approaches advantages drawbacks 
encoding hypothesis chromosome allows easier control genetic search introduces large redundancy lead populations hard manage individuals enormous size 
encoding clause chromosome allows operation competition di erent clauses reduces redundancy requires sophisticated strategies evolution coping presence population 
introduces evolutionary algorithm evolves set chromosomes representing clauses iteration tter chromosomes selected mutated optimized 
main nov respect previous approaches stochastic mechanisms controlling complexity construction optimization evaluation clauses 
rst mechanism allows user specify percentage background knowledge algorithm way controlling computational cost tness evaluation 
second mechanism allows control greediness operators mutate optimize clause controlling computational cost search 
furthermore introduce test variant universal su rage selection operator called weighted universal su rage wus selection operator 
selection operator idea individuals candidates elected positive examples voters 
positive example voting power 
idea wus selection operator give voting power examples harder cover 
voting power examples adjusted computation 
show experimentally algorithm able nd hypotheses satisfactory quality respect accuracy simplicity short time 
learning algorithm algorithm considers horn clauses form consisting atoms arguments variables constants 
atom called head set atoms called body 
head describes target concept predicates body background knowledge 
background knowledge contains ground facts clauses form constants 
training set contains facts true positive examples false negative examples target predicate 
clause said cover example theory formed clause background knowledge logically entails example 
clause declarative interpretation universally quanti ed fol implication procedural order solve solve 
set clauses forms logic program directly slightly di erent syntax executed programming language prolog 
goal learning algorithm rephrased nding logic program models target concept set training examples background knowledge 
algorithm introduce called ecl evolutionary concept learner illustrated pseudocode gure 
algorithm ecl sel positive examples repeat select partial background knowledge population initial pop terminate select chromosomes sel selected chromosome mutate optimize insert population store population final population sel sel positive examples covered clauses population max iter reached extract final theory population repeat statement algorithm constructs iteratively final population union max iter populations 
iteration part background knowledge chosen stochastic search bias described 
population evolved repeated application selection mutation optimization statement 
operators chosen part background knowledge 
generation evolution clauses selected means universal su rage selection operator powerful selection mechanism achieving species formation gas concept learning 
selection chooses randomly positive example set sel positive examples covered clauses actual final population performs roulette wheel selection clauses population cover example 
example covered clause new clause constructed example seeding operator 
selected clause modi ed mutation optimization operators inserted population 
construction final population completed logic program extracted set covering algorithm 
presenting main steps ecl describe stochastic search biases 
stochastic search biases ecl uses stochastic mechanisms selecting part background knowledge selecting degree greediness operators evolutionary process 
parameter real number simple stochastic sampling mechanism selects element background knowledge probability way user limit cost search tness evaluation setting low value 
part background knowledge assessing goodness individual 
leads implicit selection subset examples examples covered partial background knowledge selected considered 
individuals evaluated examples partial background knowledge 
way individual wrongly evaluated subset examples examples wrongly classi ed case covered background knowledge covered partial background knowledge 
di erent mechanisms improving eciency tness evaluation training set sampling employed speeding evaluation individuals 
construction mutation optimization clause greedy generalization specialization operators described apart section 
greedy operator involves selection set constants set variables 
size set supplied user setting corresponding parameter 
elements set randomly chosen uniform probability 
way user control greediness operators higher values parameters imply higher greediness 
ecl uses language bias commonly employed ilp systems limiting explicitly maximum length clauses 
search biases allow reduce cost search tness evaluation price pay may impossibility nding best clauses 
fitness representation quality clause cl measured tness function fitness cl pos pos cl pos 
neg cl neg aim ecl evolve clauses minimum tness cover positive examples negative ones 
formula pos neg respectively total number positive negative training examples pos cl neg cl number positive negative examples covered clause cl weight favor clauses covering negative examples 
weight deal skewed distributions examples high weight positive examples negative ones 
ecl uses high level representation similar sia clause described sequence representation preferred ga typical representations bit string allows direct ilp operators generalization specialization clause 
constraint length chromosome bitwise representation net systems requires user specify initial template target predicate 
clause construction clause cl constructed selection operator selects positive example covered clause actual population 
example seed procedure bk denotes chosen part background knowledge 

selected example head emerging clause 
construct sets cl cl cl consists atoms bk having argument occur head cl contains elements bk cl having argument occurring head 

length cl cl cl randomly select atom cl remove cl cl empty randomly select atom cl remove cl 
add selected atom emerging clause cl 
generalize cl possible means repeated application generalization operator constant variable described section 
apply operator clause tness increases maximum number iterations reached 
case retract application generalization operator 
step maximum length clause supplied user 
supplied rst condition cycle dropped constraint length clause imposed 
selection selection operator rst introduced selects clauses steps 
randomly select examples positive examples set 
selected example cov set clauses current population cover cov choose clause cov roulette wheel mechanism sector associated clause cov proportional ratio tness sum tness clauses occurring cov 
cov create new clause covering seed 
introduced selection operator distributed system various genetic nodes genetic node performs ga setting examples assigned node different training sets changed computation 
ga level examples probability selected 
propose variant selection called weighted selection examples di erent probability selection 
weight associated example smaller weights associated examples harder cover 
random selection step selection replaced selection takes account weights examples 
detail weight example equal cov pop pop current population cov set clauses pop cover population empty example weight 
examples selected roulette wheel mechanism dimension sector associated examples inversely proportional weight example 
clauses cover example chances example selected 
weights examples updated iteration 
examples selected selection clauses standard selection operator 
mechanism uncovered examples favored examples covered clauses favored having wider sector roulette wheel 
examples covered clauses penalized easier cover 
way system focus iteration harder examples covered 
mutation optimization mutation consists application generalization specialization operators 
operator chosen follows 
randomized test decides generalization specialization operator 
operators chosen class randomly applied 
rst test completeness consistency selected individual 
individual consistent training set individual generalized 
probable individual specialized 
test decides generalize clause cl probability gen cl pos cl pos neg decides specialize clause 
constant slightly bias decision generalization 
probability gen maximal cl covers positive negative examples minimal opposite case 
optimization phase consists repeated application greedy operators selected individual tness increase maximum number iterations reached 
system crossover operator 
experiments simple crossover operator uniformly swaps atoms body clauses conducted 
results justify 
hypothesis extraction termination condition main statement ecl met positive examples covered maximum number iterations reached 
case logic program target predicate extracted nal population 
theory cover positive examples possible negative ones notice stage clauses globally evaluated complete background knowledge 
problem translated instance weighted set covering problem follow 
element cl nal population column positive weight equal weight cl neg cl covered positive example row 
columns relative positive example clauses cover example 
way clauses covering negative examples favored 
fast heuristic algorithm applied problem instance nd best theory 
generalization specialization operators clause cl generalized deleting atom body clause replacing occurrences constant variable 
dually cl specialized adding atom body cl replacing occurrences variable constant 
operators utilize parameters respectively de nition gain function 
applied operator clause cl gain function yields di erence clause tness application gain cl fitness cl fitness cl operators de ned 
atom deletion consider set atm atoms body cl randomly chosen 
atm compute gain cl gain cl deleted cl choose atom yielding highest gain gain cl ties randomly broken generalize cl deleting body 
insert deleted atom list cl associated cl containing atoms deleted cl atoms list may added clause evolutionary process means specialization operator 
constant variable consider set ar variables cl plus new variable 
consider set con consisting constants cl randomly chosen 
con ar compute gain cl fa xg gain cl occurrences replaced choose substitution fa xg yielding highest gain ties randomly broken generalize cl applying fa xg 
atom addition consider set atm consisting atoms cl list built initialization time atoms cl randomly chosen 
atm compute gain cl gain cl added body cl choose atom yielding highest gain gain cl ties randomly broken specialize cl adding body 
remove original list cl cl 
variable constant consider set con consisting constants problem language randomly chosen variable cl randomly chosen 
con compute gain cl fx ag gain cl occurrences replaced choose substitution fx ag yielding highest gain ties randomly broken specialize cl replacing occurrences experimental evaluation consider datasets experimenting ecl vote credit mutagenesis dataset respectively 
dataset public domain datasets 
vote dataset contains votes house representatives sixteen key votes 
problem learning concept distinguishing democratic republican 
dataset consists instances examples democrats 
credit dataset concerns credit card applications 
problem consists learning allow subject credit card 
instances positive instances negative instances 
instance described fteen attributes 
rst datasets taken 
mutagenesis dataset comes eld organic chemistry concerns problem learning mutagenic activity compounds 
compounds occur automobile exhaust common intermediates synthesis thousands industrial compounds 
highly mutagenic carcinogenic 
concept learn expressed predicate active states compound mutagenic activity 
dataset originates 
parameter settings experiments table 
vote credit mutagenesis pop size mut rate max gen max iter table parameter settings pop size maximum size population mut rate mutation rate number selected clauses max gen maximum number ga generations max iter maximum number iterations parameters greedy operators parameter bk selection maximum length clause values obtained experiments training sets constraint run ecl take hour 
expected values depend speci dataset 
unfortunately unable nd general rules explain choice parameters 
general challenging problem investigating methods line adaptation parameters 
evaluation method fold cross validation 
data set divided disjoint sets similar size sets test set union remaining forms training set 
ecl run training set outputs logic program performance new examples assessed test set 
process repeated times time di erent set test set 
average results taken nal evaluation measure ecl 
consider performance measures eciency running time algorithm training set nding logic program simplicity number clauses logic program accuracy proportion examples test set correctly classi ed resulting logic program 
system vote credit mutagenesis net progol ecl table accuracy results obtained fold cross validation 
standard deviation brackets 
results obtained ecl compared results obtained ective concept learners di erent approaches table 
decision trees progol employs progressive coverage method net distributed coevolutionary genetic algorithm 
results rst systems taken result progol taken 
results obtained fold cross validation 
vote dataset results obtained ecl comparable obtained systems 
results credit dataset worse net 
table presents results obtained datasets parameter set 
means background knowledge 
parameters ones de ned table 
seen results better results shown table especially mutagenesis dataset 
probably due tting take place information problem tackle 
expected dataset accuracy eciency simplicity vote min credit min mutagenesis min table results obtained ecl parameters shown table set background knowledge 
dataset eciency simplicity vote ecl minutes vote net credit ecl minutes credit net mutagenesis ecl minutes mutagenesis hours table eciency average running time simplicity average number clauses ecl disjuncts net 
system slows sensibly background knowledge 
table shows average time taken run dataset 
table shows cases systems outperform ecl ecl able nd short amount time simple result satisfactory accuracy 
instance mutagenesis dataset ecl able nd simple logic program clauses just minutes average 
contrast mentioned net distributed system working cluster workstations needs hours nding theory comparable simplicity accurate 
unfortunately detailed results execution time net available replicating experiments resulted possible due impossibility install system vs weighted selection operator wus vote credit mutagenesis table average accuracy results obtained dataset weighted selection operator 
neri support 
table reports results wus selection operators compared 
seen wus selection operator improves accuracy system vote mutagenesis datasets 
particular vote dataset di erence evident 
credit dataset wus selection operator lead improvement 
results experiments indicate dramatic bene wus selection operator ect ciency system alternative selection mechanism 
concept learning algorithm evolutionary computation incorporates novel simple parametric mechanisms controlling cost searching hypotheses space cost tness evaluation 
introduced variant selection operator called weighted selection operator 
algorithm pro exploring ef ciently new learning problem get rst rough idea possible simple models target concept experimenting range di erent search strategies time including random search hill climbing bounds range obtained ecl setting appropriately bias search parameters 
search biases ecl assume uniform distribution data selection 
re ect reality learning problems 
investigating alternative stochastic sampling mechanisms selecting portion background knowledge take account estimated importance element fact background knowledge evaluation measure obtained examples training set 
giordana giuseppe lo bello lore saitta 
experimental evaluation concept learning 
proc 
th international conf 
machine learning pages 
morgan kaufmann san francisco ca 
ashby 
de nitive relationships chemical structure carcinogenicity mutagenicity chemicals tested ntp mutation research 
learning rst order logic rules genetic algorithm 
usama fayyad uthurusamy editors international conference knowledge discovery data mining pages montreal canada 
aaai press 
blake merz 
uci repository machine learning databases 
lopez de 
structure activity relationship mutagenic aromatic compounds 
correlation molecular orbital energies 
journal medical chemistry 
eiben michalewicz 
parameter control evolutionary algorithms 
ieee transaction evolutionary computation july 
giordana neri 
search intensive concept induction 
evolutionary computation 
giordana saitta 
phase transitions relational learning 
machine learning 
robin glover peter sharpe 
ecient ga techniques classi cation 
applied intelligence 

dogma ga relational learner 
page editor proceedings th international conference inductive logic programming lnai pages 
springer verlag 

knowledge intensive genetic algorithm supervised learning 
machine learning 
kennedy giraud carrier 
depth controlling strategy strongly typed evolutionary programming 
gecco proceedings annual conference pages 
morgan kau man july 
kubat bratko michalski 
review machine learning methods 
michalski bratko kubat editors machine learning data mining 
john wiley sons chichester 
leung wong 
genetic logic programming applications 
ieee expert 
marchiori 
evolutionary algorithm large scale set covering problems application airline crew scheduling 
real world applications evolutionary computing 
springer pages 
springer verlag 
mitchell 
generalization search 
arti cial intelligence 
mitchell 
machine learning 
series computer science 
mcgraw hill 
muggleton 
inverse entailment progol 
new generation computing 
muggleton 
inductive logic programming issues results challenge learning language logic 
arti cial intelligence 
muggleton de raedt 
inductive logic programming theory methods 
journal logic programming 
neri saitta 
analysis genetic algorithms evolution pure selection 
proceedings sixth international conference genetic algorithms pages 
morgan kaufmann san francisco ca 
quinlan 
learning logical de nition relations 
machine learning 
srinivasan muggleton king sternberg 
mutagenesis ilp experiments non determinate biological domain 
wrobel editor proceedings th international workshop inductive logic programming volume gmd studien pages 
gesellschaft ur mathematik und mbh 
astro teller david andre 
automatically choosing number tness cases rational allocation trials 
john koza kalyanmoy deb marco dorigo david fogel max garzon hitoshi iba rick riolo editors genetic programming proceedings second annual conference pages stanford university ca usa july 
morgan kaufmann 
