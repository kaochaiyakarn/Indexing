early performance testing distributed software applications giovanni universit di milano dipartimento di informatica sistemistica milano italy disco performance characteristics response time throughput scalability key quality attributes distributed applications 
current practice rarely applies systematic techniques evaluate performance characteristics 
argue evaluation performance particularly crucial early development stages important architectural choices 
glance contradicts testing techniques usually applied project 
assume distributed systems built middleware technologies java enterprise edition ee common object request broker architecture corba 
provide services facilities implementations available architectures defined 
note middleware functionality transaction persistence services remote communication primitives threading policy primitives dominate distributed system performance 
drawing observations presents novel approach performance testing distributed applications 
propose derive applicationspecific test cases architecture designs performance distributed application tested middleware software early stages development process 
report empirical results support viability approach 
keywords middleware software testing distributed software architecture software performance performance analysis models research conducted author study leave ucl 
partially supported european union research training network 
andrea cnr pisa italy wolfgang emmerich university college london dept computer science wc bt london uk emmerich cs ucl ac uk 
various commercial trends lead increasing demand distributed applications 
firstly number mergers companies increasing 
different divisions newly merged deliver unified services customers usually demands integration systems 
time available delivery integration short building new system option existing system components integrated distributed system appears integrating computing facility 
secondly time available providing new services decreasing 
achieved components shelf integrated system built scratch 
components integrated may incompatible requirements hardware operating system platforms deployed different hosts forcing resulting system distributed 
internet provides new opportunities offer products services vast number potential customers 
required scalability commerce government sites usually achieved centralised client server architectures demand distributed software architectures 
growing importance distributed systems interested devising systematic ways ascertain distributed software architecture meets performance requirements users 
performance characterised different ways 
latency typically describes delay request completion operation 
throughput denotes number operations completed period time 
scalability identifies dependency number distributed system resources distributed application typically number hosts processors latency throughput 
despite practical significance various aspects adequately understood test performance distributed applications 
weyuker reported weakness published scientific literature software performance testing 
date significant scientific advances performance testing 
furthermore set tools available software performance testing fairly limited 
widely tools workload generators performance profilers provide support test execution debugging solve unclear aspects process performance testing 
particular researchers practitioners agree critical performance problems depend decisions early stages development life cycle architectural choices 
iterative incremental development widely promoted testing techniques developed far focused development process 
consequence need early evaluation software performance weakness testing great majority research focused performance analysis models testing techniques 
research shares general approach translating architecture designs unified modeling language uml models suitable analysing performance layered queuing networks stochastic petri nets stochastic process algebras 
estimates performance reveal flaws original architecture compare different architectures architectural choices 
models may give useful hints performance help identify bottlenecks tend inaccurate 
firstly models generally ignore important details deployment environment 
example performance differences may significant different databases operating systems complex characteristics specific databases operating systems seldom included models 
secondly models tuned manually 
example case layered queued networks solving contention cpu requires input number cpu cycles operation expected 
tuning type parameters usually guessed experience result easy obtain precise models 
advances distributed component technologies ee corba distributed systems longer built scratch 
modern distributed applications integrate shelf legacy components services provided third parties real time market data provided reuters rely commercial databases manage persistent data 
built top middleware products referred middlewares software provides facilities services simplify distributed assembly components communication synchronisation threading load balancing facilities transaction security management services 
result trend class distributed applications considerable part implementation available architecture defined elaboration phase unified process 
argue enables performance testing successfully applied early stages 
main contribution description evaluation method testing performance distributed software early development stages 
method observation middleware build distributed application determines performance application 
example middlewares databases usually contain software transaction persistence management remote communication primitives threading policies great impact different aspects performance distributed systems 
note coupling middleware application architecture determines actual performance 
middleware may perform differently context different applications 
observations propose architecture designs derive application specific performance test cases executed early available middleware platform distributed application built 
argue allows empirical measurements performance successfully done early stages development process 
furthermore envision interesting set practical applications approach evaluation selection middleware specific applications evaluation selection shelf components empirical evaluation comparison possible architectural choices early configuration applications evaluation impact new components evolution existing applications 
structured follows 
section discusses related highlights original aspects research 
section gives details approach performance testing 
section reports results empirical evaluation main hypothesis research performance distributed application successfully measured early available components 
section discusses limitations approach sketches possible integration performance modelling techniques 
section summarises contributions sketches research agenda 

related section briefly review related areas performance testing distributed applications studies relationships software architecture middleware 
performance testing distributed applications authors exploited empirical testing studying performance middleware products 
liu compare performance different ee middlewares 
benchmark application stresses middleware infrastructure transaction directory services load balancing mechanisms 
comparison empirical measurement throughput increasing number clients 
similarly compare performance different orb object request broker implementations adhere corba component model 
liu investigate suitability micro benchmarks light weight test cases focused specific facilities middlewares directory service transaction management persistence security support 
suggests suitability empirical measurement middleware selection making decisions middleware best satisfy performance requirements distributed application 
liu rate application specific behaviour equations far results generalised different hardware platforms databases operating systems open problems research tackles problems 
study application specific test cases early performance evaluation comparing performance distributed applications specific deployment environments include middlewares databases operating systems shelf components 
weyuker report industrial experience testing performance distributed telecommunication application 
stress lack historical data usage target system architecture key identify software processes input parameters realistic representative values significantly influence performance 
extends consideration wider set distributed applications distributed component software general 
aim provide systematic approach test definition implementation deployment covered weyuker 
software architecture middleware medvidovic taylor state idea coupling modelling power software architectures implementation support provided middleware 
notice architectures middleware address similar problems large scale component development different stages development life cycle propose investigate possibility defining systematic mappings architectures middlewares 
study suitability particular element software architecture software connector 
medvidovic interesting taxonomy software connectors 
draw similar assumptions relationships architecture middleware research medvidovic different goals aim measuring performance attributes architecture early available implementation support middleware significant part medvidovic colleagues aim building implementation topologies bridging middlewares preserve properties original architecture 
results previous studies software connectors possibility mapping architectures middlewares may important engineering approach 

early testing performance section introduce approach early performance testing distributed component applications 
focus aspects problem need investigation 
long term goal realize software tool supports application approach describe 
approach comprises performance testing process consists phases 
selection case scenarios referred simply cases relevant performance set architecture designs 

mapping selected cases actual deployment technology platform 

generation stubs components available early stages development life cycle needed implement cases 

execution test turn includes deployment application test aut creation workload generators initialisation persistent data reporting performance measurements 
discuss research problems approach solving phases testing process 
selecting performance cases design test suites performance testing radically different case functional testing 
noticed authors 
performance testing functional details test cases actual values inputs generally little importance 
table classifies main parameters relevant performance testing distributed applications 
important concerns traditionally associated workloads physical resources number users frequencies inputs duration test characteristics disks network bandwidth number speed cpu 
important consider middleware configuration table reports parameters case ee middlewares 
comment workload physical resource middleware parameters extensively discussed literature 
important parameters performance testing distributed settings associated interactions distributed components resources 
different ways facilities services resources middlewares deployment environments correspond different performance results 
performance differ database accessed times 
middleware may perform adequately applications stress persistence quite badly transactions 
cases middlewares may perform badly different usage patterns service 
application specific cases performance relevant interactions specifically triggered aut covered 
row table classifies relevant interactions distributed settings take place middleware components components access persistent data database 
taxonomy far complete interactions distributed components map interactions take place middleware level elicited different abstraction level considered different category classification 
workload number clients client request frequency client request arrival rate duration test physical number speed cpu resources speed disks network bandwidth middleware thread pool size configuration database connection pool size application component cache size jvm heap size message queue buffer size message queue persistence application interactions middleware specific transaction management security service component replication component migration interactions components remote method calls asynchronous message deliveries interactions persistent data database accesses table performance parameters conducting studies empirical assessments direction 
believe taxonomy distributed interactions key approach 
taxonomy step definition appropriate metrics evaluate performance relevance available cases interactions trigger 
supports selection sets adequately represent performance target application enables definition reasonable distribution selected cases final workload basic principles synthetic workload modelling 
mapping cases middleware initial stages software process software architectures generally defined level 
just describe business logic details deployment platforms technologies 
expected strengths approach possibility driving software engineers intricate web architectural choices technologies deployment options keeping focus performance final product 
need understand cases mapped possible deployment technologies platforms 
example consider case fragment represents uml creation component type component issued client message create 
deployment case middleware map component enterprise java bean interactions shown 
message create client delivered component container part middleware 
middleware dispatch request actual component messages create post create sent respectively initialisation support structures middleware 
optionally client directory service provided middleware java naming directory interface retrieve component factory responsible creating furthermore ought specify transactional behaviour method execute context client transaction newly created nested transaction 
address mapping cases specific deployment technologies platforms intend leverage studies software connectors 
characterised software connectors may associated deployment topologies preserve properties original architecture 
possible implementation alternatives defined advance characteristics software connectors 
instance example define component creation connector provides properties case showed 
associate connector ee deployment topology list possible transaction behaviours 
deployment topologies alternatives vary different deployment technologies platforms 
previous studies software connectors precious direction needed understand dimensions species software connectors relationships possible deployment technologies platforms 
generating stubs far suggested early test cases performance derived instances architecture software connectors exploited means establish correspondence views provided cases concrete instances 
implement test cases solve problem application components participate cases available early stages development life cycle 
example components implement business logic seldom available participate cases 
approach uses stubs place missing components 
stubs fake versions components corresponding components instantiating cases 
approach stubs specifically adjusted cases different cases require different stubs component 
stubs take care distributed interactions happen specified components coherently exercised 
idea engineered approach needed stubs automatically generated information contained cases elaborations software connectors 
example referring component available stub implemented just able receive messages create actual middleware 
contain empty code methods create post create set corresponding transaction behaviour specified 
different case persistence instances corresponding interactions database specified case create component container lookup factory create create component post create case deployment view database calls far extracted case included method create case database early available component actual sql code stated interactions hard coded stub course functional details generally known implemented stub 
normally result discrepancies execution times stubs actual components simulate 
main hypothesis performance measurements presence stubs approximations actual performance final application 
descends observation available components middlewares databases embed software mainly impact performance 
coupling implementation support applicationspecific behaviour extracted cases implementation details business components remain negligible 
words expect discrepancies execution times stubs orders magnitude impact interactions facilitated middleware persistence technology databases 
report empirical assessment hypothesis section aware empirical studies needed 
executing test building support test execution shall involve technical scientific problems research questions stated answered 
part consists engineering activities selecting cases mapping deployment technologies platforms generating stubs replace missing components 
automate deployment implementation workload generators initialisation persistent data execution measurements reporting results 
relevant aspects research directly connected 

preliminary assessment section empirically evaluates core hypothesis research performance distributed application successfully tested middleware shelf components available early stages software process 
conducted experiment controlled environment 
considered sample distributed application implementation available 
selected case application implemented test case approach described section 
executed performance test different amounts application clients early available components compared results performance measured actual application 
experiment setting target application considered duke bank application ee tutorial 
application distributed sun public license able obtain full implementation easily 
duke bank application consists lines java code meant exemplify main features ee platform including transactions security 
consider duke bank application adequately representative medium size component distributed applications 
duke bank application referred remainder 
organisation borrowed 
application accessed web application clients 
consists ejb enterprise java beans components handle operations issued users bank 
components associated classes operations related bank accounts customers transactions respectively 
classes operations pair session bean entity bean provided 
session beans responsible interface users entity beans handle mapping stateful components underlying database table 
arrows represent possi web client ee application client session entity database beans beans table accounts controller customers controller transactions controller ejb container account bean customer bean transaction bean duke bank application accounts customers transactions ble interaction patterns components 
ejbs constitute business components deployed single container application server part middleware 
experiment jboss application server mysql database engine running machine 
selected sample case describes transfer funds bank accounts 
illustrates selected case uml 
client application uses service transfer provided 
service requires input parameters representing accounts amount money respectively involved transfer 
business components realize service database storing persistent data database invoked times updating balances accounts recording details corresponding transactions 
assume database engine software available early software process 
test database engine table structure sql code original application 
represented database shadowed box 
differently database business components assumed available generate corresponding stubs 
implementing stubs map transfer account account amount duke bank database update account update account log transaction account log transaction account sample case duke bank case selected deployment technology ee 
commented role software connectors may play mapping 
research mature exploit software connectors purpose 
presently just manually augmented case necessary information follows 
interaction clients specified service transfer invoked synchronous call starts new transaction 
interaction database specified invocations synchronous calls take place context single transaction embed available sql code database connection initialised call uses entity beans bean managed persistence handle interactions database tables 
information implemented stubs needed realize interactions considered case deployed test version referred jboss application server 
implemented workload generator initialised persistent data database 
workload generator able activate number clients time takes care measuring average response time 
persistent data instantiated case client withdraws money account exists bank account client deposits corresponding amount account third party supposed clients 
simulates recurrent case group people paying authority internet 
incidentally notice automated test environment initialisation persistent data require specify performance sensible part information actual values database tables generally little importance 
example case number elements table relationships case clients access different table row real concerns 
performance parameters table generated workload test increasing numbers clients starting 
applications deployed jboss application server running pc equipped pentium iii cpu ghz mb ram memory linux operating system 
generate workload run clients sun fire equipped sparc cpus mhz gb ram 
machines connected private local area network bandwidth mbit sec 
stubs geographical distances components actual application 
order avoid influences experiments caused contemporary existence lot active session beans restarted application may sound bad implementation choice preferred maintain policy original application avoid biases comparison 
entity beans ee components represent persistent data application 
database table associated entity bean 
data entity bean taken synchronised database 
case bean managed persistence synchronisation code embedded entity bean 
latency increasing numbers clients server successive experiments 
jboss running default configuration 
specific setting concerning particular case discussed previous paragraphs remote method calls components transaction management service order handle data shared various beans consistently 
experiment results executed increasing numbers clients measured latency test case 
repeated single experiment times measured average latency time 
shows results experiments 
plots latency time number clients repetitions experiment 
see curves near 
average difference accounts response time 
experiments showed low value standard deviation 
ratio expectation results fact definitively lower 
results experiment suggest viability research witness performance specific case approximated early available components 
results encouraging aware single experiment generalised 
working experiments cover large set alternatives component distributed applications 
plan experiment different cases sets cases test case different management schemas transactions performance different communication mechanisms asynchronous call ee application server jboss corba middlewares commercial databases presence early available components 

scope extensions results support possibility stubs application code real middleware database proposed application provide useful information performance distributed application 
particularly true enterprise information system applications distributed component technologies ee corba 
commented class distributed applications middleware generally responsible implementation support relevant performance mechanisms handling distributed communication synchronisation persistence data transactions load balancing threading policies 
cases critical contention resources bottlenecks happen middleware level execution time business components negligible 
approach allows providers class distributed applications test extent middleware may satisfy performance requirements application development 
respect approach may perform better pure benchmarking middlewares enables applicationspecific evaluation generates test cases take account specific needs particular business logic application architectures 
approach wider scope solely testing middleware 
generalised test components available development process example components acquired shelf third parties 
empirical measurements performance tuning architectures architectural choices may performed 
despite valuable benefits note approach identify performance problems due specific implementation late available components 
example final application going bottleneck business component development approach chance discover bottleneck exhibited stub component 
performance analysis models remain primary pursue evaluation performance cases 
currently studying possibility combining empirical testing performance modelling aiming increasing relative strengths approach 
rest section sketch basic idea integration 
problem applying performance analysis middleware distributed systems middleware general difficult represent analysis models 
instance consider case wants provide detailed performance analysis sample application section 
ought model interactions business components components processes middleware interact 
include limited component proxies marshal parameters remote method invocations transaction manager coordinates distributed transactions database connectivity driver facilitates interactions database processes automatic activation deactivation objects sample model components 
application simple structure derivation correspondent analysis model costly 
believe class issues addressed combining empirical testing performance modelling process 
analysis model built solved abstracting presence middleware 
resulting model generally simple structure 

empirical testing simulate results model frequency operations actual middleware computing execution middleware contention resources middleware affects performance characteristics modelled interactions response time operation may increase involves middleware execution 

model parameters tuned testing results 

process repeated model stabilises 
instance shows layered queuing network corresponding case 
detailed description models scope refer interested readers 
layers represent main interacting components client application database 
component may number copies threads 
white boxes represent services layer provides limited services interest considered case 
connections white boxes indicate client server relationships services arrows pointing servers 
specific case represented clients interact application service turn uses services database layer update accounts log transaction details 
important parameters model indicated include number calls service example database services twice considered case cpu cpu time service service thinking times 
middleware explicitly represented model involved execution service affects example ideal cpu time thinking time 
empirical measurements available parameters model tuned accordingly 
hand solving model compute frequency invocations service different numbers clients 
generate test cases middleware accordingly 
cost approach depends number iterations process 
expect models stabilise iterations 
experimental evidence missing required understand costs benefits integrated approach 

distributed component technologies enforce middleware commercial databases shelf components services 
software implements available initial stages software process generally embeds software structures mechanisms services impact performance distributed settings 
proposed exploit early availability software accomplish empirical measurement performance distributed applications architecture definition time 
best knowledge approach proposed novel software performance engineering 
fulfilled goals 
discussed published scientific works related positioning ideas current research landscape 
described novel approach performance testing selecting performance relevant cases architecture designs instantiating executing test cases early available software 
indicated important research directions engineering approach classification performance relevant distributed interactions base select architecture cases investigation software connectors mean instantiate actual deployment technologies platforms 
reported experiments show actual performance sample distributed application approximated measurements early available components supporting main hypothesis research 
identified scope approach proposed possible integration performance modelling techniques aimed relaxing limitations 
software performance testing distributed applications thoroughly investigated far 
reason believe testing techniques traditionally applied software process 
conversely critical performance faults injected early wrong architectural choices 
research tackles problem suggesting method class applications software performance tested early stages development 
long term far early evaluation middlewares concerned believe empirical testing may outperform performance estimation models precise easier 
envision application ideas set interesting practical cases middleware selection possibility evaluating selecting best middleware performance specific application reckoned important authors pointed section 
approach provides valuable support 
architecture designs allows measure compare performance specific application different middleware middleware technologies 
cots selection central assumption traditional testing techniques testers complete knowledge software test requirements execution environment 
case components shelf cots produced independently deployed environments known advance 
producers may fail identifying possible usage profiles component testing component isolation performed producers generally 
limited performance concerns approach allows test shelf components context specific application developed 
complement testing done cots providers assist selecting shelf components 
iterative development modern software processes prescribe iterative incremental development order control risks linked architectural choices see unified process 
applications incrementally developed number iterations 
iteration subset user requirements fully implemented 
results working slice application presently evaluated iteration extended cover part missing functionality 
iteration new architectural decisions generally impact evaluated respect current application slice 
performance concerns approach life cycle architecture established elaboration phase allows test expected performance new software architecture software initially available 
continuing experiments augmenting empirical evidence viability approach providing wider coverage possible alternatives componentbased distributed applications 
working engineering approach starting study research problems outlined 

authors james contribution preliminary definition research ideas 

inverardi 
approach performance evaluation software architectures 
proceedings international workshop software performance pages 

uml sequence diagrams statecharts petri nets models 
proceedings rd international workshop software performance wosp pages 
marchetti 
real time uml performance engineering aid manager decisions multi project planning 
proceedings rd international workshop software performance wosp pages new york july 
acm press 
ee tutorial 
addison wesley 
booch rumbaugh jacobson 
unified modeling language user guide 
addison wesley 
booch rumbaugh jacobson 
unified software development process 
addison wesley 
emmerich 
software engineering middleware roadmap 
finkelstein editor software engineering pages 
acm press 
emmerich 
distributed component technologies software engineering implications 
proceedings th international conference software engineering icse pages 
acm press 
liu 
software component quality assessment practice successes practical impediments 
proceedings th international conference software engineering icse pages new york 
acm press 
jacobson booch rumbaugh 
unified software development process 
addison wesley longman reading ma usa 
kao iyer 
user oriented synthetic workload generator 
th international conference distributed computing systems icdcs pages 
ieee computer society press june 

rational unified process 
addison wesley longman 
lin weyuker sai lai 
issues interoperability performance verification multi orb telecommunications environment 
proceedings international conference dependable systems networks dsn pages 
liu liu jiang chen 
designing test suite empirically middleware performance prediction 
international conference technology object oriented languages systems tools pacific sydney australia 
acs 
medvidovic taylor 
role middleware architecture software development 
international journal software engineering knowledge engineering 
mehta medvidovic 
taxonomy software connectors 
proceedings nd international conference software engineering icse pages 
acm press 

corba new components chapters 
technical report tc document ptc object management group 
mills 
top programming large systems 
editor debugging techniques large systems 
prentice hall 

architecture performance analysis applied telecommunication system 
ieee transactions software engineering 

uml derive process algebra models 
proceedings th uk performance engineering workshop pages 
rosenblum 
challenges exploiting architectural models software testing 
proceedings international workshop role software architecture testing analysis 
shannon 
java platform enterprise edition specification proposed final draft 
technical report sun microsystems 
emmerich 
model driven performance analysis enterprise information systems 
proc 
int 
workshop test analysis component systems warsaw poland volume april 

construction representative synthetic workload 
communications acm mar 

object driven performance testing web applications 
proceedings asia pacific conference quality software 
weyuker 
experience performance testing software systems issues approach case study 
ieee transactions software engineering 
