fly cycle collection revisited harel paz david bacon elliot kolodner erez petrank rajan counting garbage collector reclaim unreachable cyclic structures objects 
counting collectors backup tracing collector seldom employ cycle collectors reclaim cyclic structures 
fly cycle collector may run concurrently program threads bacon rajan 
demonstrated ability run fly counting resorting auxiliary tracing collector 
improved fly cycle collector combining techniques developed sliding views collectors 
resulting collector gains advantages 
improves ciency original collector significantly making cycle collection solution usable practice 
second eliminates termination problem appeared original algorithm 
rare race may delay reclamation unreachable cyclic structure forever 
new cycle collector guarantees reclamation unreachable cyclic structures 
categories subject descriptors programming languages processors memory management garbage collection 
general terms languages algorithms 
keywords runtime systems memory management garbage collection concurrent garbage collection fly garbage collection 
dept computer science technion israel institute technology haifa israel 
email cs technion ac il 
ibm research 
ibm research 
dept computer science technion israel institute technology haifa israel 
email erez cs technion ac il 
research supported bar nir software technology center excellence ibm faculty partnership award 
ibm research 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
copyright acm xxxxx xx xx xx 

counting classical garbage collection algorithm 
systems counting implemented starting sixties 
counting garbage collectors reclaim cyclic structures objects noticed 
counting collectors accompanied backup mark sweep collector run infrequently collect garbage cyclic structures cycle collector 
trying avoid developing maintaining additional mark sweep collector counting collected system attempts design cycle collector 
popular algorithm cycle collection proposed martinez 
algorithm performs local mark scan objects suspected belong garbage cycle avoids global tracing 
algorithm enhanced times modified fit fly counting collector bacon 
fly counting collector accompanying cycle collector collectors may reclaim unreachable objects concurrently program run 
fly garbage collection garbage collectors design single thread program threads stopped called world setting 
multiprocessor platforms desirable program perform collection single thread processor leads long pause times poor processor utilization 
concurrent collector runs concurrently program threads 
program threads may stopped short time initiate finish collection 
fly collector need program threads simultaneously initialization completion collection cycle 
study fly garbage collectors initiated steele dijkstra continued series papers :10.1.1.15.9106
advantage fly collector parallel collector types concurrent collectors avoids operation stopping program threads 
operation costly usually increases pause times 
today fly collectors typically achieve pauses short couple milliseconds 
challenge bacon rajan fly cycle collector main drawbacks practical problem theoretical 
typical cycle collector traces cycle candidates repeatedly discover cycles referenced pointers cycle 
crucial problem repeated scanning arises program threads allowed modify objects graph scan 
means scan really repeat objects graph scan equal objects graph scan 
furthermore modifications occur concurrently scan scans guaranteed view consistent snapshot objects graph specific point time 
problem source drawbacks previous algorithm practical theoretical drawback 
practical problem order achieve safety algorithm repeated scans candidates reduces ciency counting collector 
theoretical problem liveness guaranteed 
rare race condition may prevent unreachable cyclic structure reclaimed 
solution propose algorithm fly cycle collection solves drawbacks 
solution employs new techniques developed concurrent garbage collection :10.1.1.15.9106
main idea virtually fix graph processed cycle collector 
suppose stopped threads took replica heap snapshot 
running synchronous cient algorithm snapshot ciently detects cyclic structure 
course replica heap realistic 
virtual snapshot heap may taken ideas :10.1.1.15.9106
furthermore sliding view snapshot appropriate adjustment sliding view scan objects graph obtain fly cycle collector short pauses fly collectors :10.1.1.15.9106
suggest improvements synchronous algorithm making run faster 
theoretical liveness problem immediately solved 
unreachable cyclic structure generated program snapshot start interval sliding view read garbage cycle may easily identified view 
cycle collection executed top sliding view cycle guaranteed reclaimed 
incorporate new algorithm collector paz petrank 
algorithms perfect match 
cycle collector spends large fraction time working cycle candidates newly allocated objects 
age oriented collector building weak generational hypothesis uses tracing reclaim newly allocated objects counting rest objects 
eliminates large fraction cycles large fraction cycle collector run older objects 
implementation measurements discussion implemented new cycle collector levanoni petrank counting collector age oriented collector :10.1.1.15.9106
implementation done jikes java virtual machine original cycle collector bacon rajan implemented 
measure ectiveness cycle collector compared featured original cycle collector showing number traced objects substantially reduced 
comparing throughput irrelevant case built di erent counting collectors see 
provide comparison cycle collection backup tracing collector 
comparison interesting main options provided implementer counting algorithm 
measurements contain comparison run times jvm uses cycle collector jvm uses backup tracing collector collect unreachable cyclic structures 
specjbb benchmark specjvm benchmark suites 
benchmarks described detail spec web site 
turns cycle collection falls backup tracing collector application throughput 
small cost allows pure counting adding backup tracing collector 
direction modern computing believe cycle collector may ective comparing backup tracing collector 
counting currently inferior tracing respect throughput modern benchmarks 
heaps grow larger possible counting start winning 
tracing trace live objects heap counting needs account counts updates reclaiming dead objects 
heap tight collections frequent counting winning tracing heap 
benchmarks large live heap updates young objects counting may best collector 
happens companion cycle collector required 
case cycle collector may excellent companion expect outperform backup tracing collector 
interestingly cycle collector age oriented collector performed backup tracing collector 
turns young objects spared cycle collector highly cient 
detailed measurements provided section 
sequel assume reader familiar memory management standard terminology algorithms 
detailed garbage collection memory management reader referred 
organization start overview previous collectors section 
new cycle collector employs techniques collectors described section 
overview new cycle collector provides section 
implementation results section 
related discussed section conclude section 
section review relevant previous 
algorithmic ideas section describe new collector section 
start reviewing synchronous algorithms cycle collection uniprocessor review previous concurrent cycle collector 
explain ideas sliding views counting tracing garbage col aid overcoming disadvantages state art cycle collectors 
collecting cycles uniprocessor algorithm observations 
observation garbage cycles created count decremented non zero value 
second observation garbage cycle counts internal pointers cycle nodes reside cycle nodes 
internal subtracted counts counts nodes garbage cycle zero unreachable cycle identified 
incorporation cycle collector counting collector follows 
unreachable objects reclaimed count decremented zero 
reclaim cycles counting algorithm detects candidate unreachable cyclic structures runs cycle collector 
specifically count object decremented value di erent zero cycle collector described applied objects reachable general idea cycle collection algorithm perform traversals graph objects reachable candidate object traversals update counts reflect pointers external cycle 
reclaims objects count decremented zero restores counts surviving objects 
traversing objects algorithm uses colors mark state objects 
initial color object black signifying object active possible member garbage cycle represented gray color object marked white member garbage cycle 
algorithm candidate object count decremented non zero value works stages mark stage traces graph objects reachable subtracting counts due internal marking nodes possible garbage coloring gray 
traversal counts sub graph reflect external pointers nodes sub graph 
scan stage scan sub graph objects reachable restores counts objects reachable external pointers 
reachable nodes re colored black 
nodes sub graph objects remain zero counts colored white objects identified forming garbage cycle 
collect stage scan sub graph reclaim garbage white objects 
increase ciency invoking cycle collector time new candidate object detected algorithm lazily applied 
traversals postponed saving values deleted pointers bu er 
value candidate root garbage cycle 
suitable point bu er objects traversed 
benefit obtained laziness time bu er traversed indication value stored bu er garbage 
bu er values irrelevant time bu er traversed count drops zero deleted incremented 
lazy treatment candidates prevents re traversals object 
summarize delaying traversal decreases number candidates traversed 
additional important ciency improvement proposed run scans candidates simultaneously applying algorithm candidate separately 
strategy achieves practical ciency improvement reduces theoretical worst case complexity stands transitive closure candidates 
collecting cycles fly concurrent cycle collection algorithm complex 
deal fact object graph may modified collector scanning 
problem concerns accuracy counts may outdated due mutator activity 
bacon rajan designed implemented concurrent cycle collection algorithm building extending synchronous algorithm described 
object graph may modified cycle collection algorithm scans rely repeated traversal graph reading set nodes edges 
algorithm consists phases 
phase variant synchronous algorithm obtain candidate set nodes believed garbage cycles 
run variant stages algorithm collecting white nodes nodes added set possible garbage nodes 
due concurrent mutator activity algorithm may produce incorrect results 
particular presence concurrent mutator activity cause live nodes included set candidates cycles 
second phase required prevent collection false cycles 
second phase executed garbage collection 
phase candidate cycle detected previous phase tested information available time ensure garbage cycle 
candidate cycles reclaimed 
synchronous algorithm mark stage subtracts counts traced objects scan stage increments counts objects belong garbage cycles algorithm terminates object holds exact count 
concurrent collector rely repeated traversal graph form set nodes edges possible certify second traversal scan stage restore original count object correctly 
solve issue algorithm modify actual count field object 
second count field kept object denoted crc cyclic count cycle collection algorithm 
mark stage algorithm initializes crc black object reached count 
stages mark scan collect stages operate solely crc living count field unmodified 
need restored 
disadvantages concurrent garbage collector poses drawbacks 
theoretical practical 
drawbacks initiated solves resulting cient non intrusive live collector 
describe drawbacks starting theoretical 
garbage collector called live eventually collects reachable objects 
rare race conditions may prevent cycle collector collecting garbage cycles 
example garbage cycle collected follows 
output phase set candidate cycles 
candidate cycle set nodes may form garbage cycle 
due mutator activity candidate cycle may include actual garbage cycle additional live nodes 
candidate cycle bound fail tests second phase collection 
happens algorithm reconstructs candidate cycle chosen node cycle 
similar race condition occurs reconstructed set nodes may contain live modes 
course events may prevent algorithm collecting garbage cycle matter collections run 
sum collector guarantee collecting unreachable objects 
turn practical problem 
objects graph modified program activity cycle collector care need taken ensure safety collection 
extra care translated scanning objects substantial reduction efficiency 
example algorithm colors objects concurrently execution mutators 
possible mutators eliminate cause arbitrary set gray white objects invisible collector scan 
improperly colored object may fool naive algorithm making incorrect 
concurrent algorithm handles problem adding action increment decrement count 
particular count gray white object changed object objects reachable gray white colored black 
excessive scanning objects pose ciency problem 
number objects scanned reported high 
incorporating sliding views explained section disadvantages concurrent cycle collector 
reduced ciency due repeated scanning objects inability collector guarantee liveness 
problems stem fact concurrent cycle collector rely able re trace graph 
modified cycle collection algorithm extends techniques adds developed techniques 
idea snapshot heap sliding view heap :10.1.1.15.9106
fixed view heap reflected snapshot sliding views mechanism possible eliminate redundant tracing guarantee liveness 
describing new algorithm provide overview sliding views counting collector 
simple version levanoni petrank collector may described allowing point time collection mutators halted 
halt possible get virtual snapshot heap copy write mechanism 
object associated dirty bit cleared halt 
pointer modified dirty bit object holding probed 
object dirty copied previously pointer assignment may proceed action 
object copied local bu er assignment executed 
allows counting tracing collector access view heap snapshot taken initial halt objects dirty may read heap find values equal existing initial halt dirty objects replica designated bu ers actual values initial halt 
deal multithreaded programs carefully designed write barrier allowing write barrier operate concurrent threads synchronization :10.1.1.15.9106
noted non null recorded object fields read collector updates newly created objects need monitored 
collector updates counts due values modified pointers previous snapshot current :10.1.1.15.9106
observed pointer updates necessary buys substantial reduction number required updates 
details may original :10.1.1.15.9106
algorithm described far probably obtains short pause times order get shorter pause times sliding view mechanism proposed 
program threads halted simultaneously time 
snapshot view assumed anymore correctness considerations dictate snooping mechanism 
time mutators halted snooping mechanism operates modified pointer write barrier 
modified object acquired new logged 
logged objects considered roots current collection reclaimed 
view heap collector may thought sliding view heap objects viewed view slightly di erent points time 
snooping mechanism sure reachable object reclaimed 
details appear :10.1.1.15.9106

cycle collector overview section describe new cycle collector 
collector details omitted lack space 
full details measurements appear technical report 
mentioned adding sliding views techniques state art cycle collector achieves synergy solving disadvantages previous cycle collector yielding non intrusive cient cycle collector guarantees liveness 
start describing new cycle collection algorithm assuming snapshot heap 
main idea applying synchronous algorithm snapshot heap correctly identifies garbage cycles heap viewed snapshot 
combining fact synchronous algorithm cient fact garbage cycles stable property program activity unreachable object reach able get cient identification garbage cycles 
suggest improvements obtained algorithm improve cycle collector 
main operation synchronous cycle collector heap traversing sub graph 
concentrate specifying traverse heap snapshot 
ideas similar 
need traverse object pointer values existed snapshot time necessarily currently existing heap 
employ write barrier :10.1.1.15.9106
examining object scanned collector examines dirty bit object 
object dirty pointer object modified snapshot taken current state equal state snapshot may trace reading heap 
object modified snapshot time marked dirty 
case trace snapshot values recorded threads local bu ers 
way objects traced state snapshot time consequence multiple traces bounded trace graph time 
terms liveness means garbage cycle created exist snapshot bounded collected synchronous algorithm 
terms ciency means may cient synchronous algorithm get rid ine ciencies originating need insure correctness spite program collector races 
example need save identified garbage cycles validated garbage collection discussed section need go cycles collection 
proceed sliding views snapshots removing need simultaneous halt program threads 
cycle collector remains reads sliding view graph snapshot 
previous sliding views collectors sliding view may find object unreachable view represent heap consistent point time 
snooping mechanism see section sure objects reclaimed ensuring safety property 
cycle collector means set objects may incorrectly identified unreachable cyclic structure 
happen inaccuracies counts due sliding view discussed 
intuitively pointer written heap collection mutators halted sliding view represents snapshot heap taken time mutator stopped denote time pointers written heap snapshot gets distorted 
distortion appears respect modified pointers may replace pointers existing time modified pointer creates falsely determined unreachable garbage cycle particular means pointer implying reachability objects cycle missing sliding view heap 
case guaranteed object falsely unreachable sliding view snooped reclaim cyclic structure contains 
safety cycle collector may reduced safety tracing collector 
respect liveness holds unreachable cyclic structure formed collection begins collected 
reason objects modified time sliding view taken particular new pointers written objects cycle 
objects cyclic structure snooped view pointers objects appears sliding view exactly appeared taken real snapshot time unreachable cyclic structure reclaimed 
cycle candidates previous cycle collection algorithms candidate member unreachable cycle object count decremented non zero value 
possible levanoni petrank write barrier eliminates redundant count updates see section 
pointer takes values 
sliding views required count updates decrement rc increment rc 
fact increments decrements objects 
executed prevent noting decrements creates new unreachable cycle 
turns old objects created sliding view problem 
reason unreachable cyclic structure created assigning pointer objects changing cycle reachable previous sliding view unreachable pointer referenced object cycle previous sliding view modified time sliding views 
change pointer logged mutation bu er decrement count object previously referenced executed 
point object candidate cycle collection 
young objects problem 
may fail notice collect candidate cycle comprising solely young objects objects created collection 
consider scenario occurring garbage collections new objects created pointers form cycle 
note changing pointers create logging operation 
new objects known point nulls previous collection logged 
old object modified point local pointers objects erased 
updated may cause old object previous descendants logged mutation log notation 
pointer overwritten leaving cycle unreachable 
second update object logged 
objects count noticed cycle collection decrement unnoticed 
solve problem consider young objects candidates garbage cycle 
doing covers possible cycles contain young object 
explained cycles containing old objects accounted properly 
garbage cycles properly noticed 
note weak generational hypothesis objects short lifetimes expect get false candidates considered 
objects reclaimed counting collector remaining candidates cycle collection 
summarize levanoni petrank write barrier consider object count decremented non zero value young object candidate 
age oriented collector measurements show cycle collector spends substantial fraction time checking cycle candidates newly allocated objects 
alternative collector problem age oriented collector 
age oriented collector fly collector uses tracing reclaim young objects counting old objects 
collector turns perfect match algorithm 
eliminates large fraction cycles large fraction cycle collector need consider young objects candidates 
incorporated cycle collector age oriented collector provide measurements resulting collector standard counting collector 
reducing number traced objects ectiveness cycle collection algorithm heavily depends number objects traced cycle collector 
finding strategies reduce number objects traced important algorithm performance 
idea reduce number objects candidate roots garbage cycles 
algorithm applies strategies 
new 
techniques reducing objects tracing employed previous collectors mentioned 
idea record values candidates bu er hoping time identified non candidates example reclaimed counting collector 
second idea performs stages mark scan collect entirety candidates simultaneously 
strategy eliminating candidates introduced concerns acyclic object 
objects inherently acyclic part cycle array scalars 
objects statistically determined 
acyclic objects considered candidates roots algorithm 
acyclic object reached algorithm traversals ignored 
usually considerable portions objects acyclic majority ignoring acyclic objects significantly reduces overhead cycle collection 
reported combination candidate filtering strategies highly ective reducing number possible candidates factor reducing worst case algorithm complexity quadratic linear 
measurement show small percentage non filtered candidates belong garbage cycles 
feel filtering techniques key component improving ciency cycle collection algorithms propose couple additional elimination strategies reduce number candidates number objects traced candidates traversal 
cycle collector bacon rajan triggered fixed number garbage collections earlier collection candidates bu er exceeded threshold size 
new collector runs cycle collection garbage collection 
candidates mature testing membership unreachable cyclic structure 
discussed candidates wait checked reclaimed may removed candidate list 
strategy check candidates accumulated collections ago filtered 
having large candidates bu er employ smaller candidates bu ers containing candidates accumulated di erent collections current collection check oldest bu er 
object added current candidates bu er removed older bu er recorded 
removal executed short processing bu ers collection 
note structured way candidates mature 
run cycle collector collections candidates run candidates discovered matured 
employing new strategy trace candidates filtered died collections 
note objects known alive current collection 
includes objects directly reachable roots objects snooped objects dirty modified sliding view taken 
addition objects currently held candidates newer candidate bu ers 
objects get special treatment trace 
particular cycle collector scans object mark stage ignores black need mark gray trace gray need decrement crc 
addition live object reached scan phase modified colored gray object colored black black descendants 
save scanning time add small additional stage mark phase scan phase 
scan stage may color white object sub graph find stage object referenced gray object externally referenced 
situation object sub graph colored black second traversal scan stage 
repeated traversals saved start coloring black externally referenced objects subgraph color white rest 
find externally referenced objects may approximate list collected mark phase includes objects encountered known alive modified object snooped object object directly referenced system roots candidate located newer candidate bu er 
running mark phase starting scan phase color descendants black 
disadvantage filtering additional crc field asynchronous cycle collector bacon rajan 
see section explanations crc field 
reason set live objects subset dirty objects fixed algorithm 
safe trace sub graphs trace clear eliminate tracing stages proceed 
necessitates crc field 
possible avoid avoid dirty bit identify living objects 

implementation results implemented algorithm jikes java virtual machine linux red hat 
entire system including collector written java extended unsafe primitives available java virtual machine implementation access raw memory 
jikes uses safe points interrupting threads asynchronous signals thread periodically checks bit condition register indicates runtime system wishes gain control 
design significantly simplifies implementing handshakes garbage collection 
addition implementing java threads operating system threads jikes multiplexes java threads virtual processors implemented operating system threads 
jikes establishes virtual processor physical processor 
platform benchmarks 
run measurements way ibm server mhz intel pentium iii xeon processor gb physical memory 
benchmarks specjvm benchmark suite specjbb benchmark 
benchmarks described detail spec web site 
feel multithreaded specjbb benchmark interesting specjvm appropriate clients algorithm targeted servers 
feel dire need academic research multithreaded benchmarks 
see example specjbb representative large multithreaded applications 
testing procedure 
benchmark suite test harness performing standard automated runs benchmarks suite 
standard automated run runs benchmark times jvm involved implementing di erent collector 
understand better behavior collector tight relaxed conditions tested varying heap sizes 
specjvm suite started mb heap size extended sizes mb increments final large size mb 
specjbb larger heaps starting mb heap size extending mb increments final large size mb 
compared collectors 
incorporated cycle collection algorithm collector counting collector collector :10.1.1.15.9106
collectors implemented jikes accompanied backup mark sweep collector run infrequently collect garbage cycles 
performance measurements ran collectors accompanied cycle collection algorithm collectors backup mark sweep algorithm 
addition compared characteristics cycle collection algorithm collectors characteristics previous fly cycle collector bacon rajan 
server performance major benchmark specjbb benchmark 
specjbb requires multi phased run increasing number warehouses 
phase lasts minutes ramp period half minute phase 
benchmark provides measure throughput report throughput ratio improvement applied proposed cycle collection algorithm compared collector backup mark sweep algorithm higher ratio better algorithm behaves particular ratio larger implies cycle collector outperforms tracing auxiliary collector 
stress specjbb benchmark produces garbage cycles dozens objects turn cyclic garbage 
collector gets minor benefit applying algorithm specjbb benchmark su ering overhead produces collection 
note applying mark sweep algorithm produce special overhead applied infrequently original collector add 
specjbb serve measuring overhead algorithm produces applied program produce cycles 
measurements reported varying number warehouses varying heap sizes 
measurements cycle collector levanoni petrank counting collector 
behavior algorithm separated cases 
case warehouses 
case machine processors fly compared collectors run spare processor 
setting collectors handle mutators running handshakes collectors achieve throughput share similar allocator get warehouses 
warehouses backup mark sweep collector performs better usually 
reason collector releasing space fast allocations 
program delayed waiting collector finish 
expected overhead algorithm noticeable tight heaps collections run frequently 
second case refers warehouses collectors run spare processor share processor program threads 
note gave collector case highest priority collection triggered collector gets dedicated processor 
number warehouses ciency collector important collector able handle mutators running collector cient collection consume time letting mutators larger fraction fourth processor increasing throughput 
warehouses results show warehouses backup mark sweep collector performs better usually 
tighter heaps collector ciency significant overhead cycle collector larger 
measurements run collector 
results 
cycle collector age oriented collector large fraction cycle collector eliminated newly allocated objects considered cycle heap size mb jbb warehouses counting warehouse warehouses warehouses heap size mb jbb warehouses counting warehouses warehouses warehouses warehouses warehouses specjbb multiprocessor throughput ratio levanoni petrank collector heap size mb jbb warehouses age oriented warehouse warehouses warehouses heap size mb jbb warehouses age oriented warehouses warehouses warehouses warehouses warehouses specjbb multiprocessor throughput ratio age oriented collector candidates 
measurements show achieve similar performance achieved backup mark sweep algorithm 
age oriented collector accompanied cycle collector able handle mutators running collection time hardly ected added cycle collection activity 
measurements appear technical report 
client performance cycle collection algorithm targeted servers running smp platforms sanity check measured performance collector backup mark sweep algorithm uniprocessor 
behavior collector uniprocessor may demonstrate ciency 
measured cycle collection algorithm uniprocessor specjvm benchmark suite results appear 
counting collector incorporation cycle collector usually incorporation backup tracing collector 
age oriented collector cycle collector performs similarly backup mark sweep collector 
bad exception encountered javac benchmark produces hundreds thousands objects garbage cycles 
dealing objects time consuming 
collector characteristics amount tracing new strategies suggested reduce number candidates number objects traced order reduce overhead introduced cycle collection algorithm 
measured effectiveness strategies measuring reduction number candidate objects traced objects 
report ratio candidates traced objects traced compared 
note measure number objects traced 
original algorithm objects processed verify safety 
processing included measurements traced object 
new algorithm run extra processing saving new algorithm better conservatively measured figures 
graphs lower ratio better algorithm behaves ratio smaller implies traced candidates objects 
measured algorithm counting collector denote rc age oriented collector denote ao 
collector characteristics measured candidates bu ers 
case implication candidates gathered current collection considered collection delay collection cycle handling collected candidates 
case delay collections 
denote cases delay delay 
measured algorithm configurations depending delay underlying collector 
results number traced candidates objects introduced 
may see heap size mb specjvm uniprocessor counting jess db javac mtrt jack heap size mb specjvm uniprocessor age oriented compress jess db javac mtrt jack specjvm uniprocessor throughput ratio 
jess db javac mtrt jack jbb benchmarks candidates roots ratio compared bacon rajan candidates traced ratio rc delay rc delay ao delay ao delay jess db javac mtrt jack jbb benchmarks objects traced ratio compared bacon rajan objects traced ratio rc delay rc delay ao delay ao delay specjbb saving tracing number candidates 
rations trace candidates compared previous cycle collector benchmarks 
checking objects traced new cycle collector traces substantially objects case mtrt benchmark counting configurations 
superiority age oriented configurations counting configurations clear demonstrates saved having collect cycles young object having consider young objects candidates 
bu ers algorithm traces bu ers means delaying handling candidate traversal may spared 
measuring benchmarks throughput cases clear throughput superiority 
due fact handling candidates bu er filtering candidates collection consumes time 
tune number candidates bu ers collector collection triggering policy 
collectors candidates bu ers usually collectors frequent collections believe bu ers improve ciency 

related traditional method counting applicable realm developed lisp collins 
simplest form allowed immediate reclamation garbage localized manner notable overhead maintaining space semantics counters 
weizenbaum showed delay introduced recursive deletion non constant delay caused classic counting ameliorated distributing deletion object creation operations 
deutsch bobrow eliminated computational overhead required adjust counters method deferred counting 
method local counted need track fetches local pointer duplication cancellation deemed unnecessary 
stores heap need tracked 
immediacy counting lost certain extent garbage may reclaimed mutator state scanned 
bacon levanoni petrank extended counting algorithm running concurrently program threads :10.1.1.15.9106
achieve extremely low pauses times ms 
inability counting reclaim cyclic garbage structures noticed 
christopher developed algorithm primary method counting tracing collector called periodically reclaim nodes heap non zero counts externally reachable 
algorithm martinez reclaims cells uniquely referenced count drops zero pointer shared object deleted local depth search applied 
search subtracts counts due internal pointers 
collection objects zero counts garbage cycle collected 
lins extended algorithm post traversals saving values deleted pointer bu er value candidate root garbage cycle traversing bu er suitable point 
delaying traversal decreases number actual candidates traversals bu er values irrelevant time bu er traversed counts drop zero incremented 
bacon extended lins algorithm concurrent cycle collection algorithm 
improved lins algorithm performing tracing candidates simultaneously reducing number traced objects 

new cycle collector counting fly combining techniques sliding views collectors fly cycle collector 
gain ciency simplicity running simpler synchronous cycle collector bacon rajan sliding views heap 
eliminates previously required ensure correctness running concurrently program 
addition add filtering techniques manage filter large fraction cycle candidates 
resulting collector cient cycle collector retains short pauses onthe fly counting collectors 
new collector guaranteed reclaim garbage cycles previous fly collector extremely rare sequence events prevents collecting unreachable cyclic structure forever 
provide direct comparison running cycle collector running backup tracing collector 
current benchmarks backup tracing collector small advantage 
expect counting win large heaps accompanying cycle collector required 
provides companion cycle collector 
incorporating new cycle collector age oriented collector save collecting young generation cycles cycle collector performs equally backup tracing collector 

ram initiated discussion problem suggesting algorithms strongly connected components ciently locate garbage cycles 
attempts follow direction failed evolved 
ram interesting discussions 

bowen alpern attanasio anthony cocchi derek lieber stephen smith ton ngo john barton susan flynn hummel janice mark mergen 
implementing jalapeno java 
oopsla acm conference object oriented systems languages applications volume acm sigplan notices pages denver october 
acm press 
yossi levanoni harel paz petrank 
fly mark sweep garbage collector sliding view 
oopsla acm conference object oriented systems languages applications acm sigplan notices anaheim ca november 
acm press 
david bacon clement attanasio han lee rajan stephen smith 
java ee breaks nonintrusive multiprocessor garbage collector 
proceedings sigplan conference programming languages design implementation acm sigplan notices snowbird utah june 
acm press 
david bacon rajan 
concurrent cycle collection counted systems 
knudsen editor proceedings th european conference object oriented programming ecoop volume springer verlag budapest june 
springer verlag 
henry baker 
list processing real time serial computer 
communications acm 
ai laboratory working 
ben ari 
fly garbage collection new algorithms inspired program proofs 
nielsen schmidt editors automata languages programming 
ninth colloquium pages aarhus denmark july 
springer verlag 
ben ari 
algorithms fly garbage collection 
acm transactions programming languages systems july 
daniel bobrow 
managing re entrant structures counts 
acm transactions programming languages systems july 
hans juergen boehm alan demers scott shenker 
parallel garbage collection 
acm sigplan notices 
christopher 
count garbage collection 
software practice experience june 
george collins 
method overlapping erasure lists 
communications acm december 
peter deutsch daniel bobrow 
cient incremental automatic garbage collector 
communications acm september 
dijkstra leslie lamport martin scholten ste ens 
fly garbage collection exercise cooperation 
communications acm november 
damien doligez georges gonthier 
portable unobtrusive garbage collection multiprocessor systems 
conference record annual acm symposium principles programming languages acm sigplan notices 
acm press january 
damien doligez xavier leroy 
concurrent generational garbage collector multi threaded implementation ml 
conference record twentieth annual acm symposium principles programming languages acm sigplan notices pages 
acm press january 
elliot kolodner erez petrank 
generational fly garbage collector java 
proceedings sigplan conference programming languages design implementation acm sigplan notices vancouver june 
acm press 
elliot kolodner ethan lewis elliot katherine itai erez petrank igor yossi levanoni 
implementing fly garbage collector java 
hosking 
john ellis kai li andrew appel 
real time concurrent collection stock multiprocessors 
technical report dec src tr dec systems research center palo alto ca february 
david gries 
exercise proving parallel programs correct 
communications acm december 
tony hosking editor 
ismm proceedings second international symposium memory management volume acm sigplan notices minneapolis mn october 
acm press 
richard jones 
garbage collection algorithms automatic dynamic memory management 
wiley july 
chapter distributed garbage collection lins 
kung song 
cient parallel garbage collection system correctness proof 
ieee symposium foundations computer science pages 
ieee press 
leslie lamport 
garbage collection multiple processes exercise parallelism 
proceedings international conference parallel processing pages 
yossi levanoni erez petrank 
scalable counting garbage collector 
technical report cs technion israel institute technology haifa israel november 
yossi levanoni erez petrank :10.1.1.15.9106
fly counting garbage collector java 
oopsla acm conference object oriented systems languages applications volume acm sigplan notices tampa fl october 
acm press 
rafael lins 
cyclic counting lazy mark scan 
information processing letters 
computing laboratory technical report university kent july 
martinez rafael lins 
cyclic counting local mark scan 
information processing letters 
harold 
counter method 
communications acm september 
david moon 
garbage collection large lisp system 
guy steele editor conference record acm symposium lisp functional programming pages austin tx august 
acm press 
harel paz david bacon elliot kolodner erez petrank rajan 
fly cycle collection revisited 
technical report cs technion israel institute technology november 
harel paz erez petrank 
age oriented garbage collection 
technical report cs technion israel institute technology october 
tony david detlefs 
generational concurrent garbage collector 
hosking 
spec benchmarks 
standard performance evaluation 
www spec org 
guy steele 
multiprocessing garbage collection 
communications acm september 
guy steele 
corrigendum multiprocessing garbage collection 
communications acm june 
weizenbaum 
symmetric list processor 
communications acm september 
