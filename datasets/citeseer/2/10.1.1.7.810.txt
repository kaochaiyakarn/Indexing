hardness aware restart policies ruan university washington seattle wa ruan cs washington edu henry kautz university washington seattle wa kautz cs washington edu eric horvitz microsoft research redmond wa horvitz microsoft com demonstrated possible boost efficiency combinatorial search procedures principled restart policies 
coupling machine learning dynamic programming extends prior efforts endowing restart policies knowledge hardness specific instance solved 
ability allows restart policy take consideration updated probability distribution hardness previously unseen instance solved 
discuss methods highlighting importance real world applications combinatorial search 
empirical results 
key observation decade procedures solving difficult combinatorial search problems show great variance running time 
large variance run time significant obstacle creating real time reasoning systems numerous challenging domains 
pursuit fast robust search algorithms investigators targeted uncertainty run time directly techniques including restarts algorithm portfolios :10.1.1.112.8065
describe new methods complement efforts developing sound probabilistic restart policies :10.1.1.4.5961
earlier centered machine learning inform reasoner probability distribution time required solve particular run instance drawn source distribution ensemble 
efforts predictive modeling date addressed challenges handling great variation hardness different instances captured example median run time required solve instance derived solving instance multiple times 
developing means recognizing hardness specific instances important real world scenario committing solution particular instance seen 
attack problem directly developing new machinery allows solver continue update beliefs hardness specific instance solved conditioning information gathered repeated restarts 
shall summarize prior restart policies 
new methods clustering ensemble instances sub ensembles decrease hardness variation sub ensembles 
creation instance sub ensembles enables system learn reason probability distribution hardness specific instance hand 
review dynamic programming approach identifying ideal restart policies consideration likelihood different :10.1.1.4.5961
describe experiments performed test methods 
discuss research opportunities 
research restart policies run time backtracking heuristic search algorithms notoriously unpredictable 
gomes demonstrated effectiveness randomized restarts variety problems scheduling theorem proving planning 
approach randomness added branching heuristic systematic search algorithm search algorithm find solution number backtracks referred cutoff algorithm restarted new random seed 
luby described restart policies stochastic process scenarios runtime observable run random sample known distribution calculate fixed optimal cutoff ii knowledge distribution universal schedule mixing short longer cutoffs comes log factor minimal run time 
horvitz showed possible better luby fixed optimal policy making observations variety features related nature progress problem solving early portion run referred observation horizon learning bayesian model predict length run 
assumption run independent random sample runtime distribution rtd observations discriminate potentially short runs long ones adopted different restart cutoffs types runs 
ruan considered case known distributions run sample distributions solver told distribution :10.1.1.4.5961:10.1.1.4.5961
showed offline dynamic programming generate optimal restart policy policy coupled real time observations control restarting 
scenarios taken simplified versions real world situation distribution corresponds heterogeneous ensemble instances problem instance run 
analysis real world scenario requires machinery relates rtd ensemble rtd individual instances randomized solver 
addresses challenge creating techniques tackling real world scenario 
method steps follows 
collecting data 
training instances randomly sampled ensemble instances training instance solved times randomized solver obtain rtd 
start run collect set features learning decision classifies instances sub ensembles observed features 

partitioning ensembles 
partition training instances instances sub ensembles similar rtd employ machine learning build predictive model provides probability distribution parent sub ensemble instance 

constructing restart policies 
compose optimal restart policy harnessing offline dynamic programming approach :10.1.1.4.5961
shall see policies require simple combination optimal cutoffs rtd undertook set experiments 
building partitions composing ideal hardness aware restart polices sample new set instances ensemble test efficacy constructed restart policies 
variability problem hardness problem solving scenarios involve solving instances drawn distribution problems mixed hardness sampled problem solved 
proven extremely difficult practice define realistic problem ensembles instances vary widely hardness 
different instances widely varying rtd widely varying optimal fixed cutoffs known random sat problem ensembles fixed clause variable ratios 
mse number sub distribution left reduction variability mse sub ensembles number sub ensembles colorable graph coloring problem gcp 
axis represents number sub ensembles axis represents average mean squared error mse measurement variability cluster 
right differences rtd sub ensembles ensemble 
axis length run axis probability run finishing steps 
middle curve rtd ensemble upper curve rtd easy sub ensemble lower curve rtd hard sub ensemble 
ideally instances ensemble run time distribution variability ensemble problem finding optimal restart policy newly instance ensemble collapses problem finding luby optimal cutoff run time distribution ensemble 
practice typical see high variability intrinsic hardness instances ensemble 
prior quasigroup holes demonstrated variability hardness instances size square number holes order magnitude 
high variability hardness remains problem impose finer grained properties ensemble 
example see great variation time solving instances consider instances show balanced hole pattern 
similar observation domains combinatorial auctions 
high variability hardness instances infeasible adopt fixed cutoff restart policy 
cutoff set low hard instances may little chance solved 
hand cutoff set high may waste time multiple runs 
candidate restart policy luby universal policy 
experimental results show policy relatively inefficient 
approach problem high variability run time decomposing ensemble mixture ensembles 
seek divide mixture sub ensembles variability hardness sub ensemble significantly reduced rtd sub ensemble reasonable approximation rtd instances sub ensemble 
partition problem ensemble hardness divide ensemble sub ensembles hardness different ways 
focused approaches segmenting ensemble sub ensembles median run times instances clustering instances euclidean distances run time distributions 
median partition ensembles median approach decompose mixture ensembles methods consider median run times instances observed multiple runs 
employed straightforward approach segmenting instances instances median run times certain ranges clustered sub ensemble ranges divided sub ensembles equal numbers instances 
mean squared error mse measure variability ensemble sub ensemble 
mse median median median median median run times instance ensemble respectively number instances ensemble 
distribution partition ensembles approach creating sub distributions take consideration measure euclidean distance run time distributions different instances 
define euclidean distance run time distributions instance qi qj qi pi cumulative function pi probability run exactly instance number data points potentially useful measure difference probability distributions run time kullback leibler distance relative entropy formulation 
distance asymmetric measure distance observe triangular equality 
definition distance requires case probability distribution zero satisfied experimental data 
experiments mean squared error mse measure variability ensemble sub ensemble employ means clustering algorithm minimize variability sub ensemble mse euclidean distance run time distributions instance ensemble number instances ensemble 
sample results partitioning wish partition ensembles sub ensembles hardness produce small variability run time 
example variability represented mean squared error sub ensembles changes number sub ensembles display left side fig 
results distribution partition method colorable graph coloring problem gcp 
graph shows variability sub ensembles decreases rapidly increasing number sub ensembles 
experiments partitioning ensemble modest number sub ensembles significantly reduced variance run time 
right side fig 
displays example differences run time distributions sub ensembles ensemble colorable graph coloring problem 
upper curve rtd easy sub ensemble middle curve rtd ensemble lower curve rtd hard sub ensemble 
generating restart policies dynamic programming dynamic programming approach described particularly interesting study apply straightforward manner construct restart policies sub ensembles :10.1.1.4.5961
shall review dynamic programming solution framework sub ensembles partitioned hardness 
denote run time distributions sub ensembles dn 
goal find policy ti cutoff ith run total number steps solution minimized 
unsuccessful run solver beliefs likelihood instance generated sub ensemble distribution updated 
di prior probability run chosen distribution di pi probability run selected di exactly qi pi cumulative function pi shall assume pi non trivial sense pi inf 
state tuple dn set actions states set cutoffs 
action cutoff state dn possible state termination state problem solved non terminal state updated probabilities 
denote termination state 
termination state cost free state solver reaches state remains cost 
objective restart control policy reach termination state minimal expected cost 
optimal expected solution time state dn optimized sum immediate cost optimal expected solution time possible states bellman equation min shown markov decision process mdp derive optimal restart policy case :10.1.1.4.5961
methods highlighted methods folding consideration evidence observed course runs continuing update beliefs hardness instances :10.1.1.4.5961
methods update beliefs instance drawn sub ensemble di 
particular explore case evidential feature reflecting solver state solver progress observed run 
function initial trace solver calculated decision tree low level variables 
may binary valued multi valued :10.1.1.4.5961
encode part state state denoted dn 
state sn dn fn cutoff setting solution solver termination state solution states sn fn possible values fn 
transition probability sn states 
similarly define optimal expected solution time state sn dn fn equation sn min sn fn sn sn sn similarly restart policy case run time observations computed dynamic programming 
mentioned specific series cutoffs policy generates depends features observed run instance 
policy takes general form tree list 
experiments performed set empirical studies explore approach finding optimal restart policies observations 
benchmark domains considered quasigroup domain graph coloring problems logistics planning problems 
csp satz gcp satz planning satz restart policy ert ert ert ert predictor median predictor median predictor median predictor luby optimal sub ensemble luby optimal rtd testing instances luby universal table results comparative experiments policies sub ensembles observation luby universal restart policy 
ert expected run time choice points improvements measured luby universal policy 
median uses median run time distance run time distributions cluster instances sub ensembles 
benchmark domains solvers benchmark domain quasigroup completion problem 
studies generated totally instances satisfiable rest unsatisfiable 
instances order unassigned variables holes 
second problem domain explored solving propositional satisfiability sat encodings graph coloring problem gcp 
instances studies generated culberson flat graph generator 
challenge determine instance colorable 
generated satisfiable instances 
instances generated way instances colorable colorable 
explored planning problem logistics domain 
generated instances cities packages planes truck city 
generate totally satisfiable instances 
decrease variance instances instances solved parallel steps solved steps 
randomized backtracking solvers problems encoded sat satz rand randomized version satz system li anbulagan 
problems experimented specialized randomized csp solver built ilog constraint programming library 
learning models predict hardness pursued construction data decision trees refer 
models serve provide probabilities instance derived different sub ensembles consideration observations 
generate predictive models implemented methods introduced horvitz 
distribution predictors instances solved satz rand solver predictive features domains explored measure interaction binary clauses number backtracks csp solver predictive base features average number colors available filling squares average number holes see details features 
comparative analysis policies experiments ensemble contains instances runs instances training dataset testing dataset 
identify ensembles median run times clusters instances small number sub ensembles exceeding ensembles 
constructed restart policies sub ensembles offline policy iteration dynamic programming 
procedure transform continuous infinite state space discrete state space apply finite state dynamic programming methods 
experiments discretized search space uniformly segments consideration tradeoff computational efficiency accuracy 
method implemented increase computational efficiency tested cutoff steps exhausting possible cutoffs 
construction policies dynamic programming policy iteration required minutes hours depending number feature values pentium machine gigabyte memory 
characterize improvements gained dynamic dependent restart policies ran comparative experiments luby optimal fixed restart policy known distribution training ensemble partitioning ensemble sub ensembles luby universal restart policy 
case universal restart policy constructed restart policies including dynamic dependent restart policies sub ensembles fixed optimal restart policies ensembles training data 
tested policies hold cases training 
compared results ideal cases knowledge rtd testing instances 
ideal case optimal expected run times testing instances obtained applying luby fixed optimal restart policy rtd particular instance solved 
practice course actual rtd instance solved known 
comparison results shown table 
problem domains studied optimal fixed cutoff restart policy luby training ensemble solve testing instances 
policy fails high variability hardness ensembles leads situation low fixed cutoff indicated policy little chance solving hard instances 
hardness aware restart policies observations consideration efficient restart policies overlooking observations 
attributed improvement solution time ranging domains effectively harnessing predictive models identifying proper sub ensemble 
restart policy observations expected run times partitioning sub ensembles slightly better sub ensembles 
believe slight degradation associated finer grained partitioning induced tradeoff 
held number training cases constant generate accurate predictive models situation fewer sub ensembles gains predictive accuracy models smaller partitioning overcame higher variabilities sub ensembles 
summary directions introduced method constructing restart policies leverage continually updated probability distribution sub ensembles different hardness problem solving 
methods address high variability hardness instances seen attempts solve real world problems 
illustrate value methods performed experiments compare new policies static restart procedures 
developed learning predictors provide probability distributions hardness new instance 
ongoing working enhance efficiency restart policies building powerful predictive models 
pursuing powerful models predicting hardness instance execution time individual runs instance conditioned different sub ensembles 
selman kautz cohen 
local search strategies satisfiability testing 
johnson trick editors dimacs series discrete mathematics theoretical computer science vol 
pages 
ams 
luby universal restart policy change distribution distribution 
gent walsh 
easy problems hard 
artificial intelligence 
kirkpatrick selman 
critical behavior satisfiability random boolean expressions 
science 
hogg huberman williams eds 
phase transitions complexity special issue 
artificial intelligence 
carla gomes bart selman 
problem structure presence perturbations 
proceedings fourteenth national conference artificial intelligence aaai pages new providence ri 
aaai press 
carla gomes bart selman nuno crato 
heavy tailed distributions combinatorial search 
gert smolka editor principles practice constraint programming cp lecture notes computer science pages linz austria 
springer verlag 
carla gomes bart selman henry kautz 
boosting combinatorial search randomization 
proceedings fifteenth national conference artificial intelligence aaai pages new providence ri 
aaai press 
carla gomes bart selman nuno crato henry kautz 
heavy tailed phenomena satisfiability constraint satisfaction problems 
automated reasoning 
aaai workshop leveraging probability uncertainty computation 
eric horvitz ruan carla gomes henry kautz bart selman max chickering 
bayesian approach tackling hard computational problems 
proceedings th conference uncertainty artificial intelligence uai pages seattle usa 
henry kautz eric horvitz ruan bart selman carla gomes 
dynamic randomized restarts optimal restart policies observation 
aaai 
ruan eric horvitz henry kautz :10.1.1.4.5961
restart policies dependence runs dynamic programming approach 
principles practice constraint programming cp 
luby sinclair zuckerman 
optimal speedup las vegas algorithms 
information process 
letters 
henry kautz ruan achlioptas carla gomes bart selman mark stickel 
balance filtering structured satisfiable problems 
proceedings sixteenth international joint conference artificial intelligence ijcai pages 
dimitris achlioptas carla gomes henry kautz bart selman 
generating satisfiable problem instances 
aaai iaai pages 
kevin leyton brown eugene yoav shoham 
learning empirical hardness optimization problems case combinatorial auctions 
principles practice constraint programming cp 
kullback 
information theory statistics 

macqueen 
methods classification analysis multivariate observations 
th berkeley symposium mathematics statistics probability volume pages 
joseph culberson feng luo 
exploring colorable landscape iterated greedy 
david johnson michael trick editors dimacs series discrete mathematics theoretical computer science vol 
pages 
kautz selman 
pushing envelope planning propositional logic stochastic search 
proceedings thirteenth national conference artificial intelligence aaai pages portland 
aaai press 
chu min li anbulagan 
heuristics unit propagation satisfiability problems 
proceedings international joint conference artificial intelligence pages 
aaai 
