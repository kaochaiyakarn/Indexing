ieee transactions computer aided design integrated circuits systems vol 
june hierarchical finite state machines multiple concurrency models alain girault lee edward lee fellow ieee studies semantics hierarchical finite state machines fms composed various concurrency models particularly dataflow discrete events synchronous reactive modeling 
argued combinations useful concurrency model selected independently decision hierarchical fsm contrast formalisms combine fsm concurrency models statecharts variants hybrid systems tightly integrate fsm semantics concurrency semantics 
implementation supports combinations described 
index terms concurrency discrete events finite state machines fsm heterogeneity hierarchy modeling synchronous dataflow languages 
manna pnueli argue concurrency essential feature reactive systems class includes embedded systems real time systems software systems 
concurrent systems modules consist relatively autonomous agents interact messaging sort 
rules interaction agents semantics composition call model computation 
models computation support concurrency numerous 
popular today threads set sequential processes operate data 
sophisticated concurrent models computation include communicating sequential processes csp pi calculus dataflow df process networks discrete events de synchronous reactive sr model 
models sophisticated sense complex concurrent systems easily designed designs yield better analysis 
block diagram languages signal processing example variant df semantics yield deadlock analysis static manuscript received september revised october 
research conducted part ptolemy project sponsored defense advanced research project agency darpa state california micro program cadence design systems hewlett packard hitachi hughes space communications nec philips 
girault supported inria 
recommended associate editor dill 
girault university california berkeley ca usa 
inria rh ne alps grenoble france 
mail alain girault inrialpes fr 
lee lee university california berkeley ca usa mail eecs 
berkeley edu eal eecs 
berkeley edu 
publisher item identifier 
ieee scheduling reasonably efficient synthesis embedded software hardware 
concurrency major source complexity 
increasingly intricate sequential control logic adds difficulty design particularly errors control sequence fatal consequences user case embedded systems 
finite state machines fsm long describe analyze intricate control sequences 
finite nature fsm yield better analysis synthesis alternative control models sequential programs goto 
example fsm designer enumerate set reachable states ascertain particularly dangerous state reached 
question may undecidable richer language 
modern electronic systems intricate control requirements concurrency 
combining fsm concurrent models computation attractive increasingly popular approach design 
harel introduced statecharts model number variations explored :10.1.1.20.461
argos language example combines fsm sr concurrency model 
jourdan combine synchronous language lustre argos 
researchers combined fsm concurrent models computation significantly different statecharts 
specification description language sdl combines process networks fsm 
codesign finite state machine model combines fsm discrete event de concurrency model 
combine synchronous df fsm 
program state machines psm combine imperative semantics fsm 
hybrid systems mix concurrent continuous time systems usually differential equations finite automata 
simulink math works 
ma provides simulation environment combinations 
examples tightly concurrency model automata semantics 
simulink statecharts variants limited compositionality permit automata leaf cells hierarchy sdl permit automata top hierarchy hybrid systems 
statecharts harel dramatically increased usability fsm innovations 
fsm hierarchically combined 
single state level hierarchy interpreted states girault hierarchical fsm multiple concurrency models lower level hierarchy 
called states state interpreted state second fsm concurrently combined 
fsm states composed fsm states resulting fsm state called states fsm state example 
innovations allow state machines represented compactly intuitively 
static interpretation states clear dynamics far clear 
concurrent fsm state transitions relative 
communicate state transitions 
questions greatly complicate fsm model computation completely resolved harel initially 
part reason proliferation variations concurrent hierarchical fsm models computation 
harel loosely defined state transitions concurrent fsm simultaneous 
state transition broadcast event visible immediately fsm fsm state transitions immediately broadcast events 
long circular logic circular dependencies transitions notion simultaneous transitions defined 
real circular dependencies lead genuine paradoxes undetermined behavior 
apparent circular dependencies prove common practical systems primarily hierarchy model refined 
argos language refine model applying sr principle resolves apparent circular dependencies seeking instant fixed point globally consistent behavior 
sr principle developed berry esterel language gives defined determinate semantics simultaneous concurrent actions 
reason restrict concurrent fsm sr semantics 
known high level concurrency models strengths weaknesses 
sr models describing tightly coordinated control systems need tight synchronization 
dataflow process networks models loosely synchronized poorly model control logic resource management 
discrete event models excellent describing hardware physically disjoint agents physical notion time awkward conceptual concurrency 
advocates decoupling concurrency model hierarchical fsm semantics 
describe family models computation called charts pronounced 
statecharts concurrent hierarchical fsm charts define concurrency model show embed hierarchical fsm variety concurrency models 
concurrency model chosen match problem hand 
tight synchronization possible 
desirable 
sr model inappropriate df process network model better choice 
globally consistent notion time 
de model inappropriate csp model better choice 
hierarchical fsm language works concurrency models 
hierarchy charts arbitrarily deep concurrency models fsm placed 
fsm nested module concurrency model interpretation fsm describes behavior module 
conversely subsystem concurrency model nested state fsm meaning subsystem active fsm state 
particularly suited describing modal systems modes operation modeled states fsm 
interestingly decoupled fsm semantics concurrency semantics heterogeneous combinations multiple concurrency models possible 
systems truly built modular components separately designed subsystem designed models computation best suited 
main objective give scalable approach design 
scalable mean subsystems designed analyzed verified synthesized relatively independently composed way composition analyzed verified synthesized 
achieve objectives models computation satisfy objectives 
compositional 
means composite modules treated primitive modules 
second support heterogeneity 
means composite modules embedded foreign model computation 
preserve analyzability embedding done maximum amount information hiding 
side effect supporting heterogeneity specialized models computation useful 
need solve problems alternatives available 
need solve problems 
practical specialized models computation fsm synchronous df strong formal properties excellent paths synthesis natural intuitive syntaxes 
adapting standard notation fsm compact efficient considering fsm isolation get notation suitable studying compositions fsm put emphasis usual interaction fsm environment 
consider combining fsm popular concurrent models computation df de sr model 
case df introduce new subset df called dataflow hdf combines particularly fsm briefly describe experimental implementation ptolemy environment hierarchical fsm combined df de sr concurrency models 
ii 
finite state machines basic fsm fsm tuple ieee transactions computer aided design integrated circuits systems vol 
june fig 

basic fsm 
finite set symbols denoting states set symbols denoting possible inputs set symbols denoting possible outputs transition function mapping initial state 
reaction fsm maps current state input symbol state output symbol input word sequence symbols input alphabet initial state sequence reactions produce sequence states output word sequence symbols output alphabet sequences potentially infinite 
directed graph called state transition diagram popular describing fsm 
shown fig 
elliptic node represents state arc represents transition 
transition labeled guard action guard represents input symbol triggers transition action represents output symbol transition triggered 
arc source state points initial state state reaction fsm transition triggered chosen set enabled transitions 
enabled transition outgoing transition current state guard matches current input symbol 
fsm goes destination state triggered transition produces output symbol indicated action triggered transition 
focus deterministic reactive fsm fsm deterministic state exists enabled transition input symbol 
fsm reactive state exists enabled transition input symbol 
simplify notation ensure fsm reactive state assumed implicit self transition going back state input symbol guard explicit outgoing transition 
self transition action default output symbol denoted element default symbol interpreted mean empty omitted output word 
example see fig 
suppose implicit self transitions possible trace sequence reactions shown fig 

multiple inputs outputs fsm embedded environment 
environment may fact part system design may control designer 
case fig 

possible trace basic fsm fig 

provides sequence input symbols fsm reacts providing sequence output symbols tracing sequence states 
frequently interaction environment needs modeled detail 
may convenient example consider fsm single input symbol 
multiple inputs multiple outputs may natural model 
handle input alphabet factored expressed cartesian product input fsm consists signals th signal sequence events represented symbols signal alphabet fsm reacts set simultaneous symbols signals 
output alphabet similarly factored 
reactions emit events signals 
pure valued fsm common special case called pure fsm size input symbol set power signal alphabet size interpret mean reaction signal consists event absent 
common notation scenario assigns name signal denotes alphabet corresponding signal interpreted absent example consider fsm input signals output signals input alphabet written output alphabet written default symbol 
valued fsm input output alphabets factored signal alphabets signal alphabets size greater infinite 
interpret element alphabet denote absence event remaining elements denote presence event value event 
valued fsm augment automata arithmetic operations awkward specify directly pure fsm scenario augmentation fundamentally needed arithmetic operations specified foreign model computation better suited df 
valued fsm may provide convenient syntax add fundamental expressiveness briefly discuss ramifications 
pure fsm size input alphabet grows exponentially number input signals 
quite inconvenient define reactive fsm explicitly specifying outgoing transitions state girault hierarchical fsm multiple concurrency models fig 

pure fsm 
input symbol 
may large number transitions 
avoid problem single transition may bear guard subset single symbol 
represent ensemble transitions compactly 
arbitrary subset defined boolean expression input signals 
example boolean expression represents subset pure fsm guards represented boolean expressions input signals 
consider example fig 
states input signal alphabet output signal alphabet guard transition enabled input guard transition enabled input valued fsm complicated boolean valued expressions guards 
example suppose valued fsm th signal named alphabet set real numbers 
guard may contain comparison operators real numbers example 
compactly represents uncountably infinite number transitions 
difficult reason fsm 
fact sufficiently rich expression language questions undecidable 
valued fsm carry high cost loss analyzability 
fortunately model heterogeneous valued fsm add fundamental expressiveness 
guard specify guard externally say df model compute function true false 
supporting heterogeneous combinations models computation charts permits keep fsm pure simplifying formal analysis compromising expressiveness 
course combined model analyzable valued fsm able analyze pure fsm 
pure fsm actions specified reasonably compact notation 
default output signal assumed denote absent event 
action lists output signals events current reaction 
words output events explicitly emitted action absent 
example fig 
action transition implies output symbol output signal output signal absent event transition triggered 
absence implicit explicit fact important fig 

possible trace embedded fsm fig 

fig 

hierarchical fsm 
hierarchical fsm events action implicitly absent action omitted altogether 
example fig 
label transition consists just guard transition triggered output signals implicitly absent 
valued fsm action denotes output value different default 
default implicitly emitted may denote absence event 
number transitions fsm finite possible emitted values form finite set represented finite number boolean signals 
pure fsm fundamental loss expressiveness 
externally model computation boolean signals translated values 
valued fsm may provide convenient syntax fundamentally required expressiveness 
possible trace fsm fig 
shown fig 

note state inputs absent implicit self transition taken outputs absent 
hierarchy basic fsm flat sequential major weakness practical systems large number states transitions 
representation analysis difficult 
harel solutions problem hierarchy 
hierarchical fsm state may refined fsm 
call inside fsm slave outside fsm master composition 
example state fig 
refined fsm state refined illustrated fig 

fundamental level hierarchy adds model computation 
reduce number states 
ieee transactions computer aided design integrated circuits systems vol 
june fig 

trace hierarchical fsm fig 

significantly reduce number transitions fsm intuitive easy understand 
transition fig 
simply compact notation transitions state space equivalent flat fsm simply input alphabet slave fsm subset input alphabet master fsm 
pure valued fsm input signals slave fsm subset input signals master 
similarly output signals slave fsm subset output signals master 
hierarchy semantics define slave fsm reacts relative reaction master fsm 
reasonable semantics defines reaction hierarchical fsm follows current state refined hierarchical fsm behaves just basic fsm 
current state refined corresponding slave fsm reacts master fsm reacts 
transitions triggered actions taken 
actions merged 
case pure fsm easy merge actions avoid conflicting definitions output slave master 
take output event action master slave fsm emits event output 
action explicitly emit symbol absence event conflict possible syntax 
example fig 
state substate input signal triggered action slave fsm triggered action master fsm 
output hierarchical fsm output signals 
possible trace hierarchical fsm shown fig 

valued fsm adopt convention action explicit mention absent event 
actions emit event different values syntax permits conflicting definitions output 
esterel function specified combine conflicting definitions 
example reals values added 
prefer consider error condition values conveniently flexibly combined externally model computation better suited numerical computation 
valued determinate fsm triggered transitions emit output signal 
example fig 
hierarchical fsm levels 
slave fsm hierarchical fsm depth hierarchy arbitrary 
semantics generalizes trivially 
iii 
heterogeneity mixing fsm concurrency models hierarchical fsm adequate describing complex systems 
thing numerical computations extremely awkward express model 
practical application complex systems fsm model computation combined 
commonly solution generalize activity associated action 
instance stateflow tool mathworks action invoke function assign value variable 
fsm tool embedded block diagram system called simulink allowing numerical computations outside fsm 
function calls variable assignments quite limited 
provide example concurrency 
limitation procedures functions permitting operate global state outside fsm 
done way provide chaotic poorly characterized programming model 
imposing discipline model essential 
needs model computation 
version simulink version actions invoke simulink block diagrams allowing multilevel hierarchy statecharts 
computation invoked action specified simulink concurrency model 
unfortunately richness possibilities difficult decide priori models computation 
strengths weaknesses 
advocate leaving choice application designer building language 
language support heterogeneity 
convenient way support heterogeneity black box approach 
system consisting set interconnected modules module treated black box 
model computation chosen govern interaction boxes contents boxes need governed model computation 
requirement interfaces boxes conform standard accepted outer model computation 
box may encapsulate subsystem specified model computation system specified 
words heterogeneity allows different models computation systematically modularly combined 
hierarchical fsm model computation easily extended support heterogeneity 
state transition may refined black box reacts subset input signals emitting events subset output signals 
internally black box need fsm 
example turing machine halts procedure eventually returns df graph reverse scenario fsm model computation describe module inside model computation long model computation provides way unambiguously determine input symbols reaction occur 
example fig 
fsm embedded inside blocks block diagram language exact semantics embedding interaction semantics needs defined terms girault hierarchical fsm multiple concurrency models fig 

fsm embedded inside blocks block diagram language 
semantics block diagram language fsm 
interestingly block diagram language concurrent semantics df slave fsm concurrent fsm section explore interaction semantics fsm various concurrent models computation dataflow df discrete event de synchronous reactive sr 
objective develop semantics supports arbitrary nestings concurrent models fsm wish fsm able define module concurrent system state able refined concurrent subsystem 
depth order nesting arbitrary 
shown fig 
adopt notation square boxes indicate modules concurrent model computation ellipses indicate states fsm 
termination general systems interest may terminate 
concurrent models computation usually defined mind 
reaction fsm usually need take finite time 
means state refines concurrent subsystem subsystem react finite time inputs possibly emitting output events result 
implies finiteness computation intrinsic concurrent models computation 
models computation simple solution 
execution nonterminating system divided set iterations 
iteration associated reaction master fsm 
require concurrent model computation refine state fsm defined finite iteration 
explore implications requirement terms specific examples 
reaction fsm discrete applications required take finite time 
sequence reactions may finite input sequence finite 
model computation include modules refined fsm capable supplying infinite sequence inputs requesting infinite sequence discrete reactions 
problem concurrent models computation considered 
dataflow fsm df model computation originally introduced dennis thought special case process networks pn model originally introduced kahn 
lucid early language df semantics 
pn network concurrent processes communicate unbounded fifo queues 
formally process pn network prefix monotonic function maps set potentially infinite input sequences set potentially infinite output sequences 
df special case process consists sequence discrete atomic units computation called firings 
df process called actor 
denotational formal semantics dennis df 
description informal operational 
df special case better suited purposes discrete firings map naturally reactions slave fsm playing role df actor 
df pn easily describe applications terminate meeting objective regard 
df pn invent natural definition iteration 
specifically define iteration df graph minimum set actor firings greater zero return fifo queues size iteration 
unfortunately general df graphs undecidable finite iteration exists 
may unique minimum set actor firings 
get problems specialize subclass df called synchronous dataflow sdf reviewed problems disappear 
sdf time df actor fires consumes produces fixed number tokens input output fifo queues 
restricted model interesting fundamental issues arise 
advocate semantics combining sdf fsm expressive sdf fsm falls short full expressive power general df 
exchange loss expressiveness ensure intrinsic properties design deadlock bounded memory execution remain decidable desirable property embedded systems 
synchronous dataflow sdf model computation system consists set blocks interconnected directed arcs 
blocks represent functions map input data output data 
data divided tokens treated atomic indivisible units 
arc represents potentially infinite sequence stream tokens 
streams carried conceptually unbounded fifo queues 
firing block atomic computation consumes fixed number tokens input arc produces fixed number tokens output arc number tokens consumed produced input output viewed part type signature actor course data type tokens 
numbers unambiguously define iteration minimal set firings ieee transactions computer aided design integrated circuits systems vol 
june fig 

hierarchical nesting fsm concurrency models 
return queues original size explain 
done writing arc balance equation arc assumed go actor actor arc actor produces tokens actor consumes tokens 
variables defined number firings actors respectively 
balance equations tell number tokens produced source actor equals number tokens consumed destination actor 
general may infinite case trivially satisfied balance equations may satisfied finite number firings 
implement sdf systems seek finite solution balance equations construct finite schedule actor fired times data precedences respected 
finite schedule produces consumes number tokens arc iterated indefinitely bounded resources 
take variables unknown attempt solve balance equations find smallest number greater zero firings actor balance equations satisfied 
assuming arcs actors equations unknowns shown connected graph unique smallest positive solution unknowns called minimal solution solution minimal solution exists define iteration consist exactly firings actor solution sdf graph considered defective error reported analogous type error strongly typed language 
sdf decidable iteration exists 
unique firing schedule iteration determined compile time 
simplest sdf graphs homogeneous defined mean actor produces consumes single token input output arc graphs iteration consists exactly firing actor schedule firings obey data precedences token queue consumed 
avoid deadlock directed cycles homogeneous sdf graph initial token called delay arc cycle 
arbitrary sdf may require initial token arcs general fig 

fsm refining homogeneous sdf blocks embedded sdf system 
df decidable set initial tokens sufficient prevent deadlock 
fsm inside sdf fsm subsystem slave sdf actor externally obey sdf semantics 
consume produce fixed number tokens input output 
simplest case fsm subsystem refines homogeneous sdf actor 
input sdf actor provides single data token takes values alphabet 
cross product signal alphabets forms input alphabet fsm perfectly matching fsm model section ii 
actions fsm able emit events output signal representing event symbol corresponding signal 
outputs emitted fsm action assigned default element alphabet usual 
subtlety approach absent event appears explicitly token sdf graph value token encodes absent interpretation default symbol 
simple approach encode presence absence boolean valued tokens 
concurrent models computation absence event correspond absence token 
key property df absence token defined testable condition absence event encoded token 
consider example fig 
pure fsm refining homogeneous sdf actors 
iteration sdf graph consists single firing actor 
initial token arc actor fires girault hierarchical fsm multiple concurrency models fig 

fsm behaving multirate blocks embedded sdf system 
actor iteration 
names arcs indicate names nearest input output df actor 
suppose iteration input tokens values indicating absent state sdf system reacts follows fire transition output assigned value indicating 
fire transition back state output 
simple example may look concurrent fsm fact 
iteration fire sequentially 
iterations fire concurrently 
th firing may concurrent th firing course complicated sdf graphs concurrency iteration 
easily devise syntax permits fsm refine nonhomogeneous sdf actor 
nonhomogeneous actor actor token input output consumed produced syntactically differentiate token input output concatenating occurrence name 
borrowing notation signal language denotes token consumed input denotes token consumed 
consider example fig 
focusing levels 
numbers parentheses level indicate number tokens consumed produced corresponding actor 
guard arc level means tokens consumed input value representing event 
action means oldest output token output value representing absent event mentioned second newest token output value representing event mentioned 
default state transitions occur df actor refines fsm fires 
prefer transitions occur iterations df graph 
prove important states fsm may refined 
case types firings df actor refines fsm 
type transition taken action performed current state refined refinement subsystem fired 
type refinement system fired transition taken ieee transactions computer aided design integrated circuits systems vol 
june fig 

actor valid sdf composition actors produce consume single token firing suggested annotations 
corresponding action performed 
type firings iteration 
consider example fig 
focusing levels 
suppose schedule top level sdf system firings actor type firings subsystem refining current state fired 
third firing type firing refinement system fired transition taken values inputs corresponding action performed 
notation described obvious extension valued fsm leave details reader 
sdf inside fsm sdf graph refines state fsm state current state reaction consist iteration sdf graph followed reaction fsm 
slave sdf graph homogeneous consumes single token input produces single token output fits fsm model naturally 
reaction input symbol corresponding signal alphabet 
symbol interpreted denoting absent event provides token sdf graph consume 
slave sdf graph homogeneous semantics subtle 
suppose example sdf subsystem fig 
slave fsm say level 
solving single balance equation subsystem level arc entirely inside subsystem balance equation indicates iteration consist firings firing shown level type signature subsystem indicates tokens consumed input input tokens produced output iteration subsystem 
semantics choose resulting composite sdf type signature type signature fsm subsystem 
system fsm level embedded treat fsm sdf actor type signature 
number potential complications 
composing synchronous df actors create new synchronous df actor possible 
example shown fig 

actors combined form synchronous df actor behavior changes 
example actor connected shown system deadlocks actor actors problem resolved general df compositional synchronous df 
purposes assume valid aggregations specified 
second complication fsm level fig 
embedded sdf environment 
suppose example embedded de environment 
case semantics sdf embedded de covered 
key fsm contains slave sdf graphs treated sdf actor type signature determined slave sdf graphs 
third complication type signature may different states 
case fsm system treated sdf actor number tokens produces consumes dependent state 
possibility extremely interesting represents major increment expressive power handled cleanly 
deal section iii 
dataflow fsm system state refined sdf graph simplest case type signatures sdf graphs identical 
fsm system treated sdf actor type signature 
consider situation type signatures different 
example fig 
sdf graphs consumes tokens produces consumes produces 
case possible type signatures fsm subsystem embedded sdf graph 
option embed fsm system dynamic dataflow ddf boolean dataflow bdf graph 
ddf bdf number tokens consumed produced need constant actor 
price pay approach high 
ddf bdf questions system undecidable deadlock memory required fifo queues bounded 
importantly synthesis difficult implementations expensive 
choice semantics provides generality really need application 
invent new model computation call dataflow hdf 
hdf actor finite number type signatures type signature specifies number tokens consumed produced 
actor fires welldefined type signature effect 
type signatures allowed change firings 
model computation related cyclo static dataflow 
actor cycles finite list type signatures 
easy generalize balance equations actors complete integer number cycles iteration system 
iteration finite static scheduling possible 
hdf order type signatures cyclic predictable 
allow type signature actor change firings easy show model computation full expressive power bdf ddf turing machines 
modest generalization girault hierarchical fsm multiple concurrency models fig 

fsm states refine sdf subsystems different type signatures 
possible restricting changes type signature occur controlled points execution 
hdf system starts execution initial type signature effect actor 
type signatures solve balance equations finding iteration 
semantics choose hdf type signature remain constant duration corresponding iteration 
ensure fsm components change state firing iteration 
completion iteration new set type signatures effect balance equations solved anew redefine iteration 
example fig 
top hierarchy hdf system 
middle actor system possible type signatures consuming producing consuming producing 
actor refined fsm sets solutions balance equations 
corresponding sequential schedules state initial state fsm hdf system starts executing schedule 
second firing fsm allowed change state observations inputs 
point consumed tokens iteration indicated state changes completion hdf iteration repeating schedule schedule invoked 
number alternatives implementing hdf 
number possible type signature combinations small example fig 
probably best precompute compile time balance equation solutions iteration schedules 
ddf bdf theoretically possible precompute schedules possible iterations 
general number type signature combinations exponential number hdf nodes approach impractical 
fortunately balance equations solved time linear number arcs plus number actors schedule time linear number firings number edges may impractical compute schedules dynamically iterations 
currently exploring implementation alternatives 
number type signature combinations exponential number actors finite 
combination key questions decidable deadlock bounded memory schedules statically constructed 
retained key advantage sdf decidability dramatically increased expressiveness 
construct designs combinations reachable 
obviously need worry scheduling combinations 
language expressing guards rich combinations reachable decidable 
hdf significant disadvantage 
state transition occurs depends global solution balance equations local definition 
harder compromises modularity design 
note fig 
addition type signatures implied sdf refinements states type signatures implied guards transitions 
guard implies tokens consumed input iteration input pure 
compiler check constraints type signature consistent type signature refinement state arc containing guard emanates 
dynamic dataflow ddf bdf models computation permit actors consume produce variable number tokens firing 
enhancement sufficient models turing complete ieee transactions computer aided design integrated circuits systems vol 
june implement universal turing machine 
fundamental level models expressive sdf hdf 
price pay deadlock bounded memory undecidable schedules longer constructed compile time 
combine fsm ddf bdf concept firing rules formalized 
purposes firing rules simply imply df actor assert prior firing tokens needs input 
fsm refines ddf actor state fsm determine tokens need consumed input firing reaction fsm 
semantics adopt simple token consumed input signal mentioned guard outgoing transition current state 
multiple tokens mentioned single signal notation positive integer signal find largest index mentioned consume tokens plus 
state know tokens consumed input reaction 
numbers firing rules ddf actor refined fsm specifying number tokens inputs firing occur 
inverse scenario bit complicated 
ddf graph refines state fsm firing rules ddf graph exported environment fsm 
fsm state refined entire fsm ddf actor invoked firing rules ddf subsystem treated actor met 
simple fact realizations ddf semantics compositional meaning ddf subsystem treated actor defined firing rules 
techniques making ddf compositional determining resulting firing rules covered scope 
sufficient purposes know done 
discrete events fsm df loosely synchronized concurrency model events partially ordered data precedences 
partial ordering events realizations df system possible systems overspecified 
implies great deal concurrency exploited parallel implementations 
resulting loose synchronization key weakness df 
df suited explicitly modeling resource sharing resource usage 
study popular concurrency models tightly synchronized de sr formal relationship models computation studied 
actor may assert token values 
simple exercise show omitting capability compromise turing completeness 
reactive fsm adding capability increase expressiveness 
omit 
de model computation particularly useful modeling distributed parallel hardware software communication infrastructure 
carries notion global time value usually real number known simultaneously system 
event signal occurs point time 
simulation system event carries value time stamp indicates time event occurs 
time stamp event typically generated actor produces event determined time stamp input events latency block 
de simulator needs maintain global event queue sorts events time stamps chronologically processes event sending appropriate actor reacts event fires 
formal semantics de formal treatments 
semantics constructing metric space called cantor metric defining signals elements metric space 
causality turns key property operators signals characterized terms contraction mappings metric space 
determinacy ensured feedback loops contain contraction mapping 
fsm inside de de model computation df defined firings embedding fsm de straightforward control perspective 
fsm refines de actor reacts de actor fires occurs event inputs event smallest time stamp events event queue 
event value value available fsm testing guards 
input signals events time stamp available reaction signals assigned input symbol indicating absence event 
df absence event represented de absence token 
reaction fsm refines de actor may emit output events 
output events translate directly events de domain 
de assigned time stamp fsm semantics provide 
choose semantics fsm system appears de system zero delay actor 
output generated reaction assigned time stamp input triggered reaction 
consider example shown fig 

suppose event time stamp processed global event queue fsm state de system reacts follow fire exists event transition emits pure event de event time stamp processed 
fire exists event transition back state emits de event time stamps ambiguity event event queue smallest time stamp 
various de simulators deal situation differently 
see discussion issue 
purpose difference technique 
girault hierarchical fsm multiple concurrency models fig 

fsm refine de actors 
fig 

guard upper transition incomplete event absent fsm reacting 
de semantics event driven actor fire events inputs 
leads subtleties guards 
consider example fig 
suppose fsm state guard outgoing transition indicates absent transition trigger 
implicitly fsm react event trigger firing 
clearer give guard guard transition fire inputs actor fire absent 
de inside fsm df state fsm refines de subsystem properties subsystem exported environment fsm 
environment de df semantics de df apply 
state fsm refines refine de subsystem semantics imposes consistency constraint sdf 
environment fsm de semantics simple 
fsm react inputs 
input triggers firing time stamp current time environment 
current state refines de subsystem subsystem simulated current time matches environment 
may emit events outputs environment time stamps equal current time 
case de modeling zero delay actors permitted semantic problems directed cycles zero delay 
consider example fig 

reacts event starts process event circulate cycle forever advance time 
number solutions particular programming environment may impose constraints data types tokens issue addressed 
fig 

de modeling zero delay loops cause difficulties 
problem intrinsic de de fsm combination scope 
synchronous reactive systems fsm time real number de system behaved de simulation time fact advances discrete steps 
recognizing model computation discrete steps modeled time continuum 
addition resolve problem highlighted zero delay feedback loops adopting fixed point semantics 
innovations get sr model computation 
sr synchronous sense synchronous digital circuits 
time delays computations irrelevant useful conceptual assume computations take zero time 
sr major advantage de sr model compiled sequential code parallel circuits 
de contrast difficult implement efficiently sequential code routinely specify circuits intrinsically parallel vhdl verilog languages 
execution sr system occurs sequence global discrete instants called ticks ticks clock 
tick signal event absent event possibly value 
tick signals related functions signals arguments define signals 
general directed cycles permitted 
fir example signals functions tick signals defined set simultaneous equations functions 
solution called fixed point task compiler generate code find fixed point 
ensure system deterministic implementation finds solution inputs function required monotonic particular sense 
suppose function input signal signal alphabet augment alphabet special symbol pronounced bottom interpret mean unknown function defined ieee transactions computer aided design integrated circuits systems vol 
june fig 

partial orders define sr functions 
input output 
define flat partial order augmented set shown fig 

diagram set elements set comparable 
function monotonic symbol interpreted respect partial order 
partial order notion monotonic function easily generalized allow functions multiple arguments 
possible fixed point theorem knaster tarski fixed point theorem show network monotonic functions fixed point respect partial order 
fixed point taken semantics network functions 
basic approach pioneered scott manna 
practical implementations sr model constructed starting esterel language 
finding fixed point straightforward principle 
functions simply evaluated order converge fixed point 
choosing order evaluating functions greatly impact performance obviously 
edwards proposes compares algorithms choosing order evaluation 
functions allowed change ticks 
module sr distinct behaviors call produce transition 
produce phase current function evaluated determine outputs current information inputs 
transition phase function changed preparation tick 
familiar functions strict meaning arguments known function output defined 
strict functions monotonic 
directed loop strict functions solution unknown signals 
uncommon functions output determined inputs known 
nonstrict functions allows directed loops trivial solutions 
see fsm described nonstrict functions map input events output events reaction 
simple fsm inside sr embedding fsm sr module straightforward sense 
tick inputs fsm known fsm react possibly assert output events 
output events asserted known absent 
difficulties sr current state fsm may refine sr non sr subsystem 
second inputs may completely known 
particular sr system includes directed loop inputs fig 

fsm embedded sr system 
known start tick modules loop 
section assume states fsm refined 
consider example fig 
fsm embedded sr system enclosed directed loop 
function mapping inputs output state function depend fsm state observed absent specify absent observing state sr function defined fsm strict 
needs observe analysis automated get simplified function output state standard techniques digital logic design 
simplified functions indicate state inputs need known define output 
define phases execution fsm sr called produce transition 
complement firing types fsm df call firing types respectively 
produce phase type firing fsm observes inputs determines output function evaluated 
evaluated output defined 
indicates outputs unknown 
produce phase may invoked number times single tick long output functions monotonic 
transition phase type firing state transition enabled current inputs ignores action associated transition 
run time scheduler sequence function evaluations iterating fixed point 
scheduler executes phases cf 

invoke produce phase fsm sr blocks times needed define outputs reach fixed point 
algorithm ordering invocations edwards 
signals remain undefined signal causality loop error 
girault hierarchical fsm multiple concurrency models invoke transition function fsm sr system 
iterative procedure step may costly glance experience indicates intelligent scheduling convergence fixed point fast 
iterative procedure amenable embedding compiled code imply interpreted execution style 
causality loops detected run time reported run time 
serious impediment scheme embedded systems 
refined fsm inside sr consider cases 
current state fsm refines sr subsystem produce phase fsm invoke produce phase sr subsystem 
change needed 
fsm refines non sr subsystem cautious 
case assume non sr subsystem defines strict function modify sr scheduling follows 

look fsm sr system current state refines non sr subsystem subsystem fired 
non continue step 
undefined inputs signal causality loop error 
fire refinements inputs defined repeat steps 
signals remain undefined signal causality loop error 
invoke transition function fsm sr system 
experience doubly iterative procedure know costly 
sr inside fsm embedding sr systems fsm straightforward 
current state fsm refines sr subsystem semantics sr simply exported boundary fsm 
iv 
verification synthesis synthesis hardware software fsm standard practice supported years widely computer aided design cad packages 
synthesis hardware software sdf graphs demonstrated 
synthesis hardware software sr demonstrated 
simple composition semantics hard come ways combine independently synthesized components 
somewhat limited combinations demonstrated embedded software edwards 
de modeling synthesis synthesis issue 
verification fsm reachability analysis model checking studied 
verification sdf graphs includes liveness analysis conversely deadlock detection 
independent analysis compromised approach 
verification sdf fsm combination general difficult 
probable fundamental decidability questions simulation remain main validation method aspects combined system 
advantages approach permits established reasonably mature synthesis verification technologies model computation provides simple determinate mechanism combining results 
determinacy combination ensures validation combination simulation practical 
implementation experimental implementation combinations discussed implemented ptolemy software environment 
sdf de sr models software minimal modifications required interface fsm 
significant complication encountered order support arbitrary hierarchical combinations models hooks supporting produce transition phases execution required partial evaluation sr sdf de produce phase transition phase implements standard firing 
sdf de strict behavior 
get modular software architecture object oriented principle polymorphism default behavior model computation strict specific models override behavior 
reflex game vi 
examples commonly example control intensive software environments reflex game 
version reflex game player game introduce concurrency 
description game inputs system coin ready go time 
user inputs simply counts time 
outputs control user interface 
normal play proceeds follows 
player may assert coin start game 
status light turns blue 
player ready presses ready status light turns yellow 
player presses go status light turns green player presses fast 
game ends status light turns red 
game measures reflexes player reporting time 
situations game ends abnormally tilt light flashes 
follows 
coin asserted player press ready time units 
player presses instant player presses go 
player presses go player press time units 
additional rule player press go time units player presses ready go asserted ieee transactions computer aided design integrated circuits systems vol 
june fig 

system reflex game hierarchically decomposed levels subsystems 
system game advances wait player press 
heterogeneous realization game realization game shown fig 

simulate real time behavior game de topmost level modeling environment game including players 
de model contains clock generate time ticks models players reflex block modeling implementation game display block 
contains merge block player assert coin 
level hierarchy fig 
inside reflex block state fsm 
states game game 
inside game state level sr model consisting players 
interconnected zero delay feedback loop exploit fixed point semantics sr level players refined concurrent fsm player starts idle state ready asserted emits start event transitions wait go state 
causes player transition wait state emit event 
rest behavior level evident 
states need count ticks clock watch time outs 
counting simple arithmetic computation performed df graph shown level 
graph simply counts ticks compares count constant emits timeout event threshold exceeded 
girault hierarchical fsm multiple concurrency models fig 

esterel realization player reflex game 
esterel realization fig 
shows esterel realization player reflex game 
description concise slightly space fig 

application match concurrent semantics esterel synchronous reactive 
esterel module include model environment 
esterel programs generally specify modules intended reside foreign realization environment program 
support de modeling 
computational aspects reflex game involve trivially simple arithmetic match esterel 
sophisticated computations signal processing common esterel programs fall back modules written implementation 
contrast charts model designer df models sophisticated computations somewhat higher level programs 
description esterel charts readable understandable depend heavily familiarity reader languages involved 
believe version fig 
easily understood general 
vhdl realizations esterel proven paths synthesis hardware software 
code generation df graphs hardware software targets demonstrated appeared number commercial products spw cadence synopsys 
synthesis embedded software version sr semantics admits heterogeneity demonstrated 
synthesis hardware fsm models routine cad software synthesis embedded software fsm models appeared commercial products stateflow mathworks 
elements place synthesis charts heterogeneous model 
completed synthesis tool performs entire task wish imply trivial task 
implemented automatic synthesis charts model manually crafted implementations player reflex game synthesizable vhdl code written style similar generated synthesis program 
complete vhdl implementation shown fig 
readable font 
vhdl relatively verbose language description includes comments occupies pages esterel program model environment 
description somewhat shorter occupying pages 
fig 
right show vhdl descriptions level fsm fig 

fsm implemented directly ifthen clauses cases 
code segments hope reader convinced translation syntax fig 
syntax relatively straightforward 
vhdl back languages synthesized higher level descriptions purpose interfacing lower level synthesis tools compilers logic synthesis charts provides reasonable higher level description 
digital cellular telephone reflex game example rich encompass multiple models computation simple summarized page 
practical application exhibits features digital cellular telephone 
includes intensive numerical signal processing match sdf speech coder radio modem 
may include features speech recognition hands free ieee transactions computer aided design integrated circuits systems vol 
june fig 

vhdl description player reflex game segment corresponding level fig 
shown readable font upper right 
lower right version 
dialing 
signal processing components quite sophisticated may involve modal models appropriately constructed combining sdf fsm 
example equalization fading radio channel may involve distinct algorithms establishment connection vs steady state 
power conservation dictates simpler algorithms channel benign suggesting mode changes driven channel estimators 
cellular phone includes substantial amount embedded control logic call processing multiple access protocols 
time division multiple access tdma girault hierarchical fsm multiple concurrency models gsm phones requires accurate real time state transitions 
protocols get quite intricate ability systematically verify correctness fsm models may valuable 
formal verification fsm model easily understood program design constructed terms fsm correct 
modeling cellular phone requires modeling environment quite complex 
multiple access scenarios varying numbers users part model 
multipath fading modeled level detail model depend question asked design transfer model verify design radio modem drop event model verify robustness protocol implementations 
features environment conveniently modeled de 
detailed modeling multipath fading suited sdf 
cellular telephone contains analog rf circuitry adding element heterogeneity discussed 
mixed signal models include fsm de sdf active area research 
commercial systems appeared support subsets analogy models de systems continuous time systems hp ptolemy models sdf systems continuous time systems 
cellular phone development project effort coordination diverse tasks teams major challenge 
practice cellular telephone design efforts heterogeneous set tools methodologies 
different techniques embedded dsp software embedded microcontroller software custom digital hardware analog rf hardware 
believe charts model provides framework coordination efforts 
vii 
described combination fsm different concurrency models df sr systems de systems 
concurrency models different strengths weaknesses applicable different situations 
df section iii suited numerical computation signal processing poorly suited resource management control logic 
sr section iii suited resource management control logic numerical computational systems imposing synchrony 
de section iii suited modeling hardware systems poorly suited specifications physical notion time 
fsm complement sequential control easily analyzed synthesized 
semantics concurrent model computation combined fsm 
example described uses models computation 
resulting combination easily understood familiar models computation obviously obtuse familiar subset 
particular example chosen precisely illustrate claim heterogeneity multiples models computation 
designs similar complexity require subset models computation 
issues discussed 
include enhancements possible fsm example support preemptive transitions refinement state fired prior transition 
issue dealt done state refinement state fsm 
possible support history entry entering state starts refinement subsystem state 
alur courcoubetis halbwachs henzinger 
ho nicollin olivero sifakis yovine algorithmic analysis hybrid systems theoretical comput 
sci vol 
pp 
feb 
andr 
effective implementation esterel programs th euromicro workshop real time systems oulu finland june 
ashcroft proving assertions parallel programs comput 
syst 
sci vol 
pp 

sarma sdl applications protocol specification 
hemel prentice hall international 
benveniste berry synchronous approach reactive real time systems proc ieee vol 
pp 
sept 
benveniste le guernic hybrid dynamical systems theory signal language ieee trans 
automat 
contr vol 
pp 
may 
bernhard berry de simone gonthier inria sophia antipolis france programming reflex game esterel rapport de recherche june 
berry gonthier esterel synchronous programming language design semantics implementation sci 
comput 
programming vol 
pp 

berry hardware implementation pure esterel academy proc 
engineering sciences vol 
pp 

bhattacharyya murthy lee software synthesis dataflow graphs 
norwell ma kluwer academic 
engels dataflow ieee trans 
signal processing vol 
pp 
feb 
buck scheduling dynamic dataflow graphs bounded memory token flow model ph dissertation dept eecs univ california berkeley ca tech 
rep ucb erl buck ha lee messerschmitt ptolemy framework simulating prototyping heterogeneous systems int 
comput 
simulation special issue simulation software development vol 
pp 
apr online 
available ptolemy eecs berkeley edu papers 
discrete event systems modeling performance analysis 
irwin il 

chang 
ha lee heterogeneous simulation mixing discrete event models dataflow invited vlsi signal processing special issue submitted publication 
online 
available ptolemy eecs berkeley edu papers heterogeneity 
hsieh lavagno sangiovanni vincentelli hardware software codesign embedded systems ieee micro pp 
aug 
cleveland smolka strategic directions concurrency research acm computing surveys vol 
dec 
davey lattices order 
cambridge cambridge univ press 
dennis version data flow procedure language massachusetts inst 
technol 
lab 
comput 
sci 
tech 
memo mac tm may 
ieee transactions computer aided design integrated circuits systems vol 
june edwards specification execution heterogeneous synchronous reactive systems ph dissertation ucb erl department eecs univ california berkeley ca may 
halbwachs synchronous programming reactive systems 
dordrecht netherlands kluwer academic 
halbwachs caspi raymond pilaud synchronous data flow programming language lustre proc 
ieee vol 
pp 
sept harel statecharts visual formalism complex systems sci 
comput 
program vol 
pp 

henzinger theory hybrid automata proc 
th annu 
ieee symp 
logic computer science lics pp 

hoare communicating sequential processes commun 
acm vol 
aug 
hopcroft ullman automata theory languages computation 
reading ma addison wesley 
jourdan raymond multiparadigm language reactive systems proc 
ieee int 
conf 
computer languages iccl toulouse france may pp 

kahn semantics simple language parallel programming proceedings ifip congress amsterdam netherlands north holland 
lee denotational semantics dataflow firing electron 
res 
lab univ california 
berkeley ca memo ucb erl jan 
modeling concurrent real time processes discrete events invited ann 
software eng special volume real time software engineering submitted publication electron 
res 
lab univ california 
berkeley ca memo mar 
lee messerschmitt static scheduling synchronous data flow programs digital signal processing ieee trans 
comput jan 
lee parks dataflow process networks proc 
ieee may vol 
pp 

online 
available ptolemy eecs berkeley edu papers 
lee sangiovanni vincentelli denotational framework comparing models computation univ california berkeley ca eng 
res 
lab memo ucb erl jan 
online 
available ptolemy eecs berkeley edu papers denotational 
manna mathematical theory computation 
new york mcgraw hill 
manna pnueli temporal logic reactive concurrent systems 
berlin germany springer verlag 
argos language graphical representation automata description reactive systems ieee workshop visual languages kobe japan oct 
operational compositional semantics synchronous automaton compositions lecture notes computer science con cur third international conference concurrency theory vol 
stony brook ny springer verlag pp 
aug 
milner parrow walker calculus mobile processes inform 
computation vol 
sept 
narayan gajski language system level specification synthesis int 
symp 
computer hardware description languages marseille france apr 
ritz meyr dynamic data flow control flow high level dsp code synthesis proc 
ieee int 
conf 
acoustics speech signal processing adelaide australia apr vol 
pp 

halbwachs implementing reactive programs circuits hardware implementation lustre lecture notes computer science real time theory practice june vol 

berlin germany springer verlag pp 

scott outline mathematical theory computation proc 
th ann 
princeton conf 
information sciences systems pp 

narayan gajski vhdl frontend embedded systems ieee trans 
computer aided design vol 
pp 
june 
von der comparison statecharts variants proc 
formal techniques real time fault tolerant systems lncs 
berlin germany springer verlag pp 

wadge ashcroft lucid dataflow programming language 
london academic 
multirate dynamic data flow graph specification high throughput communication link asic submitted publication 
alain girault received ph degree national institute grenoble grenoble france spent years half post doc researcher esterel team sophia antipolis france ptolemy group university california berkeley path project uc berkeley 

holds research fellow position ria institut de recherches en informatique automatique grenoble france 
research interests include design reactive systems special concern distributed implementation formal verification 
designed tool synchronous programs distribution specifications user 
lee received degree control engineering national tung university taiwan degree electrical engineering computer sciences university california berkeley 
ph degree candidate department electrical engineering computer sciences university california berkeley 
research interests include embedded system design image video processing communication systems 
edward lee sm received degree yale university new haven ct degree massachussets institute technology mit ph degree university california berkeley 
professor electrical engineering computer science department university california berkeley 
research interests include embedded real time systems signal processing discrete event systems concurrency systemlevel design technology 
director ptolemy project university california berkeley 
author books numerous papers patents 
member technical staff bell telephone laboratories holmdel nj advanced data communications laboratory 
founder currently senior technical advisor consulted number companies 
dr lee received national science foundation nsf presidential young investigator won frederick award engineering education 
