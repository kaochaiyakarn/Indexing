centrum voor wiskunde en informatica software engineering sen symphony view driven software architecture reconstruction van deursen koschke moonen riva report sen april software engineering cwi national research institute mathematics computer science 
sponsored netherlands organization scientific research nwo 
cwi founding member ercim european research consortium informatics mathematics 
cwi research theme oriented structure grouped clusters 
listed names clusters parentheses acronyms 
probability networks algorithms pna software engineering sen modelling analysis simulation mas information systems ins copyright stichting centrum voor wiskunde en informatica box gb amsterdam nl kruislaan sj amsterdam nl telephone telefax issn symphony view driven software architecture reconstruction authentic descriptions software architecture required reliable foundation trivial changes system 
far architecture descriptions existing systems sync implementation 
reconstructed 
existing techniques reconstructing individual architecture views information select views reconstruction process aspects architecture reconstruction general 
describe view driven process reconstructing software architecture fills gap 
describe symphony compare different case studies serving secondary goal sharing real life reconstruction experience 
symphony process incorporates state practice reconstruction uses rich set architecture views 
symphony provides common framework reporting reconstruction experiences comparing reconstruction approaches 
vehicle exposing research problems software architecture reconstruction 
acm computing classification system keywords phrases reverse engineering case studies process note carried project sen software renovation 
symphony view driven software architecture reconstruction arie van deursen cwi delft univ technology netherlands arie van deursen cwi nl christine lehigh university usa cse lehigh edu leon moonen delft univ technology cwi netherlands leon moonen computer org authentic descriptions software architecture required reliable foundation trivial changes system 
far architecture descriptions existing systems sync implementation 
reconstructed 
existing techniques reconstructing individual architecture views information select views reconstruction process aspects architecture reconstruction general 
describe view driven process reconstructing software architecture fills gap 
describe symphony compare different case studies serving secondary goal sharing real life reconstruction experience 
symphony process incorporates state practice reconstruction problem driven uses rich set architecture views 
symphony provides common framework reporting reconstruction experiences comparing reconstruction approaches 
vehicle exposing research problems software architecture reconstruction 

software engineering tasks hard conduct relevant architectural information 
examples include migrations auditing application integration impact analysis 
illustrate consider basel ii agreement basel committee banking supervision regulates financial risk estimation reporting 
analysts forrester research estimated migrating basel ii cost banks ing deutsche bank approximately euros 
costs concern changes bank information systems 
high impact changes clear picture architecture underlying information systems 
bis org forrester com rainer koschke university stuttgart germany koschke informatik uni stuttgart de claudio riva nokia research center helsinki finland claudio riva nokia com ideal world relevant architectural information documented time architectural decisions updated decisions revised readily available needed particular task 
unfortunately architectural information available outdated incorrect inappropriate task hand 
software architecture reconstruction process obtaining documented architecture existing system 
reconstruction possible resource available documentation stakeholder interviews domain knowledge reliable source information system source code traces obtained executing system 
architecture reconstruction practice predictably ad hoc simple tools large amount manual interpretation 
researchers trying improve state practice primarily providing better techniques tools cluster concept analysis program analysis software visualization 
application techniques usually involves steps extract raw data source apply appropriate abstraction technique visualize information obtained 
research papers presenting reconstruction techniques typically describe steps needed successful application specific technique number questions remain 
problems require architecture reconstruction 
typical views recovered 
techniques suitable reconstructing particular views 
different views deal problem hand 
propose symphony method aims helping reconstruction teams answering questions 
symphony result systematic analysis experiences software architecture reconstruction name symphony reflects successful reconstruction result interplay different instruments 
authors collaboration area software architecture reconstruction started music room castle dagstuhl germany 
cases conducted close colleagues various approaches published literature 
particular integrates different reconstruction cases carried authors 
cases illustrate step symphony 
described detail appendix 
case studies demonstrate importance viewpoints focusing reconstruction activities solve particular problem 
different viewpoints corresponding techniques case studies underlining need recognize viewpoints order elements reconstruction process 
having method symphony help practitioners giving guidance performing architecture reconstruction 
addition symphony provides conceptual framework comparing case studies 
help researchers providing unified approach reconstruction consistent terminology basis improving refining quantifying comparing reconstruction processes 
furthermore symphony method view recognition importance multiple architectural views presenting architecture fundamentally defining reconstruction activities 
previous research focused recovering single architectural view preselected views 
part symphony process discovery views reconstructed order solve problem hand 
organized follows 
summarize related section 
define terminology architectural views section 
section provide overview symphony steps described sections 
section summarize contributions opportunities 

related software architecture reconstruction active area research illustrated software architecture reconstruction workshops held conjunction working conference reverse engineering dagstuhl workshops organized sei asset mining software product lines 
substantial body published area reverse architecting aware papers addressing software architecture reconstruction process se 
section summarize papers deal software architecture reconstruction discuss process elements covered 
note significant amount related furthermore discussed presentation various symphony steps 
software architecture reconstruction special form software reverse engineering 
reverse engineering approaches extract cycle sources analyzed order populate repository queried order yield system representations suitable interactive form software engineer 
tilley describe extract approach detail referring steps data gathering knowledge inference information presentation 
number reverse engineering activities focus software architecture reconstruction 
kazman propose iterative reconstruction process historical design decisions discovered empirically formulating validating architectural hypotheses 
point importance modeling system information description underlying semantics 
approach currently extended include reorganization recovered assets software product lines 
propose software bookshelf toolkit generate architecture diagrams source text 
ding medvidovic describe focus approach contrasts logical idealized high level architecture physical implemented recovered 
applying refinement logical abstraction physical architecture brought incrementally 
previous works differs symphony address determined goal concrete techniques certain fixed sets views reconstructed symphony provides general reconstruction model 

views symphony software architectures generally described models rationales 
goal symphony reconstruct models rationales possible 
models created viewpoints views 

views viewpoints view representation system perspective related set concerns 
generally accepted architecture description composed multiple views terminology related views widely accepted 
refer ieee standard 
ieee view conforms viewpoint 
view describes particular system viewpoint describes rules conventions create depict analyze view viewpoint 
viewpoint specifies kind information put view 
architectural viewpoints views key aspect symphony 
forward design different architectural viewpoints useful separating engineering concerns reduces complexity design activities 
resulting design captured separate views separation target source layer uses layer layer contains program layer contains table joined table program table program enforces integrity constraint layer table program uses program program copies file conforms naming convention layer prescribes naming convention program uses db utility parameter list table primary key column list table index column list column list compared column list 
viewpoints assessment case 
concerns helps stakeholders architects understand architecture 
architecture reconstruction multiple viewpoints views beneficial 
different viewpoints help architect determine information reconstructed order solve problem 
existence library viewpoints generally useful gives architect basis reasoning different kinds architectural information shed light problem 
separation concerns plays role allowing architect reason separately viewpoint contribute solution problem 

source target hypothesis source view view system extracted artifacts system source code build files configuration information documentation traces 
source views discussed detailed level generally considered architectural views 
instance source view may cover syntax trees control flow graphs 
target view view software system describes implemented architecture contains information needed solve problem perform tasks reconstruction process carried 
hypothetical view describes architecture system accurately 
designed architecture check conformance implemented architecture norm 
postulated architecture describing current understanding architecture system guide reconstruction 
view typically created interviewing system experts examining existing documentation 
illustrate roles source target hypothetical views take look reconstruction conducted part quality assessment system written cobol 
hypothetical view case consisted documentation presentations offered system supplier argued reason concerns quality system layering customization data handling mechanisms included architecture 
guide design target model finding potential architectural violations 
data flow actor problem elicitation stakeholders problem statement library viewpoints concept determination source viewpoints mapping rules target viewpoints source viewpoints data gathering problem statement target viewpoints information interpretation refinement knowledge inference process designer reconstructor 
interaction reconstruction design 
selection relations contained source target views shown 
relations grouped module viewpoint row data viewpoint second row 
target view provides architectural perspective system implemented source view includes relations readily derived system source code 
example target model includes create read update delete information indicating components manipulate data elements 
cases information may directly available sources program file contains sql statement 
system hand source model complex data manipulation encapsulated generated data utilities requiring analysis control calls utilities data flow parameters passed utility 
target model recovered helped identify layering violations data integrity checks bypassed ad hoc mixture custom product code complicating upgrades product releases 

symphony steps symphony stages 
reconstruction design problem analyzed viewpoints target views selected source views defined mapping rules source target views designed 
reconstruction execution analyzes system extracts source views applies mapping rules populate target views 
typically stages iterated reconstruction execution reveals new reconstruction opportunities lead refined understanding problem refined reconstruction design 
source viewpoints target viewpoints mapping rules evolve process 
outcomes symphony twofold reconstruction design results defined procedure reconstructing architecture system 
procedure may useful scope current reconstruction play role continuous architecture conformance checking reconstructions 
reconstruction execution yields architecture description needed solve problem triggered original reconstruction activity 
data data flow actor data gathering source views source views target views repository map knowledge inference reconstructor target views architectural information views interpretation stakeholders 
reconstruction execution interactions 
various symphony reconstruction steps illustrated figures 
design steps include problem elicitation concept determination discussed section 
execution steps include data gathering knowledge inference information interpretation discussed section 
reconstruction design reconstruction design distinguish problem elicitation problem triggering reconstruction analyzed discussed stakeholders concept determination architectural concepts relevant problem hand recovery strategy identified 

problem elicitation reconstructing architectures requires software architecture experts study system active involvement stakeholder representatives testers developers management business owning system system users 
people usually strong demand places project organization 
compelling reason start reconstruction 
typical reasons include performance problems high maintenance costs poor reliability considerations concerning system replacement system extensions 
reasons typically collected short page memorandum offering management perspective problem hand 
memorandum forms starting point software reconstruction activity step elaborate problem statement 
purpose symphony problem elicitation step requires involvement technical people problem analysis 
experience individual technical people involved system development typically fairly idea specific technical problems area expertise database administration networking user interfaces 
problem elicitation step different perspectives integrated picture 
techniques problem elicitation structured workshops checklists role playing scenario analysis 
example assessment case discussed previously started workshop stakeholders invited 
particular case participant asked report best worst experience system analyzed 
outcomes symphony problem elicitation step include summaries interviews workshop sessions relevant discussions summaries available high level relevant documentation available elaboration refinement problem statement summaries initial list documentation resources reconstruction 
observe original memorandum collected summaries refined problem statement may architecture agnostic expressed terms familiar stakeholders 
translation perceived software architecture concepts purpose concept determination step 
diversity motivations architecture reconstruction exemplified different case studies lead design symphony 
assessment nokia case true industrial cases 
conducted academic realistic setting better understand architecture reconstruction 
mentioned earlier detailed description case studies appendix 
assessment case 
assessment case partly described involves assessment quality characteristics commercial software product written cobol customized particular client 
course customization process took years client grew concerned data integrity reliability maintainability 
independent assessment commissioned help decide continue project 
source code documentation available assessment 
nokia case 
products nokia typically organized product families order reduce development costs maximize reuse assets 
architects needs summarized follows comprehending architecture products managing organization components logical dependencies platform enforcing conformance architectural rules 
main goal provide architects date information reconstructing architectural views typically design 
compiler case 
case built architectures large complex compilers compared architecture 
actual motivation evaluate extension original reflexion method murphy case study viewed realistic task built architecture compared idealized architecture 
duke bank case 
goal reconstruction understand duke bank determine abstractions system 
motivation learn target viewpoint extracted viewpoint hypothetical view maps mapping rules source viewpoint specifies specifies specifies specifies target view compared hypothesized architectural fact hypothetical view abstracted map implementation fact source view 
viewpoints views symphony reconstruct done efficiently examples 
additional challenge case study exercise reconstruction shelf tools rational rose grep emacs 
concept determination problem understood concept determination step determine architectural information needed solve problem way derive information 
step architect process designer defining architectural reconstruction take place final steps 
outcomes step described remainder section 
uml diagram summarizes relationships involving viewpoints mapping rules produced step 
identify potentially useful viewpoints 
step defining target viewpoint identify set viewpoints contain information stakeholders believe needed solve problem described problem elicitation 
stakeholders typically know viewpoints useful initial ideas 
getting input stakeholders architect review problems questions looking additional useful viewpoints 
architect responsible producing list viewpoints ultimately stakeholders agree 
viewpoints come library known viewpoints new viewpoint created specific reconstruction 
problem understood identify viewpoints interest problem elicitation step re applied 
commonly viewpoints architecture reconstruction module viewpoint 
identifies layers subsystems modules system describes relationships usage dependency decomposition 
common viewpoints code architecture viewpoint describes directory structure build relationships execution viewpoint describes runtime entities mapping physical resources 
conceptual viewpoint describing functionality system terms components connectors commonly reconstruction view difficult reconstruct 
see examples styles term viewpoints 
module viewpoint case studies 
nokia duke bank cases code execution conceptual viewpoints addition assessment case study viewpoints data customization addition module 
reconstruction may useful create new viewpoints ones forward design 
example reflexion model murphy notkin 
reflexion model usage dependency relationship standard module viewpoint 
contains relationships convergence divergence absence indicate usage dependencies reflected source code conform hypothetical view 
define refine target viewpoint 
shows target viewpoint specifies target view output reconstruction process 
stakeholders agree target viewpoint 
useful approach creating target viewpoint stakeholder view tables described adapted somewhat reconstruction 
original form step process culminating prioritized list views needed documenting software system 
symphony step producing candidate view list begins potentially useful viewpoints identified 
listed extent important solving problem 
second step identify specific relationships viewpoint needed 
third step prioritize relationships eliminate duplicates 
process architect thinking similarities relationships derived critical solving problem try consolidate arrive set relationships target viewpoint 
relationships target viewpoint come standard viewpoint 
example duke bank case ee application servlet forward jsp include 
initially covered adding module forw incl module relationship target viewpoint 
refinement relationship combined usage dependency relationship determination safely outset 
example summarizes murphy notkin reflexion terms symphony 
target viewpoint contains relations extracted mod starting viewpoint target viewpoint source viewpoint mapping rules reflexion module convergence module dir contains dir relation file maps module variant module divergence module dir contains file rules module view module absence module func alloc file fi calls fj fi alloc maps mm module view module module func calls func 
mm mn maps fi calls fj module module mm mn maps fi calls fj mm mn trace target module module mm convergence mn mm mn mm mn source view maps mm divergence mn mm mn mm mn func calls func mm absence mn mm mn mm mn 
viewpoints mapping rules reflexion example ule reflexion viewpoints 
compiler case study reflexion starting point initially target viewpoint 
course reconstruction clear target viewpoint needed modified support hierarchies modules second iteration relationship module contains module added 
define refine source viewpoint 
source viewpoint specifies source view 
source view contain information extracted source code gathered sources source viewpoint formally describes information 
challenge defining source viewpoint determine information needed order create target views 
defining source viewpoint needs done conjunction defining mapping source target viewpoint 
reflexion example source viewpoint contains architectural lower level information directly extracted code 
true case studies automatically extractable facts formed basis source viewpoint relied addition relationships populated manual interpretation sources 
instance compiler case inspect results overly conservative automatic pointer analysis filter obviously wrong results 
assessment case study second iteration refine source viewpoint 
iteration definition source viewpoint driven information existing tools produce 
inadequate producing desired target viewpoint second iteration refined mapping expanded source viewpoint 
define refine mapping rules 
mapping rules ideally formal description derive target view source view 
realistically parts form heuristics guidelines informal approaches 
mapping completely formalized reconstruction fully automated 
said earlier typically possible software architecture expect mapping contain formal informal parts 
shows mapping rules specify map 
mapping rules entity association class connect ing target viewpoint source viewpoint 
describes maps association entities 
map instantiation mapping rules describes specific implementation facts source view abstracted architectural facts target view 
case studies reflexion example mappings contain informal parts 
reflexion example assessment case study relation file maps module manually populated produce map 
rest mapping set formal rules compute target views 
similarly mapping nokia case study relies primarily series transformations formalized relational algebra 
extreme mapping duke bank case study contains number rules entities ee applications related provided partial information creating map 
map creation done manually 
determine role viewpoint hypothetical views 
addition activities stakeholders architect determine hypothetical view needed role 
role depends purpose reconstruction 
common roles hypothetical view guide reconstruction activity baseline compare system current architecture 
serving baseline ways comparison done 
create explicit comparison view comparison embodied target view 
reflexion example compiler case study target view identifies modules identifies usage dependencies match hypothetical view 
part target viewpoint relation specifies hypothetical view called high level model 
second way hypothetical view baseline informally 
case step information interpretation 
typically architect browses target view hypothetical view compares results may decide perform iteration reconstruction process modifying target viewpoint source viewpoint mapping combination 
nokia assessment case studies hypothetical view guidance baseline 
cal view guided definition target viewpoint helped populating map served baseline information interpretation 
hypothetical view viewpoint defined 
hypothetical view embedded target view reflexion example viewpoint defined part target viewpoint 
shown containment relationship viewpoints 
hypothetical view embedded typically viewpoint similar target viewpoint comparison straightforward 
shown extracted relationship viewpoints 

reconstruction execution reconstruction execution extract approach tailored specific needs architecture reconstruction 
steps populate source view apply mapping rules create target views interpret results solve problem hand 

data gathering intent 
goal data gathering step collect data required recover selected architectural concepts system artifacts 
motivation truth actual concrete architecture sources 
general look artifacts system just source code 
artifacts include system makefiles unit tests configuration files data gathered stored repository processed knowledge inference step 
examples 
types data gathered case studies described 
facts low level expressing knowledge terms source code elements term source views 
knowledge inference facts abstracted lifted higher levels 
techniques 
techniques data gathering divided static dynamic analyses system 
static analyses analyze system artifacts obtain information valid possible executions program structure potential calls different modules 
dynamic analyses collect information system executes 
results analysis typically valid run question guarantees runs 
dynamic analysis done tracing execution paths profiles code analyzing patterns sequences dependencies 
traces collected code instrumentation debugging profiling tools connecting prepared runtime environment 
note kinds analyses necessarily developed team recover architecture 
suitable results imported wide range reverse engineering tools clustering tools data flow analysis tools 
practice pragmatic mix match approach data gathering applied combining results various extraction tools scripting glueing example unix utilities split awk 
look little methods extracting facts textual artifacts program code technique data gathering 
detailed discussion various methods source model extraction refer related described :10.1.1.13.1027
manual inspection 
experiences show data needed reconstruction project easily gathered manually examining directory structure observing behavior exploring source code beacons signal aspects interest 
cases included example package structure build relations duke bank verification client server separation assessment case 
lexical analysis 
tools available perform lexical analysis textual files 
known searches text strings matching regular expression 
tools generally give little support process matched strings just print matching lines 
support available advanced text processing languages perl allow execute certain actions specific expression matched 
lexical source model extractor uses set hierarchically related regular expressions describe language constructs mapped source view 
hierarchical patterns avoids pitfalls plain lexical patterns maintains flexibility robustness approach 
case studies data gathering grep perl scripting nokia case parts assessment case parts duke bank case 
syntactic analysis 
parser approaches increase accuracy level detail expressed 
typically create syntax tree input allow users traverse query match tree look certain patterns 
relieves having handle aspects language focus interesting parts 
compiler case study uses syntactical analysis extended semantical analysis described 
fuzzy parsing 
fuzzy parsers parsers able discard tokens recognize certain parts programming language 
seen hybrid lexical syntactical analysis 
fuzzy parsers hand crafted perform specific task 
focus mainly parsing support program browsing 
typically involves extracting information regarding symbol global definitions functions calls file includes case example relation extraction technique assessment module containment usage lexical analysis java regular expression matching dynamic program calls island grammars data flow analysis compiler variable access parsing dynamic function call parsing points analysis duke bank directory structure build relationships manual inspection directories class inheritance containment examination rational rose grep emacs nokia directory containment file inclusion function calls lexical analysis regular expression matching 
examples various data gathering techniques cases 
island grammars 
island grammars novel technique generate robust parsers grammar definitions :10.1.1.13.1027
island grammars combine detailed specification possibilities grammars liberal behavior lexical approaches 
robust parsers generated island grammars combine accuracy syntactical analysis speed flexibility tolerance usually lexical analysis 
approach suitable developing source model extractors resulting extractor single project 
docgen documentation generator assessment case uses island grammars data gathering 
semantical analysis 
additional techniques name type resolution data flow analysis points analysis improve results analyses generally syntactical basis 
example compiler case study points analysis determine accurate call graphs retrieved just applying syntactical analysis 
assessment case study simple form data flow analysis trace program calls dynamic call handler 
output 
output data gathering stage populated repository containing extracted source views 

knowledge inference intent 
goal knowledge inference step derive target view source view typically large relational data set describing implementation system 
reconstructor creates target view condensing low level details source view abstracting architectural information 
mapping rules domain knowledge define map source target view 
example mapping contains rule naming conventions combine classes modules resulting map lists class module belongs 
activity may require interviewing system experts order formalize architecturally relevant aspects available implementation iteratively augment source view adding new concepts source viewpoint 
depending degree formalization mapping step fully partly automated 
expect knowledge inference step conducted initially close cooperation system experts domain knowledge formalized automation added 
step summarized activities create map containing domain knowledge combine source view map produce target view 
practice map created iteratively iteration refining map raising level abstraction produce satisfactory target view 
techniques 
existing techniques categorized manual automatic semi automatic 
manual approaches typically simple general purpose tools manual inspection system 
may tools shrimp rigi pbs bauhaus help visualize intermediate results automated support process see example 
semi automatic approaches help reconstructor create architectural views interactive formal way 
typically rely manual definition map 
differences approaches concern expressiveness language defining transformations support calculating transitive closures relations degree repeatability process amount interaction required user types architectural views generated 
relational algebra approaches allow reconstructor define repeatable set transformations creating particular architectural view 
holt relational algebra creating hierarchical module view source code grouping source files modules calculating module dependencies 
reconstructor manually prepare containment relations new relationships inferred algebra propositions 
uses relational partition algebra rpa calculate module dependencies dependencies extracted code 
rpa check conformance extracted target view hypothetical view established design phase 
process repeatable part build process 
riva proposed method inferring architectural information relational algebra prolog 
mens uses logic meta programming prolog mapping implementation artifacts high level design checking conformance architectural rules 
light weight examples reflexion model tcl scripts defining graph transformations rigi sql queries defining grouping rules dali ad hoc graph query language 
fully automatic approaches different kinds clustering algorithms coupling file names concept analysis type inference 
case studies fall category semiautomated approaches 
map source view target view created manually 
map bridged gap conceptually different entities source entities versus logical component connectors duke bank case concrete hypothesized elements source target views mapping concrete modules hypothesized modules reflexion method compiler case 
manual map allowed propagate lift relations source entities entities target view automatically 
creation map technological organizational historical background knowledge domain knowledge required 
instance duke bank case leveraged knowledge web applications ee infrastructure recommended design patterns 
ee types provided information file executes container classes separate components 
design patterns helped identify data transfer classes helper classes 
application functionality guided decisions creating interfaces combining classes modules determining connectors 
mapping difficult hidden dependencies 
interesting experience duke bank case instance identification logical hidden interfaces 
explicitly visible source code discovered studying control flow application data sharing classes explicit dependencies 
obviously quality data gathering key successful knowledge inference 
realization poor data quality forces reiterate data gathering different means 
output 
output enriched structured repository source view domain knowledge combined create target view 

information interpretation intent 
target views selected address particular problem inspected interpreted eventually applied solve problem 
ends target views need accessible physically mentally stakeholders 
motivation 
views result knowledge inference answer problem provide foundation address problem 
information interpretation drawn reconstructed views 
lead measures taken remedy problem 
measures part reconstruction process 
ideally viewpoints selected allow immediate views viewpoints carefully tailored difficult get answer level target views may span huge information space 
cases presentations required information space amenable stakeholders 
presentation readable traceable 
readability relates ability easily find grasp relevant information views traceability allows trace inferred knowledge back original data 
techniques 
scope presentation artifacts aspects form selected viewpoints target views 
viewers task achieved stated problem elicitation 
focus presentation interaction issues 
selected viewpoints define vocabulary semantics representation define information 
information presentation addresses problem take presentation quite liberally means communicate information viewer textually graphically forms human perception including form interaction presentation 
sight addressed form human perception information presentation software architecture domain narrower term visualization perception 
presentation issues effective visual communication including visual vocabulary specific visual elements convey particular kinds information organization visual information order material viewer 
application domains conventions symbology visual vocabulary elements 
due lack space refer reader overviews software visualization literature 
want point graphs natural visualization architecture elements binary relations confirmed independent surveys indicate popularity class object diagrams uml just graphs predefined semantics rendering characteristics 
compiler assessment nokia case studies graphs convey information 
aspect interaction refers way visualization constructed 
visualizations range hard wired viewer influence presentation arbitrary redefinition viewer 
visualizations static pictures offer querying zooming navigation cross hierarchies selective hiding gathering transitive relations 
case studies standard elements hyperlinked html pdf documents embedded uml diagrams nokia assessment cases 
uml duke bank case diagrams crafted manually 
simple types visualization textual ones tables appropriate assessment case tables metrics 
nokia assessment compiler cases visualizations zooming filtering capabilities 
believe case studies benefited advanced carefully selected means visualization 
visualization issues brought afterthought potential visualization partially leveraged 
reason shortcoming simply means presentation chosen case studies opportunistically selected available tools 
focus cases solve problem quickly available tools 
initial processes repeated expect maturity improve careful consideration presentation issues 
particular problem software architecture need understand combination multiple views complicated views conceptually different viewpoints 
suggestions view fusion problem 
views overlap entities certain inferences map entities immediate correspondence entities view 
instance kazman re lifting operations containment relations fuse views 
entities may mapped source code leverage overlapping source code regions identify entities 
simple correspondence mapping typically manual 
rice instance systematically cross related entities distinct views ross model tie process structured analysis integrate views 
cross created part symphony knowledge inference form maps stored connection views explicit 
may implemented inserted views available frameworks :10.1.1.54.8082
multiple views occured case studies compiler case mapping dependencies propagated source target entities visualized 
output 
output information interpretation hyperstructure offering holistic perspective software system foundation investigating concrete architecture impact problems signaled 
hyperstructure includes traceability links views links software artifacts source text relevant documentation ideal hyperstructure allows explore system various levels abstraction lets zoom zoom sources architecture navigate views 

concluding remarks symphony software architecture reconstruction process incorporates state practice reconstruction problem driven uses rich set architecture views provides guidance performing reconstruction including pointers applicable technology allows specific reconstructions systematically compared allows reconstruction approaches systematically compared 
symphony consists stages 
stage problem elicitation concept determination produces repeatable reusable reconstruction strategy creates views necessary address original problem 
ultimate goal problem dependent viewpoints created refined concept determination phase reusable output stage 
second stage symphony concerns execution reconstruction strategy 
stage operates level views constrained viewpoints created 
outcome foundation addressing problem particular reconstruction carried 
secondary outcome sequence mappings source views target views 
sequence allows trace back information views artifacts derived 
shares real life reconstruction experience presenting comparing different case studies 
reconstruction practice problem driven fixed set views ones chosen solve particular problem 
viewpoints practice confined module viewpoint typically research literature 
viewpoint selection definition important part symphony process 
viewpoints specify input output activity allows decompose reconstruction process systematically review outcome activity 
addition reuse activity defined reconstruction process building block compose new reconstruction processes 
symphony applied academic industrial case studies unifies existing reconstruction techniques methods 
process model described allows readers leverage experience setting architecture reconstruction efforts 
provide step step methodology followed give pointers selection appropriate techniques methods phases 
addition symphony provides common framework classifying comparing various techniques methods described literature 
common helps people report reconstruction efforts uniform way easily understand 
symphony research tool helps find demarcate research problems software architecture reconstruction 
example symphony viewpoint emphasis calls catalog reconstruction methods techniques experiences organized viewpoints 
raises question reconstruction specific viewpoints exist 
symphony inclusion mappings source target views suggests finding systematic way discover describe mappings key research question 
problems hard tackle 
symphony possible address case case basis offering process model way classify compare results 
arie van deursen leon moonen received partial support delft university technology project moose cwi project ide als hosted embedded systems institute 
anderson taylor whitehead jr chimera hypertext heterogeneous software environments 
proc 
european conference hypermedia technology 
acm 
keller 
software visualization tools survey analysis 
proc 
int 
workshop program comprehension iwpc pages 
ieee cs may 
chase harris yeh 
manipulating recovered software architecture views 
proc 
int 
conf 
software engineering icse pages 
acm 
clements bass garlan little nord stafford 
documenting software architectures views 
addison wesley 
van deursen kuipers 
building documentation generators 
proc 
int 
conf 
software maintenance icsm pages 
ieee cs 
van deursen kuipers 
source software risk assessment 
proc 
int 
conf 
software maintenance icsm 
ieee cs 
devanbu chen gansner ller martin 
customizable hyperlink insertion maintenance engine software engineering environments 
proc 
int 
conf 
software engineering icse 
acm 
ding medvidovic 
light weight incremental approach software architecture recovery evolution 
proc 
working conf 
software architecture pages 
ieee cs 
van 
relational approach support software architecture analysis 
software practice experience 
holt kerr kontogiannis ller mylopoulos stanley wong 
software bookshelf 
ibm systems journal oct 
guo kazman software architecture reconstruction method 
proc 
working conf 
software architecture pages 
ii rice 
architectural metaphor foundation system engineering 
proc 
ann 
symp 
int 
council systems engineering 
nord 
applied software architecture 
object technology series 
addison wesley 
holt 
structural manipulations software architecture tarski relational algebra 
proc 
working conf 
reverse engineering wcre 
ieee 
ieee recommended practice architectural description software intensive systems 
kazman re 
view extraction view fusion architectural understanding 
proc 
int 
conf 
software reuse 
knight munro 
mediating diverse visualisations comprehension 
proc 
int 
workshop program comprehension iwpc pages 
ieee cs may 

systematic approach fuzzy parsing 
software practice experience 
koschke 
software visualization software maintenance reverse engineering reengineering research survey 
journal software maintenance evolution 
koschke simon 
hierarchical reflexion models 
proc 
working conf 
reverse engineering wcre 
ieee cs nov 
laine 
role sw architectures solving fundamental problems object oriented development large embedded sw systems 
proc 
working conf 
software architecture 
mens 
automating architectural conformance checking means logic meta programming 
phd thesis departement informatica vrije universiteit brussel 
moonen :10.1.1.13.1027
generating robust parsers island grammars 
proc 
working conf 
reverse engineering wcre pages 
ieee cs oct 
moonen 
exploring software systems 
phd thesis faculty natural sciences mathematics computer science university amsterdam dec 
murphy notkin 
lightweight lexical source model extraction 
acm transactions software engineering methodology july 
murphy notkin sullivan 
software reflexion models bridging gap design implementation 
ieee cs transactions software engineering apr 

method module architecture verification application large component system 
information software technology 
riva 
architecture reconstruction practice 
proc 
working conf 
software architecture 
ross 
removing limitations natural languages principles rsa language 
proc 
software engineering workshop 
academic press 
brien verhoef 
practice patterns architecture reconstruction 
proc 
working conf 
reverse engineering wcre 
ieee cs 
tilley paul smith 
framework program understanding 
proc 
int 
workshop program comprehension iwpc pages 
ieee cs 
wiggins 
overview program visualization tools systems 
proc 
th annual southeast regional conf pages 
acm 
case study descriptions appendix provide descriptions reconstruction case formed starting point symphony 

compiler case study problem elicitation purpose reconstruction compiler case study find actual architectures existing compilers conform canonical architecture compilers 
large complex compilers analyzed compiler microcontrollers kloc cc compiler kloc gnu compiler collection gcc 
resources available case study source code compilers compiler architecture described textbooks compiler design background knowledge building compilers bauhaus toolkit program analysis architecture reconstruction 
source target viewpoints mapping extension reflexion method perform comparison actual architectures architecture 
source target viewpoints described 
source viewpoint target viewpoint dir contains dir module convergence module dir contains module module divergence module module contains declaration module convergence module declaration depends ona module contains module declaration module depends ona module module depends module 
viewpoints compiler case depends denotes actual declarations derived source code 
types extracted summarized 
iterations iterations design stage symphony 
target viewpoint refined adding hierarchical modules 
original reflexion type description static call statically bound call function dynamic call call function pointer access set address taken variable record component access address taken function signature type occurs function signature type type variable record component local var type function local variable type type type uses type declaration 
extracted types 
method murphy colleagues non nested modules hypothetical module viewpoint 
typical compiler architectures described varying levels detail 
reason extended target viewpoint allowing nested modules 
extension required adjust original definitions convergence divergence absence reflexion model 
second refinement required source viewpoint 
compilers just direct calls calls function pointers 
indirect calls added source viewpoint 
iterations execution stage mapping source entities modules hypothesized target view hypothetical target view refined 
data gathering data gathered parsing global name type resolution 
resolve function pointer calls statically steensgaard pointsto analysis analyses supported bauhaus toolkit 
information interpretation resulting reflexion model naturally graph 
bauhaus toolkit offers graph visualization navigation tool supports nested graphs source code views 
nodes edges graph traversable linked source 
way resulting reflexion model browsed divergences investigated easily 
outcome case study comparisons actual architectures architecture comparison actual architectures 
different architectural patterns architectural anomalies actual architectures 

symphony nokia nokia worldwide telecommunication developing telecommunication terminals 
products typically organized product families order reduce development costs maximize reuse assets 
past years developed architecture reconstruction process nokia product family referred 
section recast reconstruction process symphony process model 
nokia sensitive details omitted possible diagrams simplified possible 
problem elicitation 
evolved small set products software platform developing tens products 
evolution driven consolidation family assets platform development new features various products 
architects need clearly understand control assets available platform ensure architectural rules respected products 
needs summarized follows comprehending implemented architecture products man directory contain file include contain class method file call method call def func function event message library package component hw driver server event message entity application message call system task service 
source target viewpoints 
aging organization components logical dependencies platform enforcing conformance architectural rules 
main goal provide architects date information reconstructing architectural views typically design 
concept determination discussions architects current design documentation suggested viewpoints match architects needs component view logical components interfaces logical relationships task view task allocation inter task communication development view organization source code dependencies deployment view physical location components processing units feature view run time implementation feature organizational view organization development activities projects programs sites 
target viewpoint determined architecture describing architectural styles rules conventions products discussions experts 
target viewpoint shown gray entities source viewpoint 
approach guarantees correct level abstraction granularity satisfy needs architects 
data gathering 
entities directly detectable source code directory file function server application service recovered processing source code scripts regular expressions commercial front ends 
choice technology depends accuracy want target views 
entities system package component hw driver library recovered interviewing architects 
purpose fill component inventory database information components type interfaces intended architects ownership hierarchical organization components packages mapping compo nents source files 
union gathered data component inventory represents source view 
knowledge inference target views derived source view series transformations formalized relational algebra 
case component view select logical components interfaces hierarchical organization packages calculate logical dependencies lifting low level dependencies 
information presentation views regularly published intranet consulted development teams daily tasks 
views published simple easy interpret formats hierarchical graphs rigi hyper linked web pages uml diagrams rational rose 
diagrams allow users browse various dependencies high low level starting top level packages 

duke bank symphony problem elicitation ultimate goal duke bank reconstruction determine best describe software architecture kind tools useful reconstructing architecture ee web 
subgoal simply understand architecture 
resources resources available online tutorial document source code duke bank 
conceptual module execution code architecture views starting point determining target viewpoints 
general purpose tools grep emacs rational rose exploratory reconstruction 
iterations shown process began iterations having different target viewpoint 
fifth iteration served refine module view knowledge gained previous iteration 
similarly sixth iteration served refine conceptual view reflect final module view produced previous iteration 
seventh iteration code execution architecture views refined order reflect modules module view 
second iterations class assumed separate module 
data gathering data gathering general purpose tools manual 
code arch view examine directories 
execution view observe executing application review ee documents 
module view rose grep emacs read source code 
conceptual view observe behavior application read source code read diagrams duke bank tutorial 
starting viewpoint target viewpoint source viewpoint mapping code arch view module allocated file directory structure class name matches file name iteration module deployable file package structure java rules packages jar file file names treat class module second cross view module instantiated container build relationships rules file types iteration execution view container executes process deployable file read instantiated process alloc host machine process jvm container types third module view module provides interface method calls method rules combining iteration module uses interface class fwd incl class methods interfaces module uses module class contains method classes modules module contains module identify logical interfaces trace target source module contains class module fwd incl module fourth conceptual view input form sent component navigation map identify connectors iteration component displays page tracing source code rules execution port attached role page contains input form behavior ee types component port connector role servlet jsp 
viewpoints mapping rules duke bank knowledge inference knowledge inference done manually relied heavily domain knowledge 
code arch view straightforward 
execution view apply ee rules component types 
module view create interfaces methods combine classes modules identify data transfer classes helper classes refine combining forw incl uses refine adding module knows module refine adding logical interfaces 
conceptual view determine connectors split pages input forms group processing tier 
information interpretation standard techniques document software architecture duke bank 
code arch view tables 
execution view diagram 
module view set diagrams focuses different part system dispatcher relationships separate diagram 
conceptual view set diagrams user navigating page resulting response atm link atm page atm response 
addition resulting documented software architecture reconstruction uncovered open questions resolved reconstructions applications 
issue small granularity components conceptual view modules module view driven different characteristics different ee class types servlet jsp entity bean 
existing extraction tools adapted extract information source view certain information implicit amenable automated extraction 
mapping formal certain part need manual input identifying components connectors interfaces modules 

assessment case problem elicitation reconstruction conducted support assessment quality characteristics commercial software product written cobol customized particular client 
characteristics investigated include reliability maintainability data integrity 
resources resources available reconstruction included documentation various levels abstraction full source code 
selected stakeholders available interviews lead architect supplier representatives teams responsible data migration system customization deployment problem owner business representatives 
views important views included module data customization component connector views 
selected source target relations data module view shown 
viewpoints chosen help address concerns raised client purchasing customizing system 
target model recovered helped identify layering violations data integrity checks bypassed ad hoc mixture custom product code complicating upgrades product releases 
iterations model evolved populated number iterations 
organize stakeholder workshop describe problems discussed identify relevant information get impression relevant views 

automated source code analysis existing cobol tools docgen 
tools data gathering java regular expression library inference sql querying java programming presentation graph visualization html tabular information metrics 

analyze layers module view 
partition programs naming conventions 

analyze table usage data view 
discovered docgen table analysis insufficient case hand 
additional information required included joins indexes integrity checks 
extracted perl 

analyze customization code variation points 
partition system product custom code naming conventions 
addition try opportunistic search customer names expected customization key words product find violations 

client server protocol analysis 
identify servers clients documentation 
analyze underlying communication protocol reverse engineering protocol code hand 
criticize propose alternative standard protocols 
steps done strictly sequential different people working parallel 
step included browsing searching models obtains far focusing particular trends outliers file size revision fan fan number table columns 
