analysis dpa countermeasures randomizing binary algorithm hasan department electrical computer engineering centre applied cryptographic research university waterloo ontario canada june major threats security cryptosystems nowadays information leaked side channels 
instance power analysis attacks successfully mounted cryptosystems embedded small devices smart cards 
past dpa countermeasures proposed 
countermeasures proposed oswald aigner ha moon inserting random decisions execution algorithms compute elliptic curve ec scalar multiplication redundant binary signed digit bsd representation scalar 
important advantage algorithms recoded scalar need stored 
report investigate ect countermeasures execution paths taken scalar multiplication algorithms average computational complexity 
enables comparison countermeasures 
appears increasing trend adapting elliptic curve cryptography di erent security purposes 
elliptic curve cryptosystems suitable implementation devices limited memory computational capability smart cards limited power wireless devices 
due fact elliptic curves large finite fields provide security level cryptosystems rsa smaller key sizes 
nowadays mathematical strength cryptosystem implemented devices smart cards personal wireless devices ensure security keys stored 
inevitable check resistance devices side channel attacks 
side channels include execution time power consumption electromagnetic computational faults 
discuss briefly power analysis attacks class countermeasures 
main types power analysis attacks kocher simple di erential power analysis attacks referred spa dpa respectively 
monitoring power consumption cryptographic token executing cryptographic algorithm manipulates secret key 
traces measured power analyzed obtain significant information key 
cases key totally compromised search space key reduced computationally size 
spa single power trace reveal large features algorithm executed iterations loop 
cryptosystem specific operations point doubling adding identified 
hand dpa relies collecting hundreds power traces executions algorithm key 
traces classified groups criterion internal representation intermediate results 
traces group averaged trace di erence averaged values computed 
averaging techniques usually reduce noisy components signal strengthening relevant information di erential signal case 
dpa attack general powerful spa attack 
attack kocher successfully applied data encryption standard des implementation needed monitor encryptions recover secret key 
show side channel information maximized 
described number power analysis attacks smartcard implementations modular exponentiation algorithms 
drawn attention naive implementations smart cards highly vulnerable spa dpa proposed countermeasures attacks 
specially counteract dpa attack proposed randomizing private exponent blinding point randomized projective coordinates 
di erent approach ec scalar multiplication dpa attacks proposed oswald aigner ha moon 
randomizing number sequence execution operations scalar multiplication algorithm 
randomization consists inserting random decision process building representation scalar algorithms randomization applied originally proposed speed ec scalar multiplication 
replacing binary representation integer scalar exponent representation fewer number nonzero symbols allowing negative symbols inserted bsd representation integer 
yields fewer number executions point addition field multiplication ec scalar multiplication exponentiation algorithm algorithms proposed computing referred canonical bsd known sparse naf representation integer mention countermeasures defeat variants spa attack fact versions oswald aigner countermeasure sakurai walter respectively 
note context exponentiation cryptosystems representation integer negative symbols may costly traditional square multiply method 
negative symbols exponent field division field inversion performed 
signed digit representation exponent possibly scanned left right algorithm division done constant 
attacks single measurement power consumption reveal significant information distinguished point doubling adding operations measurement may needed infer key value reduce key search space 
karlof wagner proposed general cryptanalysis model randomized algorithms totally recover bit key traces applied oswald aigner countermeasures 
take account measurement errors noisy side channel case recover average key bits traces 
entire key testing bit error patterns meet middle search 
model expected applicable ha moon countermeasure 
cryptanalysis randomization techniques depends distinguishability point doubling point addition subtraction operations power traces occurrences single doubling iterations addition doubling 
randomization techniques useful counteract dpa attacks adding countermeasures 
example randomization algorithm double add algorithm making adding operation performed iteration collecting result needed 
spa countermeasure proposed 
remedy point addition point doubling operations require exactly field operations executed unified code hardware distinguished power trace case hessian form elliptic curves jacobi form elliptic curves 
report analyze randomization algorithms oswald aigner ha moon 
investigate ectiveness produce possible representations integer 
discuss complexity analysis markov chains model grammatical specification method 
countermeasure report new result average case complexity analysis methods 
second countermeasure complexity analysis markov chains authors confirm results grammatical specification method 
report organized follows 
section briefly binary algorithms ec scalar multiplication 
section overview speedup algorithms proposed morain 
section discusses dpa countermeasure proposed oswald aigner complexity analysis 
section canonical recoding approach application ec scalar multiplication 
section discuss dpa countermeasure proposed ha moon complexity analysis 
concluding remarks section 
elliptic curve scalar multiplication elliptic curve set points solutions bivariate cubic equation field general equation defining elliptic curve form xy field gf characteristic equation transformed xy gf 
elliptic curve consisting set points special point called point infinity 
set points equipped abelian group structure addition operation 
elliptic curve addition point group identity point denotes elliptic curve group operation addition 
ec characteristic point inverse defined 
addition elements field calculated bit bit xor inverse available extra cost 
point result addition follows 
point addition point doubling require field inversion field multiplications field squaring 
consider operations binary fields having computational cost 
elliptic curve scalar multiplication scalar multiplication group points elliptic curve analogous exponentiation multiplicative group integers modulo fixed integer fundamental operation ec cryptographic systems 
scalar multiplication denoted kp result adding point times positive integer kp copies kp 

binary representation 
kp kp computed straightforward double add approach iterations 
fact algorithms 
algorithm corresponds expansion scans bits scalar right left significant bit significant 
second scans bits left right 
algorithms analogous square multiply algorithms employed exponentiation cryptosystems 
algorithms known binary algorithms section 
algorithm 
scalar multiplication right left double add input output kp 

algorithm 
scalar multiplication left right double add input output kp 

practical purposes case gf assume algorithms require elliptic curve operations average 
inverse point obtained extra computational cost algorithms modified double add subtract das algorithms binary signed digit bsd representation 
report refer symbols bsd representation 
able easily di erentiate binary symbols referred bits 
number representation exceed number bits binary representation 
nonadjacent form naf bsd representation 
characterized having minimal hamming weight fewest nonzero coe cients bsd representations 
representation das algorithms require elliptic curve operations average 
survey di erent approaches speeding elliptic curve scalar multiplication refer 
known ternary balanced notation 
morain addition subtraction chains addition chain integer list positive integers kw know addition chain length compute ec scalar multiplication kp exponentiation point addition operations multiplications topic addition chains extensively studied see example 
finding best addition chain impractical find near optimal ones 
algorithms exist binary algorithm see section variations see implementation method 
morain studied briefly called addition subtraction chains 
defined kw pointed addition subtraction chains mainly important ec computations inverse point obtained extra cost 
coming discussion focus ec scalar multiplication techniques applicable exponentiation 
algorithms morain form automata 
automaton idea comes observation consecutive binary representation integer result point additions 
instance compute kp algorithm perform operations algorithm algorithms perform point additions point doubling count doubling addition 
allow bsd representation add leftmost result obtained follows point doubling subtraction 
underlying principle replace block binary representation integer block 
automaton illustrated implements transformation automaton 
inputs automaton output kp initial condition bits integer scanned right left 
bit scanned refer triggers transition state 
states represented circles transitions arrows corresponding bit scanned 
resulting bsd representation refer mentioned explicitly deduced operations performed transition operation performed indicates generated 
transition point doubling performed indicates prepended transition point addition resp 
subtraction point doubling performed indicates resp 
prepended transition point addition resp 
subtraction point performed indicates resp 
right left prepended analyze cost automata morain approach grammatical specification see appendix 

language recognized automaton belong binary representations integers having significant bit scanned starting significant bit 
grammar generates terminal alphabet nonterminal alphabet corresponding states transformation initially proposed booth automaton respectively 
start symbol shown graph dummy state leads directly scanning input symbol 
productions productions transformed system equations variable represent terminal alphabet symbols variable added account cost transition exponent number ec point operations 
zt zu zu zu system equations solved maple outlined appendix obtain generating function expected cost automaton authors means average number additions subtractions compared binary algorithm saving number additions total number operations 
automaton extension transformation automaton deal case isolated block binary representation integer transformation previous automaton replaced transformation implemented automaton illustrated di erence second automata state named introduced take account isolated stream bits scanned 
note transformation adopted automaton generates sparse form naf integer authors analyzed automaton method automaton refer reader production rules corresponding system equations 
cost analysis showed expected cost means average number point additions subtractions performed agreement 
saving number additions compared binary algorithm saving total number operations 
authors noted actual implementation automaton optimized noticing arcs leave state leave state 
automaton 
oswald aigner countermeasure countermeasure dpa attacks ec scalar multiplication oswald aigner proposed randomization technique morain automata section 
application technique automaton see 
refer reader authors application technique automaton 
actual implementation randomized version automaton optimized way original automaton 
note authors applying randomization automata rearranged distribution addition subtraction doubling operations corresponding di erent transitions 
transition point doubling point addition subtraction point doubling performed 
say order spa attacks di cult 
counteract dpa attacks randomized algorithm follows di erent path time executed secret scalar state state bit scanned random variable drawn 
algorithm follows original path proceeds back state perform point addition point doubling way binary algorithm 
results di erent sequence operations performed time algorithm executed di erent intermediate points computed 
interchanged values original transitions departing state bit scanned 
order consistent transitions depend value randomized version automaton 
analysis randomized algorithm analyze ectiveness algorithm randomness bsd representations generated scalar corresponding ec operations performed 
analyze performance algorithm comparison binary algorithm 
example successive random decisions drawn call bsd representation generated certain run algorithm specific values 
table give di erent representations generated possible random decisions taken corresponding operations performed 
denote ec point addition subtraction doubling respectively 
table possible outcomes randomized algorithm 
case operations performed ad sd ad sd da ad sd da sd ad sd da ad ad ad sd ad ad sd da ad ad ad sd ad ad ad ad things note note transition state state point doubling performed point addition da equivalent writing output right left 
sequence da followed sd case subtraction cancels ect addition result addition subtraction operations redundant 
sequence da followed ad case sequence operations daad equivalent dda yields result 
extra addition operation 
naf representation shown section generated algorithm 
due redistribution operations performed 
original algorithm state operations performed bit scanned subtraction performed addition 
randomized algorithm addition performed scanned starting state 
suggests binary representation sparse randomized algorithm generate naf random outcomes 
cases shown table random decisions drawn di erent resulting generated representation 
means scalar binary representation contains block consecutive algorithm starts execution block intermediate point random intermediate point computed block processed probability argument applies case consecutive possible outcomes 
show argument applies block consecutive length 
length block algorithm starts scanning block state 
tuple random decisions 

assume random decision drawn 
algorithm move state generating 
point matter value remaining terms operations performed equivalent successive addition 
obvious case 

case 
sequence operations starting state equivalent dd case 
sequence operations starting state da ad sequence equivalent dda ad ad obvious mix cases covers possibilities 
yields sequence specific transition flaw algorithm exploited cryptanalysis randomized version automaton sakurai automaton walter 
intermediate point may computed instant time sequence operations may di erent 
dpa attack may take advantage flaw 
addition 
half possible values bsd representation generated long block bsd extend argument case 

case resulting bsd representation bsd forth 
considering performance algorithm authors tested algorithm thousands executions values counted number additions subtractions 
reported number binary algorithm number additions average 
analysis markov chains procedures 
analysis markov chains markov chains find limiting probability occurrence point additions subtractions proposed algorithm please refer appendix theoretical background markov chains 
basic assumptions bit integer uniformly distributed range 
bit equally probable assumption applies random bit states markov chains defined triplet denotes states algorithm 
refer states respectively 
possible state transitions shown table 
note table denotes operation performed takes value point addition subtraction performed respectively 
consider resulting random bsd representation current resulting may prepended previous ones may added subtracted position previous explained section 
transition probability matrix chain table state transition table randomized automaton 
state output state solving maple obtain limiting probability vector find probability additions subtractions conclude analysis average additional number operations oswald aigner algorithm binary algorithm 
analysis grammatical specification confirm results obtained analysis previous subsection analyzed oswald aigner randomized automaton grammatical specification method explained morain 
di erence strings recognized automaton belong language symbols language represent pair significant bit 
productions grammar generates language corresponding system equations zu zu zu zu zu zu zu solved system equations maple help documentation package part library expected cost agrees result obtained previous subsection 
canonical recoding algorithm recoding algorithm constructs canonical bsd representation naf integer scans bits starting significant bit proceeds left 
initially auxiliary carry variable set 
current bit current auxiliary carry scanned bit current bsd auxiliary carry produced assignments 
table lists values assigned di erent possible values carefully examining assignments discover approach computes computing new rule subtraction discards significant 
fact conventional pencil method add nonnegative integers gives mod carry 
carry expressed provided algorithms project inria available algo inria fr libraries software html table canonical recoding algorithm 
input output 




naf length binary representation integer bits length canonical form may 
yen intuitive formal proof algorithm uses transformation 
recoding algorithm represented state diagram illustrated 
value determines current state 
value determines transition state 
states represented circles transitions represented arrows 
outcomes transition shown triggering input arrow 
dashed arrows represent transitions discussed section 
notice behavior algorithm automaton 
fact point doubling operations rearranged identical loss generality ecting performance automaton 
assume significant bit equal morain automata operates language state diagram modified automaton 
denoted states symbols nonterminal alphabet automaton ease comparison 
productions state diagram canonical recoding algorithm 
automaton canonical recoding algorithm 
corresponding system equations zt zt zu zu zu zu expected cost exactly automaton obvious optimization applied implementation automaton applicable automaton arcs emerging states 
sake completeness consider essential include naf recoding algorithm 
derive binary expansion integer divide store remainder repeat process quotient 
derive naf integer method proposed divide repeatedly allowing remainders 
remainder choose whichever quotient division yields remainder 
algorithm 
naf computing algorithm input positive integer output naf 

odd mod compare algorithms decisions taken di erent input bits 
simplicity refer algorithms respectively 
cases case odd case mod set subtracted divided subtraction unnecessary case just shifted right bit 
equivalent case 
set change remaining bits case mod set added divided 
case addition performed division 
equivalent case 
set 
case set divided 
case mod 
value set set equal propagate carry 
canonical recoding algorithm better performance algorithm 
reason sets appropriately save carry performing subtraction addition step algorithm causing carry propagate significant bit iteration 
ha moon countermeasure prevent dpa ha moon inserted random decision algorithm constructing naf integer produces random bsd representation 
noticed outcomes algorithm auxiliary carry naf value 
equivalently represented vice versa 
insert randomness algorithm generated random bit integer 
random bits determine decision taken applicable algorithm outcome bit scanned 
may disadvantage storing random integer randomized outcomes shown table 
value ect outcomes value exchangeable values mentioned 
analysis randomized algorithm analyze performance algorithm find limiting probability symbol proposed random recoding algorithm authors modeled finite markov chain procedure 
adopted assumptions mentioned section uniform distribution integers range equal probability values bits 
defined state 
possible states state shown table 
state diagram randomized naf algorithm 
table state transition table random bsd recoding algorithm 
state output state transition probability matrix chain solving obtain probability symbol random bsd representation summing limiting probability states having symbol output 
average number point additions performed random bsd representation bit scalar algorithm 
way state diagram ha moon algorithm redrawn automaton operating language productions follows corresponding system equations zt zt zu zu zu zu zu zu zu zu expected cost automaton agreeing result obtained authors markov chains method 
comparing algorithm oswald aigner algorithm section find random decisions taken case random decisions inserted case 
fact random decision taken mod 
insert random decision algorithm ha moon algorithm 
done modifying step follows mod modification see odd remainder 
possible values remainder believed true ha moon randomization algorithm generate random bsd representation length bit integer concluding remarks considered report randomized dpa countermeasures proposed aigner ha moon original deterministic algorithms extend 
compared algorithms point view true randomness key representation generated concluded second countermeasure fact generate possible bsd representation key case 
compared average complexity analysis markov chains grammatical specifications method confirmed second countermeasure complexity binary algorithm executes point additions average 
supported part nserc natural sciences engineering research council canada ce critical infrastructure protection emergency preparedness rim research motion nserc strategic project 
james muir fruitful discussions suggestions 
appendix finite markov chains markov chain discrete time discrete valued random process 
process said state time belongs sample space markov property conditional probability mass function pmf xn xn 
xn xn means state depends state depend way state arose previous states 
process referred memoryless process 
transition probability defined ij xn xn said stationary depend transition probabilities characterized ij ij arranged matrix known transition matrix 

step transition probability defined ij computed multiplying transition matrix times retrieving th row th column 
properties apply important class finite markov chains irreducible means state reachable state finite number steps 
ergodic states recurrent transient aperiodic states 
state said recurrent revisited infinite number times infinite run process 
state said aperiodic period period state greatest common divisor number times chain starting state positive probability returning 
main theorem markov theory states irreducible ergodic markov chain steady state exists 
say state chain limiting probability defined lim ij depend vector 
chain states unique solution grammars automata generating functions grammars grammar quadruple terminal alphabet usually small letters nonterminal alphabet usually capital letters start symbol set productions rewrite rules form including nonterminal symbol 
productions common left hand side conveniently grouped production vertical bars separate production possibilities 
example grouped symbol denotes null string 
grammar context free grammar left hand side production single nonterminal symbol 
context free grammar regular grammar right hand side production string containing nonterminal rightmost symbol 
derivation step consists matching substring left hand string production replacing right hand string 
string derived certain grammar possible obtain string start symbol grammar finite number derivation steps 
set acceptable strings derived productions grammar form formal language 
deterministic finite automata deterministic finite automaton dfa quintuple set states alphabet input symbols initial state set final states transition function 
dfas represented pictorially directed graphs nodes represent states arcs labeled symbols alphabet 
initial state denoted short incoming arrow final accepting states denoted cross 
symbol arc labeled emanating state 
path graph spells string 
string recognized automaton exists path initial state finishing final state spells letters string reading labels arcs form path 
language automaton set strings recognizes 
regular grammar generates language recognized dfa specified defining terminal alphabet alphabet nonterminal alphabet set states start symbol start state productions derived transition function follows analysis algorithms generating functions greene investigated interesting property formal languages 
productions grammar treated equations replaced replaced terminal symbols replaced dummy variable equations solved start symbol result generating function number derivations grammar 
generating functions essential tool combinatorial mathematics study sequences numbers 
implanted taylor coe cients function dummy variable properties sequence studied properties 
instance denote coe cient generating function obtained grammar certain automaton language 
coe cient represents number strings length language recognized automaton 
compute expected cost algorithm studied form automaton variable inserted equations represent productions account cost transition 
accomplished making exponent variable term equations reflect cost corresponding transition 
bivariate generating function obtained number strings symbols cost terminal alphabet consists equally probable symbols case morain automata obtain referred probability generating bernoulli uniform case deduce generating function expectation coe cient series expected cost processing string length automata studied report assumed significant bit integer bits involved processing 
expected cost 
alternatively expected cost equality follows scaling property generating functions deeper study generating functions average case analysis algorithms refer reader sedgewick flajolet book series published inria research reports form preliminary chapters new book analytic combinatorics 
reports available algo inria fr flajolet publications books html 
ieee standard specifications public key cryptography ieee std 
boneh demillo lipton 
importance eliminating errors cryptographic computations 
journal cryptology 
expanded version earlier appeared proc 
eurocrypt 
booth 
signed binary multiplication technique 
quarterly journal mechanics applied mathematics 
brauer 
addition chains 
bulletin american mathematical society 
clark liang 
arithmetic weight general radix representation integers 
ieee transactions information theory 
cohen lenstra 
implementation new primality test 
mathematics computation 


resistance di erential power analysis elliptic curve cryptosystems 
koc editors cryptographic hardware embedded systems ches volume lncs pages 
springer verlag 
koc 
exponentiation canonical recoding 
theoretical computer science volume pages 

erdos 
remarks number theory iii addition chains 
acta 
greene 
labelled formal languages uses 
technical report stan cs stanford university 
ha moon 
randomized signed scalar multiplication ecc resist power attacks 
cryptographic hardware embedded systems ches volume lncs pages 
springer verlag 
hopcroft motwani ullman 
automata theory languages computation 
addison wesley second edition 
quisquater 
hessian elliptic curves side channel attacks 
cryptographic hardware embedded systems ches volume lncs pages 
springer verlag 

yen 
optimal left right binary signed digit recoding 
ieee transactions computers july 
karlof wagner 
hidden markov model cryptanalysis 
cryptographic hardware embedded systems ches sept 
appear 
knuth 
art computer programming algorithms volume 
addison wesley second edition 
koblitz 
elliptic curve cryptosystems 
mathematics computation 
kocher 
timing attacks implementations di hellman rsa dss systems 
koblitz editor advances cryptology crypto volume lncs pages 
springer verlag august 
kocher ja jun di erential power analysis 
wiener editor advances cryptology crypto volume lncs 
springer verlag 
smart 
preventing spa dpa ecc systems jacobi form 
cryptographic hardware embedded systems ches volume lncs pages 
springer verlag 
sloan 
investigations power analysis attacks smart cards 
usenix workshop smart card technology pages may 
sloan 
power analysis attacks modular exponentiation smart cards 
koc editors cryptographic hardware embedded systems ches volume lncs pages 
springer verlag aug 
miller 
elliptic curves cryptography 
advances cryptology crypto volume lncs pages 
springer verlag 
morain 
speeding computations elliptic curve addition subtraction chains 
informatique applications informatics applications 
sakurai 
insecurity side channel attack countermeasure addition subtraction chains distinguishability addition doubling 
australasian conference information security privacy volume pages 
springer verlag 

vectorial addition chains 
journal algorithms 
oswald aigner 
randomized addition subtraction chains power attacks 
koc naccache editors cryptographic hardware embedded systems ches volume lncs pages 
springer verlag 

quisquater 
analysis ema measures counter measures smart cards 
smart card programming security volume lncs pages 
springer verlag 

binary arithmetic 
advances computers 

lower bound length addition chains 
theoretical computer science volume pages 

sedgewick flajolet 
analysis algorithms 
addisonwesley 

improved algorithm arithmetic family elliptic curves 
advances cryptology crypto volume lncs pages 
springer verlag 

improved algorithms arithmetic anomalous binary curves 
technical reports corr university waterloo 
corrected updated version appearing proceedings crypto 
available www math uwaterloo ca 
walter 
security constraints oswald aigner exponentiation algorithm 
technical report cryptology eprint archive 
eprint iacr org 

