domain compression complete abstractions roberto giacobazzi dipartimento di informatica universit di le italy mail roberto giacobazzi sci 
introduce operation domain compression complete re nements nite domains 
provides systematic method simplifying domains order isolate domain exists re nement completeness semantic function returns domain 
domain compression particularly relevant compare abstractions static program analysis model checking 
case consider domain compression predicate abstraction transition systems 
keywords interpretation domains completeness domain re nement predicate abstraction model checking program analysis 
key problem designing implementing abstraction re nements way control accuracy costs 
automatic re nement quickly lead explosion domain making analysis unfeasible 
particularly evident completeness re nement sound abstraction iteratively improved complete semantics providing loss precision approximating semantics re ned domain 
completeness ideal target abstraction re nements 
known domain re nements viewed making domain complete semantic function case reduced product disjunctive completion heyting completion counterexamples model checking re nement provides algorithmic account making abstraction complete transition relation system analyze 
problem 
problem tuning re nements attacked directions widenings oracle guided widening reduce complexity re ned predicates predicate abstraction introduced speed convergence point approximation 
analogously domain simpli cation introduced domain theoretic counterpart reduce domains size complexity 
intuitively re nement operator improving precision domains simpli cations perform dual operation information domains 
context notion domain compression particularly relevant 
compressor domain simpli cation re nement domain 
holds basically re ned domain fully reconstructed generated re nement base 
related works 
notion domain compression rstly introduced interpretation connection domain re nement 
provides generalization operations domain complementation disjunctive bases 
operators respectively compressor associated reduced product disjunctive completion systematic design optimization domains static program analysis comparative semantics 
best knowledge known compressors introduced literature notion domain compression studied general point view 
notion join uniformity introduced characterize domain compressors adjoint functions domain re nements 
notion allows de nition lifted partial order making compressors monotone 
models fact compressors may take advantage structure domains leading non monotone operations standard inclusion order domains 
apart complementation disjunctive bases systematic methods deriving compressors re nement particular generic pattern known derive compressors associated completeness re nements 
main results 
consider problem systematically deriving compressors wide family completeness re nements nite domains 
characterize completeness re nement corresponding compressor provide algorithm compute base domain corresponding re nement 
base domain exists includes amount information needed generate re nements represents ort domain designer provide order re nement precision means family domains re nement canonical minimal representative base 
interest computing fold provides minimal representation domains 
particularly important designing predicate abstractions states abstracted evaluation predicate domain re ects partition predicates space states 
case derive core predicates basic partition included domain willing achieve precision degree 
compare abstractions 
impossible achieve precision re ning way round 
hide information domains 
combined domain re nement design optimal domains providing way reduce compression irrelevant information domains 
applications techniques considered static program analysis compressors domain complementation disjunctive base see 
preliminaries basic notions sets 
denotes power set src denotes erence denotes strict inclusion jsj denotes cardinality def ff xg 
hc short denotes complete lattice ordering lub glb greatest element top element bottom 
meet irreducible fa bg 
set meet irreducible elements denoted 
join dually de ned 
def fx yg 
shorthand fxg 
upward closure dually de ned 
denotes function composition def 
identity function denoted denotes isomorphism ordered structures set functions ordered point wise max def min dually de ned 
interpretation transition systems consider standard galois connection interpretation 
pair functions forms adjunction 
called left right adjoint additive additive function preserves lub glb subsets empty set included 
additive additive functions admit right resp 
left adjoint def resp 
def 
remember 
galois connection gc adjunction posets denoted 
assume concrete domain complete lattice gc respectively abstraction concretization 
addition galois insertion gi gi value domain useful representing 
domains equivalently formulated posets related gi closure operators 
second formulation advantage independent representation objects 
upper closure operator poset operator uco monotone idempotent extensive 
lower closures dually de ned 
upper lower closure uniquely determined set xpoints 
complete lattice xi def complete lattices 
particular set points upper closure moore family def xg 
isomorphic domain gi 
gi uco uco gi 
called moore closure set inclusion subset contains moore family uco isomorphic called lattice interpretations 
case moore families concrete turns domain isomorphic complete meet general isomorphic complete sublattice viz 
additive say disjunctive 
fa uco concrete common abstraction isomorphic known reduced product common concretization 
note 
dual results hold lower closures 
follow specifying hardware software system discrete transition system consisting set states total transition relation assumed total 
denote inverse relation transitive re exive closure 
transition system consider predicate transformers predicate post def pre def post 
known pre post additive functions admit right adjoint functions pre post completeness interpretation model checking completeness interpretation formalizes intuition loss precision accumulated approximating concrete semantics 
gi sound abstraction equivalently adjunction de nitions equivalent equality required 
means loss precision accumulated approximating input arguments semantic function means loss precision accumulated approximating result computations objects 
notion backward forward completeness introduced capture di erence 
generalizing results proved backward completeness proved backward forward completeness properties underlying domain 
proposition 
galois insertion 
exists complete complete 
domain uco say complete complete 
clearly backward forward complete morphism proved possible constructively re ne domain complete scott continuous function time nd domain holds 
re nement called complete shell 
analogous result proved characterizing complete shell 
recall theorem 
continuous uco 
complete max 
complete 
complete domains closed maximal inverse image function complete domains closed direct image complete shells constructively derived minimally re ning domains adding respectively maximal inverse image direct image case additive case pre post formalized unique point de nition 
observe fact case max 
de ne single step complete re nement 
point ff gives corresponding complete shell 
particular theorem domain complete 
denote def gfp 
uco implies resp 
complete shell 
squeezing domains previous section observed domain re nement achieve completeness speci ed point iteration domain transformer iteratively enhance domains including image respectively speci es generic pattern domain re nement relatively function concrete domain domain uco monotone semantic function generic completeness re nement de ned limit sequence domains fxn gn xn xn xn 
clear un nxn 
section consider problem computing domain included provides re nement 
call domain base 
observed re nements admit base 
consider sign fz closure function note clear fz fz sign fz fz fzg fzg fzg 
domain compression domain re nement uco uco note monotone map uco 
intuitively domain compressor operator uco uco domains domain 
speci es pair inverse functions 
easy verify holds exists unique join uniform equation holds uco 
happens call def uco domain compressor uco base join uniformity key notion order domain re nement corresponding compressor adjoint 
theorem 
join uniform domain re nement uco 
uco uco gc 
known examples domain compressors disjunctive base domain compressor associated disjunctive completion re nement def additive domain complementation compressor reduced product uco 
theorem 
complete lattice uco 
bg base meet generated bu base def rb 
introduce method systematically derive base complete re nements nite lattices exist 
proposition straightforward de nitions 
proposition 
join uniform re nement corresponding compressor uco 

domain re nements order embedding set corresponding bases 
means base provides canonical representation complete abstractions point domains example shows simple transition system incomparable abstractions having re nement 
example 
left side transition system states transition relation right side concrete domain including function post 
consider respectively di erent abstractions concrete domain corresponding re nements 
elements double circled points abstractions elements single circled points added post worth noting complete re nement post post example shows incomparable abstractions may completeness re nement 
case base post post exists provides abstraction derive re nement complete abstraction including 
clear proposition abstraction base post produce re nement 
post fig 

transition system abstractions complete re nements reversing domain re nement key problem designing domain compressors systematically derive bases 
section formalize method consisting algorithm construction base completeness re nement 
theorem clear irreducible elements play key role designing domain compressors 
notion naturally generalizes arbitrary functions 
de nition 
unary function set reducible elements def fxg rr def set irreducible elements 
idea reducible generated elements di erent consider sequence objects obtained iterating function def def 
de ne proposition relates lack join uniformity cycles observed sign proposition 
complete lattice 
monotone map exists join uniform 
example shows general inverse proposition doesn hold 
example 
consider lattice drawn picture 
closures represented dashed dot lines re nements give back lattice intersection bg complete di erent lattice 
case join uniform hypotheses proposition satis ed 
order model join uniformity need rst model set objects generated candidate base domain re nement ab de nition 
nite lattice uco 
def min def fxg de nition set minimal viz non redundant sets elements include generate meet collection sets generate step completeness re nement assuming candidate base 
means nd elements generating order design method ltering objects generated domain re nement base design tree structure descendant nodes tree sets objects ancestor derived re nement 
domain uco introduce binary relation 
de nition 
uco set fxg 
denote 
construction clear tree poset 
abuse notation letting represent tree 
path tree root represents sequence di erent sets objects iteratively applying may generate note leaf tree generated di erent set cycle sets path root 


note nite lattice uco tree nite construction 
check existence cycles avoids repetitions tree 
node leaf fxg doesn contain cycle contains possible minimal set di erent generate meet elements 
consider nite lattices monotone functions denote set leaves 
proposition proves correspondence tree construction generation objects re ned domain 
proposition 
nite lattice uco example 
consider concrete domains depicted suppose 
goal squeeze concrete domain clear order generate concrete domain base generate 
consider example construction rr possible candidate base 
examples drawn domain 
put denoting bad leaves leaf contains put 
bc ab ac bc fbg fcg bc ab fbg fb cg note gure domain re nement join uniform simple verify base exactly closure ab ac gure re nement associated represented function join uniform 
candidate base rr ab clearly concrete ab domains moore families clear goal compress concrete domain base 
def def generated re nement reducible include 
elements generated meet 
uco candidate base order generalize situation base abstraction require 
lemma 
uco 

lemma says candidate base generate set def fx 
clearly redundant require construction speci ed proposition see scenario side 
proposition 
uco 
proposition says contains elements generated starting elements necessary order generate domain 
contains set meet irreducible elements generated re nement 
set derive algorithm computing base domain 
deal nite domains algorithm gives method deciding re nement join uniform 
computing base collection possible moore families strictly contained uco able generate re nement 
include elements surely generated re nement def fxg uco 
design algorithm computing base domain re nement induction construction sequence sets nn nn nn rnn jj domains nn candidate bases steps algorithm 
set include minimal candidates domains erasing elements unable regenerate domain 
step 
de ne sets step nn fn minimal elements erased re introduced moore closure 
un def set candidate bases able generate elements de ne set candidate bases step un minimal set candidate bases step nn nn step reduce size domains nn nite immediate prove proposition 
proposition 
algorithm terminates uco fxg fxg fxg correctness algorithm obtained proving contains domains subdomains unable generate re nement 
lemma 
uco uco fxg 
theorem 
completeness re nement regards base fb 
algorithm described provides systematic method deriving base completeness re nement nite domains 
complexity algorithm strongly depends structure behaves 
worst case may necessary check concrete domain best case sucient check size boolean lattices logarithmic size application predicate abstraction section consider di erent examples bases predicate abstractions transition systems complete re nements post idea predicate abstraction choose set predicates representing sets concrete states satisfy 
key point predicate abstraction choice called state lattice naturally induced composing conjunction chosen predicates 
context state lattice closure 
rst example show di erent state lattices comparable di erent bases second example recall example show di erent state lattices sharing base 
examples show bases useful derive set predicates represent base state lattice 
bases useful compare state lattices design optimal predicates system 
case predicates base removed changing way state lattices re ned 
imagine analysis system speci ed family transition relations domain clear interested precision analysis rg pre pre candidate non redundant domain backward complete post 
predicate abstraction method provides systematic way simplify de nition predicates removing predicates necessary achieve completeness example 
consider transition system gure transition relation post consider di erent abstractions represented gure 
points double circled elements abstractions points single circled elements generated re nement 
consider sets elements algorithm ff gg ff gg gg 
consider abstraction gg represented gure 
note ff gg ff gg tree root leaves 
step step ff gg ggg 
gg gg possible successors gg gg may generate 
consider 
clear gg ff gg gg generated gg 
ff ggg ff ggg step clear generated 
way ff ggg algorithm terminates 
clear theorem closure gg base 
consider abstraction represented gure 
post note ff gg simple nd ff gg 
step step ff gg 
clear ff gg note closure containing may generate 
consider clear ff gg doesn generate 

ff gg ff gg step ff gg clear saw previous step generated closures contain respectively elements 
ff gg 
way ff gg algorithm terminates 
clear theorem closure base 
observing compare closures 
implies 
example 
consider transition system transition relation post 
represented respectively 
case ff gg ff gg ff gg 
note ff gg simple verify ff gg 
ff gg simple verify ff gg 
fact hold trees root respectively leaf 
algorithm terminates domains steps computing base set generating predicates 
analogously gg 
means lead di erent complete domains re ned 
introduced systematic method deriving base exists backward forward complete re nement nite domains 
method applied domain standard galois connection interpretation theory 
operation domain compression composed operations acting domains 
useful static program analysis reduce size domains model checking 
case imagine improve model checking combining domain compression abstraction re nement 
soundness model checking ensures model veri es formula holds concrete model completeness ensures 
condition hold general model checker may return counterexample trace called spurious may correspond concrete trace 
authors proved implies incompleteness abstraction post proved abstractions strongly preserving avoids spurious counterexamples making complete pre 
results imply re ning abstractions complete post pre equivalently complete pre post remove spurious counterexamples system making model checking complete 
means model pre simplest model check formula achieving precision re ned avoid spurious counterexamples 
order design formula guided re nement combine domain compression reduce size initial abstractions spurious counterexample re nement re ne traces spurious checking shown gure 
model checker spurious counterexample re nements actl pre domain acknowledgments conceived authors visiting cousot ecole polytechnique palaiseau france 
authors wish ecole polytechnique radhia cousot kind hospitality 

ball podelski rajamani 
relative completeness abstraction re nement software model checking 

stevens editors proc 
tacas tools algorithms construction analysis systems volume lecture notes computer science pages 
springerverlag berlin 


residuation theory 
pergamon press 

clarke emerson sistla 
automatic veri cation concurrent system temporal logic speci cation 
acm trans 
program 
lang 
syst 

clarke grumberg jha lu veith 
counterexample guided abstraction re nement 
proc 
th internat 
conf 
computer aided veri cation cav volume lecture notes computer science pages 
springer verlag berlin 

fil giacobazzi palamidessi ranzato 
complementation interpretation 
acm trans 
program 
lang 
syst 

cousot cousot 
interpretation uni ed lattice model static analysis programs construction approximation xpoints 
conference record th acm symp 
principles programming languages popl pages 
acm press new york 

cousot cousot 
systematic design program analysis frameworks 
conference record th acm symp 
principles programming languages popl pages 
acm press new york 

cousot cousot 
comparing galois connection widening narrowing approaches interpretation invited 
bruynooghe wirsing editors proc 
th internat 
symp 
programming language implementation logic programming plilp volume lecture notes computer science pages 
springer verlag berlin 

cousot cousot 
abstraction software veri cation 
brinksma larsen editors proc 
th internat 
conf 
computer aided veri cation cav volume lecture notes computer science pages 
springer verlag berlin 

fil giacobazzi ranzato 
unifying view domain design 
acm comput 
surv 

fil ranzato 
complementation domains easy 
maher editor proceedings joint international conference symposium logic programming jicslp pages 
mit press cambridge mass 

fil ranzato 
powerset operator interpretations 
theor 
comput 
sci 

giacobazzi 
characterization symmetric semantics domain complementation 
proc 
nd international conference principles practice declarative programming ppdp pages 
acm press 

giacobazzi 
incompleteness counterexamples re nements model checking 
cousot editor proc 
th international static analysis symposium sas volume lecture notes computer science pages 
springer verlag 

giacobazzi ranzato 
re ning compressing domains 
degano gorrieri marchetti spaccamela editors proc 
th internat 
colloq 
automata languages programming icalp volume lecture notes computer science pages 
springer verlag berlin 

giacobazzi ranzato 
optimal domains disjunctive interpretation 
sci 
comput 
program 

giacobazzi ranzato 
uniform closures order theoretically reconstructing logic program semantics domain re nements 
inform 
comput 

giacobazzi ranzato 
making interpretations complete 
acm 

giacobazzi 
logical model relational domains 
acm trans 
program 
lang 
syst 

graf sa idi 
construction state graphs pvs 
proc 
th internat 
conf 
computer aided veri cation cav volume lecture notes computer science pages 
springer verlag berlin 

jensen 
disjunctive program analysis algebraic data types 
acm trans 
program 
lang 
syst 

graf sifakis bouajjani bensalem 
property preserving abstractions veri cation concurrent systems 
formal methods syst 
des 

ranzato 
making model checking strongly preserving 
editors proc 
th international static analysis symposium sas volume lecture notes computer science pages 
springer verlag 
