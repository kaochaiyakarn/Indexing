theoretical informatics applications set publisher informatique th applications termination checking types andreas abel 
paradigm type termination explored functional programming recursive data types 
article introduces lambda calculus recursion inductive types subtyping bounded quanti cation 
decorated type variables representing approximations inductive types track size function arguments return values 
system shown type safe strongly normalizing 
main novelty bidirectional type checking algorithm soundness established formally 
mathematics subject classi cation 

interactive theorem provers alfa coq lego curry howard isomorphism inductive proofs supplied recursive functions 
functions terminate inputs constitute valid proofs 
functional programming functions commonly de ned general recursion pattern matching 
imposes challenge proof validation general undecidable recursive program terminates 
termination checkers analyze untyped program code follow methods term rewriting rely term orderings 
previous subterm ordering extended higher order functions capture class structurally recursive functions strictly positive inductive datatypes 
keywords phrases type termination sized types inductive types course value recursion bidirectional type checking strong normalization research supported logik der informatik phd program logic computer science deutsche forschungsgemeinschaft thematic networks types ist applied semantics ii ist european union project cover swedish foundation strategic research 
department computer science chalmers university technology sweden mail abel cs chalmers se edp sciences title set publisher polynomial inductive types greater class functions accepted turner 
termination checker incorporates limited form size change data ow analysis recognizes certain functions 
functions classes rst described walther property size output bounded size input argument strictly smaller case 
implemented termination reduction checking higher order logic programs subterm ordering 
termination checkers syntactical conditions drawbacks 
non strictly positive inductive types clear syntactic criterion look see section 
secondly acceptance program sensitive small changes code redexes substitution expressions equal value 
termination checking precise syntactical formulation algorithm gim enez advocates type termination method 
idea equip types recursive data structures size information 
recursive function accepted sizes arguments recursive calls bounded size inputs 
property type size information insensitive small reformulations expressions 
nice feature sized types function types express functions size preserving 
termination checking scales higher order languages problematic purely syntactic methods 
gim enez rst describe type termination hughes pareto sabry described sized types reactive functional programming combination region types 
amadio guarded types ensure productivity nite structures streams 
ideas time people reluctant pick probably shun changes type theories 
aim article provide gentle access sized types termination order increase popularity 
restrict gim enez proposal sized types calculus constructions simply typed setting ignore coinductive types con ne subtyping necessary minimum 
type termination understood simple level go ahead upgrade rich type theories full subtyping polymorphism dependent types 
system show type safety syntactically termination semantically modeling types set strongly normalizing terms 
independently barthe de ned similar restriction gim enez original proposal proven subject reduction strong normalization 
relative novel contributions article informal type termination starting simplest form mendler rule recursion restriction gim enez system 
bidirectional type checking algorithm calculus 
main technical novelty 
title set publisher motivation result type recursive function monotonically depend type input 
side condition missing gim enez original formulation 
give example nonterminating function accepted type system side condition dropped 
article structured follows 
section introduce core language recursive datatypes non termination functions show strong type soundness property 
restricting type xed point combinator force recursive functions total 
section start mendler recursion rule mother type termination re ne step step enlarging class accepted functions reach gim enez rule 
formal presentation type system section type checking algorithm section 
proof strong normalization follows section 
section rst discuss mentioned side condition 
secondly show represent productive streams type system functions natural numbers 
motivate form perspective inductive types rules sized coinductive types gim enez barthe 
applications type termination sketched section conclude summary related section 
core language recursion consider termination setting simply typed functional programming recursive datatypes 
table shows core language lambda calculus nite sums products positive recursive types 
mean recursive types walk binding site occurrence variable choose left component arrow type number times see section 
particular selection type term formers inspired category theory 
consider equivalent terms types identical 
contexts consider variable names unique 
properties ensured considering variable names just sugar de bruijn indices shall article 
write resp 
capture avoiding substitution terms resp 
types 
take liberty drop dot binder expression binding consists single symbol xm 
table lists rules static semantics typing judgement axioms dynamic semantics computation relation terminology redex left hand side reduction axiom shall denote elimination matching 
notion generalization redexes simply typed calculus richer type systems 
full reduction goes de nition denotes opening parenthesis closes far right syntactically possible 
title set publisher types appears positively terms inl inr case inl inr fst snd fold unfold contexts variables distinct 
typing types closed lambda calculus sum types inl inr case inl inr product types fst snd recursive types terms fold unfold neutral values ne fst snd case inl inr unfold val inl inr fold reduction axioms case inl inl inr case inr inl inr fst snd unfold fold reduction relations reduction axioms step reduction closure term constructors transitive closure re exive transitive closure divergence table 
core functional language title set publisher relation obtained closing relation term constructors re exivity transitivity 
proposition shall denote diverges combining nite nite reduction sequences 
recursive functions de ned general xed point combinator note binds variables stands recursively de ned function denotes argument function xed point combinator source non termination language show method restrict typing termination regained 
signi cant subset functional language recursive datatypes translated example consider haskell program sums elements list natural numbers 
data nat zero succ nat data listn nil cons nat listn sum nil zero sum cons sum sum zero sum sum succ succ sum de ned datatypes represented type expressions nat listn nat simulate haskell constructors term abbreviations 
zero fold inl nat succ fold inr nat nat nil fold inl listn cons xs fold inr xs nat listn listn representation datatypes loses succinctness gains conceptual clarity separates notion sum product recursion simpli es presentation typing interpretation types see section 
haskell program translates code contains interleaving uses sum listn nat sum case unfold inl zero inr case unfold inl snd inr succ fst title set publisher sketch syntactical proof type soundness called type safety method wright felleisen explained detail pierce 
type system guarantees language free junk terms faulty terms fst cause evaluation get stuck 
showing preserved reduction ensure junk terms arise evaluation term reaches value diverges 
theorem type preservation progress 
typed term 
types preserved reduction 
evaluation progress val term proof 
properties shown induction preservation progress text book results see pierce exercise 
corollary strong type soundness 
value proof 
coinduction 
point put forth precise de nition possibly nite reductions relation obtained greatest xed point rules re step note take xed point get 
greatest xed point adds nite reduction sequences 
prove corollary rst apply theorem assumption value done rule re theorem 
coinduction hypothesis value rule step 
coinduction hypothesis justi ed fact generating rule produce goal appealing coinduction hypothesis 
principle called condition coquand 
typed programs go wrong milner 
diverge totally unde ned function remainder develop restrictive set typing rules terminating programs typable 

mendler iteration size preserving recursion starting mendler formulation iteration stepwise motivate principle recursion size preserving functions inspired gim enez 
give semantical motivation interesting application termination veri cation quicksort type system 
title set publisher 
iteration la mendler denote set lists natural numbers denote set total functions lists lists 
possibly partial function lists arbitrary 
assume prove total lists length total lists length 
induction lists length follows total lists 
formally ln fl jlj ng nth approximation set lists proof principle expressed natural deduction rule ln ln mendler rst turned principle typing rule recursive functions typing bound terminate 
case functions lists lists rule reads follows type listn nat listn listn listn assumptions premise fresh type variable stands approximation ln de ned recursive function assumed element ln premise shows function ln argument nat assumed type denotes ln unfolded form 
assumptions body recursive function shown typed 
implies recursive calls happen arguments type arise subterms type variable 
evaluation function call reduction rule fold type variable gets instantiated listn recursive function unfolded argument 
closer look general form mendler rule reveals types exactly iterative programs cf 
matthes sp urzyczyn type title set publisher instance rule listn 
functions natural iterative implementation addition multiplication exponentiation 
instance add nat nat nat add add case inl inr succ add de nition typed type assignments bound variables nat add nat interpret xed point type operator allow domain total functions speak inductive types recursive types 

primitive recursion la mendler mendler gave expressive rule types primitive recursive programs 
premise recursion rule additional hypothesis convert predecessor input inductive type 
conversion part output argument previously de ned functions 
reduction gets instantiated identity xx 
achieve gain expressivity making subtype iteration rule 
reduction rule remains unchanged need add subsumption typing judgement 
axiom rule added 
equip subtyping standard properties transitivity re exivity case types add axioms curry howard correspondence programming side elimination schemes logical side induction axioms inhabitants name inductive types 
details correspondence reader referred sp urzyczyn 
title set publisher examples number theoretic functions natural primitive recursive implementation predecessor subtraction factorial 
instance pred nat nat pred pred case inl zero inr types pred nat observe de nition type checked mendler iteration rule need subtyping convert type nat 

course value recursion introductory example type variable denotes approximation ln set number lists 
stage approximation ln available unfolded version 
approximation stages rst class citizens follow gim enez extend type language stage operator cumulative character ln ln ln 
re ected chain subtyping relations 
derived additional rules folding unfolding applicable inhabitants approximations inductive types 
replace original rules table fold unfold original rules derived new ones plus fact subtyping admits 
new notation approximation stages typing rule recursion reads follows 
argument recursive function longer unfolded type inhabits need substitute full fold reduction fold fold silently turned primitive recursion course value recursion 
seen argument computed predecessor input body recursive function apply subtyping law type unfold compute predecessor title set publisher turn 
going analyze arbitrarily deep obtain subcomponents qualify arguments recursive calls assigned type course value recursion useful instance program division implement speci cation fibonacci numbers directly nat nat case unfold inl zero inr case unfold inl succ zero inr add de nition types bound variables nat cast type unfold look deeper recursion argument 
essence course value recursion 
note contrast xed point rules function argument automatically unfolded state need unfold manually order analyze 
precise instance weaker scheme course value iteration notion coined uustalu vene 
obtain rule value iteration replacing hypothesis yx subscript variable expresses approximation type information implicit old hypothesis 

recursion size preserving functions functions euclidean division functional quicksort succinct recursive implementation argument recursive call derived input argument function 
example assume function pivot xs splits input list xs output lists contains elements remainder 
pivot de ne xs ys quick sorts list xs prepends ys ys ys xs ys pivot xs ys sugared syntax nil cons example 
function de ned recursion rst argument 
arguments recursive calls derived input directly pattern matching 
connected xs direct subterm input function pivot 
know output lists application pivot xs long input xs justify de ned course recursion length rst argument constitutes total function 
say bit pivot needs size preserving function 
similar terminology walther 
title set publisher terms approximations pivot size preserving input xs ln output lists approximation stage ln input xs 
formally require pivot ln ln ln 
gim enez observed bounded quanti cation pivot listn express semantical property syntax level 
show function size preserving 
semantically proof induction pivot ln ln ln 
ln ln ln ln ln ln di erence proof scheme section result type mentions approximation stages 
carry modi cation syntactical level allowing occurrences result type recursion 
article restrict positive occurrences barthe 
see section negative occurrences lead non termination 
recursion rule takes shape pos 
crucial keep quanti er 
type just lost information size relations input outputs recursive function 
functions de ned rule need means instantiate bounded quanti cation gim enez formulation bounded quanti cation part type syntax consequently instantiation merged xed point rule 
size relations way local recursive functions lifted top level available functions 
instance pivot de ned locally 
bounded quanti cation rst class citizen pivot function function 
de ne function pivot assign type listn listn listn listn complete quicksort example demonstrate type system verify totality 
give program haskell language title set publisher type annotations readable direct representation core language 
simple correspondence type annotations clauses typing rule principal function argument assumed type recursive calls occur arguments type result type 
pivot nat listn pivot pivot xs pivot xs listn listn listn ys ys xs ys pivot xs ys quicksort listn listn quicksort annotations function bodies inferred type checking algorithm section types functions 

type system formally enrich type system approximation types subtyping bounded quanti cation explained informally section 
constitutes language due restricted rule types strongly normalizing terms 
contexts types subtyping table summarizes types type related judgements set raw types extension types decorations bounded quanti cations 
additionally term variables wellformed contexts bind constrained type variables 
variables bound assumed distinct 
judgements distinguish kinds types itype datatypes 
essentially positive inductive types additionally may contain type variables approximations inductive datatype 
example section see type list referring approximation type note itype formation rule swaps positivity negativity variables 
title set publisher raw types judgments cxt wellformed context 
itype datatype free positive variables free negative variables type wellformed decorated type 
subtype 
wellformed contexts cxt 
cxt type cxt 
itype cxt datatypes itype 
cxt itype cxt itype itype itype itype cxt itype itype itype itype itype itype subtyping 
itype cxt wellformed types type 
cxt type type type type type type type subtyping ii 
table 
contexts types subtyping type decorated types 
contain standard type formers inductive types approximations handled judgement bounded quanti cation 
free variables wellformed type type approximations datatypes bound separation types classes simpli es theory need de ne positivity bounded quanti cation 
secondly brings strati cation title set publisher simpli es semantics section 
instance monotonicity required 
subtyping form determines approximation inductive type 
setting approximations take shape natural number observe decidable 
entails judgements decidable rule wellformed approximations critical 
furthermore set subtyping rules ii cases right hand side approximation shape rules invoked type judgement subsumption rule see 
presentation subtyping di ers previous section types related 
formulation syntax directed transitivity re exivity approximations admissible 
judgements number technical properties 
wellformedness context byproduct wellformedness type subtyping relation types context lemma wellformedness contexts 
itype type cxt 
proof 
simultaneously induction derivation 
judgements allow weakening wellformed contexts substitution approximation variables full inductive type lemma type substitution 

cxt cxt 
itype itype 
type type 
proof 
simultaneous induction derivation 

terms type assignment features terms comes precise typing inductive data fold unfold recursive functions 
furthermore typing rules arise subtyping quanti cation 
table summarizes changes introduced section 
due richer type grammar context automatically wellformed add judgement cxt axioms typing var unit 
similarly type wellformed re ne injection rules sums 
title set publisher typing axioms cxt var cxt unit sum types type inl inl type inr inr inductive types fold fold unfold unfold recursive functions pos 
subtyping sub inst neutral values ne reduction axiom fold fold table 
typing reduction rules new typing rules inductive data treat inhabitants approximations inductive types 
explain fold rule example lists listn nat approximation type lists natural numbers nat natural number 
list approximation list size unknown inr nat folding rule list cons fold inr size 
unfold rule works analogously 
mentioned section old folding rules special case new ones set 
reduction axioms exception xed point unrolling 
ensure normalization recursive functions reduced applied value fold inductive type 
consequently get new neutral value value form fold step reduction relation multi step reductions understood regard modi ed axiom 
example empty type 
empty type de nable xed point identity function type level 
abort unfold title set publisher elimination function abort accepted type system form threat strong normalization 
holds informally explained failed counterexample 
formally established section 
assume free variable fold reduction sequence 
abort fold unfold fold 
unfold unfold fold 
unfold abort observe de nition abort produce loops contrast function simplest de nition abort typing calculus enjoys usual properties wellformedness restricted exchange weakening strengthening substitution term variables substitution holds type variables lemma type substitution 
proof 
induction typing derivation case distinction subtyping derivation 
important soundness typing fact contexts types appearing typing judgement wellformed lemma 
cxt type 
proof 
induction typing derivation 
example tree ordinals 
second number class represented strictly positive inductive type ord nat constructors 
fold inl ord zero ordinal fold inr inl ord ord successor ordinal fold inr inr nat ord ord limit ordinal example representation 
assuming nat ord de ned function converts natural number succ zero ordinal equivalent obtain representation nite ordinal omega 
title set publisher example addition tree ordinals 
ordinal addition de ned follows ord ord ord case unfold inl inr case inl inr type checking bound variables receive types ord ord nat nat nat 
positivity condition result type ord recursion trivially satis ed mentioned ord 
datatypes embedded function spaces example explicitely excluded size types hughes pareto sabry 
reason approach size annotations interpreted ordinals 
example needs larger ordinals explained section 
translation contexts 



itype 

approximation erasure types 
jji jji 
jji 
jji 
jji 
jji 
jji 
jji 

jji 
jji 
jji 
jji approximation erasure contexts jji 
jji 
jji 
jji jji 
jji 
jji jji 
table 
erasure approximation types 

weak type soundness section show extended system programs go wrong 
unfortunately type preservation property fails new type title set publisher system notion subtyping weak 
consider typing derivation fold fold unfold fold unfold fold type preservation requires 
syntactic subtyping lacks necessary property arbitrary appears positively way overcome problem add necessary closure properties subtyping relation done 
fact simpler type system ensures typed programs go wrong 
show typing derivation turned typing derivation replacing approximation types full inductive types 
progress property theorem holds slightly restricted reduction relation slightly enlarged value set type soundness ensures programs get stuck 
table speci es erase approximations types contexts 
judgement 
singles contexts 
called translation contexts map approximation type variables closed approximation free inductive types 
approximation context 
type 
type judgement 
jji outputs wellformed type approximation types replaced full inductive type 
similarly jji 
separates wellformed context cxt approximation free context translation context 

theorem soundness typing regard typing 
jji 

jji proof 
induction proof amounts removing applications subsumption instantiation typing derivation 
corollary weak type soundness 
proof 
combining theorem corollary 
lacking type preservation show obtain weak type soundness property 
purposes section show nite reduction sequences excluded advanced type system result typed term reduces value semantically property hold content lemma 
title set publisher terms 

judgments 
extended subtyping 
type term inferred term checked type type inference 
var type lam app unit pair fst fst snd snd unfold unfold unfold unfold type ann fv app app type checking 
lam inl inl inr inr case inl inr case fold fold fold fold pair pos 
match app app direction reversal 
extended subtyping 
cre table 
type checking 
title set publisher 
type checking order type system termination checker need suitable type checking algorithm 
possibility extend hindley milner algorithm bounded quanti cation approximation types 
algorithm produce set existential type variables set equations variables satisfy 
problem algorithm implemented sml instance case unsolvable equations location responsible human perspective type error hard locate 
pierce turner advocate local type inference restricts propagation type information adjacent nodes syntax tree term type checked contrast hindley milner collects type equations globally 
local type inference bidirectional type checking folklore method instance coquand dependent types davies pfenning intersection types 
dun eld pfenning extended method checking 
bidirectional type checking incomplete decide typing terms case simply typed lambda calculus exactly normal terms 
non normal terms need type annotations type check 
extend calculus means aid type checker obtain language new constructs allow annotation bound variables terms 
additionally introduce binding operational meaning better behavior type checking 
adapt bidirectional type checking calculus rules listed table 
checking judgement requires input generating rules read upwards arrow suggests 
de ned simultaneously type inference computes type rules inference read downwards 
general principle bidirectional checking type variables eliminations inferred rules var fst snd unfold app app 
contrast type introductions checked rules lam pair fold inl inr annotated lambda abstractions exception admit inference rule lam 
rule allows switch checking mode inference mode applied checking rule matches 
case type general type supplied checking judgement 
expressed extended subtyping relation encompasses subtyping instantiation 
nondeterministic character subsumption typing judgement type checking algorithm shifting applications subsumption rule speci point inference checking meet 
type inference algorithms give better error messages put forward wells yang michaelson trinder 
title set publisher positive abnormality elimination dichotomy tuples permit inference constructors unit pair 
negative abnormalities sum elimination type side clauses case construct arbitrary inferred general case 
binding seen elimination unary sum treated case 
problem occurs bounded quanti cation rule app size argument needs inferred give size bound result application 
size result known checked rule app 
rule involves simple matching level types unknown 
types rst order expressions reduction matching problem decidable 
disregarding abnormalities algorithm check types normal expressions kind expressions dominates practical programming 
non normal expressions need annotated type sensible position rules ann lam 
top level expressions recursive functions need de ned type 
heavy load programmer haskell quite common 
example type checkable version sum example 
function sum section acceptable type checker need introduce annotation 
construct write follows sum listn nat sum case unfold inl zero inr sum case unfold inl snd inr succ nat nat sum fst rules implemented higher order logical framework twelf yield prototypical type checker available homepage author 
easy turn rules deterministic algorithm mutually recursive functions inf chk speci cation 
inf error chk ok error function inf de ned case distinction function chk cases tests recursive calls necessary case read rules table 
cases rules applicable 
source non determinism resolved fusing respective rules single title set publisher case inf unfold rules unfold unfold inferring type distinguish shape 
case inf rules app app app distinguish type 
case chk rules app app similarly 
case chk rule switch inference checking rule applicable 
resulting function chk checks types time linear size input expression plus type modulo context lookup type matching subtype checking 
table shows trace type checker veri es ordinal addition function 
rst column displays rules red second column lists hypotheses rules added context third column show new state checker 
simplify presentation ignored inl branches case expressions trace 
algorithm complete check interesting programs instance examples article 
show soundness algorithm 
de nition erasure 
jm denote result erasing type annotations bindings de ne 
jm jm jm jn adding congruences term constructors 
proposition soundness type checking 
wellformed context term type 
type jm 
type jm proof 
simultaneously induction example case unfold unfold induction hypothesis assumption subtyping subsumption rule unfold unfolding rule case fv app title set publisher ord ord ord case unfold inl inr case inl inr ord ord ord nat ord ord rule context ext 
judgement start ord ord ord lam ord ord ord ord ord case unfold ord var unfold unfold nat case nat case ord var nat case nat ord var nat ord ord app nat ord lam nat ord var ord app var nat app nat var nat table 
example run type checker 
induction hypothesis instantiation type lemma induction hypothesis application rule cases similarly straightforward 
title set publisher soundness proof formally veri ed twelf obtained author 
remainder article forget additional constructs return core calculus 
strong normalization section semantical soundness proof precisely assign wellformed type set strongly normalizing terms term assigned type inhabits 
consequence strongly normalizing combination weak type soundness result section guarantees reduce values nite number steps 
proofs strong normalization long tradition methods developed 
saturated sets method notion weak head reduction luo altenkirch 

preliminaries saturated sets set strongly normalizing terms sn de ned inductively rule sn sn words sn wellfounded part set terms reduction relation 
variables strongly normalizing subterms strongly normalizing terms 
set sn closed reduction 
notion weak head reduction elegantly de ned evaluation contexts generated grammar fst snd case inl inr unfold weak head reduction reduction form situation say head redex terms form called neutral possess head redex produce head redex substituted variable term 
process normalization weak head redexes resolved way skipping performing reductions rst 
expressed standardization lemma altenkirch 
lemma weak standardization 
exists 
title set publisher proof 
induction generation base case case distinction consequence weak standardization set sn closed weak head expansion 
lemma weak head expansion 
sn sn holds sn 
proof 
simultaneous induction sn show sn lemma 
set terms called saturated written sat contains strongly normalizing terms strongly normalizing neutral terms closed weak head expansion 
saturation set de ned closure rules sn sn sets terms de ne function space fm sn qg reuse known easily veri ed fact function space constructor operates saturated sets sat sat 
type interpretation section give interpretation wellformed type datatypes semantics monotone operator saturated sets 
particular xpoint operator derived 
previous obtained xpoint theorem knaster tarski resp 
accessibility inductive de nitions 
time follow idea mendler reused amadio reach xpoint trans nite iteration 
technique enables give interpretation approximation types 
set call origin set monotonic operator sets 
ordinal number de ne iterate trans nite recursion limit ordinal hierarchy cumulative cumulative hierarchy called chain stationary point iteration process reaches xed point 
consider title set publisher sets countable domain xed point reached latest uncountable ordinal considered collection sets guaranteed xed point 
consider operators saturated sets saturated set saturation empty set 
order de ne interpretation type need valuation free type variables occurring interpret terms free term variables introduce valuations provide substitute variables bound context rules context triples holds additionally provides set terms variable note expresses dom dom term variable mapped term type variable set terms 
require assigned terms type correct conditions assigned term sets 
require formed context 
notion valuation sucient de ne type interpretation prove monotonicity interpretation positive de nition 
section sharpen requirements valuations additional judgement 
semantics types type free type variables 
de ne interpretation recursion title set publisher shown free inductive types xed point reached ordinal 
examples include nat listn nat empty type 
example interpretation empty type 
built empty type interpreted case de ned 
qg show extensionally equal exists abort abort recall abort unfold 
proof proceeds induction approximations side induction saturation fact abort fold abort inductive types involving function spaces closure ordinal greater 
instance type tree ordinals ord introduced example 
example 
ord requires iteration denote generating operator type ord 
conversion function natural numbers tree ordinals nat 
approximation stage omega inhabits 
continue showing interpretation positive type monotone operator 
rst observe interpretation preserved substitution types holds 
lemma monotonicity itype 
itype valuations ordinals proof 
induction itype 
datatypes itype interpretation monotone sense previous lemma operator additionally property 
entails xpoints exist iterates form cumulative hierarchy 
fact important proof strong normalization data value inhabits approximation type successor iterate 
lemma 
fold fold proof 
trans nite induction 
proof strong normalization complete proof strong normalization rst ensure interpretation type saturated set 
show typed term inhabits interpretation type strongly normalizing 
title set publisher wellformed contexts cxt interpreted set sound valuations 
de ne inductively rules 

verify subtyping calculus sound lemma soundness subtyping 
holds operator ordinals proof 
induction derivation 
note previous lemma subtyping accepts example 
lemma type interpretations 
type sat proof 
state similar propositions type related judgements table prove propositions simultaneous induction 
lemma wellformed contexts satis able 
cxt exists 
proof 
induction cxt 
empty context take empty valuation 
case type know lemma cxt obtain induction hypothesis 
lemma saturated set contains 
desired valuation remaining case similarly obtain induction hypothesis extend mapping 
assembled pieces prove strong normalization 
theorem soundness typing 

proof 
induction show interesting cases fold unfold case fold assumption follows induction hypothesis 
fold 
title set publisher case unfold case induction hypothesis show unfold side induction saturation subcase 
unfold unfold neutral strongly normalizing element 
subcase sn side induction hypothesis unfold saturation unfold 
subcase fold 
reduce unfold fold follows unfold 
case appears positively 
show ordinals rst side induction fix ordinal term show second side induction saturation subcase 
neutral 
subcase second side induction hypothesis 

subcase fold lemma 
rst side induction hypothesis 

main induction hypothesis appears positively conclude saturation fold title set publisher trans nite induction 
soundness proof xed point rule uses course value trans nite induction fact new canonical inhabitants inductive datatype successor iterates lemma 
quite instructive consider economic proof simple trans nite induction 
case base case holds contains canonical forms fold step case follows main induction hypothesis limit case needs monotonicity ensured positivity condition corollary strong normalization 
sn 
proof 
lemma context wellformed 
entails exists valuation constructed proof lemma maps term variables 
soundness typing sn interpretation saturated 
type termination dml 
xi sophisticated type system admits inconsistent contexts consequently strong normalization hold prove soundness typing analogously theorem 
case proof exist show normalization closed terms empty 
strong normalization excludes nite reduction sequences 
directly show possibly nite reduction sequence fact nite 
consequence typed program reduces value 
lemma termination 
sn proof 
induction sn cases corollary reduction value 
proof 
corollary sn corollary lemma implies 
extensions issues brie discussed section positivity requirement result types recursion rule approximations coinductive types 
topics treated informally incompletely systematic approaches pareto barthe abel 

non monotonic result types recursion section promised motivate required result type recursion positive rst presentation gim enez requirement added 
simply drop side condition title set publisher type non terminating functions demonstrate 
recall type nat de ned constructors zero succ section 
introduce abbreviation 
case inl inr types nat de ne shift nat 
nat 
shift succ inl unfold nat 
nat inr succ function xed point shift show reduction sequence shift inr succ succ inl unfold unfold succ succ inr succ shift construct recursive function result type nat 
loops input nat 
nat 
zero unfold shift function typed infer types subexpressions 
nat 
nat 
shift nat 
application recursive function shift accepted type system 
simple computation zero zero shift zero created loop 
exactly causes non termination 
mere negative occurrence type nat 
unproblematic terminating recursion cf 
abel 
presence argument title set publisher type nat 
arbitrary natural numbers back door declared type way safe arguments recursion 
safe side arguments recursive function resp 
overshooting terminology hughes pareto sabry 
means limit ordinal counterexample nat 
argument violates requirement 
clearly inhabits set nat 
nat left hand side member right hand side set nat 
contains codes natural numbers systematic treatment admissible result types recursion pareto phd thesis evaluation closed terms abel evaluation binders 

coinductive datatypes approximation types check productivity nite structures streams cf 
hughes pareto sabry amadio gim enez barthe 
demonstrate simulate productivity checking streams type system encoding streams functions natural numbers 
streams nite sequences elements xed type nitary languages de ned recursion 
dual termination case functions productivity streams 
means time unfold stream extract rst element obtaining remainder productive 
size inductive data de nedness coinductive structures 
de ne set partial streams natural numbers sn fs unfolded times characterizes streams de nedness corresponding predicate ln lists covariant argument see section ln lm de nedness contravariant sn sm set productive streams 
bottom element approximation chain sn 
productive streams obtained induction rule sn implies sn 
rules productive streams form extension show rules admissible small extension original calculus 
title set publisher formation 
itype stream itype stream type stream type subtyping 
stream stream stream stream stream stream elimination 
hd stream tl stream 
scons stream recursion 
stream pos 
stream reduction 
hd scons tl scons hd hd tl tl rules enable instance code sequence natural numbers starting sorted merging streams 
nats stream nat nat nats nats scons nats succ merge stream nat merge merge hd fst hd snd scons merge tl fst snd scons merge fst tl snd claim need simulate streams de nition stream nat type system little liberal handling subtyping bounded quanti cation new xed point combinator implements recursion second argument 
extend rules title set publisher bounded quanti cation subtyping 
type type recursion second argument 
neg 
pos 
reduction 
fold fold encode streams extended replace quanti cations stream nat occurrences remaining occurrences stream nat 
formation rules streams immediately valid subtyping justi ed rule arrow example destructors constructor streams de ned correct typing hd nat hd zero tl nat tl succ scons nat scons unfold typing scons need new rule bounded quanti cation 
xed point combinator streams special case recursion second argument 
polarity conditions satis ed positive implies negative 
calculation verify title set publisher computational behavior streams hd scons 
unfold zero tl scons unfold succ hd 
zero 
zero hd tl succ succ tl reduction completely simulated encoding tl equal lambda abstraction 
axiom streams equal encoding 
reader invited check programs nats merge inhabit translated types 
nats nat nat nat merge nat nat nat nat summing managed justify approximation stages coinductive types example streams 
hope provided easy access rules productivity checking nite structures experience author harder communicate rules termination checking 

applications establishing soundness show ectiveness approach section 
sketch explored principles applied functional programming theorem proving speci example resource bound certi cation 

functional programming article demonstrated type termination small functional programs 
example shows system handle mutual recursion interleaving inductive types non strictly positive types 
title set publisher introduce abbreviations certain datatypes list lists type term rst order terms continuations 
list term int int list rst order terms consider constructed variables ary function symbols continuations constructors var int term func int term list term mu term term var denotes ith variable func ith function symbol applied terms list mu term term term stores current continuation retrieves continuation throws term note term rare example non strictly positive type furthermore term list interleaving called nested 
system accepts mutually recursive substitution function 
subst int term term term subst var subst func func sl list sl list term list sl sl ts subst sl ts subst mu mu term subst recursion interleaving inductive datatypes naturally expressed mutually recursive functions 
case crucial mutual recursion simultaneous interleaving approximation type terms term available inner function sl approximation list 
informally contains terms upto certain height list lists terms 
contains lists restricted length consist terms bounded height 
typing ensures call subst sl terminates call graphs necessary cf 
abel altenkirch lee jones 
continuations consider modeled calculus parigot bierman 
chosen representation positive type derived abel 
title set publisher line encodes substitution continuations applying technique non strictly positive types 
termination obvious measure approaches clear measure 
sure termination checked usual untyped notion subterm ordering subterm type termination succeeds types provide data ow information available subterm calculi 
day programming functions terminating inputs 
may terminating termination proof may involve complicated arguments checked automatically 
reason desirable allow total partial functions program 
realized naturally system simply adding rule impose restriction recursion 
extended system functions total typing derivation liberal rule 
keep eciency implementation type system functions tagged total resp 
possibly partial compiler 

theorem proving pointed typed approach termination suitable theorem provers theories inductive de nitions agda coq lego 
needs adapted dependent type theories 
rst proposal put forth blanqui 
combines parts approaches xi gim enez hughes obtain type termination criterion calculus algebraic constructions 

resource bound certification crary weirich describe language resource bound certi cation 
estimate cost de ned operations static cost functions 
technically cost functions called constructors type theory type checking decidable constructors terminating 
currently restricted mendler style primitive recursive functions see section 
extension integrated type theory strictly increase expressiveness language 

method ensuring termination types shown soundness algorithm type checking discussed applications intended theorem provers 
table gives overview technical results article 
section formalized type checking algorithm sound typing excludes nite reduction sequences proven section 
program assigned type obtained erasure section guarantees evaluation get stuck title set publisher jji 
jji sn jm table 
summary technical results 
section 
putting things type checkable program reduces value nite time 
type termination combines program analyses ordinary type checking termination checking called reduction checking resp 
size checking chin khoo 
expect combination implementations normalizing calculi succinct ecient transparent user 
give substance claim implementations type termination tested practice 
conclude discussion related sized types termination 

hughes pareto hughes pareto sabry sized types termination productivity checking functional programs 
detailed treatment pareto thesis 
type system refers approximations type natural numbers nat size expression 
full type natural numbers represented nat 
bounded quanti cation uses quanti cation size variables stage operation 
simulated successor operation sizes 
instance type nat listn pivot function written nat list nat list nat list nat system size variable 
pareto type language expressive aspects sizes separated approximation stages assign instance precise type list nat length function furthermore enables size information polymorphic functions map list list secondly size expressions contain addition sizes multiplication constant precise type list list list append function possible 
title set publisher hand sizes bounded ordinal treat inductive types embedded function spaces ord example 
semantics denotational domains shows termination closed programs permit evaluation binders 
notwithstanding di erent interpretations formation recursive functions underlies constraints pareto approach 
side condition xed point rule see section restriction condition instantiate size quanti er limit ordinal 
side condition xed point rule called bottom check 
expresses type recursive function instantiated universe terms semantics 
setting types recursive functions restricted shape trivially satisfy bottom check page empty types th approximation inductive type 
pendant bottom check base case trans nite induction soundness proof xed point rule see 

gim enez gim enez provided starting point 
describes termination approximation types extension calculus constructions provides soundness proof 
showing strong normalization method original motivation article 
gim enez barthe formulation type system follows hughes 
set size expressions generated size variables successor operation symbol denoting rst uncountable ordinal type system features function types inductive datatypes excludes quanti cation size variables size preserving function see section 
bounded quanti cation system embeds barthe give proof subject reduction strong normalization 
describe type checking algorithm 
type system ready termination checker 

xi dependent ml xi considers termination closed functional programs dml functional language lightweight dependent types 
contrast approach approaches described size data structure determined height integer expression de ned user 
example de ne size tree total number nodes sum labels 
recursive functions come termination measure form lexicographic product size expressions 
size annotations exact contrast notion size just upper bound 
need subtyping compare integer expressions relies constraint solver 
hand due exact size annotations xi perform size checking accumulation parameters functions impossible approaches title set publisher mentioned 
quali es xi approach practical termination checking realistic functional programs 
hand xi ordinal sizes handle higher order datatypes nite trees common proof theory 
limits applicability approach theorem provers 

related termination general vast amount literature published give non representative overview related 
typed functional programming 
previous thorsten altenkirch described syntactic check structurally recursive functions context simple types 
proved termination closed terms strong normalization 
turner check termination productivity recursive functions interpretation 
track size change domain power approach comparable 
giesl generates termination predicates static analysis functional programs 
termination proven external automated theorem prover 
approach limited power theorem prover exible quite unpredictable 
higher order logic programming 
describes calculus termination reduction checking logic programs higher order term language 
calculus subterm ordering hoas theorem prover twelf 
untyped functional programming 
lee jones ben investigate termination untyped rst order functional programs size change graphs 
show implicit complexity termination checking mutually recursive functions pspace hard 
term rewriting 
classical area investigating termination 
accentuate giesl example arts dependency pairs 
blanqui jouannaud okada investigate term rewriting systems inductive types 
thesis blanqui proves strong normalization calculus algebraic constructions rewrite rules 
author thorsten altenkirch year joint termination thierry coquand pointing gim enez john hughes lars pareto conversation eventually lead counterexample section martin hofmann frank pfenning brigitte helpful discussions fr ed eric blanqui encouraging feedback article 
indebted ralph matthes careful reading draft conversation advice helped overcome unforeseen diculties nal preparation phase articles 
anonymous referees critical remarks led clearer presentation 
title set publisher abel 
speci cation veri cation formal system structurally recursive functions 
coquand dybjer nordstr om smith editors types proof programs international workshop types volume lecture notes computer science pages 
springer 
abel 
third order representation calculus 
ambler crole editors electronic notes theoretical computer science volume 
elsevier science publishers 
abel 
termination checking continuous types 
hofmann editor typed lambda calculi applications tlca volume lecture notes computer science pages valencia spain june 
springer 
abel 
soundness bidirectional typing algorithm 
twelf code available author homepage www tcs informatik uni muenchen de abel may 
abel altenkirch 
predicative analysis structural recursion 
journal functional programming january 
altenkirch 
constructions inductive types strong normalization 
phd thesis university edinburgh november 
amadio 
analysis guard condition type theory 
nivat editor foundations software science computation structures international conference fossacs volume lecture notes computer science 
springer 
arts giesl 
termination term rewriting dependency pairs 
theoretical computer science 
barthe gim enez pinto uustalu 
type termination recursive de nitions 
mathematical structures computer science 
bierman 
computational interpretation calculus 
editors proceedings symposium mathematical foundations computer science volume lecture notes computer science pages brno czech republic august 
blanqui 
type theory rewriting 
phd thesis paris xi sept 
blanqui 
type termination criterion dependently typed higher order rewrite systems 
th international conference rewriting techniques applications rta june aachen germany lecture notes computer science 
springer 
appear 
blanqui 
jouannaud okada 
inductive data type systems 
theoretical computer science 
giesl 
termination analysis partial functions 
proceedings third international static analysis symposium sas volume lecture notes computer science aachen germany 
springer 

chin 
khoo 
calculating sized types 
higher order symbolic computation 
coquand 
agda 
www page 
www cs chalmers se agda 
coquand 
nite objects type theory 
barendregt nipkow editors types proofs programs types volume lecture notes computer science pages 
springer 
coquand 
algorithm type checking dependent types 
mathematics program construction 
selected papers third international conference mathematics program construction july germany volume science computer programming pages 
elsevier science may 
crary weirich 
resource bound certi cation 
proceedings th acm sigplan sigact symposium principles programming languages pages boston massachusetts usa january 
title set publisher davies pfenning 
intersection types computational ects 
proceedings international conference functional programming icfp pages montreal canada september 
dun eld pfenning 
typechecking 
jones leroy editors st annual symposium principles programming languages popl venice italy pages 
acm jan 
giesl 
termination nested mutually recursive algorithms 
journal automated reasoning 
gim enez 
structural recursive de nitions type theory 
automata languages programming th international colloquium icalp aalborg denmark july proceedings volume lncs pages 
springer 
wells 
type error slicing implicitly typed higher order languages 
programming languages systems th european symp 
programming volume lecture notes computer science pages 
springer 
hagino 
typed lambda calculus categorical type constructors 
pitt poign rydeheard editors category theory computer science volume lecture notes computer science pages 
springer 

alfa home page 
www math chalmers se alfa 
hughes pareto 
recursion dynamic data structures bounded space embedded ml programming 
international conference functional programming icfp pages 
hughes pareto sabry 
proving correctness reactive systems sized types 
symposium principles programming languages pages 
inria 
coq proof assistant manual version edition april 
coq inria fr doc main html 
lee jones ben 
size change principle program termination 
acm symposium principles programming languages popl london uk january 
acm press 
luo 
ecc extended calculus constructions 
phd thesis university edinburgh 
matthes 
extensions system iteration primitive recursion monotone inductive types 
phd thesis ludwig maximilians university may 
mcbride 
dependently typed functional programs proofs 
phd thesis university edinburgh 
mendler 
recursive types type constraints second order lambda calculus 
proceedings second annual ieee symposium logic computer science ithaca pages 
ieee computer society press 
mendler 
inductive types type constraints second order lambda calculus 
annals pure applied logic 
milner 
theory type polymorphism programming 
journal computer system sciences aug 
pareto 
types crash prevention 
phd thesis chalmers university technology 
parigot 
calculus algorithmic interpretation classical natural deduction 
voronkov editor logic programming automated reasoning proc 
international conference lpar pages 
springer berlin heidelberg 
pfenning sch 
system description twelf meta logical framework deductive systems 
ganzinger editor proceedings th international conference automated deduction cade volume lecture notes arti cial intelligence pages trento italy july 
springer 

termination reduction checking higher order logic programs 
gor nipkow editors automated reasoning international joint conference volume lecture notes arti cial intelligence pages 
springer 
title set publisher pierce 
types programming languages 
mit press 
pierce turner 
local type inference 
popl th acm sigplan sigact symposium principles programming languages san diego california 
pollack 
theory lego 
phd thesis university edinburgh 
sp urzyczyn 
type xpoints iteration vs recursion 
sigplan notices 
proceedings international conference functional programming icfp paris france 
turner 
ensuring streams ow 
algebraic methodology software technology amast volume lecture notes computer science pages 
springer 
turner 
ensuring termination 
journal universal computer science apr 
proceedings 
uustalu vene 
primitive recursion course value iteration categorically 
informatica academy sciences 
walther 
argument bounded algorithms basis automated termination proofs 
lusk overbeek editors th international conference automated deduction volume lecture notes computer science pages 
springer 
wright felleisen 
syntactic approach type soundness 
information computation 
xi 
dependent types program termination veri cation 
journal higher order symbolic computation october 
yang michaelson trinder 
explaining polymorphic types 
computer journal 
communicated zolt igor walukiewicz 
may 
