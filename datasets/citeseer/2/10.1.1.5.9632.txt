proceedings ieee broadway compiler exploiting domain specific semantics software libraries samuel calvin lin describes experiences broadway compiler support domain specific compiler optimizations 
goal provide compiler support wide range domains context existing programming languages 
focus technique call library level optimization recognizes exploits domain specific semantics software libraries 
key system separation concerns compiler expertise built broadway compiler machinery domain expertise resides separate annotation files provided domain experts 
describe system optimize parallel linear algebra codes written plapack library 
find annotations effectively capture plapack expertise levels abstraction compiler automatically apply expertise produce considerable performance improvements 
approach shows abstraction modularity modern software asset compiler programmer 
index terms library level optimization domain specific compiler study compilers matured capabilities traditional optimizing compilers stretched limit increasingly complex optimization algorithms yield diminishing returns 
situation reflects extreme difficulty better performance set low level programming language constructs 
contrast domain specific languages offer new high level primitive operations compilers analyze manipulate 
domain specific compilation remaining frontiers optimizing compilers 
number domain specific compilers exist 
tied particular language matlab spiral tied particular domains sparse matrices 
great strength approaches compiler ability important assumptions specific domain 
problem approaches limited applicability capabilities provide translate languages domains 
approaches difficult programmers multiple domains single program difficult develop compilers new domains 
describe alternate approach domainspecific compilation supports wide range domains single compiler infrastructure 
key idea separate general purpose compiler mechanisms domainspecific information expertise 
hard code domain knowledge compiler solution encapsulates information small annotation language 
different annotations different domains configurable compiler called broadway compiler target multiple domains program 
solution targets software libraries domainspecific languages annotations identify library routines serve domain specific operations 
compilation annotations guide broadway compiler analysis optimization operations 
design yields number benefits 
mentioned allows handle multiple domains 
great domains provided libraries formulated languages 
second libraries widely bring domain specific compilation existing software little change current programming practices 
third incremental cost adding new domains new optimizations low require modifications compiler 
broadway compiler consists primarily domain independent compiler machinery dataflow analysis framework code transformation system set traditional optimization passes 
spectrum domain specific compilers broadway represents tradeoff favors breadth applicability depth capabilities 
system produces competitive results domains compete custom compilers individual domains 
deciding include broadway consider general utility feature complexity configuring annotation language 
dataflow analysis example general static analysis technique collecting information dynamic behavior program 
formulation dataflow analysis supports subset analysis problems limits annotation writer exposure underlying lattice theory 
capabilities express wide variety domain specific compilation tasks optimizing parallel linear algebra codes checking system software security vulnerabilities 
presents overview system explains design rationale summarizes results experiences 
remainder organized follows 
section reviews related 
section ii describes broadway system general notion library level optimization 
section iii explains broadway system applied parallel linear algebra library 
section iv presents performance results section concludes identifies prospects 
related domain specific compilers designed expressly particular domains 
systems include matrix optimizing matrix operations specification matrix proceedings ieee structure falcon compiler optimizing matlab programs fftw system generating fast fourier transform implementations 
focusing single domain systems employ best representation aggressive optimizations domain 
contrast broadway compiler annotation language tailored specific application domain trade power generality 
telescoping languages project shares goals ideas research 
proposal describes annotation language similar captures properties library interfaces 
currently focuses generating optimized code scripting languages matlab 
system uses offline compilation generate alternative library implementations uses type inference system select 
broadway targets generalpurpose programming languages support wider range domains uses dataflow analysis drive optimizations 
dataflow analysis solve type inference problems track state computation awkward express types 
useful view broadway specific instance system supporting active libraries 
active libraries represent broad class reusable software components traditional libraries actively involved compilation process 
meta programming techniques expression templates programmable syntax macros meta object protocols allow library developers specify code customizations take effect application compile time 
techniques provide powerful compile time program manipulation capabilities suffer major drawbacks 
meta program complex error prone 
second systems primarily syntactic level include advanced program analysis 
system drives program transformations dataflow analysis captures deep semantic information programs operates larger scope typical meta programs 
previous research explored number different ways making compilers flexible motivated desire support high level domainspecific compilation 
existing approaches take considerably different view tradeoff usability power 
particular provide comprehensive set tools defining new compiler components tools difficult error prone 
examples include open compiler infrastructures suif optimizer generators genesis compiler analyzer generators sharlit pag 
view approaches viable domain specific compilation require compiler expertise domain experts 
ii 
broadway section describe opportunities optimization show broadway compiler exploits 
key feature system separation general purpose compiler mechanisms domainspecific information 
compiler mechanisms provided part broadway compiler domain specific information kept separate annotation files written light weight annotation language 
library level optimization libraries common mechanism encapsulating domain specific functionality 
great strength libraries simplicity library simply set ordinary types functions programmers add domain specific functionality application just including appropriate header files making calls library interface 
programmers develop new libraries new domains time easily combine substantially different domains single application 
built operators programming language domain specific operators library interface meaning compiler 
result traditional compilers assist operators task libraries correctly efficiently left entirely programmer 
goal broadway system provide explicit compiler support domain specific operators represented libraries 
strategy extend existing compiler mechanisms recognize manipulate library routine calls way built operators 
show mechanisms proven effective built operators effective library operators 
key capture domain specific information library form compiler 
opportunities compiler targets kinds library level optimizations domain independent extensions 
optimizations direct extensions traditional optimizations dead code elimination loop invariant code motion applied library routine calls 
enabled simple dependence information library routine 
example knowing math library operators side effects compiler safely hoist loops 
single domain optimizations 
library interfaces provide range different routines designed handle special cases efficiently 
example matrix library provide special routines handling triangular matrices 
knowing safely routines require significant expertise 
class optimizations automates selection specialized routines including identifying opportunities ensuring correctness 
cross domain optimizations 
layering encapsulation library code carries performance penalty 
libraries compiled ahead time making difficult take advantage information particular applications 
cross domain optimizations provide systematic way break open layers exposing library implementation compiler proceedings ieee library property action linear algebra special forms triangular tridiagonal replace general purpose routines special purpose routines graphics drawing state lighting shading options inline specialize routines avoid unused filters file access file state open closed report error accessing closed file threads lock state locked unlocked report double locking bugs plapack matrix distribution row column distribution remove unused code handles distributed cases libraries validity check unchecked remove redundant error checking fig 

libraries properties context application 
optimizations combine application libraries single integrated customized piece code 
identifying optimization opportunities typestate central task library level optimization identify places legal profitable change application 
changes typically straightforward single domain optimizations replace general purpose library call special purpose call series low level library calls cross domain optimizations consist inlining followed optimization 
challenges express conditions optimization applies identify parts application satisfy conditions 
observe conditions library level optimizations depend kinds information states objects passed library call global fact state computation 
cases representation states expresses domainspecific information 
example series linear algebra computations result matrices special forms triangular tridiagonal 
knowing matrices properties compiler knows replace general matrix multiply call exploits special forms 
refer notions special form domainspecific properties refer possible states triangular tridiagonal property values 
aspects efficiency correctness expressed conditions property values objects 
table shows concrete examples libraries associated properties actions compiler take deriving information 
properties form typestate include features types states 
behave types property values related subtyping relation 
example diagonal matrices defined subtypes triangular matrices 
specifically property values property explicitly organized lattice see section iid 
details 
properties behave states different values different points program 
example matrix start empty initialized factored triangular form 
broadway optimization process typestate properties proceeds follows library expert designs set domain specific optimizations encodes information annotation language 
step involves identifying properties property values significant library 
specifying behavior library routine terms properties 
specifying code transformations library routine predicated property values arguments 
application programmer obtains annotation file passes broadway 
compilation broadway consults annotations determine interpret manipulate library routine calls solves typestate analysis problem yielding assignment property values objects application 
evaluates predicates call site applies code transformations predicates true 
performance typestate information detect incorrect unsafe uses library routines 
case results typestate analysis emit compile time error messages guide code transformations 
feature helps produce robust systems improves programmer productivity 
library specific error messages useful provide immediate feedback coding mistakes delaying problems run time 
addition facility check deeper security flaws 
security critical high performance computing growing popularity grids distributed computing 
annotation language broadway system domain specific information provided annotations library specifies analysis problems code transformations error messages 
give brief overview language complete discussion 
annotation language conveys kinds information compiler dependence information library interface including uses defs pointer structures manipulated routine domain specific program analysis problems solved compiler analysis framework domain specific optimizations expressed code transformations contingent analysis results compile time messages emit messages command line analysis results 
annotation file library organized routines interface 
routine entry proceedings ieee file contains information related routine 
addition global annotations apply routines 
show grammar kind annotation standard library examples 
note grammar descriptions adopt conventions italics indicate non terminals indicates literal keywords identifier 
procedure procedure identifier list pointers analyze transform report pointers entry structure exit structure structure varname varname new structure varname structure delete varname access identifier list modify identifier list dependence annotation grammar procedure fopen path mode entry path path string mode mode string access path string mode string exit return new file handle procedure fclose file entry file file handle exit delete file handle example fig 

pointer dependence annotations provide way describe library traverses updates pointer data structures 
operator declares points relationship 
library interface information annotations library routine enclosed procedure annotation 
shows grammar part language example annotations standard file routines 
procedure annotation library routine set pointer dependence annotations describes behavior entry annotation describes pointer structures expected input library routine 
annotation tells compiler traverse pointer structures provides names internal objects 
arrow thought points operator leads natural declarative description pointer structures 
access annotation lists objects routine accesses 
list refer variables interface names introduced entry annotations 
modify annotation lists objects routine modifies 
information dependence analysis need describe routine modifies 
exit annotation describes changes pointer structure effected routine 
example indicates fopen routine takes pointers arguments accesses targets pointers allocates returns new object 
callsite compiler binds actual objects involved names annotations 
compiler terms access modifies annotations specify uses defs routine respectively 
note pointer dereference automatically recorded access pointer update automatically recorded modification 
information broadway compute data dependence information application including library calls 
information includes model heap objects pointer aliases def chains 
dependence information allows compiler perform number traditional optimizations dead code elimination library calls 
property property dir property vals initially property vals property val list property val list property val property val list property val property vals dir forward backward property annotation grammar property open closed initially closed property kind socket local remote file example property definitions lattices properties fig 

property annotations define flow values library specific analysis passes 
syntactic structure implies underlying lattice 
library specific analysis passes mentioned library level optimizations error messages triggered library specific typestate information properties 
annotation writer defines property specifying name property set property values effects library routine values 
property values organized lattice expresses subtyping relation 
broadway uses dataflow analysis push property values application derive assignment property values objects different points program 
property property values defined property annotation effects library routines defined analyze annotations routine 
shows property annotation grammar including proceedings ieee examples annotations lattices imply 
properties direction forward backward indicates way information flows program 
backward properties useful describing objects point program execution 
analyze annotations describe library routine updates property values objects 
shows grammar annotations examples standard library 
analyze annotations unconditional fopen example produces file handle open state 
analyze annotations guarded socket example produces remote socket local socket depending domain argument 
property value tests described 
analyze analyze analysis rule analyze effect analysis rule condition effect default effect condition test numeric comparison condition condition condition condition condition test varname 
varname exactly varname atleast varname varname atmost effect varname varname varname analysis annotation grammar procedure fopen path mode entry exit analyze kind file handle procedure socket domain type protocol entry exit analyze kind domain af inet return domain af unix return examples fig 

analysis annotations specify library routines affect property values 
compiler serve transfer functions 
optimizations error reports library level optimizations error reports defined routine basis 
shows grammar annotations example uses 
optimization consists code transformation guarding condition 
broadway applies code transformation callsite condition true 
similarly error report consists message emit guarded condition 
guarding conditions annotations test results property analysis 
provide operators test property values lattice relationships exactly evaluates true object left hand side ends exactly property value right hand side 
atleast atmost operators represent lattice equal greater equal tests respectively 
socket example property value local atleast socket 

unary operator evaluates true object ends lattice bottom 
operator evaluates true object takes value right point program 
optimization annotations specify transformations apply satisfying callsite replace library call arbitrary code fragment inline library routine implementation assuming library source available 
replacement mechanism works hygienic macros compiler parses checks code fragments ensures expansion results syntactically correct code 
shows code replacement example routine size just fgetc store returned character directly string 
note compiler replaces token actual argument call site 
code replacement facility useful expressing single domain optimizations inlining facility useful cross domain optimizations exposes implementation library routine 
code replacements inlining contingent results dataflow analysis 
feature enables domain specific inlining policies help ensure inlining takes place beneficial 
shows error report example compiler emit message program attempts read file handle open 
compiler replace callsite token line number file name erroneous call site 
compiler design broadway source source translator written 
built top breeze compiler infrastructure inherits components including front parser internal representation suite traditional compiler analysis optimization passes 
shows architecture system 
broadway takes input application written annotation files describe libraries application 
compilation phase compiler consults annotations determine effects call library 
compiler mechanisms central domainspecific optimizations configurable dataflow analysis framework solves domain specific typestate analysis problems annotations code transformation engine tests conditions applies optimizations specified annotations 
addition error reporting mechanism visits library call sites emits messages specified annotations 
proceedings ieee fig 

architecture broadway compiler 
transform condition replace code condition inline report report condition report element report element string literal varname callsite varname action annotation grammar procedure size entry exit size replace fgetc report file handle exactly open error callsite file open examples fig 

action annotations specify optimizations error reports 
dataflow analysis framework uses traditional iterative analysis algorithm solve library specific analysis problem 
includes number powerful features improve precision scalability 
features critical exploiting opportunities real industrial strength software 
framework includes integrated pointer analyzer provides alias information surface variables detailed model heap allocated structures 
pointer information critical library level optimization non trivial library objects accessed pointers 
objects internal structure represented pointer data structures 
dataflow dependences exist internal components sound model memory avoid applying optimizations incorrectly 
second framework employs interprocedural analysis allowing compiler gather information library routine usage large scope 
built language operators library routines bound simple lexical scoping rules 
conjunction pointers library objects flow program 
program analysis required correctness valuable exposing optimization opportunities 
third framework supports range analysis precision policies including client driven analysis algorithm automatically adapts precision response needs analysis problem 
precise system flow sensitive context sensitive provides accurate analysis information nontrivial applications complex software architectures heavy code reuse 
level precision increase analysis costs intolerable level 
client driven analysis algorithm provides accuracy scalability applying precision parts program needed 
iii 
optimizing plapack section demonstrate application technique plapack parallel linear algebra library 
provide background plapack abstractions role optimization 
layered decomposition plapack system describe abstractions layer 
describe library level optimizations specified plapack 
show impact optimizations section iv 
explain technique go considerable detail target library abstractions mechanics optimizations representation annotations 
diving details enumerate important points section complex domains parallel linear algebra contain wide range potential optimizations 
show proceedings ieee annotations capture optimizations small number language constructs 
complexity plapack interface challenging programmers apply optimizations 
compiler mechanisms provide help overcome difficulties automating process 
optimizations valid particular conditions highly domain specific 
configurable dataflow analyzer compiler collect necessary information 
concepts plapack library writing parallel linear algebra algorithms consists approximately lines code provides parallel versions kernel routines blas lapack 
highest level provides interface hides parallelism programmer 
plapack application operates linear algebra objects matrices vectors partitioned distributed grid processors target computer 
application manipulates objects indirectly handles called views 
view specifies set matrix indices subsequent computations 
plapack provides routines create views shift views split views pieces 
shows split logically divides matrix smaller ones fig 

plapack algorithms operate higher level traditional linear algebra algorithms splitting matrices logical pieces called views operating views 
typical algorithm starts entire object splits manageable pieces 
computes directly continues iteratively splitting large remaining piece entire data set visited 
view captures part matrix special properties 
understanding exploiting properties lead significant performance improvements 
plapack kernel routines parallel matrix multiplication implemented lower level set routines data distribution movement explicit 
level library creates objects special distribution properties uses communication routine pla copy transfer data 
example shows compute outer product matrix column panel matrix row panel 
algorithm creates overlapping replicated panels rows columns 
uses pla copy routine copy data original panels replicated forms 
result processor contains right pieces panels perform local matrix multiply completes computation 
plapack parlance local operations sequential computations serve building blocks parallel counterparts 
optimizations describe specific optimizations produce results section iv 
categorize plapack layer apply 
shows conceptual layers plapack implementation 
layer programming abstractions optimizations 
derive plapack optimizations number sources 
cases codify techniques suggested plapack publications 
cases examine plapack programs determine possible performance improvements 
discover potential optimization determine circumstance applies formulate program analysis pass detect circumstance 
parallel blas sequential blas data distribution message passing interface fig 

logical layers plapack implementation 
programming highest level desirable provides powerful abstractions hides complexities parallel programming 
leverages large body reusable code underneath 
working high level programmers optimization opportunities exploit explicit parallelism 
programmers ideally write code highest level tool compile code lowest level 
system provides way 
global layer parallel blas highest layer provides parallel linear algebra operations hides parallelism application developer 
consists operations view regardless data resides 
level optimizations terms matrix domain 
scalar algebra 
pla scal routine multiplies elements matrix vector scalar constant 
constant known call effect removed 
constant zero replace call special plapack call sets elements zero 
matrix algebra 
scalar algebra exploit matrix multiplication identities 
pla routine computes form optimizations slightly different 
zero matrices code effect removed 
identity matrix call essentially computes matrix addition 
replace call code explicitly adds elements entirely local operation requires communication processors 
proceedings ieee fig 

algorithm compute distributed outer product multi vectors explicit data replication local computation 
middle layer data distribution fig 

plapack distributes matrix data processors 
split operations result special case distributions sub matrices reside entirely processor 
middle layer uses structured forms communication expose notions data distribution locality 
show way split overlaid grid represents partitioning data grid processors 
actual partitioning complex simple block distribution basic observations hold 
notice splitting matrix certain pieces reside entirely columns processors rows processors single processor 
way split yields local view resides entirely processor column panel resides column processors row panel resides row processors fully distributed submatrix 
take advantage information improve performance 
particular algorithms designed process distributed matrices significantly simplified customized row panels column panels 
layer consists sequential blas calls operate local pieces data invocations pla copy routine move data processor grid 
effective optimizations come breaking open global layer routines expose middle layer implementations 
reason global layer routines designed kind linear algebra object regardless size distribution 
applications pass particular special distributions routines exploit extra information create customized version routine particular distribution 
enumerate special cases define set optimizations transform generalpurpose implementation customized version special case routine selection 
internally plapack routines multiple implementations specialized different situations 
example general matrix multiply routine pla implemented internally different algorithms different matrix shapes 
runtime routine chooses algorithms comparing relative sizes input matrices 
analysis identify cases compile time avoiding runtime cost 
view optimizations 
simplify matrix splitting routines input view distribution 
example need vertically split column panel resides single column processors 
optimizations eliminate entire loops code 
empty views 
computation empty view removed 
computational routines example pla pla check empty views done runtime incur synchronization overhead 
avoid cost removing code compile time static removal code expose additional optimization opportunities dead code elimination 
lower layer mpi communication lower layer contains explicit communication mpi message passing interface 
identified optimizations level 
example analyze matrix splitting pattern application determine point point broadcast yield software pipelining 
experiments require additional annotations part 
object type analysis ready describe encode specific plapack optimizations annotation language 
plapack pla obj data type represents linear algebra objects 
library create manipulate different kinds objects matrices vectors scalars called multi scalars replicated processors 
internal library data structures maintain type information runtime various library routines handle objects appropriate manner 
pla copy routine particular needs know type objects decide perform data copying 
proceedings ieee annotation language track information compile time 
object types explicit creation routines analysis succeeds accurately determining types statically 
information purposes 
sure types passed computation match expected types 
example pla routine expects matrix vector input 
object type analysis validate requirement compile time 
compile time check succeeds eliminate runtime check improve performance 
compile time check fails issue informative message describing nature location error allows programmer fix having execute debug program 
second object type information perform algorithm selection compile time 
combination distribution analysis described avoid cost runtime switches ordinarily choices 
optimization yield significant performance improvements 
runtime switches removed inline optimize implementation chosen algorithm 
property shown provides names different kinds linear algebra objects 
base types matrix vector projected vector multi scalar 
ordinary vector distributed processor grid manner improves matrix vector operations 
projected vector vector distributed column row matrix 
multi vectors consist vectors stored 
duplicated projected projected multi vector replicated rows columns processor grid 
shows graphically examples projected multi vectors copied distributed projected multi vectors 
property matrix vector fig 

property captures different kinds linear algebra objects supported plapack 
annotate object creation routine record type object 
shows annotations routine creates matrices 
note associate type view structure allow change type object suits computation better 
example treat panel matrix projected multi vector helps reduce amount copy routine 
distribution analysis significant plapack optimizations result recognizing exploiting special case object distributions 
shows property annotations tracking distribution 
define separate properties rows object columns object distribution rows columns vary independently 
procedure pla matrix create datatype length width template ptr align align matrix entry matrix matrix exit matrix new view length width data new data analyze view fig 

object creation routines set type object 
property unknown nonempty distributed local duplicated vector empty property unknown nonempty distributed local duplicated empty fig 

annotations describe different ways rows columns matrix distributed 
distribution object determined initially routine creates subsequently splitting operations applied 
depicts graphically effects pla obj split routine possible shapes input matrix 
shows representative analysis annotations routine codify effects set rules 
actual annotations contain cases model ability routine split matrix relative sides matrix just top left corner 
instances split routine produces empty views happens general purpose routine pla specialized context input matrices fully distributed 
compiler eliminate subsequent operations empty views 
shows example optimization 
see dimensions inputs empty remove call 
furthermore consider loop repeatedly splits matrix matrix desired form iteration loop consumes data views empty loop removed 
procedure pla side diag alpha entry alpha view alpha view view view exactly empty view exactly empty view exactly empty view exactly empty replace fig 

remove operations empty views 
proceedings ieee analyze view exactly distributed view view view view view atleast local view view view view view exactly empty view view view view analyze view exactly distributed view view view view view atleast local view view view view view exactly empty view view view view effects splitting matrices 
annotations codifying effects 
fig 

analysis annotations pla obj split routine 
depending distribution input matrix split routine create special case views empty views 
special case inlining step generating customized routines expose implementations global layer routines 
library specific analysis decide perform inlining inlining performed useful 
level blas routines policy row column distributions input objects local inline implementation 
policy exposes operations local objects tend yield benefit 
shows annotations inlining pla routine performs triangular solve multiple right hand sides 
procedure pla side diag alpha entry alpha view alpha view view view atleast local view atleast local view atleast local view atleast local inline fig 

annotation uses dataflow analysis information define library specific inlining policy 
algebraic simplifications global layer middle layer define optimizations take advantage algebraic identities 
shows examples pla scal routine applies scalar multiplier elements matrix 
scalar equal multiplication effect remove 
scalar zero avoid multiplication operations just set matrix zero 
procedure pla scal alpha entry alpha view alpha length width data data alpha view data alpha replace data alpha replace pla obj set zero fig 

exploit domain specific algebraic identities 
opportunities rare appear inlining 
example pla scal routine called inside implementation pla handle coefficients alpha beta 
cases values proceedings ieee zero minus 
exploit information routine inlined 
redundant copy removal idiom plapack programs copy routine redistribute data suitable form subsequent computations 
input submatrices suitably distributed call site copying necessary 
situation occurs specialization triangular solve routine pla 
unfortunately current annotation language express optimization requires compiler recognize replace sequence library calls 
defined syntax optimization anticipate having capability 
experiments section iv show results fully automated system results include copy remove optimization applied hand 
iv 
results section presents performance results obtained applying system set plapack applications kernels 
find annotations effectively specify library level optimizations optimizations produce significant performance gains layers abstraction 
methodology start written versions plapack programs serve baseline represent ideal programming style code focuses clearly expressing algorithm obscuring hand coded optimizations 
programs generally highest layer plapack means poor implementations 
perform competitively similar programs written parallel programming technologies 
apply library level optimization programs single set plapack annotations 
apply series optimization passes program 
pass performs library specific analysis followed library specific code transformations 
apply set cleanup optimizations including constant propagation control flow simplification dead code elimination 
repeat process new code transformations occur 
find considerable synergy optimizations process typically requires iterations 
programs programs experiments cholesky factorization lu factorization kernel lyapunov equation solver 
baseline version cholesky factorization shown 
lyapunov equation arises control theory applications 
complex poses challenging optimization problem approach 
plapack authors provided baseline implementation 
pla obj split size pla side top size top owner top pla obj split size pla side left size left owner left size min size top size left break pla obj split size size cur pla dummy col pla local cur pla pla side right pla lower triangular pla trans pla diag cur col pla pla lower triangular pla trans min col fig 

main loop baseline cholesky factorization 
annotations shown examples plapack annotations due space limitations include entire annotation file 
summary characterizes annotation file annotation effort 
plapack library consists lines code 
plapack annotation file consists lines annotations 
annotated plapack routines 
routine averages lines annotations 
routines require lines annotate routines view splitting routines require lines handle analysis cases 
annotation file devoted pointer dependence information 
current language information repeated routine 
annotations define library specific program analyses property annotations 
property backward analysis 
error reporting debugging annotations 
code transformation annotations 
majority remove useless computations computing empty view 
describe conditions inlining implementation routine 
emphasis reflects goal generating customized code general purpose routines 
platform experiments broadway cross compiler compile programs locally pentium workstation running linux copy source parallel environment ibm power multiprocessor 
multiprocessor consists tightly bound network way symmetric multiprocessors smp way smp way smps 
processor runs ghz 
compile vendor supplied tools link vendor supplied message passing interface mpi handles non uniform memory architecture 
proceedings ieee problem size percent improvement processors hand coded broadway copy idiom broadway fig 

percent improvement cholesky processors 
curves hand coded broadway copy idiom versions sit top 
performance results programs measure execution time base version broadway optimized versions redundant copy idiom see subsection iii 
cholesky factorization time version hand optimized plapack implementation team 
run program range input matrix sizes range processor grids processors processors 
find general results plapack annotations consistently improve performance 
depending program problem size number processors improvement ranges just percent percent 
processor performance improvement increases increase number processors decreases increase problem size 
suggests annotations effectively eliminating software overhead associated library layers 
redundant copy idiom noticeably improves performance rest annotations contribute significantly 
program show performance improvement obtained broadway 
program specific graphs show percent improvement execution time baseline version processors grid range problem sizes 
shows results cholesky factorization program 
code generated specialization strategy runs percent faster baseline version 
include redundant copy idiom improvement jumps percent 
case broadway generated version runs fast hand coded cholesky factorization written library authors serves upper bound approach 
fact optimizations codified annotations come insights hand coding process 
annotation form problem size percent improvement processors broadway copy idiom broadway fig 

percent improvement lu processors 
problem size percent improvement processors broadway copy idiom broadway fig 

percent improvement lyapunov processors 
easily apply optimizations programs including test programs 
shows results lu factorization 
program dominated calls triangular solve routine redundant copy idiom significant difference 
manual inspection broadway generated code indicates additional optimization opportunities plapack level abstraction 
shows result lyapunov equation solver 
results represent significant test approach program complexity 
specialization strategy improves performance percent 
addition redundant copy idiom improves performance percent 
shows results programs large fixed size problem plotted number processors 
cholesky factorization lyapunov solver library level optimizations provide consistent scalable performance improvement 
lu factorization appears scale poorly processors maintains consistent improvement 
shows execution times programs varying problem sizes 
proceedings ieee number processors percent improvement matrix cholesky lyapunov lu fig 

optimizations consistent scale 
problem size performance processors lyapunov baseline lyapunov broadway lu baseline lu broadway cholesky baseline cholesky broadway fig 

execution time programs 
discussion experiments described lead believe library level optimization effective way optimize layered scientific systems 
observations experiments contribute technique works exploits domain specific semantics ignored conventional compilers 
notion matrices data distributions optimizations applied plapack possible 
technique effective crosses software layers optimizing layer context application layers 
design allows compiler shift domain systematically processing layer 
limited configurability annotations capture useful interesting properties layer abstractions 
find optimizations adequately express language optimizations mpi routines require accurate model communication 
developing annotations difficult task mitigated factors 
develop annotations incrementally adding new optimizations discover 
second cost annotations amortized large number applications library 
manual application plapack optimizations infeasible tedious resulting code incomprehensible 
order provide better optimization error detection services programming tools optimizing compilers software checkers need improved information program behavior 
existing systems focused entirely obtaining information directly application programmers 
observation software libraries programmers providing wealth domain specific information 
capturing codifying information significantly improve quality compilation requiring changes existing programs existing programming practices 
foundational produced promising results believe scratches surface large source optimization 
identified number potential improvements directions richer types dataflow analysis 
annotation language currently supports relatively simple class program analysis problems 
generalized dataflow analyses allow compiler construct complex models library domain 
code patterns 
current compiler allows annotations replace individual library calls code 
expand range optimizations supporting annotations recognize stylized patterns library routine usage replace alter entire sequence 
domain specific traditional optimizations 
current compiler implementation traditional optimizations constant propagation dead code elimination library routines exactly way primitive operations 
traditional optimizations formulate optimizations library routines analogy primitive counterparts 
example tell compiler particular library routine effectively creates copy object apply domainspecific version copy propagation 
traditional optimizations lend technique common subexpression elimination management resources scheduling 
exploiting existing algorithms continue keep annotations simple 
suggests new approach designing software libraries takes advantage compiler support 
library consist distinct interfaces programmer compiler target 
programmer interface focus providing straightforward intuitive access library domain proceedings ieee exposing implementation performance details 
high level interface serves purposes programmer job easier second provides domainspecific information compiler 
compiler interface consists low level library routines serve compiler target give compiler fine grained control implementation 
level routines implement basic building blocks domain 
compiler analyzes highlevel interface generates appropriate implementation assembling building blocks 
technique strictly limited libraries exploit module boundaries occur software convey domain specific information compiler 
research part wider trend programming language research software modularity improve capabilities performance software engineering tools 
hope providing tools practical powerful help move valuable advances compiler research everyday programming practice 
acknowledgments robert van de useful discussions plapack tok improvements broadway compiler 
supported nsf ccr eia aci aci darpa contract 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley englewood cliffs nj 
anderson bai bischof demmel dongarra du greenbaum hammarling mckenney sorensen 
lapack users guide 
siam philadelphia second edition 
baker morrow van de 
plapack high performance high level abstraction 
proceedings international conference parallel processing pages 
benner 
parallel distributed solvers large stable generalized lyapunov equations 
parallel processing letters 
arun 
telescoping matlab dsp applications 
thesis proposal dept computer sciences rice university june 
arun ken kennedy 
automatic library generation telescoping languages 
proceedings sc high performance computing networking conference november 
chiba 
metaobject protocol 
acm sigplan conference object oriented programming systems languages applications pages october 
timothy scott collins 
efficient matrix computations hierarchical type specifications 
phd thesis university texas austin 
luiz derose 
compiler techniques matlab programs 
phd thesis university illinois urbana champaign 
dongarra duff hammarling 
set level basic linear algebra subprograms 
acm transactions mathematical software 
carter edwards po robert van de 
parallel matrix distributions doing wrong 
technical report cs tr university texas austin 
dawson engler 
incorporating application semantics control compilation 
usenix conference domain specific languages pages october 

fast fourier transform compiler 
sigplan conference programming language design implementation pages atlanta georgia 
samuel 
incorporating domain specific information compilation process 
phd thesis university texas department computer sciences 
samuel emery berger calvin lin 
detecting errors configurable program dataflow analysis 
technical report tr dept computer sciences university texas austin february 
samuel daniel jimenez calvin lin 
breeze compiler infrastructure 
technical report tr dept computer sciences university texas austin november 
samuel calvin lin 
annotation language optimizing software libraries 
usenix conference domain specific languages pages october 
samuel calvin lin 
optimizing high performance software libraries 
workshop languages compilers parallel computing pages august 
samuel calvin lin 
client driven pointer analysis 
international static analysis symposium pages june 
hall anderson amarasinghe murphy liao bugnion lam 
maximizing multiprocessor performance suif compiler 
ieee computer december 
ken kennedy 
telescoping languages compiler strategy implementation high level domain specific programming systems 
international parallel distributed processing symposium 
kiczales des rivieres bobrow 
art metaobject protocol 
mit press cambridge ma 
gary kildall 
unified approach global program optimization 
acm sigplan sigact symposium principles programming languages pages 
eugene kohlbecker daniel friedman matthias felleisen bruce duba 
hygienic macro expansion 
proceedings acm conference lisp functional programming pages 
vladimir keshav pingali paul 
compiling parallel code sparse matrix applications 
proceedings acm ieee conference supercomputing cdrom pages 
florian martin 
pag efficient program analyzer generator 
international journal software tools technology transfer 
markus bryan singer xiong jose moura jeremy johnson david padua manuela veloso robert johnson 
spiral generator platform adapted libraries signal processing algorithms 
journal high performance computing applications 
robert van de 
specialized parallel algorithms solving linear matrix equations control theory 
journal parallel distributed computing 
luiz de rose david padua 
techniques translation matlab programs fortran 
acm transactions programming languages systems march 
rob strom yemini 
typestate programming language concept enhancing software 
ieee transactions software engineering 
steven tjiang john hennessy 
sharlit tool building optimizers 
sigplan conference programming language design implementation pages 
robert van de 
plapack parallel linear algebra package 
mit press 
todd veldhuizen 
expression templates 
report 
todd veldhuizen dennis gannon 
active libraries rethinking roles compilers libraries 
proceedings siam workshop object oriented methods inter operable scientific engineering computing oo 
siam press 
daniel weise roger crew 
programmable syntax macros 
sigplan conference programming language design implementation pages june 
deborah mary lou soffa 
automatic generation global optimizers 
acm sigplan notices june 
