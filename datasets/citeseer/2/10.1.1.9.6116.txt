denotational semantics staged execution open code andrew pitts computer laboratory university cambridge andrew pitts cl cam ac uk tim sheard ogi school science engineering oregon health science university sheard cse ogi edu functional meta programming language metaml sheard contains explicit staging constructs generating executing code 
provides finer control order computation traditional languages fixed evaluation strategies 
presents novel denotational semantics untyped metaml provides remarkably simple treatment semantically problematic aspects language computation involves substitution open code values scope variable binding constructs involves persistence reification compiled values contexts expecting higher stage symbolic value 
shown solving suitable domain equation gabbay pitts permutation model names binding produces denotational semantics untyped metaml possessing strong correspondence taha big step structural operational semantics language 
gives rise semantics interpreters metaml written fresh caml haskell validation programming laws contextual equivalence expressions 
staged programs proceed stages 
stage writes program executed stage 
practical examples staged systems include run time code generation dynamic compilation 
order reason systems important understand semantics staging 
answer question appropriate mathematical workspace describing staging 
analogy appropriate 
category sets functions provides sufficient workspace describing semantics simply typed calculus fixed research partially supported uk epsrc gr 
supported nsf ccr 
points semantics compositionally recursion structure terms 
wish add recursion explicitly implicitly considering untyped calculus complicated categories appropriate various categories domains structural recursion remains :10.1.1.50.8851
staging adding staging calculus require shift complexity category domains 
denotational semantics defined structural recursion answers give questions respectively 
get description notion open code presence binding constructs inductive recursive properties propose moving world fm cpos handle reflective nature staged computation move structural recursion denotational descriptions fixed point recursion 
fortunately shift complexity entailed changes large remarkably simple semantics staging 
staged meta programming staged programming language meta programming system uses staging annotations separate metaprogram program executing stage object program program constructed execution stage 
staged language consists core language plus staging annotations 
purpose staging program provide programmer precise control order evaluation 
changing default evaluation order lazy strict programmable gives programmers powerful tools 
eliminate redundant computation saving execution time reduce size intermediate computations saving space 
semantics staged language supply meanings core language staging annotations 
semantics staging provides precise set rules interpreting staging annotations directions evaluated 
core language untyped calculus staging annotations code brackets escape run run 
purpose code brackets delay enclosed computation constructing code expression code brackets 
purpose escape may appear surrounding code brackets escape code construction works splicing code value code template escape appears 
call bracketed expression embedded escapes code template 
purpose run transition stage executing code constructed annotated body 
short examples metaml system illustrate points 
fun pow val pow fn int body pow branches generate code 
branch code template product 
spliced template escape annotation 
left simply code value argument right code valued result recursive call pow 
note value pow function arguments piece code 
declaration cube code defined code template object level expression bound variable body created splicing call pow 
val cube code pow val cube code int note evaluation cube code involves going binder fn evaluating open expression pow 
example see generated code convertible modulo conversion bound variable declaration cube code renamed resulting code value 
hand free meta level variables inside code brackets captured scope code template appears multiplication operators declaration scope includes declarations called cross stage persistence 
generated code executed run map run cube code val int list illustrated map useful strategy generate piece code multiple times generated code free interpretive overhead :10.1.1.34.1931:10.1.1.62.9845
example recursive call inherent pow executed code generation time element list 
www cse ogi edu projects metaml contributions provide denotational semantics untyped subset metaml called introduced taha study metaml operational semantics served vehicle studying type systems staged execution open code :10.1.1.34.1931
syntax operational semantics recalled section 
section discusses form domain equation denotational semantics deal process reification needed model persistence 
domain equation solved section fm cpos version domain theory carried gabbay pitts model fresh names binding 
compared previous approaches presheaf categories model integrates easily key constructs classical domain theory limit colimit construction recursively defined domains logical relations derive properties domains 
fact exploited sections define denotational semantics establish tight correspondence operational semantics 
proof correspondence result theorem complicated semantics run necessitates fixed point recursion structural recursion define denotations expressions proof essential notion support key feature fm cpos deal semantics open code values see 
section discusses applications results semantics interpreters metaml verifying programming laws 
section draws 
language language untyped call value calculus core plus staging annotations bracket escape run 
syntax expressions exp run ranges countably infinite set variables 
usual identify expressions renaming bound variables write result capture avoiding substitution free occurrences expressions classified stages capturing formedness condition escape appear inside corresponding set brackets 
expression classified stage surrounded additional brackets satisfy nested escapes 
formally sets exp stage expressions inductively defined 
hard see exp exp union sets exp exp defines operational semantics form inductively defined family relations exp val val exp exp exp exp exp exp exp exp exp exp exp run exp exp run run run 
staging evaluating expressions subset exp consisting stage values val exp val val exp 
note requirement values closed expressions 
ultimately interested evaluating closed stage expressions necessary consider evaluation higher stage expressions open expressions 
wishes simplify code evaluating cf 
cube code example 
example closed stage expression evaluates closed stage code value derivation evaluation fact open stage expression evaluates 
complicated example phenomenon appendix 
recursive domain equation section motivate form domain equation solve order give denotational semantics 
assume familiarity simple domain theory chain complete partial orders cpos continuous functions see :10.1.1.50.8851
fact reasons emerge section usual category cpos category fm cpos describe section moment just refer cpos precise 
seek cpo elements give denotations stage values 
stages greater values denotations just coincide syntax trees modulo conversion 
take cpo denotations stage values just set val regarded discrete cpo val exp 
discrete cpo partial order relates elements iff equal cpo code values approximations 
computational effect non termination construct fixed points call value untyped calculus 
give denotations non value expressions stage lifted cpo interpreting non terminating expressions element 
main thing explain definition obtained solving domain equation fun bra 
equation fun discrete cpo set exp stage function values bra discrete cpo set val stage code values 
understand particular domain equation note set val stage values disjoint union fun bra correspondingly disjoint union cpos elements bra bijection stage values val noted denotations higher stage values taken equivalence classes syntax trees take second component disjoint union set bra regarded discrete cpo 
component function value fun determines substitution function stage values val stage expressions exp analogy denotational semantics call value calculus try solving suitable domain equation take cpo continuous functions lift denotations elements exp sufficient take product fun function cpo discrete cpo fun explain order take account phenomenon cross stage persistence mentioned 
cross stage persistence refers fact variables fun bra specified recursive domain equations see 
stage expressions stage value substituted free variable expression may implicitly coerced higher stage inclusion val val example term exp evaluated original stage occurrence denotationally function object ends stage resulting value val code object 
model coercion values lower higher stages denotationally need functions suitable properties 
val val fact sufficient give single function reify val turning denotations back syntactic values giving function amounts giving pair functions type val type val fun just function space expected take function val simply second projection composed inclusion fun val function val inclusion bra val fm domain theory section describe kind domains solve domain equation 
operational semantics involves open code values capture avoiding substitution give corresponding denotational semantics need setting support conversion bound variables freshness names free variables 
approach issues dependence semantic objects names explicit parameterizing contexts free names leading various kinds functor categories 
alternative ways simpler approach emerged leaves dependence semantic objects names implicit notion finite support explained turn properties sets equipped action name permutations 
permutation model sets atoms devised fraenkel mostowski order study axiom choice shown provide syntax independent mathematical model fresh building second syntactic component denotations function values get simple totally defined reification function 
literature normalization evaluation see survey contains complicated notion reification mathematical functions reified applying fresh variable normal forms variables denotational values setting recursively applying reification function result obtain code abstracting code respect fresh variable 
method open variables stage values lack supply suitably generic elements fortunately nave approach reifying semantics syntax works purpose 
names conversion 
section simple domain theory just chain complete partial orders continuous functions fraenkel mostowski universe sets atoms 
follows set variables set atoms consider mathematical structures equipped notion swapping atoms 
action permutations general swapping definable see 
definition fm cpos continuous functions 
fm cpo respect fixed countably infinite set atoms specified set partial order function swap write swap 
required satisfy properties define 
finite support property holds finitely 
shown properties imply possesses smallest finite subset supp supp called support 

upper bounds lubs chains finitely supported sense finite subset xs supp xs 
continuous function fm cpos definition monotone function preserves upper bounds finitely supported chains respects swapping action 
require fm cpo lubs chains may cpo usual sense 
requiring just lubs finitely supported chains sufficient category fm cpos continuous functions support usual constructions domain theory needed minimal solutions fixed point equations level elements fm cpo recursively defined fm cpos 
fm domain theory turns example set fin finite subsets ordered inclusion swapping xs xs certainly cpo strictly increasing chain finite sets upper bound fin fm cpo turns chain finite sets xs xs xs finitely supported iff xs contained finite set iff chain eventually constant lub 
similar classical domain theory just remember constructs involving subsets functions restricted finitely supported subsets functions 
notion finitely supported chain case point fm cpo continuous functions gives cartesian closed structure category fm cpos defined follows 
definition fm cpo continuous functions 
fm cpos note define notion swapping atoms functions defining function mapping just special case usual definition action permutations functions satisfies property definition swap swap 
order satisfy property just cut functions property respect swapping action 
fm cpo continuous function underlying set monotone functions preserving lubs finitely supported chains crucially holds finitely partial order usual pointwise iff holds continuous functions defined definition precisely elements supported empty set case holds easily seen equivalent preserving swapping action 
may elements non empty support example non empty support constant function value element support non empty equal fact 
fm cpo contains element usual tarski construction form fixed points elements finite support chain form lub usual pre fixed point fix 
hard see fix continuous function fm cpos fix notions constructs classical domain theory need transfer easily setting 
lift fm cpo obtained usual adjoining element turns swapping action forced 
fm cpo continuous partial functions combination fm cpo continuous functions lifting product cpos swapping component wise 
similarly disjoint union fm cpos 
note sets syntax closed swapping variables give rise discrete fm cpos partial order just equality chains constant trivially lubs 
discrete fm cpos need set sets exp val stage expressions values subsets fun bra stage function code values section 
notation 
notation connection lifted fm cpos write corresponding element borrowing moggi computational calculus meta expression determining element fm cpo partial functions ranges write element necessarily unique 
write operation kleisli composition continuous function sending function 
recursive domain equations involving discrete fm cpos lifting products sums continuous partial functions constructs don need solved fm cpos way classical domain theory limit colimit construction resulting characterized minimal invariant property theorem :10.1.1.50.8851
omit details just give theorem sums need know minimal invariant fm cpo domain equation 
theorem existence 
fm cpo equipped continuous functions fn fun br bra satisfying invariance fn br injective disjoint images jointly surjective determine isomorphism sum fun bra particular continuous functions bra fm cpo induce continuous function effect write case fn br 
minimality consider continuous function mapping case fn fn br br notation notation fixed point fix equal 
full domain equations 
construct differentiates fm domain theory classical version existence fm cpos atom abstractions see section 
inductive characterization sets syntax modulo conversion follows sets val exp regarded discrete fm cpos minimal invariants suitable simultaneous recursive domain equations mirroring inductive definition sets capture binders modulo renaming 
give countably indexed family domain equations define fm cpos 
purely terms constructs starting 
summands represent variables expressions applications code values respectively forms legally appear inside code values 
denotational semantics section give denotational semantics expressions fm cpos previous section 
stage denotation stage expression exp respect valuation finite partial function variables elements element lifted fm cpo denotations shown construct properties 
unfortunately properties support definition recursion structure expression presence run expressions second branch clause taken applied expression subexpression derived denotational semantics 
construct specified properties fixed point suitable continuous function fm cpos 
exp env exp define den recursion structure defining clauses replaced den den run den case fn br side condition clause provided supp supp 
case function maps exp exp den determines continuous function fm cpo exp 
fm cpo element exp noted section form fixed point function call define den deduce properties 
ole freshness 
clause subtle may appear place fm cpos associated notion finite support definition comes play 
clause compute denotation open stage expression binder 
doing get desired correctness property particular substitution property avoid inadvertent capture free variables introduced valuation requiring support supports provide semantics notion set free variables syntactical object 
identify expressions equivalence choose representative parse tree bound variable finite set supp righthand side clause independent choice general reason 
fm cpos suppose continuous function vd satisfies supp supp 
supp finite subset infinite set certainly satisfying supp 
hard see property guarantees 
get new function fresh defining fresh supp 
case fresh continuous involving continuously notation fresh element fresh notation written clause concretely fresh 
condition holds case supp coincides finite set free variables contain ole valuations 
denotational semantics languages involving execution open code primary role valuations provide meanings free variables open expression giving denotation 
situation complicated 
free variables appearing higher stage positions expression values 
perfectly possible undefined valuations supports env fm cpo partial order induced swapping action sends env finite partial function mapping dom dom calculate support supp valuation coincides finite set variables dom dom supp 
valuations env fin empty non empty 
reification reify val defined reify case fn br 
denotations exp env satisfies dom dom reify fn reify provided supp case fn br br case fn br run case fn br run run clause reify denotes expression obtained simultaneous capture avoiding substitution value reify free occurrences ranges dom domain definition 
see discussion side condition clause 

specification denotational semantics expressions free variables example distinct variables may calculate element fn bra discussing correctness properties denotational semantics section restrict attention case just empty valuation 
need consider valuations 
answer lies clause 
component meaning stage function abstraction function semantic values usual calculate function denotational semantics body function abstraction respect suitably extended valuation 
correctness section establish tight correspondence denotational semantics operational semantics 
certainly case sound lemma 
call value calculus denotational semantics minimal invariant cpo domain equation converse soundness holds called computational adequacy closed term evaluates call value syntactic value closed abstraction 
get stronger converse soundness find syntactic value expression evaluates reifying denotational semantics 
theorem gives precise statement 
proof far straightforward outline rest section 
theorem correctness 
stage expressions exp stage values val holds iff satisfying reify words partial function exp val deterministic evaluation relation coincides reify 
ii higher stage expressions exp values val holds iff 
words partial function exp val deterministic evaluation relation coincides 
lemma denotation values 
val env unique element 
proof 
shows induction structure higher stage value val reify holds valuation env particular 
follows properties val env lemma soundness 
stages stage expressions exp stage values val 
proof 
proved induction derivation evaluation rules 
closure rule stage function application prove substitution property denotational semantics induction structure example 
empty valuation lemma necessary may case arbitrary valuation example consider evaluation run 
valuation fn reify run fn fn fn reify fn 
clearly particular run run soundness easy half correspondence operational denotational semantics 
establish harder half theorem construct apply certain logical relation semantics syntax 
lemma logical relation existence 
binary relation elements fm cpo stage values val properties 
property auxiliary relation exp defined val 
val holds iff fn fun satisfying val ii br bra 
admissibility val set closed upper bounds finitely supported chains fm cpo happen open expression closed hard see es es lemma applies 
construction done adapting world fm cpos relational properties recursively defined domains section flow minimal invariance property property theorem 
fact distinctive properties fm cpos swapping atoms finite supports hinder method construction 
omit details 
combining property lemma definition reify get connection reification logical relation 
lemma 
val reify lemma specifies logical relation stage 
higher stages recalling val exp define val just equality relation exp 
define exp exactly way defined terms find exp 
lemma logical relation fundamental property 
stages stage expressions exp case holds 
proof 
standard method proving property logical relation formulate stronger hypothesis open expressions preserving logical relation prove induction structure expressions 
method relies denotational semantics defined structural recursion 
adapt method noted section semantics run expressions forces construct fixed point recursion scott induction structural induction 
recall auxiliary functions den section fixed point definition denotational semantics 
exp satisfies exp prove stages valuations value substitutions finite partial functions variables stage values den means dom dom holds dom 
proved induction structure lemma den defined structural recursion 
follows continuous function exp exp 
den exp exp maps set exp exp 
virtue lemma closed lubs finitely supported chains fm cpo exp certainly contains element fm cpo exp way defined scott induction fixed point 
applying empty value substitution trivially satisfies get den proof theorem 
part take definition lemma lemma definition terms determinacy evaluation holds reify lemma 
conversely reify lemma definition holds reify lemma reify part ii lemma property 
conversely lemma holds definition applications semantics interpreters translate denotational semantics section recursive declaration interpreter suitable higher order functional language 
fresh caml www freshml org patch inria objective caml system www ocaml org particularly suitable swapping freshness properties fm cpos built definition see 
fresh caml rapidly prototype various ideas denotational semantics way 
fresh caml somewhat experimental 
attractive alternative carried second author write haskell library freshml style treatment name swapping binding produce semantics implementation generally metaml haskell 
fresh caml code interpreter denotational semantics appendix 
interpreter shares advantages calculus normalization evaluation see survey albeit untyped section type directed variety functions function application interpreted functional language implementation functions application example building passing function closures 
correctness theorem strong evidence interpreter agrees evaluation relation course formal proof involve operational semantics fresh caml 
programming laws standard corollary correctness results theorem expressions denotation contextually equivalent sense operationally produce termination behaviour context 
theorem computational adequacy 
stages stage expressions exp suppose env contextually equivalent closed stage expression containing occurrences denotes result replacing occurrences val val theorem deduce program equivalence laws hold contextual equivalence cf 
properties call name taha establishes confluent reduction system 
corollary basic reductions contextual equivalences writing ctx indicate stage expressions contextually equivalent 
equivalence exp val ctx 
ii exp ctx 
iii closed exp run ctx full abstraction 
denotational semantics designed type application mentioned section semantics implementations staged meta programming languages metaml tool establishing contextual equivalences 
denotational equality implies contextual equivalence theorem relations equal words denotational semantics certainly fully 
reason goes usual reasons failure full abstraction models sequential higher order functions 
elements fm cpo denotation stage values element example denotational equality demands denotation expressions equal respect valuations including ones non definable elements 
example discrepancy denotational equality contextual equivalence consider fact law corollary iii probably holds stage expressions just closed ones 
say probably relatively little known properties contextual equivalence 
provided answer question started appropriate mathematical workspace describing staging 
answer consists adapting traditional methods domain theory permutation model fresh names binding provided 
far know gives denotational semantics metaml style multi stage metaprogramming 
useful semantics sheds light subtleties involved staged execution open code implicit existing operational semantics domain theoretic methods potentially powerful 
power show operational semantics recovered denotational semantics gives rise implementation metaml staging 
pursue expect methods study important topic type systems staged meta programming languages semantic notions code types associated logical relations may useful proving correctness existing proposals sophisticated type systems metaml type bindingtime analysis 
expect theory useful giving semantics meta programming languages permitting intensional analysis code 
abramsky jung :10.1.1.50.8851
domain theory 
handbook logic computer science volume chapter 
oxford university press 
ager danvy 
interpreter compiler virtual machine functional derivation 
technical report brics rs dept computer science univ aarhus 
burger 
efficient compilation profile driven dynamic recompilation scheme 
phd thesis indiana univ computer science dept 
burger dybvig 
infrastructure dynamic recompilation 
proc 
international conf 
computer languages pages 
ieee 
dybjer filinski 
normalization partial evaluation 
applied semantics advanced lectures volume lncs pages 
springer 
engler hsieh kaashoek 
language efficient machine independent dynamic code generation 
proc 
popl pages 
acm 
fiore plotkin turi 
syntax variable binding 
proc 
lics pages 
ieee 
gabbay pitts 
new approach syntax variable binding 
formal aspects computing 
mock philipose chambers eggers 
expressive annotation directed dynamic compiler theoretical computer science 
philipose mock chambers eggers 
evaluation staged run time optimizations 
proc 
pldi pages 
lee leone 
optimizing ml run time code generation 
proc 
pldi pages 
leone lee 
dynamic specialization fabius system 
acm computing surveys 
moggi 
notions computation monads 
information computation 

meta programming names necessity 
proc 
icfp pages 
acm 
oles 
types algebras functor categories block structure 
nivat reynolds editors algebraic methods semantics chapter pages 
cambridge university press 
pitts 
relational properties domains 
information computation 
pitts 
nominal logic order theory names binding 
information computation 
plotkin 
lcf considered programming language 
theoretical computer science 
poletto hsieh engler kaashoek 
tcc language compiler dynamic code generation 
acm toplas 
sheard linger 
search binding time analysis type directed 
proc 
asia pepm 
acm 
sheard thiemann 
metaml run constrained type system staged execution open code 
submitted oct 

swapping atom programming binders fresh caml 
proc 
merlin 
acm 
pitts gabbay 
freshml programming binders simple 
proc 
icfp pages 
acm 
smyth plotkin 
category theoretic solution recursive domain equations 
siam journal computing 
stark 
categorical models local names 
lisp symbolic computation 
taha 
multi stage programming theory applications 
phd thesis oregon graduate institute science technology portland oregon usa 
taha 
sound reduction semantics untyped cbn multi stage programming 
proc 
pepm 
acm 
appendix 
fresh caml fresh caml patch inria objective caml system www ocaml org features handling fresh names binding operations described 
user manual example programs available www freshml org foc 
fresh caml declarations give evaluator expressions corresponding closely clauses 
declare type var names variables instantiating polymorphic family types name type type type var name declare datatype exp values bijection expressions modulo equivalence type constructor corresponds fm cpo constructor mentioned 
type exp vid var fn exp app exp exp run exp run bra exp esc exp declare datatype corresponding fm cpo define reification function 
type exp exp reify exp match abs fn abs bra represent valuations association lists library function list assoc perform look ups define function reify valu substitutes reification valuation expression cf 
footnote capture avoidance substitution automatic way name abstraction patterns matched fresh caml 
type valu var list reify valu valu exp exp rec rv exp exp match vid try reify list assoc fn fn rv app app rv rv run run rv bra bra rv esc esc rv rv functions calculating denotations den computes den computes es higher stages functions raise exceptions cases value cases non termination statically detectable 
type stage int exception error string rec den exp valu match vid try list assoc raise error den fn function den reify valu app match den phi phi den raise error den run match den den raise error den bra den esc raise error den den stage exp valu exp match vid try reify list assoc fn fn den app app den den run run den bra bra den esc match den raise error den esc den compute denotation closed stage expressions respect empty valuation reify result theorem give value evaluation relation 
eval exp exp reify den example closed stage expression run exp represented declarations 
fresh fresh fresh exp app run bra fn app esc app fn bra vid fn bra vid fn vid fn vid rules calculate 
correspondingly try evaluating declaration boolean value true 
bool eval bra fn vid declaration uses equality type exp correspond equivalence expressions ok reuse name bound variable 
case fresh caml correctly computes value true 

