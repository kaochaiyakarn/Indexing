xpath queries streaming data feng peng sudarshan chawathe department computer science university maryland college park college park maryland usa cs umd edu design implementation xsq system querying streaming xml data xpath 
clean design hierarchical arrangement pushdown transducers augmented buffers xsq supports features multiple predicates closures aggregation 
xsq provides high throughput memory efcient buffers data buffered streaming xpath processor 
empirical study performance characteristics xpath features embodied xsq systems 

xml de facto standard information exchange amount xml data growing rapidly 
data accessible streaming form 
data items xed serialization application seek forward backward data revisit data item encountered earlier explicitly buffered 
addition data occurs natively streaming form stock market updates real time news feeds network statistics useful process large xml datasets streaming form greater streaming systems sequential scan non sequential data access disk 
sequel term streaming xml refer data occurs naturally streaming form data best accessed streaming form 
address problem evaluating xpath queries streaming xml 
xpath accepted language addressing parts xml document 
host language xquery xslt 
serves stand query language xml 
methods efcient evaluation xpath queries xpath query engines systems powerful languages xquery incorporate xpath 
xpath query consists location path output expression 
location path sequence location steps specify path document root desired element 
material supported national science foundation iis career iis itr 
permission digital hard copies part personal classroom granted fee provided copies distributed prot commercial advantage copies bear notice full citation rst page 
copy republish post servers redistribute lists requires prior specic permission fee 
sigmod june san diego ca 
copyright acm 
output expression species portions functions matching element form results 
location step axis node test optional predicate 
example location path query book year name text book year name 
location path matches elements reachable document root path consisting zero elements arbitrary labels followed book element turn followed name element 
output expression text indicates text content matching name appears result 
rst location step book year closure axis denoting descendant self book node test year predicate 
predicate restricts results name subelements books year subelement content value greater 
automaton methods processing streaming data attractive due clean design 
challenging task building automaton systems xpath queries generation automaton query 
explained examples due xpath features closures predicates conjunction read nature streaming data 
automaton encounters item stream data required determine item query result may unavailable 
unavoidable buffering introduces complexities buffer management buffered data subsequent satisfaction predicates duplicate avoidance 
previous paradigm focuses ltering collection xml documents restricted xpath expressions :10.1.1.29.2817
xpath expressions predicates essentially regular expressions transformed nite state automata fsa accept exactly documents satisfy expressions 
fsa accepts document ltering system returns current document user 
systems need buffer individual elements documents 
shall explain shortly general xpath queries evaluated streaming system lacks buffering capabilities 
system closer match supports xpath expressions retrieve parts document 
support predicates xpath expressions 
encounters element matches path expression query write output 
contrast query includes predicates membership element query result decided immediately general 
system handles predicates query handle closures aggregations 
assumes query contain closure axis 
describe closures pose signicant challenges query evaluation 
note xpath features multiple predicates clo 

id 



type discount 
id 

second 


type discount 



example 















example tag fo op constant fo attribute tag attribute text attribute text count sum op contains bcnf subset xpath sures aggregations important usability advantages especially data semistructured structure unknown query 
write useful query data structure partly unknown closure 
similarly predicates permit accurate delineation data interest leading smaller usable results 
challenges posed features exacerbated data recursive structure explained 
survey real datasets recursive 
contributions best knowledge method evaluating xpath queries streaming data rst handles closures aggregations multiple predicates 
examples illustrate features especially conjunction pose signicant implementation challenges 
methods clean design hierarchical arrangement pushdown transducers augmented buffers 
system easy understand implement expand complex queries 
detailed empirical study xsq related systems section 
study illustrates costs bene ts different xpath features implementation trade offs embodied systems 
methods described fully implemented xsq system released gnu gpl license 
addition serving testbed topic system useful building systems languages include xpath xquery xslt 
rest organized follows 
rest section examples highlight evaluating xpath queries xml streams 
preliminaries including sax data model xpath language covered section 
design basic pushdown transducer bpdt corresponds xpath location step section 
section describes method composing generate hierarchical pushdown automaton hpdt corresponding xpath query 
related summarized section 
section presents results empirical study xsq related systems 
conclude section 
example 
consider query xml data pub year book price encounter rst author element stream know satises path pub book author 
predicate rst location step year evaluated encountered year subelements 
encountered rst price subelement book element 
determine book fails predicate price price subelements 
need buffer book element 
encounter second price element book second predicate evaluates true 
know year pub element author continue buffered 
encounter author subelements second book need buffer authors 
buffer 
encounter second price element second book satisfy predicate 
reach second book element know predicate price evaluates false price subelements 
author elements second book removed buffer 
note author buffer belongs rst book 
determine year element pub element satises rst predicate 
noting author buffer satised predicate determine author sent output immediately 
suggested example need solve problems order evaluate relatively simple query 
may encounter data potentially result encounter items required evaluate predicates decide membership 
need buffer potential result items 
second items buffer marked separately evaluation predicate process items affected predicate 
third encode logic predicates automaton 
example price children fail satisfy predicate reach book element book element fail satisfy predicate 
mean time children satises predicate know predicate true perform operations accordingly 
predicates access different portions data 
evaluated tag encountered evaluated encountering text content 
forms predicates discussed detail 
consider complex example query closures data recursive structure 
suggests data recursive structure pub element line grandchild named pub line 
example 
consider query xml data pub year book author name 
example introduces new problems addition discussed previous example 
closure axis query node descendants may match location step time 
instance pub elements line line match node test rst location step 
consider name element line 
ways match query matches gives different results predicates pub year book author name line true line false line line true line true line line false line true line indicated table match second row results predicates evaluating true 
encounter tag pub element line know pub element line fails predicate year 
remove name buffer possible item satises query 
situation occurs encounter tag book element line 
possible matches evaluated predicates false remove item buffer 
careful cases multiple matches evaluate predicates true 
example add author element line line book element line match rst row evaluate predicates true 
cases avoid duplicates outputting element twice 
examples illustrate encountered designing automaton evaluating xpath queries systematically 
dif culties arise due fact elements xml stream may come order match order corresponding predicates query due recursive structure data 
query contains closure axis multiple predicates keep track information needed proper buffer management 

preliminaries data model xml streams parsers sax api process xml document generate sequence sax events 
opening closing tag element sax parser generates respectively event 
event element comes list attribute name attribute value pairs attribute name key 
text contents enclosed opening closing tag sax parser generates text event 
streaming xml data modeled sequence sax events extended depth event 
xml stream sequence 
attrs 
attrs event element tag depth xml data attrs list attribute name value pairs 

event element tag depth simple pda simple pdt xml stream text 
text text event element tag depth content text event retrieved text 
xpath noted earlier xsq implements xpath including closures aggregations multiple predicates reverse axes preceding sibling position functions pos 
rest focus core subset xpath described grammar shown 
xpath query form 
consists location path 
output expression element matches location path path document root element matches sequence labels location path satises predicates specied syntactically square brackets 
matching element result applying output function element added query result 
output expression specify attribute element text value 
may aggregation function sum applied element content 
output expression specied query query returns elements result set 

basic pushdown transducer pushdown transducer pdt pushdown automaton pda actions dened transition arcs automaton 
nite set states includes start state set nal states set input symbols set stack symbols 
step fetches input symbol input sequence 
input symbol symbols stack changes current state operates stack transition function 
state transition stack operation transition function output operation generate output transition 
note traditional extra buffer operations buffer 
discussed section evaluating xpath queries xml streams requires buffering potential results 
simple pda xml streams introduce pda accepts xml streams certain string 
shows state transition diagram pda accepts xml stream 
text events shown diagram map self transitions 
sax events generated xml stream pda state transition state transition diagram 
event puts tag element stack 
event match tag current element tag top stack 
tags match pops tag stack 
xml stream formed 
pda processed events generated stream pda nal state stack empty 
discussion assume xml stream formed 
pda adapted ltering system xml documents method 
suppose want nd documents contain elements pattern pub book name 
just remove branches lter pda shown 
note state transition event dened lter pda lter pda just stays state 
lter pda reaches state know current xml document contains element satises lter expression return document user 
put output functions state output content name element lter pda pdt answer xpath query 
straightforward extend simple pda pdt answers xpath queries 
main reason pda memory previously processed data stack pda exclusively keep track matching tags 
need results predicates may come combinations sequences determine state transitions actions 
direct solution remember current results predicate mark item ag indicates predicates satised 
methods degrade performance 
instance time evaluate predicate method need go buffer check items affected result 
system complex uses ad hoc methods keep track information needed 
example rst year element satised predicate year year element pub element tested anymore 
need explicitly set ag predicate reset appropriately 
considering different semantics predicates need set operations set reset check check separately 
closures query data recursive naive approach complex 
building bpdt solution problem observations example 
example 
xpath query consider second location step book author pub year book author name text pdt query need perform tasks location step 
book element author subelement need remember fact 

book element author subelement need sure name current book element buffer deleted buffer 

book element author subelement need sure name current book buffer sent output predicates evaluated true 
predicates evaluated hold content buffer handle 
event perform rst task event author element 
event perform second task event book element sure book element author subelement 
event author element need perform third task know predicate current location step true 
intuitively observations suggest associating pdt similar suggested location step form 
buffer operations explained detail shortly 
similar analysis example predicates xpath location steps xpath queries categorized classes events predicates evaluated 

test current element specied attribute attribute satises condition book id book id 

test current element contains text text value satises condition year text 

test current element specied type child book author 

test current element specied child contains attribute value attribute satises condition pub book id 

test specied child current element value satises condition book year 
categorization design template category location steps 
summarize templates 
template start state true state indicates predicate location step evaluated true na state indicates predicate evaluated 
pdt generated location step template called basic pushdown automaton bpdt 
bpdt important features 
result predicate encoded states 
easy show bpdt true state predicate evaluated true bpdt na state predicate evaluated 

logic predicate encoded bpdt 
example see exact logic want location steps pub year example 
children satises criterion bpdt move true state 
children fail predicate bpdt return start state na state signifying predicate evaluated false 
buffer operations bpdt contrast simple pda bpdt buffer organized queue 
operations buffer follows 
enqueue add queue 
clear remove items queue 
ush send items queue output fifo order 
upload move items queue queue bpdt parent bpdt hpdt network explained section 
note dequeue operation queue items queue operated cleared ushed output 
state transitions bpdt need process closures multiple predicates xpath queries bpdt non deterministic 
recall example section runtime keep current state set attr val start state true state template bpdt tag attr val start state true state na state queue upload queue clear text val text val template bpdt tag text val attr val start state true state na state queue upload attr val template bpdt tag child attr val true state na state start state queue clear queue upload template bpdt tag child text val start state na state true state queue queue clear text val template bpdt tag child val queue enqueue output text queue flush text queue flush output queue enqueue queue clear bpdt query pub year step bpdt transition current state input symbol sax event predicate note predicates operations new states stored transition arcs 
bpdt rst matches labels transition arcs 
nd match ignores nds matched arc rst checks predicate null bpdt evaluates evaluates alse 
replaces new state determined transition arc addition state transition may operate buffer produce output 
need process closures bpdt deterministic 
single current state 
transition arc matches current event 
nds match incoming event terminate searching process immediately process incoming event 
need visit transition arc ef cient data structure store arcs matching process efcient 
addition regular transitions bpdt special transitions denoted special labels 
stands closure 
match incoming event labels self transition 
stands wildcard 
match incoming event match event 
stands symbol 
output expression specied query 
case need output element result set 
match incoming event corresponds descendant current element 
example 
bpdt shown uses symbol 
answer query single location step pub year 
see state transitions responsible get descendants pub elements 
difference state know pub element result put descendants queue rst 
soon know predicate true bpdt performs state transition items queue ushed output 
year elements fail predicate bpdt clear queue 
note ush operation transition arc takes care items enqueued text event event year element 

hierarchical pdt combined hierarchical pushdown transducer hpdt form binary tree process xpath queries 
key idea position bpdt hpdt encode results predicates 
bpdt determine predicate evaluated position xed easy get binary tree 
buffer operations determined accordingly 
due space limitation give brief description algorithms section example hpdt state transition diagram shown generated query pub year book author name text 
ignore special transition arcs diagram answer simpler query closures pub year book author name text 
upload function diagram called contents buffer current bpdt moved parent bpdt buffer 
describe process hpdt evaluates query stream shown 
box gure denotes bpdt 
number shoulder box name bpdt 
example 
hpdt starts state 
follows rule usual pdt 
encounters name rst state enqueues text content rst buffer bpdt 
event name element item uploaded buffer bpdt 
event event author element hpdt goes state state uploads item buffer bpdt 
process applies item second name element second book 
event year element hpdt state buffer bpdt contains items rst second 
hpdt encounters text event year element evaluates predicate year text 
result true 
hpdt goes state ush content buffer output 
hpdt returns right result query 
example see bpdt buffer operations determined position hpdt 
example bpdt know right child bpdt 
fact indicates connected na state bpdt 
hpdt reaches bpdt predicate bpdt evaluated 
similarly bpdt right child bpdt know hpdt reaches bpdt predicate bpdt evaluated 
combine facts hpdt bpdt know predicates evaluated 
notice information obtained solely positions easy determine buffer operations systematically 
details described 
building hpdt xpath queries describe build hpdt xpath query 
bpdt decides buffer operation position hpdt denote position bpdt unique id depth bpdt hpdt system sequence number layer right left 
xpath query ids generated described follows 
rst generate root bpdt 
root bpdt consume details please see longer version technical report www cs umd edu xsq start state true state template root bpdt events generated sax parser document root xml document 
root bpdt id 
location step go bpdt generated thought root 
existing bpdt na state generate bpdt right child na state bpdt start state 
bpdt na state set bpdt null 
similarly generate bpdt left child bpdt uses true state bpdt start state 
connect method buffer operation bpdt determined follows 
fact hpdt reaches state including start state bpdt ith predicate evaluated true 
prove fact induction left child connected true state parent means predicate parent evaluated true hpdt reaches states bpdt 
buffer operations bpdt determined results predicates 
note bpdt know predicates higher layer evaluated true 
bpdt bpdt sends content buffer output predicate evaluates true 
generating new bpdt templates modify resulting bpdt axis closure axis 
add self transition marked start state 
transition arc event come start state reach lower layer bpdt marked 
arcs called closure transitions 
usage transitions described shortly 
add output functions lowest layer 
bpdt value sent output directly 
layer output sent buffer 
output expression specied corresponding attribute function added transitions lowest layer 
transition added lowest layer 
running hpdt xsq handles xpath queries closures multiple predicates needs additional mechanisms ensure cases example handled correctly 
show example hpdt encounters name element line ways path element matches query closures query 
matches evaluates predicates query differently 
get result predicates position current bpdt described earlier need solve problem multiple matches matches evaluates predicates true hpdt keeps element result 
example depicts scenario hpdt processing multiple matches 
example 
consider stream 
hpdt process 
hpdt encounters name element line state 
paths 
paths lead state predicates text queue clear queue flush text queue flush bpdt queue clear queue flush bpdt bpdt queue flush queue clear queue enqueue name text queue upload queue enqueue name text queue upload queue upload queue upload bpdt bpdt bpdt hpdt query pub year book author name text queue enqueue name text output name text queue upload bpdt bpdt hpdt generated query pub year book author name text evaluated 
current bpdt id know rst predicate true unknown rst predicate root true 
simply enqueue item text event current element 
rst path item cleared state transition state hpdt encounters book element line corresponds book line 
book element author child predicate second location step evaluates false 
similarly third path hpdt clear item goes state state year child pub element line fails predicate rst location step 
hpdt follows second path output item goes state state encounters year element line 
elements different order hpdt returns correct result 
depth vector keep track path current state 
runtime current state associated depth vector dv 
records depths events trigger state transitions lead current state 
dv state initialized empty 
suppose incoming event new state 
case state transition occurs dv dv appended dv dv dv 
case dv dv removed dv dv dv 
text events change depth vectors 
addition append remove operations operation top returns depth vector 
depth vector essentially simulates stack operations possible path element matches query 
enqueue item associate depth vector current state item 
item may depth vector may enqueued different states 
accordingly perform buffer operations operate items depth vector equal depth vector current state 
example example hpdt goes state encounters pub element line clear buffer 
note item correct match buffer time 
bpdt operates items buffer depth vector current state item corrected match depth vector deleted 
operations items buffer organize items items depth vector kept group operated 
note operations depth vector implemented bitmap vectors 
operations comparisons done integer bit operations 
quite efcient implementation 
possible item enqueued sent output multiple times matches satisfy query 
solution follows 
operate item system mark item output soon match satises query 
item marked output head queue sent output immediately 
remain unchanged matter operations rst item queue 
operation important factor affects performance compared deterministic hpdt show experimental results section 
deterministic hpdt result items determined document order 
perform put function directly write output 
need buffer items check buffer improves throughput xsq system 
need additional rules state transitions due closures 
usually transition arc starts state accepts event depth satises criterion dv top dv top 
special labels different rules 
transition arcs labeled accept incoming event depth 
closure transitions marked signs accept specied event depth 
matches event dv top indicates element corresponding event descendant element leads current state 
dene queue upload function move items current bpdt nearest ancestor current bpdt right subtree 
dene upload function way uploads items buffer directly bpdt na state 
ancestor current bpdt current bpdt left subtree predicate ancestor evaluated true reached true state 
denition ensures function results called clear function 
example 
consider example example 
suppose put function transition arc state current dened event year element 
happens result name element comes text event year element line event 
function arc state 
hpdt reaches state current states depth vector self transition state 
guarantee result item cleared mistake 
denition upload function ensure result item text event year element uploaded bpdt performs ush function state state 
example bpdt upload content bpdt bpdt predicate bpdt evaluated true 
notice denition prevents item cleared clear function state 
cleared aggregations xsq system augmented statistics buffer stat handle aggregations 
stat buffer item aggregation function initial value null 
operations stat buffer 
stat update aggr value update item aggregation function aggr stat value 
example stat update count add number stat 

stat output aggr output value stat 
screenshot xsq system example consider query pub year book author name count hpdt keep replace queue 
flush stat update count number items queue output value stat update count place stat count transition arc state document ends 
resulting hpdt answer aggregation query 
modify semantics stat update emits new value number buffer updated 
get aggregation value data seen far 
feature useful process aggregation queries unbounded streams 

related due space constraints restrict attention closely related xsq systems studied section 
general discussion stream processing refer reader number papers topic example stream processing context dsms system discussed 
methods dynamically grouping similar queries increase system throughput niagaracq discussed 
methods validating streaming xml pushdown automata 
rewriting xpath queries reverse axes equivalent queries forward axes studied 
pebble tree walking tree transducer model dened xml transformation 
streaming xml traversed depth rst order transition combinations visiting previous siblings applicable 
easy apply techniques alternating automaton process streaming xml 
example universal state alternating automaton need get results children label acceptance rejection applicable streaming environment 
systems ltering xml document focus searching collection xml documents match query 
output restricted set document 
systems typically handle predicates handle predicates restricted structural matching 
xfilter system uses nite state automata lter xml streams performance improved indexing combining similar fsas 
yfilter system uses fsa evaluate concurrently submitted lter expressions 
supports predicates elements 
predicates evaluated immediately element apply encountered 
ltering systems yfilter need handle situations predicates evaluated different sequences example 
methods indexing common subexpressions xpath queries data structure called xtrie 
related topic query labeling studied 
authors propose notion requirements index dual traditional data index 
framework provided organize index label nodes streaming xml documents matched requirements index 
recall section supporting closure features xpath requires nondeterminism automaton approaches equivalently combinatorial explosion number states 
system uses lazy deterministic nite state automaton new states added needed runtime 
determinism results higher system throughput 
trade deterministic automaton requires memory nondeterministic counterpart 
authors provide bound size 
transducer approach answer queries written xquery 
main idea decompose query subexpressions mapped xml stream machine 
arranged network chaining output input query semantics 
techniques transforming network single optimizing dtds provided 
key differences xsq handle queries aggregations closures queries example 
second chaining method suitable streaming queries 
example semantics aggregation functions easy express chaining method 
third combination optimization complicated 
group similar queries 
contrast hpdt xsq simple regular structure multiple grouped methods suggested 
currently xsq system schema unaware 
interesting topic automatically incorporate schema information available system optimization 
release version unavailable time writing appear empirical studies section 
network transducers approach evaluates regular path expressions quali ers formed xml streams 
mention querying non streaming xml documents discussed section 
galax full edged implementation xquery language static typing guarantees 
ocaml implementation dom materialization xml document 
full text search engine uses xquery query language supports boolean combinations keywords order query collections xml documents 
preprocess document collection create full text index query processing 
saxon provides system transforming xml data 
transformations specied xsl uses xpath expressions specify patterns 
saxon xslt processors needs build dom tree entire xml document main memory performing operations restricting utility streaming systems 
simple transformations xml stx implemented joost system transformation language designed streaming xml 
stx procedural xslt uses boolean program variables store results predicate query 
predicate evaluation sets appropriate variables cleared explicitly 
time predicates may examined determine appropriate actions output 
element xml stream data precedes determine actions element 
restriction implementation complexities illustrated buffered predicate name support xsq xsq nc saxon galax joost streaming predicates closure xpath xpath xquery stx xslt xpath xquery aggregation system features name size text size number avg max average mb mb elements depth tag length shake nasa dblp psd dataset descriptions examples occur 

implemented xsq system java sun java sdk version 
xml parser xerces java 
implemented versions xsq system xsq nc supports multiple predicates aggregations closures supports multiple predicates aggregations closures 
shows screenshot gui xsq system 
screenshot query macbeth xml shakespeare play collection xpath query contains closure axes predicates aggregation function 
experimental setup conducted experiments pentium iii mhz machine gb memory running redhat distribution gnu linux kernel 
maximum amount memory java virtual machine set mb 
compare xsq system systems process xpath queries xpath queries 
described galax version version version saxon version joost version section 
summarizes query language basic features systems 
systems handle sizes datasets xpath queries 
goal simply compare performance 
study xpath processors want get insights cost support certain xpath features closures predict system perform better kind environment 
example want simple xpath fragment predicates need full xquery engine galax 
need express complicated queries involve constructing new elements resort systems galax 
systems query languages supersets xpath variations xpath modify xpath queries needed ensure queries convey semantics remain unchanged 
cases results enclosed different container elements contents 
experiments systems evaluate queries datasets differ size characteristics including real synthetic datasets 
real datasets shakespeare play collection shake repository nasa saxon galax joost xsq nc xsq query relative throughputs systems different queries shake dataset play act scene speech line love speaker text play act scene speech speaker text act speaker text dblp records dblp pir international protein sequence database psd 
characteristics datasets listed 
synthetic datasets generated ibm xml generator 
characteristics synthetic datasets described related experimental results 
throughput throughput important metric streaming systems data size varies unbounded 
systems sax api parse data 
throughput sax parser parses xml data gives upper bound throughput xml query system 
wrote parsing programs named java 
uses parser 
java uses xerces java specify xsq nc xsq saxon joost experiments 
parsers generally faster java parser parsing involves large number string operation efcient parsers 
mb dblp dataset parsing seconds java uses seconds 
raw throughput normalized throughput systems respect throughput corresponding called relative throughput measure performance systems written different programming languages different parsers 
galax implements parser ocaml 
java ocaml sax parser believe faster java 
shows relative throughputs systems evaluate different queries shake dataset 
shows relative throughput query different datasets 
see xsq nc fastest systems applying queries handle 
important reason determinism systems 
xsq nc buffer data underlying pdt deterministic 
processing query closure xsq nc faster xsq xsq uses non deterministic pdt 
searching matching transition arc automaton xsq nc searching nds match 
contrast xsq go transition arcs current state sure arc handled 
shown example item result xsq nc output immediately xsq needs extra ensure saxon galax joost xsq nc xsq dataset shake nasa dblp psd relative throughputs systems querying different datasets dataset query shake play act scene speech speaker text nasa datasets dataset source name text dblp dblp article title text psd authors author text item twice due non determinism 
see saxon faster xsq process xml data main memory 
saxon uses sax parser load data memory build dom tree evaluates query 
parsing data saxon process main memory 
memory processing efcient support powerful queries 
suitable streaming data general 
see amount memory needs usually times le size 
scale process large xml les 
study time systems spend phase query evaluation 
dark bar represents query compilation time usually includes parsing query building query engine 
gray bar represents preprocessing time 
example saxon loads data memory build dom tree evaluate queries 
builds full text index query data 
see advantage streaming systems return available results soon data available crucial response time system important 
non streaming systems wait preprocessing nish evaluating 
long systems remain memory subsequent queries evaluated faster results preprocessing reused 
memory usage memory usage critical scalability streaming system 
non streaming systems need memory linear size input need load dataset memory 
contrast streaming systems need store small fraction stream 
shows memory usage reported queries datasets size mb mb 
datasets excerpts dblp dataset 
example mb dataset contains rst mb data dataset 
size approximate include closing tag elements mb offset 
see saxon galax memory roughly linear size input data 
linear memory usage constant factor dom system unsuitable large xml les 
xml generator program generate datasets measured total time querying preprocessing building xsq nc xsq saxon galax joost java system preprocessing time query processing time total querying time dataset shake query play act scene speech speaker text note unable determine separate times joost galax 
size dataset mb xsq nc joost galax saxon xsq memory usage systems querying dblp dataset different sizes query dblp inproceedings author title text 
query dblp inproceedings title text 
tested currently supports elements document 
varying size recursiveness 
example dataset size mb nested level parameter xml generator program set maximum repeats parameter set 
see highly recursive data queries closures amount memory xsq uses constant 
recall section xsq needs buffer data closures query 
items buffers determined encounter event element specied rst location step hpdt returns highest level bpdt maximum amount memory xsq needs exceed maximum size elements stream 
characterizing xpath processors systems sensitive order elements data elements involved query 
generate mb dataset template applied repeatedly generate new elements increasing id attributes 
repeat times queries prior posterior id return null result set different systems behave dif joost galax size dataset mb saxon xsq xsq nc memory usage systems querying synthetic datasets different sizes query pub year book id title text 
system handle query dataset 

galax reports stack error try query 
experiments 
throughputs saxon system loads data memory evaluates queries 
traverses dom tree main memory evaluate query document order important 
throughput xsq nc larger query queries 
query xsq nc decide element contents element ignored 
queries data current element buffered closing tag element met xsq nc slower 
xsq sensitive xsq nc order 
recall section xsq knows item result set marks item output rst output item handles possible transitions due non 
study sensitivities result size systems 
systems sensitive result size different degrees 
example slower systems query returns large portion dataset 
query contains tag data returns empty result set immediately 
systems spend similar amount time query matter tags query appear document 
generate test dataset mb consisting types elements top level elements elements tag red green blue 
content element character 
shows relative throughputs systems query returns different types elements 
see xsq nc sensitive result size 
difference performance due different handling data items result 
items result ignored xsq nc stays state 
items result set xsq nc state transitions output operations consist large portion running time xsq nc 
xsq sensitive xsq nc 
described section keeps item rst matter result checks queue transition arcs handled 
difference large xsq nc 
saxon sensitive result size loads data main memory evaluation process done main memory output process constitutes small amount total execution time 
smaller difference caused cost 
clear joost sensitive id posterior prior xsq nc xsq saxon system effect data ordering throughput blue green red xsq nc xsq saxon joost system effect result size throughput result size 

described design implementation xsq system evaluating xpath queries streaming xml data 
distinguishing feature xsq buffers data buffered streaming xpath query processor 
xsq clean design hierarchical network pushdown transducers augmented buffers 
xsq system fully implemented supports features multiple predicates closures aggregation 
empirical study xsq related systems order explore costs xpath features implementation choices 

franklin 
efcient filtering xml documents selective dissemination information 
vldb journal pages 
avila raven green gupta suciu 
xml toolkit light weight xml stream processing 
www cs washington edu homes suciu 
babcock babu datar motwani widom 
models issues data stream systems 
st acm sigact sigmod sigart symposium principles database systems pages madison wisconsin june 
barbosa mendelzon lyons 
template data generator xml 
fifth international workshop web databases madison wisconsin june 
becker 
joost original streaming transformer 
joost sourceforge net 
becker 
streaming transformations xml 
www cz stx 
chan felber garofalakis rastogi 
efcient filtering xml documents xpath expressions 
th international conference data engineering 
chandra kozen stockmeyer 
alternation 
journal acm jacm 
chen dewitt tian wang 
niagaracq scalable continuous query system internet databases 
acm sigmod conference pages 
choi 
real dtds 
fifth international workshop web databases madison wisconsin 
dan tobias 
evaluation regular path expressions xml streams 
technical report pms fb institute computer science ludwig maximilians university munich may 
fischer franklin 
yfilter efcient scalable filtering xml documents 
th international conference data engineering san jose february 
fernandez simeon 
galax 
db bell labs com galax 
green miklau suciu 
processing xml streams deterministic automata 
th international conference database theory siena italy january 
ibm 
xml generator 
www alphaworks ibm com tech 
katz 

www com 
kay 
saxon xslt processor 
saxon sourceforge net 
lakshmanan 
efcient matching streaming xml documents queries 
international conference extending database technology pages prague czech republic march 
papakonstantinou 
transducer xml query processor 
th international conference large data bases hong kong august 
milo suciu vianu 
typechecking xml transformers 
proceedings nineteenth acm sigmod sigact sigart symposium principles database systems pages 
acm press 
meuss bry 
xpath looking forward 
workshop xml data management th conference extending database technology prague march 
springer verlag 
vianu 
validating streaming xml documents 
st acm symposium principles database systems pages madison wisconsin june 
xsl working group xml linking working group 
xpath xml path language xpath 
recommendation www org tr xpath november 

