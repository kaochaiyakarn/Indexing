detection collisions self collisions image space techniques bruno heidelberger matthias teschner markus gross computer graphics laboratory eth zurich 
image space techniques shown efficient collision detection dynamic simulation animation environments 
proposes new image space technique efficient collision detection arbitrarily shaped water tight objects 
contrast existing approaches consider self collisions approach combines image space object representation information face orientation overcome limitation 
image space techniques commonly implemented graphics hardware software solutions neglected far 
performance gpu implementations cpu implementation proposed collision detection algorithm compared 
results suggest graphics hardware accelerates collision detection geometrically complex environments cpu implementation provides flexibility better performance case small environments 
keywords 
collision detection self collision image space technique graphics hardware animation 
efficient collision detection fundamental problem physically simulation computer animation gan tes 
especially collision detection addressed cloth modeling vol pro bri medical simulations handle interaction surgical tools tissue lom 
applications robotics cam computational biology tur games mel 
order accelerate collision detection rigid bodies approaches pre computed bounding volume hierarchies proposed hub qui got klo ber lar zac bra 
case deformable objects hierarchical data structures permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
journal wscg vol 
issn wscg feb czech republic 
copyright union agency science press pre computed updated frequently 
effort spent optimize update lar expensive case dynamic environments 
image space techniques proposed collision detection mys bac hof kim hei kno gov 
approaches commonly process projections objects 
require pre processing employ graphics hardware 
especially appropriate dynamic environments 
new image space technique collision detection arbitrarily shaped deforming objects water tight surfaces 
approach layered depth images ldi hei 
contrast new method combines ldi object representation information face orientation detect collisions self collisions 
compares cpu gpu implementations collision detection algorithm 
results suggest graphics hardware accelerate collision detection large environments faces cpu implementation provides flexibility better performance case small environments consisting surface triangles 
graph ics hardware efficient ldi required collision detection multiple rendering passes required 
contrast cpu implementation processes rendering pass 
additionally data read back gpu comparatively expensive small environments avoided 
related early approach image space collision detection outlined shi 
depth layers convex objects rendered depth buffers 
interval smaller depth value larger depth value pixel approximately represents object efficiently interference checking 
similar approach bac 
methods restricted convex objects consider self collisions 
mys image space technique detects collisions objects 
approach process concave objects 
maximum depth complexity limited 
additionally object primitives pre sorted 
method efficiently deforming objects self collisions detected 
application image space collision detection cloth simulation vas medical application lom intersections surgical tool deformable tissue detected rendering interior tool 
approaches restricted convex objects 
hof image space method employed collision detection proximity tests 
method restricted objects 
kno edge intersections surfaces detected multi body environments 
approach efficient 
robust case occluded edges 
gov image space methods combined object sub object pruning collision detection 
approach handle objects changing topology 
setup complex considered 
hei image space technique compute ldi representation object 
data structure collisions detected 
self collisions 
contrast existing approaches proposed approach detect collisions different objects handles self collisions arbitrarily shaped deformable objects closed surface 
image space algorithm computes ldi allows process different collision self collision queries 
self collisions object detected 
second intersection volume objects computed 
third vertices penetrating volume object detected 
additionally investigate drawbacks benefits different gpu cpu implementations 
method section image space approach detection collisions self collisions 
overview algorithm sec 
followed detailed description different implementations 
sec 
sec 
address variants accelerated graphics hardware 
sec 
describes implementation employ gpu 
refer sec 
performance analysis discussion characteristics implementations 
overview approach detects collisions self collisions objects manifold geometry 
approach confined triangular meshes watertight object surface required order perform volumetric collision queries 
algorithm computes approximative volumetric representation object 
representation different collision queries 
algorithm proceeds stages 
stage computes volume interest voi 
voi axis aligned bounding box aabb representing volume collision queries performed 
case self collision test voi chosen aabb object 
collision test pair objects performed voi intersection aabbs objects 
voi empty collision detected algorithm aborts 
voi empty objects voi processed stage 
stage computes ldi objects inside voi 
note ldi generation restricted voi object primitives outside voi discarded 
ldi consists images layers depth values representing object surfaces 
depth values ldi interpreted inter sections parallel rays scan lines entering exit object 
ldi classifies voi inside outside regions respect object 
concept similar spirit known scan conversion algorithms fill concave polygons fol intersections scan line polygon represent transitions interior exterior 
contrast hei additional information face orientation stored ldi 
depth front face back face classification known entry ldi data structure 
stage results ldi sorted depth values explicitly labeled entry front face exit back face points voi 
stage performs possible collision queries 
self collisions detected analyzing order entry front face exit back face points ldi 
correctly alternate self collision 
invalid sequences front faces back faces detected operation provides explicit representation volume 
collisions pairs objects detected combining boolean intersection 
intersection inside regions empty collision detected 
operation provides explicit representation intersection volume 
individual vertices tested volume object 
vertex transformed local coordinate system ldi 
transformed vertex intersects inside region collision detected 
voi computation stage collision queries stage significantly contribute computational cost algorithm see hei 
ldi generation stage comparatively expensive analyzed variants 
variants employ gpu obviously useful stage basically triangles 
lack flexibility gpu implementations data read back delay motivated third implementation completely processed cpu 
sec 
give detailed description variants stage 
ordered ldi method generates ordered ldi graphics hardware depth peeling 
similar approach correct rendering transparent surfaces eve 
contrast render fixed number layers flexible abort criterion generate entire ldi object respect voi 
additionally color information considered approach 
back faces front faces object handled successive steps 
allows label ldi entries accordingly 
separation eliminates singularities contour edges robustness problem original approach 
back faces front faces coincide original algorithm produces single depth value falsifying inside outside classification 
order solve problem generate ldi additional information face orientation multi pass algorithm performed twice 
pass processes front faces followed second pass back faces 
depth buffers corresponding depth tests 
buffer active passive 
switching active passive buffer possible 

active depth buffer cleared 
object rendered active depth buffer regular depth test 

depth value written active depth buffer ldi generation aborted 

content active depth buffer stored ldi structure 
active passive depth buffer switched 

active depth buffer cleared 
object rendered active depth buffer regular depth test 
addition second test passive depth buffer performed 
values passive depth buffer discarded 

go back step 
algorithm implemented core opengl functionality widely opengl arb extensions 
second depth test provided gl arb shadow gl arb depth texture extensions hardware accelerated shadow mapping functionality described eve 
contrast occlusion query robust abort criterion multi pass algorithm 
enabling occlusion query mode gl arb occlusion query number written fragments automatically accumulated gpu 
counter queried rendering completed 
fragments rendered counter larger zero valid layer ldi produced 
ldi generation aborted occlusion query returns zero written fragments 
fig 
illustrates ordered ldi generation 
ordered ldi generated multiple rendering passes 
result rendering pass copied shadow map second depth buffer subsequent pass 
unordered ldi second method generates unordered ldi graphics hardware 
get ordered ldi depth values sorted cpu 
approach second depth buffer required ordered ldi approach eliminated 
depth tests disabled 
contrast hei front faces back faces handled successive steps provide information self collision queries stage 
multi pass algorithm performed front faces back faces 
depth buffer stencil buffer employed 
stencil tests stencil operations 
color buffer depth test disabled improves performance 

layer index counter initialized 
stencil test set pass current stencil value equal layer index counter 
stencil operation defined increment stencil value incoming fragment 

depth stencil buffer cleared 
object rendered depth buffer 

maximum value stencil buffer zero ldi generation aborted 
maximum stencil value content depth buffer stored ldi structure 
layer index incremented 

current layer index greater equal maximum stencil value ldi generation aborted 

depth stencil buffer cleared 
object rendered depth buffer 

content depth buffer stored ldi structure 
layer index counter incremented 

go back step 
fragments rendered arbitrary order algorithm generates unsorted ldi 
processing ldi sorted pixel cpu 
rendering order arbitrary algorithm relies consistency individual passes provided gpu 
algorithm implemented core opengl functionality 
opengl extensions employed 
rendering pass requires buffer read back 
reading back data gpu expensive depending actual hardware 
propose methods optimizing data transfer opengl extensions 
depth stencil values pixel usually stored bit word frame buffer 
allows read back buffers single pass opengl extension gl nv packed depth stencil 
second rendering passes performed independently pass 
exploit fact render individual layers different regions frame buffer 
finished frame buffer read back single pass 
optimization reduces number read backs maximum assuming frame buffer memory sufficiently large 
stalls rendering pipeline reduced performance algorithm significantly improved 
fig 
illustrates unordered ldi generation 
software ldi third method ldi generation completely processed cpu 
investigation variant motivated drawbacks gpu implementations 
detailed timing measurements graphics hardware accelerated techniques indicated buffer main performance bottleneck 
second graphics hardware requires multiple passes ldi generation output restricted value fragment frame buffer 
contrast software renderer suffer rendering pass generates unsorted ldi layer 
additionally rendering pass computes depth complexity number rendering passes 
restriction multiple buffers time 
simplified implemented especially designed ldi generation 
simplified software renderer features basic frustum culling face clipping orthogonal projection rasterization triangle meshes 
produced fragments directly stored ldi structure 
contrast methods depend intermediate frame buffer 
software renderer object triangles voi provided stage 
necessary remaining triangles clipped voi 
clipping produce additional triangles shown sut 
software renderer triangles passed culling clipping stages 
depth generated fragment stored ldi structure information front face back face orientation 
fragments rasterized position ldi overwrite result generation additional ldi layer pixel 
software renderer generates fragments arbitrary order similar unordered ldi method 
pixel sorting ldi performed processing 
results implemented methods sec 
pc pentium ghz geforce fx ultra gpu 
various experiments carried measure performance methods 
section presents test scenarios employing different collision queries 
scenario uses dynamically deforming hand phone consisting faces faces respectively 
volumetric collision detection performed hand phone 
additionally animated hand tested 
ldi resolution 
tab 
shows timings collision queries 
method collision min max ms self collision min max ms min max ms ordered unordered software table dynamic test sequence animated hand faces phone faces 
minimum maximum values collisions hand phone self collisions hand 
time collision detection shown column 
resolution ldi 
fig 
fig 
illustrate test 
test scenario software ldi provides best performance data transfer gpu significantly reduces performance ordered unordered ldi approach 
data read back independent model geometry 
rasterization performance graphics hardware outweighed data read back smaller geometries 
unordered ldi approach efficient ordered ldi approach 
methods require number rendering passes rendering setup ordered ldi approach involved 
experiments indicate unordered ldi approach times faster compared ordered ldi approach 
second scenario arbitrarily placed particles tested volume dragon 
particles randomly positioned aabb model 
ldi resolution 
different scene complexities tested faces particles 
measurements tab 

method high complexity ms medium complexity ms low complexity ms ordered unordered software table particles arbitrary positions aabb dragon model tested volume 
measurements model complexities high faces particles medium faces particles low faces particles 
ldi resolution 
fig 
illustrates test 
second experiment voi encloses entire model triangles dragon rendered 
highly complex scenes time spent triangle rasterization read back 
unordered ldi approach outperforms software renderer rate hz achieved large scene triangles particles 
third experiment collisions hat mouse model fixed geometric complexity detected varying ldi resolutions 
method ldi ms ldi ms ldi ms ordered unordered software table test animated hat faces mouse faces 
collisions detected intersected 
ldi resolution varies 
fig 
illustrates test 
due moderate geometric complexity scene software ldi shows best performance third experiment 
seen ldi resolution significantly influences performance approach 
methods higher ldi resolution requires fragments rendered 
additionally data read back slows case higher ldi resolution gpu approaches 
experiment collision detection test scenario triangles performed rate hz software ldi approach 
method suited games interactive animation environments 
general experiments show approach collision self collision detection accelerated graphics hardware large environments 
typical game environments collisions checked complex characters comparable third experiment 
applications cpu implementation provides best performance hz 
ongoing currently focussing applications collision detection technique 
research efficient collision response fast deformable models intend integrate components system real time cloth simulation interactive surgery simulation 
cloth simulation fast collision detection deformable objects required handle interaction cloth walking avatars 
surgery simulation approach employed interactively simulate interactions different deformable organs 
investigating collision detections methods overcome current limitation closed objects 
intend generalize method arbitrary triangle meshes 
new image space technique detection collisions self collisions arbitrarily shaped water tight objects 
due fact pre processing required method especially useful dynamic environments deformable objects 
implementations approach 
performance analysis shown approach accelerated graphics hardware case geometrically complex scenes cpu implementation provides better performance case small environments 
method efficiently detects collisions complex objects triangles 
smaller environments handled rates hz current pcs 
approach games interactive simulation animation environments 
research supported swiss national science foundation 
project part swiss national center competence research computer aided image guided medical interventions 
bac sai wong sun 
recode image collision detection algorithm 
journal visualization computer animation vol 
pp 

ber van den bergen 
efficient collision detection complex deformable models aabb trees 
journal graphics tools vol 
pp 

bra bradshaw sullivan 
sphere tree construction medial axis approximation 
proc 
acm symposium computer animation sca pp 

bri fedkiw anderson 
robust treatment collisions contact friction cloth animation 
proc 
siggraph pp 

cam cameron 
collision detection intersection testing 
ieee transaction robotics automation vol 
pp 

eve everitt 
interactive order independent transparency 
technical report nvidia 
fol foley van dam feiner hughes 
computer graphics principles 
addison wesley publishing 
gan sullivan improving collision detection deformable objects 
proc 
spring conference computer graphics castle bratislava 
got gottschalk lin manocha 
obb tree hierarchical structure rapid interference detection 
proc 
siggraph pp 

gov govindaraju redon lin manocha 
interactive collision detection complex models large environments graphics hardware 
proc 
acm graphics hardware 
hei heidelberger teschner gross 
realtime volumetric intersections deforming objects 
proc 
vision modeling visualization vmv pp 

hof hoff lin manocha 
fast simple geometric proximity queries graphics hardware 
proc interactive graphics pp 

hub hubbard 
interactive collision detection 
proc 
ieee symposium research frontiers virtual reality pp 

kim kim lin manocha 
fast penetration depth computation physically animation 
proc 
computer animation pp 

klo klosowski held mitchell 
efficient collision detection bounding volume hierarchies dops 
proc 
siggraph pp 

kno knott pai 
collision interference detection real time graphics hardware 
proc 
graphics interface 
lar larsson moeller 
collision detection continuously deforming bodies 
proc 
eurographics pp 

lom 
cani 
realtime collision detection virtual surgery 
proc 
computer animation pp 

mel 
dynamic plane shifting bsp traversal 
proc 
graphics interface pp 

mys kunii 
fast collision detection complex solids graphics hardware 
visual computer vol 
pp 

pro provot 
collision self collision handling cloth model dedicated design garment 
proc 
graphics interface pp 

qui quinlan 
efficient distance computation non convex objects 
proc 
ieee int 
conf 
robotics automation pp 

shi 
interference detection rasterization 
journal visualization computer animation vol 
pp 

sut sutherland 
reentrant polygon clipping 
communications acm vol 
pp 

tes teschner heidelberger mueller gross 
optimized spatial hashing collision detection deformable objects 
proc 
vision modeling visualization vmv pp 

tur turk 
interactive collision detection molecular graphics 
technical report tr university north carolina chapel hill 
vas 
fast cloth animation walking avatars 
proc 
eurographics pp 

vol volino magnenat thalmann 
versatile efficient techniques simulating cloth deformable objects 
proc 
siggraph pp 

zac zachmann 
minimal hierarchical collision detection 
proc 
acm virtual reality software technology vrst pp 

dynamic animation hand faces phone faces 
collisions red detected 
refer tab 
performance measurements 
left collisions red self collisions green hand detected 
middle green detected 
right ldi representation resolution 
refer tab 
performance measurements 
left dragon faces 
middle ldi representation resolution 
right particles penetrating volume dragon detected 
performance measurements tab 

left middle dynamic animation mouse faces hat faces 
intersection volume red shown 
right intersection volume ldi resolution 
performance measurements tab 

