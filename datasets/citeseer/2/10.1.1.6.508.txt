precise expressive mode systems typed logic programming languages david overton submitted total fulfilment requirements degree doctor philosophy december department computer science software engineering university melbourne victoria australia thesis look mode analysis logic programs 
mathematical formalism predicate logic logic programs priori notion data flow single logic program may run multiple modes mode describes prescribes pattern data flow 
mode system provides domain describing flow data logic programs algorithm analysing programs infer modes program check correctness mode declarations programmer 
analysis provide useful information compiler optimising program 
prescriptive mode system mode analysis important part semantic analysis phase compilation type analysis inform programmer errors potential errors program compile time 
believe essential component industrial strength logic programming system 
aim develop strong prescriptive mode system precise expressive possible 
believe requires strongly typed purely declarative language focus language mercury 
contribution give detailed description mercury existing mode system interpretation 
system years time described level detail 
time relationship mode system formalism interpretation clear 
look ways extending mode system provide precision expressiveness overcome limitations current system 
extensions support form constrained parametric polymorphism modes 
analogous constrained parametric polymorphic type systems type classes adds somewhat similar degree expressiveness mode system 
look method increasing precision mode analysis keeping track aliases variables 
increased precision gain allows increase expressiveness allowing partially instantiated data structures complex uniqueness annotations modes 
final area look alternative approach mode analysis boolean constraints 
allows design mode system capture complex mode constraints variables clearly separates various tasks required mode analysis 
believe constraint system provides platform extension mercury mode ii system 
describe implemented melbourne mercury compiler constrained parametric polymorphism far part cial compiler release 
declaration certify thesis comprises original phd indicated preface ii due text material iii thesis words length exclusive tables maps bibliographies appendices 
david overton december iii iv declaration preface thesis comprises chapters including 
chapter provides background notation necessary understand rest thesis 
chapter presents mode analysis system currently implemented melbourne mercury compiler 
chapter presents extensions mode system allow mode polymorphism 
chapter describes extension mode system keep track definite aliases 
chapter presents new approach mode analysis boolean constraints 
chapter contains concluding remarks 
mode system described chapter designed implemented fergus henderson notation formalisation system thesis entirely 
section research part carried jointly andrew 
previously published 
section part ross overton somogyi 
chapter overton somogyi stuckey material describing implementation new 
vi preface research possible financial support commonwealth australia form australian postgraduate award 
supervisor zoltan somogyi members advisory committee lee naish harald sndergaard advice support phd 
andrew peter ross peter stuckey collaborated various components research 
peter providing robdd package implementing chapter 
friend tom conway encouragement got involved mercury project started phd don worry tom 
fergus henderson extremely thorough code reviews helped greatly improve research implementation 
rest mercury team ralph becket mark brown simon taylor david je ery tyson great working 
learnt great deal logic programming language design software engineering time mercury ce 
writing thesis carried employed hal project monash university 
mara de la banda kim marriott monash peter stuckey university melbourne generosity giving time thesis finished providing enjoyable stimulating friendly environment 
family support 
mother providing happy home environment regular meals roof head large proportion 
especially wife constant love encouragement believing ability finish thesis didn believe continuing support finishing date kept moving sacrifices enable get done 
looking forward spending thesis free weekends 
melbourne june vii viii contents declaration iii preface vii contents ix list figures xiii list tables xv background fundamental concepts 
mathematical preliminaries 
logic 
logic programming 
programming logic 
unification 
nondeterminism 
modes 
negation failure 
prolog 
interpretation 
mode analysis 
descriptive versus prescriptive modes 
precision mode analysis 
previous mode analysis 
types modes 
mercury 
logic programming real world 
ix contents types 
modes 
determinism 
unique modes 
higher order programming 
modules 
current mercury implementation simple mode system 
syntax 
instantiation states 
modes procedures 
operations mode analysis 
mode analysis rules 
full mercury mode system 
liveness information 
dynamic modes 
unique modes 
higher order modes 
concrete syntax recursive insts 
modifying goals mode analysis 
conjunct re ordering 
implied modes selecting procedures 
mode analysis algorithms 
mode checking algorithm 
mode inference algorithm 
related 
relationship interpretation 
related 
mode polymorphism problem general mode polymorphism 
constrained mode polymorphism 
syntax 
sub insts 
constrained inst variables 
inst substitutions 
mode checking constrained inst variables 
uniqueness ranges 
theorems free 
insts 
related 
contents xi alias tracking need alias tracking 
aliases precision 
aliases unique modes 
aliases partially instantiated modes 
definite versus possible aliasing 
extending mode system 
alias insts 
unification 
merging 
mode rules 
implementing partially instantiated data structures 
annotating free insts 
extending mercury machine 
tail call optimisation 
related 
limitations possible 
limitations expressiveness 
performance limitations 
constraint approach mode analysis background 
programs 
deterministic regular tree grammars 
types 
instantiations modes 
simplified example 
constraint generation 
inference checking 
full mode inference 
expanded grammars 
mode inference constraints 
mode declaration constraints 
constraints higher order code 
selecting procedures execution order 
implementation issues 
reducing number variables 
restriction variable ordering trade 
order adding constraints 
removing information robdds 
experimental results 
related 
limitations possible 
xii contents review 
contributions thesis 
benefits programmers 
benefits mercury implementors 
benefits language designers theoreticians 
bibliography index list figures example hasse diagram 
type graph list 
instantiation graph list skel 
mercury determinism lattice 
syntax order mercury 
syntax predicate append 
unquantified variables 
simple instantiation state 
hasse diagram inst 
hasse diagram inst 
mode rule procedure 
mode rules compound goals 
mode rules atomic goals 
syntax predicate append mode annotations 
mode rule procedure liveness information 
mode rules compound goals liveness information 
mode rules atomic goals liveness information 
instantiation state inst 
uniqueness annotations 
abstractions functions uniqueness annotations 
instantiation states uniqueness annotations 
mode rule procedure unique modes 
syntax predicate append unique mode annotations 
higher order mercury 
mode rule higher order calls 
mode rule higher order unifications 
instantiation states constrained polymorphism 
get subst function 
mode rules calls constrained polymorphic modes 
syntax predicate append polymorphic modes 
instantiation states constrained polymorphism uniqueness ranges 
xiii xiv list figures get subst inst function constrained inst 
syntax predicate map polymorphic modes 
nested unique modes example 
partial instantiation example 
instantiation states aliases 
merging insts alias tracking 
merging bound insts alias tracking 
merging modes alias tracking 
mode rules atomic goals alias tracking 
mode rule procedure alias tracking 
instantiation states annotations free 
lcmc transformation 
mode append transformation 
mode append transformation 
generated code mode append transformation 
program 
declarations client server system streams 
constraints conjunctions disjunctions 
calculating nodes consumed positions 
calculating visible need visible 
function find sat 
function remove sat 
definition semantics 
normalisation function 
conjunction disjunction 
list tables truth table connectives propositional logic 
mercury determinism categories 
comparison mercury concrete syntax insts 
normalised benchmark results tail call optimisation 
ect alias tracking mode analysis times 
times mode checking logic programming benchmarks 
times checking inferring modes partially instantiated data structures xv xvi list tables chapter idea predicate logic basis programming methodology introduced kowalski 
major advantages promoted programming logic ability clearly separate concept program 
notion captured famous quote algorithm logic control 
logic component determines meaning algorithm control component determines strategy solving problem 
control component ects ciency solution solution computed 
argued clear separation components lead software correct reliable maintainable 
words logic programming form ideal programming paradigm achieving goals software engineering 
separation logic control facilitates possibility control component automatically handled system 
system may modify control component order improve ciency leaving logic component unchanged guaranteeing modified program solves problem 
advantage logic programming single predicate may solve problem 
example predicate concatenates lists may split list 
logic component predicate specifies relationship arguments predicate control component determines arguments input output determines predicate concatenates lists splits list 
di erent behaviours called mode predicate 
unfortunately traditional logic programming languages prolog challenging living ideals programming logic 
versions prolog fixed control strategy left right selection literals depth search hard write programs purely logical way execute ciently 
particularly hard write program execute ciently guaranteed terminate intended multiple modes 
depth search strategy lead incompleteness predicate fails terminate called modes may possible write predicate logical way guaranteed terminate modes interest 
reason prolog non logical features cut predicates inspecting instantiation states variables 
features allow programmer alter aspects control component chapter 
program 
features destroy pure logical semantics program harder prove correctness harder maintainer understand harder compiler analyse purpose optimisation 
prolog implementations take shortcuts gain acceptable ciency 
example usually omit occur check unification procedure lead unsoundness 
check negation failure ways guaranteed sound 
mode analysis systems analyse modes logic program data flow mode 
information produce alleviate problems enable logic programs execute ciently sacrificing declarative semantics 
example mode system may able determine safe omit occur check 
mode systems fall broad categories 
descriptive prescriptive 
descriptive systems analyse program usually operate small finite domain approximating possible instantiation states variables 
domains usually include don know value order cope cases mode system precision describe instantiation state accurately 
mode systems remove expressiveness program describe program accept valid prolog program 
limited precision guarantee soundness cient execution 
prescriptive mode system hand attempt re order program conform mode system idea mode correctness may reject programs prove mode correct 
result prescriptive mode system sacrifice expressiveness language precise analysis domain descriptive system 
generally absolute precision possible particular prescriptive mode system need balance requirements expressiveness amount precision able provide keeping analysis time reasonable 
prescriptive mode systems usually require programmer provide mode declarations predicates specify modes predicates intended run 
mode analyser check mode declarations correct 
prescriptive mode systems classified strong mode systems weak mode systems 
strong prescriptive mode systems generally tolerate having don know value domain reject program precisely categorise instantiation states 
weaker mode systems may tolerant uncertainty instantiation states information re ordering reject programs don conform mode declarations 
somogyi claimed order provide reliability robustness ciency strong prescriptive mode system essential real world industrial strength logic programming language 
argued mode system attain precision required su ciently expressive precise information possible structures terms information exactly provided strong type system pp 
discuss categories detail give examples section 
see somogyi henderson conway keefe 
chapter 
somogyi ideas realised strongly typed strongly moded logic programming language mercury 
mercury mode system provides extremely precise domain describing instantiation states variables 
implementation mode analysis algorithm melbourne mercury compiler version allow full potential precision utilised 
problem mode system keep track su cient information relationships instantiation states di erent variables 
consequence loss precision possible partially instantiated data structures data structures holes left filled program meaningful way 
expressiveness mercury unique modes allow modelling destructive update provide hints compile time garbage collection su ers lack precision 
thesis propose number enhancements mode system order alleviate lack expressiveness improving precision analysis 
remainder thesis organised follows 
chapter introduce notations concepts need rest thesis 
includes detailed mode systems logic programming overview mercury language 
chapter depth description mode system mercury 
mode system developed fergus henderson smaller contributions members mercury team including author thesis 
time described level detail formality aside implementation 
chapter provides essential information understanding enhancements proposed rest thesis 
clarifies relationship mercury mode system formalism interpretation 
chapter extension mode system provide form constrained parametric polymorphism mode declarations 
allows example polymorphically typed predicates polymorphic instantiation states associated type variable 
particularly useful subtype information conveyed instantiation state needs propagated input arguments output arguments 
important type variables instantiated higher order types 
require higherorder mode information available order useful higher order object called 
extension implemented melbourne mercury compiler part cial release version 
chapter describe extension mode system track aliases variables subterms body predicate 
provides increase precision analysis allows partially instantiated data structures 
improves expressiveness unique modes system allowing code unique objects nested inside unique objects 
extension implemented mercury compiler part cial mercury release due concerns added analysis time requires 
chapter alternative approach mode analysis 
boolean constraints express relationships instantiation states variables di erent parts predicate body 
approach easier separate di erent conceptual phases mode analysis 
believe provides appropriate platform extension chapter 
mercury mode system 
experimental prototype analysis implemented melbourne mercury compiler 
chapter concluding remarks 
chapter background chapter cover basic concepts needed understand rest thesis look previous mode analysis logic programming languages 
section briefly covers notation mathematical concepts require 
section introduces logic programming 
section introduces interpretation 
section introduces concept mode analysis logic programming looks previous area 
section gives mercury programming language 
fundamental concepts cover notation basic mathematical concepts require rest thesis 
information topics text books arbib kfoury moll davey priestley 
clear concise definitions concepts need 
definitions definitions 
logical connectives implies quantifiers exists 
define formally 
mathematical preliminaries sets set possibly infinite collection objects 
write denote object member set similarly means member slash symbol generally indicate negation meaning symbol 
symbol denotes empty set set defined listing members enclosed curly brackets 
xn defines set containing elements 
xn set comprehension form defines set containing elements property holds 
write shorthand 
cardinality set denoted gives indication size set 
finite number elements thesis need deal infinite sets chapter 
background don need worry cardinality 
sets union intersection set di erence member member say subset write write ps denote set possible subsets ps 
call ps power set set sets union sets intersection sets operator 
example 
set ps ps 
tuples tuple ordered finite sequence objects write enclosed angle brackets 
xn 
number elements tuple known arity tuple elements ary tuple tuple short 
particularly important kind tuple tuple call binary tuple pair notation refer tuple 
xn arbitrary length treat tuple 
xn set 
xn 
sets define call cartesian product relations relation set tuples arity 
ary relation set consisting tuples 
ary relation notation 
xn short hand 
xn binary relation usually write infix notation ary relation sn say sn signature usually write sn sn say ary relation example 
binary relation natural numbers signature 
fundamental concepts binary relation symmetric antisymmetric reflexive transitive 
thesis abbreviation 
transitive closure trans binary relation set transitive 
partial order relations binary relation reflexive antisymmetric transitive called partial order relation 
symbols partial order relations 
partial order relation set pair set equipped 
called partially ordered set poset short 
poset say comparable incomparable 
pair elements comparable say total order relation poset upper bound upper bound holds say upper bound lub similarly lower bound lower bound holds greatest lower bound glb write lub glb respectively write lattices poset pair elements exist lattice 
exist possibly infinite subset complete lattice 
definition complete lattice exist 
denote pronounced top pronounced bottom respectively 
example 
subset relation partial order relation set poset complete lattice upper bound operator greatest lower bound operator 
convenient visualise posets lattices hasse diagram 
hasse diagram elements set represented arranged nodes graph pair comparable elements greater element partial order higher diagram lesser element path graph 
example 
hasse diagram complete lattice shown page 
note diagram clear 
chapter 
background example hasse diagram functions important kind relation function 
relation function mapping denote function write signature generally notation denote member function 
notation equivalent say result application function say domain written 
say total function partial function undefined values define functions relations pattern matching example fac fac fac defines factorial function equivalent fac fac define functions notation lambda calculus lambda quantified variable expression usually containing 
definition equivalent means expression replaced occurs 
example alternative definition factorial function fac 
useful function fixed point combinator fix fix takes function argument 
fixed point combinator allows give 
fundamental concepts definition factorial require recursive application fac fac fix fixed point combinator allow define infinite terms 
example list constructor fix infinite list 
logic formal mathematical logic basis logic programming basis mathematics 
reeves clarke distinction object languages meta languages object language language studying logic programming language mercury language propositional calculus 
meta language language describe rules object language algorithms analyse 
language mathematical logic object languages meta language 
avoid confusion di erent notation meta language object language 
di erences noted 
give brief overview concepts notations propositional predicate logic refer reader text book reeves clarke information 
propositional logic simplest type logic look propositional boolean logic 
propositional logic mathematical system set bool usually take mean false mean true 
sentences propositional logic constructed logical connectives informally 
define formally truth table table 
conjunction disjunction implication equivalence negation table truth table connectives propositional logic boolean valuations constraints assume set boolean variables bvar 
boolean valuation mapping boolean variables values domain bool bvar bool 
previously 
tend notation meta language object languages 
chapter 
background bvar bool define boolean constraint boolean function bool function constrains possible values set boolean variables vars bvar 
require 
vars 
say model write 
say valid 
say satisfiable 
overload logical connectives lifting domain defined boolean variable bvar occurs context expecting boolean constraint take mean constraint 
lift respectively 
represents unsatisfiable constraint represents valid constraint 
define restriction existential quantification operation bvar 
intuitively restriction don care value required true 
define restriction set variables 
xn 
xn clauses resolution boolean formula expression consisting boolean variables logical connectives 
boolean formula define boolean function 
boolean formulas equivalent define boolean function 
literal boolean formula single variable negated variable call positive literal negative literal clause disjunction ln ln literal 
boolean formula rewritten equivalent formula conjunction kn clause 
boolean formula form said conjunctive normal form 
clause positive literal called horn clause 
horn clause exactly positive literal called definite clause 
definite clause yn written equivalent form yn reverse implication 
literal known head clause yn body clause 
extension notation write clause clause yn yn empty clause written represents boolean function 

fundamental concepts meta language write clause yn form 
yn equivalently problem determining boolean formula satisfiable known propositional satisfiability problem sat short 
problem restricted formulas clausal form clause literals call problem sat general problem sat np complete restricted case sat solved linear time 
method solving sat proof refutation inference rule resolution 
resolution rule says set clauses clause contains literal contains literal deduce new clause disjunction clauses literals removed 
formally proving boolean formula satisfiable equivalent proving valid 
convert conjunctive normal form possible apply resolution rule add new clauses 
add empty clause proven valid satisfiable 
predicate logic order predicate logic extension propositional logic relations predicates propositions 
assume set logic variables var set predicate names set function symbols functors 
signature set pairs integer arity function symbol arity called constant signature set ground terms called herbrand universe denoted defined set satisfying 

simplicity assume contains constant 
var set variables 
set terms denoted similarly defined set satisfying 

chapter 
background set atomic formulas atoms function signature variable set predicate signature element pair defined 

treat atoms terms 
substitution signature variable set mapping variables terms written 
xn 
allow substitutions applied terms variables 
substitution term term variable occurring dom replaced 
unifier terms substitution syntactically identical 
general unifier terms denoted mgu unifier property unifier exists substitution composition general unifier terms computed unification algorithm give 
described lloyd places 
formulas order predicate logic constructed atoms logical connectives universal existential quantifiers predicate logic define literal atom negation atom 
clausal form called prenex normal conjunctive normal form quantifiers front formula 
definitions horn clause definite clause extended definitions propositional logic obvious way 
shorthand notation avoid having explicitly write quantifiers horn clauses 
atoms horn clause contain variables implicitly quantify variables follows 
qn horn clause predicate logic say implicitly equivalent 
xn 
ym qn 
xn variables occurring 
ym variables occur 
qn resolution rule extended predicate logic ln mgu atoms general unifier unifiable 
rule formulas prenex normal form remove existential quantifications process called 
mainly interested specialised case sld resolution discuss 
main thing note resolution involves computing substitution find useful look predicate logic programming language 
note satisfiability problem predicate logic general undecidable 

logic programming logic programming section gives brief overview logic programming 
see kowalski lloyd van emden kowalski information 
programming logic early research unification resolution predicate logic mainly focused automated theorem proving 
kowalski realised predicate logic computation basis programming language 
involved subset predicate logic consisting horn clauses plus specialised resolution rule known 
definite logic program set definite clauses plus clause consisting negative literals known query goal qn execution logic program consists applying rule sld resolution order attempt refute query 
result successful refutation substitution variables query negation qn true 
proving theorem computed useful information 
logic programming gives di erent views clause qn 
true 
qn true 
declarative view 

execute execute 
qn operational procedural view 
clause resembles procedure definition procedural programming language 
major advantage logic programming clause understood declarative semantics predicate logic 
unification logic programming languages contain predicate defined clause infix notation operator 
seen ect body atom unify terms generally refer atom unification atom form 
generally referred call predicate unification fundamental part logic programming ort gone optimising unification algorithm 
note general unification algorithm quite expensive logic programming analyses look try find places logic programs general algorithm replaced specific algorithm particular subset terms 
particularly expensive part algorithm occur check involves checking variable unified term occur term unification fail 
check expensive logic programming systems leave pragmatic reason virtually needed 
leaving occur check lead unsoundness sld resolution know safe leave performed 
aims mode analysis 
sld resolution stands sl resolution definite clauses 
sl stands linear resolution selection function 
chapter 
background nondeterminism note multiple clauses predicate symbol head 

trying prove goal 
execution may try clause fails prove goal clause may backtrack try clause 
typical logic programming system select clauses order appear program source code depth search strategy predicate multiple clauses calls predicates multiple clauses may solution particular call 
say predicate nondeterministic 
modes consider clauses define predicate append 
append append append constant binary function symbol infix notation representing list constructor 
give query append obtain answer substitution 
see predicate append ground terms representing lists arguments return concatenation lists third argument 
arguments input arguments third argument output 
consider query append 
due nondeterministic nature predicate definition possible substitution sets produced 
case third argument acting input arguments output 
say append operate di erent modes 
general complex modes just input output classifications possible 
study modes subject thesis 
negation failure programming definite clauses convenient possible body clause contain just conjunction positive literals 
particular possible body contain negative literals 
common way achieve concept negation failure negative literal considered true possible prove program 
modified resolution rule sldnf resolution sld resolution negation failure 
sldnf resolution sound proving negated literal cause variables bound cause substitutions created 
logic programming systems check 

interpretation negation failure way adding negation logic programs 
see apt bol survey alternative approaches 
prolog widespread logic programming language prolog programming logic implementations text books iso standard 
modern versions prolog iso standard syntax derived dec edinburgh prolog implemented compiling variant machine known warren machine wam 
modern prolog systems allow body clause arbitrary goal include disjunctions constructs conjunctions negations 
syntax prolog comma represents conjunction semicolon represents disjunction operator takes place separating clause head body clause terminated full variable names start capital letter 
example 
prolog code predicate append saw append 
append append 
prolog uses constant empty list binary function symbol list construction 
note closely prolog code resembles predicate logic clauses 
language mercury uses syntax prolog extensions support functional higher order programming 
prolog assumes fixed execution order conjunctions executed left right clauses selected order program source 
modern prolog implementations provide argument indexing means argument head clause predicate di erent top level function symbol execution jump immediately matching clause predicate called argument bound function symbol 
significantly improve execution times 
prolog language nonlogical features features declarative semantics operational semantics may unsound respect declarative semantics 
unfortunately programs find necessary nonlogical features 
example programs need cut acceptable ciency 
input output done nonlogical way prolog 
interpretation interpretation formalised system providing framework analysis properties programs 
interpretation logic programs studied great depth 
idea interpretation mimic execution program abstraction semantics program 
abstraction semantics may involve simple chapter 
background abstraction data values variables may take may complex abstraction program state 
formalise notion abstraction assume concrete property programs interested abstraction approximates property 
call concrete domain domain 
assume relations partial orders respectively formalise relative precision domain 
precise description posets complete lattices necessary 
abstraction defined abstraction function maps elements precise counterparts function maps elements back elements defines semantics domain 
say galois connection write having galois connection gives guarantees abstracting member doesn give precise member unsound abstracting member won lose precision analysis precise possible domain 
example 
consider case powerset terms signature variable set subset ordering ground free abstraction functions defined ground free ground free 
domain represents undefined value exception infinite loop ground represents ground terms free represents variables represents don know includes terms 
see forms galois connection 
domain basis simple mode analysis system 
discuss section 
analysis interpretation abstractions operators language studied provided 
logic programs include abstractions unification conjunction disjunction 
fc operation language fa abstraction operation abstraction sound require fc fa 
mode analysis want ensure interpretation terminates finite reasonable time 
general abstractly interpreting recursively defined procedure ensure termination need ensure fa reaches fixpoint value fa finite number applications 
finite set complete lattice fa monotonic fa easy ensure fixpoint fa reachable finite number applications fa starting element finite large approaches may needed ensure termination reasonable time 
approach reduce precision analysis widening operation 
mode analysis section noted features logic programs predicates execute multiple di erent modes 
allows form code re available kinds programming languages 
mechanisms required provide feature hard implement ciently sound way 
predicate intended mode multi moded nature logic programming cient implementation hard 
noted ciency issues associated general unification algorithm example 
example having deal potential nondeterminism keeping choice points backtracking eventually needed 
mode analysis deals analysing possible modes predicate may run order obtain information may useful specialising predicate helping compiler implement ciently 
interested mode analysis detect prevent potential errors program unbound variable place bound variable required preventing unsound uses negation failure knowing safe leave occur check 
want find errors possible compile time avoid showing unpredictably bugs run time 
research gone mode analysis systems mode systems short logic programs 
survey 
mode analysis aims categorise run time instantiation patterns variables di erent computation points execution program inherently linked operational semantics program 
aim usually identify parts program produce data instantiating variables parts program consume data 
mode analysis form data flow analysis 
declarative approach modes views modes constraints success set program set ground atoms solutions program 
useful categorise di erent mode systems criteria 
mode system descriptive prescriptive defined 
second degree precision mode system captures mode information program 
look concepts discuss previous mode systems fits criteria 
chapter 
background descriptive versus prescriptive modes probably fundamental question ask mode system purpose intended serve 
mode system may aim describe execution program imposing constraints programs allowed attempting modify program 
examples include 
alternative descriptive mode systems mode systems prescribe particular pattern data flow 
prescriptive systems may attempt transform predicates re ordering conjunctions conform required pattern data flow usually mode declarations may reject programs prove mode correct examples systems 
prescriptive mode systems classified strong weak strong mode systems require exact information possible instantiation state variable 
know variable computation point variable instantiated degree 
weak prescriptive mode system information available re ordering check mode declarations conformed necessarily know particular variable bound unbound 
di erence descriptive prescriptive mode systems largely language design issue 
example mercury mode system prescriptive compiler done re ordering necessary program mode correct say descriptive system modes describe modified program behave 
precision mode analysis criterion categorising mode systems degree precision granularity domains 
simplest domain groundness analyses domain ground 
domain ground free saw example page distinguishes definitely free variables analyses 
analyses take free mean variables don aliases aliased variables mapped 
attempt simple form alias analysis 
analyses add value domain ground 
value represents set terms variables 
schemes small finite domains mode analysis zachary yelick refer fixed value domains analyses attempted increase precision refining multiple values representing di erent states 
analyses refine ground set values representing kind subtyping 
analyses precise domains rely getting information possible structure terms type system 
operate untyped language 
generally precise 
allow mode polymorphism discuss chapter instantiation state may represented instantiation variable represents unbounded number instantiation states 
constraints require instantiation variables mean strong mode system 

mode analysis order provide expressive programming language prescriptive mode system generally require precise domain descriptive mode system 
previous mode analysis early implementations dec prolog introduced mode declarations supplied programmer annotate arguments predicate input output 
annotations compiler optimisation 
annotations checked compiler unpredictable erroneous results occur predicate manner contrary mode declaration 
logic programming systems including epilog nu prolog mode annotations fixed value domains control order literals query selected resolution 
similarly read variable annotations concurrent prolog similar concept versions parlog control parallel execution goals may share variables 
automatically deriving modes done mellish 
debray warren improved explicitly considering variable aliasing derive precise analysis albeit simpler domain 
mode analysis logic programming focused untyped languages mainly prolog 
consequence systems simple fixed value analysis domains ground free 
patterns code derive detailed program specific domains janssens bruynooghe le charlier van hentenryck tan lin analyses sacrifice precision achieve acceptable analysis times 
somogyi proposed fixing problem requiring type information types variables domains mode analysis 
possible handle complex instantiation patterns 
papers similar ideas 
papers mode inference assume program analysed reordering 
modes describe program executions interested modes prescribe program execution order insist compiler exact information instantiation states 
prescriptive mode analysis systems simpler domains example ground prolog recognises instantiation states free ground 
related mode checking concurrent logic programming languages logic programming languages coroutining emphasis detecting communication patterns possible deadlocks 
modes languages independent particular execution strategy 
example parlog concurrent logic programming language moded flat ghc argument declared input need necessarily instantiated start goal argument declared output need necessarily instantiated goal 
words languages allow predicates override declared modes 
necessary coroutining predicates operate construct term 
predicates declared ghc stands guarded horn clauses confused glasgow haskell compiler 
chapter 
background producer term argument declared output declared consumer argument input 
generally producer responsible binding top level functor term consumer bind parts term 
moded flat ghc uses constraint approach mode analysis 
ghc moded flat ghc rely position clause head guard versus body determine unification allowed bind variables significantly simplifies problem mode analysis 
constraints generated equational rely delaying complex cases occurrences variable goal 
simplified approach applied mercury adding guards clauses 
significant change language consider undesirable number reasons harder write predicates multiple modes destroy purity language making possible write predicates operational semantics match declarative semantics feel desirable software engineering point view require programmers think write guards 
mercury want strong prescriptive mode system precise possible allows cient implementation mercury programs allowing unsoundness negation failure omitting occur check 
want able handle higherorder programming constructs largely ignored previous uniqueness analysis described henderson 
look mode systems relate mercury relevant places thesis 
types modes brief mention importance type system provide information necessary precise expressive strongly prescriptive mode system 
worth making observations relationship types modes concepts closely related 
mercury keep concepts types modes separate 
type variable refers set possible ground values variable allowed take mode variable refers instantiation state variable change execution predicate describes set possibly non ground terms variable take 
instantiation state variable represents set ground terms ectively represents sub type type variable 
programming paradigms mode concepts usually treated framework type analysis 
example concept linear types functional languages closely related mercury concept unique modes discuss chapters 
logic programming types modes combined 
example notion directional types 
example directional type predicate append 
mercury append list list list list free list 
asserts append called second arguments lists answer arguments lists 
mercury describe logic programming language mercury rest thesis 
description brief mainly highlight aspects mercury interested purpose mode analysis 
details language please refer language manual papers cite 
logic programming real world mercury purely declarative logic programming language designed construction large reliable cient software systems teams programmers 
mercury syntax similar syntax prolog mercury strong module type mode determinism systems catch large fraction programmer errors enable compiler generate fast code 
programming mercury feels di erent programming prolog closer programming strongly typed functional language haskell imperative language ada ei el 
somogyi henderson conway keefe argue strong module type mode determinism systems essential industrial strength real world logic programming language 
definition predicate mercury goal containing atoms conjunctions disjunctions negations quantifications 
prolog requires predicates conjunctive normal form transforms form mercury allows compound goals nested arbitrarily 
simplify algorithms mercury compiler converts definition predicate call normal form 
form predicate defined goal variables appearing atom including clause head distinct atoms ignoring higher order constructs forms xn xn example 
definition predicate append normal form append xs ys zs xs ys zs xs xs zs zs append xs ys zs 
chapter 
background types mercury strong static parametric polymorphic type system hindley milner type system ml mycroft keefe type system prolog 
type defines set ground terms 
type type definition form type 
mk 
type constructor 
type parameters 
term constructors members signature program terms 
mk types 
example 
examples type declarations type bool 
type 
type list list 
note di erent types share term constructor constant example 
allow overloading constructors 
note type definition may refer allowing define types recursive data structures lists 
useful think type definition defining type graph example graph list shown 
nodes labelled types list represent positions terms sub terms rooted positions give types sub terms 
called nodes sub term general bound function symbols 
nodes labelled represent function symbols called term constructors called nodes list type graph list 
mercury type predicate declared pred declaration 
example declaration append pred append list list list 
declares append predicate arguments type list 
mercury run time system allows information types accessed program run time 
type system supports haskell style type classes existential types 
features unrelated mercury mode system discuss note need take account section 
information types mercury see je ery 
modes mercury mode system mode system somogyi 
built domain called instantiation state inst usually abbreviate 
inst abstraction set possible terms variable may bound particular point execution program 
refer point computation point 
inst attaches free bound nodes type tree 
node decorated free sub terms corresponding positions term described inst free variables aliases node decorated bound sub terms corresponding positions term described inst bound function symbols 
inst ground short hand 
maps bound node attached nodes reachable type graph 
programmer define insts inst definition 
example definition inst list skel bound free list skel 
defines inst list skel 
variable inst list skel top level function symbol bound constant binary functor bound argument free variable second argument bound list skel 
definition gives instantiation graph shown 
note instantiation graph resembles type graph list shown preceding page nodes labelled insts types 
list skel free instantiation graph list skel chapter 
background mode variable describes variable changes execution goal predicate body 
write modes syntax inst variable start goal inst goal 
modes names example common modes defined mode ground ground 
mode free ground 
thought representing input output arguments respectively 
inst mode definitions may take inst parameters 
example inst list skel bound list skel 
mode mode free mode declaration predicate attaches modes predicate arguments 
predicate may general multiple mode declarations 
example possible mode declarations append mode append 
mode append 
mode predicate called procedure 
compiler generates separate code procedure 
mercury mode declarations may contain non ground inst parameters 
chapter look extend mode system provide mode polymorphism 
extension part mercury 
predicate exported module defined mode declarations usually optional modes inferred declaration 
mode declaration predicate compiler check declaration valid 
compiler may re order conjunctions necessary ensure mode declaration procedure valid 
define mode system formally give rules algorithms mode inference checking chapter 
determinism procedure categorised solutions produce fail producing solution 
known determinism 
ignore committed choice contexts concern thesis di erent categories det multi erroneous failure 
meanings table 
maximum number solutions fail 
erroneous det multi failure table mercury determinism categories 
mercury determinism categories arranged lattice representing information contain shown hasse diagram 
categories higher lattice contain information categories lower lattice 
information mercury compiler determinism procedure cient code generate 
failure erroneous det multi mercury determinism lattice determinism annotations added mode declarations compiler check 
example annotate mode declarations gave append mode append det mode append multi 
tell compiler calls procedure append exactly solution calls append solution possibly 
compiler infer determinism predicates local module 
determinism analysis system uses information provided mode system check infer determinism procedure 
determinism information generate cient code specialised procedure 
information determinism system see henderson somogyi conway 
see nethercote describes determinism analysis system mercury context general interpretation framework 
language hal uses determinism system mercury 
unique modes unique modes extension mercury mode system henderson turn linear types wadler 
allow programmer tell compiler value longer needed memory associated re 
allow modelling destructive update input output logically sound ways 
system introduces new base instantiation states unique clobbered ground variable inst unique corresponding value variable inst clobbered corresponding value 
unique version bound exists 
example inst unique list skel unique unique list skel 
defines inst unique list skel list skel skeleton list uniquely referenced 
chapter 
background common modes associated uniqueness di stands destructive input uo stands unique output ui stands unique input 
mode di unique clobbered 
mode uo free unique 
mode ui unique unique 
unique mode analysis ensures unique value program attempt access value clobbered 
variants unique clobbered called unique clobbered 
allow modelling destructive update trailing logically sound way 
value inst unique forward execution may backtracking 
value inst clobbered forward execution may referenced backtracking 
predefined modes mdi mui di uo ui unique clobbered unique clobbered 
higher order programming higher order programming allows predicates treated class data values passed program functions functional languages 
higher order term created higher order unification 
example pred det gives variable value higher order term input returning value incremented 
note modes determinism higher order term supplied 
term called goal bind value 
may passed predicate 
example map bind list 
predicate map higher order predicate takes higher order term list applies higher order term element list 
type mode declarations pred map pred list list 
mode map pred det det note higher order type pred higher order inst pred det higher order unification general undecidable mercury mode system allow general unification higher order terms 
unifications allow involving higherorder terms assignments see 
means mercury higher order constructs integrated order semantics simple program transformation 
methods doing transformation proposed 

mercury modules mercury module system allows separate compilation large programs provides information hiding 
mercury module interface section implementation section 
declarations visible outside module placed interface section 
internal declarations clauses placed implementation section 
predicate visible outside module defined type mode determinism declarations module interface 
types exported abstractly module exposing implementation details giving type declaration module interface giving definition type implementation section 
insts supported section discusses supported 
chapter 
background chapter current mercury implementation chapter look mode analysis system implemented current melbourne mercury compiler described mercury manual 
system interpretation domain instantiation state inst usually abbreviate 
section describe simple mode system order subset mercury include features unique modes dynamic modes higher order modes 
section describe full mercury mode system section discuss transformations turn non mode correct program mode correct program 
section give mode analysis algorithm discuss limitations 
section look mercury mode system related particular framework interpretation 
simple mode system describing greatly simplified mode system order subset mercury 
look means program mode correct system discuss di culties checking mode correctness 
section build simple system stages eventually describe full mode system mercury language 
syntax facilitate discussion syntax order mercury programs described page 
syntax normal form introduced section requires variables predicate body head variables explicitly existentially quantified 
order mercury refer current implementation referring version released april 
version released th december addition mode system described chapter implements polymorphic mode system extensions described chapter 
chapter 
current mercury implementation program expressed syntax straightforward transformation 
section expand full syntax mercury including higher order constructs 
variable var function symbol predicate name flattened term goal goal call unification existential quantification negation conjunction disjunction predicate pred program program syntax order mercury notation denotes set elements xs 
program program set predicates 
predicate pred form atom head predicate goal body head consists name predicate argument vector 
arguments distinct variables 
goal goal call argument variables distinct unification existential quantification negation conjunction disjunction 
refer calls unifications atomic goals existential quantifications negations conjunctions disjunctions compound goals 
head variables implicitly universally quantified predicate body 
variables goal existentially quantified non head variable explicitly quantified original program implicitly existentially quantified closest enclosing scope transformation syntax 
predicate logic mercury assumes set function symbols signature set variables var 
allows define set terms term var 
flattened term term variable functor applied arguments distinct variables 
writing goals enclose corner brackets distinguish surrounding mathematics 
example 
predicate append syntax shown page 
strictly necessary negation goal type considered special case equivalent empty disjunction goal fails empty conjunction goal succeeds 

simple mode system append xs ys zs xs ys zs xs zs xs xs zs zs append xs ys zs syntax predicate append definition unquantified variables function uq goal pvar gives set unquantified variables goal defined 
uq uq uq uq uq uq unquantified variables instantiation states instantiation state abbreviated inst attaches instantiation information nodes type tree 
information describes corresponding node bound free 
children free node free 
definition instantiation state page describes form simplified instantiation states 
inst inst free bound set possible functors argument insts described recursively 
function symbol occur set 
predicate logic usually known free variables term avoid confusion alternative free mercury mode system 
similarly refer quantified variables bound variables 
full mercury mode system described chapter information node unique structure 
chapter 
current mercury implementation instantiation state inst free bound occur simple instantiation state definition function inst approximates set terms function inst free bound 

call function insts 
underscore var represent fresh variable occur aliased part term data structure 
give abstraction function inst reverse mapping little 
note representation wish inst represent infinite set terms inst need infinitely large 
example wish represent set terms lists finite length 
inst need bound free bound free bound 
concept infinite insts convenient mathematical abstraction simplify presentation follows 
section discuss insts implemented mercury compiler 
section gives summary di erences correspondence syntax instantiation states chapter concrete mercury syntax described chapter 
note definition allow represent terms containing variables aliased 
look issue chapter 
major role mode analysis determine instantiation states variables predicate change forward execution predicate body 
certain instantiation state transitions prohibit 
particular variable instantiation state may change bound free variable bound may unbound forward execution 
restriction apply argument insts functor bound inst 
describe allowable transitions introduce partial order relation 
definition instantiatedness partial order insts define partial order instantiation states free bound bound 


say instantiated 
simple mode system variable transition instantiation state instantiation state forward execution goal allowable definition reached define inst reached bound 
instantiation state indicates unreachable computation point computation fails infinite loop program abort 
write refer greatest lower bound refer upper bound insts 
note insts inst reached free 
set insts unique upper bound unique greatest lower bound 
inst complete lattice free reached 
example 
shows hasse diagram lattice inst herbrand universe set ground terms restricted 
free bound free free bound bound free bound free bound bound reached bound bound bound free bound free bound bound bound bound hasse diagram inst herbrand universe see example definition ground insts convenient define inst ground bound ground 
ground times ground ground set ground terms 
ground practice type information variable program 
type definitions define subset ground inst thought approximating subset defined type particular variable associated 
chapter 
current mercury implementation say ground inst 
modes procedures definition instmap instmap function instmap var inst instmap dom reached dom reached instmap gives mapping program variables instantiation states particular program point 
variables instmap inst reached variables inst reached 
reason variable inst reached unreachable program point point variables inst reached 
definition unreachable instmap define set unreachable instmap unreachable instmap dom reached refer unreachable 
forward execution variables instantiated 
provide operation allow instmap updated subset variables instantiated 
definition instmap update operator instmap instmap instmap allows values instmap updated reached unreachable unreachable dom 
require dom dom variable instantiated definition mode mode pair mode instmap instmap represents initial final instantiation states set variables goal 
domains set variables variable 
simple mode system instantiated second instmap 
mode instmap dom dom dom refer domain mode domm dom dom instmap initial instmap write init final instmap write fin define modes init fin 
times mode analysis analysing procedure call procedure body need ensure variable certain instantiation state 
may know variable question specific instantiation state equally 
able express relation instantiation states say inst matches specific inst may place required general inst 
definition matches partial order insts define partial ordering insts free free reached free bound bound 


say matches note reached matches inst need separate rule form reached bound reached syntactic sugar bound third case handles 
note relation subset relation inst 
di erence free reached match free 
note lattice bottom element reached top element 
write refer greatest lower bound refer upper bound exists insts 
operators give glb lub defined respectively sets insts 
example 
page shows hasse diagram poset inst herbrand universe 
diagram uses bound free readability 
edges inst inst shown dotted comparison 
example bound free bound bound free bound free bound free bound free free chapter 
current mercury implementation reached hasse diagram inst herbrand universe see example definition abstraction function partial order allows define abstraction function inst 
free 
bound 
note partial function 
defined set terms upper bound abstractions defined set containing variable non variable terms 
defined term containing aliased variable 
abstraction function gives alternative simpler way defining inst ground ground section look abstraction functions mode analysis fits framework interpretation 
definition procedure procedure tuple proc pred mode predicate mode describes initial final instantiation states arguments predicate 
domain mode exactly variables argument vector predicate variables predicate body existentially 
simple mode system quantified appear procedure mode 
proc pred mode domm operations mode analysis define operations mode rules simple mode system 
operations partial functions give definitions state conditions defined 
call functions inputs undefined understood corresponding mode error 
definition mode sequence operation mode sequence operation defined equation resulting mode initial instmap initial instmap argument final instmap final instmap second argument 
final instmap argument initial instmap second argument 
definition restriction operation modes operation mode pvar mode restricts mode removing variables set mode domain init domm fin domm define operations merging insts modes 
mode rules combine mode information branches branched goal disjunction 
variable node inst variable may free branch branched goal bound set functors branch 
set functors variable may bound branched goal union sets functors may bound branch 
upper bound operation matches partial order required properties definition inst merge merge insts branched goal defined upper bound exists partial order 
definition mode merge define merge modes exists equation dom modes initial instmap initial instmap merged mode 
final instmap merged mode obtained merging insts variable final modes 
chapter 
current mercury implementation note unreachable corresponding branch succeed due call library predicate error aborts program result merge instmap 
look operation unification instantiation states 
unification equivalent unification operation terms 
result abstractly unifying insts inst instantiated initial insts 
unification greatest lower bound partial order 
requirement simple system variables may aliased allow unification concrete unifications represents cause variables aliased 
straightforward way avoid require resulting inst ground variables term resulting unification obvious unification doesn cause variables aliased 
arrive definition unification 
definition unification insts unification insts defined unify inst ground see definition explicitly requires inst resulting greatest lower bound ground avoiding problems aliasing 
example 
examples clearly seen hasse diagram page 
unify inst free bound bound bound bound unify inst bound bound bound bound free bound bound unify inst bound free bound free reached unify inst free bound free defined 
unifications form unification needs compute final inst final insts argument definition unification functor unification inst functor argument insts unify inst functor unify inst bound bound reached reached 
reached inst resulting unification resulting insts arguments 
section look liveness information relax restriction chapter look alias tracking relax 

simple mode system note variable functor unification resulting inst bound functor unification succeed reached unification fails 
mode analysis rules section define set basic rules means program 
start giving rules mode correct procedure 
procedure order execution conjuncts conjunction fixed 
tasks mode analysis determine mode correct order conjuncts 
rules ordering merely describe means procedure mode correct 
section discusses 
intuitively procedure mode correct initial variable substitution var term dom final substitution execution procedure body goal property dom 
notation proc mode judgement means procedure proc mode correct respect environment 
set proc set procedures program 
similarly goal goal notation goal means mode correct goal mode respect environment 
environment mode judgements goals extra component var set non local variables goal 
gives relationship mode judgements goals procedures procedure goal mode mode correct mode argument variable init init fin fin mode correct mode requirement init init means initial instantiation variable mode declaration tight required procedure body 
example procedure body may require variable inst bound mode declaration may stricter require say bound 
conversely fin fin means final inst variable guaranteed procedure body tight required mode declaration 
proc goal domm domm uq init init fin fin proc mode rule procedure page shows mode rules compound goals conjunctions disjunctions existential quantifications negations 
relation true mode cause variables set chapter 
current mercury implementation instantiated init fin test required ite rules ensure soundness negation failure 
conj uq goal 
uq gn goal gn mn mn goal 
gn goal goal disj uq goal 
uq gn goal gn mn mn goal 
gn goal goal ite uq goal uq goal uq goal goal mode rules compound goals conjunction mode correct mode conjunct mode correct mode sequential combination modes 
disjunction mode correct mode disjunct mode correct mode mode obtained merging modes disjuncts 
existential quantification mode correct mode existentially quantified goal mode correct mode mode obtained removing existentially quantified variables negation mode correct mode negated goal mode correct mode instantiate variable non local goal 
goal mode correct mode condition goals mode correct modes respectively instantiate variable nonlocal definition equivalent simple mode system definition mode requires fin init 
important introduce unique modes see section allows inst variable unique negated goal 

simple mode system call 

init init fin init fin init goal 
unify vv unify inst init init fin init goal unify vf 
vn init init 
init unify inst functor 
fin init 
goal 
vn mode rules atomic goals shows mode rules atomic goals unifications calls 
call mode correct mode predicate mode correct procedure mode init matches init pair actual parameter call corresponding formal parameter 
actual parameter final inst greatest lower bound initial inst final inst corresponding formal parameter reason take greatest lower bound just final inst avoid losing information may initial inst final inst example final inst may know initial inst prohibits bound particular function symbol 
variable variable unification mode correct final instmap initial instmap inst inst resulting unification operation 
similarly variable functor unification mode correct final instmap initial instmap variable involved unification inst computed unify inst functor 
note generate mode error 
ectively performing occur check compile time 
allow unifications simply generate code fails 
unification useful practice programmer error useful thing report mode error alert programmer problem 
check plus fact don allow construction terms containing free variables means safely avoid run time occur checks 
categorise unifications modes 
unification free unification called assignment variables bound chapter 
current mercury implementation unification complicated unification mercury compiler replace call unification procedure specialised type mode arguments 
unification construction free unification deconstruction 
di erent kinds unification cient specialised implementation mercury machine 
mode analysis gives information required avoid needing general unification algorithm 
example 
example simple mode system shows syntax append saw page annotated mode information mode append 
initial instmap xs ground ys ground zs free show sub goal variables insts changed subgoal final insts variables 
note conjunction second disjunct di erent order 
re ordering necessary append mode correct particular mode 
discuss issue section 
append xs ys zs xs xs bound ys zs zs ground xs bound zs ground xs zs xs xs xs bound ground ground ground xs ground append xs ys zs zs ground zs zs zs bound ground ground xs bound ground ground ground xs ground zs ground zs bound ground ground xs bound ground ground zs bound ground ground xs bound ground ground zs ground syntax predicate append mode annotations completely defined simplified mode system 
section show expanded full mercury mode system 
full mercury mode system section gradually extend simple mode system defined able describe full mercury mode system 
necessary redefine types relations functions rules defined 
refer text referring version defined 

full mercury mode system liveness information simple mode system possible unification resulting inst ground 
system keep track aliases variables variables aliased unification instantiated mode system know variable instantiated 
know variables involved unification unification unification allowed 
definition liveness variable live program point may occur point reachable point forward execution 
define notion liveness precisely extending mode rules 
improve unification function 
liveness information useful uniqueness analysis section 
add new component var environment 
set set variables live success current goal 
allow boolean function pvar bool returns variables argument set live 
redefine mode rules calculate liveness set rules unification 
shows mode rules procedure 
liveness set body procedure set procedure arguments equivalent set unquantified variables body goal 
proc goal init init fin fin domm domm uq proc mode rule procedure liveness information page shows mode rules compound goals 
goals just pass liveness set sub goals 
exception conjunctions liveness set sub goal includes unquantified variables sub goals follow sub goal forward execution 
page shows mode rules atomic goals 
rule calls unchanged previous section 
rules unifications pass required liveness information unify inst unify inst functor 
chapter 
current mercury implementation conj goal uq uq mn goal 
gn goal goal disj goal uq mn goal 
gn goal goal ite goal uq uq goal mode rules compound goals liveness information definition inst unification liveness unify inst ground change unify inst resulting inst required ground variables live 
definition inst functor unification unify inst functor 


bound 
reached reached 
reached bound 

unify inst bound 
calculate approximation final inst ectively assumes 
reached final inst final argument insts reached 
bound need compute final argument insts abstractly unifying initial argument insts corresponding argument insts 
full mercury mode system call 

init init fin init fin init goal 
unify vv unify inst init init fin init goal unify vf 
vn init init 
init 
vn unify inst functor 
fin init 
goal 
vn mode rules atomic goals liveness information simple mode system said disallowing unifications form allowing unifications result non ground term su cient conditions safely omit occur check run time 
weakened conditions allowing construction term containing unbound variable variable live construction 
su cient condition safely omit run time occur checks unbound variable live occur unifications 
dynamic modes mercury strongly moded logic programming language 
trade strong modes flexibility expressiveness 
example doing constraint logic programming generally possible mode analyser know exact instantiation state constrained variables point program 
cases mercury allows form optional dynamic modes introducing instantiation state 
definition instantiation states shown 
instantiation state inst free bound instantiation state inst addition inst mercury mode system resembles mode system chapter 
current mercury implementation constraint logic programming language hal corresponding hal old free corresponding hal new 
mercury inst hal implementation targets mercury 
inst introduced mercury needed mercury clp interface predecessor hal project 
definition function insts function extended case free term bound 

inst approximates term 
definition instantiatedness partial order insts partial order extended insts free bound 

bound bound 


inst contains free components instantiated 
allow partial order describing inst variable changes forward execution 
rule safe context safe arbitrary pairs insts described 
definition inst unification unify inst restricting result live unification ground restrict 
possible free components result unification live variables 
definition matches partial order insts partial order extended insts free free reached free bound 


full mercury mode system bound bound 


insts match free bound inst functors free argument 
potentially allow free inst complete lattice 
variables inst generally require sort representation run time need initialised free variables represented memory 
mode system potentially introduce call initialisation predicate predicate called free variable argument expecting inst 
hal mode system fact introduce initialisation predicates mercury mode system 
significantly allowing free seriously weaken mode system allow merge insts succeed possibly producing inst free ground 
mean dynamic modes introduced places code programmer intend predicates dynamic mode declarations explicitly called 
prevent compiler reporting common programming errors believe idea 
definition abstraction function change uses new definition 
definition extra condition added predicate insts init fin init contain variable set may initial inst components 
test variable inst bound goal disallow variables negations conditions ensure soundness 
may overly restrictive cases typical hal programs quite extensively analysis may warranted allow simple cases able prove variable instantiated simply unified free variable 
important note inst subvert mercury strong mode system entirely optional ect variables 
said noted programmer entirely responsible ensuring insts way cause program unsound respect declarative semantics 
trade expressiveness safety static checking 
unique modes unique modes keep track number object 
allows possibility destructive update known variable object chapter 
current mercury implementation unique 
mercury unique modes henderson similar linear types uniqueness types languages concurrent clean 
uniqueness annotations describe unique modes introduce concept uniqueness annotations attach uniqueness annotation bound inst 
definition uniqueness annotation gives definition set uniq uniqueness annotations 
uniqueness annotation uniq unique unique shared clobbered clobbered uniqueness annotations annotation unique means corresponding memory cell unique means forward execution may backtracking shared means number unknown clobbered means corresponding data may accessed example may destructively updated clobbered means corresponding data may accessed forward execution may accessed backtracking 
definition uniqueness total order define total order uniqueness annotations unique unique shared clobbered clobbered say unique unique operators pairs sets represent greatest lower bound upper bound respectively 
intuition definition value uniqueness annotation higher total order restricted value uniqueness annotation lower total order terms done value 
example value unique annotation including places destructively update value value annotation shared unique required value annotation clobbered may value required examined 
counts define uniq formally abstraction concrete property terms runtime number memory cell representing function symbol term 
define concrete domain refcount set natural numbers 

full mercury mode system imagine function symbol term annotated tuple refcount represents number possible memory cell representing forward execution represents number possible considering forward backward execution 
require 
general sets may element number depend computation path taken reach particular program point 
require min forward execution backward execution combined forward execution 
define function uniq refcount abstraction function refcount uniq give semantics uniqueness annotations counts 
functions 

set positive integers 
clobbered clobbered shared unique unique clobbered clobbered unique unique shared abstractions functions uniqueness annotations define partial order counts annotate function symbol count refcount write notation term refcount mean set terms obtained annotating function symbol count follows 


require condition sub term parent term 
note record count annotations variables 
variables may aliased implicitly assume variable count 
term define chapter 
current mercury implementation define set annotated terms refcount term uniqueness function partial order counts alternative definition partial order uniqueness annotations see uniqueness annotation lower total order information possible number value 
value uniqueness annotation shared know value current may access value may way assumes may re memory 
value uniqueness annotation unique know value 
unique variable start atomic goal variable live goal forward execution count goes may re memory holding value 
memory variable re computation path rest system assume original content clobbered 
map set counts including uniqueness clobbered means avoid variable situation value may required 
instantiation states definition instantiation state gives new definition instantiation states includes uniqueness annotations 
possible uniqueness annotations constrained bound inst unique parents necessary subterm term contained 
precisely inst inst unique inst free bound 

inst instantiation state inst free bound 
occur arguments unique instantiation states uniqueness annotations 
full mercury mode system note uniqueness annotation free inst 
free insts implicit annotation unique free variable may may aliased 
definition function new definition insts uniqueness annotations definition function modified return set terms annotated counts inst 
free term bound 

definition uniqueness function define partial function uniqueness inst uniq returns uniqueness annotation top level functor instantiation state 
uniqueness uniqueness bound function undefined inst free 
definition instantiatedness partial order uniqueness partial order instantiation states modified free bound 

bound bound 


definition section augmented extra requirement inst free unique second 
mode system variable may unique forward execution 
definition matches partial order uniqueness partial order instantiation states modified follows free free reached free bound 

bound bound 


chapter 
current mercury implementation definition section augmented extra requirement inst free unique second 
okay variable unique initial inst mode declaration initial inst procedure body requires okay variable unique final inst procedure body final inst mode declaration requires 
similar considerations apply calls 
note uniqueness ordering reverse relation longer subset 
definition abstraction function abstraction function operate sets terms annotated counts inst 
free 
bound 
definition ground define inst ground parameterised uniqueness ground bound ground 
ground times defining ground ground unique say inst ground ground 
definition reached likewise define reached bound reached reached unique inst reached reached 
mode rules mode rules goals unchanged apart updated definitions unify inst unify inst functor 
initial liveness set procedure body precise variable uniqueness annotation clobbered clobbered top level live procedure succeeds 
changed procedure rule shown page 
predicates unify inst unify inst functor modified shown 

full mercury mode system proc goal init init fin fin domm domm uq clobbered uniqueness fin proc mode rule procedure unique modes definition inst unification uniqueness unify inst shared unique unify inst clobbered unify clobbered unify free free clobbered uniqueness clobbered uniqueness unification live variables result shared multiple live value 
achieve glb input insts shared checking contains free components 
variables live result just greatest lower bound insts loss uniqueness creating extra live value 
restriction part insts clobbered unification able fail 
reason values variables clobbered insts available unification possibly fail examine values variables 
definition inst functor unification uniqueness unify inst functor 


bound unique 
reached reached 
reached bound 

unify inst bound 
reason annotation unique bound unique 
unifications construct unique terms 
free operation ensures resulting inst chapter 
current mercury implementation unique 
example 
shows syntax append annotated mode information mode append di di uo 
initial instmap xs ground unique ys ground unique zs free show sub goal variables insts changed subgoal final insts variables 
mode declaration gives final inst xs ys ground clobbered 
gives mode checker information variables live unifications appear 
example ys zs unification know ys dead 
means resulting inst ground unique ground shared ys live 
note final inferred instmap xs ys inst ground unique 
okay ground unique ground clobbered inferred final insts match declared final insts 
append xs ys zs xs xs bound unique ys zs zs ground unique xs bound unique zs ground unique xs zs xs xs xs bound unique ground unique ground unique ground unique xs ground unique append xs ys zs zs ground unique zs zs zs bound unique ground unique ground unique xs bound unique ground unique ground unique ground unique xs ground unique zs ground unique zs bound unique ground unique ground unique xs bound unique ground unique ground unique zs bound unique ground unique ground unique xs bound unique ground unique ground unique zs ground unique syntax predicate append unique mode annotations mode checking uniqueness annotations necessary ensure program allow variables clobbered inst referenced backtracking 
check done determinism analysis turn done main phase mode analysis describe 
don know backtracking occur determinism analysis determinism procedure may depend modes calls 
determinism analysis second phase unique mode analysis scope thesis 
uniqueness annotations declared programmer inferred mode analysis implement automatic structure re compile time garbage collection 
discussion see taylor 
adding explicit uniqueness annotations mode declarations cumbersome 
done compile time garbage collection need 
full mercury mode system programmer manually add annotations annotations exist 
higher order modes shows changes required syntax instantiation states support mercury higher order programming features 
convenience introduce notion argument mode mode single procedure argument variable 
init fin flattened term higher order term goal goal call higher order call unification existential quantification negation conjunction disjunction instantiation state inst free bound higher order higher order inst argument mode higher order mercury higher order term may constructed unification form arguments pairs consisting lambda quantified variable argument mode lambda quantified variables distinct variables outside higher order term 
goal body higher order term 
higher order call atomic goal form variable previously bound higher order term sequence distinct variables 
higher order instantiation state form higher order uniqueness inst vector argument modes 
definition higher order function extended case higher order insts associated determinism annotation 
required determinism analysis omit simplicity 
chapter 
current mercury implementation higher order insts free term bound 

higher order 


var goal definition uniqueness function higher order case added uniqueness function obtaining uniqueness annotation higher order inst 
uniqueness uniqueness bound uniqueness higher order definition instantiatedness partial order higher order instantiatedness partial order extended incorporate higher order insts free bound 

higher order bound bound 


reached higher order higher order ground higher order 
higher order 


init init fin fin see definition higher order insts ground insts higher order insts comparable corresponding initial final insts comparable 
analysing call predicate higher order argument caller may specific information initial inst higher order argument callee requires 
want operation preserve extra information 
defining comparability higher order insts way ensure 
example facing page shows greatest lower bound higher order insts call rule 
comparing higher order values equality general undecidable requires proving di erent formulas predicate logic equivalent ideally mercury compiler generate error program attempts unify variables higher order insts 
melbourne mercury compiler adds check implementation unify inst 

full mercury mode system unfortunately catch occurrences attempting unify higher order values variable higher order value necessarily higher order inst may inst ground 
undecidable higher order unifications detected compile time caught run time 
definition matches partial order higher order extend matches partial order incorporate higher order insts free free reached free bound 

higher order bound bound 


reached higher order higher order ground higher order 
higher order 


init init fin init fin partial order higher order insts comparable corresponding insts argument modes comparable 
higher order inst matches higherorder inst higher order value inst value inst required 
ordinary calls okay caller provide tighter initial inst callee requires callee provide tighter final inst caller requires 
example 
higher order shared ground shared ground shared higher order shared bound shared bound shared higher order shared ground shared bound shared refer call rule page 
call mode formal parameter initial inst actual parameter final inst formal parameter definition abstraction function extend abstraction function higher order terms 
free chapter 
current mercury implementation 
bound 

higher order 
shows mode rule higher order calls 
rule similar call rule see page uses insts higher order inst mode procedure called 
ho call init higher order 

init init fin init fin init goal 
vn mode rule higher order calls facing page shows mode rule unification variable higher order term lines describe instmap procedure changed unification bound higher order inst live variables occur inside outside higher order term denoted shared variables inst unique free components unwanted aliasing higher order term variables 
remaining lines describe higher order term mode checked 
mode higher order term contains unquantified variables goal lambda quantified variables modes 
variables initial insts live variables shared may instantiated lambda goal 
goal mode correct mode respect environment uq set unquantified variables clobbered concrete syntax recursive insts convenience uniformity presentation syntax chapter insts di ers concrete syntax mercury language 
table page gives correspondence syntaxes fairly straightforward 
remind reader exposition chapter simplicity ignored determinism annotations higher order insts 
note concrete syntax insts example higher order insts uniqueness annotation shared 
syntax insts added simple modification mercury parser deemed useful feature 
described section language allows programmer define named insts may possibly recursive definition named inst may refer 
assumed named insts expanded 
fixedpoint combinator necessary convert recursive definitions infinite insts 
insts examples regular trees 
require insts mercury program regular trees expressed finitely 

full mercury mode system unify unify inst init higher order unique uq init unique init shared fin init domm uq 


init init fin fin init init uq clobbered uniqueness fin uq goal goal mode rule higher order unifications mercury concrete syntax syntax free free shared unique unique unique unique clobbered clobbered clobbered clobbered ground ground shared unique ground unique unique ground unique clobbered ground clobbered clobbered ground clobbered reached reached bound 
bound shared 
unique 
bound unique 
unique 
bound unique 
pred 
det higher order shared 
table comparison mercury concrete syntax insts chapter 
current mercury implementation example 
example mercury inst definition inst list skel bound free list skel 
occurrence list skel expanded fix 
bound shared free syntax 
obviously possible represent recursive insts infinite data structures compiler 
actual implementation inst type contains extra alternative defined inst inst name inst name pointer lookup table known inst table contains definition inst 
operation insts compiler passed inst table keep track defined insts seen ensure keep expanding recursive insts indefinitely 
operations create new insts may need add new entries inst table 
extra book keeping adds considerably complexity mode system 
order maximise comprehensibility exposition chosen leave presentation concept infinite insts 
information regular trees implementation techniques see aiken murphy comon 
modifying goals mode analysis mode rules sections assume procedure body fixed 
particular procedure mode correct mode system able perform limited modifications may possibly transform mode correct form whilst preserving declarative semantics 
modifications system may perform 
re ordering conjuncts conjunction 
introducing extra variables unifications allow call implied mode predicate 
mode system decide procedure predicate call predicate information specified source code 
issues discussed 
conjunct re ordering conjunction mode correct permutation may 
mode system free select permutation mode correct 
section discusses algorithm selection 
conjunct re ordering particularly important predicates multiple modes 
may possible write clauses predicate valid required modes 
example 
example predicate append conversion form looks 
modifying goals mode analysis pred append list list list 
append xs ys zs xs ys zs xs xs zs zs append xs ys zs 
mode analysis procedure mode append conjunction second disjunct re ordered 
annotated unification indicate assignment construction 
mode append det append xs ys zs xs zs ys xs xs append xs ys zs zs 
procedure mode append mode correct di erent order required conjunction second disjunct mode append multi 
append xs ys zs xs ys zs zs zs append xs ys zs xs 
chapter 
current mercury implementation implied modes selecting procedures definition implied mode know mode valid mode predicate mode valid mode predicate domm domm domm 
init free init free init init fin fin known implied mode write example 
example append implied mode append append 
analysing call predicate mode available predicate matches mode require may able mode mode implied mode 
particular call 
vn variable init free procedure mode corresponding argument requires initial inst free replace new free variable call add unification call 
goal existentially quantified conjunction 

vn extension transformation multiple arguments obvious 
task mode system analysing calls call predicate multiple procedures procedure selected 
general may procedures may valid particular call 
may include procedures called implied modes described matching procedures general mode required 
mode analysis try select mode cient 
prefer exact match implied mode prefer specific matching mode general matching mode 
exact match general cient implied mode avoid unnecessary construction comparison data structures 
specific matching mode may cient general matching mode extra information input arguments may allow avoid tests values arguments 
mode analysis algorithms previously chapter mode rules obeyed mode correct mercury procedure described procedures may transformed allow obey rules 
describe actual algorithms mode analysis transformation 
bulk information needed understanding mode analysis give informal presentation algorithms filling important information implementation 

mode analysis algorithms algorithms take input mercury module consisting set predicates plus set mode declarations 
mode declarations required predicate exported module 
optional predicates 
predicate output set procedures mode correct rules previously chapter set mode errors 
predicate set mode declarations procedure output corresponding mode declaration provided proved mode correct 
mode declarations predicate modes procedures inferred modes predicate callers see section page 
algorithm free modify body procedure described section 
considerable ort expended implementation error messages informative helpful possible 
omit discussion 
annotate subgoal body procedure map describes instmap changes execution goal 
refer instmap delta 
ciency treat ground primitive inst defining terms bound 
allows ground insts type represented single word complex data structure describing structure inst 
mercury programs rarely insts free ground ciency benefits doing considerable 
mode checking algorithm mode checking procedure mode check procedure 
initialise insts head variables initial insts mode declaration 

mode check body goal see mode checking goals 

mode errors goal analysis check final insts computed analysis match final insts mode declaration 
scheduling sub goals mode checking conjunction requires notion scheduling sub goals goal 
attempt schedule goal mode check goal described respect current instmap 
mode checking succeeds scheduling succeeds commit executing goal immediately previously scheduled goals current conjunction 
mode checking reports error due insu ciently instantiated non local variable scheduling fails current instmap may try instmap 
mode checking goal mode check goal goal conjunction attempt schedule sub goal 
sub goal scheduled schedule delay 
continue remaining sub goals goals left 
chapter 
current mercury implementation time variable gets bound see wake delayed goal attempt schedule new current instmap time get back conjunction 
delayed goals reach conjunction report mode error 
time try new ordering goals recompute liveness sets goals comply conj rule 
disjunction mode check sub goals check final insts non local variables comparable sub goals compute final instmap operator see disj rule 
existential quantification mode check sub goal 
remove existentially quantified variables instmap see rule 
negation mode check sub goal 
check sub goal instantiate non local variables see rule 
attempt schedule condition 
successful check doesn instantiate non local variables mode check part part check final insts match compute final instmap operator see ite rule 
unification perform unification accordance rules unify vv unify vf unify depending form unification 
predicate call check mode declaration predicate matches current instantiation arguments see call rule 
predicate mode declarations need mode inference see section 
handle calls implied modes see section 
higher order call check higher order mode matches current instantiation arguments see ho call rule 
limitations mode checking main limitation mode checking keep track aliases 
chapter discusses impact limitation precision expressiveness mode system ers solution problem 
algorithmic complexity carried formal analysis computational complexity mode checking algorithm 
observations practical experience 
note mode checking phase mercury compiler takes significant proportion compile time profiling indicates typically 
mode checking time module linear number predicates 
predicate time potentially super linear size goal 
particularly bad case occurs unification constructs deeply nested term 
example unification free variables ground expanded 
mode analysis algorithms normal form conjunction 
compiler know doing expansion final order conjunction job mode analysis determine 
order correct ground unification 
happens cient order type analysis order compiler initially chooses 
mode analyser reverse order conjuncts order mode correct case free unification 
order tries schedule unifications denote left hand side variables fail fail fail fail succeed fail fail fail succeed fail fail succeed fail succeed succeed 
reversal takes time nesting depth original term 
significant cost mode analysis limitations current system important extensions cient possible 
mode inference algorithm mercury mode system allows basic modes inferred predicates exported module defined 
mode checking come call predicate mode declarations attempt infer mode predicate initial insts arguments called 
predicate recursive directly indirectly scc predicate declared modes may necessary repeat inference process fixpoint reached 
normalisation prevent excessive number procedures produced call site predicate potentially result new procedure created ensure termination mode inference algorithm normalise insts procedure replacing ground inst inst ground matches 
definition normalise function normalise inst normalise ground ground bound normalise bound ground 
normalise normalise 
normalise 
ground normalised inst ground inst uniqueness upper bound set ground 
non ground bound inst function attempts normalise argument functors 
actual implementation recursive step 
theory means inference algorithm may terminate non ground insts far problem practice probably chapter 
current mercury implementation fixpoint algorithm mode analysis see call predicate modes weren declared check call matches modes inferred 

create new procedure predicate 

set initial insts normalised version insts call arguments 
set final insts reached 

mode check body goal 

normalise computed final insts 

final insts changed go step 
reaching fixpoint return calling procedure set insts arguments normalised final insts computed call continue analysis 
procedure inferring modes directly recursive may need multiple iterations loop steps reach fixpoint 
iteration typically derive insts final arguments appropriate non recursive clauses final insts recursive call reached insts variables recursive clause reached 
second iteration recursive clauses may able contribute reachable insts 
general inst computed argument iteration iteration algorithm infers final inst ground normalise function cause result quickly converge fixpoint ground limitations mode inference number limitations implementation mode inference infer modes predicates exported module 
infer normalised modes 
re order conjunctions contain calls predicates modes need inferred 
doing re ordering may require mode system attempt analyse di erent modes predicate cause combinatorial explosion 
infer modes arguments clobbered 
infer higher order modes higher order variables arguments mode declared predicate declaration higher order unification 
chapter look alternative approach mode analysis overcome limitations 
mode inference partially instantiated insts moment 
implementation ensure inferred partially instantiated insts regular trees described finitely 
implementation 

related related relationship interpretation take look relationship mode analysis mercury interpretation 
look mode system unique modes 
definitions abstraction function inst function inst 
matches partial order form galois connection inst note total function likewise inst complete lattice 
sets terms term defined represent sets possible values may produced programs mode correct sets containing variable non variable terms term 
interested descriptive mode system weak prescriptive possible total function adding free definition upper bound pair insts 
previously discussed believe mode system weak catch programmer errors catch suitable strong prescriptive system 
uniqueness annotations galois connection refcount uniq obtain galois connection inst uniqueness annotations need define appropriate partial order rt rt 


rt galois connection rt inst doing mode checking avoid need fixpoint computation declared modes predicate 
doing mode inference need widening step form normalise function order ensure reach fixpoint finite reasonable time 
interpretation provide modifying program analysis re ordering conjunctions introducing unifications implied modes 
possible formalise transformation program transformation framework cousot cousot interpretation looked doing 
related noted mercury mode system somogyi henderson 
features set mercury mode system apart mode systems chapter 
current mercury implementation logic programming languages strong prescriptive system allows extremely high level precision describing modes performs re ordering conjunctions necessary supports higher order programming contains uniqueness analysis 
believe mode system provides features 
closely related mode system mercury mode system hal 
di erences 
hal uses names new old free 
hal allows new old mode system weaker mercury detecting mode errors compile time convenient doing constraint logic programming inst constraint variable usually old generally possible know precise instantiation state 
hal compiler inserts call init predicate new variable needs initialised 
initialisation variable old 
hal allow new occur inside argument bound inst old 
support mercury unique modes features 
hal facilities making inst look di erent inside module looks outside module 
convenient writing constraint solvers typically want constraint variables inst old outside module solver defined ground inst inside module 
see de la banda information hal mode system information hal language general 
terms precision expressiveness probably closely related mode system mercury 
describe mode analysis domains statically typed logic programming language godel 
mode system instantiation states types 
ways system expressive mercury example describe open non terminated structures di erence lists 
instantiation states reflect structure type closely way describe subtypes list number elements non empty list 
equivalent mercury insts inst definitions 
inst list bound list 
inst non empty list bound list skel 
appear ignore higher order constructs system built top prescriptive type system mode system descriptive 
implementation works technique compilation abstraction program compiled prolog program executed 
means di erence lists complex variable aliasing patterns may expressed variable aliasing program 
system constructs single prolog module entire godel program 
prohibits separate compilation multi module program believe technique impractical large real world programs 
mentioned earlier mercury unique modes henderson turn wadler 
functional language concurrent clean uses similar idea uniqueness annotations placed types 
ueda presents linearity analysis concurrent logic language moded flat ghc 
constraint approach determine data structure linear non linear way 
data structure exactly 
related producer data structure linear exactly consumer 
consumer data structure knows consumer data may free re memory associated data structure 
concept similar mercury destructive input mode di unique clobbered 
system descriptive system prescriptive closer spirit mazur aims find opportunities compile time garbage collection structure re mercury prescribed uniqueness conditions 
general automated system preferred programmer allows avoid explicitly annotating mode declarations uniqueness 
uses unique modes modelling input output arrays necessary prescribe unique modes order ensure data structures ways ensure soundness operational semantics ensure program try backtrack undo operations access value array destructively updated 
chapter 
current mercury implementation chapter mode polymorphism problem general mode polymorphism mercury parametric polymorphic type system important feature facilitating code reuse 
example predicate append declared pred append list list list 
able operate lists containing elements type 
polymorphically typed predicate 
order predicate polymorphically give mode type 
insts ground free modes ground ground free ground useful situations type 
example mode declaration mode append 
equally lists type 
possible situations ground mode polymorphically typed predicate lead unacceptable loss precision expressiveness 
mode append may called input arguments having instantiation states match ground specific 
example elements lists may bound higher order terms corresponding higher order insts 
predicate builds output list elements input lists know elements output list ought higher order inst 
unfortunately mode declared higher order information lost output argument 
means element list may called higher order term program 
clearly want able sort parametric polymorphism mode declaration associate insts input arguments final inst output argument 
need checked analysing mode predicate 
defined inst inst list skel bound list skel 
think specify inst variable analogous type variable type declaration chapter 
mode polymorphism mode append list skel list skel list skel 
stand inst 
unfortunately 
inst inst free 
usual definition append lead predicate creating aliasing free variables elements lists mercury allow 
observe knew inst represented contain free components problem mode 
allow mode polymorphism need constrain possible insts inst variable allowed represent 
rest chapter extension mercury mode system allows form constrained polymorphism mode declarations 
section presents syntax system gives mode checking rules 
section presents extension gives flexibility handling uniqueness system 
section look polymorphic mode information may derived polymorphic type declarations 
section discuss issues surrounding types instantiation states closely related polymorphism 
section look related 
constrained mode polymorphism syntax inst variable constraints form states inst variable represents inst sub inst inst 
definition sub inst precise section constraints may appear mode declaration predicate preceded operator may appear constraint 
example mode declaration mode append list skel list skel list skel inst variable constrained represent sub inst ground 
inst variable appearing mode declaration occur initial inst argument mode 
reason parameters designed relate initial insts arguments final insts possibly di erent arguments 
predicate constrained polymorphic mode called actual inst represented inst variable calculated initial insts determine final insts arguments call 
syntactic convenience assume unconstrained inst variable mode declaration constrained sub inst ground 
example mode append list skel list skel list skel 
equivalent declaration previous example 
valid mode declaration append general 
constrained mode polymorphism mode append list skel list skel list skel sub insts formally define notion sub inst 
want describe inst matches inst unique 
definition sub inst inst sub inst inst write constraint means represents inst note exactly level uniqueness 
example ground component uniqueness annotation constraint imposed fact definition uses uniqueness partial order reverse way definition 
section looks allow inst variable represent insts range uniqueness annotations 
example 
example bound shared ground shared bound unique ground shared bound clobbered ground shared 
constrained inst variables implement constrained inst variables adding alternative constrained inst set inst variables inst definition domain inst shown 
inst may contain occurrences constrained inst 
meaning constrained inst represents inst sub inst sub inst insts represented inst variables inst constrained inst equivalent 
instantiation variable instvar instantiation variable set instantiation state inst free bound higher order constrained inst instantiation states constrained polymorphism creating procedure mode derived mode declaration replacing occurrence constrained inst variable constraint mode declaration constrained inst domain 
ensures properties hold mode belonging procedure property constrained inst occurs 
singleton set 
chapter 
mode polymorphism property constrained inst occurs constrained inst occurs properties need necessarily hold modes goals procedure body 
extend partial orders 
treatment sets inst variables definitions designed give partial orders required properties operations unification inst merge matching 
explained 
definition instantiatedness partial order constrained inst partial order defined free bound 

higher order bound bound 


reached higher order higher order ground higher order 
higher order 


init init fin fin constrained inst constrained inst constrained inst constrained inst constrained inst constrained inst recall partial order defines transitions instantiation states valid variable forward execution goal refer section page 
inst transition inst inst allowed definition case constrained inst constrained inst requiring constrains sets sub inst contain inst variables sub inst may contain inst variables reason define sub inst know new inst sub inst insts represented inst variables sub inst know new inst sub inst insts represented inst variables inst variables see definition inst constrained inst treated constrained inst 
unification operation defined terms greatest lower bound partial order 
definition see constrained inst constrained inst constrained inst 
constrained mode polymorphism means doing unification constrained inst resulting inst constrained inst contains inst variables original insts resulting inst sub inst original inst 
example 
constrained inst bound shared constrained inst bound shared constrained inst bound unique constrained inst bound shared constrained inst bound shared note includes inst variables bound shared bound shared bound shared bound shared 
include bound shared bound unique bc uniqueness annotation changed unique shared 
definition matches partial order constrained inst partial order defined free free reached free bound bound 


reached higher order higher order ground higher order 
higher order 


init init fin fin constrained inst constrained inst constrained inst constrained inst constrained inst constrained inst chapter 
mode polymorphism definition requires match inst constrained inst non empty inst variable set requires inst constrained inst matches contains inst variables partial order check inst matches places checking insts argument variables call correctly instantiated procedure called checking insts inferred procedure body match final insts procedure mode declaration 
see definition requires inst variable occurs final inst mode declaration inst variable occur corresponding final inferred inst 
case definition directly 
necessary apply inst substitution inst variables procedure mode 
described section 
example 
constrained inst ground shared constrained inst ground shared inst merge operation defined upper bound 
definition leads constrained inst constrained inst constrained inst merging constrained insts requires intersection inst variable sets 
example 
constrained inst bound shared constrained inst bound shared constrained inst bound shared inst substitutions analysing call procedure constrained polymorphic insts mode necessary substitute inst variables mode corresponding actual insts arguments call 
need notion inst substitution 
analogous usual variable substitution works inst variables program variables 

constrained mode polymorphism definition inst substitution inst substitution function mapping inst variables insts instvar inst order cause inst variables inst substituted accordance substitution apply 
write 
substitution comes mode declaration assume property page holds occurrence constrained inst singleton set 
definition apply substitution inst inst inst substitution inst obtained replacing occurrence constrained inst dom 
substitution fails dom constrained inst dom bound bound higher order 
higher order 
free 


init fin analyse call procedure constrained inst insts mode thing need substitution needs applied insts procedure mode insts argument variables caller 
function get subst defined help 
function insts mode declaration assume property page holds 
definition get substitution function get subst inst inst defined page calculates substitution set call set pairs member pair inst argument variable calling procedure second member initial inst called procedure corresponding argument 
function get subst calls get subst inst pair insts calls merge merge results substitution 
pair insts constrained inst get subst inst returns substitution 
reason greatest lower bound just ensure inst substituted unique necessary condition sub inst cases definition get subst inst search inst substitutions recursively compound insts chapter 
mode polymorphism get subst bound get subst ho respectively find corresponding pairs insts functors bound insts argument modes higher order insts 
final case returns empty set substitutions 
function merge responsible combining set substitutions single substitution 
inst variable occurs multiple substitutions take upper bound insts 
get subst merge get subst inst get subst inst constrained inst get subst inst constrained inst get subst bound bound bound get subst ho higher order higher order 
get subst bound get subst 


get subst ho 

get subst init init fin fin merge dom dom get subst function example 
assume mode declaration mode append list skel list skel list skel 
predicate append call append initial insts list skel bound list skel bound free 
syntax insts list skel defined list skel fix bound shared 
call get subst list skel bound shared list skel list skel bound shared list skel free free computes substitution bound shared 
mode checking constrained inst variables mode check calls procedures constrained insts modes modify call rule previous definition see page 
new definition shown 
constrained mode polymorphism 
di erence previous definition get subst calculate substitution initial insts caller callee 
apply substitution insts callee 
similar modification required ho call rule 
call 
init init get subst 

init init fin init fin init goal 
vn ho call init higher order 
init init get subst 

init init fin init fin init goal 
vn mode rules calls constrained polymorphic modes mode rules remain unchanged simply new definitions correctly calculate inst variable sets constrained insts 
example 
page shows syntax append annotated mode information mode mode append list skel list skel list skel initial instmap xs list skel constrained inst ground shared ys list skel constrained inst ground shared zs free show sub goal variables insts changed subgoal final insts variables 
space reasons symbol denote inst constrained inst ground shared 
note final inst inferred zs matches final inst required mode declaration 
particular includes constrained inst variable 
chapter 
mode polymorphism append xs ys zs xs xs bound shared ys zs zs list skel xs bound unique zs list skel xs zs xs xs xs bound shared list skel xs list skel append xs ys zs zs list skel zs zs zs bound unique list skel xs bound shared list skel xs list skel zs list skel zs bound unique list skel xs bound shared list skel zs bound unique list skel xs list skel zs list skel syntax predicate append polymorphic modes uniqueness ranges problem scheme mode polymorphism previous sections set insts constrained inst variable may represent uniqueness 
useful able specify upper lower bound uniqueness insts may represented inst variable 
example consider procedure mode mode 
procedure mode correct ensure uniqueness argument maintained 
argument procedure way requires unique reason ground 
want able specify inst variables constrained uniqueness range shared unique 
pair insts di er uniqueness unique second 
partial order relation gives definition need 
definition uniqueness partial order insts define partial order insts insts identical apart level uniqueness unique 
uniqueness ranges extend inst constrained inst replacing pair insts require new definition inst shown 
meaning constrained inst represents inst compare previous definition constrained inst constraint 
note old new definitions equivalent 
instantiation state inst free bound higher order constrained inst instantiation states constrained polymorphism uniqueness ranges constrained inst insts approximate actual inst represented inst variables places mode analysis safe approximation places safe approximation 
formalise safe approximations new definitions 
definition instantiatedness partial order constrained inst partial order defined free bound 

higher order bound bound 


reached higher order higher order ground higher order 
higher order 


init init fin fin constrained inst constrained inst constrained inst constrained inst chapter 
mode polymorphism constrained inst constrained inst case constrained inst constrained inst require ensures inst range smaller inst inst large range larger inst 
determine constraints compare constrained inst sub inst inst represented include inst variables cases constrained inst compared inst constrained inst treat constrained inst 
definition matches partial order constrained inst partial order defined free free reached free bound bound 


reached higher order higher order ground higher order 
higher order 


init init fin fin constrained inst constrained inst constrained inst constrained inst constrained inst constrained inst case constrained inst constrained inst ensure definition comparing constrained inst non constrained inst treat constrained inst 
redefine application inst substitutions get subst inst function 
definition apply substitution constrained inst applications inst substitutions merely need modify check substituted inst checking check constrained inst dom bound bound higher order 
higher order 
free 

uniqueness ranges get subst inst see constrained inst constrained inst previous definition decide place definition get substitution constrained inst new definition get subst inst shown 
auxiliary functions get subst bound get subst ho unchanged call new version get subst inst 
constrained inst return substitution 
take glb ensure inst represented unique mode rule calls ensures uniqueness falls range specified constrained inst call get subst inst recursively safe approximation inst represented inst variable know get subst inst constrained inst get subst inst constrained inst get subst bound bound bound get subst ho higher order higher order 
get subst inst function constrained inst example 
page gives example constrained polymorphic insts uniqueness ranges 
define recursive inst unique list skel fix bound unique assume mode declaration map initial instmap higher order shared ground shared ground shared free constrained inst ground shared ground unique xs ground shared ys free final instmap ys unique list skel constrained inst ground shared ground unique inst parameter constrained inst ground shared ground unique relate higher order inst final inst ys 
caller map instantiates predicate final inst second argument ground unique final inst ys list unique skeleton elements inst ground unique 
hand instantiated predicate final inst second argument ground shared final inst elements ys chapter 
mode polymorphism ground shared 
mode annotations symbol place inst constrained inst ground shared ground unique 
map xs ys xs xs bound shared ys ys bound unique xs bound shared ys bound unique xs ys xs xs xs bound shared ground shared ground shared ground shared xs ground shared map xs ys ys unique list skel ys ys ys bound unique unique list skel xs bound shared ground shared ground shared ground shared xs ground shared ys unique list skel ys bound unique unique list skel xs bound shared ground shared ground shared ys bound unique unique list skel xs bound shared ground shared ground shared ys unique list skel syntax predicate map polymorphic modes theorems free adding constrained inst parameters mode declaration polymorphically typed predicate big impact syntactic declaration time required mode analysis example inst list skel ground adds extra complexity compiler traverse structure inst time processes analysis 
extra overhead book keeping required recursive insts 
nice compiler infer situations constrained mode polymorphism programmer avoid complicated mode declarations compiler worry added complexity mode analysis potentially polymorphically moded predicate 
predicate polymorphically typed argument operations possible argument restricted 
variable typed values predicate know type value values type discard pass output arguments 
strictly true mercury due presence run time type information way problem discussed 
allows infer relationships arguments share polymorphic type variables solely predicate type 
insts declaration 
concept generally know theorems free 
idea theorems free obtain implicit mode polymorphism mentioned de la banda respect hal 
achieved propagating type information insts mode declaration procedure polymorphic type variable type declaration inserting corresponding polymorphic inst variable mode declaration 
example pred mode declaration pred member list 
mode member 
infer precise mode declaration mode member list skel means programmer worry polymorphic mode declaration member 
means mode analyser simpler declaration mode analysis member saving considerable analysis time 
analyser inferred polymorphic declaration analysing calls member add significant time mode analysis 
theorems free case unconstrained type polymorphism 
type variables predicate declaration type class constraints unable infer theorems free involve type variables methods instances type class information type question able construct new values type 
mercury programs access run time type information rtti type program 
allows predicates perform certain operations objects type type known compile time 
includes operations allow construction new values arbitrary type conversion universal type univ 
operations invalidate theorems free way type class constraints 
implicit type class constraint type variable predicate declaration 
theorems free approach modify mercury language require implicit constraint explicit 
create new type class require type instance class wish perform operations manipulate values type run time type information 
polymorphically typed predicate wished operations required type class constraint declaration know apply theorems free 
insts mentioned section mercury supports types 
consider module type declaration type interface section type definition type pred int int 
chapter 
mode polymorphism implementation defines higher order type 
values type passed outside module type predicates module know implemented values type calling 
seen value higher order type callable needs higher order instantiation state provides mode declaration predicate represents 
define instantiation state inst pred det 
keeping principle information hiding type inst revealed information outside module know definition higher order type arguments 
problem providing insts inst may contain free components know safe creating aliases free variables 
similar problem providing general mode polymorphism provide similar solution provide constraint inst declaration give mode system information needs inst exposing implementation details 
mitchell plotkin showed types thought existentially quantified types 
treat inst similar way kind existentially quantified inst 
idea give inst declaration need give constraint inst 
example inst declares inst sub inst ground words declaration says exists inst sub inst ground 
mode checking module mode system compare inst declaration definition module implementation ensure constraint valid 
appears predicate mode declaration visible outside module replace constrained inst ground shared 
inside module implementation constrained inst 
change need mode checking algorithm get subst inst see constrained inst ground shared create substitution inst variable 
means predicate requires inst initial inst argument variable inst match 
related saw section hal mode system able propagate polymorphic type information modes predicate theorems free principle 
able original inst corresponding type variable ground 
hal provide support programmer give arbitrary constrained inst parameters 
related mode declarations system general 
hal mode system support uniqueness annotations deal issues surrounding mode polymorphism uniqueness 
mode polymorphism uniqueness ranges provides similar expressiveness attribute variables concurrent clean allow polymorphism uniqueness type attributes 
attribute variables di er mode polymorphism parameterise uniqueness attributes parameterised insts types 
chapter 
mode polymorphism chapter alias tracking chapter look significant shortcoming mode system described chapter inability analysis keep track aliases variables 
section look want keep track aliases 
section explain choose track definite aliases possible aliases section extension mode system chapter adds definite aliasing analysis describe benefits addition entails precision mode system 
section look extension mode system extension mercury machine allow limited form partially instantiated data structures loss precision caused insts 
give example extensions provide opportunities turning call tail call moving construction unifications call 
section look related 
section limitations alias tracking system discuss possible 
simplify discussion base alias tracking system mode system described chapter omit polymorphic mode extension described chapter 
note extensions described current chapter chapter orthogonal problem implementing mode system 
need alias tracking motivate need alias tracking presenting examples presence improves precision analysis allows admit programs able prove mode correct 
aliases precision need alias tracking improve precision mode analysis generally arises variables aliased usually unification inst variables changes 
ultimate precision correctness change reflected inst variable 
example 
simple example conjunction chapter 
alias tracking ground start conjunction mode bound 
alias tracking information call result mode error mode system know bound functor 
kept track fact aliased know bound bound confirm call mode correct 
example 
variation mode bound bound ground start conjunction 
directly aliased aliased argument functor bound 
see keeping track alias give precise information inst inst changes 
examples alias tracking allowed gain precise information inst variable alias information allow avoid throwing away information may useful determining mode correctness analysis 
consider example assume initial inst unique ground 
unification live inst need ground ground shared need throw away unique annotation 
mode requires unique run mode error 
record unification aliased say unique long remember change inst ect inst 
subtle change mean unique 
previously variable inst unique meant single 
means may multiple know 
consider example assume initial inst free 
assume purpose discussion conjunction re ordered 
mode system chapter unification result mode error live 
way tracking change inst variable ect inst 
dealing ground insts lack alias tracking lead loss precision may acceptable circumstances 
non ground insts partially instantiated insts allowing live free variables unified wouldn just lose precision introduce possibility inst mode system compute longer correct approximation actual term variable bound 
example call causes clobbered record clobbered 
particular example mode system re order conjunction unification delayed unification 
re ordered conjunction mode correct 
section see example re ordering possible 

need alias tracking mode system option report mode error unification 
record alias know bound argument functor bound 
means allow partially instantiated insts exist provided know aliases 
seen alias tracking useful increasing precision mode analysis potential unique modes useful allow limited partially instantiated insts far useful gains 
expand uses alias tracking examples 
aliases unique modes mode system described chapter handles simple unique modes di uo adequately purposes 
lack alias tracking means correctly analyse nested unique modes unique object placed inside unique data structure 
example 
consider code page 
code defines type record consists single functor arguments types io state int 
defines inst record functor argument unique second argument ground 
inst io record argument clobbered 
predicate get io extracts unique io state inside record 
live io state field 
alias tracking analysis give io inst ground shared match required inst ground unique 
alias tracking know live get io exits argument clobbered infer correct inst allow procedure admitted mode correct 
aliases partially instantiated modes partially instantiated data structures data structures contain free variables 
useful wants di erent parts data structure filled di erent parts program 
partially instantiated insts approximate partially instantiated data structures 
example 
consider code page 
goal length iota length constructs skeleton list specified length iota fills elements list 
alias tracking system unable verify mode correctness second disjunct iota 
deconstruction unification unifies tail partially instantiated 
recursive call instantiates ground information tail aliased mode checker unable determine recursive call causes tail ground required mode declaration iota 
reason generate mode error deconstruction unification 
re order conjunction ground deconstruction unification need generate mode error 
possible mode syntax inst record bound unique ground unique ground shared see table page 
chapter 
alias tracking type record io state int 
inst record unique unique ground 
inst io unique clobbered ground 
pred hello record record 
mode hello record clobbered free record det hello get io io write string hello world io io set io io 
pred get io record io state 
mode get io record io free unique det get io io io 
pred set io record io state record 
mode set io io clobbered unique clobbered free record det set io io io 
nested unique modes example iota requires partially instantiated recursive call deconstruction unification conjunct partially instantiate definite versus possible aliasing design alias tracking system important question need answer appropriate way handle indefinite aliasing information 
considering variables possible cases 
variables definitely aliased 
variables may possibly aliased don know certain 
variables definitely aliased 
example 
consider code fragment 

definite versus possible aliasing pred length list int int 
mode length list skel free det length length 
pred iota list int int 
mode iota list skel free ground det iota iota 
partial instantiation example 
disjunct definitely aliased second disjunct definitely aliased disjunction know definitely aliased possibly aliased possibly aliased depending branch disjunct taken 
partially instantiated data structures variables definitely aliased definitely aliased 
case possible alias needs mode error insu cient information able say happens variable variable possibly aliased instantiated 
partially instantiated data structures need keep track definite aliases 
unique modes hand want know variable definitely unique possibly aliased 
ideally unique modes keep track possible aliases 
keeping track definite possible aliases quite expensive conservative approximation allows just definite aliasing information unique mode analysis 
approximation shared inst annotation indicate variable possibly aliased specifying variable may aliased 
chapter 
alias tracking extending mode system describe extend mode system chapter alias tracking system allow write programs examples shown 
alias insts extend inst new alternative alias inst key shown 
set symbols distinct var 
alias inst may appear mode procedure argument modes higher order term 
inst key instantiation state inst free bound higher order alias instantiation states aliases extend instmap allow mapping inst keys insts instmap var inst 
assume existence function new inst key instmap instmap returns inst key occur instmap 
meaning alias variables parts variables inst alias instmap definitely aliased 
actual underlying inst obtained looking inst key instmap addition alias means insts meaningful instmap 
program point associated instmap refer current instmap point 
execute goal current instmap initial instmap mode goal 
just executed goal current instmap final instmap mode goal 
abstractly unify insts alias alias need record inst keys aliased 
adding alias instmap 
chains inst keys analogous pointer chains aliased variables wam 
need able determine inst key necessary new inst key unique procedure described rename inst keys merge 
actual implementation inst key inst mapping kept separate data structure called inst key table instmap 
simplifies types convenient implementation convenient describing system extension mode system previous chapters 

extending mode system instmap key chain described contains 
inst key function 
definition inst key define function instmap alias 
say inst key corresponds 
definition inst keys inst useful able obtain set inst keys inst refers respect instmap inst keys inst keys alias nm inst keys bound 

fm 
nm 
operations modify insts need access may need modify current instmap 
give new definitions operations 
comparisons insts partial orders usually remain unchanged long expand insts compared substituting alias inst key current instmap appears insts compared 
definition alias expansion expansion inst respect current instmap expand expand alias bound expand bound 
expand expand 
expand 
definition alias expansion define variation expansion removes alias inst resulting inst shared 
function defined inst partially chapter 
alias tracking instantiated 
expand shared alias expand shared unique shared bound bound expand shared expand shared expand shared 
expand shared 
happens particular inst key appears instmap inst key provides useful information removed instmap replacing single occurrence alias clear variable inst appears really alias due inst key 
purpose assume existence function remove singleton inst keys instmap instmap 
definition restriction operation modes singleton inst keys occur mode restriction operation see definition page 
redefine operation ensure singleton inst keys removed init fin remove singleton inst keys dom unification recall unification defined terms greatest lower bound partial order 
alias tracking unification needs access current instmap order lookup inst keys may occur insts abstractly unified 
may need update value inst key instmap inst corresponds instantiated 
define parameterised operators analogous respectively parameterised mode current instmap passed operator init operator returns fin init updated changes inst key mapping operation 
definition instantiatedness partial order aliasing new parameterised partial order previous definition mode parameter 

extending mode system case added comparing inst alias inst case lookup value current instmap find greatest lower bound inst update instmap entry new value need ensure occur necessary order avoid getting cycle instmap 
need instmap acyclic allow safely leave occur check run time 
rule alias alias want lose aliasing information inst forward execution 
free fin init fin init bound 

fm 
nm 



mm higher order fin init bound bound 

fm 
nm 





mm reached higher order fin init higher order ground fin init higher order 
higher order 


init init fin fin fin init alias inst keys definition instantiatedness greatest lower bound aliasing new parameterised greatest lower bound operation defined terms new parameterised partial order 
example 
assume contain alias insts alias alias alias chapter 
alias tracking alias instmap updated record aliased represent inst unification variables variable functor creates aliases 
perform unification insts represent newly created alias new inst key 
record instmap maps greatest lower bound insts abstractly unifying return alias result unification 
unification live variables longer need worry making sure result ground shared 
delay checking places may need remove definite aliases ends disjuncts ends arms predicate body 
definition inst unification alias tracking unify inst alias new inst key clobbered unify expand expand definition inst functor unification alias tracking add mode parameter unify inst functor pass unify inst 
unify inst functor 


bound unique 
expand reached 
reached expand bound 

unify inst bound 
merging interested definite aliases merging need ensure keep aliasing information common throw away information instmap 
throwing away aliasing information may need unique insts shared may need generate mode errors inst partially instantiated 
definition inst merge aliasing merge insts predicate merge insts defined facing page 
predicate takes insts insts particular variable branches 
extending mode system branched goal 
pass branch liveness variable 
outputs merged inst instmap contains mappings inst keys needed describe sets inst keys 
contains inst keys needed remove merge 
likewise contains inst keys needed remove 
collect inst keys merging insts variable 
adjust inst key mappings final instmap ensure uses keys shared 
variable insts merging live safely expand insts merge upper bound 
ensure catch situations di erent arms disjunction disagree variable instantiated throws away information aliasing variable 
alias information needed live variables live variables call auxiliary predicate merge insts job preserve information 
merge insts insts alias insts obtain corresponding inst keys appropriate 
lookup insts corresponding inst keys call merge insts recursively insts 
create new inst key resulting inst 
previously left structure inst keys unspecified 
creating new inst key need able associate back inst keys pair containing inst keys 
add instmap return alias resulting inst 
insts bound auxiliary predicate merge bound insts defined page 
expand insts inst keys contain shared 
inst keys shared recorded resulting inst upper bound expanded insts 
merge insts expand expand merge insts merge insts alias alias merge insts alias bound bound merge bound insts bound expand shared expand shared inst keys inst keys merging insts alias tracking actual implementation inst keys represented integers separate data structure recording mapping 
separate data structure discarded finished merging 
chapter 
alias tracking predicate merge bound insts takes sets bound inst functors merges 
splits sets parts 
set contains corresponding pairs functors arguments functors occur sets contain functors arguments functors occur respectively 
pass merge bound insts merges pair functors arguments returns result inst key occurs retained final instmap need shared 
know variable bound function symbol containing branch function symbol variable bound function symbol containing know definitely aliased 
need record branch came case discover need shared replace inst insert new instmap 
inst key dummy inst key guaranteed occur instmap 
inst key substituted record came second branch 
operations done calls add aliases 
combine results merge bound insts add aliases obtain predicate merge bound insts passes corresponding pair insts functor arguments merge insts merged 
combines results produce predicate add aliases takes function set bound insts instmap calls auxiliary predicate add aliases inst combines results produce predicate add aliases takes function renaming inst keys inst instmap alias inst alias obtain inst key recursively call add aliases inst obtain obtain new inst key applying add obtain return alias 
defined merge insts show merge modes 
involves main steps call merge insts corresponding pair insts final modes 
second step additional information obtained merging insts determine inst keys need shared 
need know variables live pass liveness set parameter mode merge operator 
definition mode merge aliasing operation defined page merges modes liveness set produce mode initial identical initial instmap instmap 
final unreachable final instmap result final instmap 
merge insts variable final combine results merges produce sets instmap contains mapping inst new inst keys created merges 
obtain set inst keys dom need shared 
recall inst key dom pair domm fin domm fin 
occurs inst keys dom shared 
ensure insts corresponding inst keys partially 
extending mode system merge bound insts 





merge bound insts add aliases 
add aliases 
merge bound insts 




merge insts 

add aliases 

fm 
nm 

add aliases 

fm 
nm add aliases alias add aliases alias bound add aliases bound merging bound insts alias tracking chapter 
alias tracking instantiated 
obtain set set inst keys referred set expand shared function corresponding insts shared 
final stage add computed variable inst mappings remove singleton inst key 
init init init fin unreachable fin fin fin unreachable fin fin 
vn fin var domm fin 
vn fin var domm fin 
merge insts fin fin dom dom dom dom dom expand unique inst keys expand shared alias fin remove singleton inst keys 
vn merging modes alias tracking example 
assume code shown example page instmap start disjunction ground unique disjunct instmap alias alias ground unique alias alias ground unique second disjunct instmap alias ground unique alias alias alias ground unique assuming apply mode merge operator 
implementing partially instantiated data structures alias ground shared ground shared alias ground shared final instmap records definitely aliased inst key 
alias information discarded insts ground shared 
mode rules mode rules compound goals remain unchanged page disj ite rules need pass liveness set 
updated mode rules atomic goals shown page 
modified pass mode parameters unify inst unify inst functor remove aliases doing comparisons 
updated mode rule procedure shown page 
mode procedure allowed contain alias insts 
expand alias insts final instmap goal comparing final instmap procedure 
stages 
expand insts non live variables remove singleton inst keys 
insts expanded expand shared function cause insts corresponding remaining inst keys shared fail insts partially instantiated 
implementing partially instantiated data structures seen modify mode system track aliases allows limited partially instantiated data structures precise mode information opposed loss precision inherent inst 
order implement partially instantiated data structures mercury code generator requires extra information free insts implement change mode system 
corresponding change machine necessary 
describe changes 
annotating free insts mercury machine level variable instantiation expansion aliases bound represented word containing value variable inst free represented word 
free variable inside partially instantiated data structure need represent location value go variable instantiated 
need di erentiate types free free aliased indicate free variable aliased live data structure free aliased indicate free variable aliased exactly live data structure 
new definition inst shown page 
variable inst free aliased treated previously treated variables inst free 
variable inst free aliased represented word contains address value placed variable instantiated 
chapter 
alias tracking unify vv unify inst init init goal unify vf 
vn init init 
init 
vn unify inst functor 

vn goal 
vn unify unify inst init higher order unique uq 

expand init init unique init shared mm 
domm uq 


init init fin fin init fin uq clobbered uniqueness fin uq goal goal call 


expand init init init fin init mn goal 
vn ho call expand init init higher order 


expand init init init fin init mn goal 
vn mode rules atomic goals alias tracking 
implementing partially instantiated data structures proc goal init init clobbered uniqueness fin fin expand fin fin remove singleton inst keys expand shared fin domm domm uq proc mode rule procedure alias tracking inst key instantiation state inst free bound higher order alias alias count aliased aliased instantiation states annotations free mode analysis uninstantiated parts partially instantiated data structure inst free aliased free aliased 
places mode analysis free aliased free aliased insts treated 
exception unification free variables 
mode error attempt unify live free aliased variables variables insts free aliased free aliased may unified unification inst free aliased 
allow unification variables insts free aliased 
require free aliased variable record address memory location filled variable instantiated 
implemented require significant overhead 
long free aliased variable aliased slot data structure leave slot store address variable slot stack frame 
binding variable code generator preserve address stack frame avoiding need trailing 
allow aliases slots data structures need record set addresses slots data structures terminated pointer chains wam circular pointer chains parma 
case instantiating aliased variable overwrite addresses data structures requiring instantiation 
require place program backtracking may occur check needed 
overhead required parts program aliases 
program uses aliases heavily chapter 
alias tracking overhead outweigh benefits gained 
parma scheme implemented mercury hal project conjunction imprecise inst provide prolog style logical variables 
hal uses trail types constraint solvers extra cost herbrand constraints 
achieved success reducing size trail cost trailing scheme 
extending mercury machine modify mercury machine argument procedure initial inst free aliased required location passed procedure 
code generator reserves input register argument places address memory location filled register calling procedure 
variable inst free aliased instantiated code generator emits code place value memory location representation free aliased variable points 
tail call optimisation look partially instantiated data structures enable optimisation transform calls tail calls 
tail call call action executed execution path body procedure 
tail calls allow saving stack usage allow stack space caller re callee 
tail call implemented unconditional jump 
case tail call recursive call means recursive procedure implemented simple loop possibly lowlevel transformations optimise away decrements increments stack pointer 
tail calls important allow recursive procedures sccs execute constant stack space requiring space proportional depth recursion 
improve execution time avoiding cost setting tearing stack frames importantly modern architectures improving locality avoiding cache misses 
predicate tail recursive prolog tail recursive mercury reason usually standard mercury implementation returns output arguments call registers 
output argument needs placed memory done returning call 
example consider recursive clause append append xs ys zs xs xs zs zs append xs ys zs 
wam implementations prolog call optimisation ensure clause tail recursive 
mercury recursive call append return zs register needs copied correct memory location second argument nethercote mycroft show cache misses major performance bottle neck lazy functional language haskell running modern architecture 
believe similar results mercury cache related ects main cause performance improvements due tail call 

implementing partially instantiated data structures cons cell 
support partially instantiated data structures situation worse mode checker delay entire construction unification zs zs recursive call 
somogyi briefly outlines solution problems reorder code construction unifications come call create new version called predicate returns relevant arguments memory pass addresses place results 
taken outline basis new optimisation pass mercury compiler call call modulo constructors optimisation lcmc 
optimisation relies changes mode system machine described earlier chapter 
optimisation similar aim debray describes algorithm deciding return output values registers return memory 
technique requires profiling information number times procedure called call sites potentially supplied mercury deep profiler 
algorithm require significant extensions handle separate compilation 
implementation lcmc probably captures benefit implementation complexity 
lcmc optimisation involves simple transformation move call procedure body 
back compiler generate tail call call 
lcmc pass occurs passes may increase chances able apply lcmc 
include simplification inlining accumulator 
stage mode analysis selected initial scheduling order procedure avoids construction partially instantiated terms 
lcmc traverses goal procedure turn 
procedure determined candidate lcmc path goal contains final conjunction call conjunction followed construction unifications 
algorithm described formally page 
conjunctions lcmc applied conjunction re ordered constructions appear call 
required mode called predicate di erent previously determined mode 
need find procedure predicate output arguments appear right hand side construction unifications pass 
arguments initial inst free aliased free aliased 
procedure exist create run lcmc transformation 
called predicate calling predicate result tail recursive procedure 
running lcmc procedure run subset mode checker new body goal 
subset re ordering believes existing mode annotations calls recomputes annotations unifications compound goals process checks new definition mode correct 
transformation created unification free aliased variables manifest mode error abandon transformation procedure 
term comes similar idea described wadler calls tail recursion modulo cons 
chapter 
alias tracking procedure lcmc input goal procedure transformed output transformed goal 
gn lcmc 
lcmc gn lcmc lcmc 
gn 

init free 

gn 
gn lcmc gn lcmc transformation look transformation applied procedure append refer mode predicate append 
code procedure lcmc shown facing page 
comments show change instantiation state variables sub goal uniqueness annotations omitted relevant lcmc 
lcmc discovers second arm disjunction construction zs moved recursive call 
zs inst free aliased call lcmc tries find mode append matches inst 
required mode created mode copying mode changing initial inst zs 
code mode stage shown page 
lcmc run new procedure mode 
re orders call construction finds appropriate mode append exists mode 
code mode looks mode mode third argument free aliased ground free aliased ground 
code generated compiler tail recursive mode append shown page 
code readable shortening label names removing type casts 
arguments xs ys zs passed registers respectively 
creating new stack frame storing return address code checks xs empty list branches 
implementing partially instantiated data structures mode append 
append xs ys zs initial insts xs ground ys ground zs free aliased xs zs ys zs ground xs xs ground xs ground append xs ys zs call mode append zs ground zs bound ground ground 
zs ground mode append transformation mode append 
append xs ys zs initial insts xs ground ys ground zs free aliased xs zs ys zs ground xs xs ground xs ground zs bound ground alias ik zs alias ik ik free aliased append xs ys zs call mode append ik ground 
zs ground mode append transformation label append falls code recursive case 
allocates new word cell heap places pointer cell tagged tag value cons represents value zs 
places value zs caller expects memory location address caller passed 
fills word new cell puts address second eventually copied tell recursive call put value zs 
extracting xs second field cons cell xs putting completes setup recursive call ys 
recursive call unconditional jump start procedure 
code base case implements assignment zs ys copying ys caller expects zs 
low level optimisation passes compiler improve code eliminating unnecessary jumps making cient registers removing stack frame allocation altogether append call predicates necessary save stack 
lcmc optimisation guarantee tail call procedure transforms 
chapter 
alias tracking define entry append incr sp push define label append goto label append tag incr hp field field field field field goto label append define label append decr sp pop proceed generated code mode append transformation transformed call tail call returns exactly sequence outputs exactly locations containing procedure 
call followed code places output arguments containing procedure proper places 
cases optimisation may useful may allow tail call new pass procedure reducing number output registers procedure 
seen append example call mode mode tail call mode needs save value zs stack call place register returns 
recursive call mode tail recursive place zs required location memory soon constructed needs done recursive call 
compiler runs lcmc recursively new procedure point created check optimisation going give tail call new procedure abandon optimisation procedure 
ect optimisation depend call recursive call call recursive call situations optimisation usefully applied 
ross overton somogyi show optimisation combined accumulator optimisation information associativity predicates allow opportunities tail recursion optimisation 
table page benchmark results showing optimisations combine synergistically improve execution times programs 
benchmarked set small programs pc mhz intel pentium iii cpu kb cache mb memory running linux 
benchmark programs process lists tested input list 
implementing partially instantiated data structures integers 
executions repeated times eliminate uncertainties involved measuring small time intervals 
results form normalised run times raw data available mercury web site 
table shows sets results garbage collection 
set columns show performance optimisations just lcmc just accumulator 
cases optimisations mercury compiler turned exception unused argument elimination unused argument elimination relating call back promise call di cult 
intend move unused argument elimination tail recursion optimisations requires modifying implementation accept modes produced lcmc 
gc gc lcmc acc lcmc acc append nrev mirror table normalised benchmark results tail call optimisation append benchmark append predicate seen previous examples 
predicate sums list integers 
benchmarks achieve speed increase relevant optimisation enabled 
nave reverse nrev reverses list nave ine cient algorithm involving repeated calls append 
benefits optimisations 
lcmc call append tail recursive improves performance caller nrev 
accumulator allows speed increase reducing big complexity algorithm ectively turning reverse making nrev predicate tail recursive 
turning lcmc turning accumulator slows code slightly accumulator version nrev argument append list length fixed overhead lcmc transformation compensated lcmc making append tail recursive 
predicate traversal sums list integers returns list element doubled case don get significant speedups optimisations turned 
predicates expected produced deforestation 
predicate mirror requires optimisations turned tail recursive 
mirror benefit lcmc append 
moment mercury uses boehm conservative garbage collector 
collector requires function call memory allocation gc case mercury allocates memory simply incrementing heap pointer 
boehm collector lacks provision ciently recovering memory garbage collection di erent repetitions test 
memory allocation accounts bigger fraction runtime program gc gc get smaller relative speedups gc www mercury cs mu oz au chapter 
alias tracking gc optimisations eliminate memory allocations 
lcmc eliminate memory allocations 
accumulator eliminate memory allocations reduces big complexity predicate allocates memory iteration 
nrev mirror predicates benefit ect 
related early mode analysis attempt alias tracking 
terms containing aliased free variables mapped 
debray warren introduced simple alias analysis operated locally predicate 
predicate annotated alias bit indicate create aliasing arguments 
inexpensive way improving status quo time need global analysis approach provide kind precision require prescriptive mode system 
analysis possible aliases non ground variables studied extensively 
includes set sharing domain sharing jacobs codish shown isomorphic domain pos pair sharing domains sndergaard stuckey 
somewhat di erent aims 
generally designed descriptive system provide information optimisations occur check reduction possible definite aliases required 
analyses deal non ground aliasing need know particularly uniqueness analysis aliasing ground terms 
suggested stuckey adapted analysis ground terms adding extra variable functor term 
require definite aliases uniqueness analysis interesting try approach fact believe way add uniqueness analysis mode analysis system describe chapter 
mazur mentioned chapter looks possible aliasing ground terms order determine memory occupied term re 
system operate individual modules programs automatically infer check uniqueness annotations modes 
deal partially instantiated modes 
approach alias tracking taken suggested henderson 
henderson provide detailed description operations algorithms required analysis 
particular mention merge insts containing aliases branched goal 
mode system described descriptive mode system free system means possibly free tolerate imprecision 
personal communication author 

limitations possible limitations possible alias tracking system enhances mercury mode system allowing programs admitted mode correct 
system main limitations expressive want mode system quite ine cient 
discuss limitations detail 
limitations expressiveness alias tracking system designed dealing aliasing variables procedure 
track aliases escape single procedure live variables aliased procedure provided mechanism tracking alias procedure succeeds 
dealing unique modes serious simply insts variables shared 
variables partially instantiated report mode error 
programs handle limitation 
example known logic programming benchmark program shown 
pred list int list int 
arrange numbered 
pred list int list int list pair int int 
pair 

pred arrange list pair int int tree pair int int 
pred numbered tree pair int int int int 
program intended input output 
call traverses instantiates list skeleton length instantiates list pairs element second element aliased corresponding free variable call arrange arranges binary tree ordered element pair 
call numbered instantiates second element pair tree instantiating elements set mercury mode declarations look mode 
mode free pair ground free 
mode arrange pair ground free chapter 
alias tracking pair ground free 
mode numbered pair ground free pair ground ground 
arrange create aliases free components data structures reflected modes way mode system know eventually ground 
loss mode precision acceptable hal approach replacing occurrence free mode declarations 
allows mode system conclude final inst ground 
add promise ground checked compiler leading potential undefined behaviour run time 
type program able handle currently form predicates operate instantiate data structure 
model client server processes turn model program acts client server database access 
way modelling client server relationship synchronised streams list elements represent requests client server list elements represent corresponding responses server client 
technique suggested landin model functional languages 
problem programmer manually ensure streams remain synchronised 
get quite di cult complex program 
logic programming languages solve problem combining streams 
client request partially instantiating element list 
server carries request instantiates rest element result 
known paradigm incomplete messages example simple case kinds request reading file writing file type inst mode declarations shown page 
code called goal io client actions io server actions 
client server run routines server blocking receives request client client blocking server instantiates result 
unfortunately mode declarations quite right require entire stream requests produced client passed server 
need iterated mode segments somogyi recursive modes suggested conway chapter implemented partly due problem keeping track aliases mode analysis 
chapter look constraint approach mode analysis easier extend handle sort program 
performance limitations alias tracking system chapter requires lot book keeping adds large overhead cost mode analysis terms memory time 
cost increase analysing procedures alias tracking provides extra useful precision mode analysis 
example table facing page shows 
limitations possible type io action read string filename char char read write string filename char char write 
inst request read ground free write ground ground 
pred io client list io action 
mode io client request 
pred io server list io action 
mode server request ground 
declarations client server system streams mode analysis times common logic programming benchmark programs 
times milliseconds 
measured time repeats mode checking benchmark divided result 
tests run dell gx pc mhz intel pentium iv kb cache mb memory running linux kernel 
column labelled alias contains times mode system alias tracking extension 
column labelled alias contains times mode system alias tracking 
programs require extra precision provided alias tracking seen adding alias tracking analysis usually slows mode analysis time cent 
alias alias alias alias crypt deriv nrev poly primes qsort queens query tak table ect alias tracking mode analysis times interesting note benchmarks nrev qsort mode checker faster alias tracking 
mode checking time benchmarks dominated analysing code builds large static lists benchmarks input data 
unification form vn xn converted conjunction chapter 
alias tracking cations xn vn vn normal form nrev qsort 
mode checker calls unify inst functor unifications refer definition page turn calls unify inst argument 
case second argument functor inst alias 
means call unify inst inst simply comparing alias alias immediately having take glb complicated insts process 
sort improvement outweigh costs alias tracking extreme cases 
order improve analysis times alias tracking becket suggested alternative demand driven approach keep minimal book keeping information aliases full alias tracking analysis variable discover need need prove variable unique unable show alias tracking 
constraint approach chapter ers alternative approach alias tracking 
shall see chapter performance problems need overcome 
chapter constraint approach mode analysis limitations noted mode analysis algorithm preceding chapters complicated 
combines conceptually distinct stages mode analysis single pass 
modifications algorithm include new functionality quite di cult 
algorithm quite ine cient analysing code involving complex modes 
chapter new approach mode analysis mercury programs attempts solve problems systems previous chapters 
separate mode checking distinct stages constraint approach naturally express constraints arise mode analysis 
believe approach easier implement extensible mode analysis system mercury overcome limitations current system 
associate program variable set positions correspond nodes type graph 
key idea new mode system identify position type variable position produced goal binds part variable function symbol 
associate node type graph goal program variable occurs boolean variable indicates node graph program variable bound goal 
boolean variables describe constraints arise correct terms boolean constraints 
represent manipulate descriptions standard data structures reduced ordered binary decision diagrams robdds 
allowing constraints individual positions di erent data structures obtain precise analysis mode system chapter avoiding complications alias tracking system chapter 
section give background information rest chapter depends 
section give simplified example constraint system presenting full system section 
section show results analysis select execution order goals conjunction 
section look issues implementing system 
section give experimental results performance constraint system 
section look related 
section look chapter 
constraint approach mode analysis limitations new system possible 
background programs chapter assume unifications transformation normal form side variable appear outside unification 
unifications meet requirement influence execution program deleted 
simplicity assume negations replaced replace 
explicit existential quantification goals define scope variables assume goal annotated set variables nonlocal goal see definition 
leave discussion higher order code 
apart omission negation existential quantification goals syntax page 
subscripts primes represent program variables 
order describe variable bound algorithms need able uniquely identify subgoal predicate body 
code subgoal serve identifier piece code may appear predicate definition 
goal paths purpose 
goal path consists sequence path components represent path zero components denotes entire procedure body 
goal path conjunction goal path denotes nth conjunct 
goal path disjunction goal path denotes nth disjunct 
goal path goal path denotes condition denotes part denotes part 
definition parent goal path goal path function parent maps goal path parent 
definition set variables occur goal set variables nonlocal goal occur inside outside convenience define set goals 
goal path uniquely identifies goal predicate body apply operations goals goal paths 
deterministic regular tree grammars order able express di erent useful modes program variable able talk individual parts terms program variable able take values 
finite manner regular trees expressed tree grammars 
empty disjunction goal fails empty conjunction succeeds 

background tree signature ground term set defined section 
tree grammar signature non terminal set nt finite sequence production rules form nt form 
xn 
xn nt tree grammar deterministic regular nt rule form 
xn 
brevity shall write tree grammars compressed form 
shorthand sequence production rules 
types recall types mercury polymorphic hindley milner types 
type expressions types terms language type type type type constructors variables type type parameters 
type constructor type definition 
definition type definition form type 
mk 

distinct type parameters 
tree distinct tree constructor arity pairs 
mk type expressions involving parameters 
occurrences right hand side definition form 
vn say type definition regular 
clearly view type definition simply sequence production rules signature tree non terminal set type type 
order avoid type expressions depend infinite number types restrict type definitions regular 
regularity ensures type grammar defined finite 
associate non parameter type expression production rules define topmost symbol type 
type expression form 
type definition form definition 
define rules production rules 
vn 


vn 
mk 
vn substitutes type define rules empty sequence 
extend notation associate tree grammar type expression 
grammar sequence production rules recursively defined rules grammar grammar mk operation concatenates sequences production rules removing second occurrences duplicate production rules 
chapter 
constraint approach mode analysis call nonterminal set production rules position describe positions terms position root term subterms 
call positions nodes correspond nodes type trees 
example 
consider type definitions type list list 
type abc grammar type list abc list abc abc list abc abc nonterminals positions grammar list abc abc correspond nodes page 
mode inference checking takes place type checking assume know type variable appearing program 
instantiations modes insts defined tree grammars 
di erences inst associated predicate involves instantiation parameters polymorphic modes possible extension seen chapter base insts free ground representing completely variables completely bound terms 
instantiation expressions terms inst inst 
definition instantiation definition inst form inst bound mk 

distinct instantiation parameters 
tree distinct function symbols 
mk instantiation expressions inst free ground inst 
associate set production rules rules instantiation expression just type expressions 
base instantiations define rules free rules ground 
definition goal changes instantiation state position free bound said produce bind position goal requires initial instantiation state position bound said consume position 
simplified example motivation constraint mode analysis system avoid problems current system 
order break mode analysis problem phases 
phase determines subgoals produce variables second uses information 
simplified example determine execution order procedure 
focus task return second section 
ease explanation show simplified form approach 
simplified form requires variables instantiated instantiation states recognises free ground requires variables eventually reach ground state 
avoids complexities arise di erent parts variables bound di erent times parts left unbound 
address complexities give full algorithm section 
constraint generation algorithm associates constraint variables program variable 
program variable associate family constraint variables form true produced goal path predicate body 
explain algorithm append 
code shown transformation compiler form 
form form additional restriction variable appears argument functor 
compiler adding extra unifications necessary 
pred append list list list 
append ah ch ct ah ch append ct 
examine body generate constraints 
body disjunction constraints get simply specify variable nonlocal disjunction disjunction produces variable disjuncts produce variable disjunction produce variable disjunct may produce variable 
append expressed constraints process disjuncts 
disjuncts conjunctions 
processing conjunction algorithm considers variable occurring conjunction potential producer 
variable nonlocal conjunction may produced inside outside conjunction variable shared conjuncts chapter 
constraint approach mode analysis may produced conjuncts 
algorithm generates constraints sure variable exactly producer 
variable local constraints say exactly conjunct produce variable 
variable nonlocal constraints say conjunct may produce variable 
disjunct variables shared conjuncts constraints get ones say nonlocal produced conjunction produced conjunct appears conjunct disjunct yields nontrivial constraints 
intuitively lack constraints goal reflects fact produce test value 
second conjunct disjunct yields constraint says goal produce second disjunct generate constraints analogous conjunct nonlocal variables 
disjunct contains shared local variables ah ch ct appears conjuncts 
constraints variables state variables produced exactly conjuncts appears 
ah ah ch ch ct ct conjunct second disjunct shows handle unifications form yn 
key understanding behaviour algorithm case knowing trying decide alternatives unification takes input produces takes input produces contrary people experience real programs unifications form ways bindings produce subset unification way requires input possible producers outside unification 
transform program form sure unification form fresh variables right hand side 
producer replaced right hand side unification new variable addition new unification convert unifications take input unifications take input produce variables right hand side 
variables right hand side appear variables unbound unification produce create nonground term 
simplified approach consider nonground terms cases generates extra constraint requires input goal 

simplified example case ah ah appear get constraints ah ah says goal produces variables right hand side produces 
conjunction second constraint says goal produce variable left hand side variables right hand side 
constraints get ch ct analogous ch ct ch equation ah ch acts just equation disjunct generating ah ch conjunct call case recursive call 
assume calls predicate strongly connected component scc static call graph caller mode 
currently inferring mode know exactly constraint variables need 
means call produces ith argument predicate body produces ith argument 
leads constraint argument position ct concludes set constraints generated algorithm append 
inference checking constraints generate predicate infer modes 
projecting head variables constraint set just built di erent solutions append modes append append append append append modes append append call principal modes 
implied modes existence implied existence principal modes changing mode argument job predicate strictly easier 
rest chapter assume predicate set assumption somewhat restricts set allowable moded programs 
unreasonable restriction practice 
come cases typical mercury programs want recursive call di erent mode 
restriction overcome simply giving set mode declarations predicate scc see section 
chapter 
constraint approach mode analysis modes downward closed means contains mode pm contains modes implied pm 
practice compiler generates code mode declared principal mode modes caller renaming variables inserting extra unifications 
synthesis form equivalent replacing append append 
inferring modes filter generated implied modes associate principal modes predicate 
generate separate code mode predicate reduce sizes executables 
checking declared modes check declared modes principal implied mode 
declared mode pass test incorrect generate error message 
solution implicitly assigns modes primitive goals body specifying variable produced 
example solution assigns true constraint variables ah ch ct false corresponds mode append shows ah deconstruction uses fields define ah ch ct construction binds new heap cell 
cases values constraint variables head variables uniquely determine values constraint variables 
set value assignments constraint variables body consistent value assignment constraint variables head 
cases compiler choose assignment prefers 
example assignments di er causes variable produced unification second causes produced predicate call called predicate happens nondeterministic able succeed mode called compiler prefer assignment lead cient code 
full mode inference expanded grammars consider problem handling programs di erent parts variable may instantiated di erent goals 
need ensure distinct positions variable may di erent instantiation behaviour way referring separately 
need expand type grammar associated variable 
empty grammar original code predicate expressed normal form 
modify grammar predicate body stage mode analysis 
unification 
yn appears definition predicate grammar rule functor add rule 
yn occurs left hand side grammar rule head clause replace occurrence program add unification grammar rule 
replace unification conjunction 

yn 
full mode inference process may add unifications form occurs 
unifications safely removed 
processing unifications add copy rules rules grammar variable type 
example 
form usual source code append variant ah ah ct append ct second clause algorithm replaces ah ch ct ah ch append ct yielding form shown section 
expanded grammar computed append ah ae ch ct ct ce ct note grammar rules unrolled rules allows refer position ah representing variable ah head element separately elements represented position ae 
necessary nonterminals grammar constitute set positions create constraint variables generate constraints predicate body nonterminal position node interchangeably 
note nonterminal denoting top level functor variable variables nonterminals denoting non top level functors 
note nonterminal fulfil functions variable strictly part 
example nonterminal ah stands variable ah element list bound variable variables unified computation paths nonterminal 
predicate needs boolean variables position 
true position produced outside predicate 
true position produced inside predicate 
true position produced inside outside predicate 
note definition tuple 
xn head variables formal parameters predicate chapter 
constraint approach mode analysis definition expanded grammar position define immediate descendants 
yn set positions reachable 
yn generating constraints variables type need able refer positions variables correspond ah ch denote corresponding positions inside notion correspondence allows variables expanded di erent extents expanded grammar 
example descendant nonterminals append grammar type 
unification nonterminal correspond definition expanded grammar positions define set pairs corresponding nodes lhs tree 
yn 
wn lhs lhs 
lhs lhs 
wn lhs lhs 
convenience define pair tuples 
xn 
yn definition expanded grammar rule 
yn say parent node nodes 
yn 
full mode inference mode inference constraints ensure variable occurs predicate renaming necessary 
construct expanded grammar program module compiled 
group predicates module strongly connected components sccs process sccs bottom creating function scc scc 
represents boolean constraints generate predicates scc 
remainder section defines scc constraint function scc scc conjunction constraint functions pred generate predicates scc scc pred 
xn constraint function infer predicate constraint function scc inf scc inf may stricter pred scc may constrained members scc 
predicates defined modules derive inf mode declarations mechanism describe section 
pred conjunction functions struct structural constraints relating variables goal constraints predicate body goal pred 
xn struct 
xn goal define struct goal 
structural constraints boolean formula proposition program variable bound call 
boolean formula proposition bound return 
boolean formula proposition bound predicate 
constraints relate relationships variables relationships di erent times 
node reachable predicate argument variables bound call 
node bound return bound call produced predicate body 
node may bound call produced predicate body 
version mode system require node bound call parent node bound call 
similarly node bound return parent node bound return 
wanted support particular paradigm communication incomplete messages see section need relax constraint 
struct chapter 
constraint approach mode analysis example 
append structural constraints ah ah ah ah ah ae ae ae ae ae ch ch ch ch ch ct ct ct ct ct ce ce ce ce ce ah ah ae ae ch ch ct ct ce ct ce ct goal constraints boolean variable path contains program variable 
variable represents proposition position produced goal referred path constraints generate goal fall categories general constraints apply goal types gen constraints specific goal type goal 
complete set constraints goal comp conjunction sets 
general constraints components 
local says node reachable variable local goal bound return produced goal 
second ext says node reachable variable external goal occur produced 
note node reachable variable local goal 
conjunction definition ext variables predicate occur variable occur parent goal parent goal constraints won mention point creating constraint variables comp gen goal gen local ext local ext parent compound goals constraints generate kind compound goal conjunction disjunction shown page 
case goal type specific constraints conjoined complete set constraints subgoals 
conjunctive goal position produced conjunct 
disjunctive goal node produced disjunct produced disjunct 

full mode inference goal node produced produced condition branch branch 
node may produced condition branch ectively conjoined 
nodes reachable variables nonlocal produced condition negation condition ectively conjoined branch 
node reachable nonlocal variable produced branch produced branch vice versa 
branches ectively 
goal 
gn comp conj 
gn goal 
gn comp disj 
gn goal comp comp comp ite conj 
gn cn disj 
gn ite constraints conjunctions disjunctions atomic goals consider kinds atomic goals consider higher order calls unifications higher order terms section 
unifications form 
unifications form 
yn 
yn 
calls form 
yn 
unification form may produce pair corresponding nodes 
mercury currently allow aliases exist unbound nodes node reachable variable involved unification produced 
true free aliased inst discussed section hal relaxed restriction 
chapter 
constraint approach mode analysis unification goal path constraint goal goal scheduling phase require node produced aliased node 
restrictions disallow uses partially instantiated data structures require sort chains just single location value place implementation 
discussed chapter possible scheme 
remove restriction mode system simply removing constraints 
example 
unification append goal path constraints generated ch ch ct ct ce ce unification form 
yn path produce arguments 
yn transformation normal form ensures var functor unifications responsible producing arguments functor 
node produced 
constraint goal 
yn note member 
yn transformation done start section 
example 
unification ah append goal path constraints generated ah ae mode append ah ae input procedure unification doesn bind nodes 
mode ae bound recursive call ah bound unification ch leaving node bound unification 
call 
yn constrain nodes reachable arguments call 
predicates current scc allow recursive calls mode caller 
constraint goal 
yn 
full mode inference part ensures call produces position position produced predicate scc 
second part ensures call variable produced required bound call call 
true true mistakenly call site produce example 
recursive call append ct goal path append constraints generated argument ah ae ah ae ae ae ae ae calls predicates lower sccs constraints similar obtain inf constraint called predicate existentially quantify head variables possible call predicate di erent modes di erent places current scc goal 
yn 
inf mode declaration constraints predicate modes declared mode analysis system check declarations inferred mode information 
involves generating set constraints mode declarations ensuring consistent constraints generated predicate body 
declaration constraint decls predicate set mode declarations disjunction constraints decl mode declaration decls decl constraint decl mode declaration 
xn conjunction constraints arg argument mode corresponding head variable decl 
xn arg struct 
xn 
xn structural constraints determine variables constraint arg argument mode head variable conjunction constraint init initial instantiation state constraint chapter 
constraint approach mode analysis fin final instantiation state arg init fin constraint init initial instantiation state head variable init free init ground init rules init init yn constraint fin final instantiation state head variable isomorphic init di ering constrains variables form fin free fin ground fin rules fin fin yn mode checking simply determining declared modes strong inferred modes 
declared mode predicate check implication decl inf holds 
doesn declared mode incorrect 
declared modes predicate short circuit calculation sccs decls mode inference predicate calls allows programmers get restriction calls predicate scc caller mode simply giving mode declaration called predicate 
example 
mode definition mode free ground 
mode declaration append gives decl ignoring variables ah ae ch ct ce ah ae ch ct ce 
full mode inference show decl inf append 
constraints higher order code recall construction higher order term mercury syntax unification form 
yn 
yn lambda quantified arguments 
modes arguments lambda body goal 
mercury requires argument modes declared constructing higher order terms 
analyse construction things 
analyse unification 
analyse lambda body goal 
record higher order argument modes mode check calls higherorder term 
unification goal path node produced unification 
nodes reachable variables non local lambda body goal produced lambda body goal 
goal constraint unification goal 
yn analysing lambda body goal treat predicate analyse described 
modes higher order term mode declaration see section 
ensure non local variables produced goal 
constraint body goal 
yn decl 
yn struct 
yn goal analysing higher order calls mode information associated higher order term obtain mode declaration predicate calling 
higher order term constructed higher order unification current predicate exactly mode declaration associated 
returned predicate may multiple mode declarations mode predicate returned predicate higher order argument mode declarations 
assume collected information higher order terms variable bound higher order term 
yn 
yn set mode declarations 
yn associated higher order term 
chapter 
constraint approach mode analysis goal constraint higher order call 

require produced 
constraints higher order call resemble constraints call predicate mode declarations 
goal 

decls selecting procedures execution order generated constraints scc solve constraints 
constraints solution position consumers producer report mode error 
constraints solutions solution gives mode predicate scc set solutions defines set modes predicate 
need find feasible execution order mode predicate scc 
algorithm finding feasible execution orders takes solution input 
mode predicate corresponds solutions su cient feasible ordering 
main problem finding feasible schedule mode analyser code generator distinct views means produce position variable 
grammar generate append example nonterminal ah represents value variable ah value element variable forward mode append ah true mode analyser considers ah produced caller execution enters append 
far code generator concerned ah doesn really exist unification ah 
cater divergent views separate notion variable produced notion variable visible 
definition expanded grammar assignment boolean values constraint variables predicate constraint inf true model inf 
write inf 
definition model inf define set nodes produced goal path produced definition model inf define set nodes consumed goal goal path formula shown facing page 
unification form say node side equation consumed corresponding node side produced 
due symmetric nature relationship correspond consumed consumed produced produced 
possible pair corresponding nodes produced consumed unification 
mean things 
subterms node bound unification test equality subterms free create alias 
note unification produces top level nodes call assignment unification 

selecting procedures execution order produced produced 
yn produced 
yn 
yn inf 
yn 
yn decls 
gn produced 
gn produced produced calculating nodes consumed positions unification form 
yn say node consumed produced nodes consumed 
reason half rule grammar nonterminal subterm unification merely creates aliases corresponding subterms nonterminals produced unification produced produced 
note unification produces call construction unification consumes call deconstruction unification 
higher order unification node consumed body goal nodes reachable lambda quantified variables consumed unification goal 
call predicate know nodes actual parameters call model predicate analysing says produced call 
need find model constraints causes corresponding nodes actual parameters output 
stage analysis succeeded know model exists 
consumed nodes call nodes actual parameters correspond nodes formal parameters requires input 
higher order call 
yn set consumed nodes similar set consumed nodes predicate call mode information higher order term predicate 
node consumed require bound higher order term produced higher order call 
chapter 
constraint approach mode analysis compound goals consumed nodes union consumed nodes subgoals minus nodes produced compound goal 
example 
mode append produced consumed sets conjuncts path goal produced consumed ch ct ce ah ch ct ah ch ch ah append ct ct ce ae disjunct produces position consumes 
ordering algorithm required node produced consumed find order acceptable 
hand code generator example emit code recursive call needs know variables ah stored bound 
need concept visibility 
definition variable visible goal path variable head variable appeared predicate body left functions visible need visible defined page respectively determine goal variable visible requires visible 
note visibility applied variables nodes 
example 
mode append visible need visible sets conjuncts path goal visible need visible ah ah ch ct ch ct ah ch ch ah append ct ct algorithm needs find conjunction body ordering conjuncts producer node comes consumers variable visible point needs visible 
traversing predicate body top 
conjunction construct directed graph nodes conjuncts 
initial graph edge produces node consumes 
graph cyclic mode ordering fails 
isn try add edges keeping graph acyclic 
sort variables need visible conjunction visible conjunction classes clear conjunct 
selecting procedures execution order visible atomic visible 
gn visible 
gn visible visible visible need visible atomic need visible visible 
gn need visible 
gn pc need visible pc pc visible calculating visible need visible visible isn 
variable falls class visible conjunct conjunct visible producer top level node 
forward mode append variables fall class variable visible conjunct ch need visible conjunct conjunction 
variables add edge conjunct variable visible conjuncts need visible 
graph acyclic start searching space mappings map variable second class conjunct variable visible looking map results acyclic graph add links selected visible conjunct variable corresponding need visible conjuncts 
happen conjuncts need variable visible goals conjunction visible 
variable visible goal left conjunction conjunction encloses fine 
isn ordering enclosing conjunction failed conjunct variable visible conjunction needs visible 
mapping yields acyclic graph procedure mode error 
mappings algorithm general choices pick acyclic graph pick order conjuncts consistent graph 
nodes forward mode append consumes input predicate chapter 
constraint approach mode analysis ordering constraints producers consumers 
disjunct visibility constraints order 
second disjunct visibility requirements dictate ah occur ah ch append ct ah visible required 
leaves compiler graph ah ch ct ah ch append ct graph completely fix order conjuncts 
parallel implementation may choose execute conjuncts parallel coroutining implementation may choose interleave execution case worthwhile 
implementation may choose schedule recursive call ensure tail recursion 
chapter needed program transformation separate mode analysis introduce tail recursion predicates 
example 
consider predicate defined pred int int int 
mode det mode constraints satisfiable model variable produced equation occurs left 
initial graph conjunction graph possible graphs cyclic procedure mode error 
implementation issues analysis implemented melbourne mercury compiler 
represent boolean constraints reduced ordered binary decision diagrams robdds implementation shown robdds provide cient representation logic program analyses boolean domains 
robdds directed acyclic graphs common subexpressions merged 
provide cient canonical representation boolean functions 
worst case size robdd exponential number variables 
practice care worst case behaviour usually avoided 
number techniques keep robdds small cient possible 
reducing number variables ective ways reducing size robdd avoid putting unrelated constraints robdd 
analysing program single robdd separate robdd scc predicates 
analyse sccs bottom mode information lower sccs available analysing higher sccs 
predicates 
implementation issues mode declarations analysed separately sccs 
predicates analysed sccs analysed 
inferring modes scc predicates mode declarations 
time get analysing predicates mode declarations mode information need predicates call 
way reduce number variables robdd size note analysis certain pairs variables constrained equivalent 
disjunction path containing disjunct path dn applies 
assume 
constraint obviously applies non local variables 
local variables slightly stronger constraints previously position local variable may bound condition branch branch 
allow add constraint note due mercury quantification rules variable local local branch occur branch 
variable local branch obviously holds 
occur branch extra constraint added occur constraints 
equivalence constraints occur positions disjunctions reduce number constraint variables variable side equivalence 
create constraint dn 
restriction variable ordering trade size robdd sensitive ordering variables chosen 
example boolean function 
yn variable ordering xn yn represented robdd nodes change ordering xn yn robdd requires nodes 
go robdd size linear number variables size exponential number variables just changing ordering 
practical try compute optimal ordering variables finding optimal ordering np complete problem bit care intuition certain orderings bad come heuristic ordering 
intuition variables closely related close variable ordering 
example variables closely related placing close variable ordering produces smaller robdd 
important operation reducing size robdd remove existential quantification boolean function intermediate variables longer needed 
chapter 
constraint approach mode analysis operation known restriction robdd 
describes algorithms doing general purpose algorithm restrict removing single variable restrict threshold removing variables greater equal variable variable ordering 
function restrict threshold cient restrict want choose variable order allow possible 
choosing variable ordering involves balancing considerations 
ordering allows restrict threshold need restriction secondarily attempts keep related variables close 
variables needed analysis lowest numbers extra variables easily restricted away analysis 
variables need nodes reachable arguments predicate refer interface variables path unification call goal nodes reachable variables goal refer leaf variables 
starting argument nodes visit reachable node instantiation grammar numbering interface variables node order 
variables node constrained number consecutively 
traverse body predicate assign numbers leaf variables 
analysis analysing goal path constraint variables need keep finished goal 
constraint variables nodes reachable program variables occurring goal 
assign numbers variables analyse goal recursively sub goals restrict threshold remove intermediates longer needed 
order adding constraints order constraints added significant impact size intermediate robdds 
general want generate stronger constraints weaker ones 
predicate mode declarations generate constraints corresponding 
generates final solution set interface variables rest analysis ectively reduced just checking constraints satisfied working exactly node produced 
adding mode declaration constraints particularly ective mode declaration predicate common occurrence typical mercury programs completely constrains interface variables 
note node known true mode declaration immediately know goal path false node input predicate produced predicate 
variables constrained false immediately adding mode declaration constraints 
predicate body generate constraints bottom starting call unify goals 
helps keep size intermediate robdds smaller goals usually involve fairly strong constraints small number variables disjunctions conjunctions require generating relatively weak constraints large number variables 
exception goal constraints condition may produce nodes non local variables 
constraints strong 
implementation issues beneficial generate generating constraints enclosed goal 
removing information robdds robdds cient compared methods storing general boolean constraints certain kinds simple constraints stored ciently representations 
know sorts constraints appear overhead keeping separate outweigh benefits alternative representations improve ciency analysis 
describes implementation groundness analysis pos domain positive boolean functions robdds 
uses optimisation variables definitely true removed robdd kept separate set implemented bit vector 
improves ciency groundness analysis ways easier determine variables definitely ground point analysis reduces size robdds making operations cient 
improve removing equivalent variable pairs robdd representing array 
find yields significant ciency gains groundness analysis pos resulting robdd nearly single node 
detailed description algorithms 
analysis uses larger subset boolean functions pos 
particular possible variables may definitely false 
obvious augmentation approach proves useful include separate set definitely false variables set definitely true variables 
removing definite variables equivalence constraints robdd useful remove sat constraints 
particular analysing programs involving large data structures lot implication constraints created early stages analysis parent child nodes instantiation grammar 
constraint occurs analysis sat constraint 
find removing storing cient data structure beneficial performance 
detecting removing sat constraint robdd easy remove 
keep constraints clausal form resolution obtain maximal set clauses 
operations restriction disjunction easier 
potential cause set clauses grow large 
find practice problem 
constraints added cause large number sat clauses generated 
represent sat constraints clausal form represented compactly definite variable equivalent variables sets 
describe algorithms required keeping sat constraints separate robdd 
notation closely possible 
robdd node robdd terminal nodes true false nonterminal node components val bvar true robdd false robdd 
assume total order bvar require val true val val false val robdd 
robdd node created function node bvar robdd robdd robdd 
call node returns robdd node val chapter 
constraint approach mode analysis true false matching node exists node returns creates new node 
re existing nodes ensures robdd duplicate sub graphs 
refer robdd top level node semantics robdd function jk robdd defined false true val jr true val jr false operators robdd robdd robdd robdd robdd robdd provide conjunction disjunction respectively robdds 
jr jr jr jr functions vars entailed robdd vars robdd defined 
vars entailed bvar 
vars bvar 
application vars entailed returns set boolean variables entailed application vars returns set boolean variables define robdd bvar robdd obtained replacing node val true similarly robdd obtained replacing node val false semantics functions 
robdd results constrain require variable value restrict away variables robdd 
likewise result constraining value restricting away variables 
defines representation sets pairs equivalent variables equiv bvar bvar 
implementation issues leader function bvar bvar equiv min bvar semantics equiv function jk equiv jek defines equiv equiv equiv equiv equiv equiv give operations conjunction disjunction respectively 
trans je jek je je jek je requiring equiv transitive relation bvar ensures explicitly represents equivalence relations implied semantics 
allows disjunction implemented simple set intersection 
function equiv vars robdd equiv obtains pairs equivalent variables robdd function squeeze equiv robdd bvar bvar robdd removes equivalence constraints robdd leader function representing equivalences 
functions identify remove equivalence constraints robdd 
define extension add separate representation sat constraints represent implications 
literal literal variable bvar negation define var pair literal literal represent clause define res literal literal literal literal res closure resolution set containing clauses plus clauses derivable resolution 
example 
res represent sat constraints set pairs pair represents clause containing literals 
require pair ordered total order bvar require set clauses closed resolution sat literal literal res var var semantics sat function jk sat sat jik sat define operations sat sat sat sat sat sat provide chapter 
constraint approach mode analysis conjunction disjunction respectively sat domain res ji sat jik sat ji sat ji sat jik sat ji sat requirement sat closed resolution allows disjunction operation implemented simple set intersection 
operations restriction easier 
find sat constraints robdd function find sat robdd sat defined 
robdd true find sat returns empty set 
robdd false find sat returns set possible sat constraints 
robdd find sat computes sat constraints involving val obtaining sets variables entailed true false calls find sat recursively true false compute sat constraints branch takes intersection sets 
potentially cient method computing sat constraints branch bound algorithm allow information shared computations branch computing branch independently intersection 
algorithm complete finds sat constraints robdd robdd constrain variables definitely definitely 
require operate robdds constraints removed 
find sat true false sat val vars entailed true val vars true val vars entailed false val vars false find sat false find sat true function find sat sat constraints robdd remove function remove sat sat robdd robdd defined page 
implementation find sat remove sat order avoid repeated traversals sub graph 
represent boolean constraints tuple 
give definition semantic function jk facing page 
intuitively bvar set variables definitely true bvar set variables definitely false equiv set pairs equivalent variables occur sat set constraints sat represented robdd contains remaining constraints represented means 
function vars returns set boolean variables contained member equiv sat robdd 

implementation issues remove sat remove sat remove sat true false val remove sat true val remove sat false node val remove sat val val true remove sat val val false function remove sat bvar bvar equiv sat robdd vars vars vars vars vars vars vars vars vars entailed vars equiv vars find sat jek jik sat definition semantics extension representation consisted components 
arbitrary tuple equiv sat robdd want normalise equivalent tuple 
ensure constraint represented cient manner 
define function normalise equiv sat robdd 
algorithm shown page 
check intersection empty 
constraints inconsistent return representing 
understand rest algorithm note involves propagating constraints di erent components order move constraints far left possible reduce size components right far possible 
equations defining propagate constraints component components 
equations defining propagate constraints component components 
equations defining propagate constraints component components 
equations defining propagate constraints component component 
equations defining propagate constraints component component 
chapter 
constraint approach mode analysis normalise false var var vars entailed vars equiv vars squeeze equiv find sat remove sat normalise normalisation function equations defining propagate constraints component component 
iterate steps reach fixpoint 
termination guaranteed sets finite components reduced size iteration 
operators provide conjunction disjunction respectively 
definitions shown facing page 
definitions extended definitions 
conjunction just return normalise 
definition cient reduces size robdds possible conjunction 
disjunction take disjunction component left right 
example take disjunction components gives constraints occur added back components respective components processed 
practice rarely generalised algorithms 
algorithms specialised type constraint need add 
try avoid calling normalise possible 
example wish conjoin constraint represented constraint bvar simply return 
normalising time add simple constraint add large overhead delay normalisation 
implementation issues normalise normalise normalise conjunction disjunction chapter 
constraint approach mode analysis needed 
option write specialised normalisation algorithms type constraint want add 
approach taken 
experimental results experimental results show feasibility analysis 
timings taken tests run gateway select pc mhz amd athlon cpu kb cache mb memory running linux kernel 
table compares times mode checking standard logic programming benchmarks 
column labelled simple time simple constraint system ground variables section 
column labelled full full constraint system section 
column labelled old time mode checking current mercury mode checker described chapter 
columns show ratios new old systems 
final column taken table page shows ratio alias tracking system chapter old system 
times milliseconds 
measured time repeats mode analysis benchmark divided result 
simple full old simple old full old alias old crypt deriv nrev poly primes qsort queens query tak table times mode checking logic programming benchmarks constraint analyses significantly slower current system alias tracking system 
partly obtaining information program doing lot 
example current system selects fixed sequential order conjunctions mode analysis order disallows partially instantiated data structures constraint approaches allow possible orderings considered building constraints 
appropriate scheduling selected execution model considering example argument passing conventions possibility introducing tail calls execution sequential parallel 
profiling shows execution time spent building manipulating robdds 
may worth investigating di erent constraint solvers propagation solvers 
optimisation bdd approach investigation cient sat solvers may yield improved performance 
possible method improving analysis time run old mode analysis new analysis predicates old analysis fails 

related interesting observe di erences simple constraint system full system 
benchmarks require partially instantiated data structures able analysed simple system 
cases simple system di erent full system particularly bigger benchmarks significantly faster 
speculate bigger benchmarks benefit reduced number constraint variables simple analysis 
table shows timings programs partially instantiated data structures current mercury system simple constraint system unable analyse 
times milliseconds measured repeating test times dividing result 
check infer infer check iota append copytree table times checking inferring modes partially instantiated data structures iota benchmark program example page 
append benchmark classic append 
copytree benchmark small program structural copy binary tree skeleton elements copy new free variables shown type tree empty tree tree tree 
inst tree bound empty tree tree tree 
pred copytree tree tree 
mode copytree tree free tree free 
copytree empty empty 
copytree tree tree copytree copytree 
times check columns checking programs mode declarations infer column shows times doing mode inference mode declarations removed 
interesting note saving analysis time achieved adding mode declarations 
particularly notable copytree benchmark mode inference able infer modes declared 
similarly declare mode append reduce analysis time ms 
related moded flat ghc system aware uses constraints mode analysis 
discussed earlier moded flat ghc relies position clause chapter 
constraint approach mode analysis head guard versus body determine unification allowed bind variables significantly simplifies problem 
constraints generated equational rely delaying complex cases occurrences variable goal 
boolean constraints proven technique groundness sharing analyses logic programs 
analyses program variable typically represented domain single boolean variable 
abstraction program set constraints boolean variables 
discover state variable point program execution examine constraint store corresponding point interpretation 
contrast approach separate boolean variable position variable program point 
necessary enable express constraints variables di erent program points 
large number boolean variables approach necessitates challenging represent constraints cient manner 
analysis functional programs boolean constraints 
example glynn success boolean constraints binding time analysis strictness analysis 
constraint analysis mercury 
particular constraint binding time analysis notable 
similar basic approach constraints positions type trees variables express data flow dependencies 
binding time analysis requires results mode analysis available 
mode analysis determined argument input variables computed arguments divides input arguments classes bound di erent times seeks find variables bound schedule body goal evaluated early possible 
main constraint variable bound variables computed bound 
constraints significantly simpler ones deal 
limitations possible defined constraint approach mode analysis mercury 
cient current system mode checking able check infer complex modes current system decouples reordering conjuncts determining producers 
implementation handles mercury constructs including higher order constructs 
constraint mode analysis handle subtyping unique modes 
plan extend handle features explore advanced mode systems complicated uniqueness modes unique objects stored recovered data structures polymorphic modes boolean variables represent pattern mode usage circular modes needed client server programs client server processes modelled recursive loops cooperate instantiate di erent parts data structure coroutining manner 
handling unique modes plan look modified version sharing analysis stuckey discussed section 
approach may similar linearity analysis ueda moded flat ghc discussed 
limitations possible section 
need extend considerably handle kinds data flow allow mercury programs 
chapter 
constraint approach mode analysis chapter chapter provide review contents thesis followed discussion benefits provides various groups 
discussion includes possible research implementation directions 
review thesis premise strong prescriptive mode system allow cient implementation logic programming language need non logical features destroy declarative semantics language 
shown providing precise mode analysis domain algorithm strong static type system allow system retain expressiveness logic programming language contributing significantly robustness required real world industrial strength language 
chapter detailed description mode system mercury including formalisation mode analysis rules overview algorithms mode checking inference 
previous descriptions mercury mode system intended high level overview system contain detail necessary depth understanding required reason extend system referring reader papers mode system 
papers papers related systems hal describe similar mode systems mercury 
description design choices led mercury mode system detailed description worked source code melbourne mercury compiler 
clarified relationship mode system formalism interpretation 
providing functions formalised semantics domain instantiation states 
matches partial order formalises comparison information content di erent instantiation states 
provided formal proof mode system sound 
confident framework provide basis proof 
partial order allows comparison similar mode systems hal chapter 
di ers mercury mode system mainly defines slightly di erently 
small di erence significant consequences strong mode system suitable particular purpose mercury mode system designed software engineering goals mind aims strong possible mode system hal compromises mode system weaker order constraint logic programming convenient gaining benefits prescriptive mode system 
formalising writing mode analysis rules beneficial enabling reason mode system 
example formalising notions unification merging matching definition partial orders greatly facilitated design development constrained polymorphic modes extension described chapter 
extension chapter allows relationship modes input output arguments predicate expressed precisely 
benefit analogous provided parametric polymorphic type systems 
caller predicate precise information instantiation state predicate input arguments required predicate mode declaration 
extension allows caller deduce precise information instantiation states output arguments particular call succeeds information input arguments 
increases expressiveness language way extremely useful practical consequences 
major benefit allows higher order values stored retrieved polymorphic data structures lists trees losing higher order mode information 
easier certain styles higher order programming common functional programming languages 
allows higher order values treated class values intended 
chapter extension mode system keep track definite aliases variables predicate body 
alias tracking system uses inst keys indicate parts inst instmap aliased 
inst keys ways compile time analog logic variables 
represent sharing bound terms unbound variables 
increase precision mode system resulting alias tracking major benefits 
allows uses partially instantiated data structures 
saw enable tail recursion predicates tail recursive 
restricted partially instantiated data structures cases require single part data structure needs filled 
avoids need pointer chains trailing machine implemented ciency costs 
desired analysis extended allow cases multiple required 
machinery support implemented hal project compiled mercury run time system compiler flag 
features incur ciency costs run time parts code try avoid possible 
case uses partially instantiated data structure require multiple un mercury mode system dynamic modes inst 
contributions thesis amenable herbrand constraint solving approach hal 
second major benefit alias tracking analysis allows complex uses unique modes 
unique modes important modelling input output destructive update arrays logically sound way 
provide compiler information needs implement automatic compile time garbage collection structure re 
alias tracking extension mode system precise handle cases unique objects stored inside unique objects 
previously possible making unique modes large programs inconvenient 
large program may unique objects threaded parts program 
convenient able bundle data structure requiring separate pair di uo arguments predicate unique object 
possible 
unfortunate side ect alias tracking system slows mode analysis significantly cases extra information provides required 
investigate ways making system cient 
chapter alternative approach mode analysis boolean constraints express instantiation relationships variables 
boolean constraints determine node expanded type graph variable subgoal responsible producing node 
information determine execution order conjuncts conjunction check correctness mode declarations 
system precise expressive alias tracking system chapter 
advantage provides allows re ordering conjunctions doing mode inference just mode checking 
separates conceptual stages mode analysis determine producers consumers schedule goals 
plan add stages handle sub typing constraints unique modes 
significant benefit chapter provides explicit representation instantiation graphs means referring individual nodes graph just insts program variables 
gives precision previously possible mode system 
believe easier add extensions required describe complex patterns data flow required allowing operative paradigms incomplete messages synchronous streams 
phase analysis provides information needed determine goals conjunction may executed parallel 
automatic parallelisation programs framework described conway 
implemented prototype constraint mode analysis system 
currently significantly slower existing mode system show feasibility approach 
required improve ciency 
contributions thesis section discuss contributions thesis main groups beneficiaries mercury application programmers mercury implementors language designers theoreticians 
chapter 
benefits programmers main benefit thesis provides mercury application programmers increases expressiveness language allowing programming constructs previously possible 
limitations pre existing mode system described chapter restrict programmers just simple modes unique modes di uo special cases destructively updatable arrays 
mode system gives mercury level expressiveness roughly comparable strict functional programming language 
ways provides considerably expressiveness functional languages providing nondeterminism backtracking 
ways provides slightly expressiveness example making harder higher order objects stored inside polymorphic data structures 
polymorphic mode system described chapter alleviates problem allowing programmer declare modes polymorphic predicates propagate higher order mode information input arguments output arguments 
mode system mercury complex may concern usable average application programmer 
fortunately believe huge problem 
time programmers continue need simple modes di uo 
experience programmers previous experience logic programming find modes intuitive easy represent familiar concepts input output arguments destructive update 
addition believe mode declarations act valuable documentation aids programmer determining intended meaning predicate 
despite positive anecdotal evidence interesting conduct formal usability testing language 
testing scope thesis 
polymorphic mode system extensions chapter mainly programmers writing libraries polymorphic code 
programmers experienced language familiar extra concepts required 
application programmers need understand polymorphic mode declarations degree order libraries 
long recognise say list skel input argument list skel output argument trouble 
furthermore expect polymorphically moded predicates corresponding polymorphic types 
theorems free principle described section allow polymorphically typed code take advantage polymorphic modes extra ort required part library writer application programmer 
extensions described chapters increase precision mode analysis allow programs classed mode correct 
change syntax language way complicate language application programmers 
fact application programmer task simpler programs resulted generation mode errors novice programmer may find hard understand allowed compiler 
extensions allow alias tracking body predicate 

contributions thesis may allow modes declared inferred contain aliases predicate arguments 
require changes syntax mode declarations clear changes way causes confusion mercury programmers 
benefits mercury implementors probably major benefit implementors mercury language formalisation mode system chapter 
provides description mercury mode system detailed provided language manual higher level abstraction actual implementation 
believe provides right level detail abstraction allow new implementors get speed workings mode analyser existing compiler develop new implementation mercury scratch 
chapters provide documentation implementation extensions mode system respectively describe 
chapters particular describe experimental prototypes require significant implementation part mercury distribution 
provide potential extension experimentation see 
parts thesis invaluable eventually takes tasks 
benefits language designers theoreticians thesis provides benefits language designers logic programming theoreticians 
shown strongly typed logic programming language strong prescriptive mode system capable expressive allow rich variety logic programming constructs idioms 
encourage language designers continue experiment extending boundaries achieved system 
constraint mode system chapter provides framework experimenting di erent properties mode systems modifying constraints 
example relaxing constraints enforce sequentiality obtain system allows operative paradigms incomplete messages synchronous streams 
chapter provided important link theory practice form galois connection set inference rules 
gives formal connection pre existing implementation mercury mode system theory interpretation essential precursor eventually proving soundness system 
chapter 
bibliography aiken murphy 
implementing regular tree expressions 
proceedings acm conference functional programming computer architecture pages 
acm press 
hassan kaci 
warren machine tutorial reconstruction 
mit press 
allen cocke 
program data flow analysis procedure 
communications acm march 
krzysztof apt 
remarks boolean constraint propagation 
new trends constraints joint ercim net workshop volume lecture notes artificial intelligence 
springer 
krzysztof apt roland bol 
logic programming negation survey 
journal logic programming 
michael arbib kfoury robert moll 
basis theoretical computer science 
springer 
roberto 
reactive implementation pos robdds 
swierstra editors programming languages implementations logics programs proceedings eighth international symposium volume lecture notes computer science pages 
springer 
roberto peter 
factorizing equivalent variable pairs robdd implementations pos 
editor proceedings seventh international conference algebraic methodology software technology volume lecture notes computer science pages 
springer 
erik barendsen smetsers 
uniqueness typing functional languages graph rewriting semantics 
mathematical structures computer science 
ralph becket 
thinking mode analysis 
email mercury developers mailing list january 
url www mercury cs mu oz au mailing lists mercury developers mercury developers html 
peter saumya debray 
return value placement tail call optimization high level languages 
journal logic programming january 
bibliography hans juergen boehm 
dynamic memory allocation garbage collection 
computers physics may 
ingo wegener 
improving variable ordering obdds np complete 
ieee transactions computers september 
george boole 
mathematical analysis logic essay calculus deductive reasoning 
macmillan barclay macmillan cambridge 
george boole 
investigation laws thought 
dover new york 
ma 
directional types annotation method 
journal logic programming 
ivan bratko 
prolog programming artificial intelligence 
addison wesley third edition 
maurice bruynooghe 
practical framework interpretation logic programs 
journal logic programming 
randal bryant 
graph algorithms boolean function manipulation 
ieee transactions computers august 
randal bryant 
symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys september 
chen kifer warren 
hilog order semantics higher order logic programming 
ewing lusk ross overbeek editors proceedings north american conference logic programming pages 
mit press 
cheng van emden richards 
warren method functional programming logic 
proceedings seventh international conference logic programming 
cho ueda 
diagnosing non moded concurrent logic programs 
proceedings joint international conference symposium logic programming pages 
church 
set postulates foundation logic part annals mathematics 
church 
set postulates foundation logic part ii 
annals mathematics 
keith clark 
negation failure 
gallaire minker editors logic databases pages 
plenum press 
keith clark steve gregory 
notes systems programming parlog 
proceedings international conference fifth generation computer systems pages 
bibliography keith clark steve gregory 
parlog parallel programming logic 
acm transactions programming languages systems january 
william clocksin christopher mellish 
programming prolog 
springer fourth edition 
codish dams 
bottom interpretation logic programs 
theoretical computer science 
michael codish bart 
analyzing logic programs prop logic programs magic wand 
journal logic programming 
michael codish harald sndergaard 
boolean logic set sharing analysis 
principles declarative programming volume lecture notes computer science pages 
springer 
michael codish harald sndergaard peter stuckey 
sharing groundness dependencies logic programs 
acm transactions programming languages systems 

interpretation concurrent logic languages 
proceedings north american conference logic programming pages 
mit press 
diaz 
simple cient boolean constraint solver constraint logic programming 
journal automated reasoning 
comon dauchet gilleron tison 
tree automata techniques applications 
available www grappa 
univ lille fr tata october 
tom 
programming parlog 
addison wesley 
thomas conway 
parallel mercury 
phd thesis university melbourne august 
thomas conway fergus henderson zoltan somogyi 
code generation mercury 
proceedings international symposium logic programming pages 
thomas conway zoltan somogyi 
deep profiling engineering profiler declarative programming language 
technical report department computer science software engineering university melbourne july 
url www mercury cs mu oz au information papers html 
patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proceedings fourth annual acm sigplan sigact symposium principles programming languages pages 
acm press 
bibliography patrick cousot radhia cousot 
systematic design program analysis frameworks 
proceedings sixth acm sigplan sigact symposium principles programming languages pages 
acm press 
patrick cousot radhia cousot 
interpretation application logic programs 
journal logic programming 
patrick cousot radhia cousot 
comparing galois connection widening narrowing approaches interpretation invited 
bruynooghe wirsing editors proceedings fourth international symposium programming language implementation logic programming volume lecture notes computer science pages 
springer 
patrick cousot radhia cousot 
systematic design program transformation frameworks interpretation 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
davey priestley 
lattices order 
cambridge university press 
saumya debray david warren 
automatic mode inference logic programs 
journal logic programming september 
alvaro del val 
sat renamable horn 
proceedings seventeenth national conference artificial intelligence pages 
aaai press mit press 
bart mara de la banda warwick harvey kim marriott peter stuckey 
herbrand constraint solving hal 
proceedings sixteenth international conference logic programming pages 
bart mara de la banda warwick harvey kim marriott peter stuckey 
overview hal 
proceedings international conference principles practice constraint programming pages 
ed 
prolog standard 
springer 
tyson zoltan somogyi fergus henderson thomas conway david je ery 
run time type information mercury 
proceedings international conference principles practice declarative programming volume lecture notes computer science pages 
springer 

layered modes 
journal logic programming 
john gallagher andre de waal 
fast precise regular approximations logic programs 
van hentenryck editor proceedings eleventh international conference logic programming pages 
mit press 
bibliography mara de la banda peter stuckey warwick harvey kim marriott 
mode checking hal 
proceedings international conference computational logic volume lecture notes computer science pages 
springer 
magnus 
tree automata 
budapest 
magnus 
tree languages 
rozenberg salomaa editors handbook formal languages volume pages 
springer 
kevin glynn martin sulzmann peter stuckey 
cient strictness analysis horn constraints 
cousot editor proceedings eighth international static analysis symposium volume lecture notes computer science pages 
springer 
kevin glynn martin sulzmann peter stuckey harald sndergaard 
boolean constraints binding time analysis 
danvy editors proceedings second symposium programs data objects volume lecture notes computer science pages 
springer 
thomas magnus carlsson 
programming fudgets 
johan jeuring erik meijer editors advanced functional programming volume lecture notes computer science pages 
springer may 
paul 
nave set theory 
springer 
dana harrington 
type system destructive updates declarative programming languages 
master thesis department computer science university calgary 

prolog users manual 
department computer science university southern california april 
andy abo michael codish andy king 
simple polynomial groundness analysis logic programs 
journal logic programming 
fergus henderson 
strong modes change world 
honour report department computer science university melbourne november 
url www 
mercury cs mu oz au information papers html 
fergus henderson thomas conway zoltan somogyi david je ery peter simon taylor chris tyson ralph becket 
mercury language manual 
department computer science software engineering university melbourne april 
url www mercury cs mu oz au information documentation html 
version 
fergus henderson zoltan somogyi thomas conway 
determinism analysis mercury compiler 
proceedings australian computer science conference pages january 
pat hill john lloyd 
godel programming language 
mit press 
bibliography hindley 
principal type scheme object combinatory logic 
transactions american mathematical society 
alfred horn 
sentences true direct unions algebras 
journal symbolic logic 
iso 
standard programming language prolog 
standard number iso iec international organisation standardisation iso 
jacobs 
accurate cient approximation variable aliasing logic programs 
ewing lusk ross overbeek editors proceedings north american conference logic programming pages 
mit press 
ja ar jean louis lassez 
constraint logic programming 
conference record fourteenth annual acm symposium principles programming languages pages 
acm press 
janssens maurice bruynooghe 
deriving descriptions possible value program variables means interpretation 
journal logic programming 
david je ery 
expressive type systems logic programming languages 
phd thesis university melbourne february 
david je ery fergus henderson zoltan somogyi 
type classes mercury 
edwards editor proceedings third australasian computer science conference volume australian computer science communications pages 
ieee press 
kenneth kennedy 
survey data flow analysis techniques 
steven muchnik neil jones editors program flow analysis theory applications 
prentice hall 

type synthesis ground prolog 
proceedings fourth international conference logic programming pages 
mit press 
robert kowalski 
predicate logic programming language 
proceedings congress international federation information processing pages 
elsevier north holland 
robert kowalski 
algorithm logic control 
communications acm july 
peter stuckey 
precise pair sharing analysis logic programs 
claude kirchner editor proceedings fourth international conference principles practice declarative programming pages 
acm press 
landin 
correspondence algol church lambda notation part communications acm february 
bibliography landin 
correspondence algol church lambda notation part ii 
communications acm march 
le charlier pascal van hentenryck 
groundness analysis prolog implementation evaluation domain prop 
proceedings acm sigplan symposium partial evaluation semantic program manipulation pages 
acm press 
le charlier pascal van hentenryck 
experimental evaluation generic interpretation algorithm prolog 
acm transactions programming languages systems 
thomas lindgren johan 
taylor scheme unbound variables 
technical report computing science department uppsala university sweden october 
lloyd 
foundations logic programming 
springer 
kim marriott harald sndergaard 
precise cient groundness analysis logic programs 
acm letters programming languages systems 
kim marriott harald sndergaard neil jones 
denotational interpretation logic programs 
acm transactions programming languages systems 
kim marriott peter stuckey 
programming constraints 
mit press 
nancy mazur janssens maurice bruynooghe 
module analysis memory reuse mercury 
proceedings international conference computational logic volume lecture notes artificial intelligence pages 
springer 
nancy mazur peter ross janssens maurice bruynooghe 
practical aspects working compile time garbage collection system mercury 
proceedings seventeenth international conference logic programming volume lecture notes computer science pages 
springer 
mcallester 
outlook truth maintenance 
ai memo artificial intelligence laboratory massachusetts institute technology 
mcallester 
truth maintenance 
proceedings eighth national conference artificial intelligence pages 
christopher mellish 
automatic derivation mode declarations prolog programs 
research department artificial intelligence university edinburgh 
christopher mellish 
global optimizations prolog compiler 
journal logic programming april 
bibliography miller drechsler 
dual edge operations reduced ordered binary decision diagrams 
proceedings ieee international symposium circuits systems volume pages 
ieee press 
robin milner 
theory type polymorphism programming 
journal computer system sciences december 
john mitchell gordon plotkin 
types existential types 
acm transactions programming languages systems july 
janssens bruynooghe 
practicality equation systems 
international conference logic programming 
mit press june 
alan mycroft richard keefe 
polymorphic type system prolog 
artificial intelligence 
lee naish 
automatic control logic programs 
journal logic programming november 
lee naish 
negation control prolog volume lecture notes computer science 
springer 
lee naish 
declarative view modes 
proceedings joint international conference symposium logic programming pages 
mit press 
lee naish 
higher order logic programming 
technical report department computer science university melbourne february 
url www cs mu oz 
au publications tr db tr html 
lee naish 
mode checking constrained regular trees 
technical report department computer science university melbourne march 
url www cs mu oz au publications tr db tr html 
amit narayan 
advances bdd representations boolean functions survey 
twelfth international conference vlsi design pages 
ieee press 
nicholas nethercote 
analysis framework hal 
master thesis department computer science software engineering university melbourne april 
nicholas nethercote alan mycroft 
cache behaviour large lazy functional programs stock hardware 
proceedings acm sigplan workshop memory system performance 
acm press 
richard keefe 
craft prolog 
mit press 
david overton zoltan somogyi peter stuckey 
constraint mode analysis mercury 
claude kirchner editor proceedings fourth international conference principles practice declarative programming pages 
acm press 
bibliography rinus plasmeijer marko van eekelen 
concurrent clean language report version 
department software technology university nijmegen september 
porto 
language extended programming logic 
van editor proceedings international logic programming conference pages 
steve reeves michael clarke 
logic computer science 
addison wesley 
olivier patrice boizumault frederic 
typed static analysis application groundness analysis prolog lambda prolog 
proceedings international symposium functional logic programming volume lecture notes computer science pages 
springer 
robinson 
machine oriented logic resolution principle 
journal acm 
peter ross david overton zoltan somogyi 
making mercury programs tail recursive 
proceedings ninth international workshop logic program synthesis transformation volume lecture notes computer science pages 
springer 
peter 
cient robdd operations program analysis 
ramamohanarao editor proceedings australasian computer science conference pages 
australian computer science communications 
peter 
precise cient static analysis logic programs 
phd thesis university melbourne july 
tom bart 
combining improvement parma trailing trailing analysis 
claude kirchner editor proceedings fourth international conference principles practice declarative programming pages 
acm press 
ehud shapiro 
systems programming concurrent prolog 
conference record eleventh acm symposium principles programming languages pages 
acm press 
ehud shapiro 
subset concurrent prolog interpreter 
concurrent prolog collected papers volume pages 
mit press 
simonis 
test generation constraint logic programming language chip 
levi martelli editors proceedings sixth international conference logic programming pages 
mit press 
jan georg 
modes types logic programming 
phd thesis university kent canterbury december 
jan georg pat hill andy king 
termination logic programs block declarations running modes 
palamidessi editor proceedings bibliography tenth symposium programming languages implementations logics programs volume lecture notes computer science pages 
springer 
jan georg pat hill andy king 
preventing instantiation errors loops logic programs multiple modes block declarations 
editor proceedings international workshop logic program synthesis transformation volume lecture notes computer science pages 
springer 
jan georg pat hill andy king 
mode analysis domains typed logic programs 
proceedings ninth international workshop logic program synthesis transformation volume lecture notes computer science pages 
springer 
zoltan somogyi 
system precise modes logic programs 
proceedings fourth international conference logic programming pages 
zoltan somogyi 
parallel logic programming system strong precise modes 
phd thesis university melbourne january 
zoltan somogyi fergus henderson thomas conway 
mercury cient purely declarative logic programming language 
proceedings australian computer science conference pages 
zoltan somogyi fergus henderson thomas conway 
execution algorithm mercury cient purely declarative logic programming language 
journal logic programming 
zoltan somogyi fergus henderson thomas conway richard keefe 
logic programming real world 
donald smith editor proceedings ilps workshop visions logic programming pages 
harald sndergaard 
application interpretation logic programming occur check reduction 
robinet wilhelm editors proceedings european symposium programming volume lecture notes computer science pages 
springer 
leon sterling ehud shapiro 
art prolog 
mit press second edition 
tan peng lin 
recursive modes precise analysis logic programs 
ma editor proceedings fourteenth international logic programming symposium pages 
mit press 
andrew taylor 
high performance prolog implementation 
phd thesis university sydney 
andrew taylor 
parma bridging performance gap imperative logic programming 
journal logic programming 
bibliography simon taylor 
optimization mercury programs 
honour report department computer science software engineering university melbourne 
url www mercury cs mu oz au information papers html 
james thom justin zobel 
nu prolog manual 
technical report department computer science university melbourne 
ueda 
mode analysis concurrent logic programming 
theory practice parallel programming volume lecture notes computer science pages 
springer 
ueda 
experiences strong concurrent logic constraint programming 
proceedings international workshop parallel symbolic languages systems volume lecture notes computer science pages 
springer 
ueda 
linearity analysis concurrent logic programs 
michael leuschel editor proceedings international workshop optimization implementation declarative programs volume electronic notes theoretical computer science 
elsevier 
ueda morita 
moded flat ghc message oriented implementation technique 
new generation computing 
maarten van emden robert kowalski 
semantics predicate logic programming language 
journal acm october 
pascal van hentenryck agostino le charlier 
type analysis prolog type graphs 
journal logic programming 
peter van roy 
logic programming execute fast imperative programming 
phd thesis university california berkeley november 
peter van roy alvin despain 
high performance logic programming prolog compiler 
ieee computer january 
wim 
binding time analysis constraint solving modular higher order approach mercury 
parigot voronkov editors proceedings seventh international conference logic programming automated reasoning volume lecture notes artificial intelligence pages 
springer 
wim 
techniques line specialisation logic programs 
phd thesis katholieke universiteit leuven belgium june 
philip wadler 
better laziness lazy evaluation garbage collection compile time 
proceedings acm symposium lisp functional programming pages 
philip wadler 
theorems free 
fourth international conference functional programming languages computer architecture pages 
acm press 
bibliography philip wadler 
deforestation transforming programs eliminate trees 
theoretical computer science 
philip wadler 
linear types change world 
broy jones editors programming concepts methods 
david warren 
implementing prolog compiling predicate logic programs 
research reports department artificial intelligence university edinburgh 
david warren 
higher order extensions prolog needed 
hayes donald michie 
pao editors machine intelligence volume lecture notes mathematics pages 
ellis horwood 
david warren 
prolog instruction set 
technical note sri international menlo park california usa october 
joseph zachary katherine yelick 
moded type systems support abstraction 
frank pfenning editor types logic programming chapter pages 
mit press 
lei zheng peter stuckey 
improving sat sat 
proceedings th australasian computer science conference pages 
index symbols function mapping 
equivalence 
implication 
abstraction function uniqueness annotations 
abstraction function 
simple mode system 
higher order modes 
unique modes 
set atoms 
bottom 
set intersection 
corresponding nodes 
set union 
empty set 
mode merge operation 
instantiatedness lub 
instantiatedness glb 
partial order counts 
mode restriction operation 
alias tracking 
matches glb 
matches lub 
matches partial order simple mode system 
dynamic modes 
higher order modes 
modes 
modes uniqueness ranges 
unique modes 
inst key 
uniqueness lub 
uniqueness total order 
mode sequence operation 
uniqueness glb 
corner brackets 
empty goal path 
nonlocal variables 
existential quantifier 
mercury syntax 
predicate logic 
restriction boolean function 
universal quantifier 
predicate logic 
function uniqueness annotations 
function 
simple mode system 
dynamic modes 
higher order modes 
unique modes 
set member 
lambda quantifier 
reverse implication horn clause 
mercury syntax 
equivalence propositional logic 
sub inst partial order 
models 
negation 
mercury syntax 
propositional logic 
variables goal 
instmap update 
instantiatedness partial order index simple mode system 
alias tracking 
dynamic modes 
higher order modes 
modes uniqueness ranges 
polymorphic modes 
unique modes 
function space 
implication propositional logic 
set di erence 
subset 
set ground terms 
set terms 
cartesian product 
top 
disjunction 
mercury syntax 
propositional logic 
conjunction 
mercury syntax 
propositional logic 


set cardinality 

member 
power set 

tuple 
sat 
compilation 
domain 
inst 
interpretation syntax order mercury 
full mercury 
type 
unification 
alias tracking 
unify inst simple mode system 
alias tracking 
dynamic modes 
liveness 
unique modes 
unify inst functor simple mode system 
alias tracking 
liveness 
unique modes 
abstraction function 
aiken murphy 
algorithm logic control 
alias inst 
aliasing 
allen cocke 
nodes 
antisymmetric 
inst 
application 
apt 
apt bol 
arbib 
set 
argument mode 
arity 
assignment 

atom 
atomic formula 
see atom atomic goal 
attribute variables 
kaci 
backtrack 


barendsen smetsers 
set 
index becket 
debray 
binary 
binding time analysis 
body 
boehm 
wegener 
bool set 
boole 
boole 
boolean constraint 
boolean formula 
boolean function 
boolean logic 
boolean valuation 
boolean variable 
bottom 
bound inst 
ma 
bratko 
bruynooghe 
bryant 
bryant 
set 
bvar set 
call 
mercury syntax 
call mode rule 
cardinality 
cartesian product 
comp function 
conj function 
decl function 
decls function 
disj function 
ext function 
gen function 
goal function 
chen 
cheng 
cho ueda 
choice points 
church 
church 
inf function 
ite function 
function 
clark 
clark gregory 
clark gregory 
clause 
clobbered uniqueness annotation 
local function 
clocksin mellish 
codish 
codish sndergaard 
codish 
codish 
diaz 

comon 
comparable 
compile time garbage collection complete lattice 
complicated unification 
compound goal 
computation point 
concrete domain 
function 
simple mode system 
dynamic modes 
unique modes 
concurrent clean 
concurrent logic programming languages 
concurrent prolog 
conj mode rule 
conjunction 
conjunctive normal form 

constant 
constrained inst inst 
constraint logic programming 
construction 
consumed 
index function 
conway 
conway somogyi 
conway 
coroutining 
corresponding nodes 
cousot cousot 
cousot cousot 
cousot cousot 
cousot cousot 
pred function 
scc function 
struct function 
cut 
data flow analysis 
davey priestley 
debray warren 
dec prolog 
deconstruction 
definite aliases 
definite clause 
definite logic program 
del val 

depth search strategy 

descriptive 
destructive update 
determinism 
di erence lists 
directional types 
disj mode rule 
disjunction 
dom function 
domain 

dynamic modes 
edinburgh prolog 
see dec prolog empty clause 
empty set 
environment 
epilog 
equivalent 

existential quantification 
existential types 
expand function 
expand shared function 
argument indexing 
order predicate logic 
fix function 
fixed point combinator 
fixed value domains 
fixpoint 
flattened term 
free inst 
set 
higher order 
set 
function 
function symbol 
functor 
see function symbol gallagher de waal 
galois connection 
de la banda get subst function 
ghc 
see moded flat ghc glb 
glynn 
goal set 
higher order 
goal 
mercury syntax 
goal path 
godel 
grammar function 
greatest lower bound 
ground inst 
ground inst 
index ground prolog 
ground term 
groundness analysis 


hal 
carlsson 

harrington 
hasse diagram 

head 

henderson henderson 
henderson 
herbrand universe 
higher order inst 
higher order modes 
higher order programming 
hill lloyd 
hindley 
ho call mode rule 
horn 
horn clause 
normal form 


implied mode 
incomparable 
inst set simple mode system 
alias tracking 
annotations free 
dynamic modes 
higher order modes 
polymorphic modes 
polymorphic modes uniqueness ranges 
unique modes 
inst 
inst constraint 
inst definition 
inst key 
inst keys function 
inst substitution 
inst variable 
instantiation graph 
instantiation state 
see inst set 
instmap set 
instmap 
intersection 
iso 
ite mode rule 
iterated mode segments 
jacobs 
ja ar lassez 
janssens bruynooghe 
je ery 
je ery 
kennedy 

kowalski 
kowalski 
stuckey 
lambda calculus 
lambda quantified 
landin 
call modulo constructors 
call optimisation 
lattice 
upper bound 
le charlier van hentenryck le charlier van hentenryck lindgren 
index linear types 
literal predicate logic 
propositional logic 
live 
liveness 
lloyd 
logic programming 
logic variable 
logical connectives 
lower bound 
lub 
visible function 
mapping 
marriott stuckey 
marriott sndergaard marriott 
mazur 
mazur 
mcallester 
mcallester 
melbourne mercury compiler mellish 
mellish 
member 
mercury 
mercury machine 
merge 
alias tracking 
merge insts 
meta languages 
miller drechsler 
milner 
mitchell plotkin 
mode 
mode analysis 
mode checking 
mode checking algorithm 
mode correct 
mode declaration 
mode inference 
mode inference algorithm 
mode judgement 
moded flat ghc 
model 
modes 
modules 
monotonic 
general unifier 
clobbered uniqueness annotation 
unique uniqueness annotation 

mycroft keefe 
naish 
naish 
naish 
naish 
narayan 
need visible function 
negation 
negation failure 
negative literal 
nethercote 
nethercote mycroft 
new inst key function 

node 
nondeterminism 
nonlogical 
normalisation insts 
mode rule 
reached inst 
nu prolog 
keefe 
object languages 
occur check 
nodes 
overloading 
index overton 
pair 
paradigm incomplete messages 
parametric polymorphism 
parent 
parent node 
parlog 
parma 
partial function 
partial order 
partially instantiated data structures 
implementation 
partially ordered set 
see poset path component 
pattern matching 
plasmeijer van eekelen 
porto 
pos 
poset 
position 
positive literal 
possible aliases 
power set 
precision 
pred set 
predicate 
mercury syntax 
predicate logic 
predicate name 
set 
prenex normal form 
prescriptive 
proc set 
proc mode rule 
procedure 
produced 
produced function 
program set 
program 
prolog 
propositional logic 
propositional satisfiability problem 
query 
re ordering conjunctions 
recursive modes 
reduced ordered binary decision diagram 
see robdd reeves clarke 
refcount set 
counts 
reflexive 
regular trees 
regular type 
relation 
remove singleton inst keys function 
resolution predicate logic 
propositional logic 
sld resolution 
sldnf resolution 
restriction 

robdd 
robinson 
ross 
set 
rtti 
see run time type information rules function 
run time type information 
sat 
satisfiable 
scc 


scheduling sub goals 

clobbered unify 
set 
index set comprehension 
set di erence 
shapiro 
shapiro 
shared uniqueness annotation 
sharing 
sharing analysis 
signature relation 
set terms 
simonis 

sld resolution 
sldnf resolution 




software engineering 
mode rule 
somogyi 
somogyi 
somogyi 
somogyi 
sterling shapiro 
strictness analysis 
strong 
strongly connected component 
see scc structure re 
sub inst 
subset 
substitution 
inst 
subtype 
normal form symmetric 
synchronised streams 
sndergaard 
tail call optimisation 
tail recursion 
tan lin 
taylor 
taylor 
taylor 
term set 
theorems free 
thom zobel 
top 
total function 
transitive 
transitive closure 
trans transitive closure function 
tree 
tree grammar 
truth table 
tuple 
type classes 
type constructor 
type definition 
type graph 
type parameters 
types 
ueda 
ueda 
ueda 
ueda morita 
undefined 
unification 
mercury syntax 
unification algorithm 
unifier 
unify mode rule 
unify vf mode rule 
unify vv mode rule 
union 
uniq set 
unique uniqueness annotation 
unique modes 
uniqueness 
uniqueness function 
uniqueness annotations 
index uniqueness ranges 
uniqueness types 
unquantified variables 
unreachable set 
upper bound 
uq function 
valid 
van emden kowalski 


van hentenryck 
van roy 
van roy despain 
var set 
visible 
wadler 
wadler 
wadler 
wam 
warren 
warren 
warren 
warren machine 
see wam weak 
widening 
zachary yelick 
zheng stuckey 

