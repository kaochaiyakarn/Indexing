meta reasoning survey costantini loc 
aquila italy 
basic principles possible applications systems capable meta reasoning reflection 
discussion seminal approaches outline perception state art mainly computational logic logic programming 
review relevant successful applications meta reasoning basic underlying semantic principles 
meaning term meta reasoning reasoning reasoning 
computer system means system able reason operation 
different performing object level reasoning refers way entities external system 
system capable meta reasoning may able reflect introspect shift meta reasoning objectlevel reasoning vice versa 
main principles possible applications metareasoning reflective systems 
review relevant approaches mainly computational logic logic programming discuss state art interesting applications meta reasoning 
briefly summarize semantic foundations meta reasoning 
necessarily express partial point view field provide consider important 
previous reviews subject indebted refer reader wider perspective careful discussion problems foundations languages approaches systems 
especially mention 
reader may refer computational logic aspects proceedings workshops meta programming logic 
significant meta programming carried esprit funded european projects ii 
results discussed sections 
wider report refer reader 
generally meta reasoning various kinds paradigms including object oriented functional imperative languages reader may refer 
research meta reasoning reflection computer science roots principles techniques developed logic fundamental del tarski may useful refer surveys 
meta level approaches knowledge knowledge represented admitting sentences arguments sentences abandoning framework order logic 
alternative important approach formalize knowledge knowledge modal approach initially developed logicians philosophers received great deal attention field artificial intelligence 
aims formalizing knowledge logic language augmented modal operator interpreted knowledge belief 
sentences expressed represent properties knowledge belief 
common modal systems adopt semantics 
semantics knowledge belief regarded propositions specifying relationship knowledge expressed theory external world 
review modal meta languages focused expressivity consistency problems possibility translating modal languages meta level setting reader may refer 
meta programming meta reasoning underlying computational paradigm piece software included system say manipulates kind data organized suitable data structures 
data various ways producing results sending messages performing actions just updating component internal state 
data assumed denote entities software component 
computation produce effects visible external environment necessary assume exists software system environment sense intended effect achieved means suitable interface devices 
means software component performs action order instance print text send mail message switch light causal connection guarantee happens 
software components take programs data 
important known example compiler manipulates data structures representing source program translated 
compiler written language intended translate instance compiler written different language 
important notice case mixture compiler source program 
compiler performs computation outcome transformed form source program 
source program just text recorded suitable data structure step step transformed representations 
essence compiler accepts manipulates source program 
logic language takes sentences language objects discourse called meta language 
language called object language 
clear separation object language meta language necessary consists fact sentences written metalanguage refer sentences written object language means kind sentences written object language treated data 
known kurt del developed technique coding formulas theory arithmetic means numbers del numbers 
possible write formulas manipulating formulas represented corresponding del numbers 
view compiler writing compiler just programming meta programming 
language compiler written acts meta language 
language source program written acts object language 
generally tools program analysis debugging transformation meta programs 
perform kind meta programming called meta programming 
syntactic meta programming particularly useful theorem proving 
fact stressed lemmas theorems meta theorems asserting validity fact simply looking syntactic structure 
case software component theorem prover consists different parts call object level proofs performed repeatedly applying inference rules call meta level meta theorems stated 
may notice theorem prover intelligent system performs deduction form mechanized reasoning 
say theorem prover object level performs object level reasoning 
meta theorems take arguments description object level formulas theorems meta level proofs manipulate descriptions 
meta level system performs reasoning entities internal system opposed object level reasoning concerns entities denoting elements external domain 
say meta level theorem prover performs meta level reasoning shortly meta reasoning 
meta theorems particular kind meta knowledge knowledge properties object level knowledge 
object meta level usefully interact meta theorems order shorten object level proofs improving efficiency theorem prover derive proofs easily 
view meta theorems may constitute enhance pragmatic view deductive power system 
notice meta level new meta theorems proved applying suitable inference rules 
pointed software components implicitly incorporate kind meta knowledge pieces object level code accordance meta knowledge states 
instance object level planner program know holds holds case planner meta level explicitly encode meta rule stating relation symmetric equivalent relation antisymmetric case 
meta level statements symmetric antisymmetric 
results obtained means explicit meta reasoning implicit knowledge hidden code 
advantage meta reasoning performed way symmetric antisymmetric relation may 
properties relations encoded meta level similar way meta level specification independent specific object level knowledge application domain reused applications 
possible architectures meta knowledge metareasoning applications 
reviewed 
wider perspective reader may refer various specific architectures applications systems discussed 
reification meta level rules manipulate object level knowledge 
knowledge represented kind language meta rules manipulate representation syntactic expressions object level language 
analogy natural language representation usually called syntactic expression 
difference word language instance name word denote entity domain situation talking name denotes word say flower composed characters expressed english translation italian fiore 
word name inspected instance count characters manipulated instance translated 
expression formal language may different kinds names allow different kinds meta reasoning expression 
names expressions meta language 
instance equation may simple name natural language kind name called usually intended constant meta language 
name may complex term equation left hand side variable right hand side binop minus variable constant term describes equation terms left hand side righthand side describes right hand side application binary operator binop operands operand variable second constant 
constants meta language names expressions object language 
complex name called easier inspect expression instance see contains variables manipulate instance possible transform name name equation modifying composing terms 
course variations possible detailed names kind detail express 
choices names instance name variable meta constant meta variable 
discussion different possibilities advantages disadvantages see 
definition names relation object level expressions meta level expressions play role names usually called naming relation choose 
general depends kind meta reasoning wants perform 
fact meta theory reason properties object level expressions explicit naming relation 
may provide names language expression simplest complex ones 
logic meta language may names variables constants function predicate symbols terms atoms entire theories meta level may principle encode reason description object level theories 
practice trade expressivity simplicity 
fact names kept simple possible reduce complexity improve readability meta level expressions 
starting considerations argues naming relation adapted particular case definable user 
shown different naming relations coexist context different purposes providing operators transforming representation 
definition naming relation implies definition operation compute name language expression 
second compute expression name stands 
operation obtaining name object level expression called inverse operation called built operations operational semantics consists applying naming relation directions 
shown naming relation sort input parameter meta language 
meta language may carefully designed large extent independent syntactic form names class expressions named 
line full theory definable naming relations developed naming relation basic properties defined set equations associated rewrite system applying 
introspection reflection idea meta knowledge meta reasoning useful improving reasoning performed object level instance exploiting properties relations symmetry suggests object meta level interact 
fact object meta level seen different software components interact passing control 
object level operation allows expression transformed name name input argument meta level component 
means object level computation gives place meta level computation 
computational step called meta level considered higher level respect object level 
object level component suspends activity order initiate meta level 
meant analogy process people conscious meta level mind mental states currently object level 
inverse action consists going back object level activity called object level activity resumed suspended restarted 
state altered meta level activity performed 
downward reflection may imply name dereferenced resulting expression extracted name input argument resumed restarted object level activity 
logical languages upward downward reflection specified means special inference rules reflection rules axioms reflection axioms may state kind knowledge exchanged 
functional procedural languages part run time state object level ongoing computation reified passed meta level function procedure inspect modify state 
function terminates object level computation resumes possibly modified state 
shifts level activity object meta level may sense invoked user interactive systems determined kind specification explicitly text theory program sense auto matically performed occurrence certain predefined conditions 
explicit implicit reflection may exist 
forms reflection rely requirement equivalently recommendations metalevel followed object level 
instance procedural case modifications state performed meta level effective corresponding impact object level computation 
usefulness reflection consists exactly fact system object reasons properly affected results reasoning 
summary meta level architecture building software components provide possibility defining meta level means naming relation manipulate representation object level expressions 
notice levels may meta level may meta metalevel uses naming relation representing meta level expressions 
similarly meta meta meta level 
may object level independent meta levels object level may time time associated performing different kinds meta reasoning 
architecture may provide reflection mechanism allows different levels interact 
reflection mechanism provided computation performed meta level simulates object level formulas naming relation simulates object level inference rules means meta level axioms 
discussed case main approaches meta reasoning 
languages object level meta level expressed may different may coincide 
instance may meta level order logic language meta reasoning performed object level functional imperative language 
languages coincide object language meta language may fact 
case language expressive explicitly represent syntactic expressions language capable interesting deep discussion languages self 
role introspection reasoning discussed 
interesting contribution reflection applications 
seminal approaches fol fol standing best knowledge reflective system appeared literature 
proof checker natural deduction knowledge meta knowledge expressed different contexts 
user access contexts expressing inferring new facts 
fol system consists set theories called contexts order language sorts conditional expressions 
special context named meta describes proof theory model theory fol contexts 
specific context take object theory naming relation defined attachments user defined explicit definitions relating symbols terms meta interpretation connection meta provided special linking rule applicable directions formula object theory name fact meta theory 
means special primitive called reflect linking rule explicitly applied user 
effect formula meta theory derive meta theorems involving vice versa metatheorem theorem theory 
meta theorems subsidiary deduction rules 
interesting applications fol system mathematical problems 
amalgamating language meta language logic programming seminal approach reflection context horn clause language proposed bowen kowalski 
proposal representing horn clause syntax provability logic means meta interpreter interpreter horn clause language written horn clause language 
case object language meta language coincide 
concept implementation meta interpreter introduced john mccarthy lisp programming language 
mccarthy particular defined universal function written lisp represents basic features lisp interpreter 
particular universal function able accept input definition lisp function list arguments ii evaluate function arguments 
bowen kowalski developed powerful important idea field logic programming inference process building proofs theory evaluating functions 
bowen kowalski meta interpreter specified predicate defined set meta axioms relevant aspects provability explicit 
predicate takes argument representation name object level theory representation name goal means goal provable theory formulation approach inference performed meta level invocation object level simulated providing suitable description object theory strength originality rely object level meta level 
consists upward downward reflection means provability meta level means provability object level application linking rules coincides practice invocation reflection 
amalgamation allows mixed sentences object level sentences invocation determines shift meta level meta level sentences invocation determines shift object level 
theory deduction performed input argument object level meta level theories exist inference process 
extension conservative theorems provable provable gain expressivity practical terms great 
traditional problems knowledge representation find natural formulation 
extension non conservative additional rules added represent auxiliary inference rules deduction strategies 
additional arguments added integrating forms basic definition provability 
instance possible control amount resources consumed proof process structure proof explicit 
semantics predicate easy define see holds meta theory linking rules provide extension basic horn clause language conservative faithful representation horn clause provability 
amalgamated language far expressive object language enhanced meta interpreters semantically ruled case extension non conservative 
practice success approach great enhanced logic programming artificial intelligence see instance logic programming textbook 
seminal initiated field meta programming logic programming computational logic 
problems promises field discussed kowalski 
approach meta interpreters relevant applications meta programming discussed section 
lisp lisp important example reflective architecture object language meta language coincide 
lisp meta interpreter lisp elaboration mccarthy original proposal interesting aspects state program interpreted stored passed argument functions internal meta interpreter 
procedures takes state argument modification passes modified state internal procedure 
procedures call tail recursively procedure call action state remains explicit 
meta interpreter called meta circular interpreter 
assumes meta circular interpreter executed interpreter imagine potentially infinite interpreters lowest executing object level program see summary formalization approach 
meta level accessible object level run time reflection act represented special kind function invocation 
object level program invokes function special way receives additional parameter representation state program 
inspect modify state returning control object level execution 
reflective act implies reification state execution procedure internal interpreter 
turn contain reflection act meta circular interpreter able reify state start brand new copy 
approach principle perform reflection reflective tower interpreters 
program able interrupt computation change state continue modified interpretation process 
kind mechanism called 
semantics computational reflection procedural declarative 
reflective architecture conceptually similar lisp proposed horn clause language fully implemented 
procedural nature easy understand practice computational reflection having great success years especially context imperative object oriented programming 
authors propose computational reflection basis new programming paradigm 
computational reflection perceived way performing meta reasoning non logical paradigms success important meta reasoning especially complex applications 
important approaches amalgamated approach experimented attardi simi omega 
omega object oriented formalism knowledge representation deal meta theoretical notions providing objects describe omega objects derivability omega 
non amalgamated approach logic programming del language object theory meta theory distinct 
del provides conservative provability predicate explicit form reflection 
language developed experimented context european project 
described book 
contribution meta programming del proposed aspects hand programming style efficient meta programming outlined hand modifications implementation proposed order improve performance meta programs 
project extends builds fol lisp getfol 
developed top novel implementation fol approach amalgamated object theory meta theory distinct 
getfol able introspect code lifting reason deductively declarative meta theory result produce new executable code pushed back underlying interpretation flattening 
architecture sharp distinction deduction fol style computation lisp style 
reflection getfol gives access meta theory features system explicit code implements system 
main objective getfol implementing theorem provers ability implementing flexible control strategies adapted computational reflection particular situation 
similarly fol kind reasoning performed getfol consists performing reasoning meta level ii results reasoning assert facts object level 
interesting extension applying concept system multiple theories multiple languages theory formulated language steps reinterpreted doing reasoning theory ii jumping theory reasoning basis derived previous theory 
deductions concatenated application inference rules premises belong language theory belongs language 
different concept reflection embodied reflective prolog self referential horn clause language logical reflection 
objective approach developing expressive powerful language preserving essential features logic programming horn clause syntax model theoretic semantics resolution unification procedural semantics correctness completeness properties 
reflective prolog horn clauses extended self resolution extended logical reflection order achieve greater expressive inference power 
reflection mechanism interpreter language automatically reflects upwards downwards applying suit able linking rules called allows reasoning metareasoning interleave user intervention exploit knowledge meta knowledge proofs approaches level class deduction performed level plays secondary role 
reflection principles embedded procedural declarative semantics language extended resolution procedure interpreter construction models give meanings programs 
procedurally implies need axiomatize provability meta theory 
object level reasoning simulated meta interpreters directly executed language interpreter avoiding unnecessary inefficiency 
semantically theory composed object level meta levels regarded enhanced theory enriched new axioms entailed theory reflection principles interpreted axiom schemata 
reflective prolog language metalanguage amalgamated non conservative extension 
reflection reflective prolog gives access meta theory various kinds meta knowledge expressed application domain behavior system 
deduction reflective prolog means step meta level object level knowledge continuous interleaving levels 
meta reasoning reflective prolog implies declarative definition meta knowledge automatically integrated inference process 
relation meta reasoning reflective prolog modal logic discussed 
interpreter reflective prolog fully implemented 
interesting notice reflective prolog implemented means computational reflection 
demonstration computational reflection low level implementation tool 
approach successful context object oriented languages including ones java meta object protocol gives object corresponding meta object instance meta class 
behavior object behavior object meta object pair 
meta level important aspects operational semantics inheritance instantiation method invocation defined 
meta object protocol constitutes flexible mean modifying extending object oriented language 
approach applied logic programming language 
addition mentioned meta class capabilities language preserves prolog capabilities manipulating clauses language provides provability predicate 
example application approach review java reflective implementations 
limitation aspects directly related objects described meta object 
properties sets objects system expressed 
authors argue non functional requirements security fault tolerance atomicity implemented reflection meta object invocation object method 
applications meta reasoning meta reasoning widely variety purposes interest new potential applications meta reasoning reflection significant 
section provide necessarily partial limited view relevant applications field 
meta interpreters seminal bowen kowalski common application meta logic computational logic define implement 
technique especially prolog probably popular logic programming language variety purposes 
basic version meta interpreter propositional horn clause programs reported 
demo demo demo 
demo demo demo 
definition names conjunction names 
theory named list containing names sentences 
propositional case formulas names may coincide problems ambiguity discussed arise presence variables 
theory represented list meta interpreter augmented additional meta axiom demo member 
instance query program simulated query demo 
alternatively possible constant symbol name theory 
case theory say defined metalevel axioms demo 
demo 
demo 
query demo 
meta axioms defining demo regarded theory named list constant say 
possible write queries demo demo means ask derive meta interpreter goal proved theory 
prolog applications theory argument omitted called vanilla meta interpreter 
standard declarative formulation vanilla meta interpreter prolog prolog counterpart indicates conjunction demo empty 
demo clause demo 
demo demo demo 
object level program add meta interpreter unit clauses clause 
clause empty 
clause empty 
query demo 
vanilla meta interpreter propositional programs programs containing variables 
case important ambiguity concerning variables 
fact variables object level program meant range usual domain program 
variables instantiated object level terms 
variables occurring definition meta interpreter intended range object level atoms 
correct approach meta variables accurate discussion problem see 
typed version vanilla meta interpreter advocated correctness proved 
suitable naming mechanisms proposed overcome problem 
untyped version generally prolog practice researchers tried specify formal account vanilla particular order logic ambivalent syntax proposed purpose correctness results obtained 
vanilla meta interpreter enhanced various ways making built prolog meta predicates allow prolog act metalanguage 
predicates fact aimed inspecting building modifying goals inspecting instantiation status variables 
aspects proof process explicit 
formalization unification implicitly demanded underlying prolog interpreter order execution subgoals conjunctions 
formulation aspects explicit 
unification performed procedure rearranges subgoals conjunction 
demo empty 
demo clause unify demo 
demo reorder demo demo 
second extra arguments added demo represent instance maximum number steps demo allowed perform actual number steps demo performed proof tree explanation returned user 
clearly definition meta interpreter suitably modified extra arguments 
third extra rules enhance behavior meta interpreter specifying auxiliary deduction rules 
instance rule demo ask 
states consider true user answers explicitly asked way meta interpreter exhibits interactive behavior 
auxiliary deduction rules may may interact 
reflective prolog specifies additional rules definition standard provability remains implicit 
example instance failure goal goal demo automatically generated example implicit upward reflection employing additional rule query user interesting approach meta interpreters binary predicate demo may answer queries uninstantiated variables represent arbitrary fragments program currently executed 
reader may refer illustration meta interpreter programming techniques applications including specification expert systems prolog 
theory composition theory systems theory construction combination important tool software engineering promotes modularity software reuse programming 
observed theory construction regarded metalinguistic operation 
european projects meta logic approaches working theories proposed 
algebra logic programs proposed defines combination object programs seen theories modules set composition operators 
provability query respect composition programs defined meta axioms specifying intended meaning various composition operations 
basic operations composing logic programs introduced encapsulation denoted union intersection import 
encapsulation copes requirement module import functionality caring implementation 
kind behavior realized encapsulation union main program module combined program intersection yields combined theory original theories forced agree deduction single partial 
operation builds module modules resulting module 
usefulness operators knowledge representation reasoning shown 
meta logical definition operations extending vanilla meta interpreter 
alternative implementations del programming language proposed discussed 
extends untyped vanilla meta interpreter 
exploits metaprogramming facilities offered language names typed variables 
second cleaner version authors suitable implementing program composition operations requiring fine grained manipulation object programs 
alloy language proposed theory system collection interdependent theories stand meta object relationship forming arbitrary number meta levels :10.1.1.50.8989
theory systems proposed meta programming software engineering methodology aimed specifying instance reasoning agents programs manipulated programs manipulate meta object relationship theories provides inspection control facilities needed applications 
basic language theory systems definite clause language augmented ground names formed expression language 
theory named ground theory system defined collection theories tools 

symbol relating theory terms sentences 
instance theory terms says theorem theory 

distinguishes function symbol means metatheory 

expressing exactly theorems 
behavior operators defined reflection principles form meta axioms suitably integrated declarative proof theoretic semantics 
event calculus representing reasoning actions temporally scoped relations years key research topics knowledge representation 
event calculus ec proposed kowalski sergot system reasoning time actions framework logic programming 
particular event calculus adapts ontology mccarthy hayes actions fluents new task description course events 
essential interesting notice fluent terminology dates back newton idea terms called names time dependent relations 
kowalski sergot write holds understood fluent true time situation calculus 
worthwhile discuss connection kowalski metaprogramming definition event calculus 
logic programming framework comes natural recognize higher order nature timedependent propositions try represent meta level 
kowalski fact considers mccarthy situation calculus comments write holds possess bob book weaker adequate bob book 
formulation possess bob book term names relationship 
second bob book atomic formula 
representations expressed formalism firstorder classical logic 
allows variables range relationships second 
identify relationships atomic variable free sentences regard term possess bob book name sentence 
case holds meta level predicate 
clear advantage reification computational point view reifying need write frame axiom inertia law saying truth relation change time specified 
negation failure natural choice implementing default inertia law 
simplified time points oriented version default inertia formulated follows holds happens initiates date ts ts clipped ts clipped ts true record event happening ts terminates validity words holds derivable interval initiation fluent time query terminating events happened 
easy see holds specialization demo 
kowalski sadri discuss depth event calculus program specified assumptions nature domain accommodated manipulating usual vanilla meta interpreter definition 
proposal number improved formalization order adapt calculus different tasks abductive planning diagnosis temporal database models legislation 
extensions applications accounted reader may instance refer 
logical frameworks logical framework formal system provides tools experimenting deductive systems 
logical framework user invent new deductive system defining syntax inference rules proof theoretic semantics 
specification executable user experiments new system 
logical framework reasonably provide tools defining possible deductive system stay certain class 
formalisms powerful meta level features strong semantic foundations possibility evolving logical frameworks 
maude system instance particular implementation meta theory rewriting logic 
provides predefined functional module meta level maude terms reified process reducing term normal form represented function default interpreter represented function application rule term 
reflective version maude proposed formalization computational reflection proposed 
meta level module flexible allow user define syntax logic language means meta rules 
new language consist addition variation basic syntax maude language 
reflection tool integrating user defined syntax proof procedure maude 
particular piece user defined syntax reflection act meta level module happens apply corresponding syntactic meta rules 
rewriting system maude evolved logical framework logic languages rewriting 
reflective computational logic logical framework evolution reflective prolog metalogic language 
implicit reflection reflective prolog semantic counterpart adding theory set new axioms called axiom schemata called 
reflection principles specify shift levels meta reasoning principles 
instance reflection principles define forms analogical reasoning synchronous communication logical agents 
originated idea generally reflection principles may express inference rules user defined deductive systems 
deductive systems specified evolutions horn clause language predefined enhanced syntax 
basic version naming provided enhanced horn clause language formalized equational theory 
specification new deductive system ds accomplished steps 
step definition naming device encoding ds 
user definition extend predefined 
leaves significant freedom representation names 
step ii defining naming convention user provide corresponding unification algorithm suitable additions predefined 
step iii representation axioms ds form enhanced horn clauses 
step iv definition inference rules ds reflection principles 
particular user required express inference rule function clauses constitute antecedent rule sets clauses constitute consequent 
theory ds consisting set axioms reflection principle theory containing obtained deductive closure set additional axioms generated 
consequently model theoretic fixed point semantics obtained model theoretic fixed point semantics generate query dynamically generates specific additional axioms usable answer query reflection principle inference rule ds 
logical agents area intelligent software agents issues require integration kind meta reasoning ability system 
fact existing formalisms systems frameworks defining agents incorporate different forms meta component 
important challenge area interconnecting agents sense necessarily uniform implementation knowledge possess behavior exhibit 
framework developing multi agent systems provide great deal flexibility integrating heterogeneous agents assembling communities independent service providers 
flexibility required structuring cooperative interactions agents creating accessible intuitive user interfaces 
meta reasoning essential obtaining degree flexibility 
metareasoning performed single agent special meta agents designed act meta theories sets agents 
meta reasoning help interaction agents user ii implementation suitable strategies plans responding requests 
strategies domain independent rely domain applicationspecific knowledge reasoning auxiliary inference rules learning algorithms planning forth meta rules meta programming may particularly useful coping aspects ontology problem meta rules switch descriptions syntactically different semantically equivalent help fill gap descriptions equivalent 
meta reasoning managing incomplete descriptions requests 
relevant examples approaches developing agent systems form meta reasoning 
open agent architecture meant integrating community heterogeneous software agents specialized server agents called perform reasoning explicitly metareasoning agent interactions necessary handling complex expression 
perform complex meta reasoning assist facilitator agent coordinating activities agents 
constraint logic programming language show capabilities complex reasoning provide interface external modules 
meta agents agent trigger meta reasoning guide planning process 
applications agents may objectives may need reason agents beliefs actions agents may take 
perspective bdi formalization multiagent systems proposed bdi stands belief desire intentions 
approach meta agents allow agents reason agents state beliefs potential actions introducing powerful meta reasoning capabilities 
meta agents specification tool efficient implementation translated ordinary agent programs plus integrity constraints 
logic programming research multi agent systems starts best knowledge kim kowalski 
amalgamation language meta language predicate theories named constants formalizing reasoning capabilities multi agent domains 
approach demo predicate interpreted belief predicate agents reason bdi approach beliefs 
effort obtaining logical agents rational reactive logical reasoning agents capable timely response external events general approach proposed kowalski kowalski sadri :10.1.1.50.8989
meta logic program defines observe think act cycle agent 
integrity constraints generate actions response updates environment 
approach agents communicate meta level primitives agent represented theory set clauses prefixed corresponding theory name 
communication agents formalized reflection principle com com 
intuitive meaning time atom form derived theory means agent wants communicate proposition agent atom consequently derived theory means proposition available agent 
objective formalization agent specify means clauses defining predicate tell modalities interaction agents 
modalities vary respect different agents different conditions 
instance program composed agents defined follows 


told 
told 
agent says ciao agent considers friend 
definition friend agents happy says ciao 
happy derived agent derived agent fact get agent dell acqua sadri toni propose approach logic agents combination approaches approach agents kowalski sadri approach meta reasoning costantini 
similarly kowalski sadri agents agents exhibit behavior 
reasoning core agents proof procedure combines forward backward reasoning 
backward reasoning primarily deliberative activities 
forward reasoning primarily reactivity environment possibly including agents 
proof procedure executed observe think act cycle allows agent alert environment react think devise plans 
proof procedure iff proof procedure proposed fung kowalski treats inputs environment agents actions hypotheses 
adapting techniques proposed agents capable reasoning beliefs beliefs agents 
authors extend approach providing agents communication capabilities 
proactive agents able communicate initiative response 
resulting framework reactive rational hybrid agents reason beliefs beliefs agents communicate proactively 
agents behavior regulated condition action rules 
approach primitives communication treated abducibles observe think act cycle agent architecture 
predicate express passive reception messages agents reception information response active request 
example taken aimed illustrating basic features approach 
ag represented abductive logic program clauses state ag may told say agent explicitly asked clause tells proactively second clause 
third clause says ag believes told 
fourth fifth clauses say respectively agent desires car free price 
integrity constraint says agent desires told agent price offer telling 
logic programming language dali indebted previously mentioned approaches logical agents 
dali introduces explicit reactive proactive rules object level 
reactivity proactivity modeled basic logic language agent fact declarative semantics close standard horn clause language 
procedural semantics relies extended resolution 
language incorporates tell told primitives integrity constraints solve rules 
observe think act cycle course implemented dali agent longer necessary modeling reactivity proactivity 
simplified fragment dali agent representing waiter pub tries serve customer enters 
customer wants request indicated arrives agent 
event triggers reactive rule indicated usual determines body rule executed 
goal computation initiated query starts reception event 
execution body reactive rule waiter checks available drinks 
waiter serves drink predicate serve drink fact action indicated 
waiter checks request expressed foreign language translation available simple example coping aspect ontology problem 
case waiter asks customer explanation expects told order try serve notice predicate translate symmetric symmetry managed solve rule 
understand behavior assume rule additional rule basic meta interpreter explicitly reported 
subgoal translate beer automatically transformed call meta interpreter form solve translate beer formally implicit upward reflection 
symmetric translate succeeds solve translate beer attempted automatically reflected object level formally implicit downward reflection 
subgoal translate beer succeeds instantiated 






ask serve 

symmetric solve 
agents interact agents external environment may expand modify knowledge base incorporating new information 
dynamic setting knowledge base agent seen set agent may change time 
agent may reach stage beliefs inconsistent actions taken regain consistency 
theory belief revision aims modeling agent updates state belief result receiving new information 
belief revision opinion important issue related intelligent agents meta reasoning usefully applied 
model diagnosis system capable revision description system diagnosed inconsistencies arise observations 
revision strategies implemented means meta programming meta reasoning methods 
framework proposed rational reactive agents dynamically change knowledge bases goals 
particular agent observations learn new facts new rules environment contrast current knowledge update knowledge accordingly 
solve contradictions techniques contradiction removal preferences sources adopted 
pointed existing approaches intelligent agents difficulties model way agents revise beliefs new information come certain meta information new information comes 
source reliable 

agent reason meta information order revise beliefs 
leads proposal new approach meta information explicitly represented reasoned revision strategies defined declarative way 
semantic issues computational logic meta programming meta reasoning capabilities mainly self possibility describing language expressions language 
fact relevant approaches object language meta language coincide 
main tool self naming mechanism 
alternative form self proposed mccarthy suggests introducing function symbols denoting concepts quoted expressions sufficient forms meta reasoning 
perlis observes word just said expression representable function refers particular word concept 
quotation necessarily involved point self describing language 
appears describe specific expressions carriers meaning concepts 
issue appropriate language facilities naming addressed hill lloyd 
point distinction possible representation schemes representation object level variable represented meta level variable representation object level expressions represented ground variable free terms meta level 
ground representation object level variable may represented meta level constant ground term 
problem non ground representation related meta level predicates prolog true variable instantiated false 
remarked see difficulty consider goals var solve solve var object program consists solely clause leftmost literal computation rule goal succeeds second goal fails 
hill lloyd propose ground representation expressions order language order language types 
definition hill lloyd ground representation 


empty contains function predicate symbols useful declaratively redefining impure features prolog vanilla 
instance constant 
constant 
constant 
var 
naming mechanism providing declarative semantics meta interpreter implements sldnf resolution normal programs goals 
approach evolved metalogical facilities del language 
notice names predicate symbols function symbols properties predicates symmetry explicitly stated 
levels del separated amalgamated naming mechanism provide operators 
important issue raised essential un naming device return quoted sentence original assertive form axioms stating naming un naming accomplish 
line approach developed detail proposes name atom form 

name name name 
name term 
name requiring names compound expressions compositional allows unification constructing name terms accessing components 
approach able express properties predicates names 
instance say predicate binary predicate symmetric asserting symmetric 
term name term expression indicates result quoting expression indicates result axioms operators formalize relationship terms corresponding name terms 
form equality theory called defined basic compositional encoding outlined 
enhanced encodings obtained adding axioms theory 
nt states exist names names term referenced times name compound term obtained names components 
definition basic encoding nt 
nt cn cn cn xk 
xk 
xk 
xk xk 
xk 
xk set axioms admits associated convergent rewrite system un 
corresponding extended unification algorithm unification algorithm ua un defined deals name terms addition usual terms 
shown proposition unification algorithm nt 
ua un standard semantics horn clause language adapted include naming device 
precisely technique quotient universes jaffar purpose 
definition quotient universe 
quotient universe finest congruence relation corresponding un exists get standard semantics horn clause language modulo naming relation 
naming relation extended application domain hand adding new axioms nt correspondingly extending un ua un provided nice formal properties preserved 
important advocated approach meta programming approach naming independent 
important observe shown ground non ground encoding providing names variables shows amalgamated language kind problems emphasized 
fact definite program object level variable meta variable 
goal succeeds instantiating proving 
contrast goal fails instantiated name say subgoal fails distinct 
choosing naming mechanisms providing names variables hand terms inspected respect variable instantiation hand important properties lost 
ground naming mechanism providing declarative semantics conservative amalgamation language meta language logic programming 
naming mechanism formed expression act name provided ambivalent logic jiang 
assumption expression interpreted formula term function predicate predicates functions free arity 
unification extended accordingly results theorem termination unification algorithm 
theorem correctness unification algorithm 
limitation ambivalent unifiers general traditional unifiers 
theorem properties resolution 
ambivalent logic proving correctness vanilla meta interpreter respect conservative amalgamation object language meta language 
object program language vp vanilla meta interpreter vp language vp mp herbrand model mvp herbrand model vp mvp herbrand model vp theorem properties vanilla meta interpreter 
vp demo mvp demo mvp demo mp demo mvp similar result obtained martens de schreye class non ground representation overloading symbols name atom term identical atom 
language independent programs characterized follows proposition language independence 
real practical interest lies enhanced 
martens de schreye extend results meta interpreters additional clauses additional arguments 
additional argument instance explicit theory argument argument denoting proof tree 
amalgamation conservative expressivity achieved 
approach proving correctness vanilla meta interpreter proposed levi uses semantics introduced falaschi 
order fill gap procedural declarative inter definite programs herbrand model program contains ground atoms atoms computed answer substitution 
semantics obtained variation standard semantics horn clause language 
levi martens de schreye prove independently demo vp iff approach reflective prolog axiom schemata defined meta level means distinguished predicate solve naming facility 
deduction performed level applicable axioms 
means drawn basic theory available implicit reflection meta level vice versa 
definition resolution sld resolution reflection independent naming mechanism provided suitable unification algorithm supplied 
definition resolution 

ak am 
am 
bq am 
ak 
bq am 
bq am solve am am 
bq selected atom am object level atom resolved ways 
usual clauses defining corresponding predicate case instance am clauses defining predicate second clauses defining predicate case ii name am am unify mgu instance referring nt naming relation defined clause solve 
selected atom am solve resolved ways 
clauses defining predicate similarly goal case 
second clauses defining predicate corresponding atom denoted argument case iii instance clauses defining predicate 
declarative semantics reflective prolog upward downward reflection modeled means axiom schemata called reflective herbrand model rmp program herbrand model program augmented possible instances reflection principles 
rmp fixed point suitably modified version operator tp theorem properties resolution 
rmp discussed meta level approach knowledge representation reasoning roots logicians played fundamental role computer science 
believe fact meta programming meta reasoning essential ingredients building complex application system 
tried illustrate broad audience main principles meta reasoning way principles applied variety languages systems 
illustrated sentences arguments sentences means naming devices 
distinguished amalgamated separated approaches depending meta expressions defined extension language separate language 
shown different levels knowledge interact reflection 
opinion choice logic programming basis metaprogramming meta reasoning theoretical practical advantages 
theoretical point view fundamental issues including reflection coped strong semantic basis 
fact usual framework order logic suitably modified extended demonstrated various existing meta logic languages 
practical point view logic programming meta level mechanisms understandable easy rise successful applications 
fact tried necessarily shortly revise important applications meta programming meta reasoning 
survey wish explicitly acknowledge fundamental deep wide contribution robert kowalski field 
robert kowalski initiated meta programming logic programming successful applications including meta interpreters event calculus logical agents 
enthusiasm constant encouragement research field researchers including 
wish express gratitude gaetano mentor research meta reasoning reflection 
gratefully acknowledge dell acqua participation research important contribution study naming mechanisms reflective resolution 
wish mention jonas interesting discussions fruitful cooperation topics 
due carlucci aiello careful review constructive criticism useful advice 
alessandro help 
anonymous referees useful comments suggestions 
remaining errors misconceptions course entire responsibility 

hill gallagher meta programming logic programming 
gabbay hogger robinson eds handbook logic artificial intelligence logic programming vol 
oxford university press 
metaprogramming logic 
kent williams eds encyclopedia computer science technology 
volume 
dekker new york 
metalogic programming 
ed years logic programming italy 

abramson rogers eds meta programming logic programming cambridge mass mit press 
bruynooghe ed proc 
second workshop meta programming logic leuven belgium dept comp 
sci katholieke univ leuven 
ed meta programming logic 
lncs berlin springer verlag 
fribourg turini eds logic program synthesis transformation meta programming logic 
lncs springer verlag 
costantini van harmelen eds proc 
workshop meta programming logic post jicslp workshop bonn germany technical report sept computing science dept uppsala univ 

apt turini eds meta logics logic programming 
mit press cambridge mass 

maes nardi eds meta level architectures reflection amsterdam north holland 
kiczales ed meta level architectures reflection proc 
intnl 
conf 
reflection xerox parc 
cointe ed meta level architectures reflection proc 
second intnl 
conf 
reflection 
lncs berlin springer verlag 
incompleteness theorem 
barwise ed handbook mathematical logic 
north holland 
diagonalization self 
oxford university press 
kripke semantical considerations modal logic 
acta philosophica 
volume 

carlucci aiello nardi schaerf modal meta languages consistency expressiveness 
apt turini eds meta logics logic programming 
mit press cambridge mass 

aiello weyhrauch checking proofs metamathematics order logic 
proc 
fourth intl 
joint conf 
artificial intelligence georgia morgan kaufman publishers 
bundy meta level inference selective application multiple rewrite rules algebraic manipulation 
artificial intelligence 
weyhrauch prolegomena theory mechanized formal reasoning 
artificial intelligence 
carlucci aiello representation metaknowledge 
proc 
ieee 
carlucci aiello levi uses metaknowledge ai systems 
proc 
european conf 
artificial intelligence 

davis buchanan meta level knowledge overview applications 
procs 
fifth int 
joint conf 
artificial intelligence los altos calif morgan kaufmann 
maes computational reflection 
phd thesis vrije universiteit brussel dienst brussel 
genesereth metalevel reasoning 
logic logic group stanford university 
carlucci aiello levi uses metaknowledge ai systems 
maes nardi eds meta level architectures reflection 
north holland amsterdam 
carlucci aiello nardi schaerf solution puzzle 
ras saitta eds methodologies intelligent systems ismis elsevier science publishing 
carlucci aiello nardi schaerf reasoning knowledge ignorance 
proceedings international conference fifth generation computer systems fgcs icot press 
genesereth nilsson logical foundations artificial intelligence 
morgan kaufmann los altos california 
russell wefald right thing studies limited rationality chapter metareasoning architectures 
mit press 
carlucci aiello nardi meta level description diagnosis intelligent tutoring systems 
proceedings sixth international peg conference peg 

carlucci aiello nardi reasoning student knowledge reasoning 
journal artificial intelligence education 
dam sio nejdl pereira schroeder model diagnosis preferences strategies representation logic meta programming 
apt turini eds meta logics logic programming 
mit press cambridge mass 

costantini dell acqua reflection principles computational logic 
journal logic computation 
meta variable prolog 
abramson rogers eds meta programming logic programming 
mit press cambridge mass 

hill lloyd analysis metaprograms 
abramson rogers eds meta programming logic programming cambridge mass mit press 
costantini dell acqua semantical properties encodings logic programming 
lloyd ed logic programming proc 
intl 
symp cambridge mass mit press 
van harmelen definable naming relations meta level systems 
ed meta programming logic 
lncs berlin springer verlag 
cervesato rossi logic meta programming facilities log 
ed meta programming logic 
lncs berlin springer verlag 
costantini semantics metalogic programming language 
intl 
journal foundation computer science 
perlis languages self foundations order logic 
artificial intelligence 
perlis languages self ii 
artificial intelligence 
konolige reasoning introspection 
maes nardi eds meta level architectures reflection 
north holland amsterdam 
genesereth introspective fidelity 
maes nardi eds meta level architectures reflection 
north holland amsterdam 
van harmelen wielinga schreiber reinders voss akkermans bartsch sp rl reflection 
enhancing knowledge engineering process contributions esprit 
elsevier science amsterdam netherlands 
carlucci aiello weyhrauch meta theoretic reasoning algebra 
volume lecture notes computer science springer verlag 
bowen kowalski amalgamating language metalanguage logic programming 
clark eds logic programming 
academic press london 
mccarthy lisp programmer manual 
levi formalization metaprogramming real 
warren ed logic programming procs 
tenth international conference cambridge mass mit press 
subrahmanian foundations metalogic programming 
abramson rogers eds meta programming logic programming cambridge mass mit press 
martens de schreye untyped nonground metaprogramming problem 
logic programming 
sterling shapiro eds art prolog 
mit press cambridge mass 

kowalski meta matters 
invited presentation second workshop meta programming logic meta 
kowalski problems promises computational logic 
lloyd ed computational logic 
springer verlag berlin 
smith reflection semantics lisp 
technical report xerox parc isl palo alto ca 
formal analysis computational reflection 
cointe ed proc 
reflection 
costantini di un interprete di horn 
mello ed proc 
th italian national symp 
logic programming bologna italian 
friedman sobel reflection oriented programming 
kiczales ed meta level architectures reflection proc 
intnl 
conf 
reflection xerox parc 
attardi simi meta level reasoning viewpoints 
shea ed proc 
european conf 
artificial intelligence amsterdam north holland 
hill lloyd del programming language 
mit press cambridge mass 

bowers gurr fast declarative meta programming 
apt turini eds meta logics logic programming 
mit press cambridge mass 

giunchiglia cimatti introspective metatheoretic reasoning 
fribourg turini eds logic program synthesis transformation meta programming logic 
lncs 
giunchiglia traverso metatheory mechanized object theory 
artificial intelligence 
giunchiglia serafini multilanguage hierarchical logics modal logics 
artificial intelligence 
costantini metalogic programming language 
levi martelli eds proc 
th intl 
conf 
logic programming cambridge mass mit press 
costantini metalogic programming approach language semantics applications 
int 
experimental theoretical artificial intelligence 
konolige autoepistemic analysis metalevel reasoning logic programming 
ed meta programming logic 
lncs berlin springer verlag 
dell acqua development interpreter metalogic programming language 
degree thesis univ degli studi di milano milano italian 
maes concepts experiments computational reflection 
proc 
oopsla 
acm sigplan notices 
kiczales des rivieres bobrow art meta object protocol 
mit press 
malenfant lapalme metaclasses logic 
proc 
ecoop cambridge univ press 
malenfant lapalme metaclasses metaprogramming prolog 
bruynooghe ed proc 
second workshop meta programming logic dept comp 
sci katholieke univ leuven 
stroud welch evolution reflective java extension 
lncs berlin springer verlag 
jiang ambivalent logic semantic basis metalogic programming van hentenryck ed proc 
th intl 
conf 
logic programming cambridge mass mit press 
jiang ambivalent logic 
apt turini eds meta logics logic programming 
mit press cambridge mass 

correctness vanilla meta interpreter ambivalent syntax 
apt turini eds meta logics logic programming 
mit press cambridge mass 

christiansen complete resolution principle logical meta programming languages 
ed meta programming logic 
lncs berlin springer verlag 
christiansen efficient complete demo predicates definite clause languages 
technical report dept computer science roskilde university 
brogi mancarella pedreschi turini composition operators logic theories 
lloyd ed computational logic 
springer verlag berlin 
brogi composing logic programs meta programming del apt turini eds meta logics logic programming 
mit press cambridge mass 

brogi turini meta logic program composition semantic issues 
apt turini eds meta logics logic programming 
mit press cambridge mass 

dell acqua basis multilevel metalogic programming language 
fribourg turini eds logic program synthesis transformation meta programming logic 
lncs berlin springer verlag 
dell acqua meta programming theory systems 
apt turini eds meta logics logic programming 
mit press cambridge mass 

shoham mcdermott temporal reasoning 
ed encyclopedia artificial intelligence 
kowalski sergot logic calculus events 
new generation computing 
mccarthy hayes philosophical problems standpoint artificial intelligence 
machine intelligence 
kowalski database updates event calculus 
logic programming 
kowalski sadri situation calculus event calculus compared 
proc 
intl 
logic programming symp 

kowalski sadri reconciling event calculus situation calculus 
logic programming 
hypothetical reasoning situation calculus event calculus 
computational intelligence journal 
az paton stimuli business policies modeling constructs definition validation event calculus 
proc 
caise 

sripada efficient implementation event calculus temporal database applications 
lloyd ed proc 
th intl 
conf 
logic programming cambridge mass mit press 
pfenning practice logical frameworks 
kirchner ed trees algebra programming caap 
lncs linkoping sweden springer verlag 
clavel eker lincoln meseguer principles maude 
meseguer ed proc 
intl workshop rewriting logic volume electronic notes th 
comp 
sc 

clavel duran eker lincoln marti oliet meseguer quesada maude metalanguage 
proc 
second intl 
workshop rewriting logic volume electronic notes th 
comp 
sc 

clavel meseguer axiomatizing reflective logics languages 
kiczales ed proc 
reflection xerox parc 
costantini formal definition sound implementation analogical reasoning logic programming 
annals mathematics artificial intelligence 
costantini dell acqua reflective agents metalogic programming 
ed meta programming logic 
lncs berlin springer verlag 
martin cheyer moran open agent architecture framework building distributed software systems 
applied artificial intelligence 
rao georgeff modeling rational agents bdi architecture 
fikes sandewall eds proceedings knowledge representation reasoning kr morgan kaufmann publishers san mateo ca 
rao georgeff bdi agents theory practice 
proceedings international conference multi agent systems icmas san francisco ca 
subrahmanian pick meta agent programs 
logic programming 
kim kowalski application amalgamated logic multi agent belief 
bruynooghe ed proc 
second workshop meta programming logic dept comp 
sci katholieke univ leuven 
kim kowalski metalogic programming approach multi agent knowledge belief 
lifschitz ed artificial intelligence mathematical theory computation academic press 
kowalski sadri unified agent architecture combines rationality reactivity 
proc 
international workshop logic databases 
lncs berlin springer verlag 
kowalski sadri logic programming multi agent systems 
annals mathematics artificial intelligence appear 

dell acqua sadri toni combining introspection communication rationality reactivity agents 
dix cerro furbach eds logics artificial intelligence 
lncs berlin springer verlag 
fung kowalski iff proof procedure abductive logic programming 
logic programming 
dell acqua sadri toni communicating agents 
proc 
international workshop multi agent systems logic programming conjunction iclp las cruces new mexico 
costantini active logic programming 
brogi hill eds proc 
nd international workshop component software development computational logic 
pli paris france www di unipi brogi proceedings index html 
rdenfors belief revision 
ed meta programming logic 
lncs berlin springer verlag 
rdenfors roth belief revision 
gabbay hogger robinson eds handbook logic artificial intelligence logic programming 
volume 
clarendon press 
dell acqua pereira updating agents 

lamma pereira agents learning valued logical setting 
ed workshop machine learning intelligent agents conjunction machine learning applications advanced course artificial intelligence greece available di fct unl pt lmp 

brewka declarative representation revision strategies 
baral truszczynski eds nmr proc 
th intl 
workshop non monotonic reasoning 

mccarthy order theories individual concepts propositions 
machine intelligence 
lloyd foundations logic programming second edition 
springer verlag berlin 
dell acqua reflection principles computational logic 
phd thesis uppsala university uppsala 
dell acqua sld resolution reflection 
thesis uppsala university uppsala 
jaffar lassez maher theory complete logic programs equality 
logic programming 
martens de schreye semantics definite meta programs non ground representation 
apt turini eds meta logics logic programming 
mit press cambridge mass 

falaschi levi martelli palamidessi new declarative semantics logic languages 
kowalski bowen ed proc 
th intl 
conf 
symp 
logic programming cambridge mass mit press 
