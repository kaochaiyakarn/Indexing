type error slicing implicitly typed higher order languages christian depaul university chicago usa wells heriot watt university edinburgh uk previous methods generally identified location type error particular program point program subtree rooted point 
new approach identifies location type error set program points slice necessary type error 
identify criteria completeness minimality type error slices 
discuss advantages complete minimal type error slices previous methods presenting type errors 
prove correctness algorithms finding complete minimal type error slices implicitly typed higher order languages standard ml 
key words type error location type inference intersection types previous approaches identifying type error locations 
large body explaining type errors implicitly typed higher order languages polymorphism haskell miranda ocaml standard ml sml 
harder monomorphic explicitly typed order languages 
partially supported epsrc gr ec fp ist nato crg nsf ccr itr sun microsystems equipment 
preprint submitted elsevier science january previous entirely satisfactory 
particular previous approaches poor job identifying location type errors 
uae type inference algorithms identify error location type inference algorithm traverses program syntax tree fails node tree currently visited blamed :10.1.1.29.4595:10.1.1.30.6846
algorithms differ eagerly check various type constraints may fail different nodes 
addition confusion caused just program node user interfaces results algorithms typically print entire program subtree node inference failed programmers may believe entire program subtree blamed root subtree 
example consider sml program fragment val fn fn val defines function function call compute list :10.1.1.46.4848
suppose programmer erroneously typed making error typing highlighted spot val fn fn val uae example error location identified val fn fn val uae designed intention blame location containing error handles bindings way fails way error 
proposed yield accurate error locations 
example identifies error location val fn fn val example illustrates general fact uae fail identify real location error 
identify node program tree participates type error wrong node adding confusion user interfaces somewhat arbitrarily identify node bit higher program tree 
example sml nj compiler numbers emits source code highlighting maintain source code location information node syntax tree manipulates internally 
appears human programmer writes syntax containing derived forms sml nj internally translates bare language running type checking 
blame 
approaches identify program subtrees include locations participate type error example uae include occurrence blamed subtree 
problem happen cases happen 
sense wrong intention may root subtree blamed nodes subtree programmer may understand distinction 
identifying node subtree program error location difficult programmers understand type errors 
choose correct place fix type error programmer find program points participate error 
find program points programmer reconstruct state type inference algorithm time failed run type inference algorithm backward 
programmer understand type inference process able run mind 
obviously mentally idea programmer save effort 
new notion type error location 
contrast locates errors single nodes subtrees syntax tree program slices 
example implementation finds error location val fn fn val correctly includes parts program changes fix type error 
importantly correctly excludes parts program changes fix type error 
occurrences highlighted differently show endpoints clash int list type constructors 
alternative erroneous slice program separately displaying small incomplete program contains type error source program type error 
cases easier programmer understand error especially error spans multiple source files 
actual output implementation style example type constructor clash endpoints int vs list 



formally type error slice set program points 
complete representation type error program points relationships program points guarantee program type error 
minimal representation program points irrelevant type error 
examples incomplete type error slices include locations returned error messages example sml nj compiler 
consist single program point point type inference algorithm detects failure 
program point form type error 
example non minimal type error slice take entire program contains type error 
type error locations produced uae algorithms viewed identifying program subtree merely node program tree view encouraged way location typically user usually non minimal 
related 
dinesh tip applied slicing techniques locating sources type errors 
techniques applicable explicitly typed languages 
approach depends fact type system expressed rewrite system techniques origin dependency tracking rewrite systems find error locations 
type inference algorithms implicitly typed languages phrased rewrite systems large part rewrite rules concern auxiliary functions unification constraint solving 
reason believe direct application dinesh tip methods results accurate location type error sources languages depending significant amounts type inference 
damas called type inference system 
damas name type system call damas system damas algorithm system set typable expressions widely known hindley milner system output match expected formalism implementation slightly richer language closer sml 
fn keyword missing sml match syntax 
bound fn match opposed case match irrelevant error 
quantified types allows multiple types type environments free variable 
seen intersection types free variables damas system seen restriction system rank intersection types 
jim proposed rank intersection types accurate type error location 
bernstein stark damas system type error debugging open terms 
wand algorithm finding source type errors implicitly typed languages 
similar methods duggan bent 
wand algorithm uses modified unification procedure keeps track constraint sets derivation unsolvable constraints 
attempt corresponding program slices constraint sets need minimally unsolvable 
related carefully designed method subroutine 
addition minimize constraint sets resulting minimal type error slices 
slices minimal sense omission program points yields non error 
johnson walz method attempts choose location blame counting number sites prefer type 
haynes study type error diagnosis simply typed language 
treat polymorphism 
propose type error locations program slices notation slices 
graph unification framework port finding minimal unsolvable constraint sets 
diagnostic unification algorithm computes single unsolvable constraint set necessarily minimal 
contrast algorithms graph running unification algorithm multiple times 
advantage approach simplicity presentation implementation 
haynes give detailed presentation algorithm enumerates minimal unsolvable constraint sets 
algorithm quickly enumerates minimal unsolvable subsets constraint set cut time limit 
algorithm expensive practice exhaustively enumerating sets solving practical cases difficult worst case time complexity enumerating sets intractable 
cases algorithm port idea may find feasible time minimal unsolvable subsets cases arise practice 
may adopt algorithm influenced sketched port 
propose constraint type inference improved type unpublished mentioned verbal communication treats polymorphism approach alternates generating solving constraints 
error messages 
treat polymorphism type system features style hindley milner system damas system addition equality constraints inference algorithm generates type scheme instance constraints 
result constraint solving order restricted 
believe simplify system permit accurate error messages removing hindley milner style features type system 
attempt compute type error slices 
mrspidey static debugger scheme distributed versions drscheme programming environment :10.1.1.22.2542
debugger set flow analysis 
constructs demand displays parts flow graphs highlights critical program points runtime errors may occur 
related type error analysis sophisticated ways automatically generating type error explanations :10.1.1.46.4848:10.1.1.43.7746:10.1.1.25.818
explanations tend complicated lengthy 
believe important accurately locate type errors display type error locations user friendly way 
understanding errors programmers typically additional semantic knowledge provided automatically anyway 
intended step direction 
outline 
section informally discusses larger examples 
remainder technical 
section introduces terminology 
section gives overview damas system methods type error slicing proceed steps 
step consists assigning constraints program points 
described section 
second step consist finding minimal unsolvable subsets set constraints 
section describes algorithms doing 
contains example worst case number minimal type error slices grows exponentially size program gives support choice enumerate error slices program 
section describes type error slices computed results obtained previous steps states completeness minimality theorem 
theorems proved appendix completeness proof straightforward expect constraints associated variable binders may get lost result slicing 
val average fn weight fn list val iterator fn sum length sum weight length val sum length foldl iterator list sum div length val find best fn weight fn lists val average average weight val iterator fn list best max val avg list average list avg list max list avg list best max val best foldl iterator nil lists best val find best simple find best acknowledgments fig 

sml program type error carlier help making web demonstration interface greg michaelson phil trinder jun yang stimulating discussions 
examples illustrate important concepts section uses example erroneous sml programs output prototype type error slicing implementation explain important concepts 
complete minimal error regions slices consider erroneous sml program 
defines functions average find best find best simple 
function average takes weight list scales list element weight computes average scaled list elements 
function find best uses average function find list highest average list lists 
function find best simple specializes function find best applying identity weight 
scaling list element identity weight leaves element fixed 
find best simple simply finds list highest average list lists 
program type error 
traditional compiler uses algorithm identify error region val average fn weight fn list val iterator fn sum length sum weight length val sum length foldl iterator list sum div length val find best fn weight fn lists val average average weight val iterator fn list best max val avg list average list avg list max list avg list best max val best foldl iterator nil lists best val find best simple find best region incomplete representation actual type error error explained pointing region referring context 
result error may fixed outside highlighted region actual fix may leave highlighted region unchanged 
trouble program confusion weight represented integer function 
body average parameter weight applied variable function 
hand line find best applied integer passed weight parameter 
prototype implementation highlights error region val average fn weight fn list val iterator fn sum length sum weight length val sum length foldl iterator list sum div length val find best fn weight fn lists val average average weight val iterator fn list best max val avg list average list avg list max list avg list best max val best foldl iterator nil lists best val find best simple find best algorithms identify line error region 
algorithm uae identify location algorithm technically type error type constructor clash function type constructor integer type constructor 
endpoints type constructor clash highlighted darker color 
prototype displays alternative representation type error location program slice irrelevant program points omitted sliced away type constructor clash endpoints function vs int 
val average fn weight 
weight 
val find best fn weight 
average weight 
find best 
type error completely explained just looking program slice 
programmer easily read explanation directly slice weight parameter average function applied argument 
weight parameter find best function passed average 
line slice find best applied integer function 
type error slice permits independent explanation type error needing refer part program call complete error representation 
slice minimal error representation omitting additional program points break explanation 
fix location depends semantics goal compilers report error regions include location fixed fix location compilers report complete error regions 
omitting program points complete region may result omitting fix location 
fix location depends intended semantics program programmer mind designing program 
clearly compiler read programmers minds 
identifying complete error regions best compiler 
illustrate point consider possible fix locations example 
possibility programmer intended weight integer function body average forgot multiplication sign 
fixed slice look 
val average fn weight 
weight 
val find best fn weight 
average weight 
find best 
highlighted inserted multiplication sign 
possibility programmer intended weight function forgot line 
case fix replace integer line identity function 
val average fn weight 
weight 
val find best fn weight 
average weight 
find best fn 
possible programmer intended weight parameter average function weight parameter find best integer 
gives rise possible fix location 
val average fn weight 
weight 
val find best fn weight 
average fn weight 
find best 
overlapping error regions case complete error regions overlap 
single fix overlapping region may fix error regions 
example consider erroneous sml program 
example line programmer forgotten turn element list 
line list replaced list 
traditional compiler uses algorithm identifies error region contain fix location region space reasons argue terms slice complete program 
sml infix operator appends lists 
val fn iterator fn list state val iterator fn list state val state iterator state list state foldl iterator nil state list val fn mod val fn list val iterator fn iterator list fig 

sml program type error identified algorithm contained identified val fn iterator fn list state val iterator fn list state val state iterator state list state foldl iterator nil state list val fn mod val fn list val iterator fn iterator list contrast shows error regions produced prototype implementation 
fix location contained regions 
display regions single picture overlapping region highlighted darker val fn iterator fn list state val iterator fn list state val state iterator state list state foldl iterator nil state list val fn mod val fn list val iterator fn iterator list val fn iterator fn list state val iterator fn list state val state iterator state list state foldl iterator nil state list val fn mod val fn list val iterator fn iterator list 
val fn iterator fn list state val iterator fn list state val state iterator state list state foldl iterator nil state list val fn mod val fn list val iterator fn iterator list fig 

overlapping error regions just error regions example complete error regions altogether 
reader invited find regions web demonstration tool 
fix location line contained regions fix line fixes regions 
informing programmer overlapping regions helps find fix location 
jump correct fix overlap 
common case hold programmer changed data representation failed fix locations creating data representation 
label fixed infinite set labels finite subsets label var fixed infinite set variables int set integers lexp lexp lexp lexp fn lexp lexp lexp val lexp lexp restriction labels occur labeled expression distinct 
fig 

labeled expressions definitions notations section defines basic mathematical notions notations 
natural number symbol denotes th projection operator xs 
xn 
xs xi 
function denotes function 
set subset denotes reflexive transitive closure 
element called irreducible respect iff element set sets min denotes set elements minimal respect set inclusion 
sets called incomparable iff subset 
definitions rewrite systems form pattern matching 
symbol denotes wildcard matched element appropriate domain 
disjoint union pattern form pat pat matched set iff sets matches pat matches pat 
usually matches pat pat way 
damas type inference system concreteness describe methodology detail small model language shown 
labels superscript expressions mark program points 
labeled expression language sublanguage standard ml sml 
implementation larger sublanguage sml 
ty ty int lexp int lexp int lexp lexp int ty lexp ty fn lexp lexp ty ty lexp ty lexp lexp ty ty lexp ty lexp ty val lexp lexp types defined follows ty fig 

damas typing rules ty ty ty ty int ty ty ity tyvar fixed infinite set type variables set finite subsets ty elements called intersection types 
symbol syntax 
example int int 
type environment total function var 
range env set type environments 
empty type environment maps variables 
damas type inference system defined 
call damas system damas algorithm differs rule expressions hindley milner system damas called type scheme inference system 
hindley milner system requires types occurrences bound variable substitution instances common type scheme system require 
damas showed approaches accept expressions 
fact variation proposition damas ph thesis 
fact closed lexp empty lexp ty iff lexp type ty sml 
system accurately locating sources type errors 
closely related systems proposed previously type error analysis separate compilation 
formally minor syntactic adjustments omitted needed translate lexp exp sml definition 
assigning constraints program points section explains type constraints assigned program points 
define function maps labeled expressions finite sets type constraints 
expression typable iff associated constraint set solvable 
function keeps track program point imposes particular type constraint 
association type constraints program points important locating type errors 
labeled constraint triple ty ty written ty ty expresses types ty ty need equal program typed constraint jointly imposed program points contained labeled constraint called atomically labeled iff element set 
initially constraints atomically labeled constraint solving arbitrarily labeled constraints get generated 
ty ty stand ty ty range set finite sets atomically labeled constraints 
range set finite sets labeled constraints 
type substitution function tyvar ty 
type substitution position expecting function ty ty implicitly lifted coerced function ty ty type ty function application ty yields result modifying ty replacing type variable occurrence ty 
solution constraint ty ty type substitution ty ty equal 
solution set constraints type substitution solves constraints constraint set simultaneously 
projection operator defined ty ty 
stand 
total function lexp env ty defined relation satisfies rules 
function variation damas type assignment algorithm term fresh variant object involving type variables denote result renaming type variables occurring fresh type variables 
define 
operation type environments defined 
define iff iff var 
facts variations propositions pages damas ph thesis 
fact suppose lexp ty 
solution lexp ty 
empty ax ax empty ax fresh fresh int lexp ty lexp ty lexp lexp fresh ty int ty int int fn lexp lexp ty ax fresh ax ty ty ax ty lexp ty lexp ty lexp lexp fresh ty ty lexp ty lexp ty 
ty ty val lexp lexp ty 
ty fresh variants ty max 

ty ty 
ty ty fresh ty fig 

algorithm lexp ty solution ty ty example consider partially labeled expression 
omitted labels irrelevant example 
lexp fn note expression obvious type error 
bound variable function integer 
formally case lexp empty type variables constraint set subset int hard see unsolvable 
minimally unsolvable proper subset solvable 
type error message implementation displays program slice contains program points associated applied declaration displays message val fn type constructor clash endpoints function vs int 
fn 


damas original algorithm variation algorithm expression result type fresh type variable equated type ty separate constraint 
additional constraints type variables vital obtaining complete type error slices 
example variable rule replaced empty ax ax ax fresh example generated constraint set mention labels 
relevant program points wrongly omitted type error location 
resulting type error slice incomplete 
fn 
expression rule copies constraint set lexp variable lexp 
bad cases number copies constraint set exponential size program 
consider example program val lexp val val xn xn xn xn xn resulting constraint set contains variants lexp constraint set 
note family expressions notorious algorithm lexp fn type scheme assumed principal type scheme entire expression contains distinct type variables 
remember hindley milner sml typability small expression language dexptime complete 
bad example fortunately involves deep nesting rare practice 
finding minimal unsolvable constraint sets define function maps sets atomically labeled constraints sets associated labels labels ty ty ty ty 
set labels called error respect iff unsolvable subset labels 
denote set errors errors 
denotes set elements errors minimal respect set inclusion 
section shows find minimal errors unsolvable constraint set 
labeled unification vital tool task 
greedy minimization algorithm unsolvable constraint set finds single element 
algorithm reasonably efficient practical purposes 
show enumerate elements 
unfortunately practical exhaustively enumerate elements set worst case size exponential size 
simple enumeration algorithm find candidates minimal errors 
candidates close minimal minimized minimization algorithm 
labeled unification 
labeled unification algorithm set state transformation rules 
rules define state transformation relation 
algorithm similar wand algorithm 
initial states form unify final states form success error 
intermediate states form unify unify state compo fn fn fn fn fn 
example sml value polymorphism restriction allows generalizing types syntactic values 
example sml expand replacing occurrence xi xi fn xi xi nents follows initial constraints considered tyvar ty environment derived bindings derived constraints bindings label label constraints currently focus attention ignores labels labeled unification algorithm just variation transformation syntactic unification instance chapter 
proposition consequence lemma 
proposition termination unify state transformation sequence terminates 
state irreducible iff final state 
define function app maps environments partial functions ty ty 
function app defined function app int int app ty app ty ty app ty app ty ty app ty ty ty ty function app partial function note app total rule size decreasing variable rule may instance occur type ty 
environments app total generated algorithms issue unimportant 
app total fact behavior function ty ty lifting ty ty substitution results app restricting domain tyvar 
case implicitly treat app substitution results restricting domain 
type substitutions composition type substitution satisfies type variables identity substitution denoted id defined id type variables type substitution called general unifier mgu iff solution exists type substitution part theorem consequence lemma 
part theorem derived lemmas 
theorem correctness unify unify success app total function general unifier unify error errors errors 
dummy arbitrarily chosen fixed label driver rules unify unify tyvar unify unify dummy unify success unify unify unification rules unify ty ty unify unify ty ty int error unify int ty ty error unify int unify int unify ty ty unify ty ty unify ty ty ty ty unify ty ty ty ty unify ty ty unify ty ty ty unify ty unify ty occurs ty unify occurs check error occurs ty occurs ty occurs ty ty occurs occurs occurs int occurs ty ty occurs ty fig 

non deterministic labeled unification algorithm ignores labels labeled unification algorithm looks standard presentations unification 
version occurs check may look bit unfamiliar 
explanation occurs ty returns set pairs form occurs ty occurrence type variable app ty function type constructors remember type constructor small model language 
occurs check succeeds iff occurs ty empty occur app ty contains pairs form equal app ty 
note transformation system non deterministic 
arbitrary choices label driver rule constraint unification rules label set associated occurs check error case unification rule 
different choices may yield different final results 
surprise label sets get returned case failure record parts histories transformation sequences 
example int int int unify error unify error 
result obtained instance constraints inspected order second result obtained instance inspected order 
note example shows unify error imply minimal 
example int int int int unify error 
result obtained instance constraints inspected order 
note inspected error discovered element return set 
case unify error 
result obtained instance constraints inspected order 
happens case error minimization 
minimization enumeration algorithms labeled unification algorithm execute multiple times different subsets initial constraint set 
minimization algorithm idea unify error error error 
follows element minimal error contained minimization algorithm exploits fact repeatedly build minimal error 
algorithm set state transformation rules 
initial states form minimize 
initial state form called nice iff errors errors 
final states form 
intermediate states form minimize ranges type substitutions 
intention minimize nice minimize minimal error contained lemma unify error errors 
proof 
suppose contradiction errors errors 
errors theorem 
standard property general unifiers 
proposition suppose mgu statements hold mgu mgu 
unsolvable proof 
suppose mgu part solution prove solvable establishing part lemma 
certainly solution definition mgu exists solves solves part mgu 
solution need find 
argumentation proof part exists solves 
solves mgu exists associativity 
lemma suppose minimize cin lin lin nice minimize cin lin lin minimize 
hold cin lin lin 
general unifier 
solvable 
solvable 
proof 
statement part proved induction length transformation sequence 
part proved induction length transformation sequence theorem proposition 
parts minimize minimize id unify error minimize unify success app unify error minimize minimize fig 

non deterministic error slice minimization algorithm proved inspection transformation rule theorem 
proposition termination minimize minimize lin lin nice 
transformation sequence starting minimize lin lin terminates 
minimize lin lin st st irreducible iff final state 
proof 
transformation sequences terminate step subsequent step decrements size label set considering arbitrary states form minimize including reachable nice initial states rules non exhaustive 
specifically third rule conceivable unify success 
show impossible states reachable nice initial states 
assume initial state reached state minimize minimize lin lin minimize assumption assume premises rule hold unify success assumption app assumption assumption contradiction unify success assumption theorem app mgu 
theorem solvable 
proposition solvable 
contradicts lemma 
lemma key correctness minimize 
lemma suppose minimize lin lin nice minimize lin lin minimize 
errors 
proof 
induction length transformation sequence 
suppose minimize lin lin nice 
case transformation sequence length case transformation sequence uses rule minimize lin lin minimize id lin lin assumption errors 
lin lin goal holds lin lin errors assumed minimize lin lin nice 
case transformation sequence length case rule transformation sequence rule 
assume reached state minimize minimize lin lin minimize assumption assume premises rule hold unify success assumption app assumption unify error assumption need show statement errors 
pick arbitrary label set satisfies premise implication errors assumption assumption goal ind hyp 
mgu lemma errors subproof lemma element error contained 
error 
follows subproof suppose contradiction hold solvable 
note subset inclusion holds chain equations holds equations follows definition second holds 
proposition follows solvable 
contradicts 
theorem correctness minimize minimize lin lin nice minimize lin lin lout lout lout lin 
proof 
suppose minimize lin lin nice suppose minimize lin lin lout 
step transformation sequence instance rule 
lout minimize lin lin minimize minimize lout unify error lemma lout lin 
show lout errors mgu lemma errors lout errors proposition remains show lout minimal 
errors lout 
lout lemma 
transformation sequence minimize requires calls labeled unification algorithm size 
worst case labeled unification algorithm takes exponential time size constraint set linear time unification algorithms exist adapted perform role 
linear time unification algorithm minimization take quadratic time size 
apply minimization algorithm label sets returned initial run labeled unification 
large input programs expect label sets small 
error enumeration 
enumerating minimal errors harder finding just 
worst case number minimal errors exponential size constraint set 
wolfram shown arbitrary constraint sets 
example shows worst case behavior comes constraint sets generated algorithm note example type polymorphism expressions 
example exponentially sized set minimal errors expression distinct minimal errors 
fn 
fn xn fn 
fn fn fn 
fn fn 
fn lexp 
lexp xn 
lexp defined lexp zk fk xk xk fk fk minimal error contains program points associated program slice 
program slice error 
fn 
fn xn fn 
fn fn fn 
fn 
sl 
sl 
xn 

sl sl 
fk xk 
xk 
program points impose type constraints 

argument type fk type xk argument type type xk addition 
minimal type error contains exactly sets program points 
fn 
fk 


fn 
fk 

forces type constraint argument type fk argument type note possibilities picking additional sets program points 
follows xn identical types 
xn typed 
error enumeration simple algorithm quickly finds number different errors close minimal 
principle practice algorithm eventually returns set minimal errors 
interrupt execution short time 
interrupted algorithm returns intermediate state contains list candidates 
candidates errors guaranteed minimal 
close minimal minimization algorithm minimize 
algorithm property finds minimal errors fast expense behaving badly hypothetical limit case 
think practice problem algorithms find minimal error slices program 
today compilers report type errors time 
report type errors programmers correct reported errors try recompile 
previously defined function satisfies equations unify success unify error min labels recursive implementation equations identical errors times 
instance unify error minimal error example algorithm behaves hypothetical limit case may find single minimal error reality time space limits breadth exploration possible transformation sequences labeled unification 
enum enum enum unify labels success enum todo enum todo unify labels error distribute todo todo enum todo enum todo def ls todo def todo ls todo distribute def fig 

non deterministic error slice enumeration algorithm contained labels gets returned recursive calls 
enumeration algorithm suffers recomputations 
reason algorithm impractical exhaustively enumerating minimal errors cases small 
algorithm essentially iterative version recurrences set state transformation rules 
initial states form enum final states form ls ls set pairwise incomparable label sets 
intermediate states form enum todo todo sets pairwise incomparable label sets 
state set contains close approximations minimal errors candidate set 
members set todo represent items need done set 
specifically label set set minimal errors contained labels need 
usually interrupt execution enum terminates error 
case elements current set get minimized returned 
proposition termination enum state transformation sequence terminates 
state irreducible iff final state 
proof 
proves induction length transformation sequence enum enum todo elements todo pairwise incomparable respect subset inclusion 
todo todo 
fix powerset labels 
todo todo 
suppose elements todo pairwise incomparable respect subset inclusion 
statements hold 
todo transformation sequence starting state enum todo terminates 
todo enum todo enum todo todo proper subset todo 
theorem correctness enum enum ls ls 
proof 
enum enum todo 
shows statements separately induction length transformation sequence elements pairwise incomparable respect subset inclusion 
min labels todo correctness follows inspection transformation rule 
slicing program defines syntax class slices 
grammar sl extends labeled expression grammar lexp additional phrase dots sls sls possibly empty finite sequence slices 
dots node slice syntax tree represents irrelevant segment corresponding program syntax tree 
experimental implementation displays dots sl sl sl instance type error slice 
sl 
sl 
sl 
fn dots dots dots computed erroneous program section displayed fn 


defines additional typing rules slices 
slice form dots sl 
sl typable type assumptions result type iff sl sls set finite sequences slices vsl dots sl slice sl sl fn vsl sl sl sl typing rules val vsl sl sl dots sls 

sl ty dots sl 
sl ty sl ty fn dots sl ty ty sl ty sl ty val dots sl sl ty algorithm sl ty ci 
fresh dots sl 
sl 

ck sl ty fresh fn dots sl ty sl ty sl ty fresh ty val dots sl sl fig 

additional rules slices sl typable 
typing rules phrases omitted expressions see 
extends algorithm need extension order formulate statement relates erroneous programs type error slices 
rule dots phrases generate additional constraints 
merely propagates recursively computed results 
rules phrases omitted exactly 
defines function slice takes label set labeled expression lexp returns slice 
function replaces node lexp syntax tree dots node label uses auxiliary function mask sls roughly speaking returns dots sls flattens immediately nested dots fly 
result flattening slice lexp immediately nested dots 
mask lexp sl slice lexp sl lexp sl lexp sl lexp lexp sl sl lexp sl lexp sl lexp lexp mask sl sl vsl lexp sl fn lexp fn vsl sl lexp sl fn lexp mask sl lexp sl lexp sl lexp lexp sl sl lexp sl lexp sl lexp lexp mask sl sl mask vsl lexp sl lexp sl val lexp lexp val vsl sl sl lexp sl lexp sl val lexp lexp mask sl sl 
mask dots sls sl dots sls mask sls dots sls mask sl sls dots sl sls mask sls dots sls mask dots sls sls dots sls sls fig 

slicing function slice constitutes phase type error slicing method 
summarize method consists phases compute type constraint set input program lexp algorithm 
find minimal error sets constraint set combination algorithms figures described section 
function compute type error slices slice lexp 
consequence completeness theorem slices computed way untypable 
theorem completeness lexp slice lexp errors 
contextually closed transitive relation slices satisfying axioms 
informally sl sl iff sl obtained sl masking sl syntax nodes 
say sl proper slice sl iff sl sl 
dots dots dots sl sl sl sl dots sl fn dots sl dots sl sl sl sl dots sl sl val dots sl sl dots sls sls sls dots sls dots sls sls axiom dots may applied expression variable binder 
instance slices sl fn 

sl fn 

sl fn 


proper slices sl 
sl fn 


note sl sl sl typable sl 
fact proper slices sl typable sl minimal untypable slice 
consequence minimality theorem slices computed type error slicing method minimally untypable way 
theorem minimality lexp bound variables slice lexp distinct sl slice lexp sl typable 
minimality theorem condition bound variables distinct needed 
see consider expression fn fn methods compute type error slice sl fn 
fn 

sl minimally untypable sl sl sl untypable 
sl fn 
fn 


sl differs sl inner variable binder masked 
causes occurrence inner function body bound outer variable binder 
expect minimality theorem precondition distinctness bound variables definition allows independent masking bound variables 
live slight cosmetic shortcoming propose convert type error slices create great confusion programmers cases 
introduced notion type error slices sets program points 
defined criteria completeness minimality type error slices explained criteria useful 
illustrated output prototype type error slicing implementation type error slices highlighting points context full program presenting incomplete program omits program points set 
algorithms type error slicing implicitly typed calculus polymorphism 
algorithms generate type equality constraints version damas type inference algorithm find minimal unsolvable subsets set generated constraints 
shown computed type error slices complete minimal 
want extend implementation type error slicing full sml improve user interface 
user interface highlight program points source code display separate type error slices 
separate slices especially useful relevant program points far apart possibly multiple files 
hyperlinks relate program points separate slice corresponding points source 
extension full sml require treatment additional issues 
instance presence equality types overloaded built operations requires additional sort constraints kind constraints type variables 
important issue explicit type annotations 
put natural boundaries type error slices 
instance library modules annotated explicit signatures module types type error slices programs library contain parts library implementation 
completeness minimality auxiliary relation appendix prove completeness minimality slicing stated theorems 
completeness minimality obvious true label sets lexp ty slice lexp ty contains variant 
unfortunately statement hold constraints associated variable binders may get lost 
take instance lexp fn 
suppose lexp ty slice lexp ty 
contains constraint labeled saying type binder equal type expression hand contain constraint labeled 
key completeness minimality minimal error contain constraints relevant error relevant constraints get lost slicing minimal error 
technical device introduce auxiliary relation closely related 
defined stating modifications rules 
lexp ty relation applied lexp non deterministically generates subsets note subsets generated 
lemma key lemma completeness minimality lexp ty cmin minimally unsolvable subset ty lexp ty cmin labels labels cmin 
variable rule replaced rules empty fresh empty ax ax ax fresh modified side condition function abstraction rule ax ty ty ax ty ty ax ty ax ty ty ax ty modified side condition expression rule ty ty modified side condition rules fig 

system modifications rules postpone proof lemma 
iff subset equal renaming type variables 
lemma key property suppose lexp ty lexp ty labels 
exists slice lexp ty labels 
proof 
induction structure lexp 
important generated environment lexp slice lexp 
reason get induction working variable binding constructors function abstractions expressions 
completeness theorem completeness lexp ty slice lexp ty errors 
proof 
suppose lexp ty slice lexp ty 
minimal unsolvable subset cmin labels cmin 
lemma ty lexp ty cmin labels 
lemma labels slice lexp ty 
unsolvable cmin unsolvable labels ty ty equal renaming type variables 
minimality modify slice order indexed finite set variables xs binder environment 
defining rules xs rules exception congruence rules 
congruence rules function bodies decrement binder environment sl xs sl fn sl xs fn sl sl xs sl val sl sl xs val sl sl congruence rules variable binders get additional side condition vsl xs xs fn vsl sl xs fn sl vsl xs xs val vsl sl sl xs val sl sl bv sl denote set bound variables sl 
lemma bound variables sl distinct sl sl sl sl proof 
proves general statement induction derivation sl sl bound variables sl distinct bv sl xs sl sl sl xs sl iff 
xs iff xs 
lemma monotonicity sl xs sl sl ty sl ty xs sl contain immediately nested dots labels labels 
proof 
induction structure sl 
theorem minimality lexp ty bound variables slice lexp distinct sl slice lexp sl typable 
proof 
suppose lexp ty bound variables slice lexp distinct sl slice lexp 
exists minimal unsolvable subset cmin labels cmin 
lemma ty lexp ty labels 
lemma exists slice lexp ty labels 
lemmas sl ty slice lexp contain immediately nested dots labels proper subset variant subset solvable minimality sl typable extension slices fact 
key lemma completeness minimality 
section prove key lemma 
define auxiliary system attaches stamps constraints 
stamps unique 
instances non uniquely stamped constraints get introduced 
firstly constraints associated variable occurrence corresponding variable binder stamp 
secondly rule expressions stamps get refreshed fresh variants constraint keep identical stamp 
stamp infinite set stamps disjoint sets 
range stamp 
stamped environment entry pair ty type ty stamp stamped intersection type object form finite set stamped environment entries 
stamped type environment function var set stamped intersection types 
stamped constraint pair labeled constraint stamp meta variables range stamped type environments sets stamped constraints 
clear context meta variable refers stamped object 
fresh variant stamped triple ty obtained triple replacing type variables fresh type variables keeping stamps fixed 
stamped system defined 
note constraints variable binders fn abstractions expressions inherit stamps environment 
note variable axiom constraint environment entry carry stamp 
def ty ty def def lemma lexp ty lexp ty 
proof 
induction derivation lexp ty 
stamps def ty ty stamps def var stamps stamps def ss range sets stamps 
ss def ty ss ty ss def ss ss def ss lemma lexp ty lexp ss ty ss 
proof 
induction derivation lexp ty 
definition stamped environment entry ty stamped constraint called stamped item 
stamped item ty say item stamp set stamped items called clique iff elements stamp 
clique clq called atomic iff forms cl cl empty ax ax empty int fresh lexp ty lexp ty lexp lexp ax fresh fresh ty int ty int int fn lexp lexp ty ax fresh ax ty ty ax ty lexp ty lexp ty lexp lexp fresh ty ty lexp ty lexp ty 
ty sn ty val lexp lexp ty 
ty fresh variants ty 

max ty ty 
ty ty sn fresh ty fig 

stamped system type variable forms called subject atomic clique 
subset set items called maximal clique iff clique clique subset proper superset 
items def items def var items items def items lemma suppose lexp ty maximal clique items elements 
set atomic cliques statements hold variant 
subject occur ty items 
proof 
induction derivation lexp ty 
lemma lexp ty cmin cmin minimally unsolvable constraint set labels stamps cmin labels cmin 
proof 
ss stamps cmin labels ss labels cmin 
obviously cmin ss need show stamped constraint sc cmin stamped constraint scl cl cl labeled denote label 
obviously assume maximal clique contains sc scl 
form described lemma 
particular variant scl sc scl scl atomic clique subject call occur scl scl 
claim scl cmin assume contradiction scl cmin 
cmin scl unsolvable cmin occur cmin scl 
contradicts minimality cmin 
proof lemma 
lexp ty cmin minimally unsolvable subset lemma stamped objects lexp ty 
min subset min cmin ss stamps min 
lemma lexp ss ty ss 
cmin min ss min ss 
lemma labels ss labels min labels cmin 
baader nipkow 
term rewriting 
cambridge university press 
:10.1.1.46.4848
explaining type errors polymorphic languages 
acm letters programming languages systems 
bernstein stark 
debugging type errors full version 
technical report state university new york stony brook 
carlier wells 
web demo type error slicing 
www macs hw ac uk ultra compositional analysis type error 
compositional explanation types algorithmic debugging type errors 
proc 
th int conf 
functional programming 
acm press 

unification source tracking application diagnosis type inference 
phd thesis indiana university 
haynes 
diagnosis ill typed programs 
technical report indiana university 
damas milner 
principal type schemes functional programs 
conf 
rec 
th ann 
acm symp 
princ 
prog 
langs 
damas 
type assignment programming languages 
phd thesis university edinburgh edinburgh scotland 
dinesh tip 
slicing approach locating type errors 
proceedings usenix conference domain specific languages santa barbara california 
duggan bent 
explaining type inference 
sci 
comput 
programming 
flanagan flatt krishnamurthi weirich felleisen :10.1.1.22.2542
catching bugs web program invariants 
proc 
acm sigplan conf 
prog 
lang 
design impl 
hage 
parametric type inferencing helium 
technical report uu cs university utrecht 
hage swierstra 
generalizing hindley milner type inference algorithms 
technical report uu cs university utrecht 
jeuring swierstra 
improving messages functional languages 
technical report uu cs university utrecht 
jim 
principal typings 
popl 
johnson walz 
maximum flow approach anomaly isolation unification incremental type inference 
popl 
kanellakis mairson mitchell 
unification ml type reconstruction 

lassez plotkin eds computational logic essays honor alan robinson 
mit press 
kfoury tiuryn urzyczyn 
ml typability dexptime complete 
th colloq 
trees algebra programming vol 
lncs 
springer verlag 
superseded 
kfoury tiuryn urzyczyn 
analysis ml typability 
acm 
supersedes 
lee yi 
proofs folklore polymorphic type inference algorithm 
acm trans 
prog 
langs 


unification substitutions type inference 
hammond davie clack eds implementation functional languages ifl vol 
lncs london uk 
springer verlag 

generalising techniques type debugging 
trinder 
milner tofte harper macqueen 
definition standard ml revised 
mit press 
conf 
rec 
popl rd acm symp 
princ 
prog 
langs 
port 
simple approach finding cause non 
proc 
fifth international conference logic programming 
mit press 
shao appel 
recompilation 
conf 
rec 
th ann 
acm symp 
princ 
prog 
langs 
trinder michaelson 
loidl eds 
trends functional programming 
intellect 
collection papers earlier scottish functional programming workshop 
wand 
finding source type errors 
conf 
rec 
th ann 
acm symp 
princ 
prog 
langs 
wolfram 
intractable problems backtracking 
proc 
third international conference logic programming vol 
lncs 
yang 
explaining type errors finding source type conflict 
trinder 
yang michaelson trinder wells 
improved type error reporting 
draft proc 
th int workshop implementation functional languages aachen germany 
draft proceedings distributed workshop containing submitted papers 
yang jun michaelson trinder 
explaining polymorphic types 
computer journal 

