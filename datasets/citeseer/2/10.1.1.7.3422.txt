ephedra java migration environment johannes martin sc northern illinois university dissertation submitted partial fulfilment requirements degree doctor philosophy department computer science 
accept dissertation conforming required standard 
dr ller supervisor department computer science university victoria dr horspool department computer science university victoria dr jahnke department computer science university victoria dr li department electrical computer engineering university victoria dr tilley department computer science university california riverside johannes martin university victoria rights reserved 
dissertation may reproduced part photocopying means permission author 
supervisor dr ller internet grown popularity years gained importance current businesses 
need offer products services web sites 
static content interactive services logic services needs programmed 
various approaches programming web services exist 
java pro gramming language implement web services run internet clients servers exclusively interaction 
java programming language standardised computing platforms matured past years popular choice implementation web services 
amount available tested java source code small compared programming languages 
risks costs program libraries preferable move core logic existing solutions java integrate java programs services web interface 
ph dissertation survey evaluate selection current approaches migration source code java 
narrow scope dissertation reasonable limit focus program ming languages source languages 
mature programs program libraries exist languages 
survey current migration approaches reveals number re disadvantages context moving program libraries java integrating java programs 
experiences survey established number goals improved migration ap proach developed ephedra approach closely goals 
show practicality approach implemented automated tool performs migration ephedra approach evaluated ii migration process result respect goals established selected case studies 
ephedra provides high degree automation migration process letting software engineer decisions multiple choices possible 
central problem migration java trans formation pointers java 
ephedra provides different strategies transformation explains applicability subject systems 
code resulting migration ephedra maintainable functionally equivalent original code save documented exceptions 
performance trade offs analysed evaluated light intended subject systems 
dr ller supervisor department computer science university victoria dr horspool department computer science university victoria dr jahnke department computer science university victoria dr li department electrical computer engineering university victoria dr tilley department computer science university california riverside iii contents table contents iv list tables list figures xi overview survey motivation 
problem 
approach 
outline 
summary 
problem definition related language conversion 
paradigm shift 
api conversion 
automated conversion tools 
dimensions migration 
summary 
iv contents survey current migration strategies integration native binary code 
byte code compilation 
re implementation 
source code transliteration 


summary 
goals improved migration approach ii ephedra approach phases source conversion 
shift object orientation 
overview step approach 
normalisation 
translation 
optimisation 
summary 
normalisation insertion function prototypes 
data type type cast analysis 
example transformation 
formalisation evaluation 
language features 
macros constants inline functions 
pointers 
summary 
contents vi translation pointer mappings problem overview 
definition terms 
kinds pointers 
classification pointer uses 
approach mapping augmented 
basic idea 
classes arrays 
classes arrays 
efficiency considerations 
approach mapping inner classes 
basic idea 
arrays 
pointers 
efficiency considerations 
untyped pointers serialisation 
style storage allocation de allocation 
summary 
translation detailed catalogue lexical conventions 
tokens comments identifiers 
keywords operators 
literals 
basic concepts 
declarations definitions 
scopes 
start termination 
storage classes 
types 
fundamental types 
derived types type names standard conversions 
contents vii float double 
floating integral 
arithmetic conversions 
pointer conversions pointers members 
expressions 
postfix expressions 
unary operators 
explicit type conversion 
arithmetic logical operators comma operator 
constant expressions 
statements 
labelled statement jump statements expression statement 
declarations 
specifiers 
enumeration declarations 
pointers arrays functions 
initialisers 
classes 
class members 
non static member functions 
unions 
bit fields 
nested local class declarations derived classes 
member access control 
special member functions 
constructors 
conversions 
destructors 
contents viii copying class objects 
overloading 
templates 
exception handling 
preprocessing 
summary 
iii evaluation implementation ibm visualage 
type cast analyser tool 
source code transliteration tool 
implementation strategy 
java asg api 
asg conversion 
testing 
tool development 
summary 
case studies conversion non trivial library function 
conversion style game program 
insertion function prototypes 
transliteration source code 
conversion program problematic type casts 
data type type cast analysis 
transliteration source code 
manual optimisation code 
conversion cpu intensive algorithms 
insertion function prototypes 
data type type cast analysis 
transliteration source code 
contents ix summary 
quality generated code readability 
conformance integration 
performance 
summary 
summary 
major contributions 

list tables dimensions migration 
glossary notations algorithm 
transformation fundamental data types ephedra 
renaming operator functions 
list figures matrices arrays 
levels re engineering 
sample program 
transliteration result 
transliteration result excerpt hand optimised 
migration 
style program 
ansi style program 
program possibly faulty return types 
program corrected return types 
example related data structures program transformation code 
inheritance detection algorithm 
conversion macros constants 
conversion pointers 
example non fatal array bound overflow 
conversion pointers 
conversion pointers pointer arithmetic 
conversion pointers 
int equivalent ephedra class 
ephedra pointer class 
ephedra interface 
xi list figures xii serialisation variables part 
serialisation variables part 
transformation declarations definitions 
transformation scoping naming conflicts 
transformation typedef 
conversion boolean arithmetic types 
explicit type conversion postfix expression 
class member access 
sizeof expressions 
new expressions 
delete expressions 
compound assignment operators 
conversion comma operator 
goto statements nested loops 
goto statements function 
expression statements 
wrapping top level declarations 
conversion local static variables 
conversion enumeration declaration interface 
conversion enumeration declaration class 
priori conversion function parameters 
conversion default arguments 
conversion ellipsis 
conversion initialisers variables fundamental types conversion brace list initialisers 
conversion incomplete brace list initialisers 
conversion nested brace list initialisers 
initialisation character arrays 
initialisation 
conversion member functions 
conversion nested class declarations 
conversion classes 
list figures xiii conversion base class initialisers 
implicit type conversions constructors conversion functions 
copy constructors assignment operators 
conversion overloaded functions 
conversion exceptions 
querying ibm visualage 
java asg api classes representing declarations 
asg counter intuitive representation 
error monopoly program 
corrected example code 
ephedra migration tool transliteration data structures ephedra migration tool analysis type casts 
transliteration code part 
transliteration code part 
manual optimisation code figures 
optimisation code 
part overview survey chapter motivation relatively short history internet shown tremendous growth number services offered number users 
survey shows percent north america population uses internet percent entire world population 
businesses realised potential internet commerce early tried attract new customers keep current customers offering services internet 
stay competitive global marketplace competitors follow suit migrate services products offer online internet clients 
applications example browsing product catalogues obtain ing account balances financial institution sufficient internet clients access data stored information systems 
soon value added services offered desirable inter net client access data information systems perform computations data 
offloading computations central servers helps keep servers available tasks 
internet client perform computations independently delays network congestion heavy loads central servers avoided improving customer satisfaction 
chapter 
internet clients commonly run part web browser 
sev eral approaches running client web browser 
java script interpreted language embedded html documents 
language large web browsers support various dialects cross platform deployment complex applications difficult 
web browsers allow called plug ins extend functionality web browser 
usually platform specific need installed client machine large heterogeneous network difficult particular software needs updated frequently 
web browsers include java virtual machine jvm allows run programs written java programming language java 
java modern object oriented programming language comes large class libraries 
jvm java standardised java programs downloaded web browser demand making simple sys tem administrators deploy update programs 
java programs compiled java byte code deployment byte code jvm run time web browser verify programs downloaded untrusted parties compromise system security 
java popular programming language writing clients distributed internet applications 
importance java growing server side distributed internet applications 
server side java applications communicate client side java applications generate html pages data gener ated applications 
java virtual machines optimised integration web servers offer performance 
java byte code stored binary format interpreted efficiently scripting programming languages popular web servers need interpreted execution time 
client server side application coded java communication client server simpler coded different programming languages possibly slightly different communi cation protocols 
chapter 
problem avoid difficult risky expensive business logic tested current legacy applications desirable integrate parts legacy applications usually written legacy programming language cobol fortran new clients servers written java 
dissertation focus integration programs written java programs 
integration successful differences java need known 
chapter explores important differences 
stem different goals designers programming languages language support low level high performance system programming java developers put emphasis security needed applications run web browsers 
chapter surveys evaluates number current approaches reconciling differences java 
particular integration native binary code byte code compilation re implementation source code transliteration approaches discussed 
remainder dissertation term refer programming languages 
want emphasise applies programming language term 
approach deem conversion source code java source code appropriate integration strategy purpose turning monolithic legacy applications distributed internet applications 
researchers familiar source code conversion formulated number requirements analyse assess importance needs chapter 
formulate coarse strategy source conversion explain detail part ii dissertation ephedra 
gain confidence strategy implemented software tested number case chapter 
studies chapters 
strategy roughly follows phases source conversion chapter 
phase normalisation source code converted ansi facilitate type checking remove obvious errors code undetected lack prototypes :10.1.1.44.9066
phase type casts data types analysed find hardware dependent code relationships data types 
relationships create class hierarchies data types eliminate java incompatible type casts 
second phase translation normalised source code converted java source code 
code optionally improved third phase optimisation 
stage process source code remains compilable ex errors introduced conversion process detected corrected early 
implemented tools support automate con version process 
part ii describes approach detail 
outline dissertation explains important differences java shows cause problems migration integration legacy programs java applications chapter 
related cial applications research contributions chapter 
chapter surveys current strategies relevant migrating integrating legacy programs java applications shows address language differences integration problems 
experiences gained survey establish goals chapter new conversion approach introduced part ii 
part iii evaluates new approach showing software implementation strategy presenting case studies conversion pro grams various application domains done implementation discussing quality code generated case studies respect goals set chapter 
open problems appli cations discussed chapter 
chapter 
summary chapter motivated need migration legacy applications internet platforms 
rough overview main problems migration java particular 
explained approach solution problems gave overview remainder dissertation 
chapters investigate main problems arise migrating programs java survey existing approaches current research migration language conversion 
chapter problem definition explained java language specification java related important differences pose problems migration java 
investigated differences comparing specifica tions java programming language java virtual machine specifications :10.1.1.26.9545
important differences preprocessor programmers include files macros avoid du code 
expanded preprocessing source code 
java preprocessor 
macros defining constants small functions cases define arbitrary code fragments syntactically complete seen independently 
difficult convert ones java meaningful way 
control flow control flow statements java equivalent exception goto statements supported java 
java allows labelled break continue statements loop statements conversion goto statements 
expressions compilers perform widening narrowing type con versions fundamental types implicitly necessary 
ex chapter 
problem definition ample explicit type conversions required assignments floating point integral variables 
java requires explicit type conver sion type conversion result loss precision 
compilers run time environments check incorrect type conversions attempted 
variable converted type compatible error goes unnoticed 
vari ables guaranteed storage contains object variables data types 
java type conversions validated compilation actual types objects unknown time verified correctness run time 
variables guaranteed objects variables data types 
allows programmer number expressions evaluated sequence result expression kept called comma expressions 
frequently macros achieve side effects 
compilers provide language extensions allow arbitrary statements included sequence 
language extensions comma expressions equivalent java 
source code language features difficult convert java 
data types java domains primitive data types guaranteed compilers platforms 
true data types 
primitive java data types signed 
pro grammer specify integral variable signed unsigned 
data types named aliased typedef directives 
equivalent construct exists java 
structured types allocated statically dynamically java allocation dynamic 
pointers contain physical memory addresses statically dynamically allocated storage chapter 
problem definition matrices arrays freely manipulated arithmetic operations java immutable 
allows type conversions primitive struc tured types type checks overridden 
java enforces strict type checking compile run time 
supports matrices arrays see 
differences overlooked experienced programmers apparent multi dimensional versions 
multi dimensional matrices fixed bounds high order dimension internally represented uni dimensional array size multiple number elements low order dimensions 
multi dimensional arrays may unbounded dimensions represented internally layers pointers 
bounds checked matrices arrays bounds known compile time 
arrays supported java 
internally represented storage containing array elements 
arrays treated structured types inherit java object class 
java virtual machine checks bounds arrays compile chapter 
problem definition run time 
order indexing multi dimensional arrays java highest order index followed lower order indices 
languages fortran different conventions 
inheritance supports multiple implementation inheritance 
java lows single implementation inheritance provides multiple interface inheritance 
memory management supports static automatic dynamic allo cation memory primitive structured types 
static automatic variables implicitly allocated deallocated dynamic variables need explicitly allocated deallocated 
con destructors executed known times allocation deallocation respectively 
java primitive variables static automatic allocated deallocated implicitly 
structured variables arrays dynamic need allocated explicitly 
constructor executed time 
deallocated java virtual machine time determined longer 
executed usually unknown time 
exceptions java support exceptions 
java methods declare exceptions may throw 
declarations optional 
java run time exceptions errors illegal storage accesses overflows detected reported java exception mech 
may caught reported operating system exception mechanisms go unnoticed 
parameterised types methods supports parameterised types methods called templates 
java direct equivalent 
java arrays achieve similar functionality cases 
chapter 
problem definition source organisation declarations definitions data types functions variables may cases sepa rated 
commonly spread source files 
namespaces allow developers logically group parts sources 
java definitions declarations 
sources organ packages classes 
physical placement source files permanent storage media follow logical package class structure software 
run time environment originally provide standard run time library 
set library functions evolved standardised 
situation similar 
minimal set standard libraries defined java 
imple java virtual machine come extended set standard libraries 
multi threading multi threading synchronisation threads supported language concepts 
implemented run time libraries language extensions 
java support threads synchronisation realised java language concepts monitors part standard library 
chapter related migrating source code java hard problem facets procedural language java object oriented language syntax semantics source code need translated paradigm shift necessary move procedural object oriented code 
sections review related software migration approaches 
language conversion realities language conversions verhoef give account experiences language conversions 
ex amples provide deal cobol systems apply instances language conversions 
argue difficulties conversions underestimated manifold emphasis put technology tools claim aid language conversion little attention paid training personnel major impact success failure migration project 
articulate number important facts source conversion candidates language conversion usually critical systems business emphasis put reliability conversion process 
chapter 
related software engineers performing conversion experts source target languages realise intricate differences languages problems arise 
converted system designed system developed specifically target programming language 
similar source target languages difficult detection differences syntactically close identical source artifacts big semantic differences 
difficult impossible go rich source language minimal target language 
verhoef list requirements met achieve successful source code conversion 
come back chapter 
propose coarse step process source conversion 
migration notes ad hoc tech niques source conversion systematic approaches 
formalises process proposed verhoef 
process description ephedra approach section 
de fines set goals source conversion identifies distinct conversion styles listed ascending order complexity dialect conversion conversion program dialect programming language dialect programming lan guage 
usually done new version compiler build system different compiler product selected 
api migration adaptation program new set apis 
occurs example different database user interface chosen information system 
language migration conversion programming language different 
may involve dialect conversion api migration 
chapter 
related observations dialect conversions cobol pl rpg domains pilot studies source conversion cobol java rpg cobol sql 
number papers describing experiences lessons learned source conversion projects 
kontogiannis report conver sion ibm compiler back pl derivative 
ya describes system translating smalltalk programs envi ronment 
presents case study automated language con version project proprietary language visual basic cobol 
cordy developed txl transformation system programming language rapid prototyping system specifically designed support com puter software analysis transformation tasks 
paradigm shift level complexity added source conversion involves paradigm shift 
growing popularity object oriented languages attempts move procedural object oriented systems 
major problems particular paradigm shift identification candidates classes members 
common approach data structures legacy system basic building blocks classes add functions operate structures methods classes 
different approach design documents subject legacy system structure charts data flow diagrams recover possible object oriented architecture legacy system 
cimitile centre identification classes persistent data stores files tables database functions candidate methods classes 
paradigm shifts may occur concurrently shift procedural object oriented code 
example flexible lax memory access scheme pointers java programming language imposes strict rules memory management 
chapter 
related conversion java paradigm shifts 
demaine developed general method converting pointers java fortran 
targets primarily scientific applica tions describes approaches converting pointers combined handle cases pointers theoretical considerations founded plausible unfortunately provide implementation show feasibility approach 
fails motivate scientific applications usually cpu intensive performance critical benefit conversion java 
demaine il code transformations small isolated examples clear complex expressions 
techniques mapping pointers similar approach 
describe commonalities differences techniques detail chapter 
api conversion api conversion happens context maintenance migration tasks 
software engineers deal api conversion regular basis adjust products new releases third party libraries products depend 
new releases libraries usually com earlier releases may depend undocumented features errors old versions libraries 
netscape gnu linux sys tems examples programs ceased correctly library upgrade 
library replaced new library completely different interface task difficult 
may necessary program moved operating system different database system 
common approach set wrapper functions conform old library interface invoke new library functions 
ibm approach easier migrate windows applications os operating system 
chapter 
related automated conversion tools products market promise help migration programming language 
reviewed selected tools deal particular problem moving source code java java virtual machine 
automated java transliteration tool 
tool simple succeeds converting constructs close java equivalents 
significant help conversion large volumes legacy code software engineer substantial manual finish transliteration 
released java proven large volumes code correctly example pgp encryption software 
mapping data types java non intuitive circumvents java security run time features garbage collection memory protection 
integration code mainstream java code quite difficult 
waddington generates java byte code source code 
allows freedom control flow java language restrictive 
mapping data types java similar generated code difficult integrate mainstream java code poses risks type checking storage protection 
dimensions migration performing migration legacy system new technology plat form usually certain trade offs respect anticipated qualities conversion process new code 
architectural re design legacy system requires certain amounts knowledge application domain 
knowledge usually re constructed source code supporting documentation experts domain 
today software engineering tools chapter 
related incapable dealing structural information pro vide little support automated re design 
software engineer required choices domain knowledge tool determine proper choice structural information 
deal large legacy systems hand high level au desirable 
impractical highly paid software engineers perform changes millions lines code 
conversion techniques transformation large volumes code need designed possibility automation mind 
higher level re design better opportunity produce source code conforms generally accepted style coding guidelines target language 
case java target language mance supports java built security safety features 
generally standards conformance supports program understanding facilitates maintenance tasks 
approaches mentioned previous sections put emphasis different dimensions language conversion 
focus high level automation ability migrate large volumes code centre architectural re design achieve high level conformance target language case java security constraints un hardware platform 
table shows aforementioned techniques fit migration space 
important note columns migration space impact cost migration long run 
sight high level automation biggest cost factor investments re design security language conformance help reduce maintainability problems long term 
summary chapter different kinds aspects source code migration language conversion paradigm shift api con version 
discussed related research areas including tools automated conversion source code java 
identified prop chapter 
related security approach re design automation language scalability conformance identification classes high varying high kontogiannis medium high medium demaine little high medium little medium high high little waddington high little table dimensions migration erties pertaining source code migration approaches characterised available tools research contributions properties 
chapter describes selection tools detail evaluates suitability integration source code java applications deployed internet platforms 
chapter survey current migration strategies main approaches integration code java 
approach java virtual machine extended code compiled native machine language target system 
section discusses approach 
second approach code compiled java virtual machine directly section converting source java 
conversion done translating data types functions equivalent java data types functions transliteration section recovering design algorithms code re implementing java section 
integration native binary code virtual machine jvm execute programs speed obtained programs compiled native machine language allow access features particular specific concrete hardware platform 
allow developers implement performance critical code native machine language computer coding assembly native compiler take advantage features hardware platform chapter 
survey current migration strategies exploited jvm java native interface jni designed 
migration code integrated java programs jni easy little modifications necessary source code 
necessary provide interface classes handle communication java parts program 
generation interfaces largely automated constitute major performance overhead run time interfaces frequently perform data type conversions 
evaluate carefully performance gain im plementation code justifies performance loss incurred interfaces 
major drawback jni loss platform independence 
code compiled native machine language particular hardware platform combined java program run particular platform 
may acceptable server applications run particular platform suitable client applications usually need run various different platforms 
code executed safe environment jvm susceptible failures security breaches prevented running control java virtual machine 
byte code compilation java virtual machine designed java programming language mind general support programming languages 
comprehensive list programming languages available jvm 
java back gcc implements compiler generates machine language java virtual machine 
appears strategy implemented way integration java programs difficult circumvents java type safety 
map memory handling run time environments java virtual machine accurately strict type checking chapter 
survey current migration strategies jvm large array allocated store variables source code 
program compiled native machine code faulty programs may cause corruption entire array causing unexpected errors difficult debug 
argue problem dealing mature program libraries occasional bug need enhanced maintained software engineering tool useful helps locating sources errors software 
problem approach special interfaces needed java code communicate code 
support routines needed build java objects raw data memory array 
jni conversions create potentially significant run time overhead 
re implementation way turn source code programming language original design documents code follow forward engineering approach re implement code documents new target language 
cases original design documents longer exist reflect real architecture functionality system lehman states laws software evolution software systems continually adapted satisfactory law continuing change 
time pressures design documents rarely kept date development code 
case current design needs recovered source code reverse engineering 
design documented implemented target language possibly refinement adaptation features target language anticipated changes 
depending degree re design desired abstraction taken different levels see 
approach taken current system maintenance performance problems large changes requirements anticipated 
number papers describe approach published 
usually parts process automated 
opdyke fowler chapter 
survey current migration strategies levels re engineering refactoring behaviour preserving reorganisation source code means architecture refinement automated 
looking automated approach suitable converting large amounts source code imminent desire change design source code pursue option focused attention source code transliteration 
source code transliteration transliteration approach original source code converted target language changing data structures program logic little possible 
various degrees change possible emulating source language data types target language data type emulation amount change kept low 
data types original source substituted data types target language code may changed deal differences data types 
explain differences approaches source code java better small sample program exhibits difficulties java migration 
particular shows pointers primitive data types structure assignments function calls chapter 
survey current migration strategies struct int struct foo int struct int goto continue goto break continue break return void bar struct struct int pi malloc sizeof int int pi foo pi sample program non primitive call value parameters 
employs goto statements comma expressions 
tool converting classes java classes 
data types control flow quite long similar java differences 
shows transliteration result example source code produced 
expects methods variables class sample code slightly modified chapter 
survey current migration strategies class int class foobar public foo int int goto continue goto break continue break return public void bar int pi malloc sizeof int int pi foo pi transliteration result chapter 
survey current migration strategies ation 
source syntactically correct java program 
fails recognise convert comma expressions goto statements 
data type conversions done trivial way usually ing address dereference operators 
fails distinguish star multiplication star dereference pointer simply removes star encounters 
expression inside malloc statement example exhibits problem 
different assignment parameter passing semantics java ignored result program different behaviour original 
flags changes comments removed increase readability programmer review correct code 
assist developer integration code java programs extensive manual efforts necessary large volumes source code 
similar source java handle 
applied successfully nontrivial programs solves problems 
control flow features supported java comma expressions goto statements 
comes large run time library providing routines typical programs require 
shows part transliteration generated 
source longer original 
logic pro gram difficult understand complex transformations applied exactly emulate behaviour original source source code shown simplified removing dead code superfluous nesting 
shares disadvantages java back gcc data structures stored large array circumventing java type checking run time security checks 
array access required operations necessary extra type conversions create run time chapter 
survey current migration strategies class sample public int int ci int cs int label int retval int ch int label break switch label case label lab sample true int cs int ci break lab sample label continue switch label case label ch int int ci lab sample ch int cs int ch label break continue int ch label break break ch int int ch int ci case continue label label case break int cs int int int int int ci retval int cs return retval 
transliteration result excerpt hand optimised chapter 
survey current migration strategies head 
code difficult read 
sense provides little advantage java back gcc debugging easier java source code available hand control flow structures may efficiently implemented compiling source code directly machine language jvm 
summary chapter surveyed java source code migration approaches introduced chapter detail 
evaluated java na tive methods jni byte code compilation re implementation strategies transliteration tools assessed suitability integration source code java 
findings helped identify prioritise goals improved migration approach describe chapter 
chapter goals improved migration approach survey previous chapter points number cies current java migration strategies severely limit usefulness migration mission critical business applications 
verhoef propose number requirements met achieve successful source conversion inventory native simulated constructs source lan guage needs built 
construct conversion strategy native simulated construct target language 
source constructs may obsolete target language target construct 
conversion strategies illustrated source target code fragments 
clarified extend target system functionally equivalent source system 
obvious errors system corrected migration 
new system compatible existing test cases 
goals migration process achieve maximum automation 
chapter 
goals improved migration approach new system maintainable 
developers familiar source system maintain target system new system structure similar existing system possibly emulated language constructs 
new set developers maintain system new code native language constructs possible 
efficiency size new system acceptable 
conversion tools times run time efficiency importance 
requirements pose questions need answered fore conversion strategies developed 
example postulates source conversion result system uses native language constructs possible emulation non native language constructs negative impact maintainability avoided 
choices appear reasonable questions answered individual conversion project requirements may vary 
project choices compatible may possible achieve total automation maximum performance complete functional equivalence possible readable maintainable code 
ephedra aimed specific source conversion project seeks provide generalised approach migrating java little freedom making choices 
prioritised follows maintainability generated code maintainable 
developers experience java maintaining code native source constructs possible 
emulation native source construct decrease maintainability code significantly 
functional equivalence generated code functionally equivalent original code 
conversion process document chapter 
goals improved migration approach possible incompatibilities 
studies shown generally cost effective prove migrated software system functionally equivalent original system example wide spectrum language wsl 
cost effective sensible ap proach define set acceptance tests migrated software system pass example current regression tests original system 
high automation aim achieve high automation rely human developers intervene automated conversions produce non maintainable code 
automated tools document problems guide developers solution 
efficiency generated code generated code signifi cantly slower code written human developer 
efficiency tools tools intended variety projects performance significantly worse compiler 
verhoef mention requirements catalogue native simulated constructs source language mappings target language built 
simulated constructs varies project project impossible provide complete catalogue ephedra 
provide partial catalogue common native simulated language constructs part ii dissertation related conversion language constructs 
part ii ephedra previous chapters pointed limitations problems current approaches integrating source code java programs requires extensive manual verification correction code 
jni java back gcc susceptible ing java type safety security result poor maintainability possibly large performance overheads 
goal ephedra approach supply better solution prob lem integrating source code java programs 
provides structured approach migrating source code java virtual machine minimising manual intervention software engineer possible guiding full automation achieved 
resulting java source code circumvent safety features java virtual ma chine easily integrated existing java programs 
emphasis approach language ephedra supports conversion commonly language elements 
chapter approach phases source conversion fundamental concepts problem solving science applies software engineering big problem broken manageable small problems 
concept provided rationale developments software engineering 
procedures procedural programming units modules modular programming classes namespaces packages object oriented programming aim reduce complexity problems solved 
source conversion non trivial problem solved providing systematic step step approach 
verhoef phase process language conversion refined expressed formally cite para graphs phases source migration keep difficulties control phases source migration 
normalisation reducing translation space 
lexical level kind source factoring essential code factor available design analysis 
normalisation chapter 
approach migration fact directed dialect conversion target dialect chosen translation step easier 
may involve api migration apis available target environment 
translation hardest step 
goal version runs target environment improved maintainable artifact optimisation 
semantics preserved factors difficult define requirement 
blind translation effective approach little support semantically intermediate stages 
optimisation similar optimisation compiler back ends improvements intended improvements reflect goals migration especially maintain able source 
probably involve removing simpli fying apis inherited source normalisation recognising improving idioms conform native style target side possibly improving software architecture 
directed dialect conversion different direction 
summarised resemblance weight lifting device taken calling model 
reminds keep balanced con weight required migrating software source chapter 
approach re engineering tasks kept ends carried single semantic framework platform integration testing software management processes place tricky task keeping ends kept narrow 
ephedra approach expressed phases phases divided sub phases 
research focused attention normalisation translation phases relying existing optimisation phase 
distribution conversion tasks phases evaluated placed best 
elimination goto statements example done normalisation phase 
lacks multi level break continue statements conversion goto statements result poor quality code 
goto statements exist java dealt optimisation phase 
translation phase obvious choice conversion 
tried keep translation phase free need user involve ment 
elimination type casts illegal java done normalisation phase needs developer choices 
conversion depend language concepts available java disadvantage doing normalisation phase 
tool support refactoring java source code 
decided delay major structural changes optimisation phase take advantage existing tools 
shift object orientation object oriented programming invented simula popular late early availability program ming languages smalltalk java :10.1.1.26.9545:10.1.1.26.9545
pro adopted object oriented ideas working non object oriented languages 
fact research continues express object chapter 
approach oriented features procedural languages 
implemen tations features may look elegant possible original front cfront written stroustrup ates code code emulates features data structures pointers subsequently compiled object code :10.1.1.26.9545
comparing source code generated cfront source code written developers procedural systems similarities data control structures 
manually convert procedural code object oriented code quite easily 
experiments question arose possible discover intentional unintentional object oriented structures code inverses mappings cfront conversion 
possible help immensely migration procedural legacy systems object oriented platforms 
performing paradigm shift procedural object oriented code experimented question 
section strategy discovering implicit polymorphism procedural code converting explicit polymorphic language concepts normalisation phase conversion process 
problem areas conversion procedural object oriented code researched overview chapter 
majority problems dealt normalisation optimisation 
tool support better java propose handle optimisation phase 
supports native java language concepts converted language concepts 
overview step approach ephedra suggests step approach conversion programs java roughly oriented migration 
sections give overview code transformations applied migration ephedra 
chapters describe steps detail 
chapter 
approach normalisation normalisation step section necessary con version style code 
kind code contain function prototypes limiting ability compiler perform type checking 
find remedy major type inconsistencies may cause problems current code necessary function prototypes inserted code 
ansi compiler able compile code step 
procedural language allows data types explicitly related composition 
object oriented languages support inheritance relationships 
second normalisation step section data types type conversions analysed find relationships implicitly code better explicitly expressed inheritance re 
code changed accordingly side effect java incompatible type casts disappear code 
step performed early programs 
obstacle conversion java multiple inheritance partially supported specific language constructs java 
wen examined multiple inheritance programs identified different categories multiple inheritance 
developed approaches convert different multiple inheritance types java java language constructs interfaces 
normalisation phase convert multiple inheritance single inheritance 
new strategies conversion multiple inheritance refer thesis wen 
adds programming language adding object oriented language features classes inheritance ing number additional language constructs particular constants 
replacing macros constants selected pointers functionally equivalent version source code produced java translation maintainable better run time performance section 
chapter 
approach transformations performed code compiled compiler verified existing test suites 
ephedra normalisation step strictly conform mi takes advantage fact closely related programming languages involves translation source code 
translation simplifies transformation tasks normalisation step involve major syntactic changes view part normalisation step 
translation translation phase source code java source code 
data structures converted classes functions con methods collected classes 
transliteration code analysed invocations storage allocation library functions converted near equivalents java language 
java source code result translation phase compiled java compiler verified existing test suites 
optimisation refactoring community developed founded strategies improv ing architecture object oriented programs 
strategies formalised algorithms implemented software engineering tools 
develop new techniques optimisation step rely existing research 
summary chapter explained approach ephedra takes con version source code java 
described phases source mi model illustrated ephedra fits model presenting overview code transformations applied phases 
chapter 
approach chapters describe normalisation translation phases detail 
chapter normalisation insertion function prototypes major styles source code kernighan ritchie designed programming language source code written style called :10.1.1.44.9066
developments extensions standardised american national standards institute 
code standard usually called ansi obvious difference ephedra significant differ ence styles function prototypes 
variables declared unknown identifier followed function call operators assumed identifier function function assumed take variable number arguments return integer value 
left programmer sure assumptions valid 
ansi developers encouraged declare functions function prototypes specify return type number types arguments 
function prototypes added source file invocation function source file 
figures show differences styles means small example program 
consistency checking function definitions function chapter 
normalisation main argc argv int argc char argv int argument argc printf usage value argv exit argument atoi argv printf square argument square argument exit square int return style program include stdio declares printf library function include declares atoi exit library functions int square int declares square function int main int argc char argv declares main function int argument argc printf usage value argv exit argument atoi argv printf square argument square argument exit int square int return ansi style program chapter 
normalisation foo return type defaults int value returned bar int foo statement valid result undefined foo program possibly faulty return types void foo states explicitly return value accordingly value returned void bar int foo compiler correctly flags statement error foo valid statement program corrected return types left programmer risk introducing errors 
increase chances successful migration java important eliminate sources errors 
step ephedra migration approach program written style converted ansi style 
free software foundation gnu compiler collection gcc comes tool automates conversion 
improve readability correctness source code return types functions checked 
return type specified prototype function compiler assumes integer 
programs default formal return type functions return value 
modern compilers detect flag discrepancies aid software engineer locating code needs change 
figures show annotated example 
chapter 
normalisation data type type cast analysis object oriented programming languages greatly facilitate reuse providing generalisation specialisation features inheritance 
pub mentioned chapter show identify distinct classes system take advantage generalisation specialisation fea tures provided target programming language 
worthwhile examine commonalities relationships structures legacy system exploited design inheritance hierarchies target system 
type casts unrelated structures program model generalisation specialisation features procedural code 
type casts pose problems trivially java type casts data types related inheritance prohibited java 
stricter type checking performed run time prevent objects cast class type instantiate 
migrate program java successfully type casts removed data structures involved type casts changed implicit relationship explicit 
section shows problematic type casts data structures involved identified 
section presents algorithms automate process 
section tool shown implements algorithms suggests changes data structures type casts admissible java program 
example transformation sample code shows simple example program distinct data struc tures type casts express specialisations data structure 
spe data structures manager worker contain fields base data structure employee additional fields 
point ers variables type manager worker allocated state variable initialised identify variables run time type 
pro chapter 
normalisation enum worker manager struct employee int char name char extension struct manager int char name char extension int struct employee struct worker int char name char extension struct manager manager void struct employee printf name switch case worker struct worker struct worker printf managed manager name break case manager struct manager struct manager printf manages employees break example related data structures program chapter 
normalisation gram accesses variables pointers type employee general pro cessing 
computations particular specialised data structures program determines run time type variable state variable casts pointer specialised type manager worker 
large number similar techniques express tions generalisations 
cases specialised data struc tures contain base data structure containing fields 
data structures padded extra variables ensure size 
cases unions group related data struc tures 
cfront front class hierarchy data structures similar ones example 
identification inheritance typical approach converting java transform structures java classes functions static member methods java class 
approach followed example resulting java program compile type casts function illegal java structures involved type casts related 
better solution migration problem needs 
simi larity data structures examples type casts suggest closely related 
domain knowledge supports obser vation managers workers employees 
suggests target classes modelled way explicitly states relationship inheritance 
shows transformation example classes related inheritance 
employee structure continues contain fields general data structure manager worker structures inherit fields employee redefining 
code transformed java converting data structures java wrapping function class 
remaining type casts legal java 
chapter 
normalisation enum worker manager struct employee int char name char extension struct manager public employee int struct employee struct worker public employee struct manager manager void struct employee printf name switch case worker struct worker struct worker printf managed manager name break case manager struct manager struct manager printf manages employees break transformation code chapter 
normalisation formalisation evaluation algorithm algorithm formalises transformation 
abbreviations primitive operations artifacts subject system source code algorithm explained table 
type casts non primitive data structures program analysed step 
algorithm iterates relevant type cast expressions records relations source target data structures 
mentioned section cases extra variables pad data structures size 
algorithm checks fields data structures referenced program step 
padding fields algorithm identifies fields longer program help detection errors code fields really referenced removal dead code fields longer needed 
groups related structures identified analysis type casts transformed class hierarchies base classes containing common fields sub classes containing specialised fields 
fields program included classes built step 
example fields considered common data structures type name position data structures 
definitions common fields possible fields names phonetically semantically compared compatible identical field types considered criteria commonality 
efficiency considerations dealing algorithms large software systems important consider computational complexity algorithms sure perform adequately average software engineer workstation 
algorithms introduced examined chapter 
normalisation set type cast expressions involve non primitive types 
typeset set non primitive types defined 
set field access expressions field access expression algorithm refers expression denotes field structure name name 
ce destination type cast expression ce 
ce source type cast expression ce 
fe field field involved field access expression fe 
set fields type true field referenced 
set types contain completion algorithm non primitive types type cast 
set types contain completion algorithm non primitive types type cast 
function returns set common fields types set function returns set types set related type casts determined steps algorithm 
function returns subsets set mem ber types share fields fields set member member exactly returned possibly element subsets function creates class containing fields set base class function creates class type fields name type base class table glossary notations algorithm chapter 
normalisation step analyse type casts typeset ce add ce ce add ce ce step check fields structures typeset false fe fe field true step build class hierarchy typeset null proc base fields base base inheritance detection algorithm chapter 
normalisation perspective definitions cn complexity algorithm number type cast expressions non primitive types number field access expressions number structured data types maximum number types set related structured types step algorithm examines type cast expression program ex 
type cast non primitive data types data type added sets data types 
assuming complexity log insertion element set leads statement log experience legacy systems examination object oriented class libraries suggest number data types set related data types relatively small rise significantly subject system grows 
logarithmic expression replaced constant step algorithm sets flag field access expression 
step algorithm iterates sets related types subsets 
data structure member exactly sets subsets algorithm processes data structure exactly 
chapter 
normalisation adding sub complexities conclude complex ity algorithms depends linearly size subject system number lines code language features macros constants inline functions lacking appropriate efficient way define constants pro gram programmers preprocessor macros purpose 
macros source code created difficulties software engi neering tool developers macros expanded separate step lexical semantical analysis source code repre sented syntax trees 
software engineering tools operate syntax trees similar constructs handle macros properly provide views subject systems macro sub applied 
ephedra source code translation tool shares disadvantage 
constant defined macro translation tool see con stant name syntax tree processes 
sees value 
recommend conversion constant definitions macros constant definitions constant variables shown 
string constants conversion side effect con code copy string exists memory saved 
macro definitions represent small functions replaced line functions possibly templates type parameters unknown 
chapter 
normalisation original code define maximum define message hello improved code const int maximum const char message hello conversion macros constants pointers introduces new language feature 
regarded immutable pointers 
lacking appropriate way pass variables pointers purpose programs 
distinguish uses pointers call parameters purposes improve maintainability code 
ephedra pointer mapping strategies efficient pointers 
obtaining maintainable code pointers improve performance migrated code 
illustrates uses pointers transformed 
find pointers function function body needs analysed determine value pointer changed passed parameter function assigned pointer 
summary chapter introduced normalisation step ephedra approach 
discussed source code conversions performed original code translation java 
particular explained conversion source code written style ansi analysis utilisation type dependencies code improvement legacy code language features 
chapters describe translation step ephedra 
providing complete catalogue source conversions chapter transformation techniques related conversion pointers chapter 
chapter 
normalisation original code call parameter conversion possible void int improved code call parameter conversion possible void int call call conversion possible conversion possible int product int factors int int product int factors int int result factors int result factors result factors result factors return result return result conversion pointers chapter translation mapping strategies pointers java back gcc embed structures vari ables large integer array 
pointer operations arithmetic easy intuitive accessing data mainstream java programs difficult data easily corrupted error code 
ephedra takes different approach maps structured data types corresponding java classes 
necessary pointer arithmetic emulated member functions java classes 
accomplished circumventing java storage allocation memory protection schemes 
errors code result java run time exceptions easily identified 
developed independent strategies mapping pointers java 
methods emulate semantics pointers java includ ing pointer arithmetic untyped pointers non fatal array bound overflows see section definition terms 
method suited programs create small amount large data structures best suited applications create large arrays small data structures fundamental types scientific algorithms 
chapter 
translation pointer mappings problem overview java distinguishes primitive types 
primitive types arithmetic boolean types provided java 
types system provided user defined classes 
variables primitive types contain primitive values variables types contain ref erence object class subclass class 
variables primitive types passed value variables types passed 
pass variables primitive types variables need wrapped classes 
java provides number wrapper classes values objects classes immutable 
ephedra provides wrapper classes mutable 
variables primitive types program passed address taken need converted variables corresponding wrapper types 
accesses variables need transformed wrappers fields accessed initialised respectively 
definition terms discuss approaches mapping pointer java need define terms related pointers 
untyped pointers pointers usually typed declaration includes indication kind variable point 
untyped pointers pointers point various different kinds variables 
frequently declarations standard library functions functions accessing permanent storage de vices 
pointer arithmetic mentioned section additive operators manipulate address stored pointer change storage destination pointer referring 
additive operators pointers called pointer arithmetic 
chapter 
translation pointer mappings int pi int malloc sizeof int pi 
example non fatal array bound overflow non fatal array bound overflows performing array traversals pointers described section necessary compute storage addresses refer storage allocated particular variable application 
theoretically array bound overflow condition 
long storage accessed overflow condition raise exception non fatal 
illustrates scenario 
loop terminated pointer pi point storage location outside allocated storage area 
storage accessed error 
programmer scenario may appear trivial 
see requires special consideration mapped java 
kinds pointers pointers arrays describe similar artifacts program discuss chapter 
describe characteristics differences pointer variables hold address storage area 
additive operators modify address 
additive operation performed address pointer incremented decremented multiple size pointer base type 
difference pointers type defined difference addresses point divided size base type 
chapter 
translation pointer mappings variables hold address storage area 
addresses specified definition immutable definition 
uses slightly different syntax referring pointers 
arrays allocate area storage hold specified number values base type 
array variables subscript operators yield address storage area pointer 
immutable 
supports multi dimensional arrays 
treated dimensional arrays size equal product dimensions sub arrays 
subscript operators defined pointers arrays follows refers pointer array variable expression yielding integral value 
addition operator functions way described pointer variables 
described similarities slightly different concepts regard arrays special cases pointers conversion problems immutable pointers arrays immutable pointers definition allocates storage certain number objects 
compilers assure arrays modified program code take measures guarantee immutability converted arrays 
classification pointer uses investigating programs find common uses pointers access programs address variable may taken provide part program handle storage area 
frequently done function calls programs 
subroutine able modify storage control chapter 
translation pointer mappings calling routine calling routine passes address storage call copy storage area call value 
array traversals aforementioned similarity pointers arrays programmers pointers elements array tra verse arrays incrementing pointers 
usually efficient traditional array traversal array indices address element computed access element pointer incremented 
dynamic memory pointers access dynamically allocated memory 
polymorphism discussed section limited built support polymorphism programmers pointers achieve similar effect programs 
communication operating system libraries operating sys tem routines example disk storage access expect provided address application storage read write data 
programs frequently untyped pointers pass addresses operating system routines 
violation type conversion rules programs take advantage internal representation certain types achieve purpose 
example program determine modify exponent part floating point number address number evaluating storage address 
way floating point numbers stored application storage usually differs different hardware platforms programs techniques portable 
pointers purposes recom 
modern optimising compilers may generate code unexpected behaviour techniques 
chapter 
translation pointer mappings approach mapping augmented basic idea approach java classes derived data structures assume number additional properties perform functions original data structures pointers data structures 
pointers source code replaced new java classes 
talk augmented additional properties generated java classes allow java emulate behaviour pointers 
ephedra defines pointer class provides functions emu pointer operations classes arrays 
pointer class serves replacement untyped pointer type void 
class array extends pointer class emulate pointer operations classes occur array elements original code 
primitive types java classes ephedra defines wrapper classes types provide consistent approach 
classes contain field called value primitive type represent 
accesses value variables converted primitive types wrapper types changed access value field converted variables 
variables see section initialise value allocate storage 
wrapper classes extend ephedra array class allow primitive types members arrays 
special wrapper class wraps variable type pointer 
pointers pointer types original source code converted class 
mapping approach similar demaine block model 
contrast demaine block model approach supports pointer arithmetic hard requirement real world programs 
chapter 
translation pointer mappings classes arrays shows example pointers conversion java 
java code contains excerpts ephedra predefined pointer class integer wrapper class eint 
comparisons pointers converted comparisons java shown method pointer 
classes occur members arrays original source code possibly subjected pointer arithmetic 
call method pointer raises exception 
classes arrays ephedra array class defines fields java array arrays index array 
class element type array explicitly dynamic storage allocation new malloc source converted subclass array class 
fields initialised depending storage allocated variable original source allocation storage object converted code allocates stor age java object 
fields object inherits array initialised zero null respectively 
allocation storage multiple objects converted code allocates storage array large hold objects storage objects 
array elements initialised objects 
fields objects inherit array initialised contain array index object array 
fields defined array class pointer arithmetic emu lated java code 
illustrates conversion slightly simplified way 
note java code raises run time exception program tries determine difference pointer variables distinct chapter 
translation pointer mappings original code class void foo int void void int foo transformed code class pointer public pointer int throw new java lang non zero array index single object array return public int pointer throw new java lang attempt get distance unrelated pointer objects return public boolean pointer return public final boolean pointer return public final boolean pointer return final class eint extends pointer public int value public eint public eint int value value value protected array pointer src value eint src value return class extends pointer void foo eint 
eint new eint new value foo conversion pointers chapter 
translation pointer mappings original code class 
increment pointer compare pointers int transformed code class array array int class extends array 
increment pointer length handle boundary condition compare pointers throw run time exception int conversion pointers pointer arithmetic chapter 
translation pointer mappings arrays 
behaviour original code result undefined 
code computes difference contain error ephedra aborts computation 
java transformations code frequently consist statements expressions code appears example put methods array class replaced calls methods 
improves readability converted code keeps size closer size original code 
member methods handle boundary conditions example pointer may point memory location just outside storage area allocated array non fatal array bound overflow 
long storage accessed constitute error 
methods array class create auxiliary objects handle boundary conditions necessary 
classes pointers form unit mapping approach pointers share type hierarchy associated classes 
type casts pointer types base types related inheritance original code mapped type casts java classes related inheritance 
legal correctly mapped java 
type casts typed untyped pointers translate correctly ephedra pointer class superclass classes involved type casts translation untyped pointer type void 
efficiency considerations mapping scheme produces readable code pointers data structures performance satisfy expectations cpu intensive algorithms involving large arrays fundamental data types 
requires object created array element array array fundamental types 
significant run time overhead creation objects accessing members objects significantly slower accessing primitive java variables 
problem prompted develop different approach translating pointers suited applications kinds arrays 
chapter 
translation pointer mappings approach mapping inner classes basic idea alternative mapping scheme unique java class created pointer type original program 
class implemented inner class class representing type pointer refers 
approach similar demaine improved conversion 
contrast conversion strategy approach supports untyped pointers needed program uses standard library 
arrays java arrays powerful emulate arrays refer ences approach 
special functionality imple mented transformed data structures code uses arrays pointers 
wrapper classes primitive data types need extra methods allow array elements passed illustrated 
approach transformation simple expressions require lines java code code wrapped member functions appropriate classes improve readability transformed source code 
conversion benefits earlier transformations source code replaced certain pointers see section 
pointers pointer data structure declared source code ephedra defines inner class corresponding java class responsible emulating pointer semantics 
class defines fields containing array class elements index array 
defines number member functions manipulating fields 
shows class inner class previously shown pint class represents int type 
classes representing chapter 
translation pointer mappings original code class void foo int int foo transformed code final class pint public int value public int index public final pint set int src value src index return public final pint int offset index offset return class void foo pint value index int new int new int temp temp temp temp new foo new pint set conversion pointers chapter 
translation pointer mappings pointers defined equivalent interface 
casts different pointer types original code participating pointer classes need extend ephedra pointer class shown appropriate extension class 
set method invoked type cast pointer types need performed 
efficiency considerations second approach map pointers performs better large arrays primitive types approach verify case studies section 
possible performance bottlenecks 
close look method class shows new object created post increment operation 
creation objects costly operation java virtual machines lead performance degradation 
programs post increment expressions occur isolated side effect incrementing counter result previous value counter discarded 
post increment expressions converted pre increment expressions improve performance java program 
untyped pointers serialisation untyped pointer type void standard library routines pass blocks storage parameters 
reading writing permanent storage devices example 
ephedra implements serialisation methods data types directly parameters indirectly fields directly indirectly involved classes involved calls functions requiring void parameters 
purpose ephedra defines interface 
provides methods determining size data types bytes reading writing contents data type byte arrays passed java library functions dealing disk access similar operating chapter 
translation pointer mappings public final class pint public static final class public pint value public int index public value null index public final pint get int offset return value index offset public final set pint src value new pint value index src return public final set pint src value src index return public final set src value src value index src index return public final reset value null index return public final int offset index offset return public final int offset temp new set index offset return temp int equivalent ephedra class chapter 
translation pointer mappings public class pointer public int public object public pointer set pointer src public final class pint public static final class public final int return index public final object return value public final pointer set pointer src value pint src index src return ephedra pointer class chapter 
translation pointer mappings public interface public int public int byte bytes int public int byte bytes int system functionality 
ephedra interface figures illustrate classes implement inter face 
primitive data types appropriate wrapper classes assume responsibility implementing serialisation methods 
perform serial methods library functions determine variable primitive type invoke appropriate se routine wrapper class primitive types java class corresponding original data structure 
style storage allocation de allocation opposed provide new delete operators 
standard library functions malloc free allocate de allocate storage 
converting calls library functions ephedra transforms calls calls appropriate opera tors converts operators previously shown 
tal structured data type expression malloc converted new followed loop allocate storage array element 
new expression loop statement wrapped method improve readability code 
multiple original code possibly incorrect 
ephedra conver sion shown rounds size memory block allocated 
java virtual machine raise exception memory outside block accessed way assist developer discovering error 
chapter 
translation pointer mappings original code class public int class public int transformed code class implements public int public static final int pint public static int byte bytes int pint bytes pint return public static int byte bytes int pint bytes return public int return public int byte bytes int return bytes public int byte bytes int return bytes serialisation variables part chapter 
translation pointer mappings original code class public int class public int transformed code class implements class extends implements private int public static final int pint public static int byte bytes int bytes pint bytes pint return public static int byte bytes int bytes pint bytes return public int return public int byte bytes int return bytes public int byte bytes int return bytes serialisation variables part chapter 
translation pointer mappings summary chapter discussed pointers particularly difficult problem conversion source code java 
giving general overview problem defining terms important understanding point ers explained different kinds pointers supported programming languages 
classification pointer uses programs described methods transforming code involving point ers java 
method suitable programs pointers data structures second efficient programs involving large arrays fundamental data types 
concluded chapter discussing transformation serialisation storage allocation 
realised pointers translation depends transfor mation pointers 
chapter illustrates transformations ephedra uses convert remaining language constructs java 
chapter translation detailed catalogue translation step ephedra approach source code improved corrected normalisation steps java source code 
primary goals integration generated code mainstream java programs readability generated code compliance java object model critical issues 
java quite similar parts original program transformed trivially changing syntax 
complicated transformations needed conversion structured type declarations initialisers expressions involving pointers 
sections catalogue source code transfor mations performed ephedra convert source code java source code 
organisation catalogue follows manual language :10.1.1.26.9545
paragraph manual show transformation source artifact defined paragraph corresponding java code 
catalogue explains parts language ephedra provides transformations lists parts language currently handled ephedra 
heading sec tion provides paragraph manual describes particular source artifact 
paragraphs skipped chapter 
translation detailed catalogue discussed context related paragraph 
transfor mations illustrated code examples 
code examples show complete code code excerpts illustrate code transformations 
essential part transformations access specifiers enclosing classes methods usually omitted 
pointers arrays occur code examples second approach mapping point ers java 
section describes ephedra tool automates transformation generate valid java program 
appropriate mention transliteration approaches particular handle specific conversion tasks 
lexical conventions programs consist files translated phases 
declarations definitions spread files 
phase translation preprocessor performs file inclusion macro substitution generate sequence tokens called translation unit 
translation unit contains complete declarations possibly defini tions artifacts 
java programs consist files constitute translation units 
preprocessing performed source file contain complete declarations definitions 
classes interfaces top level declarations allowed declarations need members class interface 
convert program java translation units need gathered 
top level declarations classes need wrapped classes 
classes need written files 
widely accepted convention java programmers put public class non public classes associated source file name source file public class 
ephedra follows convention 
classes public java code resulting transformations contain public classes 
java source file contains exactly class public definitions inner classes regardless public chapter 
translation detailed catalogue part definitions enclosing classes java 
tokens comments identifiers lexical structure java source files similar 
consist stream tokens identifiers keywords literals operators separators 
comments may appear tokens format java 
set possible identifiers subset set possible java identifiers transformation necessary identifier java keyword see 
keywords operators java keywords similar java defines keywords program uses identifier conflicts keyword java identifier changed 
ephedra adds underline character identifier 
creates conflict identifier modifications 
java keywords valid identifiers boolean byte extends final implements import instanceof interface native null package super synchronized throws transient minor differences operators supported java 
explained sections expression transformations 
literals minor differences representation literals java source files 
integer constants allows specification precision 
java allows specification precision 
conversion difference causes problems unsigned integer constants chapter 
translation detailed catalogue larger largest java integer constant 
ephedra propose general solution problem suggests developers inspect code question 
character string literals specified similarly 
java allow hexadecimal escapes restricts octal escapes literals need checked java compliance possibly rewritten 
wide characters transformed java unicode characters 
basic concepts declarations definitions differentiates declarations definitions 
declarations introduce names program 
definitions provide implementation details named artifact 
artifacts declared times program defined 
compiler gathers matches declarations def source artifact generate code 
java declaration place definition source artifact import package declaration 
conversion declarations definition gathered matched written java declaration shown 
scopes scoping rules identical java 
enclosed blocks code declare name declared enclosing block function hiding declaration enclosing block 
allowed java 
declarations enclosing block renamed 
resolve naming conflicts arise different scoping rules java 
resolve conflicts fact renames variables transliteration difficult developers know original code recognise code 
defines file scope 
name declared outside blocks classes chapter 
translation detailed catalogue original code point class point int public int getx int gety point cc include point int point getx 
int point gety 
transformed code point java class point private int private int public int getx 
public int gety 
transformation declarations definitions file scope 
closest equivalent java package scope 
class interface declarations allowed java package scope 
ephedra wraps non class declaration file scope class 
class placed package name derived name namespace declaration defined 
declaration defined global namespace ephedra creates auxiliary name package 
handle namespaces wraps top level non class declarations class declaration encounters source code 
creates wrapper class compilation unit 
start termination program contain function called main 
function nated start program 
usually passed parameters specifying number contents command line arguments passed program 
java class may contain function called main 
passed array strings parameter 
java virtual machine instructed start java program main function particular class pass command line arguments 
ephedra creates java main function transforms array strings chapter 
translation detailed catalogue original code foo method defined top level scope int foo int 
new definition hides previous int 
transformed code foo java package foo package method wrapped class class foo public int foo int 
variable renamed avoid naming conflict int 
transformation scoping naming conflicts data structure acceptable transformed main function transformation rules functions subsequently transfers control function 
similar technique 
handle conversion main function 
java programs terminated calling standard library exit function 
abort function terminates program abnormally 
equivalent java system exit function 
possibility throw special exception 
storage classes java support local variables automatic storage class 
auto matic variables initialised time control flow reaches definition destroyed exit block 
local variables function may declared static storage class 
opposed automatic variables initialised run time program retain value invocations function 
local variables java method automatic 
ephedra transforms static variables function static variables enclosing chapter 
translation detailed catalogue class 
named unique way avoid conflicts variables 
section describes transformation detail 
types fundamental types java provide void type specifies empty set values 
transformation necessary 
defines number integral types char short int long 
depend ing compiler implementation variables type char signed unsigned 
variables integral types signed 
integral variable changed declaration prefixing type name keyword signed unsigned 
char type large store member compiler implementation basic character set size byte 
sizes integral types implemen tation dependent short type guaranteed larger int type long type guaranteed smaller int type 
provides float larger identical double data types floating point arithmetic 
implementations define boolean type bool wide character type integral type long long larger long third floating point type long double smaller double 
java defines integral types byte char short int long 
char signed equivalents opposite 
char integral type intended arithmetic operations storage unicode characters 
sizes types exactly defined variables type byte hold values char short int long inclusive 
java provides single precision bit double precision bit floating point types values operations conform ieee standard 
chapter 
translation detailed catalogue difficult choose transformation integral data types particular characteristics implementation dependent transforming unsigned data types java char type signed data types java short type achieve transformation conforms definition language 
current programs depend int data type larger java short data type fail conversion 
java discourages char data type arithmetic favours signed integral data types 
data type java data type void void char bool bool signed char byte unsigned char byte signed short short unsigned short short signed int int unsigned int int signed long int unsigned long int signed long long long unsigned long long long float float double double long double double table transformation fundamental data types ephedra chose transform integral data types displayed table 
integral data types transformed signed java data types achieve maximum conformance java cod ing standards 
automated transformations developers informed chapter 
translation detailed catalogue places transformations unsigned signed data types formed check code depends boundary conditions longer met 
developers usually need thorough knowledge code proper assessment 
decided transform character arrays strings java string stringbuffer data types 
programs pointer arith manipulate character arrays 
java string stringbuffer data types manage strings different way character arrays conversion complicated probably require manual intervention 
considering conversion character arrays involve pointer arithmetic java string data types version ephedra 
means reducing amount manual labour required source conversion verhoef suggest data type emulation original unsigned data types emulated classes java instrumenting code operating data types 
advantage conversion fully automated need developer understand original code validate conversion 
rejected option conversion fundamental data types improve performance readability generated code language conversion long term investment emphasise maintainability 
perform similar transformations 
convert unsigned data types closest signed java data type informing developer change 
uses larger data types performing comparisons unsigned data types ensure comparisons yield right result 
unsigned long data types integral java data type larger long 
similar ephedra uses byte arrays store character strings 
contrast converts java char string data types 
chapter 
translation detailed catalogue derived types type names java support definition derived types 
transformations discussed detail sections 
fundamental derived types additional names typedef mechanism 
equivalent java 
transformation additional names type need changed refer original names original data type unnamed 
case exactly additional names name unnamed data type 
shows example transformation 
original code typedef int integer typedef struct typedef struct 
integer transformed code class class int transformation typedef discards typedef declarations conversion java 
conversion typedef structured type declarations visible java code 
semantics hidden java source code statements access designated storage area 
chapter 
translation detailed catalogue standard conversions float double java conversion precise equally precise floating point type change value converted 
conversion precise precise floating point type implementation dependent 
value may rounded 
value range precise type result undefined 
java rounds zero 
value range precise type result positive negative infinity 
conversions implemented java conflict ones transformation necessary 
floating integral conversion floating point types results conver sions involving boundary conditions undefined implementation specific 
java defined 
moving java transformations necessary java implementations conversions contradict language specification 
arithmetic conversions expressions involving binary operators java implicitly convert operands matching data types 
conversions smaller data types transformed larger 
cases involving operations signed unsigned data types operands trans formed data type larger 
decided transform data types signed java data types conversion apply converted code 
require arithmetic types converted explicitly boolean types required returned operators statements vice versa 
arithmetic zero value considered boolean false non zero arithmetic values considered boolean true 
boolean false implicitly chapter 
translation detailed catalogue converted zero boolean true implicitly converted 
java allow implicit explicit conversion types special expressions conversion required 
shows example 
original code int bool transformed code int boolean true false conversion boolean arithmetic types pointer conversions constant expression evaluates zero converted pointer commonly called null pointer implicitly necessary 
conversion illegal java done explicitly 
java provides null keyword represent null 
variable type void hold pointer variable function 
java object class super class java classes variable type object object java class 
ephedra provides wrapper classes fundamental data types emulate pointers fundamental data types 
sections discuss transformations pointers java detail 
java support implicit conversions pointer de rived class pointer base classes 
restrictions protected private inheritance 
inheritance java public restrictions apply java 
particular implicit type casts classes done compiler valid java performed implicitly java compiler 
chapter 
translation detailed catalogue pointers members pointers members little known feature language infrequently 
equivalent java java reflection api emulate similar constructs java 
ephedra support conversion pointers members 
software engineer decide suitable transformation case case basis 
discuss pointers members dissertation 
expressions expression sequence operators operands specifies compu tation 
syntax order evaluation meaning defined funda mental data types java 
cases defines behaviour expression specifying result undefined cases 
java usually stricter definitions defining result cases un defined mention differences java sections java definition equivalent special attention needs paid conversion process 
operators overloaded class types 
compiler transforms uses overloaded operators function calls specific member functions class operator defined 
java support operator overloading transformations performed source conversion java 
member functions renamed names contain characters permit ted java identifiers 
ephedra chooses new names reflecting origin purpose functions shown table 
allows user define conversions class objects fundamental types pointers 
compiler applies implicitly unambiguous invoking special conversion functions defined user 
java support conversions 
source transformation implicit conversions need turned explicit function calls 
con version functions renamed names contain characters chapter 
translation detailed catalogue permitted java identifiers 
original operator function name operator operator operator int operator char transformed function name toint tostring table renaming operator functions postfix expressions subscripting java define subscript operator 
subscript operator applied array pointer 
java subscript operator applied arrays 
chapter explains detail data types con java behaviour subscript operator emulated java 
modify subscript expressions resulting java code may correct possibly syntactically 
converts subscript expressions expressions accessing dedicated storage area hides subscripting semantics 
function call java define function call operator 
expression specifying function called operand followed possibly empty list expressions containing parameters enclosed parentheses 
allows various kinds expressions operand java re operand name method 
causes problems conversion function pointers 
features supported java variable length parameters lists default arguments 
section explains ephedra resolves issues 
chapter 
translation detailed catalogue function called formal parameter function initialised actual argument 
process initialisation temporary variables may created formal parameter type 
source conversion temporary variables created explicitly necessary 
order evaluation parameters undefined 
java parameters evaluated left right 
contradiction transformation necessary 
explicit type conversion type name followed expression list constructs value specified type expression list possibly creating temporary object 
type refers class constructor matching expression list defined constructor 
syntactic equivalent explicit type conversion 
type name refers fundamental type type derived expression converted way type cast expression section 
type name refers class type ephedra transforms expression java new expression calls appropriate constructor class 
roughly equivalent compiler implicitly constructed temporary object implicitly compiler case known time recycled unknown time garbage collector java 
destructor class side effects conversion may change behaviour program 
favour solution solution increases readability 
shows example conversions applied explicit type conversion involving class types 
class member access different ways access members class 
value variable class instance members instance accessed dot postfix expression 
object referred pointer chapter 
translation detailed catalogue original code class public int static void 
transformed code class public int public static void 
new explicit type conversion postfix expression variable arrow postfix expression normally 
java objects referred 
dot postfix expression access members 
conversion arrow postfix expressions replaced dot postfix expressions 
shows example 
original code class public int 
pa 
pa 
transformed code class public int 
initialisation pa 
pa 
class member access transforms class member access way ephedra 
maintain definitions structured data types accesses class members hidden statements accessing dedicated storage area 
chapter 
translation detailed catalogue increment decrement java provide post increment post decrement operators 
increment resp 
decrement operand returning original value result 
operators defined arithmetic types languages 
conversion necessary cases 
defines operators pointer types 
compiler assumes pointer variable contain address element array specified type increments decrements address pointer vari able point previous element array 
java pointer types allow arithmetic operations formed 
chapter shows pointers pointer arithmetic transformed java ephedra approach 
unary operators defines indirection address operators allow conver sions pointer non pointer types 
types coexist java conversions necessary 
transformation java indirection address operators stripped 
trans formation may performed time 
chapter shows transformations detail 
unary arithmetic operators unary plus unary minus 
logical negation complement exist java 
java puts restrictions operands operators 
operands need arithmetic types unary plus minus operators boolean logical negation operator integral types complement oper ator 
source transformation type conversions may need inserted comply restrictions 
section explains done 
increment decrement pre increment pre decrement operators handled analogously post increment post decrement operators section chapter chapter 
translation detailed catalogue pointers 
sizeof defines sizeof operator allow programmer determine size bytes expression type 
java equivalent operator fact actual size variables hidden programmer 
sizeof operator frequently different scenarios programs locate storage variables move storage areas variables variables disk storage 
primitive data types ephedra replaces sizeof expressions constants defined ephedra prim itive wrapper classes reflect size bytes variable type disk storage 
class data types ephedra stores sum sizes members static class variable replaces sizeof expressions type variable 
transformation closely emulates behaviour sizeof expression allows correct conversion memory allocation disk storage access 
shows example conversion 
original code class public int class public float 
sizeof int 
sizeof transformed code class public int public int eint class extends public float public int 
eint 
sizeof expressions chapter 
translation detailed catalogue new new operator allocates optionally initialises memory program heap 
allocates sufficient memory store value specified primitive class type 
case arrays allocates memory array elements 
operator initialises storage allocated specified expression constructor case classes 
java new operator defined class array types 
allocates memory object specified class array objects specified class 
case allocate storage objects 
done separate steps 
transformations necessary 
primitive types replaced corresponding ephedra wrapper types 
allocation arrays performed steps allocate storage array objects array 
ephedra provides general purpose java method class invoked occurrence new operator call code steps coded repeatedly 
illustrates conversions 
original code class public int int int 
new int 
new int 
new int 
new 
new 
new transformed code class public int int int public int size initializer 
new pint 
new pint 
new pint pint null 
new pa new 
new pa new 
new pa null new expressions chapter 
translation detailed catalogue delete delete operator de allocates storage allocated new operator 
class types calls class destructor deallocating storage 
case arrays destructors array elements called storage elements de allocated 
operand delete operator mutable value undefined application operator 
delete operator applied null pointer 
case effect 
java provide delete operator 
programmer force java virtual machine de allocate memory 
java virtual machine de allocates unused memory usually unknown intervals stor age needed objects garbage collection algorithms 
time finalize method object deleted invoked java virtual machine 
primitive types ephedra replaces delete operator assign ment null variable referencing storage de allocated 
helps java virtual machine determine storage longer needed helps programmer understanding code 
destructors classes transformed regular member meth ods java classes calls delete operator replaced methods 
ephedra provides general purpose method invokes destructors elements array 
shows transformations example 
explicit type conversion cast expression allows explicit type conversion variables values 
different kinds type conversions conversions values arithmetic types conversions different pointer types conversions pointer integral types chapter 
translation detailed catalogue original code class public int de allocate object delete delete de allocate array delete delete transformed code class public static destruct original destructor code return null public static array invoke destructor element return null pint pa de allocate object set null set destruct de allocate array set null set delete expressions chapter 
translation detailed catalogue conversions user defined conversion operators conversions values arithmetic types performed similarly java 
see section conversion boolean types 
conversions different pointer types con conversions types java 
conversions legal types involved related inheritance 
con versions conversions pointers integral types removed developer source code transformed 
section discussed removal type casts detail 
java support user defined conversion operators 
conversion java converted regular member functions class type cast conversion operators converted invocation converted regular member function 
arithmetic logical operators logical arithmetic assignment operators provided defined compatible way java 
unary operators java puts restrictions operands operators 
arithmetic opera tors need arithmetic operands logical operators need boolean operands 
conversion java operands trans formed discussed section 
care taken handling compound assignment operators involve incompatible types 
may transformed equiv expression simple assignment operator shown 
original code bool transformed code boolean compound assignment operators chapter 
translation detailed catalogue performs lexical analysis code means determine type variable perform conversions necessary due type conflicts 
transforms source code similarly ephedra 
comma operator allows multiple expressions chained expression commas 
expressions kind frequently macros 
subexpressions evaluated result final subexpression 
java support kind expression state ments transformation difficult subexpression augmented extra code boolean expressions true subexpressions concatenated logical operators 
subexpressions void value augmented true boolean expression 
case subexpression wrapped method returns true call method inserted comma expression 
variables subexpression passed wrapper method 
shows example transformations 
transformation code may legible 
identical sequences expressions occur code times developer consider wrapping expressions method enhance readability code 
alternative solution convert left hand side comma expres sion independent statement 
certain cases requires insertion temporary variables conditional statements may difficult implement transformation tools 
decided pursue option 
handle conversion comma expressions 
converts semantics exactly conversion negative effect readability source code 
chapter 
translation detailed catalogue original code void foo int int foo transformed code void foo int boolean int foo return true int true true conversion comma operator constant expressions requires constant expressions places case labels switch statements 
exactly java requires conversion necessary 
statements java supports statements defined exception goto statement 
expression statements restrictive java result hardly transformations necessary conversion statements 
sections show handle goto expression statements 
labelled statement jump statements java support goto statement 
supports rarely leads poorly structured code 
cases goto statements get limitations language ephedra concentrates detecting transforming chapter 
translation detailed catalogue cases asking developer improve code uses goto statements 
identify classes goto uses transformations nested loops break continue statements break continue innermost loop 
breaking continuing outer loop achieved goto statements 
java loops labelled break continue statements refer labels signify loop set nested loops broken continued 
goto function scenario avoid coding cleanup code multiple times function 
label put cleanup code return statement branch label return function 
java effect achieved putting label lexical block extending function just labelled statement source labelled break statement 
examples transformations shown figures 
original code 


goto goto transformed code 


break continue goto statements nested loops ephedra transform goto statements break flow control 
proves transformation possible usually results poorly structured code 
opinion developer rewrite code improve readability approach 
chapter 
translation detailed catalogue original code failure print error message goto cleanup cleanup close files transformed code failure print error message break 
close files goto statements function expression statement statements program expression statements 
expression state ments statements consist zero expressions 
expressions usually assignments function calls allows expressions expression statements 
java allows assignments function calls decrement expressions new expressions expression statements 
expression statements involving kinds expressions may programmer take advantage side effects 
source con version need check expression statement valid expression statement java side effects 
side effects wrapped statement empty body 
expression statements side effects removed program 
shows example transformations 
declarations declarations specify interpretation identifier program 
java declarations allowed context enclosing class interface declaration 
java restrictive respect class interface declarations allowed top level scope program 
declarations occur class interface declaration 
chapter 
translation detailed catalogue original code bool bool int bool transformed code boolean boolean int boolean side effect removed side effect removed expression statements conversion java top level declarations allowed java need wrapped classes 
ephedra gathers top level declarations single file class declarations transforms static members class name derived file name 
shows example transformation 
original code file double double double dm double double euro transformed code class static double static double double dm static double double euro wrapping top level declarations specifiers specifiers declaration identify various properties identifiers declared 
java supports fewer specifiers java equivalents specifiers impact functionality program transformations may applied code 
chapter 
translation detailed catalogue storage class specifiers defines storage class specifiers auto register static extern 
auto specifies variable allocated stack 
default java storage class specifier tion 
conversion java auto specifier removed source code 
register specifies value variable stored cpu register increase performance 
hint compiler may ignored 
conversion java removed source code 
static specifier different contexts top level scope source file specifies identifier visible accessible current source file 
identifiers name declared top level source files introducing naming conflicts 
directly equivalent construct java 
top level scope source file declaration wrapped class name derived source file source conversion 
naming conflicts top level identifiers source files 
identifier accessed source files 
field class specifies field exists instances class 
java static specifier effect 
method class specifies method operate object class provides service class possibly static fields class 
java static specifier effect 
local variable function specifies variable initialised load time constant initializer expres sions invocation method chapter 
translation detailed catalogue non constant initialisers retain value tions method 
java support static local variables 
conversion moved function enclosing class 
initial value variable depends arguments passed function additional code variables may added emulate behaviour code 
functions define static variables name variables re named 
shows example transformation scenario 
performs transformation similarly handle problem 
original code file foobar void foo static int void bar int static int 
transformed code class foobar static int static void foo static int static bool initialized false static void bar int initialized initialized true 
conversion local static variables function specifiers function specifiers identify characteristics functions defined 
inline specifier hint compiler inline substitution function preferred usual function call implementation 
java compiler accept hints decides inlining chapter 
translation detailed catalogue function bodies provides advantages 
java virtual machine may form inlining execution program 
conversion java inline keyword removed source code 
virtual specifier declaration non static class member functions 
discuss difference virtual non virtual functions transformations section 
typedef specifier typedef specifier introduce new type name existing fundamental derived type 
conversion shown section 
template specifier template keyword specifies declaration param type function 
section illustrates transformation tem plates 
friend specifier friend specifier give non member functions classes access protected private members class 
equivalent construct java 
java default package access class achieve similar effect giving access class members classes package 
approach flexible gives access entire group classes specific set classes functions 
type specifiers const type specifier identifies variable immutable initial 
constant expressions section 
java final keyword achieve effect 
const type specifier formal parameter function declaration param eter changed function initialised actual chapter 
translation detailed catalogue parameter function invocation 
volatile type specifier hint compiler specifying vari able may change means undetectable compiler 
compilers usually avoid aggressive optimisations expressions involving variables ensure yield expected result 
storage accessible java program control java virtual machine keyword unnecessary java 
conversion java may removed 
comment added notify developer particular variable marked volatile original code preserve documentation aspect type specifier 
type specifier declarator follows identifies type variable function declared defined mentioning name fundamental predefined type 
sections explain different kinds declarations show transformed different contexts 
enumeration declarations enumeration declaration declares distinct integral type number named constants type 
values enumeration type implicitly converted int needed explicit type casts required convert int enumeration type 
convention legacy programs unnamed enumeration declarations declare number constants assign values int variables program 
java support enumeration declarations 
way convert java declare enumeration constants interface bears name enumeration type 
variables enumeration type type changed int 
shows example conversion strategy 
transformation straight forward correct causes loss type information program variables different type java type int 
difference cause change behaviour program type information chapter 
translation detailed catalogue original code enum int 
transformed code interface final static int final static int int int 
conversion enumeration declaration interface lost conversion may important clue developer program assignment arbitrary value integer variable look suspicious assignment constant valid tion constant 
propose slightly different conversion 
enumeration declaration converted class declaration 
enumeration constants integral variable members class 
type variables enumeration type changed conversion 
shows result transformation 
original code enum int 
transformed code class final static int final static int int value int src value src int new value 
conversion enumeration declaration class conversion original enumerated type definitions lost 
uses visible comments code 
handle enumerated type definitions 
chapter 
translation detailed catalogue pointers arrays conversion pointers arrays discussed detail chapter 
functions original code class foo int int int return 
int foo converted code class 
int int int int priori conversion function parameters declaration definition functions similar java transformations necessary 
happen context conversions discussed parts chapter top level functions need wrapped classes 
parameters passed functions return values converted assignments similarly explicit inlining functions called 
illustrates conversions applied purpose defining transformations function parameters showing code conversions 
assignment pointers conversions defined section apply 
techniques shown section convert chapter 
translation detailed catalogue assignment objects 
allows function arguments default values 
arguments specified call function default values 
java equivalent construct 
possibilities conversion default values added incomplete parameter lists calls function additional functions declared take fewer arguments original function pass default values original function 
shows conversion 
original code void foo int float 
transformed code void foo int float 
void foo int foo void foo foo conversion default arguments second language element allows variable length parameter lists ellipsis 
ellipsis specified formal parameters function zero arguments arbitrary types may passed actual parameters 
macros functions defined standard headers access parameters function 
ephedra defines ellipsis class replaces ellipsis function declarations 
uses macros functions standard headers replaced calls members ellipsis class 
parameters passed function call wrapped classes passed ellipsis constructor 
ellipsis class provides large number constructors allow various argument lists stores parameters array member 
shows example conversion 
note slight difference behaviour code case type mismatches compiler run time possibility check parameters passed function satisfy assumptions type number 
java bound checks array ellipsis class type checks performed execution type casts raise exceptions function attempts chapter 
translation detailed catalogue access extra incorrectly typed parameters 
converted code safer original code 
original code void foo int num 
va list ap va start ap num int num double va arg ap double va ap foo transformed code void foo int num ellipsis ellipsis ellipsis ap new ellipsis ellipsis ap ellipsis int num double ap get 
foo new ellipsis new new new conversion ellipsis performs conversion ellipses similar ephedra 
requires statement actual parameter function call ex pression ephedra requires expression entire ellipsis 
handle ellipses 
chapter 
translation detailed catalogue initialisers initialisers assign initial value variable 
conversion simple variables fundamental data types 
variables address taken passed point program type changed corresponding wrapper variable explained chapter 
initialisers modified accordingly 
variables structured types additional steps needed con version initialisers 
definition structured variable allocates storage possibly initialises variable 
definition variable java allocate storage 
transforming java transforma tions turn implicit allocation storage explicit java storage allocation need applied 
illustrates conversions applied initialisers funda mental structured data types 
original code address taken int int address taken int int int int structured class 
transformed code address taken int int address taken pint new pint pint new pint pint new pint set pint new pint set structured class 
new conversion initialisers variables fundamental types aggregates called aggregate array object class constructors private protected members base classes virtual chapter 
translation detailed catalogue functions 
brace list list initialisers enclosed braces may initialise elements array fields class 
multi level brace list initialisers lower level braces may omitted cases 
java brace list initialisers supported initialisation arrays 
initialisation classes constructors need 
shows simplest case conversion 
original code struct int float int transformed code class int float int float src src src int new new new conversion brace list initialisers brace list initialisers may incomplete initialise storage variable initialised 
remaining storage initialised zero values 
conversion include ing initialisers brace list provide additional constructors support routines perform initialisation possibly requiring auxiliary variables 
ephedra chooses second option keeps initialisers easier read 
particular large arrays option impractical 
shows transformation 
difficulties arise transformation brace list initialisers gates nested 
possible brace list initialise object contains array 
brace list passed parameter constructor java auxiliary variable needs chapter 
translation detailed catalogue original code struct int float int transformed code class int float int int temp int pint temp new conversion incomplete brace list initialisers converted code shown 
original code struct int array 
transformed code class int array int array array array final int temp new pint temp conversion nested brace list initialisers creates special method variable brace list ini original code initialise storage area 
semantics initialisation apparent code 
fails convert code involving brace list initialisers completely 
character arrays java provide string literals initialisation strings 
string literals character arrays compiler appends null char chapter 
translation detailed catalogue string literal 
java string literals instances java string class 
string literals transformed program need converted character arrays 
ephedra uses function standard java api perform conversion illustrated 
uses custom function perform conversion converts character arrays java strings conversion string literals necessary 
original code char message transformed code byte message initialisation character arrays explained chapter converted java way pointers converted 
variables assignments identical semantics value variable changed 
special consider kind pointer define address stored pointer assign ments change contents storage addressed pointer 
syntactic difference source code shows semantic difference 
concept java different compatible source code changed achieve effect 
pointers seemingly refer literals com piler creates auxiliary objects represent literals 
shows transformations necessary emulate initialisation 
classes supports kinds classes members classes defined keyword class private default classes defined chapter 
translation detailed catalogue original code int initialisation int assignment generation auxiliary variable const int transformed code int 
initialisation int assignment generation auxiliary variable final int initialisation keyword struct union public default 
unions hold member time 
converts structured data types java classes 
cor rectly translates access specifiers fails translating specifiers static 
ignores difference virtual non virtual function overriding intricate problems language conversion 
create structured data types erated source 
code generates looks unstructured assembly code java syntax directly accesses certain storage regions symbolic names 
handle mention rest conversion catalogue 
conversions applies non specific language features correct ded storage area abandoning structured data types original data structures code lost 
class members members classes converted way top level declarations converted need wrapped enclosing classes members class 
definitions member functions static member variables cases occur outside class declaration top level scope compilation unit 
java chapter 
translation detailed catalogue place declarations 
static keyword class members mean ing java 
conversions necessary handle language construct 
non static member functions distinguishes kinds member functions non virtual virtual 
stroustrup explains difference follows class base contains virtual function vf class derived derived contains function vf type call vf object class derived invokes derived vf access pointer base :10.1.1.26.9545
derived class function said override base class function 
contrast function declared non virtual call invoked base vf 
talking terminology functions java override func tions type base classes non static java functions virtual 
non virtual functions need transformed emulate behaviour code java 
ephedra converts non virtual func tions static java functions 
static functions operate class object implicitly passed object 
passed explicitly 
accesses fields functions originally implicitly passed object need changed refer explicitly passed object 
illustrates necessary conversions 
drawbacks solution customary declare func tions static pass object function operate mainstream java programs 
experienced java programmer design algorithms differently take advantage java function calling semantics 
transformed code look unfamiliar possibly confusing java programmers 
side transformed code may perform better code non static java functions 
run time chapter 
translation detailed catalogue original code class int virtual void int call non virtual void int call virtual class void int 
void int 
transformed code class int void int call non virtual static void int call virtual class extends void int 
static void int 
conversion member functions overhead non static java functions called program needs determine run time function invoke 
difficult compilers java virtual machines optimise code calling technique 
unions unions classes hold members time 
equivalent language construct java 
section describes technique turning unions hierarchies classes 
different approach turn unions regular classes 
java classes provide storage members time provide features provided union compilers optimise storage allocation unions advantage fact need provide storage members time conversion may cause large memory overhead union fields 
software engineer evaluate approach better specific problem 
chapter 
translation detailed catalogue bit fields bit fields integer variables specified size 
members classes 
ephedra converts corresponding integral java types 
exact match ephedra uses larger integral type 
conversion integral types danger converted code perform correctly assumptions size original data type 
software engineer needs review converted code sure assumptions hold 
nested local class declarations java allow class declarations nested 
nested classes correspond nested classes java conversion static keyword needs inserted shown 
allows class declared function 
declared scope function 
equivalent language feature java may emulated including declaration local class static nested class declaration java 
care taken resolve naming conflicts class declarations move inner scope outer scope conversion 
illustrates transformations 
derived classes object oriented programming language java provide mechanisms deriving class classes 
java language con structs restrictive transformations nec essary cases 
ephedra focus mainly conversion pro code perform automatic transformations handle differences java inheritance 
provide sug related 
java support definition functions implemen chapter 
translation detailed catalogue original code class class void class int void class float transformed code class static class static class int void static class float void conversion nested class declarations tation members classes 
called pure virtual functions java methods 
class function called class 
possible create object class subclasses provide implementation methods 
programmers need explicitly identify class 
java needs keyword definition class 
shows necessary conversions 
original code class implicitly class pure virtual function virtual void transformed code class explicitly class method void conversion classes supports multiple implementation inheritance allowing class base classes 
java supports single implementation inheritance multiple interface inheritance class base class implement interfaces 
interfaces restricted kinds classes chapter 
translation detailed catalogue contain methods static fields 
wen examined multiple inheritance developed techniques conversion inheritance schemes provided java 
distinguishes public protected private inheritance 
java knows public inheritance 
conversion private protected inheritance public inheritance usually cause problem 
member access control java allow members classes declared private pro public members restricting classes access mem bers 
java protected access restrictive classes package permitted access protected fields 
difference cause problem conversion 
discussed access control respect inheritance section friend specifier earlier section 
special member functions java special member functions classes object creation deletion 
defines special functions copying con objects 
special member functions frequently called generated implicitly 
constructors constructors initialise newly created objects 
java compilers create default constructors assign default values fields object constructors class defined source code 
creates copy constructor case 
copies fields object object fields class types done invoking copy constructors fields fields fundamental data types aggregates binary copy created 
discussed section chapter 
translation detailed catalogue additional constructors may created convert brace list initialisers 
ephedra generates source code necessary constructors 
copy constructors discussed detail section 
parameters base classes specified header constructor derived class 
java call super class constructor statement constructor body 
shows conversions applied 
original code class public int class public int float transformed code class int class int float super conversion base class initialisers conversions applies constructors special conversion functions implicitly form necessary type conversions 
java support conversion func tions apply constructors implicitly 
conversion java conversion functions need renamed valid java identifiers names outlined section 
implicit calls conversion functions constructors need explicit 
illustrates transformations 
destructors conversion destructors mentioned connection delete operator section 
destructors special functions bear names valid java ephedra names chapter 
translation detailed catalogue original code class public int operator int 
int transformed code class public int public int toint 
new int toint implicit type conversions constructors conversion functions destruct converted code 
aspects including conver sion call semantics case non virtual destructors converted regular functions 
copying class objects addition copy constructor mentioned earlier uses assign ment operator function perform assignments objects classes 
certain conditions automatically generated compiler 
java compilers generate functions need coded explicitly conversion java 
assignment operator function bears name valid java name needs renamed outlined section 
important recall different assignment semantics java 
assignments structures cause structures fields assigned 
java assignment statement classes assigned 
assignment semantics coded explicitly java ensure variables types arrays copied properly 
ephedra emulates assignment semantics replacing assignment automatically generated assignment function 
constructor allocate storage variables case arrays primitive variables java clone method efficient way 
chapter 
translation detailed catalogue illustrates transformations examples 
overloading java rules overloading functions 
problems arise function defined distinct types identical conversion java 
case overloaded functions need renamed illustrated 
java support operator overloading 
operator functions need renamed bear valid java names implicit calls functions need turned explicit changing application operators function calls shown section 
unfortunate effect transformed code difficult read 
templates ephedra provide solution conversion templates called generic parameterised types 
conversion java distinct class created instantiation template 
exactly compiler compilation program performance overhead approach 
multiple copies template code source code difficult maintain 
java dialects support templates efforts underway create standard way definition upcoming release java programming language 
release ephedra take advantage language extensions achieve better transformation templates java 
chapter 
translation detailed catalogue original code struct int struct struct int transformed code class public int public src src public static src src return class public public src new src public static src src return class extends public int public public src super src int src clone new int new src public static src src int src int src return copy constructors assignment operators chapter 
translation detailed catalogue original code sufficiently different void int void double identical conversion void signed int void unsigned int void int void int transformed code sufficiently different void int 
void double 
identical conversion void signed int 
void unsigned int 
void ref eint void ptr eint conversion overloaded functions exception handling variables data type raise exception 
java objects throwable class subclasses 
functions need declare exceptions possible raise java functions raise exceptions mentioned declaration caught body 
exception rule java 
exception class subclasses thrown caught function body declared definition 
transformation java classes throw catch clause changed extend java class 
possible throw variables data type ephedra primitive wrapper classes possibly pointer classes changed extend class 
conducted experiments approach showed results significant performance overhead 
objects extending java throwable class superclass class require large amount memory processing time creation programs run times slower better approach 
developed efficient effective way convert exceptions java 
ephedra defines exception class extends chapter 
translation detailed catalogue 
acts wrapper data types raising exception 
throw clause occurs original code replaced throw clause raising exception ephedra exception wrapper class 
original throw argument passed constructor exception class 
catch clauses try statement combined single catch clause tests ephedra exception wrapper class 
java instanceof operator test type class wrapped ephedra exception class 
illustrates conversion 
conversion propose correct cause performance safety problems execution converted program 
optimal conform traditional java coding stan 
confusing software engineers familiar ephedra 
long term converted code involving exceptions reviewed manually modified software engineers conform java coding standards 
preprocessing programs define directives frequently define constants 
java provide better means declaring constants define di converted constants code converted java 
cases define directive define short functions 
functions converted regular functions fore conversion java 
ephedra provide tools automatic conversion language constructs 
summary chapter detailed catalogue showing code trans formations need applied source code migration java 
structure manual explained options conversion language element chapter 
translation detailed catalogue original code class try throw throw catch int catch catch 
transformed code class extends java lang object target object target class try throw new new pint set throw new new catch ee ee target instanceof pint int pint ee target get ee target instanceof ee target conversion exceptions chapter 
translation detailed catalogue consequences 
remaining chapters dissertation evaluate ephedra presenting tools automate java source transformations case studies performed tools ephedra approach 
part iii evaluation previous chapters dissertation ephedra approach converting programs java source code 
chapter prioritised goals requirements ephedra approach reiterate maintainability functional equivalence high automation efficiency generated code efficiency tools 
show ephedra approach satisfies requirements evaluate correctness practicality implemented tools perform code transformations described 
tested tools ephedra approach representative programs evalu ated quality converted source code assessing maintainability conformance java coding standards performance compared original code 
subject systems evaluation cover large part programming languages exhaustive sense exercising complete set language features offered 
conduct case studies validate ephedra 
results initial case studies encouraging show conversion strategy feasible 
chapter implementation goals ephedra high degree automation transliteration original code java virtual machine 
important ensure generated code correct software engineer proof read correct code 
achieve goal decided lexical transliteration source code done perform complete parse source code semantic graph subsequent transformation graph 
parsing process difficult implement complex language 
able focus attention language conver sion aspect migration decided design custom parser transliteration tool interface parser existing com piler 
time project started ibm interface visualage compiler related documentation available universities chose product 
section provides information ibm visualage interface compiler 
section describes tool build class hierar type cast relationships 
section explains implementation source code transliteration tool 
considerations implementa tion changes discussed section 
chapter 
implementation ibm visualage sources usually broken kinds files 
kind called header files contains declarations classes data types functions global variables 
second kind contains definitions rations 
ensure correctness program developer needs ensure declarations match definitions times 
traditionally done recompiling changed source files sources files depend declarations changed source file 
lot time lost recompiling code affected changes resides file contains code needing re compilation 
header files usually included source files get compiled compilation source files 
incremental compiler ibm visualage development environment takes different approach sources kept regular files compiler keeps declarations definitions depen database called 
source file changes compiler determines declarations definitions file changed declarations definitions affected change 
compiler minimal set affected source code parts source files 
ibm decided document publish interface compiler code store software engineers information collected compiler build tools depend information computer aided soft ware engineering case computer aided software re engineering care tools 
tools request compiler recompile selected function bod ies variable provide information 
information queried various stages compilation fore type analysis optimisation code generation complete semantic graph asg obtained 
tools insert additional passes compilation process example insert profiling memory management instructions generated code 
software engineers extend ibm visualage integrated de chapter 
implementation cs declaration code store cs declaration cout endl querying ibm visualage velopment environment ide adding customised views metrics programs compiled 
illustrate interface ibm visualage shows essential parts program uses api print names global variables program 
type cast analyser tool normalisation step ephedra approach section deals restructuring data types original source code 
tools visualising class hierarchies remove multiple inheritance code simple unix tools grep identify uses multiple inheritance 
type casts data structures related type casts difficult identify manually tools usually handle visualise 
traditional compilers enforce explicit type casts implicit detected lexical parsing approaches 
related data structures may reside different source files subsystems may difficult software engineers locate 
sufficient domain knowledge associate 
decided implement tool aid developer locating type casts data structures related type casts 
ibm visualage contains syntactic semantic infor mation type casts including implicit ones represented 
relatively easy implement tool api obtaining traversing semantic trees functions chapter 
implementation initialisers 
developed stand tool integrated ibm visualage ide 
tool implementation closely follows algorithms section difference steps algorithm combined increase performance 
side effects safely run concurrently 
complete tool consists lines code provide integration ide 
figures show screen shots tool running ide 
source code transliteration tool translation step ephedra approach source code improved corrected normalisation step java source code 
ephedra provides tool automates transliteration 
sections describe architecture experi ences gained implementation tool ibm visualage api 
implementation strategy ibm visualage provides information program api 
api query semantic graph asg compiler built lexical semantical analysis program 
visualage supply graph various stages compilation process type analysis optimisation 
perform correct transformation need asg annotated exact type information chose query graph type analysis 
wanted generate java source code closely resembled original code chose query graph optimisation phase compiler 
strategy traverse asg create corre sponding java asg written java source files 
designed data structures storage java asg api chapter 
implementation manipulation asg 
visualage api designed usable implementation type cast analysis tool section facilitate conversion asg java asg modelled java asg api api section 
contrast api designed solely turning source code asg included functionality java asg api write asg java source files 
transliteration tool perform asg conversion steps 
step conversions explained detailed conversion catalogue chapter applied 
tool mark variables primitive type address taken original source code wrap ping objects 
second step previously marked variables wrapped 
marking variables expressed strict java asg 
designed java asg extensible permit non java constructs graph 
approach step asg conversion convert asg java asg non java constructs second step remove non java con structs asg replace java constructs 
final result java asg written java source files 
java asg api visualage api model designed data struc tures api store manipulate semantic graph java source code 
created hierarchy connected classes reflect structure java asg 
shows class hierar chy representing various kinds declarations java source code 
class drawn shaded background example class occur strict java asg process conversion java 
similar class hierarchies exist java expressions statements type descriptors 
declaration expression statement classes provide functions printing artifacts represent java source code 
code formatted chapter 
implementation java asg api classes representing declarations chapter 
implementation indented readable style 
comments attached source code artifacts printed artifacts source code generated 
expression classes automatically add parentheses required change default evaluation order 
asg conversion code conversions explained conversion catalogue sec tion simple implementation asg traversal performing conversions appeared little complexity initial partial implementations conversions supported assumption 
conversion expressions initialisers proved diffi cult expected 
representation source code visualage asg counter intuitive 
asg correctly represented type casts compiler insert source code 
cases type casts source code discarded compiler importance 
shows similar expressions asg representations 
case cast statement added compiler second case cast statement discarded 
details asg explained documentation led confusion errors conversion tool 
problem visualage queried asg optimisation step compiler optimisations code transformations performed code 
storage allocation deallocation operations asg show new delete expressions complex expressions involving auxiliary variables calls constructors destructors undocumented functions visu run time library 
transformations documented api reverse engineered 
apparently depend properties data types involved non default constructors destructors 
depend version visualage compiler platform compiler compiling 
chapter 
implementation asg counter intuitive representation conversion asg revert complex storage allocation deallocation expressions original new delete expressions transformed java asg elements 
identify complex expressions developed algorithms try match subgraphs asg 
brace list initialisers problem particular nested 
visualage compiler needs analyse brace list initialisers iden tify parts aggregate initialise 
result analysis available api 
unfortunately part api poorly documented lot guess necessary extract vital information successfully 
visualage integrated development environment ide caused delays development 
occasionally incremental com piler generate incorrect code compilation conversion tool causing tool expose strange errors 
wasted hours search ing errors disappeared recompiled code scratch 
chapter 
implementation testing facilitate testing generated java code implemented optional functionality conversion tool 
automation regression test suites added option write classes project java file independently compiled 
larger projects conversion tool generates files compile run debug generated source code spread source files 
verified correctness implementation code transforma tions small sample source files 
initially reviewed generated java code correctness implemented automated tools compare expected results actual source code generated conversion tool 
re running tests change conversion tool quickly determine errors introduced tool eliminate early 
errors overlooked manual review code manifested complex programs subject systems case studies chapter usually resulted exceptions raised java virtual machine 
able trace origins effectively 
tool development choice ibm visualage front tools developed advantages disadvantages 
significantly helped development tools particular equally documented powerful parser available time project started 
unfortunately ibm dropped support platforms visualage run deploy ephedra tools ibm aix operating system 
compilers extract infor mation source code number stand parsers available 
done standardise output parsers extractors facilitate interoperability tools graph chapter 
implementation exchange language gxl 
appears beneficial tools independent ibm vi read write gxl 
new release tool split parts 
gnu 
gxl fact extractor visualage parsers available 
type cast analyser reading emitting gxl 
source code reading emitting gxl 
java source code generator reading gxl completion transliteration gxl representation program contains valid java program 
possible add additional optional parts java source code generation example exper optimisations refactorings 
example tools replace library calls java api invocations change error handling leverage java exceptions 
parts tool integrated current integrated devel opment environments 
integration particularly beneficial ide supported java eclipse 
summary chapter described implementation tools automation ephedra 
explained role ibm visualage api development tools details architecture 
discussed drawbacks implementation ap proach plans flexible implementation tools 
chapter describes experiences gained application tools conducting case studies migrating java 
chapter case studies migration various programs validate ephedra approach conducted case studies se typical sources migration java 
provide usable migration environment ephedra offers automatic migration frequently stan dard library functions 
implemented quite easily effectively similar methods java apis 
complex fprintf function decided erate existing implementation writing hand java 
transliteration served case study 
second case study selected small stand game program aspects similar programs expect ephedra 
written style uses pointers function pointers goto statements contains little documentation 
sample program third case study 
run time performance generated java code evaluated fourth case study 
chapter 
case studies conversion non trivial library function looking existing open source implementation fprintf ansi implementation approximately lines source code written dos os port gcc emx 
implementation consists primary function subroutines 
source code written ansi contain problematic type casts ephedra normalisation step necessary 
attempt code failed 
ibm visualage front compile source code depended nal functions integer string conversions defined emx specific header files 
identified functions purpose decided implement stubs replace calls eration calls similar methods java apis 
second transliteration attempt produced syntactically correct java class 
inspection java sources showed casts tween integer boolean values making code quite difficult read 
ap variables function return values source assumed boolean values lack boolean type actual type char 
optimise code identified variables original source code changed type bool 
third transliteration ephedra obtained readable syntactically correct java class 
replacing calls stubs created transliteration attempt calls similar java api methods able gain confidence correctness code regression tests 
new java implementation fprintf working correctly readability java source code perfect 
fprintf returns total number characters written result check errors various places guarantee return value chapter 
case studies exact 
subroutines signal return values error occurred execution return values checked 
checks hide algorithm implementation code difficult read 
original source checks hidden macros 
file ideal scenario exceptions java apis extensively file access 
decided modify generated java code exceptions handle errors 
know existing tools automate process sufficient experience case studies provide general solution problem performed modifications manually 
able replace checks errors single try catch statement primary fprintf function 
return type subroutines changed bool void 
modifications code size reduced 
result transliteration process exceeded expectations 
achieve goal obtaining functional java version fprintf completed task quickly resulting java code readable original code 
derive algorithm specification fprintf function re engineer implementation 
bugs original code tested transformations performed deterministic 
note problem optimisation step 
step performed manually repeated java code regenerated original code 
dealing code change problem case study 
dealing original code changes careful record optimisations re applied java code regenerated 
chapter 
case studies conversion style game pro gram development ephedra source code transliteration tool wrote various small programs regression test suite test certain transliteration 
validate correctness applied transformations context real program uses large range language features chose stand monopoly game program previous studies 
program written style code uses complex data structures pointers function pointers 
constitutes solid test case normalisation step difficult transformations translation step ephedra approach 
insertion function prototypes preparatory step compiled ran original monopoly program get impression functionality 
ephedra normalisation step gnu tool transform program style ansi monopoly program ready imported compiled ibm visualage ide 
attempt compile program failed compiler detected errors compiler unable discover due lack prototypes style program 
browsing capabilities ibm visualage ide detection source errors easy 
cases extra parameters passed function 
determined extra parameters needed 
choice correcting invocations function question adding extra default parameter function prototype ignored function body 
decided minimise source code changes 
retrospect chosen option 
addition superfluous parameter correct errors code obscured confuse developers working code 
chapter 
case studies routine executes truncated set commands answer gotten 
char prompt 
correct invocation enter compiler detects mismatch char yn enter yn routine executes truncated set commands answer gotten 
char prompt void 
invocations correct enter char yn enter yn error monopoly program corrected example code chapter 
case studies compiler flagged discrepancies declared return types actual return values functions 
functions code return type explicitly specified defaulted int 
functions return value flagged incorrect compiler 
corrected giving explicit return type void original code 
compiler detected problems functions responsible load ing saving games 
apparently code unix system calls save load data area 
windows version ibm visualage compiler system calls unknown compiler 
looking code difficult understand decided better re implement load save functions scratch java emulate unix system calls current implementations 
replaced functions stubs 
code compiled errors 
automated tool detect problematic type casts locate casts 
program written transform instances multiple inheritance normalisation step complete 
transliteration source code ephedra source code transformation tool performed necessary translation step 
tool transform goto state ments converted manually 
rest transformations done automatically generated java source code compiled correctly 
final step re implemented load save functions removed earlier java 
java io serializable interface helped implementation simple 
chapter 
case studies ephedra migration tool transliteration data structures conversion program problematic type casts case study converted example program 
done primarily check result automated conversion close manual conversion proposed section 
program written ansi dialect insert prototypes 
data type type cast analysis shows visualage ide importing example program switching migration page presents view generated type cast analysis tool 
top left window page shows data structures chapter 
case studies ephedra migration tool analysis type casts type cast relationships data structures 
data structures shows data structures directly related 
selection data structures top right window displays current language implementation data structure bottom window displays class hierarchy built type cast relationships 
tool correctly identified field manager data structure unused removed transliteration 
complete application field sample program modified include function accessing field appear view 
view determine source code type casts applied data types 
software engineer information locate parts source code coded chapter 
case studies elegantly exploiting class hierarchy built 
standard set views search tools visualage ide explore code usage data structures interest 
transliteration source code source code automated transliteration tool 
transliteration result shown figures 
generated code longer original source code default copy constructors copy operators replicate behaviour equivalents added source code 
manual optimisation code step optimised generated code worker manager constants clearly belong employee class moved interface 
similarly show method operates employees member class 
transliteration tool transformed character arrays java byte arrays closest transliteration 
domain knowledge tells arrays contain strings safe reasonable change type java string class 
shows code 
repetitive manual modifications source code needed case study usually comparatively labour intensive error prone 
relieve software engineer burden performing modifications research done categorising formalising classes changes 
refactorings source code changes proven change behaviour source code certain conditions met 
tools check conditions met program perform refactorings exist java help automate optimisation step 
shows transformation example 
decrease coupling classes increase coherence classes show member method employee split chapter 
case studies class employee extends pointer public int public name public extension public employee name new extension new public employee employee src src name src name extension src extension public static employee employee employee src src name src name extension src extension return class sample public static void employee stdio printf new ellipsis new name switch case worker worker worker stdio printf managed new ellipsis new manager name break case manager manager manager stdio printf manages employees new ellipsis new eint break transliteration code part chapter 
case studies interface public static final byte worker public static final byte manager class worker extends employee public manager manager public worker manager null public worker worker src super src manager src manager public static worker worker worker src employee employee src manager src manager return class manager extends employee public int public employee public manager null public manager manager src super src src src public static manager manager manager src employee employee src src src return transliteration code part chapter 
case studies class employee static final int worker static final int manager int string name string extension void show system print name switch case worker worker worker system print managed system print manager name system println break case manager manager manager system print manages system print system println employees break class manager extends employee int employee class worker extends employee manager manager manual optimisation code figures chapter 
case studies class employee string name string extension void show system print name class manager extends employee int employee void show super show system print manages system print system println employees class worker extends employee manager manager void show super show system print managed system print manager name system println optimisation code chapter 
case studies contains code common employees 
new show member methods manager worker handle specialised cases 
analysis code reveals variable constant class value meaning dif distinct classes 
java comparison operator instanceof variable needed sample code may needed parts program 
conversion cpu intensive algo rithms evaluate correctness efficiency generated code chose convert cpu intensive programs 
programs part implement spring sugiyama graph layout algo rithms 
programs filters read input standard input write results standard output 
graphs operate stored proprietary graph format 
lex yacc parse format 
graph format simple want transform lex yacc case study decided re implement parser lex yacc testing purposes 
new parser implemented lines code 
rigi graph editor uses spring sugiyama stand programs generating graph layouts 
layout programs come test suites graph editor generate test cases 
insertion function prototypes programs written style gnu transform ansi compiling programs visualage ide compiler problems 
monopoly program compiler noticed discrepancies declared return types actual chapter 
case studies return values functions 
functions code return type explicitly specified return types defaulted int 
return value flagged incorrect compiler 
corrected giving explicit return type void 
compiler encountered incorrect function call extra parameter specified 
data type type cast analysis data structures union save attributes graph 
unions contain integer untyped pointer 
ephedra approach union converted hierarchy classes base class concrete subclasses different types attributes 
fields union small decided take different approach transform union regular data structure field integer pointer value 
felt little extra amount memory approach preferable loss performance result type casts calls virtual functions strictly ephedra approach 
ephedra source code transliteration tool performs transformation automatically unions code 
manual changes code 
transliteration source code transliteration code went smoothly major problems encountered 
programs standard library functions implemented 
implemented spring layout program performed correctly 
minor differences put original transformed program 
caused differences java handle floating point numbers 
sugiyama layout program aborted null pointer exception printing results 
investigating problem revealed severe error chapter 
case studies original program memory released 
program allocate new dynamic storage release storage storage overwritten program functioned properly 
different environment program produced incorrect results caused harm parts system 
java transliteration de allocation memory emulated setting storage de allocated null 
subsequent access resulted null pointer exception revealed error hidden original program 
summary chapter case studies conversion example programs stemming various application domains java 
explained steps necessary perform migration assessed usefulness tools implemented purpose 
satisfied reliability level automation achieved ephedra tool set 
particularly pleased ephedra helped locate serious errors subject sys tems case studies 
chapter focused conversion process chapter considers conversion result assessing quality code generated conversion 
chapter quality generated code evaluated quality code generated ephedra source code conversion tools assessing properties code ity characterised readability conformance java coding stan efficiency 
readability subjective point view generally pleased read ability code generated ephedra conversion tool 
compares favourably competitor large scale automated translation source code 
obtain objective measure readability generated code need gather opinions experiences developers 
purpose created web site allows internet users perform source code translations ephedra tools systems 
project started able gather results 
releasing stand versions ephedra tools interested parties 
expected different mapping schemes pointers developed exhibit advantages disadvantages respect readability code generate 
converting pointers java mapping produces readable code pointers code chapter 
quality generated code implement linked data structures call parameters 
code responsible allocation traversal arrays suffers mapping employ standard java arrays 
opposite situation applies second mapping approach 
maps arrays java arrays array definitions traversals readable 
pointer arithmetic clearly recognisable dedicated pointer classes 
need classes creation pointer objects various places code readable pointers simply implementation linked data structures call parameters 
unfortunately currently see way reconcile ap proaches mapping pointers achieve unified approach provides op code situations 
software engineers decide mapping approach employ depending nature program converted choosing appropriate executable ephedra conversion tool 
conformance integration primary goals ephedra enable integration large volumes source code written mainstream java programs 
translator difficult storage management scheme incompatible regular java programs 
ephedra uses regular java data types classes generated code interfaces nicely manually written java source code 
arrays pointers part interfaces generated code software en basic knowledge ephedra approach deep understanding required 
classes generated ephedra currently designed serialisation standard java serialisation techniques 
data structures designed java serialisation capability mind yield unexpected results particular data structures contain point ers arrays 
ephedra supports distinct serialisation strategy closely models behaviour serialisation standard library functions 
chapter 
quality generated code ephedra approach inherently incompatible java serialisation ity software engineer add required functionality reviewing source code ensure desired effects achieved 
performance case study conversion cpu intensive algorithms section allowed evaluate efficiency code generated ephedra conversion tools 
small input files transformed versions spring sugiyama graph layout algorithms performed worse original program 
quickly determined mainly due long start time java programs 
analyse performance algorithms larger graphs created graph nodes spring algorithm graph nodes sugiyama algorithm 
difference execution time smaller significant 
performance depends pointer mapping scheme chapter 
code converted mapping scheme times slower original code spring algorithm times slower sugiyama algorithm 
tests second mapping scheme produced code ran faster code produced mapping scheme 
code compiled run time optimisations enabled 
gain better understanding causes loss efficiency measured time converted programs operations loading saving graph files execution algorithms 
noticed java programs needed significantly longer time programs 
big surprise java programs need pass data ephedra run time library java api system functions programs access system functions directly 
just time jit compilers built java virtual machines apparently unable compile optimise code performing java machine code compiler produced worse results chapter 
quality generated code java virtual machines produced significantly better performing code file bad performance explains difference efficiency converted spring sugiyama algorithms 
graph evaluate spring algorithm roughly twice big sugiyama algo rithm 
spring algorithm significantly higher complexity sugiyama algorithm time spring algorithm spent smaller fraction total execution time sugiyama algorithm 
algorithms times slower original code depending java virtual machine pointer mapping scheme 
verify small additional case study heap sort gorithm converted programs little pointer arithmetic fundamental data types perform original programs 
tests java code ran faster code compiled enabled half fast code compiled optimisations enabled 
sugiyama algorithm example illustrate effect inefficient conversion exceptions java 
straightforward transformation section pointer mapping scheme sugiyama algorithm requires enormous amounts memory 
ex ample graph nodes algorithm required mb memory original mb ran times slower optimised exception transformation 
java virtual machines able execute test case due inefficient conversion exceptions problems running test cases optimised exception transformation 
summary chapter evaluated quality java source code resulting conversion program ephedra approach 
goals set analysed converted code respect chapter 
quality generated code readability performance 
assess migrated code integrated mainstream java programs checked conformance java coding standards 
pleased developed conversion approach major negative impacts criteria 
chapter ends dissertation summarising main problems contributions solutions open problems 
chapter summary electronic commerce internet plays prominent role today business environment customers expect integrated web services provided legacy information systems 
way provide services users quickly effectively integrate legacy code information systems newly developed java programs 
java programming language opens software project larger group developers universities nowadays teach java undergraduate curricula 
dissertation integration strategies dis characteristics strengths weaknesses 
introduced ephedra approach migrating programs java ephedra software migration environment 
different migration case studies evaluate approach migrating code java 
major contributions survey current integration migration studies chapter documents evaluates approaches integrating source code java programs existed prior development ephedra 
pro chapter 
vides valuable information strengths weaknesses approaches explains scenarios yield best results 
part ii dissertation presents ephedra new approach migrating source code java 
designed specific goals mind particular ease integration converted source code mainstream java programs 
design goals met approach general permit migration wide range programs 
particular developed strategies mapping pointers java targeted different kinds applications 
contrast previous java migration strategies ephedra provides structured approach manual clearly describes conversion steps underlying rationale 
chapter showed ephedra approach automated implementing migration environment approach 
parts environment relatively self contained providing sufficient func tionality software engineering tool sets 
particular type cast analysis tool section java asg api section prove useful construction reverse re engineering tools 
case studies showed debugging generated code easier debugging code compiled native machine code 
run time checks performed java virtual machine help greatly locating faults may go undetected programs certain conditions 
may possible decrease development time cost new programs java debugging java virtual machine 
pleased java code generated transliteration tool 
generated code correct reasonably efficient 
certain guidelines followed development new code portable type casts single inheritance manual intervention required mi grate code java 
quite faults detected java code faults original code 
debuggers chapter 
mented hide intermediate java code developers appear debugging original code 
study compar ing development cost approach opposed cost traditional development interesting 
viable useful option development environments 
anticipate application began research 
monopoly application previous case studies evaluate usability re engineering tools structured experiment 
experiment repeated determine source code migration helps hinders software engineer understanding program 
studies help evaluate readable maintainable gen erated code difficult objective judge readability code simply looking code consciously avoided readability generated code dissertation 
familiar conversions applied case studies rate code readable compared java developers familiar code 
section laid strategy new flexible im plementation ephedra conversion tool 
addition structural changes new implementation perform conversions currently done manually elimination goto statements 
tool usable large critical projects important requirement preservation original comments source code 
current implementation tool contains provisions representing comments java source code 
need develop strategies iden token particular comment source code really refers 
related prove useful purpose 
discussed section macro definitions pose problem conversion tool automated reverse engineering tools expressed part grammar 
development automated method converting certain macro definitions lan guage constructs constants inline functions notable contribution research community 
bibliography american national standard 
home page 
www ca ber 
gxl home page 
www de gxl november 
standalone programs 
www fmi uni passau de graphed download standalone december 
peter aiken lewis 
reverse engineering new systems smooth implementation 
ieee software pages march 
keith bennett 
program transformations help reverse engineer ing 
proceedings international conference software nance icsm washington dc november 
peter bird andy seidl 
reengineering legacy applications june 
whitepaper genitor maria ros braga paulo 
reengineering design patterns 
proceedings seventh working conference reverse engineering pages brisbane queensland australia november 
canfora cimitile malcolm munro 
improved algorithm identifying reusable objects code 
software practice experiences 
bibliography oscar 
open developer api extensions os warp 
ibm 
cimitile andrea de lucia giuseppe di anna rita 
identifying objects legacy systems 
pages may 
internet software consortium 
internet domain survey january 
www isc org ds hosts html april 
james cordy thomas dean andrew kevin schneider 
software engineering source transformation experience txl 
proceedings st international ieee workshop source code analysis manipulation pages florence italy november 
ole johan dahl bjorn nygaard 
simula common base language 
technical report oslo norway october 
thomas dean andrew richard holt 
union schemas basis extractor 
proceedings working con ference reverse engineering pages stuttgart germany ber 
uwaterloo ca union pdf november 
erik demaine 
converting pointers 
proceedings acm workshop java high performance network com puting palo alto ca 
di mare 
iterators 
technical report universidad de costa april 
www di mare com iter htm 
james michael dupont 
gcc xml node 
sourceforge net march 
eclipse org 
eclipse web site 
www eclipse org 
bibliography editors 
advances software engi neering topics comprehension evolution evaluation 
springer verlag new york december 
rudolf rp des kos kiss 
columbus tool reverse engineer ing large object oriented software systems 
proceedings pages hungary june 
hu research columbus pdf november 
rudolf susan sim richard holt rainer koschke thy 
standard schema 
proceedings working conference reverse engineering pages stuttgart germany october 
hu research scheme pdf november 
martin fowler kent beck john brant william opdyke don roberts 
refactoring improving design existing code 
addison wesley longman 
free software foundation fsf 
gcc home page 
www gnu org software gcc gcc html october 
harald gall ren kl sch 
finding objects procedural programs alternative approach 
proceedings nd ieee working confer ence reverse engineering pages toronto canada july 
ieee computer society press 
joseph george bradley carter 
strategy mapping function oriented software models object oriented software models 
acm software engineering notes march 
adele goldberg david robson 
smalltalk language implementation 
addison wesley longman 
james gosling bill joy guy steele 
java language specification 
addison wesley longman 
bibliography james gosling bill joy guy steele 
type comparison operator instanceof chapter 

jennifer hamilton 
montana smart pointers re smart re pointers 
proceedings conference object oriented gies systems pages portland 
michael himsolt 
programmer manual 
michael 
architecture montana open ble programming environment incremental compiler 
proceedings conference foundations software engineering orlando fl november 
brian kernighan dennis ritchie 
programming lan guage 
prentice hall 
kostas kontogiannis johannes martin kenny wong richard gregory ller john mylopoulos 
code migration trans formations experience report 
proceedings cascon pages toronto 
chris 
java translator 
web site longer avail able 
lehman 
understanding laws evolution conversation large program life cycle 
journal systems software 
lehman 
programs life cycles laws software evolu tion 
proceedings ieee special issue software engineering september 
sheng liang 
java native interface programmer guide spec ification 
addison wesley longman 
frank lindholm frank yellin 
java virtual machine specifica tion 
addison wesley longman 
bibliography liu norman wilde 
identifying objects conventional procedural language example data design recovery 
proceedings ieee conference software maintenance pages san diego ca november 
ieee computer society press 
panos theodore johnson 
new approach finding objects programs 
journal software maintenance research practice 
andrew 
home page 
www uwaterloo ca november 
andrew 
migration 
shop software architecture august 
www cs ualberta ca conf papers pdf november 
johannes martin ller 
discovering implicit inheritance relations non object oriented code chapter 
december 

emx gcc tools dos os 
archiv leo org pub comp os os leo gnu emx gcc october 
ller 
understanding software systems reverse en technologies research practice 
tutorial th international conference software engineering march 
www rigi csc uvic ca html 
ller karl 
rigi system programming large 
proceedings th international conference soft ware engineering pages 
andrew myers barbara liskov liu wang nick mathewson 
java parameterized types 
www pmg lcs mit edu march 
bibliography lee 
incremental 
dr dobb journal pages december 

java translator 
www com ns nsf september 
university victoria 
rigi web server 
www rigi csc uvic ca june 
william opdyke 
refactoring object oriented frameworks 
phd thesis university illinois urbana champaign 
st cs uiuc edu pub papers refactoring opdyke thesis ps patil ying zou kostas kontogiannis john mylopoulos 
migration procedural systems centric platforms 
pro ceedings cascon pages toronto november 
pizza group 
gj generic java language extension 
www research com user wadler pizza gj march 
chris 
linux change notes august 
internet services 
internet online 
www surveys online index html march 
harry 
validating functional equivalence reengineered pro grams control path result data flow comparison 
software testing verification reliability march 
danny michael john barton david streeter 
ex tension mechanisms montana 
proceedings th ieee israeli conference computer systems software engineering june 
ieee computer society press 
margaret anne storey kenny wong philip fong david hooper hopkins ller 
designing experiment evaluate reverse engineering tool 
proceedings rd working conference reverse engineering monterey ca november 
bibliography margaret anne storey kenny wong ller 
program understanding tools affect programmers understand pro grams 
proceedings seventh working conference reverse engineering pages amsterdam holland october 
bjarne stroustrup :10.1.1.26.9545
programming language 
addison wesley longman reading ma 

automating language conversion case study 
proceedings international conference software maintenance icsm pages florence italy november 
chris verhoef 
realities language con versions 
ieee software pages november 
java community process cp programm 
jsr add generic types java programming language 
jcp org jsr detail jsp march 
ilya 
translating java 
german java developers conference journal 
sol pace edu html 
robert tolksdorf 
languages java vm 
cs tu berlin de html november 
trent waddington 
java backend gcc 
archive csee uq edu au uqbt html gcc jvm ber 
tracy wen 
translating java resolution multiple inheritance 
master thesis university victoria 
doi 
spice system ing smalltalk programs environment 
ieee transactions software engineering 
alexander yeh david harris howard 
re covering data types object instances conventional bibliography procedural language 
proceedings nd ieee working conference reverse engineering pages toronto canada july 
ieee computer society press 
surname martin names johannes place birth mainz germany vita educational institutions attended university victoria northern illinois university johannes gutenberg universit mainz degrees awarded sc 
computer science northern illinois university awards ibm center advanced studies fellowship publications johannes martin ller 
java migration experiences 
proceedings th european conference software maintenance reengineering budapest hungary march 
ieee computer society press 
johannes martin ller 
discovering implicit inheritance relations non object oriented code 
advances software engineering comprehension evaluation evolution 
edited bell canada springer verlag new york december isbn 
johannes martin martin 
web site maintenance software engineering tools 
proceedings rd international workshop web site evolution florence italy october isbn 
johannes martin ller 
strategies migration java 
proceedings th european conference software maintenance reengineering lisbon portugal march isbn 
ieee computer society press 
johannes martin kenny wong bruce winter ller 
analyzing xfig rigi tool suite 
proceedings th working conference reverse engineering brisbane australia isbn 
johannes martin ller 
considerations syntax standard exchange format 
proceedings workshop standard exchange format international conference software engineering limerick ireland 
johannes martin 
leveraging ibm visualage reverse engineering tasks 
proceedings cascon toronto 
devanbu 
chen gansner ller martin 
customizable hyperlink insertion maintenance engine software engineering environments 
proceedings international conference software engineering los angeles ca 
kostas kontogiannis johannes martin kenny wong richard gregory ller john mylopoulos 
code migration transformations experience report 
proceedings cascon toronto 
partial copyright license right lend thesis users university vic library single copies users response request library university similar institution behalf users 
agree permission exten sive copying thesis scholarly purposes may granted member university designated understood copying publication thesis financial gain shall allowed written permission 
title thesis author ephedra java migration environment johannes martin april 
