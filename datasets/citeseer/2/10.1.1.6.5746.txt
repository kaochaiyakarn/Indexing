isabelle isar versatile environment human readable formal proof documents markus wenzel lehrstuhl software systems engineering institut informatik technische universit nchen note slightly revised version phd thesis february official text published tu munich biblio tu muenchen 
de publ diss wenzel html 
version corrects typographical errors adapted isabelle 
basic motivation formal theory developments machine checked proofs accessible broader audience 
particular approach centered isar formal proof language intended support adequate composition proof documents suitable human consumption 
primary proofs written isar may checked machine read human beings final presentation merely involves trivial pretty printing sources 
sound logical foundations isar achieved interpretation generic natural deduction framework isabelle reducing high level reasoning steps primitive inferences 
resulting isabelle isar system generic respect object logics proof tools just pure isabelle 
full isar language emerges small core means derived elements may combined freely existing ones 
results rich space expressions formal reasoning supporting viable proof techniques 
general paradigms natural deduction calculational reasoning covered particularly 
concrete examples logic mathematics computer science demonstrate isar concepts sufficiently versatile cover broad range applications 
am indebted numerous people influenced way alphabetical order andreas abel david aspinall bauer henk barendregt stefan berghofer bernd john harrison florian kamm ller klein ralph matthes stephan merz olaf ller wolfgang tobias nipkow david von oheimb larry paulson norbert schirmer helmut schwichtenberg monika sebastian konrad slind martin strecker wiedijk vincent 
contents motivation 
related 
real theorem proving environments 
experiments human readable proofs 
isar approach formal proof documents 
notions proof isar 
example knaster tarski theorem 
presentation format typeset document output 
primary proof human readable source 
primitive format internal proof terms 
overview thesis 
part foundations 
part ii techniques 
part iii applications 
foundations preliminaries basic mathematical notions 
minimal higher order logic 
types terms 
propositions theorems 
definitional theory extensions 
simple definitions 
weakened definitions 
overloaded definitions 
higher order resolution 
hereditary harrop formulas 
fundamental inference rules 
isabelle pure framework 
vi contents isar proof language 
syntax semantics 
isar commands 
basic types commands 
isar vm transitions 
recovering static syntax 
generic support natural deduction 
context elements 
methods attributes 
derived commands 
concepts 
casual term abbreviations 
formal comments 
type inference polymorphism 
example order logic formal development 
syntax 
propositional logic 
equality 
quantifiers 
discussion 
generic proof support object logics 
natural deduction schemes 
declarative versus operational theorem proving 
expressions natural deduction 
ii techniques advanced natural deduction 
basic techniques 
general context elements 
local facts goals 
mixed forward backward reasoning 
raw proof blocks 
non atomic statements 
generalized elimination 
obtaining contexts 
supporting realistic soundness proofs 
common patterns generalized elimination 
proof cases induction 
immediate patterns cases induction 
rules cases 
contents vii proof methods 
common patterns cases induction 
induction non atomic statements 
discussion 
context manipulations mizar 
second order schemes mizar declare 
generalized case splitting 
calculational reasoning 
foundations calculational reasoning 
calculational sequences 
calculational elements proof language 
rules proof search 
common patterns calculational reasoning 
variation rules 
variation 
variation facts 
variation general structure 
discussion 
iterated equalities mizar 
dijkstra universal calculational proof format 
degenerate calculations big step reasoning 
iii applications isabelle hol application environment hol logic 
simply typed set theory 
primitive definitions 
advanced definitional packages 
inductive sets types 
recursive function definitions 
extensible records 
axiomatic type classes 
automated proof methods 
incorporating arbitrary proof tools 
basic types proof methods 
main isabelle hol library 
discussion 
theory specifications versus proofs 
proof methods relevance facts 
viii contents example higher order logic minimal higher order logic 
simply typed lambda terms 
basic logical connectives 
extensional equality 
connectives 
definitions 
derived rules 
classical logic 
hilbert choice operator 
concrete types type definitions 
basic characterization type definitions 
derived rules type definitions 
discussion isar techniques 
example rational numbers motivation 
quotient types 
equivalence relations quotient types 
equality quotients 
picking representing elements 
rational numbers 
fractions integers 
rational numbers 
discussion 
isar techniques 
hol techniques 
arithmetic proof tools 
example unix security motivation 

unix philosophy 
unix security 
odd effects 
unix file systems 
names 
attributes 
files 
initial file systems 
accessing file systems 
file system transitions 
unix system calls 
basic properties single transitions 
iterated transitions 
executable sequences 
contents ix possible transitions 
example executions 
odd effects treated formally 
general procedure 
particular setup 
invariance lemmas 
putting 
discussion 
isar techniques 
efficiency isabelle isar proof processing 


bibliography index contents list figures interactive development proof general 
basic types isar commands 
transitions isar proof processing 
transitions tactical theorem proving 
definitional packages isabelle hol 
main theory library isabelle hol 
hol type definition 
xi xii list figures chapter motivation general idea formalizing human reasoning long tradition reaching back ancient greek philosophy 
manifest leibniz may seen incident aimed supersede philosophical disputes formalized process decide truth statements 
purely syntactic underpinning formal reasoning mechanical checking proofs matured th century claims universal truth dismissed 
roughly speaking half century logicians demonstrated mathematics principle completely reduced logical principles 
second half century advent computers enabled build systems doing non trivial developments formal logic 
point history computer reasoning artificial intelligence possible build fully automated theorem provers able conduct substantial mathematical proof developments human intervention 
automated reasoning techniques devised decades proven limited practice useful restricted technical problems 
years different tradition interactive theorem proving quite successful supporting reasonably sized formal theory developments 
interactive proving proceeds instructing machine proof checker step step intended result achieved eventually 
individual reasoning steps may vary granularity ranging single rules invocations automated proof procedures local problems 
semiautomated reasoning systems able cover significant applications areas pure logic mathematics computer science mathematical background theories models hardware software systems programming language semantics algorithms functional programs 
note chapter 
new deep mathematical results normally discovered proof development machine 
practical limits verifying concrete hardware software systems large market basically moved model checking testing lately trading actual verification systematic finding errors 
despite relative success theorem proving certain areas fundamental obstacles addressing broader range users interest formal logic proof 
full potential applications semi automated reasoning probably unleashed 
paradoxical problem interactive proof systems support adequate notion proof speaking human perspective 
major systems oriented technical issues certain logical calculi implementation machine 
input slightly arcane languages proof scripts difficult understand proof developers typically need replay existing scripts recover idea actual reasoning process 
situation bad proof maintenance impossible communicating formal proofs wider audience 
poses particular problem derivative formal theory development previous authors 
methodological viewpoint interactive proof development similar programming proving slightly involved practice 
successful proof checking typically demands portion experimentation convince machine obviously correct reasoning steps minor omissions initial claim underlying definitions 
hand theorem proving fundamental advantage intended results theorems usually completely specified advance subsequent proof may fail produce wrong result sound implementations proof checkers 
principle enables proof scripts expressed arbitrarily bad manner affecting result 
perspective programming language design undergone decades research proof development stuck assembly language level 
attempts improve technological backdrop theorem proving drawing common ideas program development 
notable approaches include various user interfaces theorem provers presentation management sources literate programming visualization verbalization machine oriented proof structures natural language generation specific infrastructure proving large module systems change management proofs large scale repositories theory developments mathematical knowledge bases 
legitimate research issues vicinity formal proof development address core problem low level proof representations place 
shall illustrate discrepancy terms programming 
effort required slightly low level language may consider 
related ably reduced external tool support automatic code generation graphical presentations composed means nice userinterface 
environment merely uses fronted overcome inherent deficiencies relevant output needs augmented manually 
contrast considerably powerful programming language ml haskell provided class presentations high level concepts eliminating need heavy tool support place 
kind tool support useful stage 
motivated perceived lack accessible proof representations semi automated reasoning 
isabelle isar environment introduced intended viable basis human readable proof documents composed user checked machine 
main focus theory practice isar proof language isar abbreviates intelligible semi automated reasoning 
particularly aim preserving important factors interactive theorem proving success far 
intend cover range applications existing interactive provers expect potential semi automated reasoning due new quality formal proofs achieved isar 
related decades large number systems built intended theorem proving way 
overview mathematics computer wiedijk lists entries categories order prover logic education proof checker tactic prover theorem prover 
list covers systems sufficiently significant available 
order point relevant related isabelle isar shall briefly review notable systems real working environments studies human readable proof representations 
discussions existing approaches alongside exposition isar 
real theorem proving environments theorem proving systems qualify real working environments typically expressive formal languages type theory set theory feature user guided proof development usually interactive successfully applied reality considerable number users 
consider important representatives category hol coq isabelle pvs mizar 
certainly exist contenders league nuprl constable acl kaufmann 
chapter 
hol family hol systems share logical foundations system architecture 
official line represented hol gordon gordon melham hol slind current hol slind 
side branches including commercial implementation proof power icl secure systems hol light harrison successfully employed industrial verification tasks floating point arithmetic 
see gordon background information hol relatives 
hol logic version church simple theory types church henkin andrews extended schematic polymorphism order type constructors semantic type definition scheme gordon gordon pitts 
hol methodology emphasizes strictly definitional discipline theory development arbitrary axiomatizations largely considered harmful user community 
starting small axiomatic basis primitive hol standard mathematical concepts may developed reasonable effort 
years hol users collected large body material 
system architecture hol follows pioneering approach lcf gordon milner correctness construction principle 
small trusted kernel implements primitive inferences basic logic strongly typed functional programming language ml 
functions written users may invent new theorems restricted theorem constructors kernel virtue type safety programming language 
achieves high degree reliability avoiding store actual proof objects independent checking required systems implemented untyped languages lisp automath de bruijn nederpelt 
lcf architecture enabled efficient implementation advanced proof tools rewriting classical proof procedures derived specification mechanisms inductive sets types cf 
discussion harrison affecting soundness logical core 
importantly contributors need understand underlying logic full detail 
hol enforce standard paradigm produce proven results 
principle primitive derived rules written ml may invoked directly mapping existing theorems new ones 
users follow goal oriented view tactical theorem proving initial claim refined backwards steps solved form achieved 
ml specification transformation steps quite hard follow general original writer refrained ad hoc programming restricting script standard tactics tactic combinators 
hol perceived cryptic outsiders due inherent complexities tactical proof scripts due details concrete syntax raw ml 
clear distinction extending system involves ml 

related attempts organize hol proofs accessible manner generating textual reports dynamic evolution goal states cohn 
alternative proof styles tactical approach proposed generalized version calculational reasoning called window inference grundy 
notable experiments structured proof languages hol conducted see 
coq coq barras essentially draws tradition interactive theorem proving hol family follows different philosophy respects 
logical foundation coq calculus inductive constructions cic constructive type theory builtin notions inductive types recursive functions pfenning paulin mohring paulin mohring 
proofs internally represented dependently typed terms explicitly stored separate checking distinctive system component 
coq implemented type safe programming language milner correctness construction lcf hol favor de bruijn principle independent checking static proof objects de bruijn see survey barendregt geuvers 
practice coq hol achieve similar level reliability coq demands significantly time space resources realistic applications 
coq provides particular infrastructure extract functional programs constructive proofs 
principle internal term structure proof objects may automatically compiled produce ml code 
practice users interested program extraction need careful conduct proofs properly order arrive programs conforming intention 
particular concepts need arranged appropriately level inductive set logical prop types 
coq free programmability hol offers separate languages theory specifications called tactical proof scripts respectively 
raw ml view successfully replaced sane concrete syntax 
users may implement proof tools rarely required practice 
coq generally provides automated proof support hol existing classical order techniques automated reasoning may classical higher order logic quite easily proof search constructive setting involved 
interestingly coq users interested large applications tend introduce non constructive axioms order ease formalization effort breaks program extraction facility 
constructively incorrect tuning formal basis principle admit powerful proof procedures official coq support classical reasoning specifically 
coq tactic scripts primitive proof terms largely inaccessible human readers 
traditionally key developers coq chapter 
interested getting formal proofs accepted machine extract programs achieve nice presentations human readers 
significant rendering primitive proof objects terms natural language english french undertaken past 
similar verbalization facility provided system proof terms 
helm project asperti aims www access formal theories large currently working mainly coq fundamental problems adequate representation proof terms despite xml document view provided 
isabelle isabelle paulson nipkow positioned generic theorem proving environment lcf hol tradition interactive systems aimed support logics 
original author early history isabelle tale errors grand designs paulson 
apart generic framework isabelle pure isabelle distribution includes concrete object logics ready immediate applications notably isabelle hol nipkow nipkow simply typed classical set theory isabelle holcf ller domain theory hol isabelle zf paulson paulson untyped set theory zermelo fraenkel 
isabelle pure framework implements minimal higher order logic unrestricted universal quantification implication equality 
rules formulated may composed higher order resolution involves higher order unification paulson 
resolution fundamental reasoning principle isabelle admits forward backward chaining natural deduction rules paulson 
derived rules represented directly meta level theorems eliminating need hand written ml code lcf hol family 
generic higher order rewriting means rules available classical reasoning tools paulson paulson may instantiated important logics 
formalizing new object logics natural deduction principles quite easy isabelle merely providing declarations concrete syntax primitive proof rules 
hand realistic working environment isabelle hol demands years order develop sufficiently rich library standard mathematical concepts 
practical applications demand advanced specification mechanisms need implemented separately notably inductive sets types paulson berghofer wenzel recursive functions slind slind 
majority isabelle users refer isabelle hol ignoring object logics facilities define new ones 
isabelle hol benefits generic framework provides cleaner view general logical concepts specialized implementations original hol family 
isabelle generally appears slightly cryptic users 
separate 
related concrete syntax theory specifications provided early paulson nipkow proof scripts stylized generic tactics parameterized theorems large collection special invocations 
worldwide isabelle hol users able conduct significant applications past years 
presently biggest probably formalization java programming language isabelle bali project oheimb bali 
official examples significant applications included isabelle library covers object logics isabelle hol 
standard way formal reasoning isabelle resembles tactical backwards style hol coq 
past experiments improved presentations simons simons covered literate programming view theories proof scripts special tactics support idioms calculational reasoning approach dijkstra scholten 
pvs pvs owre distributed sri advertised tightly integrated environment specification proof checking model checking 
prominent features predicate subtypes collection integrated algebraic decision procedures easily accessible user interface interactive theory proof development 
logic pvs usually version higher order logic considerably deviates hol 
particular hol distinctive view schematic polymorphism semantic type definitions unavailable pvs 
fact pvs logic better understood version set theory certain aspects set membership reasoning singled specific concept predicate subtypes 
type checking conditions tccs extracted solved automatically user needs interact difficult cases means ordinary pvs proof tools 
resulting discipline approximates casual treatment typing informal mathematics reasonably 
furthermore specific notation subtypes cartesian products function spaces dependent types analogous real type theories 
pvs offers powerful definitional mechanisms algebraic datatypes wellfounded recursive functions 
set theoretic principles official pvs semantics owre shankar 
handsome integration algebraic proof tools including arithmetic semi decision procedures enables users grind everyday proof problems demanding insight logical details 
pvs provides language strategies resembles tactical ones hol coq isabelle admit arbitrary programming proof search 
pvs implementation monolithic consisting large body lisp code 
sources generally available interested parties may take chapter 
look sri change details 
advanced proof tools specification mechanisms hardwired full reduction basic logical concepts inside 
years users pvs encountered number serious problems practice just soundness issues proving false results unexpected failures 
known soundness bugs pvs considered real problem proponents 
focus pvs changed prototype verification system tool finding errors formal models software hardware systems falsification verification 
pvs quite successful respect attracting considerable number users lately 
pvs shows far paradigm interactive theorem proving may get pragmatic side computer aided verification 
users marginal interest formal logic proofs 
far little interest human oriented representations proofs pvs 
mizar mizar rudnicki trybulec emerged project program verification algol algol mizar arabic names certain stars 
point felt reasonably body mathematical background theories required able verify actual programs 
main focus mizar project shifted development enormous mizar library mizar system changed little 
new library entries periodically published journal formalized mathematics 
notable aspect mizar structured proof language designed represent common mathematical proof patterns formal setting 
mizar language tightly integrated particular logical background classical order logic axiomatic basis typed set theory tarski grothendieck special support second order schemas induction particular notion mathematical structures 
proof language provides separate elements cover proof principles raw order logic universal existential elimination versions disjunction elimination cases 
furthermore builtin notion obvious reasoning steps order finish terminal situations 
covers order steps lack separate proof language element universal elimination disjunction 
authors mizar notorious lack documentation 
new users typically instructed directly mizar experts 
partial documentation eventually available muzalewski 
detailed overview wiedijk provides approximation main mizar proof language elements terms plain natural deduction 
full details mizar proof processing published far sources implementation unavailable 

related apparently mizar represents different tradition theorem proving mainstream tactical systems hol coq isabelle pvs respect logic proof language system architecture 
mizar project successful building large body machine checked mathematical theories 
hand mizar inherent limitations due closed approach 
example practical way add new proof tools say flexible rewriting engine provide new specification mechanisms say inductive sets recursive functions 
consequently advanced concepts need simulated directly text existing mizar elements rewriting typically expressed long chains single equational reasoning steps inductive definitions constructed manually top primitive set theoretic concepts mizar library 
structured proof language mizar main communication format user machine users composing new theories existing ones 
default view www presentation mizar library omits proofs 
past experiments rendering mizar texts natural language carlson output format rarely encountered practice 
experiments human readable proofs relative success flexible tactical theorem provers hand structured mathematical proofs mizar hand stimulated research human readable proofs years 
eventually resulted experimental systems focus accessible representations formal proofs 
mizar mode hol harrison provides alternative interface interactive proof composition hol notably hol light harrison transferring useful ideas mizar proof language tactical setting hol 
harrison introduces separate concrete syntax structured proof commands translated special tactics inside perform basic transformations natural deduction schemes raw order logic 
harrison spends substantial effort automated reasoning support solving trivial situations implicitly concrete procedure may exchanged user 
mizar mode covers calculational reasoning style refers collection mixed transitivity rules declared context similar relations 
system sufficiently developed conduct example proofs classical analysis covering pages text applied 
declare syme syme stand prototype system declarative proof development acts compiler formal documents consisting theory specifications structured proof outlines 
proof language main principles order decomposition enrichment second order schema application appeals chapter 
automation 
declare advertised tactic theorem proving syme 
system draws general experience hol family harrison mizar mode established principles full reduction basic logical principles inside 
declare successfully applied author significant case studies java type safety operational semantics syme 
fact concepts declare specifically designed typical applications language modeling particular support inductive definitions proof schemes 
declare aim general applications evaluated practice system publicly available 
structured proof language spl aims providing interface proof construction mainstream hol drawing general mizar ideas experience harrison mizar mode 
spl intended larger scale applications just declare careful stay logical foundations hol 
high level concepts spl reduced primitive hol tactics 
spends significant effort powerful order proof tools hol order support reasoning large steps 
focus implicit simplifications rewriting 
spl hol system evaluated author formalizing portions group theory attempting achieve level abstraction encountered informal proofs certain textbook 
mizar light hol light wiedijk represents minimal system experiment implemented lines ml achieves readable view order tactical proof schemes mainly exhibiting propositions explicitly text implicitly goal configurations 
systems important class teaching tools formal logic provide readable textual representations proofs prefer graphical views 
case systems typically restricted primitive inferences pure logic users may occasionally specify set rules advanced proof procedures unavailable 
teaching tool burstall provides interactive editor primitive natural deduction proof texts strictly backwards manner underlying structure oriented established calculus view type theory 
main idea types sub terms propositions local facts visible text 
abel strictly text oriented proof checker intended teaching constructive logic 
system deliberately excludes kind user interface acts batch mode compiler proof texts written plain ascii 
students encouraged focus task writing proofs play fancy interfaces 
proof steps range primitive natural deduction arrangements assertion level 
system refrains arbitrary proof search implements efficient algorithm structured proof checking 

isar approach formal proof documents isar approach formal proof documents primary subject particular approach formal proof documents called isar abbreviates intelligible semi automated reasoning 
isar covers levels discourse 

specific view problem space formal proof see 
shall introduce categories primitive primary presentation formats proofs 
able identify basic components architecture including notion human readable proof documents isar places center 

concrete design isar proof language viable basis highlevel proof texts general paradigm natural deduction see chapter 
number additional concepts extra logical ones lift underlying logical framework sufficiently level adequate human consumption 
particular care taken keep isar language succinct 
fact substantial parts language defined derived elements top simpler notions 
resulting framework highly compositional large combinatorial space useful expressions ranging simple idioms advanced proof patterns see chapter chapter 

system implementation called isabelle isar wenzel built top generic natural deduction framework provided isabelle pure paulson nipkow see chapter 
rooted generic level common isabelle object logics may benefit directly isar requiring substantial changes apart minor adaptations existing theory libraries 
new object logics may commenced isar proof elements start see chapter chapter 
isabelle hol nipkow shall serve main workhorse concrete examples 
advanced working environment demands logic specific provisions notably proper integration derived specification mechanisms see chapter 
existing isabelle hol setup starting point able provide viable support realistic applications mathematics computer science see chapter chapter 
isar aims truly versatile environment particular goals 
succinct language design basic principles may combined freely 
maximum modularity language concepts 
shall take fundamental language elements primitive define concepts derived ones preserving potential chapter 
combined existing elements 
basic language layer refrain special abbreviations prefer simple idioms consisting words isar 
generally speaking isar language intended support lively expression formal reasoning relatively small vocabulary universal grammatical rules 
incremental proof processing suitable interactive development 
lesson learned interactive tactical proving observe realistic development semi automatic proofs demands experimentation writer 
step wise evaluation isar proof texts may enable users experiment key logical concepts discharge behavior assumptions particular context 
perspective readers incremental way isar proof processing induces bias left right interpretation corresponding strictly order language elements text 
independence particular object logics general framework natural deduction 
rationale cover mainstream object logics isabelle fol zf hol holcf essentially arranging isar concepts generic level isabelle pure framework 
mean unusual representations object logics benefit isar way 
example existing formalizations linear modal logics simulate sequent calculus rules pure natural deduction framework result slightly impractical isar proof texts 
independence particular automated reasoning techniques 
automated proof search shall seen core issue isar proof processing existing procedures may easily incorporated proof methods 
isar proof language shall enforce defined structure proof texts despite potentially ill behaved proof tools involved individual steps proof methods may operate isolated portions main isar proof configuration 
guarantee soundness full reduction basic logical principles 
intend actual formal proofs available practice means reasonable form internal proof presentation terms basic logical principles needs achieved eventually 
reduce accidental formal noise common reasoning patterns avoid unnecessary cluttering proof texts 
danger obscuring formal proof texts irrelevant detail 
interestingly tactical systems occasionally apt certain technical details intrude course reasoning performed user necessarily change situation unstructured proof scripts fundamentally 
isar need careful reasoning 
isar approach formal proof documents steps appear explicitly text 
adequate structured proof patterns typically demand subtle details got right 
particularly illustrative example successful formal noise reduction induction non atomic statements see 
provide stable working environment usable people apart original architect 
arriving realistic system just matter spending considerable efforts mere implementation issues 
importantly isar concepts need sufficiently simple mature providing faithful model structured proofs 
certainly requires feedback concrete applications conducted isabelle isar 
isar follows general design principles resulting framework just arbitrary arrangement certain ingredients acquires distinctive style 
slightly philosophical underpinning certainly impact achieving goals spelled explicitly 
primacy readability 
intend produce human readable proof texts eventually really need take potentially large audience readers seriously writers usually versed formal logic technical details proof system anyway 
composition accessible presentations certainly demand effort case just context formal reasoning 
task author isar proof documents taken lightly 
consequence readers need special tools access proof texts may refer traditional printed electronic pdf 
contrast writers usually require specific tool support interactive proof development 
refer common principles sane language designs 
generally draw standard repertoire minor issues emerged decades high level programming language design block structure static scoping local variables 
liberality non 
generally prefer generic concepts admit useful applications situations despite potentially pending danger inadequate uses certain circumstances 
notable instance principle flexible way arbitrary proof methods tactics inside may incorporated isar proofs 
improper language elements enable isabelle isar absorb old tactical style isabelle completely 
chapter 
open design isar language enables proofs written arbitrarily bad style 
easier compose adequate texts default requires taste author 
separation primitives versus policy 
explicitly distinguish different aspects isar proof processing logical primitives policy enforced interpreting certain language elements 
particular refrain treating isar language calculus despite inherent relation formal logic 
achieve clear separation concerns enabling think isar language extra logical categories 
notions proof isar notion proof hard pin exactly depending context discourse 
refrain attempting universal definition merely provide specific views problem space relevant isar 
proofs shall required fully formal strong sense resulting theorems guaranteed reduced basic logical inferences defined background theory 
practice means proofs need processed mechanically trusted proof checker component 
users necessarily bother actual internal representations proofs 
just ml programmers normally need know machine language executed eventually 
fact low level view quite counter productive objective human readable proofs 
primitive derivations apt obscure intentions formal reasoning historically people reject idea proof formalization altogether exposed anyway 
isar differentiate levels formal proof 

presentation format 
final material recipients audience human readers proofs 

primary proofs 
main communication format proof development system user human writer proofs 

primitive representation 
internal structure basic inferences serves foundation correct results 

notions proof isar various theorem proving systems exhibit quite different ideas proofs levels 
single system may offer different options categories 
example coq system barras terms primitive format 
primary view tactical proof scripts 
coq provides formats presentation pretty printed output primary script rendering primitive terms natural language 
hol system gordon gordon melham gordon provides different view levels proof 
primitive layer consists theorem constructors inference kernel correctness construction milner 
hol offers primary views top ranging direct access forward inferences goal centered paradigm tactical proving users may implement proof construction mechanisms 
standard presentation format hol provides pretty printed version sources visual enhancement mathematical symbols gordon melham 
isar shall take particular view levels proof see example 

presentation produces formal proof documents consisting version primary sources 
isabelle isar document preparation system automatically takes care side effect formal proof processing 
final documents meant resemble traditional mathematical texts high quality typesetting atex 
attempt significant transformations primary text refrain natural language generation 
presentation layer isabelle isar appear thin 

primary layer isar shall absorb main efforts reasonable concepts human readable proof texts 
formal proof language designed ready human consumption machine checking time 
development primary proofs facilitated finegrained incremental interpretation source text meaningful output intermediate states 
user interface support provided generic proof general environment see 
despite interactive development course reasoning expressed statically final text 

primitive layer treated abstractly isar merely demanding basic principles interface upper language level notably composition facts goals higher order resolution 
primary isar interpretation process essentially drives primitive inferences lets results intrude text directly 
consequence internal details primitive proofs really matter isar may isabelle traditional notion correctness construction primitive proof terms meta logic 
chapter 
particular division problem space formal proof shall illustrated concrete example 
example knaster tarski theorem consider simple formulation knaster tarski fixed point theorem complete lattices 
informal statement proof outline textbook presentation davey priestley pages minor notational changes 
knaster tarski fixpoint theorem 
complete lattice order preserving map 
fixpoint proof 
lower bound inequality prove reverse 
complete proof fixpoint 
order preserving 
says 
informal exposition shall merely serve guideline subsequent formal development isar 
despite small example shows key elements isar proof composition 
done realistic proof formalizations specialize statement cover concrete lattice power sets happens readily available background theory isabelle hol nipkow 
main ideas proof faithfully see wenzel similar proof version lattice theory 
presentation format typeset document output canonical proof theory presentation format isabelle isar resembles traditional mathematical documents printed simple browsable format pdf 
documents meant accessible readers large requiring sophisticated tools 
understanding formal languages encountered required basic logic isar proof elements 
subsequent knaster tarski proof simple facts set theory lattice properties general intersection 
note stands universal quantification remaining logical notation fairly standard 
concrete syntax isar proof elements admit text read aloud exact idea formal semantics 

example knaster tarski theorem theorem knaster tarski proof assume mono ge proof fix assume 


note mono show qed proof mono ge show 
qed show qed isabelle document preparation system able produce high quality output primary text user see 
informal explanations may included may refer arbitrary atex markup 
adequate presentations fully formal theory developments readily available leaving unappealing typewriter style persists theorem provers 
formal developments look ugly 
primary proof human readable source format primary proofs isabelle isar system uses directly input 
exhibit real source knaster tarski proof 
theorem knaster tarski exists proof assume mono inter ge proof fix assume 
dots 
chapter 
note mono show qed proof mono ge show 
qed show qed apparently isar source far removed presentation format 
raw text lacks highlighted keywords proper printing mathematical symbols contains additional quotation marks required isabelle delimit inner syntax types terms primary theory proof language key structure isar proofs 
isabelle isar sources somewhat resemble stylized atex input 
fact isabelle isar atex share basic idea producing typeset documents decent textual descriptions big difference atex perform formal checking course 
reality users need directly raw ascii texts shown possible principle 
additional conveniences provided generic proof general environment aspinall proof general essentially provides interface automatic cut paste including undo operations source text underlying prover process 
proof general built editing environment including symbol package take care mathematical symbols 
provers supported proof general coq lego plastic traditional isabelle old ml top level isabelle isar structured proof texts proof script emulation 
typical proof general session isabelle isar shown 
main views script prefer call static proof text dynamic proof state isabelle isar 
presents source visual enhancements including indication proof text processed far marked read editor order ensure consistency state prover process 
remaining unprocessed text may manipulated standard editing means system told step continued formal checking 
second window provides feedback isar interpreter configuration probably providing clues users proceed problems 
dynamic state significantly important structured proof texts unstructured scripts 
isar proof development really means primary text construction occasional results achieved far including facts goals 

example knaster tarski theorem interactive development proof general strictly speaking user interface view primary isar source presentation issue degenerate document preparation system covered 
fact little structure isar proof texts exploited proof general intended generic front existing interactive provers unstructured scripts 
example support actual hierarchic editing proof texts isar easily admit due separate checking sub proofs 
independently user interfaces development tools raw ascii input isar relevant long term integrity formal proof developments 
retaining human readable format primary level proof texts may kept alive easily system components unavailable eventually proof general symbol 
example losing symbol amended switching back plain ascii replacing 
chapter 
casualties happen reality may seen history mizar rudnicki trybulec 
years ago mizar tied obsolete pc font exploit special symbols 
development mizar seemingly trivial issue proper character encoding 
philosophical perspective primary source format isar important virtue confer meaningful formal content actual proof processor hand 
contrast traditional tactic scripts tend way road existing informal material system essentially inaccessible large original proof checker 
derivative slightly different context typically require go back informal literature provided figured 
inaccessible sources pending danger losing results past formalization efforts 
certainly aspect adequate archiving theory sources relevant formalized mathematics widely accepted practice 
primitive format internal proof terms isar proof processor inherits primitive notion formal proofs directly generic isabelle pure framework 
traditional secure derivations isabelle inference kernel due milner correctness construction hard visualize exist idea outside run time environment system implementation 
show alternative proof term format isabelle berghofer nipkow typed calculus 
exi type set order type set inter greatest type ha 
order subst type set type set inter lower type ha iffd mem collect eq type set ha inter lower type iffd mem collect eq type set inter greatest type ha 
order subst type set type set 
overview thesis inter lower type ha iffd mem collect eq type set ha see primary proof structure lost reduction primitive concepts 
example local result ge internally twice isar text appears independent copies primitive proof due internal normalization 
problem posed seemingly trivial issue adequate naming bound variables due arbitrary conversion inside 
hard recover readable isar text primitive representation knaster tarski simple example 
note intend cover larger applications 
fact deeper reason isar takes high level texts starting point produces low level proof representations interpretation top bottom 
overview thesis part foundations main objective isar foundations turn existing formal logic concepts viable language environment natural deduction proof texts requiring extensive theoretical studies 
isar particularly draws known principles natural deduction reasoning minimal higher order logic specific support higher order resolution higher order unification chapter 
isar proof language provides qualitatively different view general concepts high level programming languages leaving raw logic 
levels discourse bridged isar vm interpreter chapter 
basic structure natural deduction proof texts explored example pure order logic chapter 
part ii techniques generic isar framework substantial potential advanced techniques formal proof composition raw natural deduction 
give systematic exposition practically relevant isar proof patterns including derived elements generalized elimination cases induction chapter 
important paradigm calculational reasoning natural deduction explored chapter 
techniques distilled concrete isabelle isar applications proven viable practice 
chapter 
part iii applications isabelle isar able cover broad range applications 
include concrete examples pure logic chapter mathematics chapter chapter 
isabelle hol application environment chapter gives rise logic specific isar proof techniques 
general rule explain concrete proofs informally formal isar text stand 
specific isar proof techniques may discussed separately 
formal theory developments complete included applications provide evidence realistic isabelle isar proof documents produced official version isabelle 
part foundations chapter preliminaries briefly review foundational issues relevant isar framework introduced 
includes basic mathematical notions model generic natural deduction minimal higher order logic 
eventually leads viable environment primitive logical inferences due isabelle tradition notable inclusion fundamental tool support higher order unification back chaining 
details existing view simplified generalized purposes isar 
basic mathematical notions outline main aspects semi formal background language traditional pen treatment mathematical concepts 
basically employ standard version classical set theory common mathematical notation far possible bias conventions higher order functional programming haskell ml higher order logic isabelle hol nipkow see chapter 
formal logical elements introduced calculus higher order logic share substantial parts notation introduced different levels discourse quite different formal status 
sets 
basic sets taken granted truth values bool true false natural numbers nat 
common set constructions comprehension power sets set finite set cartesian products disjoint sums available 
closely stick standard set theory notation operations compound expressions 
common functional programming notation conditional expressions may proposition chapter 
preliminaries boolean value abbreviates 
vector notation 
vectors finite sequences elements treated separate notational device 
write vector elements 
single element may identified singleton vector vectors may appended juxtaposition lists 
shall denote set finite lists set lists built inductively empty list nil xs cons xs write denote list cons operator nested right 
append operation defined 
flat function iteratively appends lists lists flat xs xs 

difference lists xs ys means remove individual occurrences members ys xs left right particular bs bs 
map combinator lifts function operate lists map 
iterate operator generalizes map maintaining additional result iterate bn bn 
shall denote set non empty lists functions defined shall select elements respectively 
functions 
denote set total functions sets denote set partial functions share notation total ones 
common practice written 
usual set theory functions identified graph may plain set notation completely undefined function 
notation refer function mapping 
function application simply written omitting parentheses far possible 
abstraction application may iterated 


alternative notation application may pronounced feed operator left associative binds strongly weaker plain application 
point wise update functions written postfix notation denote function mapping special notation undefined means delete entry 
iterated update collection pairs defined obvious manner list counted left right partial function 
left right sequential composition functions written defined 
dual notation right left composition available 
procedures 
sets 
partial function nat called sequence iff undefined undefined 
minimal higher order logic undefined position encountered undefined positions may follow 
sequence infinite iff total function nat canonical refer head element sequence considered canonical 
furthermore truncate undefined truncate restricts sequence canonical result 
finite sequences coincide lists extend append operation sequences accordingly infinite 
flat operations lists lists transferred sequences sequences analogously 
function nat called procedure iff sequence 
write set procedures note procedures need necessarily computable functions 
procedures nat nat may composed canonical fashion follows result sequence mapped function composition emerging sequence sequences flattened consequently define nat flat 
alternative choice procedures means append individual result sequences left right preference function may turned procedure replacing singleton sequence canonical result furthermore procedure may converted back partial function truncating individual result sequence 
order avoid excessive detail usually treat procedures partial functions uniformly assuming implicit conversions inserted required 
particular convention admits refer complex operations succinctly functional expressions higher order unification enumerates possible solutions 
records 
tuple structures explicitly labeled fields expressed concise manner record notation 
ordinary tuples denote set records fields values write individual record expressions 
accommodate large record specifications declaration format record 

record field standard operations available field selection get field update put functional map lifting field operations records defined map put get minimal higher order logic briefly outline simply typed minimal higher order logic shall serve basis formal logic issues covered 
subsequent presentation draws similar formulations generic framework underlying isabelle pure paulson paulson influences type theory presentations barendregt geuvers 
chapter 
preliminaries types terms basic syntactic framework logical environment introduced simply typed terms modulo conversion established practice higher order syntax pfenning elliott 
name globally fixed infinite set names set strings finite alphabet 
subsequently implicit copies name achieve separate naming various syntactic categories variables constants 
types inductively defined order term structures schematic type variables name fixed type variables name type constructors name nat 
type variables may represented identifiers prefixed prime writing 
second component type constructor called arity usually suppressed clear context write bool bool 
special type constructor written infix nested right curried type expression 
may abbreviated 
ary type constructors write merely type set formed types 
terms simply typed terms built schematic variables name type fixed variables name type constants name type follows 
typing relation defined inductively atomic terms variables constants subsequent rules abstraction application note form type assignment require separate context variable typings atomic terms equipped type annotations 
term called typed iff 

apparently typed term unique type 
term set typed terms 
usual notions substitution instances taken granted 
postfix notation write simultaneous substitution types terms respect types 
furthermore terms shall considered equal modulo usual equational theory conversion 
signature collection declarations type constructors arities constants types constant declarations closed wrt 
type instances refer declared type constructors 
signature may specified giving schemes type constructor arities constant declarations 
type called formed wrt 
signature iff formed refers type constructors 
likewise term called typed wrt 
signature 
minimal higher order logic iff typed refers type constructors constants 
practice refer implicitly standard signature context 
note fixed versus schematic variables introduced just separate syntactic expressions formal concept variables 
difference merely policy certain logical operations introduced notably higher order resolution see paulson schematic variables may get instantiated fly fixed ones need left unchanged scope 
propositions theorems typed terms special type prop called propositions set propositions called prop 
statements minimal higher order logic involve separate logical connectives universal quantification implication 
assume signature current context contains declarations prop type propositions prop prop universal quantifier binder prop prop prop implication right associative infix common binder notation refers nested application universal quantifiers abstractions 

curried implication occasionally abbreviated set theorem defined inductively certain subset derivable sequents finite set prop prop 
write theorem write 
subsequent inductive definition depends fixed set propositions called axioms required closed wrt 
type instantiation 
axiom axiom intro free assumption intro elim elim alternative presentation rules common inference notation natural deduction see exposition thompson basin matthews 
local contexts involved rules chapter 
preliminaries treated implicit axiom assumption schemes suppressed 
intro intro elim elim achieve succinct presentations logical inference rules occasionally treated functions scheme parameters premises arguments assumption 
note meta level theorems especially non atomic statements involving occasionally called rules 
liberal terminology sense theorems give rise canonical inference rules higher order back chaining see 
theory consists signature cf 
plus set axioms closed wrt 
type instantiation 
theory may specified giving declarations signature part stating axioms 
usually refer implicitly standard theory signature context 
general convention paulson nipkow free variables occurring theorems top level theory context shall considered implicitly generalized 
may expressed replacing fixed variables terms types schematic ones 
outermost quantification achieves equivalent effect type variables 
may read inference system supports schematic polymorphism sense arbitrary type instances theorems guaranteed derivable requires typedness terms propositions preserved place 
deeper reason declarations constant schemes axioms closed type instantiation 
admissible rule captures schematic polymorphism succinctly quite easy establish induction derivations 
minimal higher order logic considered far sufficiently expressive represent standard logical connectives directly existing 
definitional theory extensions system 
example may represented canonical elimination form 
see chapter 
immediate extensions primary intention pure logical framework 
actual working environment isabelle hol see chapter embedded object logic 
involves separate axiomatization derivability judgment coerces object level statements meta level propositions 
isabelle paulson nipkow traditionally uses functional constant suppressed concrete syntax 
may refer object level formula 
know pure framework able represent standard logical connectives directly 
isar framework introduced see chapter essentially provides reflection minimal logic concepts level structured proof texts 
previous observation connectives may serve guideline advanced reasoning patterns see chapter existential proof context element general idea underlying 
see 
theorems routinely occur finite collections define fact theorem set lists theorems shall results derivations arise context 
technically serves partial replacement multiple result sequents available slightly complex setting declare syme syme syme 
immediate view conjunction 
occasionally helpful 
definitional theory extensions theories may extended syntax declarations axioms 
theory may specify extension follows meant introduce new type constructors term constants axioms 
note actual user environment provide higher level view theory specifications concrete syntax primitives see chapter derived extension mechanisms see chapter 
reality theory extension schemes considered appropriate qualify definitional ones meta theoretical reasons 
prerequisite definitional equations expressed framework introduce notion extensional equality axiomatic means 
theories shall contain constant axiom declarations 
prop equality relation infix reflexivity law substitution law extensionality coincidence equivalence chapter 
preliminaries various notions definitional extensions may identified restricted axiomatizations 
simple definitions basic discipline constant definitions essentially just introduces abbreviations concrete expressions logic see pitts hol point view 
refer new constant declaration wrt 
current theory context 
furthermore typed equation contains constant term variables type variables covered type contain hidden type dependencies 
extension qualifies simple definition 
strict form definition enjoys number common meta theoretical properties preservation completeness decidability consistency standard models pitts 
key property simple definitions iff type instances expanded corresponding type instance 
basic consequence important property syntactic conservativity sense theorem new context formulated old syntax holds old context 
old syntax mention constant conservativity follows trivially previous expansion property 
simple definitions may slightly liberally changing meta theory 
particular important special case function definitions may written succinctly raw recall extensional 
weakened definitions simple definitional extension 
extension derivable called weakened definition 
common instance scheme conditional definitions form arbitrary conditions 
useful instance loose specifications provided derivable original context 
easy see weakened definitions enjoy basic properties syntactic conservativity preservation consistency standard models consequences covered 
hand exact correspondence versus expansion lost left right implication holds general 
weakened definitions turn fairly liberal specification mechanism merely happens exact definitions outside formal context 

higher order resolution extreme cases weakened definitions unspecified constant declarations form arbitrary isabelle hol see chapter chapter initial axiomatizations full object logics object rules derivable hypothetical definition 
overloaded definitions scheme overloaded constant definitions wenzel requirement declarations definitions agree type scheme non overlapping type instances may specified bool false 
see wenzel details formedness conditions overloaded definitions user view covered 
liberal definition scheme offers interesting ways specify generic operations depending structure simple types 
covers objectoriented concepts method overriding late binding wenzel 
slightly conventional view overloading exploited concept axiomatic type classes offers light weight mechanism theories see 
overloading lose meta theoretical properties weakened definitions 
note tradition relatively weak meta theoretical properties goes back gordon hol system gordon melham pitts covers loose specifications overloading 
isabelle hol nipkow see chapter routinely uses overloading main library 
designers different object logics may choose ignore exotic features restrict simple definitions 
higher order resolution main purpose minimal higher order logic logical framework paulson paulson represent nested natural deduction rules formulas 
paulson idea extending original order natural deduction gentzen arbitrary nesting goes back schroeder heister 
isabelle framework presentation slightly elegant low level syntactic notions skolem constants textual inferences recast handsome connectives 
consequence particular view minimal logic primitive introductions eliminations lose significance practice get replaced derived concepts higher order resolution composing rules natural manner proof assumption finishing situation 
write resulting theorem resolving fact parallel rule resolution may read generalized application chapter 
preliminaries calculus covers implicit lifting local contexts higher order unification see 
hereditary harrop formulas language formulas admits represent different classes rules depending intended kind inference framework see literature prolog details miller 
particular set horn clauses merely consists curried implications atomic formulas flat prefix outer parameters 
set may specified succinctly shall represent variables atomic propositions containing 
outermost parameters usually expressed free variables prolog isabelle tradition presentation may simplified nicely corresponds common dimensional format inference rules 
propositions hereditary harrop format hhf miller generalize rules admitting arbitrary nested statements assumptions atomic define set hhf formulas inductively follows outermost parameters usually suppressed generalize presents generality rule terms schematic variables 
generalize hhf admits general proof schemes represented succinctly 
example mathematical induction may stated directly meta level suc typical object level encoding suc slightly awkward need treated explicit rule applications 
proposition minimal higher order logic may hhf normal form law allows parameters occur flat prefix level rule nesting 
isabelle paulson nipkow goal represented theorem gets transformed eventually 
tactic procedure theorem theorem affect main implicit assumption context 
intermediate goal configurations form subgoals hhf formulas parameters need treated arbitrary fixed premises may assumed local facts sub proof pending obligation 
higher order resolution goal representation works smoothly long main atomic 
isabelle provides special provisions derive non atomic rule statements treated advanced method isabelle documentation paulson system essentially decomposes initial statement outer context atomic rule emerges implicitly discharging context finishing proof 
deeper reason inconvenience improper list representation outer goal structure hhf misinterpret nonatomic 
premises separate subgoals 
order admit rightmost position hold arbitrary hhf formulas need preserve initial structure 
purposes isar proof composition see chapter introduce additional proposition markers logical meaning formally turn general expression 
marked hhf formulas form topmost implication structure may carry markers outer parameter prefix omitted 
derived rules admit initialize conclude goal configuration see 
init conclude require marker main 
optional markers encountered rule premises shall play second role achieve proper treatment general hhf assumptions local goal refinements see refine 
fundamental inference rules higher order resolution composes rules back chaining care local contexts instantiations automatically 
raw composition turns essentially performing modus ponens reverse order passing implication prefix compose rule covers implicit instantiation rule premise second 
compose shall refer substitution exclusively operates schematic variables types terms see 
real implementation typically enumerate possible solutions higher order unification paulson paulson exact operational details matter 
actual resolution similar compose observes hhf structure premise second rule 
general structure may order admit back chaining indicated chapter 
preliminaries rule needs adapted accordingly called lifting isabelle jargon paulson nipkow 
lifting context 
may performed derived rules 
lift rule particularly subtle schematic variables original rule need adapted depend new outer parameters 
lift lift resolve scheme acquired lift lift compose 
resolve usually prefer write resolve applicative order may pronounced see related operation introduced 
resolution may easily generalized argument rules applied parallel single rule covering certain prefix premises proof assumption solves subgoal projecting local premise instantiation 
note may take atomic assumptions account atomic 
assumption isar goal refinements essentially just plain resolution subsequent version allows arbitrary hhf assumptions solved time 
argument represents local just exported context additional assumptions optional markers premises indicate immediate proof assumption 
second argument represents enclosing goal state subgoal subgoals subsumed gj marked gj refine 
isabelle pure framework recall may consist marked unmarked hhf formulas 
marked ones immediately solved existing premises result merely covers remaining non marked premises new subgoals result 
refine operation hidden core isar proof processor see enables arbitrarily structured assumptions proof texts 
note direct goal transformations users existing tactics encounter subtleties marked versus unmarked propositions plain resolve assumption steps see 
isabelle pure framework logical framework introduced far may understood presentation existing isabelle pure environment paulson paulson paulson nipkow serve formal background isar concepts introduced see chapter 
actual isabelle isar implementation wenzel built isabelle pure system 
subsequently briefly review main differences framework minimal higher order logic traditional isabelle pure 
original view higher order logic isabelle pure paulson paulson somewhat closer older formulations church andrews gordon melham pitts omitting classical principles choice operators course see chapter 
rules stated paulson implemented primitive theorem constructors isabelle paulson nipkow 
chapter 
preliminaries elimination 
definitional equality characterized low level rules equivalence congruence properties wrt 
term formation conversion extensionality correspondence logical equivalence expressed explicit rules 
contrast presentation extensional equality merely adds basic axioms existing framework 
rules added may easily derived see chapter 
compact treatment considerably simplifies meta level studies definitional extensions details shown 
type instantiation included primitive isabelle pure paulson nipkow 
contrast able acquire rule admissible essentially due initial closure axioms type instantiations 
kept schematic polymorphism core inference system 
treating type instantiation primitive rule causes technical subtleties resulting structure derivations unnecessary effort required original meta theory overloaded definitions wenzel wenzel 
note additional concept order sorted type classes isabelle pure nipkow nipkow prehofer treated admissible extension basic inference system wenzel see user view type classes overloading 
generally speaking presentation pure framework conforming common presentations natural deduction proof systems typed calculus 
fact formulation resembles presentation hol pure type systems barendregt geuvers 
hol consists layers typed calculus separate abstractions applications potentially dependent arrow types 
notation arrows layers written corresponding syntactic function types universal quantification implication respectively 
may depend abstraction argument inherent property hol barendregt geuvers 
corresponding elimination rules essentially simple type assignment modified operate local typing contexts basic logical inferences higher order natural deduction 

intro 

intro elim 
elim 
isabelle pure framework 
intro elim unified view minimal higher order logic able improve general theoretical understanding framework considerably 
certainly influenced simplified presentation 
note improvements isabelle inference kernel berghofer nipkow follow similar perception multi level calculus 
user experience real isabelle pure system differs hol important details 
level mere syntactic types left implicit time additional conveniences automatic type inference polymorphism see 
logical levels expose primitive proof terms user propositions 
essentially derivation object may read theorem abstracted primitive proof interchangeably 
primitive proofs occur actual primary proof texts isar layer cf 

chapter 
preliminaries chapter isar proof language give detailed exposition isar proof language covering syntax operational semantics isar vm interpretation scheme 
basic elements high level natural deduction proof texts hardwired isar primitives concepts generally introduced derived ones top core system 
proof language embedded generic notion theory specifications 
isar proof processing essentially imposes certain policy selection primitive logical operations 
particular isar introduce logical calculus provides conceptually different view existing concepts generic natural deduction focusing incremental language interpretation primitive inference systems 
isar language provides general framework human readable natural deduction proofs see wenzel earlier version 
isabelle isar implementation wenzel enhances isabelle pure logical framework paulson nipkow cover actual proof texts 
isar generally somewhat biased particular infrastructure higherorder nested natural deduction basic ideas transferred foundations mechanized logic 
important philosophical issue isar approach primacy highlevel formal language operational semantics provided incremental interpretation 
particular invent new logical calculus establish number standard meta theoretical results 
foundations logic granted build conceptually different layer top 
pointed terminology techniques developed chapter 
isar proof language appropriately related field high level programming languages mathematical logic 
roughly speaking isar language may divided separate parts theory proof descriptions 
includes proper language elements declarative proof texts improper ones experimentation emulation unstructured proof scripts 
key viable support human readable formal proof texts design proper part isar proof language consists basic elements see fix assm augment logical context indicates forward chaining previous facts show claim local statements includes solving pending goal proof performs initial proof step applying method qed concludes sub proof manage block structure introduces term abbreviations higher order matching note names reconsidered facts 
common context elements represented particular instances generic assm primitive notably assume usual kind strong assumptions def local definitions see 
furthermore number derived proof commands see notably proofs empty body single rule proofs immediate proofs claims forward chaining indicated explicit forward chaining additional facts 
standard abbreviations available thesis original claim head current proof latest finished statement 
left hand side available 
special name refers fact established previous step happens 
fundamental proof methods resolve facts directly rule apply rule resolved facts insert previous facts applying rule see 
natural deduction kernel isar directly corresponds underlying logical framework cf 

example meta level rule statement may established follows 
proof fix assume show proof qed basic idea build isar proof text corresponding directly logical connectives fix assume show 
practice proof problems usually emerge different claim refined initial proof method encountered 
see chapter basic examples natural deduction isar 

syntax semantics despite primarily focused plain natural deduction proof descriptions isar framework turns sufficiently flexible support rich environment linguistic expressions readers writers may find satisfactory primary representation formal documents 
see chapter chapter systematic exploration resulting space useful proof patterns 
syntax semantics syntax isar theory proof specification language defined set primary commands defined syntactic category command 
syntactic viewpoint sequence commands formed isar document 
semantics command determined transition underlying configuration may background library theories individual theory proof state subdivided different modes 
basic typing commands induced transition semantics impose certain structure isar documents achieves block structured formal language may usual form context free grammar retrospectively see 
having isar language emerge bottom manner emphasize incremental interpretation process formal proof checking coincides interactive development debugging commands turn sufficiently fine grained support reality 
may easily extend basic language derived commands defined abbreviations existing ones potentially depending current state 
derived elements may freely combined rest language typing determined semantics underlying primitives 
achieve maximal degree language compositionality free having maintain fixed global grammar 
consequently isar primitives may restricted bare minimum required bootstrap language environment 
number standard derived elements introduced see indispensable basic applications 
canonical slots extensions proof methods goal refinement schemes attributes operations involving facts basic ones included general isar setup see 
subsequent definitions syntactic categories related basic isar language notation regular expressions parentheses 
grouping zero occurrences language element likewise zero occurrences furthermore recall basic formal items introduced nat natural numbers bool truth values name basic names type formed simple types term typed terms prop propositions terms type prop theorem derivable propositions 
chapter 
isar proof language isar commands isar proof language consists main layers sub languages command primary proof commands method operations goals attribute operations involving facts presently main focus primary command language 
secondary ones method attribute may considered parameter isar framework 
merely specify fundamental methods attributes see leaving concrete working environments incorporate tools appropriate collection automated proof methods isabelle hol see 
primary language command defines number primitives theory proof operations follows 
command theory name name name types name nat consts name type axioms name atts prop theorems name atts name atts theorem name atts prop apply method done proof method qed method term term term term note name atts name atts name atts name atts fix var assm rule name atts prop name atts prop name atts prop show name atts prop additional basic categories defined 
var name type case var prop fact theorem rule theorem theorem name atts name attribute 
syntax semantics order simplify subsequent treatment commands fix default values optional arguments follows 
proof default method rule see qed default method succeed see name atts default name empty list attributes note rule argument assm treated special way isar proof texts users may refer directly concrete syntax rule available 
assm may occur indirectly derived commands basic context elements assume presume def case introduced 
basic types commands formal isar text syntactically correct iff conforms degenerate grammar command certainly impose specific structure formal texts determined part operational semantics commands involving fine grained typings 
assume types library background storage theories theory theory contexts proof proof configurations 
isar commands types expressed signature diagram 
library theory types consts axioms theorems theorem theory proof done qed basic types isar commands apply done proof qed note fix assm show corresponding basic typings introduce classification isar commands 
theory setup commands theory theory specifications types consts axioms theorems theorem improper proof commands apply done proper proof commands proof qed note fix assm show chapter 
isar proof language naturally proof commands proof configurations main focus isar see details 
presently shall point aspects isar concept proof may embedded theory specifications including integration enclosing library theories 
underlying concepts theory library happen closely related versions isabelle paulson berghofer wenzel 
particular model mainly serves working example obviously isar proof language embedded different theory concepts 
theory consists purely logical declarations explicit environment facts additional slot keep kind auxiliary information data 
record theory types set name nat consts set name type axioms name prop theorems name fact data data data slot left unspecified purpose 
kept theory affect meaning purely logical point view 
concept extra logical theory data proves indispensable tool support advanced theorem proving environments separate contexts rules automated proof procedures high level theory specifications see chapter 
commands types consts axioms shall maintain corresponding primitive theory fields obvious manner theorems provides direct interface update theorem environment theorem conceptually quite different previous ones enters proof configuration eventually resulting actual theorem updates theorems accordingly 
theorem names shall considered reserved standard assignments empty fact respectively 
library shall represent kind background storage individual theory objects usually inherent notion acyclic dependencies 
record library theories name theory deps name set name viable theory management large scale applications issue ongoing research logical perspective pollack change management view reif hutter 
concerning isar demand primitive theory 
bn commencing new theory context merge existing ones put result back library 
independently automatic mechanisms update 
syntax semantics change management synchronization external repositories core isar commands operate theory proof configurations linear fashion 
deliberately rule unstructured interaction theory arrangement particular context entered 
example command ad hoc import existing theories context 
idea provide commands compose collection defined theory documents ad hoc manipulations formal entities 
isar vm transitions ready define operational semantics actual isar proof commands interpretation transitions isar virtual machine isar vm 
definitions isar vm configurations type proof mainly consisting static proof context plus dynamic goal information 
shall fix semantics proof commands initial terminal linking theory context interpretations proof methods additional case bindings attributes proof theory contexts left parameters 
command theory proof command proof proof command proof theory method context fact tactic name case method context fact tactic attribute context theorem context theorem attribute theory theorem theory theorem proof configuration defined stack basic proof states proof state stack represents block structure proof text proof commands usually operate head stack affect block structure 
record state mode prove state chain context context goal goal modes operation distinguish fundamental modes operations isar vm informal meaning prove awaiting direct transformation claim method application state ready state new local items assumptions local claims chain awaiting new claim previous facts indicated chapter 
isar proof language isar proof commands acquire certain typings modes shown 
imposes inherent structure isar proof texts role proof commands may play particular situation 
sequences proof commands may get successfully processed isar vm interpreter correspond legal paths diagram 
note structural constraints achieved proper nesting blocks encoded mode field determined stack structure 
apply prove theorem done show proof done show chain state transitions isar proof processing qed note fix assm inherent fine grained typing proof states key concept isar vm proof processing 
achieve structured texts incremental checking individual commands 
contrast traditional tactic scripts operate single kind state may expressed isar framework 
restriction improper proof commands original isar vm diagram degenerates 
apply prove theorem done transitions tactical theorem proving apparently tactical theorem proving holding breath claim solved completely direct goal refinements meth qed 
syntax semantics ods 
proper isar proof texts usually perform zero direct steps order change quickly rich landscape state mode order explore context casual manner 
see discussion issue operational versus declarative theorem proving practice 
state components apart mode field isar proof states clearly separated components static proof context versus dynamic goal information 
general principle context keeps items directly correspond declarations text assumptions finished claims term fact bindings goal state contains leftover claim may undergone direct refinements 
operational semantics take care results proof methods may intrude subsequent proof text 
record context theory theory fixes var rule terms name term cases name case facts name fact data data theory kept enclosing context changed final proof step just handing back theory level 
fixes fields correspond logical contexts 
hhf normal form cf 

plain propositions keep corresponding discharge rules assumptions see 
addition maintain auxiliary environments terms cases facts immediate logical significance indispensable support course reasoning structured high level manner enables proof commands refer bits pieces logical entities construction 
slot arbitrary data inherited theory may hold information separate contexts dedicated proof tools see 
record goal solve bool name name atts attribute statement prop fact problem theorem goal fields contain bookkeeping information capture state pending claims solve distinguishes show chapter 
isar proof language intended refine enclosing claim finished name atts keep original declaration applied result eventually statement holds original claim tracks facts indicated forward chaining indicated empty list problem holds internal goal state represented theorem underlying logical framework cf 

order individual constituents isar proof configurations roughly corresponds significance practical application framework static context corresponds piece proof text certain position interest dynamic goal information relevant isolated situations direct refinement takes place 
contrast traditional tactical proving revolves goal problem part ignorant rest 
purpose redundant apparatus isar vm proof configurations support interpretation model formal proof texts enables writer arrange course reasoning way reader liberated account accidental behavior primitive operations underlying arbitrary proof methods 
interpreting commands ready define interpretation proof commands isar vm transitions recall left open 
refer chapter basic operations record field manipulations composition theorems rules logical framework order avoid excessive notational detail convention record operations may applied complex structures stack state record state context goal 
furthermore partial functions procedures cf 
shall converted implicitly required plain functional notation may specification 
brevity main definition combinatorial style mentioning configuration transformed explicitly 
recall procedural composition alternative choice 
theorem init proof open block prepare term bind goal init goal false put mode prove apply assert mode prove transform goal put done assert mode prove conclude goal refine enclosing store result bind result set put mode state proof assert mode prove transform goal put mode state qed assert mode state assert goal true transform goal transform goal finish conclude goal refine enclosing store result bind result set put mode state 
syntax semantics assert mode state open block put goal open block assert mode state export close block assert goal false close block set assert mode state close block open block reset put mode state 
pn assert mode state prepare terms bind terms pn reset note 
rn assert mode state prepare facts rn bind facts set fix assert mode state map fixes fixes 
fixes reset assm 
assert mode state prepare add bind facts set assert mode state put mode chain assert mode state chain open block prepare term bind goal init goal false put mode prove show assert mode state chain open block prepare term bind goal init goal true put mode prove special proof method finish encountered ensures goal configuration reduced remaining subgoals solved assumption directly applying single rule current prems resolve 
auxiliary functions need defined see 
ultimately provide mathematical model isar vm interpretation process isabelle isar wenzel 
presentation may serve semi formal exposition general idea isar proof processing 
internal operations subsequent definitions internal operations encountered notational conventions theory argument theorem fact state proof 
recall backwards application binding tightly 
names isar language shall reserved sense may bound directly proof texts users internally primitive derived commands 
thesis 
terms prems facts rule context cases 
initial proof configuration merely consists initial context turn contains enclosing theory changed main proof inherits global theorem environment auxiliary data 
init proof mode state context init context goal init context theory fixes terms cases facts get theorems prems data get data chapter 
isar proof language basic block management mediated inherent stack structure proof configurations 
open block close block assertions ensure certain types proof configurations encountered operation isar vm interpretation process simple stops failure condition 
note goal record kept additional level nesting enables jump blocks expected 
assert mode get mode undefined assert goal get goal undefined special fact binding maintained hold result undefined order cause failure forward chaining 
set map facts reset map facts undefined export operation performs fundamental adjustments required move theorem context local parameters assumptions essentially context difference discharged inside 
intro rule generalize 
export get fixes get fixes get get intro intro generalize terms entered text normalized respect current environment term bindings 
basic operation norm shall replace occurrences schematic variables term norm lookup binding normalize recursively operation fails unbound variables 
unify shall perform simultaneous higher order unification pairs terms enumerating possible result bindings 
note immediate term bindings covered degenerate patterns consisting single variable 
special dummy pattern refers fresh schematic variable occurrence allows specify patterns certain positions skipped 
prepare term norm get terms prepare terms ts map norm get terms ts prepare tss map norm get terms tss bind terms pn map terms unify pn explicit statements text give rise automatic bindings reserved names depending role goal result statement 
important 
syntax semantics note peek theorems facts goals merely analyze terms stemming text 
proposition form decomposed follows yields term rule context yields case argument yields right hand side application undefined 
bind goal map terms thesis map cases rule context rule context bind statement map terms 
argument goal operations manage dynamic component proof configuration 
initially setup goal record consisting result specification presently chained facts trivial proof state represented theorem 
init rule 
init goal solve name atts put goal solve solve name name atts atts statement get mode chain get facts problem init reset open block put goal goal transformations occasion application proof methods may refer arbitrary tactics inside cf 

transform goal tactic cases get context get add cases map cases cases add cases map problem tactic add cases operation concluding goal exhibits finished result ways export enclosing goal applicable immediate binding context 
generalize conclude rules 
conclude goal goal get goal generalize conclude get problem goal result get name goal get atts goal get statement goal get solve goal export result order refine enclosing problem innermost structure sub proofs search stack proof states upwards apply theorem export respect context difference 
refine rule encountered takes care assumptions subgoal markers attached premises export 
select operation shall traverse subgoals left right enabling subsequent refine succeed match 
chapter 
isar proof language refine enclosing solve exp solve map enclosing map problem refine exp select map enclosing get goal map goal map enclosing export facts goal context covered 
purge operation shall remove markers may got introduced export markers significant actual goal refinements 
export outer purge export outer get facts facts emerging proof text assumptions finished goals may modified attribute expressions 
recall interprets attributes context theorem context theorem theory theorem theory theorem depending context 
lifted lists attributes sequential composition left right apply facts function evaluates lists pairs facts attributes returning modified context accumulated results 
single theorem works follows apply facts 
general definition uses iterate combinator 
apply facts iterate 
iterate referenced facts retrieved environment modified attributes 
binding facts may involve additional attributes left hand side specification applied just actual environment update 
prepare facts apply facts get facts get facts bind facts apply facts map facts 
proven result finished proof put back enclosing theory concluding main proof altogether bound local proof context continued proof operation 
store result get theory apply facts map theorems bind result bind statement bind facts assumptions introduced chunks giving list proposition lists 
additional structure merely serves separate naming resulting local facts premises flattened internally 
assumption rule generalize 

syntax semantics add 
map generalize assumption map 
bind statement map facts prems prems 

example interpretation briefly review operation isar vm interpreter small synthetic example particularly illustrates policy interpretation eventually leads application primitive inferences notably refine 
proof text fragment merely covers main elements generic assm show context different goal 
fact isar commands perform bookkeeping steps essentially serve preparation fundamental incidents actual goal refinement 


proof succeed 
assm 
show 
proof 
qed confined certain raw expressions isar commands normally occur reality identity method succeed see assm primitive supplied inference rule discharging marking assumption 
see definitions derived commands proof methods actual user applications 
subsequently give generated sequence internal operations suppressing successful assertions merely result identities 
second column exhibits trace primitive inferences encountered interpretation 
initial proof configuration shall state mode 
assume proof refers successful sequence commands done qed returning original nesting level corresponding show 

open block prepare term bind goal init goal false init put mode prove 
proof succeed transform goal succeed put mode state chapter 
isar proof language 
assm prepare add assumption bind facts set 
show open block prepare term bind goal init goal true init put mode prove 
proof conclude goal conclude refine enclosing refine bind result set put mode state 
qed transform goal succeed transform goal finish conclude goal conclude refine enclosing bind result set put mode state terminal context holds fact assignment 
recovering static syntax basic property isar vm transition system shall see static syntax proof texts may recovered deriving context free grammar approximates language legal proof texts 
inspect definition viewpoint mode field stack structure block nesting taken account 
commands may affect blocks goals theorem show proofs done qed separate block commands 
blocks opened pairs optional goal placed 
may get goal sandwich form goal produced goal commands plain block opening produced 

syntax semantics see proof exactly match goal plain openings copes case preserving 
consequently proof statement blocks properly nested interfering 
consider mode behavior proof commands 
proof statement refer sub language commands successfully processed state mode 
apparently category consists properly nested blocks basic context statements goal statements complete proof optional chain indicator 
category proof unfolded prove mode similar fashion consists optional initial scripts apply elements followed properly nested proof texts done terminator 
linking proof language theory level indicated may easily complete syntactic approximation wellformed isar proof texts giving grammar omit command arguments clarity 
theory statement types consts axioms theorems theorem proof proof apply proper proof done proper proof proof proof statement qed proof statement proof statement note fix assm goal statement goal statement proof show proof grammar refined include state current facts 
consequently legal specified explicitly grammatical means ruling malformed phrases 
note presentation covers core language isar stemming basic set commands considered 
language extensions introduced see chapter chapter chapter may provide concrete method attribute definitions extend primary command language 
may affect integrity previous isar grammar methods attributes clearly delimited enclosing syntax 
contrast derived commands easily lead syntactic conflicts due non modular nature arbitrary grammar specifications 
practice may achieve robust syntax extensions restricting definitional pattern derived isar commands essentially new keyword optional arguments expands sequence existing command phrases complete local proofs may safely incorporated see syntax obtain introduced 
disciplined way building isar language results syntactic environment clean open minded extensions 
chapter 
isar proof language generic support natural deduction isar framework covered far needs standard elements enable users express actual natural deduction concepts properly 
includes concrete context elements assumptions see attributes proof methods composition rule application see basic derived commands allow isar texts written see 
context elements speaking terms pure calculus model natural deduction context elements closely correspond abstraction 
recall primitive framework provides different layers abstraction term language function space universal parameters quantification hypothetical proofs implication 
explicit contexts required building syntax language terms built type checked directly 
furthermore universal parameters merely introduce local elements proof fix see just generalized export imposing additional hypotheses result see practical issues 
contrast actual logical hypotheses need taken care specifically 
assumptions propositional level discharged specific manner eventually depending particular context element involved 
basic operational model isar provides generic assm primitive parameterized inference rule determine exact behavior 
core element shall define actual user level context commands assume strong assumptions presume weak assumptions def local definitions case invoking symbolic contexts 
extend primary isar language follows 
assume name atts prop name atts prop presume name atts prop name atts prop def name atts var term case name atts conventions default arguments augmented def standard name name atts shall def defined variable 
basic isar context elements directly defined terms assm rule schemes discharge discharge expand 
assume 
assm discharge 

presume 
assm discharge 

def fix assm expand 
generic support natural deduction discharge expand discharge proviso free rules clearly derivable basic logical framework 
strengthen local contexts sure mention additional assumptions stated 
get discharge iterate intro rule works discharge recall marks logical significance 
order derive expand discharge equality generalize affect context right hand side specialize apply modus ponens reflexivity observe rules really get rid assumptions introduced assm rule needs map order guarantee isar vm interpretation process fail unexpectedly due pending hypotheses 
difference assume presume result treated goal context cf 

indicated markers new premises resulting discharged strong assumptions forced unify original goal context weak version simply leaves hypotheses new goals cf 
refine 
see practical isar context elements 
case command provides abbreviation fix assume elements 
invokes local context assignment current proof state 
name get cases define case follows 
case fix assume recall separate isar command bind case names 
apart automatic rule context case see cases may introduced suitable proof methods cases induct covered 
methods attributes method combinators proof methods may refer arbitrary procedures operate primitive goal configurations 
potentially infinite sequences results may represent multiple choices fixed collection rules enumeration higher order unifiers arbitrary internal proof search 
isar provides standard collection method combinators compose procedures simple fashion analogous regular expression operators 
chapter 
isar proof language sequential composition methods alternative choice methods 
try method repeat method succeed identity method sequential composition repeat frequently practice coincides succeed repeating method including zero times may expressed separate 
note excessive method combinators indication highly operational expressions unstructured proof scripts 
principle long script proof methods mn may included single proof step 
structured isar texts involve simple method expressions 
basic methods introduce generic proof methods 
syntactic category method extended follows 
rule name atts rule assumption insert name atts unfold name atts fold name atts rule method provides direct interface primary inference mechanism pure framework higher order resolution cf 

general form rule takes explicit collection rules tried left right 
complete list chained facts taken account 
rule method performs goal current goal state rule reduced applying facts parallel result applied subgoal 
omitting argument rule method means refer standard rules declared context 
attributes intro elim take care appropriate rule declarations dest declares eliminations projection format applying turned 
eliminations tried introductions chained facts interpreted pure pattern 
method applies chained facts immediately left right rule chained facts method performs goal 
just goal common case singleton chained fact 

generic support natural deduction assumption method applies exactly rule immediately singleton chained fact current prems proof context 
new premises emerging application non atomic rules solved locally assumption 
method merely inserts chained facts goal configuration form zero facts encountered practice 
insert method inserts exactly argument facts ignores chained ones 
unfold method normalizes problem collection equalities repeated application substitution extensionality rules cf 

counterpart fold normalizes swapped rules 
common instances methods assumption may expressed terms basic rule follows 
rule singleton facts assumption rule prems empty facts atomic assumptions rule atomic facts length basic operations facts attributes operate theorems changing current context 
extend syntactic category attribute follows term name atts name atts symmetric attribute provides primitive operation positional instantiation fact expression 

attribute performs application number facts higher order resolution cf 
expression 
attribute exchanges roles operator operand needs singleton 
symmetric attribute swaps equality facts 
method expression fold unfold symmetric 
derived commands shall introduce simple derived commands top set primitives provided far 
primary syntax isar commands cf 
extended follows 
chapter 
isar proof language lemmas name atts name atts lemma name atts prop name atts prop name atts prop name atts name atts name atts name atts method method 
default second method argument shall succeed just qed constituent cf 

derived commands defined follows 
lemmas theorems tag lemma lemma theorem tag lemma show note proof qed 
rule collection seemingly trivial shorthands emerged practical performed isar achieving significant improvements reading writing proof texts 
care taken abbreviations shall added excessive specific elements may eventually obscure meaning texts casual readers 
observe equalities isar commands due operational semantics 
achieve alternative characterizations basic operations involving important primitive 
show equality enables writers take apart individual phases terminal proof steps fine grained manner 
turns quite handsome interactive development debugging 
apply apply apply assumption 
done concepts principle isar vm interpretation process far sufficiently powerful support high level proof texts 
real implementation isabelle isar wenzel covers fine points 
concepts turn quite important improve usability isar practice 
briefly review issues outside core logical framework 
casual term abbreviations substantial parts structured proofs consist propositions sub terms explicitly text 
important prerequisite achieve presentations place operational proof scripts refer internal goal transformations 
hand excessive amount concrete terms text tends degrade readability right 
adequate syntactic abstractions turn key issue expressing formal reasoning succinctly 
isar provides concept term abbreviations command 
practice extra overhead separate abbreviation statements text cumbersome 
isabelle isar offers additional element admits term abbreviations introduced fly 
basic syntax isar commands augmented include optional patterns occurrence term prop 
concrete syntax casual abbreviation forms follows term patterns term prop patterns concl prop term mentioned text may get immediately analyzed higher order matching pattern essentially provides immediate benefit return duty write explicit statements place 
example annotated claim lhs rhs enables succinct potentially unwieldy terms 
say proof proceeds antisymmetry argument body may just state show lhs rhs show rhs lhs 
presentation may clarify actual proof pattern involved 
concl specifier prop patterns indicates matching nested meta level implication concl effect uses dummy pattern cf 

form concl thesis documents builtin binding thesis cf 
outer parameters 
likewise concl represent implicit argument binding 
common case equational propositions 
recall 
technically acts schematic term variable 
full power term abbreviations exhibited actual higher order matching complex statements 
main application proof induction see 
idiom essentially decomposes statement 


predicate abstracts occurrences fixed variable original body 
standard procedure enumerating higher order unifiers isabelle paulson ensures really chapter 
isar proof language abstracts occurrences normally intended user 
example binding enables succinct expressions relevant statements mathematical induction base case induction hypothesis suc step case 
see advanced proof patterns 
casual term abbreviations isabelle isar generally great virtue reduce need special proof language constructs 
example declare syme syme syme requires separate provisions macros induction patterns 
mizar rudnicki trybulec muzalewski wiedijk includes dummy goal statements existence uniqueness cover certain proof obligations arising particular specification mechanisms see related discussion 
analyzing term structure higher order matching serves viable replacement direct term manipulation potentially heavy userinterface support proposed bertot bertot 
contrast interactive manipulations performed run time user casual abbreviations isar may easily document advanced structural decompositions primary text just term patterns 
formal comments perspective recipients ultimate intention isar language describe formal documents consist theories specifications proofs alike cf 

reality theory texts may contain additional information outside formal logic sectioning informal explanations writer 
isabelle isar wenzel provides markup commands chapter section subsection text text argument 
concerning isar markup commands formal meaning part syntax language 
actual formal commands considered far may include marginal comments form text related particular entities individual declarations consts cf 

consts blah 
cn markup commands marginal comments qualify formal comments explicit relationship formal elements despite devoid logical semantics 
note commonly encountered source comments existing languages usually clear indication relationship formal entities 
comments may typically float input text completely manner 

concepts content formal comments ultimately passed document preparation front pdf atex isabelle isar 
text essentially consists source code typesetting system passed preparatory stage isabelle 
text specifications isabelle isar may contain embedded formal entities typed terms propositions theorems context 
concept embedding interpreted parts uninterpreted quoted text called anti quotation existing concepts lisp folklore 
basic syntax anti quotations isabelle isar name args see wenzel 
practice important follows 
term typed term prop typed proposition thm facts lists theorems text uninterpreted text anti quotations process argument formal context emit checked result document output pretty printed form just isar text 
degenerate text anti quotation merely outputs argument string directly treats mathematical symbols isabelle isar style cf 
raw atex 
unchecked formal descriptions may notation real isabelle isar objects demanding ad hoc atex math mode 
effect seamless integration formal informal portions text single isabelle isar source considerably reduces effort report theory developments consistent manner 
existing approaches literate programming notably knuth web system need filter formal informal views separately 
isabelle isar finished proof documents output side effect formal proof processing turn merely ignores certain parts text 
type inference polymorphism theory may easily pretend terms isar proof texts fully annotated types type checking rules underlying framework 
practice users may spared explicit type annotation chores established technique automated type reconstruction known type inference 
happens isabelle pure implementation paulson nipkow 
important note syntactic typing issues need considered actual logical framework accidental feature implementation 
analogous concept parsing automatically reconstructs syntax trees user input handsome concrete syntax 
theory parsing considered issue formal logic long ago lost relevance eventually standard parser tools chapter 
isar proof language established 
order simple type inference available isar proof texts maintain additional fields variable typings type variables proof context structure 
typing frees name type typing vars name type types set name environments typing frees typing vars determine types variables encountered proof text processed far 
new terms prepared inclusion text perform standard mutual type inference context typings resulting term extend declarations 
order guarantee general results type inference occasionally needs invent new type variables chosen apart set types maintained accordingly 
resulting discipline type reconstruction proceeds sequentially left right list isar commands observing block structure obvious manner 
scope mutual type inference limited arguments individual isar command assume 
covers propositions simultaneously 
practice scheme fair time annoying situations may occur inferred typing general intended writer due lack typing information text 
may cause unexpected failure type checking logical inferences rules specific type instances probably due overloading 
certainly writers may fall back explicit type annotations requiring readers isar proof texts care 
hand isabelle users generally expect typing issues treated automatically scenes 
failures encountered apt cause considerable confusion actual problem figured hand eventually 
refined type inference scheme hindley milner known polymorphism hindley milner slightly flexible 
improved typing discipline needs extend pure calculus separate binder term variable bound locally body canonical conversion rule 
operational idea simulated pure calculus redex key point hindley milner polymorphism separate primitive provide specific typing rule achieve localized form schematic polymorphism 
hindley milner polymorphism extends language simple types type schemes include generalized type variables may instantiated arbitrarily 
literature usually represented flat prefix universal type quantifiers 
isabelle pure may express idea 
concepts schematic type variables canonical typing rule expressions inferred type local binding replaced general type scheme type checking body fixed type variables occur fixed term variable context schematic ones 
typing may instantiated body 
order incorporate refined typing discipline isar vm interpretation process merely introduce field proof context 
fixed types set name isar proof processing fixed types component maintained hold set type variables considered fixed due occurrences types term variables manifest previous text bound variables constants matter 
need identify suitable kinds bindings isar type schemes may generalized locally 
recall isar vm interpretation process may understood certain policy composing proofs general calculus concepts cf 
see user level view 
perspective easy see kinds isar context elements qualify polymorphic binders term abbreviations introduced local facts emerging primitives note show 
note polymorphic treatment proper abstraction elements fix assume demand actual polymorphic calculus see barendregt quickly lead substantially complex situation undecidable problems 
hand variables introduced unconstrained fix statements isolation need typed actual occurrence subsequent text stages binding typing variables may kept separate ado 
local definitions def principle treated polymorphic formulation isar def appear monomorphic fix assume 
minor drawback hard fix reality mainly isabelle pure implementation paulson nipkow admit fixed variables different type instances theorems 
note significantly important practice 
order get idea hindley milner typing works isar consider synthetic example 
chapter 
isar proof language occurrence second occurrence rule refl 

bound identity function types generalized fully 
checking subsequent goal statement typing instantiated twice held fixed proof 
resulting theorem types fully generalized 
reality actual polymorphic proof texts rarely encountered 
key virtue hindley milner polymorphism isar achieve defined discipline able amend problems overly general inferred types due incremental processing text 
recall original problem caused lack syntactic relationship previous proof text potential follow material 
situation naive type inference invent new fixed type variables expressing unrestricted generality 
refined typing discipline due hindley milner able generalize variables reason got introduced place gives subsequent typing stages chance instantiate required 
experience isabelle isar shows fine tuned discipline really able relieve proof writers typing issues practice 
certainly situation simpler batch mode proof processing text may covered declare syme syme syme 
mizar rudnicki trybulec muzalewski wiedijk requires users give type annotations 
chapter example order logic formulation intuitionistic order logic canonical instantiation generic isar framework 
demonstrates existing tradition object logic declarations isabelle environment may extended cover readable presentations formal proofs 
handling specifications proofs high level manner isabelle isar qualifies truly complete logical framework 
example order logic discuss basic techniques basic natural deduction proofs isar systems 
formal development theory order logic pure theory development introduces single sorted intuitionistic firstorder logic equality 
giving common concrete syntax basic axioms definitions derived rules readable formal proofs standard derived rules examples 
syntax categories higher order syntax object language consideration individuals object statements shall implicitly meta logical judgment derivable sentences 
typedecl typedecl chapter 
example order logic judgment prop propositional logic basic propositional connectives axiomatized canonically follows 
consts false imp infixr conj infixr disj infixr axioms elim impi intro mp dest intro elim intro intro derived rule simultaneous conjunction elimination usually convenient referring individual projections separately 
theorem elim proof assume ab assume show proof rule ab show rule ab show rule qed qed furthermore introduce derived concepts plain truth negation 
true 
formal development theorem truei intro proof unfold true def show 
qed theorem noti intro proof unfold def assume 
qed theorem note elim proof unfold def assume 

qed equality equality individuals axiomatized high level manner reflexivity substitution primitive 
remaining equivalence properties easily established derived rules 
congruence properties covered substitution rule stated explicitly 
consts equal infixl axioms refl intro subst theorem trans rule subst theorem sym elim proof assume refl show rule subst qed quantifiers underlying logical framework quantifiers simply certain operators predicates concrete syntax binders recovers commonly notation 
consts binder chapter 
example order logic ex binder axioms alli intro dest exi intro exe elim simple example reasoning quantifiers statement taken paulson 
lemma proof assume proof fix assume thesis 
qed qed subsequently establish known result quantifier reasoning naturally converse statement hold general 
lemma proof assume proof fix assume show thesis proof fix 

qed qed qed discussion generic proof support object logics basic formulation fol isabelle object logic closely follows similar example paulson proofs expressed isar 
discussion proof language traditional tactic scripts 
purely declarative specification logical syntax axioms derived rules expressed explicit theorem statements meta logic key concepts basic isabelle pure framework beginnings paulson paulson paulson 
contrast original tradition lcf hol family systems required explicit programming derived rules functional programs written ml meta language see historical account gordon 
perspective isar approach readable proof documents continues mission overcome low level technical presentations formal logic 
framework isabelle pure isar able support logical syntax axioms derived rules readable formal proof texts declarative manner 
illustration different conceptual levels proof construction traditional isabelle pure versus isabelle isar reconsider fol example paulson 
presenting proof scripts paulson sets lengthy exposition number internal features isabelle system covering details higher order unification composition rules higher order resolution back chaining lifting rules logical contexts representation proof states rules basic concepts tactic language 
technical issues isar framework covered hood higher level concepts isar proof language exposed recipients 
consequently able theory casual manner specifications proof texts 
recipients familiar natural deduction techniques basically able read proofs explanations required 
hand additional insights formal proof language certainly needed write proof texts kind 
recall isar follows principle primacy readability 
notable issue automated proof tools especially completely absent example 
isabelle environment paulson nipkow provides number powerful proof tools simplifier classical reasoner new configure tools explicitly place 
apart explicit proof method specifications unfolding definitions applying basic rules merely simple default proof tool supports single natural deduction rule applications implicit manner rules determined theory declaration includes hints intro elim dest 
pure applications chapter chapter certainly demand additional advanced tools see 
general principle isar independent particular notion automated reasoning able tools happen available 
notable contrast common believe high level proof chapter 
example order logic checking 
consequently mizar rudnicki trybulec muzalewski wiedijk certain notions obvious inference steps hardwired proof checker 
likewise discussion mizar mode hol harrison dedicated issue justification proof steps proof procedure substantial parts structured proof language spl covers order automated reasoning 
contrast isabelle isar demonstrates meaningful applications may conducted plain higher order resolution single steps arbitrarily complex tools may incorporated non intrusive manner see 
natural deduction schemes order theory provides number rules canonical treatment logical connectives natural deduction cf 
gentzen 
appropriate declarations role introductions eliminations basic setup enables write isar proof texts directly correspond natural deduction schemes 
resulting presentation illustrates basic techniques writing isar proof texts 
time provides nice textual explanation natural deduction reasoning works place 
trivial elimination 
assume 
elimination proof contradiction proof assume proof qed assume 
canonical elimination modus ponens proof assume show proof 
discussion qed assume 
projections simultaneous elimination proof show proof show proof qed assume 
assume 
assume proof assume proof qed elimination propositional case split introductions assume proof assume proof assume proof qed assume 
assume 
basic equality rules reflexivity substitution elimination derived forms transitivity symmetry 
chapter 
example order logic assume rule subst assume rule trans assume 
canonical introductions eliminations quantifiers proof fix show proof qed assume 
assume 
assume proof fix assume proof qed proof schemes follow common expositions natural deduction rules quite closely thompson actual applications natural advertised 
particular equality rules elimination typical candidates refinements 
important point isar language concept course reasoning may rearranged numerous ways see examples 
furthermore isar supports number derived concepts address pure natural deduction encountered realistic proofs 
advanced techniques include generalized elimination schemes see chapter proper support equational reasoning calculations chapter 
declarative versus operational theorem proving shall investigate basic issues declarative proof texts versus operational proof scripts far plain natural deduction concerned 

discussion fundamental aspects proof construction natural deduction framework isabelle pure statements propositions rules probably instantiations composition partial results determining proof structure 
roughly speaking declarative proofs prefer state propositions explicitly provide rich text structure specify rules inference hand operational scripts merely give rules proof method specifications 
perspective declarative versus operational proofs exactly dual emphasizing complementary aspects formal proofs 
characterization turns slightly 
practice isar proofs may declarative operational different degrees 
actual readability result depends factors including intention writer addressing certain audience readers 
may demand highlight declarative operational aspects reasoning depending context 
just consider example large induction proofs involving inductively defined sets 
usually preferable suppress explicit propositions text give quasi operational specification induction scheme proof method plus structure emerging cases see chapter typical examples 
may gain readability shifting focus explicit propositions proof methods structure 
moment stay plain natural deduction illustrate basic declarative operational techniques isar proof construction 
variations propositional fact discussed 
proof texts version follows standard idiom plain natural deduction isabelle isar mixed forward backward reasoning cf 
basic elimination schemes 
lemma proof assume proof assume thesis 
qed qed apparently able complete proof naming rules explicitly just local facts 
deeper reason twofold 
explicitly stated assumptions intermediate claims giving actual proposition term 
may sound obvious thing chapter 
example order logic tactical theorem proving tradition attempt suppress explicit terms possible 
second proof quite detailed structure information quite implicitly nesting sub proofs performing suitable gestures indicate 
particular indicated forward chaining existing facts opposed mere backward reasoning appropriate involved 
order see better kind implicit processing basic inferences works detail shall expand proof sufficient operational detail exhibited 
basic abbreviations routinely expanding arrive slightly explicit scheme 
lemma proof rule assume show proof rule assume show thesis rule qed qed default rule method figures actual rule implicitly cf 
usually quite easy explicit goal statement indication forward chaining facts 
rules determined named explicitly version 
lemma proof rule impi canonical assume show canonical elimination proof rule assume show thesis rule canonical qed qed see canonical introductions may simply performed stating goal performing single default proof step likewise canonical elimination works indicating fact forward chaining 
may see third step forward chaining may result steps proof forced finished introductions tried eliminations cf 
scheme facts provided separate logical structure may eliminated 
subsequent version obfuscated include explicit instantiations rules 
certainly normally leave builtin unification isabelle paulson nipkow syntactic details 

discussion lemma proof rule impi assume show proof rule assume show thesis rule qed qed highly redundant proof texts see isabelle isar proof checking involves twofold book keeping process explicit statements structure side operational steps side 
common isar idiom usually prefers declarative parts operational ones may choose isar framework sufficiently flexible support improper uses language 
liberal attitude certainly demands taste distinction user lest system abused manner 
proof scripts version follows purely operational style tactical proving expressing main reasoning steps string proof methods main statement left explicit proposition 
lemma rule impi rule apparently way emulating traditional tactic scripts stretches isar method language cf 
bit far sequential composition methods express course reasoning single command 
worse form impractical interactive development debugging command succeeds fails single atomic transition isar vm interpreter cf 

proof scripts appropriately represented improper proof commands apply done cf 
support step step goal refinements refer implicit isar reasoning steps implicit finishing assumption cf 

lemma apply rule impi apply apply rule apply assumption apply assumption done chapter 
example order logic commands expressed immediate proof unstructured scripts better null proof terminator done name required assumption steps explicitly improves robustness maintainability 
see operational scripts consist method specifications explicit propositions occur structural hints limited plain rule basically amounts limited form forward chaining gesture indicated proper isar proof texts 
furthermore proof scripts provide immediate information inherent tree structure proof problems emerging new subgoals proceed 
customary indent script commands accordingly merely counts comment processed formally 
note particular problem specific isabelle paulson nipkow cost flexible approach internal goal addressing 
proof scripts systems reflect subgoal structure directly text coq barras hol gordon melham provide separate combinators fork script sub scripts order address corresponding goals separately 
proper isar proof texts hand may benefit isabelle flexible scope internal goals suffering potential problems structure isar sub proofs determined explicit local statements text show 
common pattern establish local claims directly atomic proof involving tiny script methods 
initial method chained facts splits original goal number subgoals terminal method solves number probably leaving trivial ones finished implicitly assumption local proof 
notable issue bringing explicit propositions back proof scripts 
existing systems isabelle paulson nipkow hol gordon melham provide number tactics take term specifications additional arguments subgoal tac simulate local claim goal state resembling isar extent 
tactical elements rarely tactical proving cf 
discussion simons 
experts tactical proving occasionally include comments mentioning intermediate propositions course reasoning 
shown longterm experience tactical proof scripts reason avoiding explicit quoting terms scripts may unstable hard maintain 
seen isar perspective problem static dynamic parts proof states cf 
context versus goal 
explicit propositions scripts belong static text need refer dynamic goal state emerging tactics applied far 
due nature common tactics dynamic result hard predict 
discussion easily mutates minor changes theory definitions declarations 
parts slightly obscure dynamic state intrude static text may quite surprising reader easily break existing proof scripts 
unfortunately realistic applications tuned operational proof scripts mention explicit terms occasionally explicit instantiation non trivial rules elimination induction schemes cf 
res inst tac classic isabelle paulson rule tac script emulation isabelle isar wenzel 
dynamically generated local parameters accidental names xa xb easily intrude proof scripts manner 
principle effects better accommodated careful usage tactics including rename tac fix parameter names 
hand kind odd behavior proof scripts generally accepted matter fact tactical theorem proving 
apart propositions part control script may consider restrict documentation purposes dynamic evolution internal goal state order gain accessibility result casual readers 
cohn proposes kind support proof accounts hol gordon melham 
system includes separate copy basic collection hol tactics produce suitable output current changes goal state 
approach faced problem reducing proof state information relevant bits 
raw goal state arbitrary intermediate positions typical proof scripts easily quite large printed pages extreme cases local differences previous steps represent actual progress 
subsequently give trace dynamic goal states encountered example proof script 
trivial case raw output cluttered irrelevant information 
lemma subgoals 
apply rule impi subgoals 
apply subgoals 
apply rule subgoals 

apply assumption subgoals 
apply assumption subgoals subgoals 
done key observations readable isar proof descriptions general course reasoning adequately represented static text referring dynamic goal information directly proper isar elements allow chapter 
example order logic place 
enabled replace internal dynamic trace goals long list large states single static text reasonable size 
general approach may expect readable proof representations scale large applications 
lesson learned isar framework liberal allowing ways conduct formal reasoning 
know system properly freedom provides powerful means interactive development experimentation unusual presentations final results 
isabelle isar texts may written arbitrarily bad style 
isar design deliberately suffers degree potential abuse price paid freedom recall principle non 
expressions natural deduction change perspective isabelle isar systems notations plain natural deduction 
comparing different expressions natural deduction corresponding isar proof texts gain understanding alternative systems isar 
original formulation gentzen plenty alternative systems notations devised represent natural deduction proofs adequately 
efforts include various forms diagrams lines boxes lay trees inferences cf 
basic formats encountered jape example advanced graphs pictures rendered proposed barwise etchemendy barwise etchemendy 
systems burstall mizar light wiedijk abel rediscovered value plain textual representations primary format proofs 
argue complex graphical representations limited small examples formal logic special applications 
diagrammatic presentations inherently restricted size structural complexity physical appearance 
quite hard oversee large pictures unclear start reading non linear representation place 
claim backed observation non textual proof formats rarely encountered large applications formal logic 
note traditional mathematics works linear texts time notable exception highly diagrammatic proofs encountered category theory example 
plain lambda calculus far primitive proof objects concerned natural deduction certainly adequately represented typed terms cf 

isabelle inference kernel berghofer nipkow provides concrete programming interface representation supporting tools 
discussion need externalize primitive proofs core system external checkers storage facilities primitive theories theorems facilities proof carrying code 
internal representation primitive proofs independent issue readable primary proof formats isar cf 

coq barras notion internal proof term tied calculus 
user experience interactive development goal oriented proof scripts directly expose foundations normal circumstances illustrated example 
goal prop 
intros ab 
induction ab 
split 
assumption 
assumption 
save example 
coq admits users construct proofs directly giving terms 
may provided definitions proof terms immediately included proof scripts feature typically expert users perform small forward inferences casual manner 
definition example prop ab ind conj ab 
goal prop exact prop ab ind conj ab 
save example 
ad hoc reasoning may simulated isabelle isar limited extent theorem expressions basic attributes composition instantiation cf 

composition covers plain application standard attribute abstraction proper isar proof context commands 
lemma proof assume ab show proof rule ab assume assume show thesis rule qed qed chapter 
example order logic hand aim isar proof language replace primitive notion terms primary proof format accessible readers 
theorem expressions attributes encountered rarely proper isar proof texts 
agda system agda coquand coquand positioned version coq different version typed calculus internally similar system philosophy 
default user experience agda quite different coq exposing calculus foundations directly primary proof presentation format resembles explicitly typed higher order functional programming language 
consider agda version running example example prop prop implies ab ab ab alfa separate graphical proof editor agda enhanced support natural language input output 
alfa user interface terms may drawn twodimensional diagrams established format natural deduction proof trees cf 
textbook exposition thompson 
typical proof presentation alfa looks follows important note formal structure underlying agda proof quite different previous 
ab ab ab agda alfa environment certainly represents basic paradigm natural deduction typed calculus faithfully 
hand general approach face standard issues scaling larger applications incorporate advanced proof tools functional programming presentation formal proofs agda draw large inference trees alfa 
versus bidirectional reasoning burstall small teaching tools interactive composition linear textual representations plain natural deduction proofs 
system generic sense new rules may added time writing functions tcl programming language involving regular expression matching 

discussion basic concepts inspired tradition calculus type theory primary format observes basic principle declarative proof texts cf 
including intermediate propositions explicitly text rules instantiations 
typical proof text produced 
form may entered directly hand usually composed interactively pointing appropriate rules applied step 
show show 


show 
show 
show qed may easily reproduce format isabelle isar follows 
lemma proof rule impi assume ab show proof rule ab assume assume show proof rule show assumption show assumption qed qed qed natural deduction format restricted pure backwards reasoning represented slightly plain assume show forward chaining 
furthermore admit auxiliary facts established separately cf 
isar achieved indirectly having assumptions emerge just right way 
assumptions facts may referenced may seen format labels dot text 
contrast isar allows local result established show results non linear reasoning dag shaped internal structure cf 
knaster tarski example 
follows systematic scheme complete labeling intermediate lines facts essentially path specifications underlying tree structure 
chapter 
example order logic lamport proposes similar format names includes additional notational devices address typical proliferation redundant labels emerging technique 
argue complete path specifiers quite appropriate realistic applications 
tree structure common proof texts linear anyway forks typically caused case analysis induction 
deeper reason labels text consist may observed accompanied isar version names 
demand labeled facts may reduced proper forward chaining insisting strict backward reasoning 
basic tuning arrive smoother isar version cf 

lemma proof rule impi assume show proof rule assume show rule qed qed primitive composition ab covered rule chained fact likewise incorporated assumption steps rule adjusting order appropriately 
seen actual rule specifications happen completely redundant explicit propositions structural information text provide sufficient clues determine scenes 
lemma proof assume show proof assume show 
qed qed see immediate forward chaining existing facts important ingredient streamline natural deduction reasoning reducing formal noise labeled facts 
variants illustrate isar liberal approach mixed forward backward reasoning depending structural details 
discussion proof may occasionally forced name facts standard rules explicitly 
lemma proof assume show proof show rule show rule qed qed lemma proof assume ab show proof ab show 
ab show 
qed qed lemma proof assume proof assume show thesis 
qed qed lemma proof assume ab ab 
ab 
show 
qed may observed version extremely forward style reasoning tends demand explicitly named local facts hand standard rules inference normally need named line needs closed separately leaving little choice rules applied 
name may easily reduced basic derived chapter 
example order logic isar commands involving cf 
particularly useful situations uses current facts earlier ones 
tuned version proof 
lemma proof assume ab 
ab 
show 
qed just peephole optimizations able reduce total number name occurrences defined referenced typical rate achieved real applications 
isar provides infrastructure basic natural deduction see chapter reduce need labeled facts large scale applications see 
strictly backward natural deduction presentation burstall complemented dual structured forward reasoning hofstadter 
format example looks cf 
hofstadter chapter vii 
push premise separation separation joining pop fantasy rule hofstadter calls 
form mode facts may locally invented discharged 
formal proof format abel happens example 
proof assumption kind forward reasoning may easily reproduced isabelle isar raw blocks see need name facts rules explicitly 
assume 
discussion rule rule rule 
see isabelle isar able cover range purely backwards purely forwards reasoning including conceivable intermediate arrangement 
mizar mizar rudnicki trybulec muzalewski wiedijk pioneered formal proof construction general guidelines established mathematical practice 
system tied classical order logic formulation typed set theory actual applications 
consequently internal foundations primary user experience farther removed pure intuitionistic look feel systems considered far including isabelle pure framework isar 
mizar provides main mechanisms formal proof checking implemented verifier proof outlining step wise refinement basic order principles terminal solving left problems builtin notion rudnicki 
despite inherently classical outlining mechanisms mizar may reasonable representations plain natural deduction proofs 
attempt emulate preferred version running example mizar 
mizar takes order foundations seriously simulate propositional variables set membership unspecified individuals 
reserve set theorem implies proof assume assume important note order assumptions fixed really need explicit naming fact order able distance 
second assumption may get directly linking subsequent step 
isar generally offers flexibility arranging key elements proof body 
particular assumptions may permuted repeated arbi chapter 
example order logic manner may rearranged 
may easily arrange text corresponding facts placed order clarify proof structure enable forward chaining reduce need named 
certainly assumptions introduced corresponding 
particular may just state assumptions happens get nested proper sub proof corresponding restriction enforces static scoping assumptions correspond abstractions compositional proof processing sub proofs may affect meaning enclosing text 
easy represent mizar proofs directly isar framework due fundamental semantical differences proof outlines processed 
observe mizar proof separate meaning serve delimiters proof body 
furthermore refers builtin automatic prover number additional facts mizar primitive technically encountered just include fact specification 
note mizar corresponds isar show isar mizar 
see wiedijk detailed attempt relate basic mizar isar language elements simplified model system 
apart superficial differences basic model processing proof outlines mizar fundamentally different way isar builds local contexts proof body solves goals eventually 
case main goal head proof encountered mizar operation may understood structured walk remaining problem transformed step step number outline commands assume ones corresponding basic order connectives quantifiers take consider trybulec see 
logical connectives treated implicitly implication conjunction 
mizar provides number additional concepts represent common patterns forward reasoning encountered mathematics notably iterated equality reasoning see diffuse reasoning goal statement head position 


elements away mizar basically arrive system close goal oriented paradigm tactical proving set tactics chosen carefully readability mind 
basic observation starting point mizar mode hol harrison worked mizar light wiedijk 
quasi operational style stepwise transformations single problem hand easily reproduced isar slightly declarative particular terminology mizar ideal linguistic reasons technically form suppressed due odd reading quasi natural language 

discussion sense arbitrary goal refinements may take place proof step performing qed 
isar proof body way pending goals directly fixed focus particular 
results meant refine enclosing goals built strictly declaratively giving suitable assume show statements proof body 
treatment mizar thesis versus isar thesis illustrates key difference structured proof processing quite nicely 
mizar thesis special placeholder remaining part problem currently working section proof body consequently thesis dynamically updated main step 
trace course value thesis mizar example may follows 
theorem implies proof thesis implies assume thesis implies assume thesis thesis thesis contrast isar thesis just term abbreviation happens bound automatically new claim stated text cf 

refers statically head proof 
initial goal refined non monotonic manner thesis useless current piece proof text 
updating thesis dynamically mizar quickly lead unreadable proofs initial goal refinements may involve just isar proof method 
hand mizar dynamic behavior cause real problems practice basic transformations available limited principles classical order logic relatively easy oversee 
give try emulating mizar example isar 
recalling canonical isar versions encountered see require additional nesting sub proofs order able enter logical structure problem 
lemma proof assume proof assume thesis 
qed qed mizar usually requires structural overhead dig order proof problems 
hand advantage strictly limited pure logic 
chapter 
example order logic contrast explicit goal refinements isar initial terminal method specifications may just ranging domain specific elimination rules declared user arbitrary automated proof tools 
fact theory intuitionistic order logic declared domain specific application place 
gain flexibility isar framework pays realistic applications formal logic chapter chapter chapter 
certainly concrete applications demand infrastructure plain natural deduction easy achieve top existing isar framework see chapter chapter 
advanced isar techniques introduced see may easily turn tide favor isar primitive example 
lemma proof assume obtain 

qed part ii techniques chapter advanced natural deduction explore broad range advanced natural deduction techniques isar 
includes systematic exposition capabilities existing language framework introduced far pointing practical virtues opposed pure calculus notions formal proof 
furthermore introduce additional derived concepts notably generalized elimination class proof context element specific support common schemes proof cases induction 
techniques turn indispensable means support scalable applications 
natural deduction introduced gentzen formalism represent way mathematicians perform proof principle 
modern expositions usually explain natural deduction terms typed calculus see thompson barendregt geuvers 
provides viable formal basis theoretical studies concrete implementations immediately offer means human readable presentations formal proof texts 
existing mathematical practice quite resemble pure calculus style reasoning 
explored aspects textual representation basic natural deduction elements earlier chapter considering isar view approaches 
isar proof texts encountered related basic concepts calculus abstraction context elements fix assume application general composition show rule applications involved proof qed steps 
derived elements calculus encountered notably various versions expressions covered note 
modified view application indicated 
chapter 
advanced natural deduction subsequently shall provide systematic exposition elements natural deduction available isar 
may expressed top existing language framework chapter correspond equally redundant additions plain calculus view reasoning 
resulting isar proof patterns turn indispensable prerequisites advanced applications chapter chapter chapter 
simple applications knaster tarski theorem benefit greatly derived elements 
general lesson learned subtle task composing proof texts needs accommodated considerable diversity formal language 
despite general aim keep core isar language small highly compositional nature results rich environment meaningful proof patterns 
principle holds natural deduction proper discussed light weight cousin calculational reasoning see chapter 
particular techniques explored exposition advanced natural deduction 

various basic techniques inherently core proof language chapter included discussion basic natural deduction far chapter 
speaking terms calculus includes non standard concepts general cascaded context elements see incremental see modified application composition see stand parentheses see internalized proof texts form meta level rule statements see 

support generalized eliminations derived obtain element see 
basically amounts existential quantification level isar proof texts conservative extensions local proof contexts 
having context elements fix assume emerge implicitly result previous backward reasoning obtain allows prove parameters assumptions may introduced certain point independent goals 
principle admits large number useful patterns considerable elimination formal noise 

specific infrastructure proof cases induction see scales practice 
depending additional proof methods attributes existing case command turned viable tool introduce large context elements proof texts succinctly corresponding canonical rules inductive sets types 
interestingly advanced issues covered revolve static proof contexts dynamic goal configurations 
observation 
basic techniques marks distinctive difference structured proof techniques versus existing approaches goal oriented tactical theorem proving traditional isabelle paulson nipkow hol system gordon melham coq barras 
calculational reasoning techniques chapter drive view ultimate consequence arriving proof style essentially devoid goals altogether 
basic techniques general context elements isar framework provides fundamental context primitives fix assm cf 

speaking terms calculus essentially correspond abstraction fix abstracts terms syntactic types assm facts internal proof terms 
proof text involving fix assm corresponds directly internal context proposition hhf normal form cf 

shall elaborate canonical equivalence transformations formula may performed isar proof texts conversion parameters permuting repeating premises commuting parameters premises law 
assm primitive directly available isar proof texts intended implement user level elements accordingly assume presume def case cf 

introduce derived obtain element see cover advanced uses case see 
contrast raw fix slightly degenerate individual concept involve special treatment discharge time 
hand derived context elements may refer fix assm simultaneously def obtain 
fixed variables variables introduced fix refer local objects purely syntactic exporting results elements may generalized canonical rule cf 

additional hypotheses wrt 
typing variables imposed underlying framework inherently assumes types inhabited see analogous situation hol object logic 
non dependent expressions may immediately simplified law portions isar proof texts involving fix convertible just corresponding binder expressions underlying logical framework 
consider trivial example 
chapter 
advanced natural deduction proof fix show proof qed proof fix show proof qed fact result proof body needs conform pending goal higher order unification 
text may cover general statement happens provable level generality 
proof fix show proof qed see isar proof texts bound accidental formulation goal statements may raise level abstraction 
existing proof systems directly focused particular goal statements cf 
intros element coq barras example 
interestingly assume mizar rudnicki trybulec muzalewski wiedijk essentially procedural paradigm see tactical view coq 
isar example exploits idea generalized proof bodies order re existing proof second time symmetric argument 
lemma proof fix general propositions may get instantiated assume proof assume thesis 
assume thesis 
qed result application 
basic techniques second symmetric result application qed exploited intrinsic virtue isar proofs cascading contexts 
having exported result cf 
proof invalidate existing context built far including kind local proof items auxiliary facts term abbreviations proper logical context elements 
second applies result general results may involve longer prefixes due additional context commands issued 
incremental behavior immediate consequence way isar vm interpreter manages corresponding environments static proof configuration context cf 

speaking terms plain calculus certain parts nested abstractions binder elements may shared expressions resulting slightly proof texts preferring linearized arrangements strongly nested ones 
strong assumptions assume fundamental proof context element 
introduces strong assumption sense exported results need unify corresponding premises enclosing goal 
finished proof fragments assume show essentially provide balanced textual focus particular open problem covering assumptions 
allows proof bodies situations cause ambiguities 
consider basic example elimination 
assume proof assume second case proof assume case proof qed furthermore strong assumptions may introduced order repeatedly changing behavior isar proof processing cf 

assume proof assume unused assume unused assume chapter 
advanced natural deduction thesis 
qed note liberal treatment assumptions quite important practice tune proof texts natural flow information interactive development improved readability final text 
particular properly arranged facts avoid explicit facts rules cf 
discussion see 
hand assumptions corresponding goal statements swapped 
subsequent example assume introduced properly related show demanding explicit label 
proof assume show proof show thesis proof qed qed contrast subsequent attempt introducing assumptions dynamically required violates scoping logical context elements abstractions 
proof show proof assume illegal dynamic assumption thesis version spare explicit previous fact unacceptable reasons 
example break modularity isar proof checking particular context introduced body sub proof change meaning main proof 
note correct assume show needs impose resulting hypothesis result independently actual sub proof 
generally speaking isar vm interpreter implements discipline static scoping proof contexts order get subtle details right 
fine points just easily overlooked real world implementations interpreted languages known issue proper programming language semantics decades 
initial error dynamic scoping lisp interpreters late overcome theory mccarthy 

basic techniques context elements presume element provides weak assumptions assume discharged hypotheses solved goal premises 
presumptions left new sub problems solved 
presume essentially defers sub proofs logical cut rule 
just consider simple example involving rule proof rule presume proof show proof qed practice presume turns useful interactive development portions proof may temporarily deferred debug failed applications assume show due faulty assumptions 
situations assume may temporarily replaced presume inspect partially applied results show pending subgoals corresponding previous presumptions 
note exporting results context weak assumptions involve special treatment premises enclosing goal context cf 

effect essentially applications non atomic rule statements 
proof rule show proof show proof qed def element essentially provides abbreviation fix assume discharged generalized equation automatically disposed reflexivity def performs definitional extension proof context cf 
similar principle theory level 
def element best studied raw proof block see 
characterization reducing basic def sophisticated obtain element generalized elimination corresponds general conservative extensions 
interestingly relevant practice 
def logical context element merely extra logical device term abbreviations 
power stems arrangement including conveniences higher order matching hindley milner polymorphism requiring underlying logical framework take care additional concepts 
case element provides generic interface invoke named context segments form fix assume 
cases typically emerge canonical proof chapter 
advanced natural deduction patterns initially applied goal configuration see cases induct methods 
non atomic claims give rise named case rule context referring pending rule context see 
local facts goals principle show goal element isar sufficient support natural deduction proofs particular need version 
speaking terms pure calculus show closely corresponds application local result pending goal 
limiting local results immediately pending goals turns slightly impractical cf 
discussion burstall 
isar element attempt refine goal merely exhibits result proof context 
sense removes tension show fit enclosing proof problem 
behavior resembles expressions calculus binds local fact eventually subsequent body 
note isabelle isar implements known polymorphic version binding hindley milner cf 

effect cascaded contexts observed holds local facts 
proven facts show may re ado 
isar essentially uses general dag shaped organization local results pure tree structure 
recall knaster tarski theorem cf 
somewhat realistic dag shaped proof 
corresponding primitive representation duplicates primitive proof shared fact ge due internal normalization 
show element solves enclosing goal exhibits result locally 
consequently multiple goals may covered sequential manner re previously proven facts illustrated 
proof show proof show proof qed included conjunct proof second analogous rule order sub proofs may changed fixed goal focus isar 
pattern corresponds symmetric rule proof show proof show proof qed 
basic techniques proof steps rule invariably 
see isar infrastructure cascaded local facts enhances plain natural deduction rules casual manner 
mixed forward backward reasoning explored variations forward versus backward reasoning 
isar flexibility respect virtue element turns important ingredient achieve readable proof texts 
general principle observed may illustrated model general situation 
consider natural deduction rule premises divided prefix ai ai appropriately filled existing facts previous assumptions suffix bj better solved separate sub proofs typically involves increasingly complex statements require separate universal parameters assumptions due nested rule 
common natural deduction rules follow basic arrangement consider elimination exactly premise 
rules regularly shaped admit valid divisions prefix suffix parts depending particular situation proof text hand 
split view rule gives rise mixed forward backward proof pattern premises established preceding context ones covered body main claim show 
proof proof proof rule show proof show proof show proof qed chapter 
advanced natural deduction arrangement distributes corresponding sub proofs isar text nicely advance ones body 
recall basic rule method demands chained facts proper order line needs take care 
attempt build ad hoc costly permutations basic steps serious proof search better left explicit automated proof methods blast classical isabelle hol see 
conducting single natural deduction proof steps practice canonical order premises filled coincides natural arrangement corresponding pieces proof text 
standard natural deduction rules tend formulated way 
furthermore normally split parts prefix suffix rule premises respectively 
rare circumstances fact positions may skipped global fact refers illustrated synthetic example 
proof proof rule show proof qed note need specify rule explicitly dummy fact provide structural clue intended proof step 
plenty non sensical eliminations tried 
fact seamless way single step reasoning isar heavily depends proper indication existing facts cf 
related discussion 
verbose method specifications need cluttering proof text unnecessarily 
balance facts versus methods turns key factor achieve readable proof texts 
deeper reason theoretically redundant modifier important isar 
simple example shifting balance indicating facts versus proof methods back forth 
assume ab available context 
rule ab rule methods initial terminal rule ab fact chained method ab facts applied immediately second form frequently encountered practice 
scheme may 
basic techniques generalized number facts arbitrary complex proof tools see 
nicely achieves indication relevance facts text leaving method specifications uncluttered additional arguments see related discussion 
raw proof blocks block structure readily available isar proofs normally explicit text 
sub proofs implicitly live local context requiring separate parentheses user 
command allows jump blocks requiring separate close open specifications 
explicit block structure occasionally quite useful 
isar provides elements delimit proof blocks separately essentially acts sub proof lacking initial claim facts may freely float 
forward composition rules result proof block final fact exported enclosing context 
local assumptions discharged accordingly 
may prove rule statements forward fashion illustrated known propositional rules assume note assume assume assume proof rule show rule show proof rule show rule qed qed note general idea spell final result near block assume 
result needs named local bindings invisible outside block 
variations rearrange course reasoning internally 
note parts contributing chapter 
advanced natural deduction final result assumptions fact may reordered affecting exported rule 
assume assume assume note assume assume note intermediate statements introduced body increasingly difficult determine final result text 
just useful concepts isar taste discernment required writer lest text incomprehensible reader recall general principle liberality 
note rules may established plain backward reasoning see 
blocks logic laboratory virtue raw proof blocks exhibited experimentation teaching natural deduction proof composition 
due absence immediate goal context behavior logical declarations may studied isolation 
technique basically amounts kind formal logic laboratory 
particular characteristics assume presume def may expressed isar quite succinctly follows 
assume proof presume proof def proof 
basic techniques note assume presume really pure forward reasoning differ exporting results goal context cf 

intra logical nature def results new local object treated opaque default fact unfolded explicitly 
amounts ad hoc abstraction concrete expression hand main reason def may get occasionally slightly convenient element term abbreviations 
note turns useful practice merely formal illusion impact logical context 
illustrated needs happen discharge time abbreviations fully expanded passing input logical inference machinery 
thesis proof full power unleashed higher order matching cf 
allows analyze structure statements extra logical fashion 
proof inversion patterns tactical theorem proving strongly biased backwards reasoning initial claim refined consecutively finished state achieved 
mode operation particularly subtle conjunction automated methods simplify goals simp auto isabelle hol see 
isar pose restrictions methods initial proof steps 
come pattern automated backwards reasoning structured isar proofs 
proof auto automated initial step generally bad idea fix assume show proof qed operational viewpoint proof text corresponds tactic script usually considered slightly unstable isabelle folklore 
problem behavior initial auto step sensitive changes collection global rule declarations background theory see 
refined situation needs covered isar proof body explicit parameters propositions text 
automated tools usually stronger library evolves years cause slightly different local problems emerge eventually demanding writer adapt original formulation accordingly 
chapter 
advanced natural deduction proof auto automated initial step generally bad idea fix assume show proof qed bad idea arbitrary automated tools determine decomposition problems structured proof texts 
unstructured scripts sensitive problems explicit statements avoided possible place rendering script unreadable course 
simple technique inverted proofs achieves robust proof texts invariant monotonic changes automated tools 
course inner proof block may emerged previous experimental phase automated backwards refinement seen 
proof fix assume proof thesis auto qed certainly final integration phase may break behavior auto changes manner occasionally happens reality 
hand significantly higher level tolerance built text 
fact pattern may considered simple instance big step reasoning portions text composed loosely exported result included automated step 
see related discussion degenerate calculations isar 
non atomic statements isar proof language exploits full potential higher order nested natural deduction basic logical framework cf 
assumption statements may arbitrary meta level propositions artificial restriction atomic ones object logic 
interestingly traditional isabelle tactic scripts paulson nipkow quite limited respect 
special treatment required goal statement non atomic premises operationally similar technique raw proof blocks covered 
worse basic isabelle tactics unable treat non atomic facts premises expected notably assume tac 
basic techniques paulson 
sense isabelle old style user experience tends emulate original hol tradition tactical proving gordon melham gordon staying faithful roots paulson paulson 
automated tactics isabelle essentially share problem enhanced isabelle isar wenzel providing filter meta level statements object logic separate connectives scenes 
basic technique derive arbitrary rules isar compose local proof context mimics top level structure statement claiming new goal 
reduces rank original problem exhibiting assumptions local facts subsequent proof text 
consider simple example 
proof fix assume proof qed consider address constituents initial rule statement term abbreviations introduced avoiding repeat probably large propositions text 
proof fix assume proof qed alternatively may standard infrastructure goal statements provided isar interpreter includes rule context case representing original context symbolically thesis abbreviation 
note abstracted outer universal parameters 
may achieve fully symbolic proof body follows local parameters need repeated text 
proof case rule context thesis proof qed form minor drawback case rule context introduces full assumption context simultaneously 
may directly refer facts assumptions encountered 
isar chapter 
advanced natural deduction intentionally refrains low level operations lists theorems facts goals generally treated opaque 
common applications previous pattern needs refer assumptions separately covered collectively 
essentially different ways get hold individual assumptions context immediate proof repeat relevant assumptions separate assume elements 
recall isar proof contexts invariant wrt 
duplicated entries cf 

proof case rule context performs fix assume simultaneously extracted result assume repeated assumption show thesis proof qed apart basic form advanced techniques exploiting implicit context information provided case especially conjunction obtain see 
proving non atomic statements initial step need necessarily idle 
apart method encountered far may plain rule steps 
rule application higher order backchaining monotonic wrt 
internal goal context previous techniques fix assume case rule context applicable 
may require different treatment due initial refinement 
synthetic example illustrates typical situation original goal context augmented due initial proof step 
proof fix assume proof qed monotonic rule application desirable applications involving non atomic claims notable exception induction 
isar provides specific support induction rule statements configuration participates recursive reasoning see 
capabilities isabelle tactic scripts fail altogether demanding switch back object level connectives order intended rule appear atomic 
typically demand additional steps strip connectives causing excessive dose formal noise 

generalized elimination generalized elimination consider canonical elimination rule natural deduction model basic idea generalized elimination may described follows 
certain point proof local parameters additional properties may introduced subsequent results mentioning auxiliary parameters exported acquiring additional hypotheses 
words generalized elimination corresponds conservative extension proof context auxiliary parameters assumptions may introduced affecting self contained results cf 
similar concept level theories proofs 
isar supports generalized elimination derived command obtain introduced see 
turns powerful mechanism basic logical point view actual applications 
important virtues obtain able hide inherent complexities elimination rules involve new local parameters 
isar proof texts may kept clean unnecessary formal noise supporting plain linear format close casual style handling existential parameters common mathematical practice 
order illustrate fundamental difference consider versions elimination turned isar text 
assume proof fix assume proof qed assume obtain 
proof version directly mimics primitive elimination rule involves additional level nesting requires explicit goal statement cf 

second version slightly handsome better policy imposed internal reasoning steps shall see 
obtain element supports liberal linear arrangements proof text avoiding separate nesting sub proofs altogether 
number results may established context obtain 
user think point generalized elimination performed 
chapter 
advanced natural deduction need state ultimate result may just explore situation forward manner 
results style structured proof composition liberated explicit goals 
assume obtain 
having sorted logical foundations obtain see proper support realistic soundness proofs existential claim involved see shall discuss useful isar proof patterns generalized elimination see 
obtaining contexts derived command obtain extends basic syntax isar commands cf 
chapter follows 
obtain var 
name atts prop name atts prop basic logical idea obtain expressed subsequent simplified implementation concise manner 
reserve theorem name reduction internal 
furthermore generic assm primitive derived rule scheme eliminate 
obtain 
proof reduction 

proof fix assm eliminate reduction 



proviso free eliminate rule eliminate easily derived basic logical framework 
discharge additional assumptions generalize clearly affect due proviso specialize proposition reduction statement apply modus ponens 
see obtain dual plain local statements established proof means certain holds context obtain proof says may assume number facts involving new local parameters 
observation duality related fundamental hhf format logical statements left hand side admits parameters multiple assumptions righthand side consists single 

generalized elimination insight essence obtain may gained looking closely reduction part 
apparently statement expresses existence elements certain properties 
coincides usual definition higher order framework see 
likewise multiple parameters correspond nested quantifiers multiple assumptions conjunction 
detour explicit connectives may understand reduction statement abstractly conservative extension proof context explicitly states self contained results may get rid temporary assumptions introduced acquiring additional hypotheses 
observation exploited eliminate rule 
remaining issue practical usability obtain perform proof reduction adequately 
due nesting left hand negative side meta level connectives raw statement slightly awkward handle directly basic proof steps 
practical applications really demand refinement proof obligation encountered 
supporting realistic soundness proofs order support realistic proofs reduction statement obtain shall give elaborate definition 
basic idea break raw soundness statement structure directly exposed isar proof text primitive proposition 
technically subtle design resulting proof situation admits number quite natural patterns complete soundness proof single steps automated tools 
additional complexity hidden readers isar proof texts writers may choose ignore superficial details going internally merely get acquainted number common reasoning patterns 
subsequent full definition obtain fact refer previous results indicated forward chaining 
fact obtain 
proof reduction 

proof succeed fix thesis assume intro 
thesis fact show thesis apply insert proof qed fix assm eliminate reduction 
understand definition obtain observe refined proof reduction statement 
explanations simplified version valid due compositionality isar proof checking 
initial proof step really facts indicated immediate absorbed 
subsequent proof body proceeds canonical chapter 
advanced natural deduction fashion establish nested rule statement cf 
fix arbitrary thesis assume premise reduction declared implicit rule claim remaining goal 
proof captures original facts inserts part just entering remaining soundness proof original text 
additional tweak involving apply intended automated proof tools behave gracefully resulting goal 
thesis thesis essentially initial reduction statement relevant information internal proof state 
common automated proof tools expect situation solved single stroke see fails may refer explicitly proof method specifications 
contrast single step proof usually requires individual constituent parts reduction available separate elements 
note due monotonicity basic rule application initial goal modified apply affect single rule steps 
order see soundness proofs obtain action suppose certain standard elimination rules declared current context especially 
ideally expect satisfy obligation posed obtain having performed single elimination step modeled statements 
happens requires additional step inside 
assume obtain proof fix assume thesis rule qed assume obtain proof assume thesis rule qed fortunately assumption steps rule covered isar builtin notion solved goal configurations 
may collapse proofs single rule step achieve succinct presentation 
assume obtain 
assume obtain 

generalized elimination single step proofs just statement provides elimination scheme usual isar special standard logical connectives apart declared standard theory library 
example common schemes involving set theory operators isabelle hol see chapter may look 
assume obtain 
assume domain obtain 
assume range obtain 
note single rule schemes discussed far employ intro declaration definition obtain 
patterns employing feature frequently encountered practice shall discussed see 
common patterns generalized elimination canonical eliminations seen single step eliminations involving standard connectives 
multiple elements encountered better existing proof tools order logic perform routine steps automatically 
assume obtain blast version explicit existential statements preceding obtain quite represent practical pattern 
text basically contains copies constituent propositions may unwieldy expressions reality 
realistic situations existential claim typically emerges different fact trivial fashion mediated standard automated tools see 
assume auto obtain blast furthermore pattern usually better expressed mentioning intermediate existential statement place 
assume obtain auto simplification assumes single automated proof step manages bridge gap directly 
general behavior automated proof chapter 
advanced natural deduction tools may change significantly inserting intermediate claims 
suppressing proposed may big difference complexity new situation 
hand situation special case intermediate existential statement essentially just different expression main obligation hand 
treated typical automated proof tools blast auto due internal skolemization 
interestingly compact form works better expected situations 
existential quantifiers cause additional overhead simple proof tools may sufficient true content soundness proof 
avoiding place highly complex methods auto may replaced plain rewriting simp example see 
assume obtain simp speaking terms proof theory automated reasoning obtain acts pretty cut elimination existential statements existential introductions followed eliminations just proceed directly contributing facts eliminated form obtained results 
reduces complexity primitive proofs directly encountered isar anyway simplifies mechanized proof processing 
enables primary proof text express reasoning succinctly 
encountered rare coincidence substantial simplifications different conceptual levels formal proof time 
commonly issues primitive inferences versus primary proofs need directly related may complementary 
proofs obtain element may really understood generalized form directions 
particular may perform proofs illustrated basic patterns 
obtain proof 
obtain proof 
typical applications schemes obtained parameter stems explicit implicit existential fact established earlier 
accommodate notoriously difficult reasoning kind requiring quantification stated explicitly see application chapter especially main invariance proof 
furthermore conjunctive form achieves effect multiple simultaneous results see related discussion 

generalized elimination apart changing external may reverse internal standard procedure soundness proofs obtain replacing previous scheme elimination elimination 
obtain proof show proof qed obtain proof show proof show proof qed note initial proof steps encountered intro declaration full definition obtain 
backchaining thesis thesis required exhibit explicit existential witness solve conjuncts respectively 
pattern may generalized parameters assumptions requiring advanced proof tools rule ranges simultaneously new context 
obtain proof show proof show proof show proof qed little needs said conjunction case merely results different arrangement reasoning performed 
contrast fundamental difference existential parameters getting involved initial left stronger problem solved context 
particular just produce existential fact eliminate witness show violate scoping rules parameters 
failed attempt documents common error beginners reasoning existential statements 
obtain proof proof order finish proof essentially require choice principle underlying object logic order extract witness existential statement scope say 
version hol isabelle hol application environment see chapter provide chapter 
advanced natural deduction hilbert choice operator see fix mistake 
hand certainly assume strong choice principles arbitrary object logics isabelle isar framework 
way repairing broken elimination proofs choice principles certainly intended primary scheme obtain 
useful application achieve different proof layout particular situations writer wishes hide large proofs existential inside body soundness proof 
main reasoning may proceed existential parameters characteristic assumptions fully manner 
just instance existential observed may directly manipulate generalized existential statements proof text needing explicit quantification 
obtained parameters forward proof obtain command defined derived context element basic isar framework natural deduction cf 

particular obtain directly dependent goal configuration 
number results may exported scope provided local existential parameters exposed outer context 
isabelle isar system implementation wenzel performs explicit check proviso existential parameters cf 
inference rule eliminate 
achieves meaningful error messages incremental proof processing 
user get low level failure underlying inference kernel isabelle pure quite hard trace corresponding obtain language element located farther upwards proof text 
important note high level checking side conditions just matter user convenience 
due manifest soundness isar proof processing may produce wrong theorems place 
export behavior obtain may observed distracted pending goals raw proof blocks logic laboratory cf 

obtain proof proof need export single result statement block ensure fact produced mention obtained parameters 
particular block may closed right obtain illegal attempt export directly 
problem export existential parameter bound 
obtain proof 
generalized elimination 
fundamental inability export obtained facts immediately deeper reason obtain goal isar include solving enclosing goals just show opposed 
variant form obtain goal existential parameters limiting advantage existing show element simultaneous 
feature improvement multiple sequential show statements achieve similar effect 
apart obtain covered simpler derived context elements isar 
raises question related 
assume presume exact effect enclosing goal context introduce immediate premises induces additional hypothesis exported result cf 

assumptions proven typically admissible particular situations effect earlier backward step 
contrast obtain involves explicit proof number facts parameters may assumed just self contained results may get rid pending hypothesis 
def declaration cf 
refers intro logical definitional extensions proof context 
idea may represented general conservative extension mechanism obtain mediated reflexivity implicit substitution 
may relate obtain def follows 
def proof obtain def proof show rule reflexive qed proof unfold def representation proofs representations existing elements terms concepts common theme applications 
typical example representation plain mathematics illustrated examples 
assume range obtain 
chapter 
advanced natural deduction assume surj obtain 
representation patterns just instances general elimination form obtain seen 
may gain understanding common patterns informal reasoning elements form 
mathematical proofs usually refrain stating kind explicit existential statement simply proceed obtained representation casual manner 
obtain turns adequate formal representation 
slightly concrete representations frequently encountered applications typically involving concrete syntactic models see chapter 
basic instance essentially proceeds follows 
fix assume obtain simp fix assume part typically stated explicitly text stems cases induction scheme see 
usually new parameters redundant obvious simplifications 
obtain pattern extracts key representation properties succinctly hiding superfluous parameters atomic proof step simp 
purely syntactic representations occasionally encountered usually related inductive datatypes see 
consider trivial examples 
assume obtain suc proof assume obtain suc suc proof see obtain supports numerous useful proof patterns providing highlevel view general elimination rules single case identical different proof techniques required cases recursive ones get involved 
corresponding concepts case analysis induction shall introduced 
centered specific proof methods cases induct may case 
proof cases induction immediate patterns cases induction isar generic higher order framework principle special proof cases induction 
initial 
proof cases induction problem may split sub problems just appropriate rule standard elimination 
typical case rules main thesis preserved additional local assumptions emerge branch 
assume proof assume thesis proof assume thesis proof qed note special command merely provides succinct form manage separate blocks proof body 
blocks usually required applications case split rules subproblem may assume local context 
basic structure explicit text mimics rule directly 
assume proof assume thesis proof assume thesis proof qed cases need depend major premises eliminated may naturally arise inherent properties underlying structure types boolean case split classical logic illustrated 
proof rule case split assume thesis proof assume thesis proof qed case rules may introduce local existential parameters 
consider pattern involving canonical non recursive representation type natural numbers see 
proof rule nat exhaust assume thesis proof chapter 
advanced natural deduction fix assume suc existential parameter occurs local assumption thesis proof qed induction rules similar ones plain cases encountered far involve issues 
particular universal inductive parameters occurring 
main thesis preserved subject inductive structure logical entities involved 
induction proofs may principle performed basic rule applications generally idea provide explicit instantiation induction parameter predicate order avoid unexpected results higher order unification 
proof rule nat induct show proof fix assume suc proof qed induction natural numbers pattern directly refers inherent property underlying type structure 
inductions elimination form involving explicitly chained facts typically occur inductive sets see 
example consider pattern reasoning set finite sets 
inductive definition main isabelle hol library see 
assume proof rule induct show proof fix set assume insert proof qed form syntactic instantiation induction rule replaced explicit membership assumption chained rule method 
illustrated previous proof patterns see case splits induction schemes may directly expressed existing isar framework 
inherent capabilities isar proof processor cover handling separate sub problems local contexts arising individual cases 
furthermore higher order nature underlying framework 
proof cases induction basic operations higher order back chaining arbitrary rules accommodate general induction schemes nicely 
principle conclude exposition proof cases induction stage 
hand issues prevent techniques scaling larger applications 
includes minor slightly low level method specifications rule nat exhaust rule nat induct 
serious problems large local contexts arising inductive definitions typical computer science applications chapter inadequate treatment non atomic induction predicates experienced naive higher order backchaining involved rule method 
subsequently outline simple additions basic isabelle isar setup considered far order support proof cases induction conveniently 
merely requires additional proof methods attributes 
rules cases basic rule method differentiate particular format meta level theorems performs higher order backchaining uniformly automatic lifting local goal contexts higher order unification 
slightly specific view rules required cases induct methods introduced see 
particular methods produce declarations named cases general version interpretation function 
having invoked method initially users may refer local contexts conveniently case command 
previous cases induction schemes model general rule format considered 

marks certain prefix major premises length specified consumes attribute 
practice merely encounter consumes rules associated types consumes sets 
remainder consists sections cases case associated name provided case names attribute 
practice name coincides datatype constructors introductions inductive sets respectively see 
particular terminology case parameters may exploited situations notably open induction patterns params attribute attaches specific names corresponding primrec definition see 
main local ones treated specifically far relevant actual proof methods applied 
recall rules non recursive cases just 
induction patterns individual typically consist particular constructor schemes underlying structure universal inductive parameters occurring apart existential ones covered assumptions 
chapter 
advanced natural deduction rules decorated additional structural information may declared automatic corresponding methods 
isabelle isar provides separate cases induct attributes supports type set rules cases type cases set induct type induct set 
see wenzel details attributes 
users rarely need declare rules may rely existing isabelle hol environment take care standard definitional concepts inductive datatype see typedef see 
rules need occasionally see modified representations involved quotient types rational numbers chapter 
proof methods cases induct methods provide uniform interface case analysis induction types sets appropriate rule declarations current context 
specific support provided implicit selection rules separate instantiations symbolic case names case command 
declarations accommodate succinct specification standard proof patterns covered see 
refrain detailed definitions cases induct methods 
essentially provide heavily sugared view basic rule method 
merely outline basic format method specifications see wenzel details 
syntax methods includes arguments terms providing explicit instantiation rules involved guiding rule selection types 
rules may explicitly user 
full method expression cases rule refers case analysis objects rule partial specifications exact reasoning pattern determined follows depending type arguments chained facts 
facts arguments selected rule cases classical case split cases standard cases type cases 
standard cases set 
cases 
rule cases rule previously declared rules may referred type set 
method expression induct rule analogous cases refers induction elements optional predicate special provisions included induction non atomic statements see 
partial method specifications induction rule determined follows 
facts arguments selected rule induct standard induction type induct 
standard induction set 
induct 
rule induction rule 
proof cases induction having selected instantiated appropriate rule indicated proof methods extract collection named local contexts cases cf 
emitted enclosing proof context 
order usable case cases need fully instantiated means original goal method specification 
unbound schematic variables stemming original rule may render individual cases invalid due specification induct lacks predicate instantiation 
local parameters cases marked hidden default inhibiting case new parameters appear text 
pure behavior cases induct method may disabled including open option 
practical impact details covered see 
facts method consumed number major premises rule cf 
usually types sets 
additional fact inserted goal verbatim applying rule 
allows facts split cases induct suitable followup method common idiom cases auto see chapter applications 
common patterns cases induction reconsider basic patterns proof cases induction cf 
time general infrastructure provided specific proof methods introduced 
see chapter concrete schemes emerging particular environment isabelle hol 
plenty examples provided existing isabelle isar applications see chapter chapter 
classical case distinction proof pattern perform classical case distinction succinctly naming case split rule explicitly 
proof cases assume thesis proof assume thesis proof qed apart stating local assumptions text may infrastructure symbolic cases provided specific proof method setup cf 

requires proposition specified 
facts emerging cases true false included text 
recall facts emerging case happen named cf 

chapter 
advanced natural deduction proof cases case true true thesis proof case false false thesis proof qed version appears slightly economic large propositions requires single occurrence text 
hand symbolic form turns comfortable common situations quite simple anyway equation lucid spell individual cases explicitly 
proof cases assume thesis proof assume thesis proof qed case distinctions require name suitable rule linear orders proof cases rule cases assume thesis proof assume thesis proof assume thesis proof qed may rephrase proof symbolic case names stemming cases rule full instantiation 
proof cases rule cases case thesis proof case equal equal thesis proof 
proof cases induction case greater greater thesis proof qed structural cases structural case analysis typically involves canonical discrimination elements inductive sets types schemes constructors original definition see isabelle hol specifics 
subsequent patterns discriminate cases natural numbers inductive structure suc 
version merely uses cases succinct specification mode reasoning slightly rule nat exhaust encountered 
proof cases assume thesis proof fix assume suc thesis proof qed alternatively may invoke symbolic case names associated rule 
names happen datatype constructors 
proof cases case thesis proof case suc thesis proof qed recall standard policy cases hide local parameters emerging individual cases 
assumption introduced suc suc hidden parameter name syntactic reasons way refer term directly corresponding fact suc suc readily available may contribute existential follows 
case suc suc 
including open option cases local parameters original rule available text 
form assumes terminology parameters declared sensible manner params attribute cf 

type natural numbers parameters cases chapter 
advanced natural deduction derived type names constructor arguments due datatype package isabelle hol see 
proof cases open case suc suc nat thesis proof qed parameter nat appear slightly unpleasant actual name way emerges implicitly case suc command 
essentially problem open modules ml paulson previous definitions may intrude current context unexpectedly 
hand implicit contexts stemming individual rules isar usually smaller ml library structures 
furthermore situation generally better inductive set definitions parameter names derived original definition user see primrec works similar fashion see rule needs referenced explicitly method specification 
open option considered harmful applications cases 
interestingly may avoided altogether elegant fashion case obtain see 
situation subtle induction universal parameters occurring 
cases generalized elimination case analysis rules consist clauses form local parameters occur local happens ultimate result cf 

particular scoping parameters amounts eliminated existential statement similar ones encountered generalized elimination obtain cf 

fact obtain may get instances case emerging plain case analysis advantage 
illustrate version structural case analysis natural numbers 
proof cases case suc obtain suc 
thesis proof qed 
proof cases induction case suc produces suc hidden existential parameter 
result subsequent soundness proof obtain standard existential pattern cf 

consequence gain control terminology parameters static proof text implicitly case cases open 
sight achieved little compared direct pattern fix assume suc seen 
technique case obtain really pays applications involving large case analysis rules typically stemming inductive sets side conditions considerable structural overhead elements involved tuples 
situations original formulation local context marginal interest 
better avoided proof text altogether order avoid excessive details distracting reader 
interesting properties emerging particular case typically immediate consequences suitable simplification superficial structure 
typically eliminates parameters assumptions place achieving important gain readability 
see chapter realistic applications technique merely hint patterns manner essentially generalized elimination scheme seen 
case fix assume obtain simp soundness proof obtain form proof method simp care obvious syntactic simplifications tuple structures 
pointed earlier instance eliminated notion existential statements obtain considerably reduces need powerful reasoning tools 
explicit quantifiers statement usually demand sophisticated proof tools order logic isabelle blast auto plain simp see 
note case obtain pattern may serve viable replacement incidents isabelle tactic scripts involving mk cases feature nipkow available tactic emulation isabelle isar inductive cases command ind cases method wenzel 
isar pattern able supplant special ml tools merely existing proof elements case obtain simp 
structural induction common structural induction datatypes pattern induct method merely requiring syntactic instantiation 
particular datatype natural numbers coincides common forms mathematical induction 
chapter 
advanced natural deduction proof induct show proof fix assume suc proof qed alternatively may refer symbolic cases giving full instantiation open option 
note isabelle hol standard terminology parameter mathematical induction default nat imposed datatype package see 
lemma nat proof induct open case proof case suc suc proof qed informal mathematics encounters different styles introducing local assumption induction step 
active style goes assume holds arbitrary fixed closely corresponds previous formulation fix assume 
contrast passive style due induction hypothesis 
may expressed nicely case version induction follows 
case suc assumption passive assumption suc proof recall proper assumptions introduced corresponding show 
restriction appear hold passive ones context augmented earlier previous case element 
case suc show suc proof assumption late passive assumption thesis proof qed assumption clarity plain works methods assumption coincide pure usage 
rule induction rule induction refer canonical induction schemes emerging inductive sets see 
rules act 
proof cases induction constructors inductive type additional conditions may included set constructions 
furthermore explicit membership judgments involved separate facts induction appears elimination pattern 
subsequently recast immediate pattern rule induction involving set finite sets generic induct method 
assume proof induct show proof fix set assume insert proof qed merely replaced original rule induct method plain induct 
version symbolic cases provided method 
give full instantiation cf 
declare local parameters open 
assume proof induct open case empty proof case insert insert proof qed avoiding unexpected parameters open form induction patterns involving symbolic cases inappropriate local parameters need specified explicitly text prevent confusion readers 
principle achieved elaborate versions initial method invocation params attribute induct open 
rule params 
turns slightly impractical direct primrec package isabelle hol provides renamed rules immediate see 
recall situation simpler non recursive cases parameters may occur existentially 
case obtain demonstrated hidden existential parameters may easily extracted text 
subsequently show different approach explicit parameter specification appears better suitable inductive situations 
concerning induct method parameters hidden may named invocation slightly enhanced version case 
pattern illustrates chapter 
advanced natural deduction idea 
proof induct case proof case suc parameters included case specification suc proof qed extended case specification form shall refer particular terminology instance case text 
pattern appears quite promising needs evaluated concrete examples including large inductive definitions see 
induction non atomic statements issue induction non atomic rule statements important non trivial applications due additional conditions variable parameters typically required strengthened inductive statements see exposition nipkow 
consider standard mathematical induction rule suc gives rise proof pattern 
proof induct show proof fix assume show suc proof qed hand non atomic rule statements may established isar follows essentially just replacing proposition fix assume show proof text cf 

proof fix assume show proof qed techniques may combined follows order establish non atomic statement induction 

proof cases induction proof induct fix assume show proof fix assume induction hypothesis rule assume suc assumption concluded rule show suc proof concluded rule qed seemingly orthogonal concepts induction non atomic propositions appear fully compositional 
retrospect special happening isar proof just turns expected place 
hand painless approach induction non atomic statements result careful treatment issues environment structured proof texts 
existing tactical provers notably isabelle paulson nipkow traditional hol systems gordon melham need impose quite technical details users illustrated 
isabelle hol tutorial nipkow includes lengthy instructions prospective users get strengthened induction statements accepted system 
practice superficial formal overhead causes considerable distractions main problem figuring suitable generalizations inductive arguments 
subsequently illustrate problems encountered tactical induction proofs means isar proof texts 
observe induction scheme may just applied naively original rule statement higher order backchaining involved monotonic wrt 
goal context 
proof rule nat induct monotonic rule application fix assume unchanged rule context show proof fix assume limited induction hypothesis show suc proof qed normal behavior rule application got way intended get access original context 
induction static assumptions outside different parameters 
established technique fix misconception unstructured tactic scripts rephrase original rule atomic proposition chapter 
advanced natural deduction object level connectives 
proof rule nat induct show proof fix assume show suc suc proof qed looks fine theory usually causes considerable amount additional formal noise practice reasons 

connectives need stripped explicit introductions entering actual proof inductive 

connectives need eliminated induction hypothesis usable common situations 

final result needs modified recover originally intended rule statement 
fourth extra logical problem writer development 
typically particular context passed induction subject experimentation properly strengthened statement figured 
switching back forth happens quite cumbersome isabelle due different syntactic precedences proper placement parentheses imposed writer 
illustrate formal issues proof pattern 
recall structural decomposition shown statically isar text hidden extraneous tactic invocations unstructured proof script 
proof rule nat induct show proof fix show proof assume show proof qed qed fix assume 
proof cases induction 

show suc suc proof fix show suc suc proof assume suc show suc proof qed qed qed note mp spec special attribute rule format isabelle isar tactic emulation wenzel simplifies phase 
concerning introductions eliminations unstructured tactic scripts blown excessively text inherent complexity 
users tactical proving suffered additional overhead simulating induction rule statements years certainly way persist proper isar 
illustrated superficial formal noise immediately affects isar proof texts unacceptable manner 
fortunately affair quite easy accommodate proper isar compositional version induction non atomic statements demonstrated initially recognized right way 
key observation induct merely needs provide filter plain rule order internalize rule statement temporarily 
induct works isar ignoring separate issues rule selection instantiation providing named cases covered 
induct unfold rule fold contains transforming meta level connectives hidden reflections object logic private copies 
consequence actual application induction rule appears operate atomic proposition 
connectives expanded order recover presentation rule 
technique assumes occurrences induction predicate proper rule positions merely surrounded 
rules existing isabelle hol packages notably datatype inductive see follow form 
individual rules isabelle hol library see need adapted usable rule statements 
rephrased 
chapter 
advanced natural deduction definition induct method appears obvious solution long standing inconvenience classic isabelle 
key observations scheme practically useful isar proof texts opposed unstructured tactic scripts 
firstly isar able treat non atomic assumptions goals uniform manner isabelle tactics strong bias flattened proof problems 
secondly rule statements may easily formulated separate local facts isar tactic scripts operate single large rule encodes full proof problem assumptions intermediate facts range actual inductive statement delimited clearly 
see additional effort structured proof composition eventually pays significant simplification typically subtle inductions generalized statements conceptual technical point view 
particular common way represent natural deduction proof schemes meta level carries advanced inductive problems 
attempt encode rules temporarily object logic essentially gives fundamental conveniences generic isabelle framework higher order backchaining meta level expressions 
slightly strange exceptional case falling back object logic induction apt diminish elegance original isabelle framework paulson paulson unnecessarily 
discussion context manipulations mizar mizar rudnicki trybulec muzalewski wiedijk provides number proof outline commands procedural transformations contexts goals 
covered propositional case issue adequate treatment quantifiers important 
consider generally critical scheme exploring particular instance isar proof documents formulation basic natural deduction cf 
chapter advanced techniques considered previously 
lemma proof fix assume proof fix assume 
thesis 
qed qed 
discussion isar structure basic natural deduction proofs directly corresponds logical statements involved 
results typical nesting sub proofs encountered 
mizar provides separate commands dig complex statements sequential manner notably take consider elimination intermediate result elimination existential premise 
propositional case cf 
follow simplified view mizar operations wiedijk 
authentic mizar treats quantifiers hardwired classical proof principles 
official documentation available works exactly 
critical users find sources mizar unavailable 
example stripped version mse hoover rudnicki rudnicki mizar mse 
full mizar mse version supports notation order logic simplifies presentation 
hand lacks variant elimination need plain consider 
environ reserve ex st holds implies holds ex st proof assume ex st holds consider holds ex st assumption gets obtain local parameter elimination consider 
mizar needs keep fixed order transformations digging nested statement 
consequently intermediate element may moved way order link assume consider lines directly 
fact needs named explicitly mizar treats result consider special case disallowing immediate linking example 
fact mizar mse version support mizar linked elements 
reason require label mizar mse full mizar employed previous fact directly 
observe mizar tends introduce amount formal noise due slightly inflexible arrangement basic proof outline elements 
contrast isar proof contexts invariant wrt 
number canonical algebraic laws permuted assumptions parameters assumptions hhf normal forms cf 

hand isar non procedural approach proof contexts may require excessive nesting sub proofs situations 
practice additional nesting chapter 
advanced natural deduction due generalized elimination patterns may accommodated adequately derived obtain element 
may rephrase example isar nesting able exploit flexible treatment context elements arrange flow facts naturally 
happens keep text free explicit facts rules 
lemma proof fix assume obtain 


qed isar quite far removed direct manipulations proof contexts goals particular technique calculational reasoning provides slightly different paradigm implicit transformations results albeit disciplined manner see chapter 
second order schemes mizar declare mizar rudnicki trybulec muzalewski wiedijk declare syme syme syme treat second order proof schemes induction special case different reasons 
mizar classical order logic hardwired axiomatization typed set theory 
special sub language handle secondorder rules including top level goal statement scheme element application rule schemes proofs 
example principle mathematical induction stated article nat mizar library follows 
scheme ind nat holds provided st holds proof having decomposed main statement indicated proof proceeds standard proof elements mizar 
body refer plain firstorder statements rule schemes may nested deeper 
subsequently give example scheme application mizar taken article mizar library 
language element rule ind mathematical induction 

discussion theorem fin holds finite proof finite st finite holds finite proof assume finite finite finset thesis thesis ind example represents common idiom induction mizar 
scheme application works existing facts provided named arguments encountered ind 
induction restricted forward reasoning explicit previous facts 
extreme style forward induction preferred informal discipline writing long detailed proof outlines proposed lamport 
isar flexible respects 
underlying framework supports complex rules directly artificial restriction firstorder logic 
isar proof language accommodates adequately treating non atomic statements uniformly text 
furthermore freedom choose direction reasoning freely may principle applied second order patterns preferred style induction backwards manner 
isar admits variations mathematical induction ranging emulation mizar slightly odd mixed form standard backward reasoning cf 

proof suc suc proof fix assume suc proof qed suc rule nat induct proof proof rule nat induct fix assume suc proof qed chapter 
advanced natural deduction proof induct show proof fix assume suc proof qed backward version appears conforming main stream style induction mathematical proofs cf 

analytical presentation top fashion especially suited large scale applications demand additional infrastructure symbolic cases proper treatment non atomic inductive predicates 
specific isar infrastructure requires induction pattern specified advance order enable succinct presentation corresponding sub proofs 
declare syme syme syme follows similar idea top induction 
system provides separate sub language rule specifications builtin proceed element second order schema application inductive arguments 
example case study performed declare syme part ii 
thm array alloc conforms lemma te wf te wf te vt st ext wf st wf val heap val alloc heap st dims ext alloc te heap heap conforms heap conforms heap heap te heap heap conforms te heap val vt st len dims ext goal proceed structural induction dims dims heap heap val variable case nil dims qed case cons dims dim dims dims 
rule specified structural induction lists type dims annotation 
variable refers selection universal parameters induction 
declare performs implicit quantification inductive statement specified 
scope resulting induction predicate determined automatically covering exactly parts current proof context mention parameters 
discipline enables declare reason top level sequents inductively 
declare implements specific support common induction patterns part 
discussion primary language 
conforms approach specialized system reasoning operational semantics syme 
isar aims general philosophy quite different 
great care taken order provide generic framework high level natural deduction proofs minimal instantiations required support different kinds applications 
advanced concepts kept close pure logical concepts sensible 
concerning particular case induction proofs means isar local parameters assumptions just meta level connectives original claim separate language elements declare 
induct method isar passes exactly rule statement induction implicit operations involved 
generalized case splitting recurrent patterns advanced natural deduction treated specifically far generalized elimination obtain infrastructure rules involving case splitting 
furthermore pointed common obtain case 
question remains case splitting may incorporated obtain directly 
speaking terms underlying framework minimal higher order logic obtain corresponds singleton case analysis optional existential parameters expressed reduction statement 

cf 

meta logical perspective idea underlying obtain easily generalized number branches 
essentially result generalized case splitting shall associate hypothetical obtain cases element follows 
obtain cases 

proof case proof case proof initial soundness proof establish multi branch reduction statement particular case split separate existential parameters 
subsequent portions text may invoke individual alternatives case need establish common result eventually 
unfortunately existing isar proof text processing scheme chapter 
advanced natural deduction support kind reasoning pattern context element obtain 
isar vm interpreter essentially bound linear operation working incrementally left right 
obtain cases discharge operation underlying assm primitive need collect results independent pieces text able apply covering statement proven 
mizar rudnicki trybulec muzalewski wiedijk provides language element cases kind isolated multi branch reasoning lacks local existential parameters 
fact way case splitting may performed mizar place 
logical manipulations covered far operate strictly linear fashion 
recall mizar may just apply arbitrary natural deduction rules isar basic proof rule form 
example case splitting mizar taken article mizar library 
fragment uses purely forward reasoning outer level 

ultimate result contradiction need stated goal 
cases case contradiction case seg seg seg tarski def contradiction contradiction soundness proof required cases merely needs establish disjunctive statement due lack existential parameters mizar primitive 
empty soundness proof cf 
semicolon cases involves classical principle non treated obvious mizar builtin verifier 
concerning isar observed forward style case analysis directly supported existing language framework 
may just basic instance cases method applied initial claim achieving reasonable presentation cf 

mizar text may rephrased isar follows 
false proof cases assume false proof 
discussion assume false proof qed interestingly practical applications logical case analysis mizar isar simple non form 
isar portion structural case analysis inductive sets types see typically emerge computer science applications chapter 
mizar offer specific support respect 
fact examples mizar library turn slightly low level users simulate underlying inductive structures raw elements order logic set theory 
declare syme syme syme provides general cases element refers decomposition enrichment primitive system 
mechanism quite powerful admitting split proof context disjunctive parts introducing number local assumptions optional existential parameters 
complex statements form 


may directly accommodated declare proofs 
system collects covering statements individual portions text user consider elements separated case keywords 
contrast isar declare may achieve relatively easily due non interactive processing proof texts 
context elements declare derived cases primitive including local facts single ended elimination consider surrounding cases case local definitions optional pattern matching performed logic 
example local definitions analogously isar pattern def obtain cf 

issue generalized case analysis marks key philosophical difference declare compared isar 
declare essentially takes inclusive primitives starting point defining simpler concepts particular instances 
isar started generic model pure natural deduction proofs built hierarchy derived elements bottom logical foundations 
moving upwards hierarchy concepts able preserve logical foundations operational model incremental proof processing full compositionality previous collection language elements 
fact deeper reason isar turns versatile formal reasoning environment 
achieve limited set goals grown sound basis cover large field applications 
propose slightly different pattern case splitting isar chapter 
advanced natural deduction quite primitive means forward reasoning proof blocks 
idea collect number individual results integrated means magical proof method needs take care eliminating ultimate covering statement 
class context element obtain cases considered 
fix assume proof note fix assume proof note blast magical integration performed fact happens instance big step reasoning paradigm performed automated reasoning tools see slightly convenient expressions degenerate calculations isar avoiding explicitly named facts 
patterns degenerate calculations turn fair replacement relatively infrequent situations fully general logical case splitting encountered practice 
lack real obtain cases isar small price flexible linear interpretation model generic natural deduction proof texts 
chapter calculational reasoning consider general notion calculational reasoning sense iterated equalities similar relations proof text 
despite centered natural deduction isar turns support multitude calculational patterns 
require changes core concepts isar proof processing derived elements added top existing framework 
flexible non intrusive manner calculational reasoning incorporated isar allows free combination existing natural deduction techniques 
demonstrates proof styles need conflict may benefit 
calculational reasoning essentially proceeds forming chain intermediate results meant composed basic principles transitivity similar relations 
advanced calculations may involve substitution case inequalities usually includes monotonicity constraints 
informal mathematics kind proof technique routinely casual manner 
mathematicians write sequences mixed equalities inequalities underline subexpressions replaced doing calculational reasoning 
fact calculational reasoning occasionally proposed simple means rephrase mathematical proof slightly formal setting back von wright back necessarily include machine checking proofs 
observing logical equivalence implication may just calculations set away traditional natural deduction reasoning altogether dijkstra chapter 
calculational reasoning scholten 
resulting discipline writing mathematical proofs slightly manner quite appealing certain groups people albeit 
calculational reasoning offers relatively simple conceptual basis build tools logical manipulations 
example popular math pad tool supports transformations algebraic expressions systematic way 
math pad acquired means formal proof checking backhouse pvs owre backend 
presently cover quite general concepts calculational reasoning isar framework 
shall see calculational reasoning may expressed top existing isar concepts natural manner may common proof patterns 
basic form calculation isar transitive chain equalities laid follows 
proof 
proof 
proof general philosophy isar fixed scheme calculations implemented ad hoc fashion 
merely introduce derived proof commands abbreviations notably 
order arrive general calculational concepts may freely combined existing natural deduction proof language 
previous example merely turns idiomatic expression larger space possible expressions 
particular isar calculations may easily combined real natural deduction elements having subscribe fully calculational view logic general proposed dijkstra scholten 
shall point detail need see calculational reasoning conflict traditional natural deduction 
proof styles readily available isar leaving user free choice appropriate technique particular situation hand 
speaking terms calculus canonical model natural deduction proofs isar calculations correspond binary composition primary secondary facts implicitly determined rules transitivity 
exhibit just concept formal reasoning principle completely redundant turns indispensable realistic applications holds advanced natural deduction elements covered chapter 
interestingly existing tactic interactive proof systems isabelle paulson nipkow hol gordon melham coq barras pvs owre lack immediate support calculational reasoning altogether 
basic form transitive chain cumbersome achieve tactical reasoning 

foundations calculational reasoning omission addressed times past 
simons simons covers specific proof tools support calculational reasoning isabelle tactic scripts 
grundy provides general transformational infrastructure window inference 
harrison mizar mode hol simulates number concepts declarative theorem proving top tactic hol light system harrison including calculational reasoning mixed transitivity rules 
formalized mathematical proof calculations recognized important concept long ago mizar rudnicki trybulec muzalewski wiedijk supports fixed format iterated equations implicit application transitivity general substitution rules 
outlines slightly flexible version mizar calculations spl language 
foundations calculational reasoning calculational sequences syntactical point view essence calculational proof isar calculational sequence set calculation freely generated constructors start fact calculation continue calculation fact calculation 
apparently calculation represents non empty list facts 
fine tune notation write canonical calculational sequences continue 
continue start 
concisely suppressing start left associative infix notation continue 
interpreted calculational sequence shall result achieved mapping start continue constructors primitive recursive fashion 
consider interpretations calculation back fact result calculation fact fix result start degree freedom left specify general case result 
kinds calculational steps considered isar framework rule step specify result result suitable rule taken context transitivity rules 
produce singleton fact applying rule current calculational result taken new facts 
accumulation step specify result result collect facts applying rule 
basic example interpreted calculation sequences fix singleton set perform rule steps get result 
chapter 
calculational reasoning may represent canonical chains equations composed plain transitivity 
alternatively perform accumulation steps achieve result get number facts collected separate list 
shall see case seemingly degenerate calculational sequences turns quite useful practice 
calculational elements proof language stage investigate provide proof language interface user compose calculational sequences 
sight way taken mizar rudnicki trybulec muzalewski wiedijk obvious simply invent concrete syntax primitive operations composing calculational sequences implementation support directly probably link basic mechanisms stating proving facts 
hand way making system particular inherent limitations 
typically yield certain amount implementation effort just kind specific feature mind 
isabelle isar follow different path 
hardwiring calculational reasoning basic language step back immediate implementation problem process composing calculational sequences may mapped natural flow reasoning non intrusive fashion 
adding abbreviations conventions shall achieve general framework calculational reasoning isar requiring minimal effort 
extension happily remaining isar proof language resulting space combined proof patterns contains large number practically useful idioms shall explored 
map calculational sequences isar language 
fix special facts register called calculation hold current state partially interpreted sequence user currently working 
start calculation shall determined implicitly indicated calculation empty 
calculation finished calculation reset await sequence start 
result finished sequence exhibited subsequent goal statement chained fact pending proof longer controlled calculational process 
furthermore wish exploit isar inherent block structure support nested calculations 
update operation calculation shall track current nesting level order commence new sequence new block entered 
number calculational sequences may coexist different levels block structure 
define derived isar proof commands ultimately maintain calculation register outlined 
treatment block structure left implicit 

foundations calculational reasoning note calculation initial note calculation calculation calculation note calculation calculation ultimately calculation main elements corresponding accumulate steps introduced 
accompanied variants ultimately finish current sequence performing final step exhibit result 
due forward chaining involved operation command goal statement show cf 
isar language semantics 
slightly peculiar definition derived isar proof commands essentially sufficient support calculational reasoning 
additional tweak required practice special term binding 
refers argument term explicit fact statement argument curried infix expression op refers right hand side 
enables user refer relevant bits previous calculational statement succinctly 
note similar element harrison mizar mode hol harrison actual mizar rudnicki trybulec muzalewski wiedijk uses special notational device 
may rephrase basic examples calculational sequences isar language 
proof 
proof 
proof proof proof proof ultimately rule primitive notion calculational sequences include particular manner actual results get eventually 
calculation employs basic pattern immediate proof single dot final result applied directly claim 
second form happens ultimate list facts prove different result rule 
expanding definitions derived calculational commands introduced may achieve raw isar proofs refer concrete attribute syntax composition facts cf 

proof note calculation rule step init calculation register chapter 
calculational reasoning 
proof note calculation trans calculation general rule step compose transitivity rule 
proof note calculation trans calculation final rule step compose transitivity rule 
calculation 
pick result note calculation purge calculation register commencing sequence proof note calculation calculation general accumulation step collect fact proof note calculation calculation general accumulation step collect fact proof note calculation calculation ultimate accumulation step collect fact 
calculation 
pick result rule certainly composition underlying primitive sequences facts may simulated pure natural deduction techniques involving backwards reasoning 
get versions 
proof rule trans show proof rule trans show proof show proof qed show proof qed proof rule show proof show proof show proof qed 
foundations calculational reasoning proof exhibits cumbersome formal detail required compose chains basic facts naively 
involves explicit rule applications trans nested sub proofs repeated intermediate statements 
traditional tactic scripts usually proceed line slightly awkward procedure typically visible code 
second backwards proof looks quite handsome sight apart separately nested sub proof may occasionally slightly cumbersome 
plain back chaining rule perfectly adequate situations 
hand useful patterns original calculational version particularly conjunction automated proof tools process accumulated result see 
rules proof search important design philosophy isar keep automated proof tools separate key mechanisms interpreting high level proof texts 
linear search limited number possibilities plus higher order unification accepted 
place complex automated proof methods usually terminal positions justify local claims context certain facts isolation see 
reconsidering commands outlining calculational sequences see single non deterministic parameter rule selected general element 
isar proof texts interpreted strictly left right subsequent result calculation calculation achieved facts rule instance determined system appropriately 
long holds canonical result uniquely determined providing facts invariably yields isar uses refined strategy support general rule selections 
assume canonical order rule context calculation input calculational step 
enumerate members priority enumerate canonical sequences results obtained parallel higher order unification back chaining cf 

filter raw result sequence disallow mere projections words remove results progress sense members list strategy subsumes simple case unique results considered job substitution declare tried plain considered far 
expression requires plain order unification unique general result 
critical part solve expression provided calculation genuine higher order problem 
chapter 
calculational reasoning resulting unifiers assign certain term abstracts possible occurrences sub expression standard strategy paulson start solution occurrences followed possible partial occurrences fixed order finish occurrences 
note case possible solution occur pathological case purpose collapses substitution rules respectively 
filtering mere projections basic calculational rule step able produce sensible result occurrences certain subexpression may replaced equal 
replacing occurrences way isar specify intended result calculational step directly 
practice ill behaved substitutions usually better replaced plain transitivity mentioning full term context explicitly text making justification step take care normalizing claim appropriately isabelle simplifier nipkow see 
substitution greater equal sub expressions additional monotonicity constraints works see 
caveat notion progress filtering strategy really ignore local assumptions higher order resolution insert additional premises degenerate cases higher order unification 
common patterns calculational reasoning space possible calculational expressions isar somewhat due nature calculational primitives incorporated basic proof language 
certainly creative users isabelle isar may invent ways calculational reasoning time 
point possible dimensions variety outline practically useful idiomatic patterns 
subsequent categories guided way primitive calculational sequences may mapped isar proof language interacting different categories existing language elements 
variation rules mixed transitivity basic form calculation plain transitive chain equations encountered 
mixed may follows observe canonical single dot proof forces final goal statement exhibit result explicitly text 
proof 
proof 
proof 
common patterns calculational reasoning 
proof 
proof likewise may combinations relations antisymmetry long clear functional mapping facts result conflict rules 
proof proof substitution technical caveats calculating substitution rules covered 
fine tuned filtering rule selections discussed admits consistent replacement equals equals ado illustrated 
proof proof 

proof practice calculations consist plain transitive steps substitutions interspersed 
may easily spotted text discipline replacement statement mentions proper sub terms previous stage referencing 
consecutive stage right hand side replacement documented appropriate occurrences 
result reconsider versus 


substitution inequalities essentially works similar fashion rules need formulated slightly specifically include separate monotonicity condition 
consider example 
proof proof 
proof proof fix assume simp qed rule premises filled facts calculation remaining monotonicity constraint left additional hypothesis result eventually solved hand proof annex 
chapter 
calculational reasoning monotonicity constraint gets fully instantiated giving facts remainder usually easily proven common automated tools 
reality usually collapse final sub proof simp just simp 
see high level calculational proof outlining nicely works hand hand dumb automation 
proof proof 
proof simp cases may want provide premises directly 
easily achieved combination accumulating additional facts calculational rule fired 
example cf 
knaster tarski proof characteristic phrase note mono 
slightly realistic applications calculations monotonicity constraints bauer wenzel bauer covering set theoretic model computational tree logic ctl 
modus ponens may calculate directly logical propositions getting somewhat closer proof style dijkstra scholten 
pattern essentially achieves light weight natural deduction implicit modus ponens rule 
proof proof proof principle transitivity may calculational rule chaining implications conveniently expressed directly isar primitive circumventing overhead explicit logical connectives altogether 
see issues calculating propositions 
rules isabelle hol collection standard calculational rules included main isabelle hol library see chapter 

common patterns calculational reasoning note meaningful calculations may performed basic transitivity 
users start new object logics may content significantly fewer rules see primitive formulation basic higher order logic chapter 
degenerate version rules distinctive applications see 
case users may easily declare transitivity rules specific relations occurring particular applications hand 
concrete syntax manipulate implicit rule context provided trans attribute see wenzel 
variation recall business managing calculational process finishes concluding ultimately command exhibits result forward chaining indicated cf 

command needs plain goal isar language show cf 

basic proof claim just meaning goal statement chapter 
calculational reasoning reiterates calculational result directly substitution instance 
occasionally wish modify final result single canonical rule easy oversee symmetry illustrated 
proof 
proof 
proof 
useful idiom feed result may just number accumulated facts single rule premises 
technique illustrated forward proof lemma proof assume ab 
ab 
ultimately show 
qed result emerges ultimate proof 
pattern may easily generalized number premises arbitrary proof methods eventually achieving version big step inferences see 
certainly obtain element may concluding goal statement plain internally 
subsequently give slightly unusual calculation consisting mere accumulation steps ultimate result obtain facts simultaneously 
proof proof proof ultimately obtain 
note ultimate proof needs perform single step due standard pattern obtain cf 

variation facts calculational schemes encountered far facts placed chain produced intermediate statements proof 
happens common pattern practice constitute inherent restriction 
isar language element yields result may calculations 
includes note recall existing 
common patterns calculational reasoning theorems goal elements show context commands assume obtain 
example knaster tarski proof illustrates basic note include auxiliary fact calculational sequence note frequently occurs applications 
combinations obtain useful typical computer science applications involving syntactic models see chapter classical mathematics involving representation proofs chapter 
assume calculation represents basic case combining calculational reasoning pure natural deduction 
consider induction proof summation formula odd numbers 
version tight integration styles reasoning 
naive backwards reasoning outer level separate local calculation establish induction step 
lemma proof induct show simp fix assume hyp show suc suc proof suc simp note hyp suc simp add power show thesis qed qed slightly proof may achieved number straight forward rearrangements defer main inductive goal casual forward reasoning strictly hierarchical organization introduce induction hypothesis place possible due flat structure eliminate superfluous naming assumption due natural flow facts suc local statements due simp final step 
lemma proof induct show simp fix simp assume 
simp add power show suc suc simp qed deeper reason natural deduction elements assumptions may chapter 
calculational reasoning get introduced middle calculational sequences way isar proof contexts managed completely independently goal statements cf 

particular proof context inherently cascaded sense scope conceptual abstractions introduced assm primitive derived forms assume cf 
spans remaining proof body closing block cf 

variation general structure calculational sequences basically linear intermediate steps may taken fact produced 
may include nested calculations long arranged separate levels block structure 
nested calculations routinely emerge virtue implicit block structure sub proofs 
raw proof blocks may cf 
occurs frequently practice 
subsequent pattern illustrates instances 
proof 
proof 
proof 
proof 
proof show thesis qed 
proof 
proof 
proof appropriate nested calculations left discernment user cf 
general liberality principle isar discussion iterated equalities mizar mizar rudnicki trybulec muzalewski wiedijk focused formal proof common mathematics style beginnings 
consequently offers mechanism iterated equality reasoning basic calculations seen typical mathematical reasoning 

discussion iterated equalities hard wired mizar implementation 
composition individual steps may involve transitivity substitution equality relation individuals order logic 
trivial example taken article mizar library 
theorem th set holds union union proof set union union union union union union recall mizar indicates subsequent statement meant solve pending goal 
furthermore continued equality sign indicates actual result shall emerge number individual equations transitivity steps handled scenes 
example works isabelle isar follows mercy automated reasoning tools available isabelle see 
theorem auto similar proof tools hol gordon melham pvs owre certainly solve trivial problems ado 
calculations mizar library kind 
incident indicates mizar builtin proof tools handle equality direct support rewriting 
consequently basic simplifications need performed hand numerous steps iterated equalities 
iterated equalities mizar turn indispensable means proper arrangement practical relevant proof patterns 
obviously arbitrary automated reasoning replacement proper concepts high level proof structure 
version takes business calculational reasoning isar seriously 
mimic original mizar proof closely possible 
theorem proof auto 
auto 
auto 
auto show thesis qed important note enlarged text meaningful despite redundant terms automated proof method available isabelle 
chapter 
calculational reasoning terminal sub proof auto strictly limited local problem way disturb global arrangement reasoning accidentally 
calculational sequence evaluated independently intermediate steps taken proof process 
robustness proof texts arbitrary operations performed inside proof methods essentially consequence modularity isar proof processing cf 
chapter 
comparing structure isar calculations iterated equalities mizar observe mizar require separate language elements manage course reasoning isar 
mizar content isar typically require 
spelled explicitly 
hand just happens particular idiomatic expression general playground cf 

notable difference final result exhibited mizar directly available proof context result solves main goal 
isar calculational result indicated forward chaining forces command goal statement meant fact appropriate manner 
common isar idiom reiterate result text prove immediately show result 
scheme isar avoids magical appearance implicit facts calculations spanning lines pages routinely encountered mizar library 
looking closely previous calculational proof proceeds see number substitution steps involved toplevel chain plain transitive repeating previous term contexts 
isar mizar able perform substitutions directly 
subsequent isar proof explicit generic 
term abbreviation indicate positions replacement substitution discipline outlined 
theorem proof auto 
auto auto 
auto show thesis qed important note 
control substitution steps documents effect 
contrast mizar bound fixed notation substitution steps non trivial chains somewhat harder read isar 
substitution chains overly smart 
practical applications adequately represented plain transitivity leaving details substitution justification 
discussion steps simp auto proof methods isabelle see 
mizar concept iterated equalities may understood hardwired version fixed format isar calculations picking parameters framework cf 

individual steps linked plain transitivity substitution individuals order logic 
may show final result emerge immediately mizar proof text additional proof step encountered isar 
intermediate facts emerge proof elements 

term abbreviation degenerates formal device indicate continued equality cf 
mizar special notation 
apparently isar able offer flexible calculational environment conservative additions existing framework 
need calculational concepts existing process high level proof processing natural deduction chapter 
dijkstra universal calculational proof format calculational proof format proposed dijkstra dijkstra scholten strong focus direct manipulation boolean expressions mere relations individual elements 
basic pattern introduced dijkstra scholten iterated logical equivalence eventually yielding boolean values true false 
hint hint hint true true note square bracket notation refers dijkstra builtin treatment implicit state dependency logical expressions cf 
discussion specific notion structures dijkstra scholten 
harrison provides somewhat simpler representation basic idea language hol plain abstraction universal quantification 
abbreviations special case propositions stating equality individuals 
essentially results transitive chains equality relation dijkstra requires leibniz rule justify pattern top previous propositional dijkstra scholten page 
chapter 
calculational reasoning hint hint hint isar framework proof patterns explained easily calculational sequences plain transitivity rules logical equivalence equality cf 

hol logic rules coincide special type bool church gordon melham 
calculate directly propositions illustrated 
note refer additional standard elimination rules true false streamline final results 
proof 
proof 
true proof 
proof 
proof 
false proof 
dijkstra proof format intended replacement natural deduction logical equivalence generally preferred directed reasoning assumptions 
furthermore hints justifying individual calculational steps drawn calculus boolean structures dijkstra scholten featuring number specific rules lattice theoretical fact called golden rule 
example shall illustrate resulting kind reasoning boolean structures cf 
dijkstra scholten 
golden rule associativity symmetry symmetry golden rule treatment full logical equivalence usually quite handsome dijkstra algebraic setting boolean structures 
plain implications 
discussion occasionally required practice direction happens hold hard prove really required 
dijkstra format allows mix equivalence implication direction 
care taken direct calculation properly depending final result true false true versus false 
naturally converse statements useless readily occur proof attempts beginners 
isar may easily emulate mixed form calculating transitivity rules backwards forwards implication propositions 
prefer simplify final implications involving basic boolean values 
proof 
proof 
true proof 
proof 
proof 
false proof 
subsequently expose complete collection transitivity rules required emulate common proof patterns dijkstra calculational format isar 
rules may declared standard eliminations order able conclude plain propositions final result merely single proof step common 
certainly formal details omitted informal setting original dijkstra 
true true false false see high level natural deduction framework isar able assimilate dijkstra algebraic view logic quite easily 
fact styles may coexist environment enabling user choose preferred techniques particular situation hand 
hand standard isabelle library declare specific collection propositional calculational rules 
logical equivalence covered general relation hol chapter 
calculational reasoning intentionally omitted implication rules apart plain modus ponens cf 

fact serious applications really demand backward implication absent isabelle hol library place 
deeper reason excluding transitive chains implication default isar natural deduction core appropriate treat issue directly requiring particular logical connectives 
general rule thumb native isar language elements preferred encoding concepts logic indirection taken care explicitly proofs 
notable example principle reconsider handling nested forms derived isar element obtain cf 

case iterated forward implication fundamental inherently basic concept forward chaining isar chapter illustrated 
assume proof proof proof 
typical applications need exhibit final statement proof may usually just continue dependent result casual manner 
variant calculates transitivity implication native forward chaining seen 
proof 
proof 
proof sight pattern appears quite handsome 
hand individual justification steps need tackle slightly different goal statement involving explicit implications 
automated proof support takes care scenes decompose statements directly text 
single rule applications tend frequently isar minor difference may considered unnecessary complication 
formal noise hidden explicit follows 
initial decomposition remaining justifications technically exactly version plain forward chaining 
proof assume 
discussion proof qed 
proof assume 
proof qed 
proof assume 
proof qed difference derivations facts versus explicit intra logical implication encountered really matter dijkstra original informal setting 
isar additional formal detail apt intrude proof texts immediately need careful avoid unnecessary clutter formal proof texts 
degenerate calculations big step reasoning corresponding notions rule steps versus accumulation steps isar provides kinds calculational commands versus ultimately 
calculations composed may considered proper ones corresponding closely original idea iterated applications implicit transitivity rules 
occasional steps may get included order accommodate rules premises cf 

actual degenerate calculations consist steps conclude ultimately 
effect collect number facts certain range proof text exhibit list theorems ultimate claim 
may involve goal statement established arbitrary proof method cf 

degenerate calculations turn surprisingly useful concept right mainly due key properties isar 

facts contributing calculation may consist proof text produces results eventually 
particular may include explicit blocks 
manage independent local contexts 

ultimate may involve proof method including advanced automated tools 

calculations may nested block structure text 
chapter 
calculational reasoning seen earlier ultimately may essentially invert course basic natural deduction 
results strongly forward style demanding excessive explicit previous facts text 
example consider version 
proof proof ultimately 
scheme may easily generalized number conjuncts isabelle classical tableau prover blast see ultimate step trivial case happens plain simp 
proof proof proof ultimately blast dual pattern elimination essentially works way logical reasoning capabilities blast really required 
facts contributing calculation emerge proof blocks separate local contexts corresponding individual cases original disjunction 
structure subsequent proof pattern follows rule assume assume proof assume proof assume proof ultimately blast examples illustrate basic big step reasoning degenerate calculations automated proof tools 
plain natural deduction essentially scaled larger fragment order logic somewhat depending capabilities underlying proof procedure 
techniques synthesizing results forward manner may occasionally get advantage order streamline isar proof texts 
deeply nested backward patterns may especially benefit illustrated subsequent versions iterated 

discussion proof fix show proof fix show proof fix show proof qed qed qed fix proof blast calculation happens consist single proof block result fed blast step plain forward chaining previous ultimately 
fact ultimately happens equivalent note calculation cf 

may understand technique degenerate calculations natural generalization isar primitive cf 
plain enables proof writer continue result immediately avoiding explicit naming previous facts ultimately achieve similar effect arbitrary number results accumulated chunks proof text 
complex nesting mixed logical connectives may big step reasoning 
limits imposed capabilities ultimate proof method 
actual isar proof processor merely takes care general flow facts including handling nested proof contexts 
proper integration individual results left accidental virtues automated proof procedures happen available 
example essentially covers simultaneous elimination 
simple task blast method isabelle see 
assume assume proof fix assume chapter 
calculational reasoning proof fix assume proof ultimately blast reality attempt omit explicit covering statement automated prover take care formal detail 
contributing facts may included separate step better put calculation 
happen achieve succinct presentation generalized case splitting patterns discussed 
assume proof fix assume proof fix assume proof note auxiliary stuff ultimately blast recall case splitting single branch coincides simpler form generalized elimination covered obtain command cf 

elimination patterns may certainly rephrased big step reasoning style turns slightly awkward practice 
assume obtain blast assume fix assume proof ultimately blast 
discussion issue avoiding explicit elimination statements initial assumptions cf 
related discussion 
note second version require explicit obtain designed independent ultimate goal statements place 
problems big step reasoning concerning general issue high level proof processing previous examples suggest principle ignore existing isar infrastructure intended fine grained natural deduction proof composition chapter content basic elements declare proof structure sufficiently powerful proof procedure fill remaining gaps 
example tempted restrict isar language fix assume ultimately blast 
extreme view big step reasoning occasionally proposed natural approach structured proof processing especially special interest automated reasoning 
wolf introduce separate calculus structured proofs classical order logic separate means achieve local results virtue automated reasoning 
concepts integrated ilf system able process adapted version full collection mizar articles mizar library heavy duty order automation 
existing formalized proofs replayed successfully 
hand unclear system perform development new applications 
original mizar system rudnicki trybulec muzalewski wiedijk particularly providing finegrained error messages failed inference steps indispensable user feedback failed proof attempts 
existing automated reasoning tools usually designed different goals mind posing serious problem error recovery 
example resolution prover transform initial problem unintelligible internal normal form immediate feedback level hard follow users 
harrison mizar mode hol harrison spl show tendency heavy automated proof tools key high level proof texts 
substantial parts covers issue providing suitable automated reasoning underlying implementations hol 
systems provide useful collection basic proof steps simple inferences 
declare syme syme syme diminishes domination automated reasoning bit 
declare heavy combination automated tools hard wired analogous auto isabelle hol see basic principles declarative theorem proving 
chapter 
calculational reasoning speaking isar terms essentially correspond advanced elimination case splitting principles specific support induction patterns 
argue purely automatic checking high level proof texts quite unsuitable realistic applications 
isar perspective automated reasoning needs restricted proper place solving occasional proof obligations occurring 
backed experience isar applications far see restrictive policy proof automation key factor achieve viable system supporting broad range formal developments 
automated reasoning essentially suffers main deficiencies 

failed proof search usually provide feedback users 

successful proof search generally non compositional 
issue failing gracefully particularly important development maintenance proofs 
typical interactive session invocations automated tools fail user able isolate bugs statements omissions auxiliary facts eventually 
successful automated proof search turns exception rule 
automated proving users foremost need proper support automated disproving 
words tools produce counter examples systematically cf 
related issues covered kiv system reif 
similar experience proof development cycle reported non trivial case study conducted declare syme syme syme 
compositionality probably key scalable applications whatsoever 
generally means smaller entities may composed larger ones modular fashion breaking previous 
context theorem proving specific aspects need covered particular monotonicity wrt 
proof contexts invariance wrt 
instantiation statements 
terms isar monotonicity means additional elements fix assume note may safely added existing proof body 
easy see basic isar proof processing mechanism fulfills property essentially due monotonicity underlying higher order backchaining rule holds robustness instantiation 
situation changes immediately automated proof methods enter scene 
practical isar proof development partial proofs routinely break due ill behaved situations involving advanced methods blast auto force see 
powerful procedures typically cause problems practice simpler ones simp 
consequently general strength reduction deductive tools sufficient conduct meaningful isar applications turns important contribution practical usability system 

discussion illustrated concrete applications chapter chapter chapter isar proofs largely refer relatively simple deductive means single step inferences fundamental methods rule cf 
plain higher order rewriting simp see 
common isar proof style able achieve relatively robust proof outlines may analyzed reasonable fine grained steps may checked interactively user 
typically hot spots terminal proofs heavy automated methods blast need taken care separately 
tend demand substantial amount time practice user machine cf 
related discussion 
important minimize incidents automated reasoning sizable isar developments 
contrast style big step reasoning emphasizes role automated means results gathered large portions proof text probably complex structured local contexts need handled ultimately single big step 
note resulting problems similar integration software components number individual pieces finished suddenly joined complex system 
lacking previous considerations individual elements may need correlate failures integration result single big problem treated ad hoc fashion 
example reconsider previous generalized case splitting patterns just minor modifications individual proof blocks due typographical errors misunderstanding writer 
assume assume modified assumption additional proof fix assume proof modified fix assume modified assumption additional parameter proof ultimately chapter 
calculational reasoning individual sub problems may accidentally respective proofs may affect situation anyway compositional proof processing isar 
having successfully processed large body text user ultimately faced failure compose pieces successfully virtue automated reasoning 
unfortunately usually provide clue exactly went wrong particular mismatch individual local proof contexts initial covering statement may left implicit place 
note modifications previous text may valid transformations proof problem independently intended writer 
mcallester essentially follows general idea big step reasoning faithfully 
main paradigm proofs nested lemmas linked implicitly specific inference mechanism 
interestingly mcallester rejects arbitrary heuristic procedures focuses algorithmic principles mcallester 
note degenerate calculations isar easily emulate proof schemes essentially replacing blast method encountered implementation mcallester inference mechanism 
similar tendency reject arbitrary proof search may observed mizar rudnicki trybulec muzalewski wiedijk builtin notion obvious inferences rudnicki deliberately limited fragment classical order logic may decided quickly 
decision may deeper reasons mizar users able compile large body applications mizar library years 
see useful concept degenerate calculations isar needs applied care lest resulting proof development result serious writer anybody doing maintenance 
general liberality principle isar cf 
users abuse 
left discernment proof writer express advanced high level proof schemes adequately 
part iii applications chapter isabelle hol application environment outline isabelle hol application environment required realistic isabelle isar examples covered 
apart basic logical preliminaries hol primary interest review practically relevant issues derived definitional mechanisms advanced proof methods main isabelle hol library 
isar framework essentially generic isabelle different applications 
hand practical demands sufficiently rich environment tools theories readily available 
commit existing isabelle hol system order get started minimal isar specific additions required 
hol logic hol gordon melham gordon emerged system church originally called simple theory types church 
viewed perspective pure logic aspects hol appear slightly peculiar sight type definition primitive example see 
hand system proven robust basis viable theorem proving environments take soundness issues seriously 
despite simplistic respects hol capable sophisticated constructions inside basic system requiring change foundations 
occasionally advanced concepts possible weaknesses hol overloading wenzel extensible records wenzel 
chapter 
isabelle hol application environment isabelle hol formulation nipkow faithful original hol family gordon melham influence isabelle system philosophy difference details 
particular special care taken user experience hol closer traditional mathematics providing separate type sets apart primitive predicates common set theory notation 
internal features hol may largely hidden sight casual readers isabelle hol theory developments 
resulting system simply typed set theory quite convenient realistic applications 
compared actual untyped set theory isabelle zf paulson paulson hol avoids number complications non uniform treatment propositions versus individuals order logic typing issues need handled explicitly set membership reasoning static typing 
subsequently point aspects basic hol concepts relevant user applications 
foundational details discussed isabelle isar example chapter 
simply typed set theory isabelle hol may best understood simply typed classical set theory 
general look feel close original formulation set theory cantor sets classes treated uniformly soundness hol guaranteed simple types church 
particular may naively similar common practice informal mathematics 
types may usually omitted specifications due automatic type reconstruction similar ml haskell 
isabelle hol provides basic notation forming sets predicates general functions 
set comprehension mapped set comprehension set image set theory concepts written usual membership union intersection difference big union type set 
coincidence basic notation isabelle hol closely follows informal background language outlined 
pure logic hol coincides set theory notions boolean expressions predicates replacing sets 
logical notation fairly standard including quantification set bounded quantification standard connectives 
hol logic note internal object logic hol building complex expressions involving boolean values 
primary rules reasoning typically formulated isabelle meta level connectives hol collection general discipline preferring meta level rules object formulae considerably reduces formal noise actual proofs outer structure logical statements need decomposed explicitly proofs 
basic mechanism higher order backchaining isabelle pure framework directly operates rules expected 
isar proof language chapter provides immediate links principles 
atomic meta level propositions require separate concrete syntax prop term type prop omitting prop marker proposition object logic judgment boolean expression 
note involves hidden coercion bool prop traditionally called isabelle 
functions play important role hol 
isabelle version uses standard notation lambda calculus modern higher order programming languages haskell ml see paulson 
application abstraction local binding conditional expression case 
simple pattern matching point wise functional update despite notational coincidence hol quite resemble programming languages 
particular artificial restriction computable functions easily formalized hol ller 
hol functions inherently total partial ones may easily represented polymorphic option datatype consists elements 
basic operations available common type option may considered canonical model partial mappings 
empty empty mapping assignment defined values dom set defined values domain primitive definitions hol logic tiny axiomatic kernel gordon melham stating fundamental facts classical set theory setting 
established tradition hol methodology extensions existing theories definitional certain disciplined axiom schemes may 
important formedness properties chapter 
isabelle hol application environment theories preserved requiring user reconsider full metatheory hol 
formal objects hol differentiated simple types terms may interpreted sets standard model theory pitts 
consequently separate definitional primitives constant definitions type definitions 
mechanisms turn quite dissimilar wrt 
technical specification meta theoretical properties 
isabelle hol provides separate primitive type definitions nipkow wenzel 
constant definitions inherited isabelle pure paulson 
constant definitions element isabelle pure provides user level interface basic constant definitions including conditional equations cf 

specification consists number pairs constant declaration definitional equality cover general type scheme declaration restriction prevents unintended overloading 
nat nat nat result set theorems corresponding original equations theorem named constant def def 
separate consts defs commands provide direct access underlying primitives constant declarations definitions 
definitions may independently declarations 
advanced definitional packages require constants declared separately inductive see primrec see 
furthermore defs allows multiple definitions non overlapping type schemes virtue overloading cf 

consts defs overloaded nat def nat bool def bool false prod def overloaded definition entails obvious results complex type instances essentially primitive recursion syntactic structure type expressions 
lemma nat bool false simp nat def bool def prod def 
hol logic specific may derived unspecified types collection definitional equations may augmented incrementally follows 
defs overloaded fun def important note overloading inherently introduces underspecification theory impossible cover possible hol type schemes uniformly 
underspecification prevents number meta theoretical properties isabelle hol preservation completeness decidability certain sub theories turns useful advanced applications axiomatic type classes wenzel object oriented verification wenzel 
fact hol logic admit strong properties place original formulation gordon melham pitts overloading 
type definitions typedef command isabelle hol provides convenient interface specific hol notion type definitions see foundational issues 
basic idea non empty subset existing type expression new type 
isabelle isar version admits required non emptiness proof performed immediately text wenzel indicated example 
typedef nat 
proof show simp qed obligation typedef existential statement reduced initial proof step demand concrete witness 
subsequent show statement takes care main aspect typedef proof 
note term abbreviation representing set available initial proof context automatically 
result typedef new type principle hol type definitions see constant constant definition name representing set old type 
rules characterize bijections abs inverse rep representing set new type provided 
internal bijection axioms see slightly primitive direct 
isabelle isar provides alternative formulations suitable highlevel reasoning 
particular surjection part expressed rules cases induction order support canonical representation proofs cf 

illustrated subsequent proof patterns 
chapter 
isabelle hol application environment obtain abs cases fix assume obtain rep cases fix proof induct fix assume abs proof qed fix assume proof induct fix show rep proof qed cases induct versions essentially equivalent due degenerate representation recursion involved 
formats actual applications 
cases usually better suited represent concrete expressions new type representing set respectively 
induction appropriate establish universal properties 
advanced definitional packages principle primitive definitional mechanisms constant type definitions sufficient build substantial applications top basic hol proceeding disciplined manner ad hoc axiomatization new concepts 
reality advanced definitional concepts required support sizable developments 
derived definitional mechanisms emerged hol tradition years gordon notably inductive sets types recursive functions see outline berghofer wenzel 
important note high level concepts usually built top existing primitives meta theory hol need reconsidered develop new packages 
implementors need understand hol logic detail rough idea typed set theory sufficient purposes 
see collection advanced definitional packages provided isabelle hol 
typedef taken primitives cf 


advanced definitional packages briefly reviewed focus specific details particularly relevant isar 
coinductive inductive recdef datatype primrec typedef record definitional packages isabelle hol inductive sets types fundamental advanced definitional mechanisms isabelle hol inductive coinductive sets defined knaster tarski fixed points paulson datatype arbitrarily branching tree types optionally mutual indirect recursion 
see berghofer wenzel detailed exposition various classes datatype definitions hol 
note presently package datatypes inductive sets rarely existing isabelle hol applications 
inductive sets inductive package takes collection rules specified theory text internally produces number basic definitions fixed points complete lattice power sets see davey priestley automatically proves rules specified text canonical eliminations resulting fixed point equation induction rule fixed point property 
eliminations declared standard rules cases method likewise induction induct method cf 

original version inductive paulson improved allow nesting standard logical connectives including quantifiers canonical polarity rules handled automatically internal monotonicity proof berghofer wenzel 
importantly meta logical connectives may involved allowing arbitrarily nested rules introductions wenzel 
particular infinitely branching inductive definitions may expressed quite naturally recourse separate connectives object logic 
chapter 
isabelle hol application environment illustrate technique definition algebra generated collection basic sets standard mathematical concept measure theory 
interesting case union inductive parameter indexed type nat 
consts sigma algebra set set set set inductive sigma algebra intros basic sigma algebra univ univ sigma algebra complement sigma algebra sigma algebra union nat 
sigma algebra sigma algebra proof illustrates introductions may ordinary inference rules establish dual union de morgan property sets 
theorem inter nat 
sigma algebra sigma algebra proof assume nat 
sigma algebra nat 
sigma algebra rule complement sigma algebra rule union sigma algebra rule complement simp show thesis qed apparently proof works straight forward manner number meaningful steps requiring unexpected formal twists 
contrast subsequent version uses alternative formulations union inter infinite branching natural numbers expressed object logic separate existing practice isabelle hol 
lemma union nat 
sigma algebra sigma algebra proof lemma inter nat 
sigma algebra sigma algebra proof assume nat 
sigma algebra nat 
sigma algebra 
formal noise nat 
sigma algebra rule complement nat 
sigma algebra 
formal noise sigma algebra rule union sigma algebra rule complement simp show thesis qed 
advanced definitional packages see elimination taken care explicitly 
required original version basic inferences pure framework handle local contexts expected 
strictly speaking proof relies uniform treatment non atomic statements isar proof texts cf 

suppressing get cumbersome proof inter follows 
lemma inter nat 
sigma algebra sigma algebra proof assume nat 
sigma algebra nat 
sigma algebra proof fix sigma algebra 
sigma algebra rule complement qed sigma algebra rule union sigma algebra rule complement simp show thesis qed statements text main atomic propositions 
pose fundamental limitation principle big difference general usability system practice 
hand additional formal twists due object level connectives exposed example big difference traditional isabelle proof scripts usually contain large number technical clarification steps anyway 
unstructured proof scripts tend contain lots formal noise unnoticed 
shall take brief look induction rule emerging inductive definition sigma algebra univ sigma algebra 
sigma algebra naturally nesting meta level connectives specification introductions carries induction 
users traditional isabelle proof scripts normally complex meta level statements kind due inherent limitation basic tactics rules consist atomic statements paulson nipkow 
pointed easy cope situation proper isar proof texts special non atomic propositions induct method takes special care preserve uniform view non atomic statements 
chapter 
isabelle hol application environment induction rule sigma algebra declared standard elimination patterns induction 
may perform rule induction wrt 
definition sigma algebra follows 
assume sigma algebra proof induct fix assume proof show univ proof fix assume sigma algebra proof fix assume nat 
sigma algebra proof qed inductive assumptions side conditions directly reflect textual complexity inductive definition may consider infrastructure symbolic case names offered induct method cf 

assume sigma algebra proof induct open case basic proof case univ univ proof case complement proof case union proof qed compact induction pattern requires additional instantiations advance 
furthermore declared scope local parameters open terminology local parameters original inductive definition appear implicitly proof text cf 

inductive types datatype package isabelle hol provides convenient interface general class tree structures represented classical set theory 

advanced definitional packages collection constructors types specified user 
internal construction inductive definitions set theoretic universe defined hol paulson berghofer wenzel result abstracted typedef primitive cf 

furthermore large number additional infrastructure derived automatically scenes including induction rules support recursion primitive general founded see 
practice important datatype lists existing type 
subsequent definition list taken main library isabelle hol nipkow 
datatype list nil cons list infixr induction provided definition declared plain patterns induct method cf 

may perform standard structural induction follows 
xs proof induct xs show proof fix xs assume xs xs proof qed datatype supports arbitrary branching existing hol type issues raised previous discussion complex meta level rules arising inductive definition essentially apply albeit lesser degree 
basic inductive structure underlying datatype definitions simpler common inductive ones 
consider subsequent example nested partial functions complex cases encountered practice far see theory nested environment bauer application chapter 
datatype env val env env option main induction rule type env involves nested meta level quantifier corresponding indirect recursion function type second case 
val fun 
fun env fun env 
env env env higher rules isar proof texts see full theory nested environments bauer 
certainly traditional isabelle chapter 
isabelle hol application environment tactic scripts quickly run serious due negative nesting meta level connectives 
recursive function definitions primitive recursion datatype package cf 
provides standard combinators structural primitive recursion 
fact primitive recursion covers large range function definitions higher order framework hol 
note inherent restriction computable functions involved 
primrec package offers simple user interface definitional mechanism requiring intended equations user determine primitive definition inside returned proven theorems nipkow 
see berghofer wenzel extensive discussion datatype primrec including issues seamless integration definitional packages 
simple example primrec define append function list introduced cf 

recursion operates argument need give canonical constructor patterns datatype 
second argument fixed parameter recursive definition 
specification coincides official isabelle hol nipkow 
consts append list list list infixr primrec ys ys xs ys xs ys primrec equations available list theorems called append facts declared standard simplification rules see 
consequently simplifier essentially performs reduction default speaking terms coq barras 
apart simplification canonical technique establish results primrec functions generic datatype induction rule may accessed standard pattern induct method cf 

theorem append assoc xs ys zs xs ys zs xs proof induct xs show simp fix xs assume xs xs simp qed alternatively may invoke infrastructure symbolic cases offered induct method provided full instantiation advance 

advanced definitional packages default terminology local parameters produced datatype package somewhat cryptic derived names types involved inductive structure better renamed rule associated primrec definition 
theorem xs ys zs xs ys zs xs proof induct open xs rule append induct case nil simp case cons xs simp qed apparently scheme slightly heavyweight previous version 
practice pattern referring implicit parameters mainly useful complex structures plain lists encountered 
general recursion apart higher order primitive recursion isabelle hol provides general founded function definitions slind recdef package known tfl slind slind 
main advantages recdef primrec theoretically general recursion scheme general pattern matching constructor expressions function arguments including overlapping patterns left right precedence 
user interface recdef similar primrec number equations package performs appropriate primitive definitions inside returns result proven theorems 
exact collection resulting rules may vary original specification depending unwinding constructor patterns performed internally 
due general approach recdef internal proof process turns quite complicated practice recdef heavy automated proof tools happens simple cases hard control users general 
internal proof process consists multiple stages including foundedness determined recursion behavior function definition actual termination wrt 
relation 
tradition fully automated reasoning proof obligations need finished standard tactics inside may controlled indirectly additional hints 
see nipkow nipkow explanations recdef practice 
note original version tfl package slind slind draws gordon hol tradition system organization gordon melham gordon isabelle 
chapter 
isabelle hol application environment argue slightly better integration recdef isar proof language needs provided powerful definitional mechanism tfl may get widely isabelle hol 
essentially proof process needs isar goal statement auxiliary proof context declarations accommodate different stages similar typedef instance see 
resulting infrastructure enable users finish simple recursive definitions canonical automated proofs simp auto able decompose complex ones defined subproblems 
see discussion practically important issue advanced specification mechanisms versus interactive proof 
extensible records record types provide high level view properly nested pairs separate operations field selection update wenzel 
isabelle hol record types need declared explicitly record package illustrated 
record foo nat nat nat definition introduces type foo notation nat nat nat 
concrete record expressions may written function foo nat nat nat foo yields result 
fundamental record operations include selection update named fields involved 
example foo nat update nat foo foo expression update may written 
nested updates available fields may repeated order 
record types operations polymorphic wrt 
rest nested field constructors involved 
due way simple types type inference hol sufficient provide useful notion extensible records essentially free wenzel 
example may add fields existing record type foo follows 
record bar foo bool bar proper type instance foo may apply previous operations ado 
selectors updates may transferred extended record type just virtue schematic polymorphism 
simp 
advanced definitional packages simp rest record type may accessed directly improper field concrete record notation uses 
dots 
example general schemes foo written nat nat nat 
types 
rest term expressions 
see wenzel discussion extensible record types simply typed hol including applications hierarchies mathematical structures object oriented verification 
axiomatic type classes apart simple types terms traditional hol formulations isabelle version provides third syntactic layer order sorted type classes nipkow nipkow prehofer 
type classes merely provide separate qualification hol types immediate logical impact 
simple observations naive polymorphism hol general classes relations types may represented meta logic 
may give immediate interpretation concepts order sorted type signatures propositions pure logical framework wenzel 
observation gives rise separate specification elements instance definition axiomatic type classes instantiation proof respectively wenzel 
overloaded constant definitions cf 
arrives light weight mechanism theories tightly integrated isabelle type system wenzel wenzel 
briefly review canonical example algebraic structures monoids groups 
declare polymorphic operations define axiomatic type classes predicates 
argument type class polymorphic type parameter involved 
note type refers universal syntactic class isabelle hol types 
consts product infixl inverse unit monoid type assoc left unit right unit chapter 
isabelle hol application environment group type assoc left unit left inverse may derive properties axiomatization fact general group theory 
theorem group right inverse group proof simp group left unit 
simp group assoc 
simp group left inverse 
simp group assoc 
simp group left inverse 
simp group assoc 
simp group left unit 
simp group left inverse show thesis qed easy see groups monoids right unit property may derived theorem group right inverse 
inclusion may formally reflected isabelle type signature wenzel including separate instance proof 
instance group monoid proof fix group show rule group assoc show rule group left unit show proof simp group left inverse 
simp group assoc 
simp group right inverse 
automated proof methods 
simp group left unit show thesis qed qed concrete instantiations axiomatic type classes may 
type lists arbitrary argument types monoid defining append nil 
note instantiation technique relies overloaded constant definitions generic hol wenzel cf 

defs overloaded product list def xs ys xs ys unit list def instance list type monoid proof fix xs ys zs list show xs ys zs xs ys zs simp product list def append assoc show xs xs simp product list def unit list def append xs xs induct xs simp xs xs simp product list def unit list def qed due nature overloaded definitions instantiations concrete structures may non overlapping pattern types wenzel wenzel 
multiple views hol type typically require isomorphic copies typedef datatype 
hol type constructors may act functors type classes canonical example direct binary products monoid monoid monoid 
see wenzel development basic lattice theory demonstrates advanced techniques axiomatic type classes 
automated proof methods hol logic turns viable platform broad range existing automated reasoning techniques 
generic isabelle provides main modules build powerful proof tools object logics simplifier paulson nipkow classical reasoner paulson includes advanced implementation existing tableau prover technology paulson 
combinations generic automated proof tools available 
chapter 
isabelle hol application environment perspective low level presentation isabelle hol primitive axioms derived rules chapter loses significance users certain inherent virtues primitive hol simplify construction proof tools considerably syntactic treatment types lamport paulson 
incorporating arbitrary proof tools pure isar framework independent particular object logic features specific prover support 
key concepts isar proof processing cf 
merely depend generic mechanisms higher order unification back chaining may understood basic principles nested natural deduction paulson paulson paulson 
arbitrary proof tools may incorporated isar interface proof methods cf 
interpretation 
technically quite easy turn existing isabelle tactics isabelle isar methods wenzel 
hand care required order achieve appropriate high level view large number variant forms tactics tactic combinations emerged time isabelle paulson 
isabelle isar follows certain classification scheme proof methods outlined see 
rarely variants incorporated main methods separate arguments options 
isar offers user choice collection automated tools relatively easy oversee 
note mizar rudnicki trybulec muzalewski wiedijk declare syme syme syme essentially provide single builtin proof tool solving terminal obligations additional parameters facts hints may user 
policy takes issue declarative theorem proving seriously user specifying operational details 
hand practical experience isabelle isar shown robustness mechanized proof processing may improved leaving user choice adequate means specific problems 
general rule thumb simpler methods preferred complex ones single rules plain rewriting heavy combinations simplification classical reasoning 
essentially occam razor applied proof methods 
consequently resulting isar proof texts processed quickly provide additional clues level complexity particular problems 
example declare essentially refer auto time isar admits differentiate complexity proofs ranging blast simp 
completely different issue incorporating existing proof methods writing new ones 
high level specification general proof procedures 
automated proof methods definitely outside scope isar 
note isar framework natively supports derived rules meta logic covers practically relevant situations considered specific methods requirement sight 
current isabelle isar implementation requires ml programming include new proof methods wenzel usually done start object logic scratch extend existing significantly 
user environment isabelle hol sufficiently equipped support broad range isabelle isar applications demanding user extend system separate ml programming 
generic tools isabelle turn sufficiently flexible practice 
example normalization wrt 
associativity commutativity may easily achieved ordered rewriting isabelle simplifier paulson requiring ad hoc programming proposed 
hand high level representations proof procedures complement primary isar proof language useful manner 
approaches internalize procedures base logic barendregt isar setting top suitable object logic support reflection principles 
alternative may extend primary isar language cover method definitions similar specification format proof procedures proposed 
basic types proof methods isar framework includes fundamental proof methods refer key concept higher order backchaining various ways rule assumption perform normalization wrt 
collection meta level equalities unfold fold 
methods provided view top notably cases induct 
contrast automated proof methods may perform numerous basic inferences inside usually guided additional rule declarations context classification intended rules simplifications introductions eliminations 
furthermore automated procedures generally prone require long runtime due advanced heuristics extensive proof search may diverge particular problem classes 
order arrive reasonably policy incorporate multitude existing isabelle tactics isar introduce classification scheme automated proof methods 
methods may simplify solve goals 
simplification means individual goals may replaced number new ones normalization wrt 
certain collection rules splitting structural case expressions logical decompositions standard introductions eliminations 
reality resulting statements appear user chapter 
isabelle hol application environment complicated simpler 
internal simplification tactics isabelle paulson isar requires simplification actual progress unchanged goal configurations cause process fail altogether 
behaviour may recovered method combinator cf 

solving goal disappear altogether note may influence goals due instantiation schematic variables proof state 
furthermore distinguish range goals addressed method covering head subgoal subgoals 
note arbitrary goal addressing considered inappropriate isar proof texts 
reconsidering standard terminal proof pattern isar methods occur initially single subgoal remaining goals essentially need covered simultaneously 
proof scripts emulated isabelle isar may refer improper commands prefer defer shuffle subgoals see wenzel 
methods isabelle hol provides collection advanced proof methods isar simplifier classical reasoner inside 
method focus kind simp simplifies head simp simp simplifies simp clarify simplifies head classical safe simplifies classical auto simplifies simp classical blast solves head classical force solves head simp classical practice non solving classical methods clarify safe mainly exploration tactic script emulation isar 
methods required porting legacy scripts fast best slow wenzel 
new isar applications may conducted significantly reduced collection essentially simp blast auto structured isar proofs generally demand exact operational behaviour automated methods 
note separate methods solves needed practice repeated application solves head versions similar effect 
may refer blast providing separate version blast 
methods simplifies focus notably auto apt notorious unstructured proof scripts 
problem auto touches existing subgoals replacing probably large number new ones necessarily look simple 
goal configurations tends blown lose previous structure making hard continue script method applications 
proper isar proofs suffer problem modularity structured 
automated proof methods proof processing limits scope methods isolated sub proofs statically delimited text 
common isar idiom auto essentially puts auto sandbox 
discipline turns potentially hazardous procedure viable multi purpose proof tool 
attributes collection proof methods subject specific context information standard rule declarations data field global theory local proof context cf 

rule declarations managed separate attributes outlined see wenzel 
attribute description kind simp simp add add simplification rule simp del delete ditto split add add case splitting rule split del delete ditto cong add add congruence rule cong del delete ditto kind classical intro add rule elim add elimination rule dest add destruction rule rule del delete classical rule kind simp classical iff add add simultaneous simplification elimination iff del delete ditto attributes xxx add may abbreviated xxx 
classical declarations intro elim dest may include modifiers indicate especially high low priorities respectively similarly iff versus iff 
see paulson wenzel details exact role different kinds rule declarations 
note subtleties mainly relevant isar writers 
readers may just choose ignore certain annotations merely observe rules may get 
arguments facts method arguments admit augment rule declarations immediate fully analogous attributes 
example consider proof context declaration note intro elim versus method invocation chapter 
isabelle hol application environment blast intro elim 
see wenzel concrete syntax specifications 
simplifier arguments provide separate short hand method specification simp add refers recurrent pattern adding simplification rules logical cumbersome forms simp simp simp simp add 
special case simp refers simplification rules achieves strength reduction isabelle simplifier turns quite handsome applications unexpected simplifications global context excluded 
facts offered automated methods forward chaining involving isar primitive treated specifically merely inserted goal configuration local premises just actual proof procedure invoked 
important note facts available isar proof context silently 
policy enables writer indicate relevance facts explicitly proof text turns important aspect readability formal documents involve notoriously obscure automated reasoning tools see detailed discussion 
main isabelle hol library theoretical expositions formal logic usually include extensive discussion primitive axiomatic basis meta theoretical properties deductive systems model theory 
contrast applied logic eventually reach stage foundational details important concrete theory environment offered users 
core principles may impact advanced concepts may get implemented especially definitional packages proof methods users care foundations long get system fits needs realistic applications 
concerning isabelle hol nipkow main library consists dag structure theory nodes 
contribute axiomatic basis hol logic hol basic axioms gordon melham set isomorphic copy predicates type set type individuals axiom infinity 
remaining theories required bootstrap reasonable working environment definitions pairs disjoint sums natural numbers support inductive sets general datatypes recursive functions 
fact dependency graph definitional packages cf 
intertwined theories advanced packages usually require basic concepts start 
easily leads quasi circular dependencies need clever arrangement basic concepts harrison special provisions inverted definitions berghofer wenzel 

main isabelle hol library divides power lfp finite set gfp wellfounded relations equiv recdef hol set typedef fun product type sum type relation record int inductive transitive closure wellfounded recursion nat datatype universe datatype bin pure numeral list map relation power main hilbert choice main theory library isabelle hol chapter 
isabelle hol application environment example datatype definitions require natural numbers internally type nat needs treated genuine datatype 
achieved rep datatype isabelle hol takes existing type canonical theorems covering freeness induction retro fits remaining infrastructure actual datatype definitions 
defined type nat may participate primrec recdef 
really behaves defined 
datatype nat suc nat deeper reason substantial efforts bootstrapping main working environment isabelle hol lies key hol methodology start basic concepts build means definitions derivations formal system 
coq barras represents slightly different approach underlying type theory equipped powerful means induction recursion place coquand paulin mohring pfenning paulin mohring paulin mohring 
concepts clear justification meta theory calculus inductive constructions developed separately 
hol strong concepts constructed reduction primitive concepts simply typed set theory essentially run time theory processor 
pvs owre follows approach substantial parts library packages hardwired implementation intrinsic formal justifications place 
independently foundational issues isabelle hol users offered comfortable working environment means ultimate theory main 
provides faithful view real isabelle hol logic primitive basis hol 
context provided main advanced induction recursion readily available appeal proponents constructive type theory details classical reasoning see hilbert choice operator see hol type definitions see largely hidden sight 
user extensions isabelle hol usually involve complex bootstrapping issues anymore 
authors may build theories natural dependencies arising definitions proofs 
vein supplemental library generally useful isabelle hol theories bauer developed outside monolithic part main isabelle hol 
discussion theory specifications versus proofs speaking terms primitive logical concepts chapter specifications proofs fundamental means achieve new results certain 
discussion context 
experience existing theorem proving environments shows applied logic demands proper methodology interaction different aspects 
definitional concepts require separate coverage proof obligations typedef instance isabelle hol 
interestingly type theory tradition able unify concepts specification proof framework typed calculus see exposition barendregt geuvers 
existing type theory provers may offer differentiated view user coq barras clearly separates specification language tactical proof language principle able produce kind terms 
practice coq occasionally requires decisions user proof better specification certain situations 
typical example side conditions stemming partial algebraic operations division see related discussion geuvers 
original lcf hol tradition gordon specifications proofs treated differently basic logic pitts essentially uniformly perspective users 
view systems ml top level loop collection datatype constructors primitive inference rules definitional extensions alike 
ml interface hol generally tends bare bones construction theory theorem objects 
example non emptiness obligation required type definition primitive see needs stated separate theorem feeding result subsequent definition stage ml value hand 
commonly encountered hol technique advanced definitional packages solve proof obligations fully automatically inside 
implementation ml typically exploits specific form proof problems emerging certain class specifications inductive datatypes particular form 
isabelle hol approach appears inductive datatype primrec recdef record 
automated setup works reasonably schematic proof obligations arising defined specification schemes datatype primrec 
things slightly difficult general mechanisms tfl slind slind recdef isabelle hol 
proof obligations termination may arbitrarily complex depending actual recursive function specification user 
pointed earlier recdef refers number standard automated proof tools may controlled indirectly hints previously established facts indication role automated process cf 
isar attributes recdef simp recdef cong recdef wf wenzel 
arrangement essentially follows original hol tradition feeding previous theorems definitional mechanisms mediates auxiliary facts complex proof procedures 
practice amounts obscure automated reasoning existing techniques chapter 
isabelle hol application environment interactive tactical proving hol 
founded recursion coq bertot exhibits analogous problems incorporating separate proof obligations non trivial definitional patterns 
unified approach type theory proofs side conditions may principle included directly terms specification text 
naive approach turns slightly impractical due complexity proof objects encountered founded recursion 
bertot propose specific coq mechanism achieve presentation restricted class founded recursive definitions 
pvs owre follows different approach side conditions arising specifications 
consider proofs class members theory developments place treats uniformly genuine proof obligations managed separately including type checking conditions due predicate subtyping logical statements termination recursive definitions plain theorem statements 
proofs managed dynamically special files actual theory merely consists definitions statements 
theory marked finished obligations covered interactively user 
specific support change management automatic replay old proof scripts scenes individual failures previous proofs marked accordingly 
pvs positioned prototype verification system users may develop formal descriptions explored means interactive proof checking model checking order exhibit bugs designs 
consequently proofs treated mere necessities pop dynamically need accommodated specific tool achieve maximum comfort users 
concept proofs independent static representations formal reasoning conducted users considered important 
specifications readable proofs isar perspective issue incorporating proofs specification mechanisms need reconsidered primary view formal document construction primitive logical issues particular system organization 
informal mathematics definitions proofs may freely intermixed text ado 
example operations quotient structures typically demand definedness proofs establishing congruence properties modulo certain equivalence relation 
mizar rudnicki trybulec muzalewski wiedijk successfully follows basic observation mathematical practice 
mizar specification schemes include proof texts cover separate obligations 
subsequent example taken article mizar library 
illustrates indirect definition giving unique characterization intended entity see expression means part 
definition 
discussion omega non empty set omega subset omega func omega means def holds existence proof 
uniqueness proof 
existence uniqueness keywords indicate specific goal statements required particular definitional scheme 
proof bodies formulated terms existing mizar proof language 
isar intend follow essentially idea incorporating existing proof language theory specification mechanisms modular fashion 
care required accommodate open ended nature isar syntax incremental way isar proof processing 
general technique split definitional mechanism stages indicated 
existing theorem command isar turns sufficiently flexible provide link stages just virtue attribute specification may included initial result specification 

preamble may perform initial preparations syntactic checks specification text commencing ordinary isar proof posing new claim theory level 

proof proceeds incrementally existing isar language elements user 
package immediate control shape proof may included special support initial context declarations term abbreviations auxiliary facts 
example may ensure canonical proof steps right thing commence manual proof practice virtue appropriate rule declarations 
trivial situations single automated step simp 

acquires result established user eventually performs actual theory extension 
note prefer include single isar proof specification mechanisms loss generality 
multiple obligations may easily represented object logic plain may achieved chapter 
isabelle hol application environment simultaneously principles underlying obtain cf 

policy avoids pseudo goal statements existence uniqueness exhibited mizar example 
conical isar proof patterns may involve plain show elements order preferred writer 
illustrate general isar technique mixed specifications proofs typedef isabelle hol cf 

derived theory command theorem primitive indicated 
refers representing set specified user package demands non emptiness statement complete actual definition see 
theorem perform typedef set user may fill isar proof immediately text example canonical proof step turn demands concrete existential witness subsequent sub proof virtue 
order accommodate common pattern typedef package provided suitable term abbreviation initial goal statement actual name type definition cf 

proof show set proof qed having finished proof result fed special attribute perform typedef essentially performs type definition primitive gordon hol implementations discussed gordon melham gordon 
recall theory attribute may arbitrary function theory theorem theory theorem cf 
interpretation 
simply perform typedef augment theory type definition primitive passing non emptiness fact 
instance specification isabelle isar works similar lines 
initial claim logical reflection type arities class inclusion statements wenzel 
standard class rules available global patterns user may standard proof step reduce raw goal number subgoals corresponding exactly class axioms need established particular instantiation hand 
remains seen technique combining advanced specification mechanisms readable proofs scales sophisticated packages tfl slind slind 
successful reformulation recdef isabelle isar provide better understanding different stages internal proof process significantly improved user convenience 
isar proof contexts provide far infrastructure lay complex proof obligations primitive goal states tfl far 

discussion proof methods relevance facts consider recurrent isar proof pattern establishing intermediate fact atomic proof step 
text fragment able communicate important aspects formal reasoning reader including usage existing facts result statement proof method isar phrase appears quite intelligible due pseudo natural language reading 
hand may raise key question formal meaning corresponding sequence isar vm transitions encountered cf 
consistent informal reading text 
principle real behavior formal proof texts readers example names primitive elements concrete syntax chosen badly 
call portion isar proof text faithful iff general perception readers coincides actual formal meaning 
apparently faithfulness texts easily determined exactly heavily depends general expectations particular readers may broad range interpretations real meaning 
concerning language design isar cf 
chapter great care taken achieve high degree faithfulness proof texts default common style writing 
open design isar highly compositional nature allows different kinds language elements combined numerous ways hard rule semantic anomalies altogether 
isar proof writer may certainly produce non sense full intention take away freedom cost inflexibility restricted language 
hand anomalies creep isar proofs accident 
reconsidering aspects elementary pattern observe isar ensures proper treatment referenced facts guaranteed established explicit statement real result produced eventually 
proof method involved apt unexpected effects arbitrary inferences may performed inside 
basic rule steps occasionally unexpected effects higher order backchaining completely trivial operation 
subsequent example demonstrates proof texts single inferences may reader 
assume ab assume chapter 
isabelle hol application environment ab 
non faithful proof text 
apparently proof slightly inappropriate reader think fact ab contributes result reality local assumptions emerging initial elimination ignored 
worse different assumption implicitly builtin notion finished isar goal configurations proof assumption 
sane proof documented detail 
ab proof assume ignored finished assumption qed fortunately danger producing faulty texts accident high practice provided writer takes minimal care proof composition 
note individual applications rules assumptions quite easy trace interactive development especially conjunction proof general interface proof general aspinall 
situation changes substantially arbitrary automated proof methods cf 

encounter fundamental problem relevance facts automated reasoning 
common proof procedures order tableau prover implemented isabelle blast paulson operate goal configuration may include number premises considered axioms purpose proof search 
general behavior common search procedures critically depends collection facts included problem 
adding removing local facts search space runtime may grow shrink considerably just failure divergence procedure 
usually hard tell particular facts really difference 
ideally proof procedures include comprehensive diagnostic information relevance facts encountered internal path automated proof search 
unfortunately poses fundamental problem existing techniques automated reasoning theory practice 
note automated tools record internal success path terms basic inference underlying logic hard acquire full representations primitive proof objects 
recording relevance internal inference steps difficult 
isar specific issues implementing automated proof tools properly offers discipline order keep critical dependency local facts control proof writer 
general rule advanced methods may refer previous facts proof contexts 
discussion assumptions local results include explicitly highlighted proof writer forward chaining separate arguments method specification 
simple policy turns quite robust practice 
possible sure facts participate building result readers know local facts may relevant particular automated step 
reconsider basic proof patterns involving heavily automated method 
blast independent exact course reasoning performed inside blast text able tell reader local facts may immediately contribute result note global declarations additional rules intro elim dest rules blast cf 
slightly different issue 
syntactic reasons global rules may refer local entities particular proof context 
badly designed theory library may cause unexpected behaviour automated tools right 
beneficial effect restricting local facts isar goal configurations kept relatively small 
essentially enforces limited form compositionality automated tools wrt 
augmenting proof contexts cf 
related discussion additional assumptions facts included advanced method invocations place disturb behavior manners 
contrast unstructured tactical proof scripts tend suffer severely goal states crowded excessive facts 
basic paradigm tactical proving apply consecutive transformations goals solved form reached eventually cf 

information accumulated big goal state routinely automated methods realistic applications 
reason tactical systems usually provide special tools tune goal states ad hoc fashion thin tac traditional isabelle paulson 
hand structured proof systems isabelle isar scalable special provisions required 
see experience reported chapter especially concerning run time behavior nontrivial isar proof texts see 
particular technique big step reasoning degenerate calculational proof schemes cf 
essentially provides perspective relevance problem facts may collected sections isar proof text 
chapter 
isabelle hol application environment chapter example higher order logic reconsider foundational issues hol logic ranging pure framework minimal higher order logic slightly exotic features classical hol practice including hilbert choice operator type definitions 
isar perspective formal development serves realistic example studying issues pure logic conducted level higher order syntax derived rules 
isabelle hol discuss foundations pure background theory isabelle isar 
minimal higher order logic theory higher order logic pure simply typed lambda terms language simply typed terms represented background theory known approach higher order syntax pfenning elliott 
introduce subclass type types language terms 
types propositions functions operate class 
classes type logic type typedecl arities type typedecl infixr arities type type type chapter 
example higher order logic signatures abstraction application object language declared follows 
state conversion rules equality axioms 
consts abs binder app infixl axioms beta conv eta conv representation basically provides separate copy syntactic background calculus happens conversion laws able keep underlying equational theory control 
consequently conversions object language exposed explicitly proofs 
explicit reasoning conversions basic syntax happens part meta theoretical study hol 
contrast actual application environment chapter identify syntax existing framework possible order spare users unnecessary formal noise 
conversion take place implicitly builtin operations especially higher order unification back chaining cf 

basic logical connectives syntax simply typed terms available actual logical properties language represented truth judgment coerces type object level statements propositions prop framework 
canonical way represent object logics isabelle meta logic paulson paulson 
note concrete syntax leaves coercion implicit special notation category prop 
judgment prop implication universal quantification arbitrary types declared syntax characteristic rules follows 
consts imp syntax imp infixr idt translations imp 
extensional equality axioms impi intro impe dest trans alli intro alle dest representation quantified propositions follows earliest tradition higher order logic church 
principle may applied similar binders 
casual handling variable binding abstraction key virtues higherorder syntax pfenning elliott 
axioms may understood rules truth judgment 
view sufficient study resulting logical system level primitive derived rules 
hand induction rule available reason derivability statements exhaustive manner 
particular admissible rules presently reach 
established way model logical system rules induction define derivability inductive set basic syntax 
enable full range meta theoretical studies including completeness issues leaving handsome approach higher order syntax 
ongoing combining higher order syntax directly induction principles despeyroux hofmann resulting systems complexities theory practice 
extensional equality axiomatic base minimal logic extended particular kind equality 
declarations introduce extensional equivalence relation coincides logical equivalence 
careful introduce atomic axioms cf 
treatment pure framework easy derive proper rules useful practice 
consts equal syntax equal infixl translations equal axioms refl intro chapter 
example higher order logic subst ax ext ax iff ax theorem subst proof note subst ax assume assume unfold beta conv unfold beta conv qed theorem ext intro proof note ext ax assume 
show qed theorem iff intro proof note iff ax assume 
assume 
show qed ready derive basic properties congruence underlying term language 
symmetry transitivity consequences reflexivity substitution 
declare standard transitivity rules calculational reasoning cf 
chapter 
theorem sym elim proof assume rule subst rule refl qed lemma trans rule subst rule sym lemma trans rule subst theorem trans trans rule subst 
connectives derive congruences application abstraction 
simple consequence reflexivity substitution 
involves additional properties term language extensionality conversion 
theorem app cong intro proof assume rule subst rule refl assume rule subst rule refl show thesis qed lemma intro rule app cong rule refl theorem abs cong intro proof assume eq show thesis proof fix eq unfold beta conv qed qed important note formulation equality framework substitution chosen primitive emerging congruences derived rules 
required induction establish substitution admissible rule possible 
complete characterization logical equivalence 
eliminations basic consequences substitution hol 
theorem iff elim rule subst theorem iff elim rule subst rule sym connectives definitions having unrestricted quantification propositions available minimal higherorder logic may introduce standard set logical connectives purely definitional manner 
representation standard connectives closely follows established traditions higher order logic type theory 
general rule thumb definition derived connective follows canonical elimination rule 
chapter 
example higher order logic consts false true conj disj ex syntax equal infixl conj infixr disj infixr ex idt translations conj disj ex defs false def true def def conj def conj 
disj def disj 
ex def ex 
derived rules definitions usual characteristic rules standard logical connectives may derived follows 
theorem elim proof unfold false def assume 
qed theorem truei intro proof unfold true def show 
qed theorem noti intro proof unfold def assume 
unfold beta conv 
connectives qed theorem note elim proof unfold def assume unfold beta conv assume 

qed lemma note rule note lemmas contradiction note note proof contradiction order theorem intro proof unfold conj def assume 
proof fix show proof assume note note show qed qed 
unfold beta conv qed theorem elim proof unfold conj def assume 

unfold beta conv assume proof show proof 
proof assume 
qed show thesis qed chapter 
example higher order logic show proof 
proof show 
qed show thesis qed qed qed theorem intro proof unfold disj def assume 
proof fix show proof assume note 
qed qed 
unfold beta conv qed theorem intro proof unfold disj def assume 
proof fix show proof show proof assume note show qed qed qed 
unfold beta conv qed theorem elim proof unfold disj def 
connectives assume 

unfold beta conv assume show proof 
proof assume rule qed proof assume rule qed show thesis qed qed theorem exi intro proof unfold ex def assume 

proof fix show 
proof assume 

unfold beta conv note show qed qed 
unfold beta conv qed theorem exe elim proof unfold ex def assume 


unfold beta conv assume show proof 


proof fix show proof assume unfold beta conv chapter 
example higher order logic rule qed qed show thesis qed qed classical logic ways characterize classical logic 
axiom corresponding derived rule express classical reasoning explicit way show proposition may assume negation 
axioms classical ax theorem classical proof note classical ax assume 
show qed peirce law similar known characterization classical logic uses implication statement 
observing acts defined way peirce law understood formal generalization classical ax statement represented arbitrary proposition theorem peirce law proof assume show proof rule classical assume proof assume rule contradiction qed show 
qed qed alternative classical rules may derived follows double negation non classical cases particularly useful practice 

classical logic theorem double negation proof assume show proof rule classical assume thesis rule contradiction qed qed theorem non proof rule double negation show proof assume proof assume 
rule contradiction qed 
rule contradiction qed qed theorem classical cases proof assume non show proof assume thesis rule assume thesis rule qed qed apparently rules entail order 
may close circle back classical rule rule proof course 
illustrate known fact rules may serve complete characterization classical reasoning cf 
comprehensive exposition thompson 
lemma proof assume chapter 
example higher order logic show proof rule classical cases assume assume rule qed qed hilbert choice operator hilbert choice operator called takes arbitrary predicate delivers unspecified element belonging extension result completely unknown empty predicate 
usual binder syntax write selection predicate 
consts syntax idt translations axioms ax theorem proof note ax assume unfold beta conv 
thesis unfold beta conv qed hilbert choice operator occasionally slightly mysterious mechanism appears allow elements picked empty set 
hand may seen just total higher order function happens somewhat underspecified formal framework hol 
view fits general totality approach hol formed expression treated properly defined demanding unique interpretation 
mainstream mathematics usually content unique descriptions selecting elements singleton sets 
fact common hilbert choice hol 
formulation andrews includes operator unique descriptions 
derived rule covers special case practically useful manner 

concrete types type definitions shows evaluate choice expression exhibiting unique witness 
theorem equality proof assume assume rule rule qed occasionally general form hilbert choice may useful 
example rational numbers chapter includes simple theory quotient types general choice principle pick default elements equivalence classes unique underlying equivalence relation see 
concrete types type definitions far presentation basic hol logic provided basic type propositions degenerates boolean values classical systems functions arbitrarily complex types order achieve sufficiently rich environment represent mathematical concepts customary axiomatize type infinite collection individuals 
subsequently common characterization infinity injection surjection 
typedecl arities type axioms infinite 
principle types sufficient represent common mathematical notions hol inherent expressive power see exposition andrews original formulation church 
example acquired infinite property turn suitable representatives successor zero respectively natural numbers may considered subset type hand potential hol types somewhat diminished elementary approach types merely achieve syntactic ranking objects order guarantee consistency system happens church original intention untyped system failed due russel paradox 
hol essentially just treated restricted version untyped set theory 
church original formulation simple theory types church chapter 
example higher order logic rediscovered gordon useful basis computer science applications interactive development machine checked formal proof gordon gordon gordon melham gordon 
point hol acquired improved treatment types supporting arbitrary type constructors schematic polymorphism 
furthermore mechanism hol type definitions devised order able introduce new types disciplined manner hol tradition generally rejects arbitrary axiomatizations users 
basic characterization type definitions hol type definitions state axioms identify non empty subset existing type new type 
expressed set theoretic manner bijections rep abs specified 
subsequent property type definition stated axiom new type represented non empty subset existing type identify sets predicates isabelle hol uses separate type sets chapter 
rep abs hol type definition type definition type definition rep abs 
rep abs rep rep abs compact axiomatization may decomposed separate theorems rep rep inverse abs inverse follows 
lemma type elim type definition rep abs rep abs rep 
concrete types type definitions rep abs rep rep inverse abs inverse proof unfold type definition def beta conv assume rep rep inverse abs inverse assume rep rep inverse abs inverse rep inverse abs inverse 
rep 
rep 
rep inverse 
rep inverse 
abs inverse 
abs inverse 
ultimately show rule qed theorem rep type definition rep abs rep rule type theorem rep inverse type definition rep abs abs rep rule type theorem abs inverse type definition rep abs rep abs proof assume type definition rep abs rep abs 
assume show thesis qed important note hol types need treated inherently nonempty due basic inference rules 
particular theorem type proof works fixing arbitrary element syntactic hol type pose additional constraint result mention element 
theorem type 
proof fix assume 

qed fundamental non emptiness hol types may observed behavior basic theory extensions cf 

particular constants arbitrary type may declared time affecting fundamental properties theory relevant manner way hol practice admit strong properties place 
chapter 
example higher order logic hilbert choice operator cf 
provides way achieve witness terms arbitrary type schemes slightly exotic construction really required observe effects pure formulation higher order logic cf 

see hol type definitions necessarily require non emptiness representing set established 
condition sufficient preserve certain semantical properties resulting axiom scheme considered definitional pitts class standard models classical hol ensures type universes closed forming non empty subsets 
hand hol type definitions share meta theoretical properties plain constant definitions cf 

demonstrated wenzel type definitions syntactically conservative consistency need preserved notion standard models underlying argument pitts incomplete wrt 
deductive system hol 
important note incomplete view hol merely effect particular set theoretic interpretation required pitts order typedef primitive appear definitional concept 
higher order nature hol apt incompleteness 
fact henkin shows completeness original formulation church 
proof may essentially techniques propositional order logic cf 
detailed exposition andrews 
derived rules type definitions primitive axioms hol type definitions quite cumbersome practice 
theorems express higher level view injections amount simplification rules equality surjections yield degenerate rules cases induction new type original set 
theorem rep inject type definition rep abs rep rep proof assume type definition rep abs show thesis proof assume rep rep abs rep abs rep 
abs rep rule rep inverse abs rep rule rep inverse show assume rep rep 
qed qed 
concrete types type definitions theorem abs inject type definition rep abs abs abs proof assume type definition rep abs assume show thesis proof assume abs abs rep abs rep abs 
rep abs rule abs inverse rep abs rule abs inverse show assume abs abs 
qed qed theorem rep cases type definition rep abs rep proof assume type definition rep abs assume rep proof rep abs rule abs inverse rep abs 
qed qed theorem abs cases type definition rep abs abs proof assume type definition rep abs assume abs proof abs rep rule rep inverse abs rep 
show rep rule rep qed qed theorem rep induct type definition rep abs rep chapter 
example higher order logic proof assume type definition rep abs assume rep rep abs assume rep abs rule abs inverse show qed theorem abs induct type definition rep abs abs proof assume abs assume type definition rep abs rep rule rep abs rep rule abs rep rule rep inverse show qed real isabelle hol environment chapter cases induct rules may get implicitly cases induct proof methods cf 
general proof patterns 
technically treat hol type definitions hybrid inductive set datatype cf 
recursion involved 
resulting high level setup isabelle isar reduces formal noise involved detailed type abstraction representation issues reasonable level 
hol type definitions turn useful mechanisms user applications 
far raw typedef generally considered cumbersome 
see chapter concrete application uses isabelle hol typedef primitive effectively isabelle isar 
discussion isar techniques technically speaking formulation higher order logic basic framework isabelle pure quite similar initial example order logic chapter 
consequently employed similar techniques reasoning plain natural deduction single steps automated proof tools available 
derivations hol slightly realistic ones fol referred additional techniques order keep tedium manual reasoning reasonable level 
note lack advanced proof tools exhibits inherent issue bootstrapping new object logics formulated pure framework 
automated 
discussion isar techniques proof tools isabelle tableau prover blast paulson typically require number auxiliary theorems internal setup obviously need derived simpler means 
far isabelle tradition building object logics concerned early bootstrapping stages tend consist slightly unstructured collection proof scripts heavy ad hoc automation simulated tactic combinators especially repeating alternative choices scripts 
isabelle isar application demonstrates decent proofs may performed start new object logic 
argue primitive theories deserve proper treatment formal proofs order enable interested readers understand details building formal reasoning environments scratch 
think need general perception primitive concepts mechanized reasoning systems slightly arcane matter equally possible employ lucid declarative techniques 
subsequently point notable techniques accommodate lack automated proof tools encountered hol formulation 
calculating implication implication frequently encountered formal text stemming atomic axioms definitions object level connectives 
wish derive proper rules formulated meta level connective need treat implication accordingly typically means modus ponens rule happens rule directly fits paradigm calculational reasoning cf 
chapter 
implication current calculational result may continue chain adding order conclude step iterated curried implications implication may continue chain expected 
example technique exhibited theorem iff 
recall statement iff ax theorem iff intro proof note iff ax assume 
assume 
show qed effect calculating implication similar restricted scripting techniques encountered intros command coq barras example 
assume element mizar rudnicki trybulec muzalewski wiedijk essentially chapter 
example higher order logic cf 

certain forms isar calculations may disciplined replacement operational goal transformations implicit compositions performed calculational sequences internally restricted set transitivity rules declared cf 
chapter 
elimination encountered example analogous elimination rule quite suitable calculational reasoning premise 
simply typed hol syntactic typing element treated logical judgment cf 

consider calculate set bounded quantifiers available isabelle hol chapter rule cf 

compact presentation multiple complete lack automated reasoning tools felt severely derived projections type definition statement 
individual proofs basically proceed manner eliminating quantifiers projecting conjunctions 
kind inferences singled separate lemma type 
multiple simultaneous results expressed canonical fashion just conjunction represented minimal logic recall 
acts just conjunction lemma type elim type definition rep abs rep abs rep rep abs rep rep inverse abs inverse proof body kept reasonably term abbreviations 
refrain cheating ad hoc proof scripts take issue structured proof texts seriously despite boring instance 
proof unfold type definition def beta conv assume rep rep inverse abs inverse assume rep rep inverse abs inverse rep inverse abs inverse 
rep 
rep 
rep inverse 
rep inverse 
abs inverse 
abs inverse 
ultimately show rule qed extracting rules basic definitions introductions eliminations recurrent pattern applications natural deduction framework isabelle paulson nipkow 
transition formal bookkeeping 
discussion isar techniques tasks proofs best represented atomic step suitable proof tools 
real isabelle hol chapter typically refer idiom unfold type definition def blast full power classical tableau proving overkill 
tool happens available isabelle paulson quick broad range logical proof problems 
non classical setting probably take care offer simpler tool achieve kind basic formal rearrangement connectives 
chapter 
example higher order logic chapter example rational numbers theory rational numbers canonical representation equivalence classes pairs integers 
standard algebraic laws fields proven 
development covers domain algebraic structures mathematical modeling involving concrete representations 
basic ideas formalization close traditional textbook expositions employ advanced techniques specific isabelle hol axiomatic type classes type abstractions 
observe isabelle isar able handle mathematical applications adequately larger ones performed 
motivation classical mathematics appears canonical domain non trivial applications structured proof languages due mizar system rudnicki trybulec muzalewski wiedijk successfully applied collecting large body formalized mathematics mizar library 
mathematicians know value real proofs readable representations logical arguments essentially definition 
surprising theorem proving environment built mathematicians strongly emphasizes structured proof texts 
contrast systems built computer scientists tend impose completely different views existing problem spaces 
far isabelle isar concerned demonstrated applications pure logic may adequately cf 
chapter chapter 
general techniques chapter chapter carry classical mathematics just 
popular example explain concept informal chapter 
example rational numbers mathematical proof place 
subsequent isar text presents fully formal version reasonable level abstraction standard theories integer division real numbers isabelle hol cf 
chapter 
establish generalized statement prime number including 
theorem real prime proof assume sqrt real assume prime prime simp add prime def assume obtain rat real real gcd gcd 
eq proof rat real real simp real real simp add power real power split abs split sqrt 
real simp show thesis 
qed dvd dvd proof eq dvd 
prime show dvd rule prime dvd power obtain 
eq simp add power mult ac simp add power dvd 
prime show dvd rule prime dvd power qed dvd gcd 
gcd dvd simp simp add dvd imp le show false simp qed just applications basic logic covered far cf 
chapter chapter isar text focuses explicit statements plus inherent structure indicating composition individual items explicit local global facts kept minimum detailed proof method specifications avoided 
compared similar proof article mizar library isar version requires explicit individual facts local ones library purely technical steps proof properly terms builtin automated checker 
realistic application human readable proof construction confronted 
motivation general issue slightly unexpected behavior automated proof tools involved 
perspective composing high level proof texts automated tools tend uneven sense simple reasoning steps just fail complex ones happen immediately 
apparently general problem kind automated reasoning tools available today similar experience observed longterm experience mizar rudnicki trybulec 
users usually interested details automated reasoning procedures technical slightly unsatisfactory 
mizar builtin notion obvious inferences rudnicki relatively simple compared standards existing automated reasoning technology simplifier isabelle hol advanced proof tool example conceptually simpler 
exact behavior hard predict practice situation usually worse heavily automated reasoning procedures blast force isabelle hol cf 

writing non trivial proof texts involves amount experimentation isabelle isar readily supports interactive interpretation probably including improper proof commands cf 
chapter 
hand important virtue high level proof checking ad hoc automated reasoning may replaced defined concepts structured proof composition situations 
principle observed mizar cf 
separates processing individual proof outline elements assume solving problems terminal position mechanisms particular view classical order logic non intuitive effects 
contrast basic machinery isar proof processing essentially restricted back chaining rules minimal higher order logic involving higher order unification advanced concept cf 
chapter chapter 
additional reasoning procedures clearly marked explicit method specifications text 
need ad hoc proof automation may reduced means derived isar language elements advanced natural deduction calculational reasoning cf 
chapter chapter 
certainly concepts completely redundant technical view formal reasoning indispensable lay realistic isar proof texts adequately 
result new users isabelle isar need spend time learning cope automated tools may get started quickly common proof patterns distinctive elements 
example meaningful applications classical mathematics may performed simple algebraic calculations involving step wise transformations equalities basic calculational cf 
chapter 
interestingly simple mode reasoning isar turns particularly difficult emulate established tactical theorem proving systems cf 
experience reported bauer wenzel 
discrepancy chapter 
example rational numbers related general bias existing tactical proof tools coq hol isabelle hol heavy logical reasoning including inductive techniques simple algebraic manipulations 
consequently traditional applications systems oriented classical mathematics 
contrast non trivial application isabelle isar mathematics known hahn banach theorem functional analysis bauer bauer bauer wenzel textbook exposition 
complete formal development bauer takes printed pages includes basic facts real vector spaces subspaces norms ordering functionals variations main theorem 
original development bauer uses early version isabelle isar conveniences environment missing advanced derived elements generalized elimination cf 

formal theory development completed master project weeks including time get acquainted concepts isar implementation quite finished time 
hahn banach application certainly marks important milestone evaluating concepts isar practice 
day perspective turns relatively simple exercise 
advanced mathematical applications come range isabelle isar concepts implementation matured large stock standard proof techniques explored cf 
chapter chapter 
mathematical example relatively small simple 
subsequently give construction rational numbers demonstrates techniques algebraic structures concrete mathematical modeling isabelle isar hol logic 
formal development uses specific concepts isabelle hol advantage axiomatic type classes type abstraction cf 
chapter 
nicely accommodates notoriously cumbersome formal treatment algebraic quotient structures cf 
harrison traditional treatment hol light involving additional ml programming 
quotient types theory quotient main introduce notion generic quotient types equivalence relations definition principles operations quotients 
basic ideas formalization stem 

quotient types equivalence relations quotient types type class equiv models equivalence relations bool 
eqv type consts eqv eqv bool infixl equiv eqv equiv refl intro equiv trans trans equiv sym elim quotient type quot consists equivalence classes elements base type typedef quot eqv 
true blast lemma intro quot unfold quot def blast lemma quote elim quot unfold quot def blast equivalence classes canonical representation quotient elements 
class equiv quot abs quot theorem quot exhaust proof cases fix assume abs quot assume quot blast abs quot blast thesis unfold class def qed lemma quot cases cases type quot insert quot exhaust blast equality quotients equality canonical quotient elements coincides original relation 
theorem quot equality iff proof assume chapter 
example rational numbers simp class def abs quot inject 
ultimately blast blast 
assume eqv proof rule collect cong fix show proof eqv 
assume 
show note eqv assume show qed qed simp class def qed picking representing elements define operation pick selecting representing elements equivalence classes inhabited due reflexivity underlying relation 
representatives equivalent specific chosen pick left unspecified due hilbert choice operator cf 

pick equiv quot pick theorem pick equiv intro pick proof unfold pick def show proof rule show 
fix assume 

qed qed theorem pick inverse intro pick proof cases 
quotient types fix assume pick simp pick equiv pick 
show thesis simp qed rules support canonical function definitions quotient types arguments 
general version covers conditional definitions simpler unconditional formulation sufficient applications 
theorem quot cond function pick pick prop def prop cong proof assume cong prop cong assume prop def pick pick simp pick pick proof rule cong show pick 
show pick 
show ultimately show pick pick simp qed show thesis qed theorem quot function pick pick proof case rule context truei show thesis rule quot cond function qed chapter 
example rational numbers rational numbers theory rational numbers quotient ring field field rational numbers represented canonical fashion start concrete fractions integers define standard algebraic operations fractions establish corresponding congruence properties 
resulting structure abstracted quotient type construction 
fractions integers type fractions type fraction represented set pairs integers numerator denominator components non zero 
typedef fraction int int proof show fraction simp qed fract int int fraction fract abs fraction num fraction int num fst rep fraction den fraction int den snd rep fraction derive basic properties selector operations canonical representation rules 
lemma fract num simp num fract simp add fract def num def fraction def abs fraction inverse lemma fract den simp den fract simp add fract def den def fraction def abs fraction inverse lemma fraction cases cases type fraction fract proof assume fract obtain fract cases auto simp add fract def fraction def rule qed theory ring field imported bauer 

rational numbers lemma fraction induct induct type fraction fract cases simp equivalence fractions instantiate generic theory quotient types cf 
defining relation fractions appropriately 
properties equivalence relations proven turning type fraction instance equiv class 
instance fraction eqv 
defs overloaded equiv fraction def num den num den lemma equiv fraction iff fract fract simp add equiv fraction def lemma equiv intro fract fract insert equiv fraction iff blast lemma equiv dest fract fract insert equiv fraction iff blast instance fraction equiv proof fix fraction show proof induct fix int assume refl show fract fract 
qed assume show proof insert prems induct induct induct fix int assume assume fract fract eq 
assume fract fract eq 
proof cases assume eq eq auto thesis simp chapter 
example rational numbers assume eq eq simp simp ac show thesis simp qed fract fract 
qed show proof induct induct fix int assume assume fract fract 

fract fract 
qed qed lemma eq fraction iff fract fract simp add equiv fraction iff quot equality lemma eq intro fract fract insert eq fraction iff blast lemma eq dest fract fract insert eq fraction iff blast operations fractions define basic arithmetic operations fractions demonstrate congruence respect underlying equivalence relation 
happens trivial technical issue turns tedious part construction rational numbers 
careful pass basic operations fractions quotient construction unary unary inverse 
derived operations introduced rational numbers referring representation 
instance fraction zero 
instance fraction 
instance fraction plus 
instance fraction minus 
instance fraction times 
instance fraction inverse 

rational numbers defs overloaded zero fraction def fract fraction def fract add fraction def fract num den num den den den minus fraction def fract num den mult fraction def fract num num den den inverse fraction def inverse fract den num lemma zero fraction iff fract simp add zero fraction def eq fraction iff theorem add fraction cong fract fract fract fract fract fract fract fract proof assume neq assume fract fract eq 
assume fract fract eq 
fract fract proof show lhs rhs proof lhs simp add int distrib ac 
simp eq eq 
rhs simp add int distrib ac show thesis qed neq show simp neq show simp qed neq show thesis simp add add fraction def qed theorem minus fraction cong fract fract fract fract proof assume neq assume fract fract 
simp fract fract 
neq show thesis simp add minus fraction def qed chapter 
example rational numbers theorem mult fraction cong fract fract fract fract fract fract fract fract proof assume neq assume fract fract eq 
assume fract fract eq 
fract fract proof eq eq simp simp add ac neq show simp neq show simp qed neq show fract fract fract fract simp add mult fraction def qed theorem inverse fraction cong fract fract fract fract inverse fract inverse fract proof assume neq assume fract fract neq obtain simp add zero fraction iff assume fract fract 
simp ac fract fract 
neq show thesis simp add inverse fraction def qed rational numbers type rational numbers type rat represented abstraction universal set quotient elements fractions wrt 
equivalence relation introduced 
provide versions pick operations quotients called fraction rat respectively 
typedef rat rat univ fraction quot set 
lemma intro simp rat simp add rat def 
rational numbers fraction rat fraction fraction pick rep rat rat fraction rat rat abs rat theorem rat equality iff rat rat simp add rat def abs rat inject lemma rat rat rat 
canonical representation rational numbers fractional expressions form subsequently establish common equality rules eliminations 
fract int int rat rat fract theorem fract inverse fraction fract simp add fraction def rat def fract def abs rat inverse pick inverse theorem fract equality iff fract fract simp add fract def rat equality theorem eq rat simp add fract equality eq fraction iff theorem rat cases cases type rat proof assume obtain abs rat cases obtain cases obtain fract cases ultimately simp fract def rat def thesis rule qed theorem rat induct induct type rat cases simp canonical function definitions generic definitional principle quotient types transferred rational numbers follows 
full conditional version required inverse simple unconditional formulation sufficient 
chapter 
example rational numbers theorem rat cond function fraction fraction fraction fraction fract fract fract fract fract fract fract fract fract fract fract fract fract fract fract fract prop def prop cong proof assume eq prop def cong prop cong abs rat fract abs rat fract fract fract proof rule quot cond function fix assume eq show abs rat abs rat pick pick simp add fraction def pick inverse abs rat inverse fix fraction show induct induct induct induct rule cong qed thesis unfold fract def rat def qed theorem rat function fraction fraction fract fract fract fract fract fract fract fract fract fract proof case rule context truei show thesis rule rat cond function qed standard operations rational numbers ready provide complete collection arithmetic operations generic signature underlying class field bauer 
instance rat zero 
instance rat 
instance rat plus 
instance rat minus 
instance rat times 
instance rat inverse 
instance rat number 

rational numbers defs overloaded zero rat def rat rat def rat add rat def rat fraction fraction minus rat def rat fraction diff rat def rat mult rat def rat fraction fraction inverse rat def inverse rat inverse fraction divide rat def inverse rat theorem zero rat simp add zero rat def zero fraction def rat def fract def theorem rat simp add rat def fraction def rat def fract def theorem add rat proof rat fract fract rule rat function rule add rat def rule rat rule add fraction cong assume fract fract fract simp add add fraction def show thesis unfold fract def qed theorem minus rat proof rat fract rule rat function rule minus rat def rule rat rule minus fraction cong assume fract fract simp add minus fraction def show thesis unfold fract def qed theorem diff rat simp add diff rat def add rat minus rat theorem mult rat proof rat fract fract rule rat function rule mult rat def rule rat rule mult fraction cong assume fract fract fract simp add mult fraction def show thesis unfold fract def qed chapter 
example rational numbers theorem inverse rat inverse proof assume neq nonzero fract simp add zero rat eq rat zero fraction iff inverse fraction cong rat inverse rat inverse fract proof rule rat cond function fix assume cond fraction proof cases fix assume cond show thesis simp add fract inverse zero fraction iff zero rat eq rat qed inverse rat inverse fraction rule inverse rat def qed neq nonzero inverse fract fract simp add inverse fraction def show thesis unfold fract def qed theorem divide rat proof assume neq nonzero simp add zero rat eq rat neq nonzero show thesis simp add divide rat def inverse rat mult rat qed field rational numbers final instantiation type rat field imminent 
infrastructure offered general fields available rational numbers specific rules proof tools 
instance rat field proof fix rat show induct induct induct simp add add rat ac ac int distrib show induct induct simp add add rat ac ac show induct simp add zero rat add rat show induct simp add zero rat minus rat add rat eq rat 
discussion show induct induct simp add add rat minus rat diff rat show induct induct induct simp add mult rat ac show induct induct simp add mult rat ac show apply induct simp add rat mult rat show induct induct induct simp add add rat mult rat eq rat int distrib show inverse induct simp add inverse rat mult rat rat zero rat eq rat show inverse induct induct simp add mult rat divide rat inverse rat zero rat eq rat qed discussion isar techniques unusual calculations proof theorem quot cond function exhibits interesting example slightly unusual calculational sequence cf 
chapter 
basic calculations merely consist facts composed encounter number show statements linked ultimately 
pick pick proof rule cong show pick 
show pick 
show ultimately show pick pick simp qed proof body need establish sub problems contribute 
essentially overlapping threads reasoning connected calculational proof commands 
recall isar calculational elements independent particular way intermediate facts produced show works just plain far local result concerned 
chapter 
example rational numbers subsequent version proof basic flow information explicit explicit labeling facts 
pick pick proof rule cong show pick 
show pick 
show show pick pick simp qed form probably lucid wrt 
technical details slightly awkward due excessive naming statements 
situation bad may get rid label standard technique chaining cf 

pick pick proof rule cong show pick 
show pick 
show show pick pick simp qed apparently works reasonably original calculation short apply intermediate rules deferring equational composition ultimate result simplifier method step cf 

users isar prefer plain formulation neat calculational arrangement 
alternative formulation proceeds individual substitution steps text replacing simplifier method 
requires rearrangement order sub problems swap equational facts calculational sequence symmetric causes local result swapped version exported enclosing goal context affected 
pick pick proof rule cong show show symmetric pick 
show symmetric pick 
show pick pick qed achieve compact representation intertwined threads reasoning easily replaced plain forward chaining anymore 
hand form probably overly smart confuse readers unnecessarily 

discussion side conditions proven assumptions theory fractions inherently involves numerous side conditions denominators non zero 
essentially amounts subtyping keep proof texts implicit possible 
pvs owre treats additional constraints automatic virtue integrated system predicate subtypes provides reflection logical statements type system 
note pvs essentially untyped set theory augmented specific infrastructure treat particular kind subtyping scenes 
pvs usually marketed version higher order logic 
isabelle hol simply typed set theory original tradition hol gordon need take care additional constraints directly logic 
shall see works reasonably isar producing excessive formal noise text 
theory followed discipline put side conditions just main rule number main premises tend filled explicit forward chaining previous facts 
typical statement theorem inverse fraction cong cf 

theorem inverse fraction cong fract fract fract fract inverse fract inverse fract rule structured proof leaves marginal side conditions open sub problems solved 
cases just done assumption referring implicitly current context 
auxiliary facts emerge indirectly previous ones 
plain require result referenced explicitly may degenerate form obtain cf 
order acquire proven assumptions ready implicit 
proof inverse fraction cong illustrates immediate proven assumptions handle side conditions 
version modified text point implicit applications standard rules assumptions directly 
proof assume note neq assume fract fract neq obtain simp add zero fraction iff acquire proven assumptions assume fract fract rule eq rule rule apply standard rule solving side conditions assumption chapter 
example rational numbers simp ac fract fract rule eq rule rule apply standard rule solving side conditions assumption neq show thesis simp add inverse fraction def qed side conditions kind need treated application 
formal detail required level due virtue isar proof processing consider problem solved immediate assumptions cf 

discipline easily achieved due inherent structure isar proof texts local problems clearly delimited 
contrast unstructured proof scripts usually require trivial assumption steps explicitly user 
results cumbersome treatment numerous side conditions encountered example 
users tactic scripts probably demand separate proof tools specific situations 
representation proofs construction type rational numbers involves number representation proofs sense existing elements considered image certain functions domain expressed additional conditions 
obtain language element particularly suited kind reasoning 
theory development eventually arrives canonical representation fractional expressions cf 
theorems rat cases rat induct 
proof theorem rat cases particularly interesting involves complete hierarchy individual representations stemming hol typedef specifications contribute type rat 
consequently proof number obtain statements cf 
composed calculational elements cf 
chapter 
note rd occurrence obtain plays second role introducing proven assumption side condition covered implicitly final step 
theorem rat cases cases type rat proof assume obtain abs rat cases obtain cases obtain fract cases ultimately simp fract def rat def thesis rule qed 
discussion isar calculations kind facts perspective special obtain opposed note assume 
chapter 
contrast builtin concept iterated equalities mizar rudnicki trybulec muzalewski wiedijk quite exact format required 
particular mizar consider analogous isar obtain may complex proof patterns involving linking facts iterated equalities 
due isar flexible approach calculational reasoning able traverse nested representations type rat adequately structure abstracted version fraction quot cf 

results rational numbers directly derived scheme rat cases variant form rat induct induction rule format 
example proof field properties type rat involves number universal statements rational numbers 
form degenerate induction derived type rat reduce problem fractional expressions corresponding algebraic laws canonical representations established 
fix rat show induct induct induct simp add add rat ac ac int distrib give enlarged version kind reasoning reduced universal statements explicit text 
fix rat show proof induct induct induct fix int assume simp add add rat ac ac int distrib qed note instantiation proof class field conditional laws inverse operations depend ability induct handle non atomic statements properly cf 

show inverse occurs premise induct simp add inverse rat mult rat rat zero rat eq rat show inverse occurs premise induct induct simp add mult rat divide rat inverse rat zero rat eq rat isar generally supports non atomic statements uniform manner cf 

required notorious detour objectlevel connectives order able apply induction rules cf 
discussion induction isabelle proof scripts nipkow 
form induction degenerate additional overhead chapter 
example rational numbers approach representation proofs satisfactory additional formal noise dominating essentially trivial proof scheme 
hol techniques hol logic cf 
chapter chapter underlying isabelle hol working environment admits distinctive techniques inherent features system occur slightly peculiar sight 
may quite useful tackling recurrent issues formal logic applications simple manner 
focus type abstraction underspecification encountered formulation rational numbers 
types versus type abstraction abstraction certainly important issue kind formal specification environment 
general specifications adequate level abstraction possible 
overly concrete mathematical models may crowded irrelevant detail needs taken care formal proofs 
furthermore accidental properties specific representation may get exploited users intended writer specification 
effect philosophically may lead practical problems due lacking modularity theories 
hand extremely presentations mathematical ideas may quite far users expect place 
typical example issue categorical characterizations known mathematical concepts 
additional demand logical tools techniques highly presentations 
users versed techniques algebraic specification model theory probably request general theory mechanisms module systems powerful features category theory example 
readily available practically relevant logics hol cf 
chapter 
issue versus concrete specification techniques occasionally linked axiomatic versus definitional method exhibiting mathematical results 
principle strictly definitional approach easily lead unexpected facts holding resulting theory development 
common example classical mathematics untyped set theory definition natural numbers john von neumann mathematicians probably just choose ignore accidental properties set theory people creative features develop useful concepts ordinal numbers 
hol tradition strongly biased definitional approach cf 
plain mathematical modeling key specification technique 
appear sight notions data types 
discussion commonplace algebraic specification methods quite alien hol 
interestingly hol able reconcile definitional axiomatic methods proper inherent virtues 
key observation hol typedef mechanism cf 
involves inherent abstraction stage link existing representing set new type fully rep abs functions 
typedef acts type abstraction higher order programming languages abstype old ml 
example reconsider construction rational numbers concrete representation fractions pairs integers cf 

concrete mathematical model enabled derive intended properties idea rational numbers able exploit accidental properties concrete representation meaningful manner 
order see assume fully axiomatic presentation rational numbers hol 
clearly enables prove canonical presentation rational numbers terms fractional expressions cf 
rat cases may backwards primitive representations quotient elements concrete fractions essentially deriving characterization original typedef specifications theorem stating rep abs 
type definition rep abs cf 

note particular version typedef isabelle hol includes conservative stage introduced concrete constants naming bijections original type definition primitive hol formulation gordon melham pitts 
see hol provides way path type abstraction concrete mathematical structures back forth fully types 
unclear particular view hol type definitions considered important issue original designers cf 
historical account gordon 
due way hol types treated purely syntactic classification objects freedom left providing non trivial definitional mechanism types anyway 
particular notions convertibility equality types absent hol link existing types new ones need morphisms 
way identify elements different hol types directly 
far users hol concerned typedef primitive widely considered arcane directly applications 
important special case inductive datatypes widely available hol implementations cf 
overview berghofer wenzel users generally preferred concrete mathematical models general class tree structures 
certainly leads specifications necessary lists finite multisets association lists lists pairs finitary functions general relations 
isabelle isar example demonstrates hol type definitions may chapter 
example rational numbers get directly applications classical mathematics 
due highlevel characterization typedef rules cases induct format able keep formal noise reasonable level generic obtain element great help 
partiality versus underspecification recurrent issue formal specification undefined elements 
example rational numbers exhibits prominent instance undefinedness division zero 
people introduced elementary arithmetic usually mysterious explanations exact nature telling permitted divide zero 
established semi formal mathematics quite different traditions treating definedness issues expressions 
side conditions provided defined spelled explicitly 
occasionally encounters statements form idea rational number undefined case conclude general facts 
note formal representation second idea may achieved lifting basic types adjoining explicit error element contrast formal hol strongly biased totality sense syntactically formed type term denoting genuinely unspecified 
partial functions may easily represented lifting type option isabelle hol cf 
chapter see ller slind details treating partiality total setting 
general disadvantage modeling partiality explicitly needs handled formal proofs time 
operations total division rational numbers better avoid additional overhead 
consequently preferred plain type total hol functions theory inverse rat rat rat rat rat 
attempts reformulate basic ideas hol partiality mind lutins logic underlying imps farmer 
additional builtin support automated totality reasoning required turn basic idea class partiality practically useful environment 
system predicate subtypes pvs owre may get model partial functions 
definedness reasoning part builtin semi automated treatment type checking conditions tccs 
systems tradition dependent type theory coq barras usually treat case partiality including non zero property divisors type division operator 
theoretically clean demands additional efforts practical applications 
example definedness divisors needs essentially proven 
discussion able write expressions involving division cf 
experience reported geuvers 
main stream tradition hol informal concept partial functions usually avoided altogether just inventing suitable results undefined cases 
example forced yield 
gain useful algebraic properties hold unconditionally inverse inverse inverse inverse 
accidental properties quite useful simplified treatment specific proof tools cf 
related discussion field real numbers harrison 
established disciplines treating pseudo partiality hol involve hilbert choice operator cf 
applied empty predicate 
similar technique uses universal unspecified dummy elements arbitrary isabelle hol nipkow 
speaking terms standard hol pitts expressions denote fixed elements type completely unknown formal system 
prevents user include dummies logical reasoning basic facts arbitrary arbitrary certainly derivable logic 
may observe unwanted accidental results arising uncontrolled reasoning coinciding instances arbitrary expressions may appeared independent sight 
robust solution essentially require separate copy arbitrary occurrence specification text 
longterm experience arbitrary hol expressions shown tricks easily confuse recipients 
including features presentation non experts hol apt distract audience main issues quite time 
demonstrated application isar may achieve slightly cleaner treatment undefined expressions full accordance established hol traditions 
term undefined literally simply exclude certain unwanted cases definition total function achieving genuine underspecification explicit partiality 
idea expressed natively conditional definitions overloaded constants 
inverse rat def inverse rat inverse fraction divide rat def inverse rat special partial hol definitions cf 
conditional equations trivial instance notion conservative extensions employed basic framework cf 

form rarely encountered existing applications hol despite useful 
ruling pathological cases may sure accidental result involving specific treatment inverse 
hol remains faithful initial totality approach may derive instances universal algebraic laws chapter 
example rational numbers guaranteed rational number virtue syntactic type 
hand inverse inverse hold unconditionally derive specific case excluded definition 
arithmetic proof tools construction rational numbers fractions integers involves numerous instances basic arithmetic reasoning 
common technique handle incidents tweak isabelle simplifier order obvious local statements single step 
additional rewrite rules need specified limited builtin support integers arithmetic suffice 
example typical simp method invocations taken instantiation proof rat field cf 

simp add add rat ac ac int distrib simp add add rat ac ac simp add mult rat ac simp add add rat mult rat eq rat int distrib see relevant theorems rational numbers add rat mult rat get mixed basic arithmetic facts integers ac ac picked isabelle hol library ad hoc fashion 
situation slightly unsatisfactory especially wellknown semi decision procedures interesting classes arithmetic problems literature 
isabelle hol happens implement basic support restricted class linear arithmetic integers multiplication nipkow 
systems coq barras hol gordon melham pvs owre offer collection arithmetic procedures quite varying coverage specific problems 
pvs marketed particularly strong respect hol light harrison implements full arithmetic procedures integers presburger arithmetic closed field real numbers tarski 
case users interactive theorem proving systems routinely encounter frustrating situations builtin support arithmetic fails requiring particular cases proven hand 
principle encountered situation isabelle isar application times 
resulting proof text turns quite acceptable 
lack specific proof support affect basic structure proofs required detailed proof method specifications especially simp indicated prolonged number calculation chains demanding detailed steps 
essentially ability isar decompose failed atomic proof steps finegrained arrangements sub problems involving calculational reasoning compensated lack powerful arithmetic automated proof support 
discussion degree 
apparently high level isar proof elements able magnify strength underlying inference systems 
similar effect may experienced mizar rudnicki trybulec muzalewski wiedijk 
builtin notion obvious inferences rudnicki weak compared existing proof tools isabelle paulson nipkow pvs owre specific support arithmetic problems 
mizar users able develop large body classical mathematics mizar library including plenty standard issues arithmetic integers rationals reals frequently encountered technique long chains iterated equalities analogous isar calculations cf 
chapter 
apparently lack decent proof tools prevent useful done mizar virtue adequate means arrange tedium formal reasoning structured manner 
observation valid isar 
course powerful tools arithmetic problems useful support larger applications 
case isar framework able incorporate specific proof methods happen available tactic implementations underlying inference engine cf 

chapter 
example rational numbers chapter example unix security unix simple powerful operating system process file 
access system resources works mainly file system including special files devices unix security issues reflected directly file system 
give mathematical model main aspects unix file system including security model ignoring processes 
formal model discuss aspects unix security including odd effects caused general worse better approach followed unix 
resulting formal development demonstrates isabelle isar sufficiently flexible cover typical modeling verification tasks encountered computer science applications formal logic 
far mainly domain interactive theorem proving systems unstructured tactic languages 
motivation years tactical theorem proving systems hol gordon melham coq barras pvs owre isabelle paulson nipkow successfully applied sizable applications especially computer science involving modeling verification tasks 
example isabelle bali project bali oheimb provides extensive formalization aspects java programming environment covering java type system operational semantics axiomatic semantics 
applications kind heavily depend number characteristic techniques specification formal proof inductive definitions types sets relations recursive function definitions corresponding proof principles case analysis induction 
typically structures encountered chapter 
example unix security quite large constructors inductive cases necessarily deep respect mathematical concepts involved 
usual outcome person months person years body theory definitions plus large collection proof scripts 
widely accepted practice public presentation results involves extensive discussions definitional part including particular design decisions formalization actual formal proofs neglected 
strong tendency report size complexity proof scripts especially degree automation achieved collection proof tools available preferred theorem proving environment 
example java formalization oheimb consists lines definitions lines tactic scripts 
definitions included appendix document actual formal representation proof scripts 
inspecting real sources reveals proof scripts follow typical style advanced tactical proving heavy proof programming techniques operating sub problems time accommodating specific structures encountered formalization 
oheimb covers small synthetic example concrete java program verification part includes account technical complexity proof scripts important parameter usability java meta theory concrete applications 
contrast proofs meta theory covered 
marginal treatment formal proofs commonplace contemporary applications class interactive theorem proving systems considered 
systems keep proof scripts apart specification parts theory separate technical means 
example pvs owre holds statements theorems actual theory source proof scripts managed separately additional infrastructure lemma dependencies change management 
classic isabelle paulson nipkow keeps proof scripts separate ml files partly purely technical reasons overcome isabelle 
degrading proof scripts second class generally accepted experienced isabelle users natural order despite causing number practical cf 

contrast coq barras keeps definitions proof scripts input source reflecting intrinsic virtue type theory internally despite composed different technical means immediate terms versus incremental tactic applications 
original lcf hol tradition gordon treats definitions proofs uniformly ml programs restricted applications certain standard functions 
deeper cause general disregard actual proofs common applications mainstream formal reasoning systems may essentially twofold 
hand existing tactical theorem proving systems provide means express proofs human readable way place 
hand people develop systems consider readable proofs unimportant content formal accounts 
motivation machine 
certainly aspects depend existing systems just happen evolved support particular proof mode operation happen support particular range applications reasonable manner 
explain applications traditional mathematics encountered area 
interestingly large body standard analysis developed harrison mainly serves auxiliary theory program verification issues 
contrast mizar system rudnicki trybulec muzalewski wiedijk able support large library formalized mathematics mizar library approximately mb sources organized articles developed decades 
successful case machine checked proof developments accessible human consumption probably draws established practice mainstream mathematics real proofs lightly 
isar perspective key question raised case inclusion actual formal proofs may extended pure logic chapter chapter classical mathematics chapter computer science applications involving modeling verification mainly domain existing tactical systems 
shall non trivial formal development completely definitions formal proofs 
particular proof texts may stand shall refrain reporting accidental technical properties degree automation achieved 
important question exposing real proofs audience computer science applications sense 
certainly badly written proofs better excluded general public coverage 
hand lucid formal expositions may greatly benefit widely accepted viable account achieved help conduct similar advanced applications formal logic 
indication particular area applied logic excluded free flow ideas techniques 
really want prevent relevant formal developments treated black boxes disclosed public view need suitable means resulting developments accessible human consumption 
human readable proofs encountered computer science applications 
mizar library includes number articles qualify belong domain meta theory classical order logic articles petri nets articles articles small computer model scm theoretical results concrete example programs including correctness proofs 
certainly examples compared remaining body classical mathematics formalized mizar 
furthermore mizar designed closed system particular domain standard mathematical applications way introduce new definitional chapter 
example unix security mechanisms specialized proof tools verification tasks turn slightly cumbersome performing inductive constructions manually primitive conducting routine proofs pages small technical reasoning steps example 
declare syme syme syme designed specific system declarative theorem proving syntax semantics formal languages place 
system evaluated example development java type soundness syme syme 
key difference isabelle isar fixed application domain grown cover broad range tradition generic theorem proving isabelle framework paulson paulson paulson nipkow extending upper levels human readable proof texts 
providing number general principles may combined ways able cover range applications formal reasoning systems including primitive logic just advanced modeling verification problems encountered computer science 
certainly isabelle isar system open areas explored creative users 
subsequent development aspects unix file system security essentially demands advanced isar techniques covered chapter chapter 
need really stretch system far larger applications performed quite easily 
see isabelle klein consists structured proof texts includes numerous old theories unreadable proof scripts 
unix philosophy decades unix community collected certain amount folklore wisdom building systems see unix heritage society pdp unix preservation society background information 
account philosophical principles unix way software systems engineering appeared slashdot com march 
unix philosophy score insightful saturday march am est user info philosophy result years software development grown unix community enforced 
defacto style software development 
major tenets unix philosophy 
small beautiful 

program thing 
build prototype soon possible 
choose portability efficiency 
store numerical data flat files 
software leverage advantage 
shell scripts increase leverage portability 
avoid captive user interfaces 
program filter lesser tenets 
allow user tailor environment 
operating system kernels small lightweight 
lower case keep short 
save trees 
silence golden 
think parallel 
sum parts greater 
look percent solution 
worse better 
think hierarchically worse better approach quoted particularly interesting 
basically means relevant concepts implemented right way irrelevant issues simply ignored order avoid unnecessary complication design implementation 
certainly quality resulting system heavily depends virtue distinction categories relevant irrelevant 
unix security main entities unix system files processes tanenbaum 
files subsume persistent static entity managed system ranging plain files directories special ones device nodes pipes sockets hand processes dynamic entities may perform certain operations run system 
security model classic unix systems centered file system 
operations permitted process run certain user determined information stored file system 
includes kind access control read write access plain file read access certain global device node proper arrangement main unix file system critical security 
deeper reason operation mounting new volumes existing file space usually restricted super user 
generally speaking unix security model simplistic 
original designers maximum security mind wanted get decent system working typical multi user environments 
contemporary unix implementations follow basic security model original versions early ritchie thompson 
back chapter 
example unix security better approaches available albeit complexity involved implementers users 
hand computer systems run little file system security virtually system exposed net 
personal computer systems long left comfortable home environment entered wilderness open net sphere 
treatment file system security typical example worse principle introduced 
simplistic security model unix got widely accepted large user community innovative cumbersome ones tend disabled default order avoid confusion beginners 
odd effects simplistic systems usually typical situations tend exhibit odd features atypical ones 
far unix file system security concerned features known experts may surprise users 
subsequently consider example exotic 
may easily experienced running unix system sequence commands may put user file system state 
assume user user working directory home user 
user mkdir foo user mkdir foo bar user touch foo bar baz user creates directory writable user puts non empty directory write access 
situation impossible user remove directory foo cooperation user foo contains nonempty non writable directory removed just 
user rmdir foo rmdir directory foo directory empty user rmdir foo bar rmdir directory bar directory empty user rm foo bar baz rm removed permission denied user cleaned directory bar user enabled remove foo bar foo 
alternatively user remove foo bar 
unfortunate case user cooperate happens temporarily unavailable user find super user root clean 
unix file systems situation 
unix root may perform file system operation access control limitations 
typical unix way handling abnormal situations easy run odd cases due simplistic policies quite easy get 
known systems somewhat harder get trouble impossible escape 
really escape user 
experiments show possible ways demonstrate absence means exhaustively 
typical situation formal proof may help 
subsequently model main aspects unix file system security isabelle hol environment cf 
chapter prove way user get rid directory foo help see main theorem stating 
unix file systems theory unix nested environment list prefix give simple mathematical model basic structures underlying unix file system fundamental operations imagined performed internally unix kernel 
forms basis set unix system calls introduced see actual interface offered processes running user space 
basically unix file plain file directory consisting content plus attributes 
content plain file plain text 
content directory mapping names files 
fact way names get associated files 
unix files name 
number names may associated file due hard links handled model 
attributes include information control various ways access file read write 
model quite liberal omitting excessive detail easily seen irrelevant aspects unix file systems discussed 
ignore character block special files pipes sockets hard links symbolic links mount points 
names user ids file name components shall represented natural numbers loss generality 
bother encoding actual names strings mapping user names user ids reality 
theories nested environment list prefix included bauer 
chapter 
example unix security types uid nat name nat path name list attributes unix file attributes mainly consist owner information permission bits control access user group see unix man pages chmod stat details 
model file permissions considers part 
user field may omitted loss generality security point view owner usually able change anyway performing chmod 
omit group permissions genuine simplification just intend discuss model multiple groups group membership pretend member single global group 
general hol model user group structures 
datatype perm readable writable executable ignored types perms perm set record att owner uid perms plain files readable writable specify read write access actual content string text stored 
directories readable determines set entry names may accessed writable controls ability create delete entries plain files sub directories 
simplification ignore executable permission altogether 
reality indicate executable plain files known binaries control actual retrieval directory entries recall mere directory browsing controlled readable 
note means order perform file system operation whatsoever directories encountered path executable 
ignore detail pretend directories give executable permission anybody usually case real world file systems anyway 
files order model general tree structure unix file system arbitrarily branching datatype env supplemental library 
unix file systems isabelle hol bauer theory nested environment 
type provides constructors val env follows val env env env option env parameter refers basic information occurring leaf positions parameter information kept inner branch nodes parameter index type tree structure 
purpose type instance att string representing plain files att attributes directory nodes name index type directory nodes 
types file att string att name env theory provides lookup update operations general tree structures subsequent primitive recursive characterizations 
lookup env list env option update list env option env env lookup env xs case xs env xs case env val env es case es lookup xs update xs opt env case xs case opt env xs case env val val env es case xs env es opt ys env es case es update ys opt basic properties operations proven theory 
routinely notice 
apparently elements type file contain att component case 
subsequently define auxiliary operations manipulate field uniformly conventions record types isabelle hol cf 

attributes file att attributes file case file chapter 
example unix security val att text att env att dir att attributes update att file file attributes update att file case file val att text val att text env att dir env att dir lemma simp attributes val att text att simp add attributes def lemma simp attributes env att dir att simp add attributes def lemma simp val att text attributes att val att text simp add attributes update def lemma simp env att dir attributes att env att dir simp add attributes update def lemma simp attributes file attributes att att cases file simp add attributes def split tupled initial file systems set known users file system shall initialized providing empty home directory user read access everybody 
note may directly user id home directory name types identified 
certainly root directory owned super user user id 
init uid set file init users env owner readable users env owner readable empty accessing file systems main internal file system operation access file user requesting certain set permissions 
resulting file option indicates file corresponding path access granted permissions recorded file system 
note rules unix file system security cf 
tanenbaum simplifications outlined super user owner may access file unconditionally 

file system transitions access file path uid perms file option access root path uid perms case lookup root path file uid uid owner attributes file perms attributes file file successful access certain file main prerequisite system calls applicable see 
modification file system performed basic update operation nested environment type 
apparently access just wrapper basic lookup function additional checking attributes 
subsequently establish auxiliary facts stem primitive lookup access 
notion independent paths defined theory list prefix bauer 
lemma access empty lookup access root path uid lookup root path simp add access def split option splits lemma access lookup access root path uid perms file lookup root path file simp add access def split option splits splits lemma access update path path access update path opt root path uid perms access root path uid perms proof assume path path obtain xs ys zs path xs ys path xs zs blast dest parallel decomp lookup update path opt root path lookup root path blast intro lookup update thesis simp access def qed file system transitions unix system calls established operating system design cf 
tanenbaum user space processes may initiate system operations fixed set 
principle enables kernel enforce certain security policies chapter 
example unix security place 
essentially idea employed lcf style theorem proving systems milner principle correctness construction isabelle 
model unix give fixed datatype operation syntax relation file system state transitions root root operational semantics introduced 
datatype operation read uid string path write uid string path chmod uid perms path creat uid perms path unlink uid path mkdir uid perms path rmdir uid path readdir uid name set path uid field operation corresponds effective user id underlying process model mentions processes explicitly 
parameters provided arguments caller path common kinds system calls 
consts uid operation uid primrec uid read uid text path uid uid write uid text path uid uid chmod uid perms path uid uid creat uid perms path uid uid unlink uid path uid uid mkdir uid path perms uid uid rmdir uid path uid uid readdir uid names path uid consts path operation path primrec path read uid text path path path write uid text path path path chmod uid perms path path path creat uid perms path path path unlink uid path path path mkdir uid perms path path path rmdir uid path path path readdir uid names path path note omitted explicit open close operations pretending 
file system transitions read write take care scenes 
basically treated sequences real system calls open read write close atomic transactions 
principle simplification big difference model explicit concurrent processes 
hand real unix system exact scheduling concurrent open close operations directly affect success corresponding read write 
unix allows processes files opened time writing ritchie thompson 
certainly result reading contents may hard predict system calls involved succeed unconditionally 
operational semantics system calls specified transitions file system configuration 
expressed inductive relation recursion involved 
consts transition file operation file set syntax transition file operation file bool translations root root root root transition inductive transition intros read access root path uid readable val att text root read uid text path root write access root path uid writable val att text root write uid text path update path val att text root chmod access root path uid file uid uid owner attributes file root chmod uid perms path update path file attributes attributes file perms root creat path parent path name access root parent path uid writable env att parent access root path uid root creat uid perms path update path val owner uid perms root chapter 
example unix security unlink path parent path name access root parent path uid writable env att parent access root path uid val plain root unlink uid path update path root mkdir path parent path name access root parent path uid writable env att parent access root path uid root mkdir uid perms path update path env owner uid perms empty root rmdir path parent path name access root parent path uid writable env att parent access root path uid env att empty root rmdir uid path update path root readdir access root path uid readable env att dir names dom dir root readdir uid names path root specification central formal development 
results established meaningful outside world transition system provides adequate model real unix systems 
kind reality check formal model known problem validation 
case doubt may consider compare definition informal specifications corresponding unix man pages inspect sources real implementation torvalds 
common way gain confidence formal model run simple simulations see compare results experiments performed running unix system example 
basic properties single transitions transition system root root defined determines unique result root root holds trivially clause operation 
uniqueness statement simplify subsequent development extent reason partial function general relation 
theorem transition uniq root root root root root root proof assume root root root assume root root 
file system transitions thesis proof cases case read root show thesis cases auto case write root show thesis cases auto case chmod root show thesis cases auto case creat root show thesis cases auto case unlink root show thesis cases auto case mkdir root show thesis cases auto case rmdir root show thesis cases auto case readdir root show thesis cases auto qed qed apparently file system transitions type safe sense result transforming actual directory yields directory 
theorem transition type safe root root att dir 
root env att dir att dir 
root env att dir proof assume tr root root assume inv att dir 
root env att dir show thesis proof cases path case nil tr inv show thesis cases auto simp add access def split splits case cons tr obtain opt root root root update path opt root cases auto chapter 
example unix security inv cons show thesis auto simp add update eq split list splits qed qed previous result may seen basic invariant file system state enforced proper unix kernel implementation 
user processes bound system call interface may mess file system root plain file directory odd configuration file system 
iterated transitions iterated file system transitions finite sequences system operations modeled inductively follows 
consts transitions file operation list file set syntax transitions file operation list file bool translations root xs root root xs root transitions inductive transitions intros nil root root cons root root root xs root root xs root sense relation describes cumulative effect sequence issued set running processes finite number run time steps 
establish basic facts relating iterated transitions single ones recursive structure lists 
lemma transitions nil eq root root root root proof assume root root root root cases simp assume root root root root simp transitions nil qed lemma transitions cons eq root xs root root root root root xs root proof 
file system transitions assume root xs root root root root root xs root cases auto assume root root root root xs root root xs root blast intro transitions cons qed rules show destruct known transition sequences 
note second relies uniqueness property basic transition system cf 

lemma transitions root root root root simp add transitions nil eq lemma transitions root xs root root root root xs root proof assume root xs root obtain root root xs root cases simp assume root root root rule transition uniq root show root xs root simp qed fact shows invariant single transitions satisfying may transferred iterated transitions 
proof obvious rule induction definition root xs root lemma transitions invariant root xs root root set xs 
root proof assume assume root xs root root set xs 
root prop root xs root proof induct root xs root fix root assume root root fix root root root xs assume root root root assume hyp prop root xs root assume root assume set xs 
chapter 
example unix security simp root root rule set xs 
simp ultimately show root rule hyp qed qed basic application previous result transfer type safety property single transitions iterated ones 
theorem transitions type safe root xs root att dir 
root env att dir att dir 
root env att dir proof case rule context transition type safe show thesis proof rule transitions invariant show set xs 
true blast qed qed executable sequences inductively defined relation root root cf 
main aspects 
resulting system admits certain set transition rules introductions specification 
secondly fixed point construction involved results induction case analysis rules eliminate known transitions exhaustively 
subsequently explore transition system experimental manner mainly rules basic algebraic properties underlying structures 
technique closely resembles logic programming combined functional evaluation simple manner 
just closed world assumption left implicit logic programming refer induction transition system 
positive reasoning possible executions exhaustive reasoning employed see shall demonstrate certain behavior possible 
possible transitions obviously list system operations executed certain state result state reached iterated transition 
exec file operation list bool exec root xs root root xs root 
executable sequences lemma exec nil exec root unfold exec def blast intro transitions intros lemma exec cons root root exec root xs exec root xs unfold exec def blast intro transitions intros case know sequence executed may destruct backwards individual transitions 
lemma exec root 
exec root xs root root root xs root root root prop xs root 
root xs root xs proof induct xs fix root assume root root simp add exec def transitions nil eq transitions cons eq fix xs assume hyp prop xs assume asm root xs show root xs proof asm obtain root root xs xs root auto simp add exec def transitions nil eq transitions cons eq xs hyp obtain root xs xs root root unfold exec def blast xs root xs root rule transitions cons show thesis blast qed qed example executions ready perform experiments formal model unix system calls 
common technique alternate rules transition system steps solve emerging side conditions algebraic properties underlying file system structures 
note constitute real proof essentially performs symbolic evaluation logical environment 
lemmas eval access def init def chapter 
example unix security theorem users exec init users mkdir perms name apply rule exec cons back chain exec cons apply rule mkdir back chain mkdir apply force simp add eval solve preconditions mkdir apply simp add eval peek normalized result optional 
users exec env owner readable users env owner readable empty env owner readable empty name env owner perms empty apply rule exec nil back chain exec nil done inspecting result shown just final step may gain confidence specification unix system calls sense 
common errors usually exhibited preconditions transition rules fail unexpectedly 
additional experiments techniques 
theorem users exec init users creat perms name unlink name apply rule exec cons apply rule creat apply force simp add eval apply simp add eval apply rule exec cons apply rule unlink apply force simp add eval apply simp add eval peek result 
users exec 
executable sequences env owner readable users env owner readable empty env owner readable empty apply rule exec nil done theorem users writable perms readable perms name name exec init users mkdir perms name mkdir perms name name creat perms name name name creat perms name name name readdir name name name name apply rule exec cons rule transition intros force simp add eval simp add eval peek result 
users writable perms readable perms name name exec env owner readable users env owner readable empty env owner readable empty name env owner perms empty name env owner perms empty name val owner perms name val owner perms apply rule exec nil done theorem users writable perms readable perms exec init users mkdir perms name mkdir perms name name chapter 
example unix security creat perms name name name write foo name name name read foo name name name apply rule exec cons rule transition intros force simp add eval simp add eval peek result 
users writable perms readable perms exec env owner readable users env owner readable empty env owner readable empty name env owner perms empty name env owner perms empty name val owner perms foo apply rule exec nil done odd effects treated formally ready give completely formal treatment odd situation discussed file system may reach state user unable remove directory populated items placed user manner 
general procedure theorem expresses general procedure achieve main result 
theorem general procedure false root 
init users bs root root init users bs root xs 
set xs 
exec root xs proof assume false 
odd effects treated formally assume init inv root 
init users bs root root assume preserve inv assume init result init users bs root fix xs assume ps set xs 
assume exec exec root xs obtain root root xs root xs root root root blast dest exec init result root rule init inv preserve inv xs ps root rule transitions invariant false rule thesis blast qed refers restriction file system operations admitted having reached critical configuration problem specification uid user 
furthermore refers operations claim impossible perform rmdir 
suitable auxiliary invariant file system reaching critical configuration choosing adequately important proof see 
particular setup introduce global declarations axioms describe particular setup considered 
avoid excessive local parameters subsequent development 
consts users uid set user uid user uid name name name name name name perms perms perms perms axioms user known user users user root user users neq user user chapter 
example unix security perms writable writable perms perms writable writable perms lemmas setup user known user root users neq perms writable perms writable bogus operations ones lead situation described bogus path key position file system things go 
bogus operation list bogus mkdir user perms user name mkdir user perms user name name creat user perms user name name name bogus path path bogus path user name name invariance lemmas invariant root file system describes bogus situation manner located certain path home directory user non empty directory owned writable user 
invariant file path bool invariant root path att dir 
access root path user env att dir dir empty user owner att access root path user writable general procedure cf 
establish key lemmas required yield final result 

invariant sufficiently strong entail pathological case user unable remove owned directory user name 

invariant hold having executed bogus list operations starting initial file system configuration 

invariant preserved file system operation performed user help users 
invariant appears assumption course reasoning formulation critical development 
odd effects treated formally properly 
particular third step sensitive invariant strong weak 
statement sufficiently lest proof cluttered confusing detail 
lemmas straight forward just inspect special cases 
lemma rmdir invariant root bogus path root rmdir user user name root false proof assume invariant root bogus path obtain file access root bogus path user file unfold invariant def blast assume root rmdir user user name root obtain att access root user name user env att empty cases auto access root user name name user simp access empty lookup lookup append simp ultimately show false simp add bogus path def qed subsequently techniques symbolic evaluation encountered 
lemma init invariant init users bogus root invariant root bogus path proof note eval setup access def init def case rule context thesis apply unfold bogus def bogus path def apply transitions rule transition intros force simp add eval simp add eval evaluate operations apply transitions reach final result apply simp add invariant def eval check invariant done qed left main effort show invariant preserved file system operation root root performed user 
note holds path particular bogus path required 
lemma preserve invariant root root invariant root path uid user invariant root path chapter 
example unix security proof assume tr root root assume inv invariant root path assume uid uid user inv obtain att dir inv access root path user env att dir inv dir empty inv user owner att inv access root path user writable auto simp add invariant def inv lookup lookup root path env att dir simp access empty lookup inv inv inv user root writable writable att auto simp add access def split option splits splits show thesis proof cases assume root root inv show invariant root path simp assume changed root root tr obtain opt root root update path opt root cases auto show thesis proof rule prefix cases assume path path inv root perms 
access root path user perms access root path user perms simp access update inv show invariant root path simp invariant def assume path path obtain ys path path path ys 
show thesis proof cases ys assume ys tr uid inv inv lookup changed path user root false cases auto simp add access empty lookup dest access lookup thesis 
fix zs assume ys ys zs lookup root path lookup root path proof 
odd effects treated formally inv lookup path ys look lookup root path zs env att dir simp obtain att dir file look lookup root path env att dir dir dir file file lookup file zs env att dir blast dest lookup upper tr uid changed look dir obtain att look lookup root path env att dir cases auto simp add access empty lookup lookup update dest access lookup dir file lookup root path zs env att dir simp add lookup append look path ys show thesis simp qed inv show invariant root path simp invariant def access def qed assume path path obtain ys path path path ys 
obtain dir lookup lookup root path env att dir inv dir empty proof cases ys assume ys path parent path path simp tr uid inv changed obtain file root update path file root cases auto lookup parent lookup root path env att dir file simp update append update cons nil env dir file empty simp ultimately show thesis 
fix zs assume ys ys zs lookup root path lookup root path update ys opt env att dir simp update append obtain file update ys opt env att dir env att dir file proof dir proof dir lookup env att dir chapter 
example unix security simp split option splits lookup 
lookup root path simp lookup append 
proof ys obtain rev ys ys cases ys rule rev cases auto tr path lookup root path lookup root path cases auto dest access lookup thesis blast dest lookup append qed show thesis qed ys show thesis insert auto simp add update cons cons env qed dir file empty simp ultimately show thesis 
qed lookup inv access root path user env att dir simp access empty lookup inv lookup writable user root access root path user writable simp add access def inv inv inv show thesis unfold invariant def blast qed qed qed putting main result imminent just composing invariance lemmas procedure 
theorem main init users bogus root xs 
set xs 
uid user exec root xs rmdir user user name proof case rule context rmdir init invariant preserve invariant show thesis rule general procedure qed 
discussion discussion isar techniques isabelle isar application routinely uses advanced techniques discussed chapter chapter 
reconsider number notable instances advanced proof patterns encountered body text 
structured treatment numerous cases proof theorem transition uniq proceeds canonical independent transitions root root root root essentially arrive quadratic number sub problems stemming individual inductive cases transition 
nested case analysis arranged proof text performing outer backwards decomposition proof cases laying resulting sub problems symbolic case names term abbreviations cf 
individual sub problem acquires additional premises stemming original inductive definition included case analysis cases auto initial cases step splits new sub problems elimination root fact terminal auto solves uniformly remaining facts previous case 
theorem transition uniq root root root root root root proof assume root root root assume root root thesis proof cases case read root show thesis cases auto case write root show thesis cases auto apparently able express pattern reasoning quite succinctly isar text covering structure proof main statements facts indication specific proof steps 
due general compositional nature isar proofs scheme may easily refined details sub proofs appropriate special treatment obvious cases complex applications 
contrast certainly produce shorter script achieves operational behavior cost usual disadvantages chapter 
example unix security unstructured proof techniques 
particular modular treatment subproblems lost detailed analysis individual cases debugging failed intermediate steps quickly serious effort 
theorem transition uniq root root root root root root transition cases transition cases auto covering cases proof theorem transition type safe exhibits different view case analysis 
superficial structure cases original inductive definition root root naively discriminate syntactic structure path parameter inspect transition 
theorem transition type safe root root att dir 
root env att dir att dir 
root env att dir proof assume tr root root assume inv att dir 
root env att dir show thesis proof cases path point achieve separate cases nil cons eventually finished similar manner performing inductive case analysis deferred far solving remaining problems automatically 
case nil tr inv show thesis cases auto simp add access def split splits case cons tr obtain opt root root root update path opt root cases auto inv cons show thesis auto simp add update eq split list splits nil case bas trivial cons requires care relevant observation inductive cases exhibited intermediate obtain statement cf 
manner 
note new existential parameters quite typical kind application plain sufficient 
qed qed apparently pattern initial discrimination plus covering cases intermediate fact obtain achieves substantial reduction volume proof text need spell separate cases 

discussion characterization particular situation encountered contributes general understanding main point proof 
contrast naive nested case splitting start easily lead large number sub problems need accommodated separate proofs 
unstructured scripts situations typically covered heavy tactic combinators operate similar goals simultaneously extensive tweaking automated methods particular sub problems uniformly 
lose structural clarity require additional efforts mastering automated tools usually requiring proof processing time 
suitable abstractions cases need provided writer isar proof texts course 
hand basic setup usually quite easy explore possible intermediate results interactively 
typically proceed inspecting remaining dynamic proof state having issued cases auto method invocations separately replacing proofs apply commands temporarily 
certainly phase interactive exploration eventually finished turning dynamic evolution proof problems static text 
example large number accidental sub problems captured simple statements logic technique somewhat dependent particular formalization problem expressive power underlying language 
simply typed set theory isabelle hol cf 
chapter reach quite far practice unlimited 
animation logical objects example executions existing inference engine isabelle animate specification set file system transitions 
basic idea treat rules inductive definition prolog program solve emerging side conditions means functional simplification involved advanced isabelle proof methods cf 

theorem users exec init users mkdir perms name apply rule exec cons apply rule mkdir apply force simp add eval apply simp add eval apply rule exec nil done certainly pattern quite far systematic combinations logical functional programming techniques main control left user giving suitable operational proof script 
due footing basic inference tools isabelle kind chapter 
example unix security tal evaluation specifications particularly fast 
example takes reasonably fast machine see 
hand nice simple tools experimentation available system demanding efforts maintain link real programming language environments 
usually involve slightly awkward restrictions strictly executable specifications 
note specification includes infinitary elements unlimited sets users unrestricted mappings names sub directories 
despite real logical inferences inside point kind symbolic evaluation actual isar proof text 
proof performed primitive level accidental 
apparently improper proof commands apply done cf 
may proper structured formal developments isabelle isar 
global declarations entering concrete description odd situation introduced declarations consts axioms global theory level 
consts users uid set user uid user uid name name name name name name perms perms perms perms axioms user known user users user root user users neq user user perms writable writable perms perms writable writable perms fixes particular context results issued 
purely axiomatic extension certainly violates hol paradigm 
hand easy see axioms satisfiable extension turns conservative cf 
fact established outside formal system 
main intention global declarations keep subsequent statements free additional parameters assumptions 
mean introduce existential context universal 
usually accepted fall back plain axioms situations 
discussion slightly comfortable explicit mechanism manage separate contexts theory level succinctly 
concept locales kamm ller achieves exactly classic isabelle similar concept sections coq barras 
unfortunately locales ported isabelle isar theory format quite trivial 
morally consider consts axioms canonical application locales raw axiomatic theory extension 
local declarations proof scripts example proof scripts achieve symbolic evaluation concrete representations unix file system structures 
despite inherently unstructured proof scripts occasionally demand local declarations usually tune behavior proof methods 
due compositional nature isar proof language may easily wrap scripts degenerate proof structures order provide local context private declarations 
evaluation script lemma init invariant uses automatic bindings case antecedent term thesis initial rule statement locally duplicating text 
lemma init invariant init users bogus root invariant root bogus path proof note eval setup access def init def case rule context thesis local declarations just merely note bind facts locally 
note traditional isabelle tactic scripts auxiliary items usually put global theory context 
advanced existential reasoning proof main invariance lemma preserve invariant exhibits number interesting techniques including non trivial pattern reasoning lines existential quantification hidden definition invariant root path obtain element manage complete proof mentioning quantifiers explicitly 
lemma preserve invariant root root invariant root path uid user invariant root path proof assume tr root root assume inv invariant root path assume uid uid user chapter 
example unix security initially eliminate existential content invariant root path exhibiting witness elements directly proof text decompose inherently conjunctive statement individual facts cf 

inv obtain att dir inv access root path user env att dir inv dir empty inv user owner att inv access root path user writable auto simp add invariant def main proof proceeds producing primed versions inv 
inv accommodate ultimate invariant root path 
note inv coincides inv inv labeled explicitly directly emerges near proof 
inv lookup writable user root access root path user writable simp add access def inv inv inv show thesis unfold invariant def blast facts explicit witness elements easily get main result having isabelle tableau prover blast cf 
details conjunction existential 
qed qed qed abstraction explicit statements common technique encountered proof preserve invariant reducing conceptual technical complexity proof inserting abstractions explicit intermediate statements 
certainly obvious thing serious proof albeit established practice unstructured tactical proving tends proceed way decomposing statements increasingly large amount simpler propositions emitted dynamically 
including appropriate statements writer isar proof texts enabled keep complexity control 
shall indicate notable instances simplifications achieved additional isar proof structure suitable local facts 
lemma preserve invariant root root invariant root path uid user invariant root path proof 
discussion show thesis proof cases point discriminate root root 
case achieves main result directly 
case provides useful additional assumption changed root root immediately obtain view inductive cases tr root root occurrences changed encountered 
assume root root inv show invariant root path simp assume changed root root tr obtain opt root root update path opt root cases auto establish resulting invariant fairly trivial case equal access current path arbitrary permissions 
claiming local rule statement universal parameter perms spare consider concrete instances writable separately 
perms 
access root path user perms access root path user perms simp access update inv show invariant root path simp invariant def provide view inductive cases fact tr root root due specific situation plain disjunctive statement sufficient example existential parameters obtained 
tr path lookup root path lookup root path cases auto dest access lookup efficiency isabelle isar proof processing resource requirements isar proof processing discussed far basically issue internal bookkeeping isar vm interpreter 
operations encountered performed quickly practical applications despite theoretical complexity higher order unification paulson involved basic proof steps isar qed claim issued show 
chapter 
example unix security run time basic isabelle isar applications chapter chapter chapter usually limited seconds theory 
interactive development user agent process proof general typically requires slightly time manage source buffer display prover output main isabelle process 
complex applications considerable amount run time spent terminal proof steps involving automated methods blast auto force cf 

resources required advanced definitions inductive datatype cf 

consequently processing time theories may approach range minutes mere seconds 
order give precise account isabelle isar run time encountered reality fix platform amd cpu mhz mb main memory mhz linux kernel poly ml compiler run time system isabelle 
timings refer clean isabelle proof processing quick dirty mode get skip number internal proofs especially advanced definitional packages berghofer wenzel 
isabelle session consists number theories loaded addition main hol image contains collection basic concepts cf 
chapter 
unix session includes additional theories bauer 
run times follows 
list prefix nested environment unix long theories library static additional overhead loading demand really matter theories need loaded interactive session 
hand advanced applications typically consist number interdependent theories right 
development user needs switch back forth different parts dag structure usually demanding frequent reloading individual theory nodes 
fact theory nested environment started genuine part unix session moved generic library 
case isabelle isar system automatically takes care reload changed theories required ensures consistent view sources managed user agent proof general 
hand specific support avoid costly replays individual proofs happen independent changes 
processing time theory nodes gets seconds situation easily hindrance development large applications 
see related discussion fundamental theorem algebra project geuvers performed coq barras 
size complexity applications natural limits perceived performance proof processing batch mode interactive development 
unix example considerably level 
discussion serious concerns 
focus individual proofs single theory unix 
substantial amount run time spent scripts symbolic evaluation examples lemma init invariant 
evaluation example evaluation example evaluation example evaluation example lemma init invariant enormous run times seemingly small problems usually caused relatively large goal states need treated simplification involving multitude different cases stem syntactic structure datatype elements 
isabelle simplifier appears particularly slow conjunction particular kind case splitting 
coq barras highly tuned builtin notion reduction perform slightly better coq number performance issues symbolic evaluation cf 
experience reported geuvers 
actual isar proof texts encountered theory unix fairly small negligible resource requirements add seconds total apart large proof lemma preserve invariant requires 
expected substantial part time spent terminal proof steps involving automated proof methods indicate contributing 
lemma preserve invariant root root invariant root path uid user invariant root path proof tr obtain opt root root update path opt root cases auto tr uid inv inv lookup changed path user root false cases auto simp add access empty lookup dest access lookup tr uid changed look dir obtain att look lookup root path env att dir chapter 
example unix security qed cases auto simp add access empty lookup lookup update dest access lookup tr uid inv changed obtain file root update path file root cases auto tr path lookup root path lookup root path cases auto dest access lookup get distribution run time lemma preserve invariant 
step step step step step remaining commands total proof obligations encountered hot spots indicated structurally quite similar initial split inductive cases stemming file system transition relation remaining sub problems solved auto cf 
involves simplification case splitting syntactic structure datatype elements 
proof problems close slow symbolic evaluations encountered 
run time behavior isar proof text fairly 
detailed analysis remaining reveals virtually penalty overhead structured proof processing isar vm interpreter cf 
run time resources completely available primitive inference engine isar level 
essentially goal viable operating system design strive achieve additional structures policies required provide high level abstractions top primitive system resources substantial portion resources 
example operating system typically require cpu time internal bookkeeping available run user space processes 
isar proof processing 
discussion achieves similar ratio run time resources left primitive steps performed inside advanced proof methods 
performance processing structured isar proof texts usually better unstructured isabelle proof scripts 
typical tactic scripts consist large number method invocations operating single unstructured goal state existing subgoals get broken simpler larger ones solved eventually new goals emerge inheriting context previous ones 
consequence goal states arising individual tactic applications tend consist lot redundant information accumulated time 
advanced proof tools need take care contribute result achieved 
contrast nicely structured isar proof texts usually state number local problems may tackled automated tools isolation indicating facts apt contribute problem hand cf 
issue relevance facts 
individual proof obligations arising text typically smaller emerging tactic scripts 
big difference heavily automated proof tools isabelle auto force 
problem redundant local facts recognized tradition isabelle tactic scripts number operations tune goal state removing unwanted premises 
additional tweaking unnecessary proper isar texts course 
just refrain including unwanted facts terminal proof steps place restricting specifications really required 
may gain efficiency proof checking clarity resulting text irrelevant facts excluded opaque automated steps 
general experience isabelle isar applications suggests stronger drawn issue efficiency proof processing 
argue local steps requiring substantial amounts run time due large search spaces somewhat questionable atomic justification place heavy duty reasoning performed sight reader 
certainly attitude assumes automated tools involved correlate inherent complexity problem real run time 
realistic proof procedures typically quite uneven respect 
experienced isar proof writer think twice terminal steps require excessive run time unexpectedly 
similar philosophy encountered mizar rudnicki trybulec muzalewski wiedijk builtin proof procedure finishing local proof obligations strictly limited class problems may decided efficiently rudnicki 
hand slightly restrictive approach rules advanced tools required broader range applications 
outside primary domain mizar classical mathematics set theory applications tend crowded numerous intermediate steps accommodate relatively weak automation chapter 
example unix security facilities 
certainly thing enable isar proof texts incorporate arbitrarily exotic proof methods happen available tactic implementations raw isabelle system 
general principle liberality cf 
left user proper available 
chapter understood natural deduction framework starting point chapter introduced versatile high level proof language isar chapter supports human readable proof texts generic wrt 
underlying object logic extensible wrt 
proof tools specific language elements sound full reduction primitive inferences 
existing approaches mechanized theorem proving far covered aspects isolation isar provides coherent view picture 
broad scope isar marks distinctive advantage consequently able cover general techniques structured proof composition chapter chapter 
isar concepts turned sufficiently simple mature provide viable basis robust system implementation isabelle isar wenzel 
able demonstrate generic framework may instantiated concrete setting isabelle hol chapter 
practical usability demonstrated generic framework chapter chapter isabelle hol instantiation chapter chapter 
particular able include complete formal proof texts meaningful examples despite extra printed pages demanded 
having achieved new quality intelligible semi automated reasoning expect address new application areas new users considered interactive theorem proving reasonable far 
note isar necessarily attract exactly kind users tactical theorem proving 
due shift proof development paradigms quite different techniques required proof writers 
experts old tactical style certainly habits master structured proof composition isar fresh users typically fewer problems 
concerning main objective human readable proofs observe chapter 
single underlying principle intelligible texts 
drawing certain repertoire common elements proof authors need spend care composing adequate record formal reasoning 
isar perspective aspects turned particular important 
moderate inclusion explicit propositions text 
proof authors certainly state key propositions explicitly need avoid clutter due excessive coverage concrete terms 
isar provides specific support casual term abbreviations higher order matching 
clear indication role logical entities assumptions versus universal versus existential parameters 
isar provides particularly rich collection specific context elements 
appropriate variations available 
reduced raw statements internally 
succinct previous facts avoiding explicit labels 
isar element provides fundamental mechanism referring directly preceding result 
derived elements exploit principle somewhat larger scale calculational proof style 
referencing facts explicitly really restricted rare situations complex dependencies multiple uses 
indication relevance facts involved particular proof steps 
chaining facts derived forms enables natural techniques feeding results consecutive goals 
general initial proof steps single rules gives rise mixed forward backward reasoning 
conjunction automated methods isar text may record contributing collection relevant facts explicitly improves readability scalability automated means 
gained insights role general aspects theorem proving particular context human readable proofs 
readability requires clear separation static proof text dynamic goal state 
tactic languages apt arbitrary elements implicit goal configurations intrude recorded source names local parameters introduced implicitly previous refinements 
isar proof processor refrains inspecting internal structure facts goals 
direct transformation internal goal states discontinued 
proof writers need answer particular form subgoal explicit text choice parameters 

importance extra logical concepts 
achieving high level view formal logic necessarily involve new exotic calculi 
built different extra logical layer structured proof configurations isar interpretation process 
rich auxiliary structure proof interpreter drives logical primitives example interpretation trace illustrates relationship layers particularly 
note isar concepts logical impact term abbreviations 
exploit powerful mechanism higher order unification abbreviation patterns hindley milner polymorphism having bother extending logical foundations 
automated reasoning techniques key issue 
big step reasoning automated bridging considerable gaps course formal reasoning proposed standard way achieve high level proofs form 
isar demonstrates careful structural arrangement proof elements may greatly reduce need automated tools 
core mechanisms isar proof composition achieve decent arrangements mainly means higher order resolution single natural deduction rules may involve higher order unification 
furthermore indicating relevant facts local automated steps may reduce complexity proof problems considerably enables get farther simpler proof tools plain rewriting 
despite achievements isabelle isar stepping stone investigations high level formal proof languages large 
apart various technical details isar proof processing issues putting isar concepts wider context 
synthesized results isar takes existing natural deduction framework isabelle pure starting point exploiting inherent potential purposes structured proof processing mere tactical theorem proving 
hand isar ignores isabelle capability schematic goal statements admit incremental synthesis proven results stepwise refinement similar logic programming techniques see paulson 
chapter 
isar proof texts really need fully specified advance 
unbound schematic variables may occur inside internal goal states initial refinement consecutive proof body needs accommodate definite text elements typically involving fix assume show 
excluding schematic statements tribute readability written texts may just mutate dynamically 
schematic goals violate modularity sub proofs course reasoning body affects result instantiation achieved eventually 
modularity key factor support large scale applications 
general idea synthesizing results completely alien structured reasoning rethink existing tactical approaches terms isar concepts 
particular calculational proof style chapter offers general framework synthesizing facts forward fashion consecutive composition chains intermediate results 
observation experimented mechanisms stepwise synthesis verified programs hoare logic wenzel 
structure resulting isar text corresponds nicely program 
hand practical usability demands refinements ideas proper export finished fragments repeated statements hoare triples text handsome right development accommodate incremental reasoning post conditions pre conditions 
unusual logics isar proof language provides faithful high level view underlying natural deduction framework isabelle pure 
object logics directly conform induced notion statements meta level connectives may immediately benefit isar layer chapter chapter 
hand unusual logics natural deduction perspective may demand different encodings isabelle framework 
example existing formulations modal temporal linear logics depend version sequent calculus isabelle library featuring explicit representations complete proof configurations complex meta logical judgments 
unfortunately slightly indirect view object logic results impractical isar proof texts requiring statements sequents text partially specified configurations schematic sequent variables unavailable 
isar text basically degenerate low level trace sequent calculus proofs 
workable interactive development pose fundamental problem 
unusual logics rarely isabelle argue traditional tactical view turns slightly inconvenient 
certainly consider augment underlying framework cover modalities notably meta level operator 
isar language 
extended accordingly achieve reasonable representations modal reasoning 
alternative approaches basin matthews encoding behaved logics directly pure natural deduction framework labeled deductive systems 
interesting see provides viable starting point adequate proof texts isar 
view particularly relevant practice support similar semantic embeddings modal logics existing natural deduction environment isabelle hol 
linear proof processing isar language left right interpretation individual proof commands operating structured proof configuration inside 
paradigm induces canonical sequential reading static proof text 
minor drawbacks left right bias may encountered small large scale occasional inversions wording patterns form 
note limitations non linear forward proof patterns cf 
discussion generalized case splitting 
conveniences available incremental interpretation model global static analysis notably simultaneous type checking cf 
cumulative error reporting failed proof steps isabelle isar currently stops problem encountered 
batch mode proof processing text available achieve features quite easily certainly intend trade virtues incremental proof development including interactive experimentation relatively marginal issues 
fact potential support block structured top development isabelle isar sub proofs may processed independently 
possible skip failed proof steps inserting dummy proof temporarily wenzel 
convenience mainly matter userinterface support existing proof general technology aspinall appears sufficient potential overcome focus linear proof script processing stage 
large scale theory development may learned mizar project rudnicki trybulec readable proofs viable support modular theory concepts mathematical structures important prerequisites large scale library developments attracting contributions authors 
isar inherits canonical concept derived natural deduction rules underlying framework 
essentially admits certain reasoning patterns meta level theorem may single proof rule 
achieve small scale packaging recurrent proof schemes analogous functional abstraction 
chapter 
integration isar language actual module systems logical environments certainly desirable 
existing concept locales kamm ller isabelle pure appears particularly promising say generalizing immediate view contexts isar proof contexts 
version locales enable packaging isar elements fix assume def note obtain 
issues may arise moving different contexts structured proofs 
meta theoretic studies isar obviously interpretation process isar commands provides operational semantics may exploited meta theoretical studies language 
standard repertoire includes suitable notions correctness completeness terms primitive inferences underlying framework 
particularly interesting formalize aspects isar isabelle isar inductive model isabelle hol 
continue old tradition presenting new programming language designs giving interpreter language 
hand fully formal treatment isar meta theory relatively little practical relevance apart providing concrete application 
practice correctness isar proof processing better achieved analogously milner correctness construction means high level proof elements fully reduced primitive inferences run time 
recall isar treats primitive level fully independent exact internal structure results 
completeness means practical purposes reasonable range applications may addressed 
demonstrated empirically examples chapter chapter chapter 
fact live demonstrations stretch isabelle isar environment far 
applications emerged people may expected 
iam est ut si ad interim 
bibliography abel abel 
chang pfenning 
human readable machine verifiable proofs teaching constructive logic 
workshop proof transformations proof presentations complexity proofs ptp www tcs informatik uni muenchen de abel ptp ps gz 
agda agda homepage 
www cs chalmers se agda 
andrews andrews 
mathematical logic type theory truth proof 
academic press 

deduction vis vis computation need formal language proof engineering 
unpublished mit express project www ai mit edu projects express june 
asperti asperti padovani coen schena 
helm semantic math web 
boulton jackson 
aspinall aspinall 
proof general generic tool proof development 
european joint conferences theory practice software etaps 
back von wright back von wright 
structured derivations method doing high school mathematics carefully 
technical report turku centre computer science 
back back grundy von wright 
structured calculational proof 
formal aspects computing 
bertot bertot 
fix point equations wellfounded recursion type theory 
harrison 
bali bali project 
isabelle tum de bali 
carlson carlson 
mizar machine translation mathematics documents 
unpublished 
barendregt geuvers barendregt geuvers 
proof assistants dependent type systems 
robinson voronkov editors handbook automated reasoning 
elsevier 
bibliography barendregt barendregt barthe 
level approach lean proof checking 
berardi coppo editors types proofs programs types volume lncs 
barendregt barendregt 
lambda calculi types 
abramsky gabbay maibaum editors handbook logic computer science volume pages 
oxford university press 
barras barras cornes courant de 
tre gim nez herbelin huet re mu oz murthy parent paulin mohring sa bi werner 
coq proof assistant manual version 
inria 
barwise etchemendy barwise etchemendy 

csli lecture notes stanford 
www csli stanford edu hp 
barwise etchemendy barwise etchemendy 
computers visualization nature reasoning 
moor editors digital phoenix computers changing philosophy 
london blackwell 
basin matthews basin matthews 
logical frameworks 
gabbay guenthner editors handbook philosophical logic second edition 
reidel 
bauer wenzel bauer wenzel 
computer assisted mathematics hahn banach theorem isabelle isar 
coquand dybjer nordstr smith editors types proofs programs types volume lncs 
bauer wenzel bauer wenzel 
calculational reasoning revisited isabelle isar experience 
boulton jackson 
bauer bauer nipkow oheimb paulson rasmussen wenzel 
supplemental isabelle hol library 
part isabelle distribution isabelle tum de library hol library document pdf 
bauer bauer 
formale isabelle isar der satz von hahn banach 
master thesis tu nchen november 
home tum de da pdf 
bauer bauer 
properties ctl 
isabelle tum de library hol ctl document pdf june 
bauer bauer 
hahn banach theorem real vector spaces 
part isabelle distribution isabelle tum de library hol hol real document pdf 
bibliography berger schwichtenberg 
proof theory program development system 
bibel schmitt editors automated deduction basis applications volume ii systems implementation techniques applied logic series 
kluwer academic publishers 
berghofer nipkow berghofer nipkow 
proof terms simply typed higher order logic 
harrison 
berghofer wenzel berghofer wenzel 
inductive datatypes hol lessons learned formal logic engineering 
bertot 
berghofer wenzel berghofer wenzel 
isabelle system manual 
part isabelle distribution isabelle tum 
de doc system pdf 
bertot bertot 
generic approach building user interfaces theorem provers 
journal symbolic computation 
bertot bertot schreiber 
implementing proof pointing structure editor 
technical report lfcs edinburgh 
bertot bertot dowek hirschowitz paulin editors 
theorem proving higher order logics tphols volume lncs 
boulton jackson boulton jackson editors 
theorem proving higher order logics tphols volume lncs 
burstall burstall 
teaching people write proofs tool 
cafeobj symposium japan april 
church church 
formulation simple theory types 
journal symbolic logic pages 
cohn cohn 
proof accounts hol 
unpublished www cl cam ac uk papers ps gz 
constable constable allen bromley cleaveland cremer harper howe knoblock mendler panangaden sasaki smith 
implementing mathematics nuprl proof development system 
prentice hall 
coquand coquand coquand coquand 
type theory 
workshop logical frameworks meta languages paris france 
bibliography coquand paulin mohring coquand paulin mohring 
inductively defined types 
martin mints editors proceedings volume lncs 
kahn th ry 
extracting text proofs 
typed lambda calculus applications volume lncs 
springer 
wolf wolf 
calculus supporting structured proofs 
journal information processing cybernetics eik 
akademie verlag berlin 
wolf 
integration automated interactive theorem proving ilf 
mccune editor th international conference automated deduction cade volume lnai 
springer 
davey priestley davey priestley 
lattices order 
cambridge university press 
de bruijn de bruijn 
survey project automath 
seldin hindley editors curry essays combinatory logic pages 
academic press 
despeyroux despeyroux pfenning sch rmann 
primitive recursion higher order syntax 
hindley editor proceedings third international conference typed lambda calculus applications tlca volume lncs 
springer 
dijkstra scholten dijkstra scholten 
predicate calculus program semantics 
texts monographs computer science 
springer 
farmer farmer guttman thayer 
imps interactive mathematical proof system 
journal automated reasoning oct 
gentzen gentzen 
untersuchungen ber das logische schlie en 
mathematische zeitschrift 
geuvers geuvers wiedijk pollack barendregt 
fundamental theorem algebra project 
www cs kun nl fta index html 
gordon melham gordon melham editors 
hol theorem proving environment higher order logic 
cambridge university press 
gordon gordon milner wadsworth 
edinburgh lcf mechanized logic computation volume lncs 
springer 
bibliography gordon gordon 
hol machine oriented formulation higher order logic 
technical report university cambridge computer laboratory 
gordon gordon 
higher order logic formalism specifying verifying hardware 
technical report university cambridge computer laboratory 
gordon gordon 
hol proof generating system higherorder logic 
birtwistle subrahmanyam editors vlsi specification verification synthesis 
kluwer 
gordon gordon 
lcf hol short history 
plotkin stirling tofte editors proof language interaction essays honour robin milner 
mit press 
www cl cam ac uk papers html 
grundy grundy editors 
theorem proving higher order logics tphols volume lncs 
grundy grundy 
window inference hol system 
archer joyce levitt editors proceedings international workshop hol theorem proving system applications 
acm sigda ieee computer society press 
gunter felty gunter felty editors 
theorem proving higher order logics tphols volume lncs 

extensible proof text editor 
logic programming automated reasoning lpar volume lnai 
springer 
harrison harrison editors 
theorem proving higher order logics tphols volume lncs 
harrison harrison 
inductive definitions automation application 
schubert alves foss editors higher order logic theorem proving applications proceedings th international workshop volume lncs pages aspen grove utah 
springer 
harrison harrison 
hol done right 
unpublished 
harrison harrison 
mizar mode hol 
wright pages 
harrison harrison 
theorem proving real numbers 
phd thesis university cambridge computer laboratory 
technical report number www ftp cl cam ac uk ftp papers reports tr theorem proving real numbers ps gz 
bibliography harrison harrison 
formalizing dijkstra 
grundy 
henkin henkin 
completeness theory types 
journal symbolic logic 

theorie und anwendung 
teubner 
hindley hindley 
principal type scheme object combinatory logic 
trans 
amer 
math 
soc 
hofmann hofmann 
semantical analysis higher order syntax 
th annual ieee symposium logic computer science lics volume 
ieee computer society 
hofstadter hofstadter 
del escher bach eternal golden braid 
basic books new york 
hoover rudnicki hoover rudnicki 
teaching logic mizar mse 
dimacs workshop teaching logic reasoning world web cs ualberta ca hoover dimacs teaching logic html 
hutter hutter 
management change structured verification 
proceedings automated software engineering ase 
ieee 
www dfki de vse papers hutter ps gz 
isabelle library isabelle theory library 
isabelle tum de library 
jape jape framework building interactive proof editors 
users 
comlab ox ac uk bernard jape html 
kamm ller kamm ller wenzel paulson 
locales sectioning concept isabelle 
bertot 
kaufmann kaufmann moore 
computer aided reasoning approach 
kluwer 
klein klein nipkow oheimb 
java 
part isabelle distribution isabelle tum de library hol document pdf 
lamport paulson lamport paulson 
specification language typed 
acm transactions programming languages systems 
lamport lamport 
write proof 
american mathematical monthly 
bibliography mcallester mcallester 
knowledge representation system mathematics 
mit press 
mcallester mcallester 
automatic recognition tractability inference relations 
technical report mit 
mccarthy mccarthy 
recursive functions symbolic expressions computation machine part 
communications acm april 
www formal stanford edu jmc recursive html 
miller miller 
logic programming language function variables simple unification 
journal logic computation 
www cse psu edu dale papers pdf 
milner milner 
theory type polymorphism programming 
comp 
sys 
sci 
mizar library mizar mathematical library 
www mizar org library 
mizar mse mizar mse 
www cs ualberta ca piotr mizar mse 
ller slind ller slind 
treating partiality logic total functions 
computer journal 
ller ller nipkow oheimb 
holcf hol lcf 
journal functional programming 
muzalewski muzalewski 
outline pc mizar 
logic mathematics informatics mizar users group 
www cs kun nl mizar ps gz 
wenzel wenzel 
objectoriented verification record subtyping higher order logic 
grundy 

teams types formal treatment authorisation groupware 
phd thesis tu nchen 
nederpelt nederpelt geuvers de editors 
selected papers automath studies logic 
north holland 
nipkow prehofer nipkow prehofer 
type checking type classes 
th acm symp 
principles programming languages 
nipkow nipkow paulson wenzel 
isabelle hol proof assistant higher order logic 
springer 
lncs 
nipkow nipkow paulson wenzel 
isabelle logics hol 
part isabelle distribution isabelle 
tum de doc logics hol pdf 
bibliography nipkow nipkow 
order sorted polymorphism isabelle 
huet plotkin editors logical environments pages 
cambridge university press 
oheimb oheimb 
analyzing java isabelle hol formalization type safety hoare logic 
phd thesis tu nchen 
www tum de oheimb diss 
owre shankar owre shankar 
formal semantics pvs 
technical report sri csl computer science laboratory sri international 
owre owre rajan rushby shankar srivas 
pvs combining specification proof checking model checking 
alur henzinger editors computer aided verification volume lncs 
paulin mohring paulin mohring 
inductive definitions system coq rules properties 
proceedings typed lambda calculi applications volume lncs 
paulson nipkow paulson nipkow 
isabelle generic theorem prover volume lncs 
springer 
paulson paulson 
natural deduction higher order resolution 
journal logic programming 
revised version www cl cam ac uk research reports tr lcp higher order resolution pdf 
paulson paulson 
foundation generic theorem prover 
journal automated reasoning 
paulson paulson 
isabelle theorem provers 
odifreddi editor logic computer science 
academic press 
paulson paulson 
ml working programmer 
cambridge university press 
paulson paulson 
set theory verification foundations functions 
journal automated reasoning 
paulson paulson 
fixedpoint approach implementing inductive definitions 
bundy editor th international conference automated deduction cade volume lnai pages 
springer 
paulson paulson 
set theory verification ii 
induction recursion 
journal automated reasoning 
paulson paulson 
generic automatic proof tools 
editor automated reasoning applications essays honor larry wos 
mit press 
bibliography paulson paulson 
generic tableau prover integration isabelle 
journal universal computer science 
paulson paulson 
isabelle 
part isabelle distribution isabelle tum de doc intro pdf 
paulson paulson 
isabelle manual 
part isabelle distribution isabelle tum de doc ref pdf 
pdp unix preservation society pdp unix preservation society home page 
cs edu au 
pfenning elliott pfenning elliott 
higher order syntax 
proceedings acm sigplan symposium language design implementation 
pfenning paulin mohring pfenning paulin mohring 
inductively defined types calculus constructions 
proceedings mathematical foundations programming semantics volume lncs 
pitts pitts 
hol logic 
gordon melham pages 
pollack pollack 
dependently typed records representing mathematical structure 
harrison 
rudnicki rudnicki 
mizar mse primer 
unpublished cs ualberta ca online primer html 
proof general proof general organize proofs 
www 
org home 

holcf higher order logic computable functions 
schubert alves foss editors higher order logic theorem proving applications volume lncs 
reif reif 
kiv system systematic construction verified software 
kapur editor th international conference automated deduction cade volume lnai 
springer 
ritchie thompson ritchie thompson 
unix time sharing system 
acm 
cm bell labs com cm cs dmr cacm html 
rudnicki rudnicki 
obvious inferences 
journal automated reasoning 
bibliography rudnicki rudnicki 
overview mizar project 
workshop types proofs programs 
chalmers university technology 

studies mechanical verification mathematical proofs 
phd thesis ku nijmegen 
schroeder heister schroeder heister 
natural extension natural deduction 
journal symbolic logic 
simons simons 
presentation formal proofs 
phd thesis technische universit berlin 
simons simons 
proof presentation isabelle 
gunter felty 
slind slind 
function definition higher order logic 
wright 
slind slind 
derivation induction schemes higher order logic 
gunter felty 

higher order quotients implementation isabelle hol 
gunter felty 
syme syme 
declare prototype declarative proof system higher order logic 
technical report university cambridge computer laboratory 
syme syme 
proving java type soundness 
technical report university cambridge computer laboratory 
syme syme 
declarative theorem proving operational semantics 
phd thesis university cambridge 
syme syme 
tactic theorem proving 
bertot 
tanenbaum tanenbaum 
modern operating systems 
prentice hall 
thompson thompson 
type theory functional programming 
addison wesley 
torvalds torvalds linux kernel archives 
www kernel org 
trybulec trybulec 
features mizar language 
workshop turin italy 
tutorial proof checker 
www tcs informatik uni muenchen de abel 
bibliography unix heritage society unix heritage society 
cs edu 
au 
backhouse backhouse 
interfacing program construction verification 
wing woodcock editors fm world congress formal methods volume lncs 
wenzel wenzel 
typ klassen isabelle 
master thesis tu nchen 
wenzel wenzel 
type classes overloading higher order logic 
gunter felty 
wenzel wenzel 
isar generic interpretative approach readable formal proof documents 
bertot 
wenzel wenzel 
isabelle isar manual 
part isabelle distribution isabelle tum de doc isar ref pdf 
wenzel wenzel 
lattices orders isabelle hol 
part isabelle distribution isabelle tum de library hol lattice document pdf 
wenzel wenzel 
miscellaneous isabelle isar examples higherorder logic 
part isabelle distribution isabelle tum de library hol isar examples document pdf 
wenzel wenzel 
aspects unix file system security 
part isabelle distribution isabelle tum de library hol unix document pdf 
wenzel wenzel 
axiomatic type classes isabelle 
part isabelle distribution isabelle tum de doc 
pdf 
wiedijk wiedijk 
mizar impression 
unpublished 
www cs kun nl mizar ps gz 
wiedijk wiedijk 
mathematical 
unpublished 
www cs kun nl notes mv ps gz 
wiedijk wiedijk 
digital math www page 
www cs 
kun nl 
wiedijk wiedijk 
mizar light hol light 
boulton jackson 
wright wright grundy harrison editors 
theorem proving higher order logics tphols volume lncs 
bibliography 
implementation extensible declarative proof language 
bertot 

readability machine checkable formal proofs 
phd thesis university kent 
index fact term method 
command 
command 
term command command add function agda system alfa system command apply command apply facts function argument function assert goal function assert mode function assm command field assume command assumption function assumption method attribute set atts field auto method command axiom function axioms field bind facts function bind goal function bind result function bind statement function bind terms function blast method bool set command assumption function calculation set case command case set case names attribute cases attribute cases field cases method clarify method close block function coinductive command command set compose function conclude function conclude goal function function cong attribute command consts command consts field consumes attribute context field context set continue function coq system data field datatype command declare system def command index defs command dest attribute discharge function done command elim attribute eliminate function expand function export function export function fact set facts field command finish method function fix command fixes field flat function fold method force method command functions partial total generalize function goal field goal set command command hol system iff attribute ilf system imps system induct attribute induct method inductive command init function init context function init goal function init proof function insert method instance command intro attribute isabelle system iterate function kiv system function lemma command lemmas command command library set lists map function map enclosing function method set system mizar system mizar light system mizar mode hol system mizar mse system mode field command name field name set name atts set names reserved nat set command norm function note command fact obtain command attribute attribute system open block function index params attribute prems fact prepare facts function prepare term function prepare terms function prepare function presume command primrec command problem field proof command proof set proof general system proof scripts unstable proof texts prop set system purge function pvs system qed command recdef command record command records refine function refine enclosing function reset function resolve function result function rule attribute rule method rule set rule context case rule context function safe method select function set function sets simp attribute simp method simp method solve field spl system split attribute start function statement field store result function succeed method symmetric attribute tactic set tag attribute term set terms field fact attribute command theorem command theorem set theorems command theorems field theory field theory set thesis term fact method term command trans attribute transform goal function system type set typedef command types field ultimately command unfold method unify function field var set vectors command 
