program extraction simply typed higher order logic stefan berghofer technische universit unchen institut ur informatik germany www tum de 
representation primitive proof objects terms built theorem prover isabelle propose generic framework program extraction 
show framework extract functional programs proofs conducted constructive fragment object logic isabelle hol 
characteristic feature implementation program extraction produces program correctness proof 
extracted program available function logic correctness proof checked automatically inside isabelle 
fascinating properties constructive logic proof speci cation contains algorithm construction satis es speci cation 
idea forms basis program extraction mechanisms theorem provers coq nuprl 
date program extraction mainly restricted theorem provers expressive dependent type theories calculus constructions 
notable exception system schwichtenberg minimal rst order logic 
isabelle simply typed minimal higher order logic purely constructive little ort devoted issue program extraction system far 
aim demonstrate isabelle quite suitable basis program extraction 
demonstrated proofs isabelle encoded terms 
encoding describe mechanism turns isabelle proof functional program 
isabelle generic theorem prover mechanism generic 
order instantiate particular object logic assign programs primitive inference rules 
induction structure proof terms build programs complex proofs making inference rules 
essence program extraction systematically produce programs correct construction describe transformation supported dfg logic computer science ist project types turns proof correctness proof program extracted 
precise de nition meant correctness called realizability interpretation relates programs logical formulae 
architecture program extraction framework shown fig 

ml program correctness proof hol term specification proof ok code generator proof checker inference engine isabelle core program extractor corr realizes extr extr typeof fig 

architecture isabelle program extraction framework noted extracted program available function object logic 
proof correctness checked inside isabelle 
checking process turns correctness proof genuine theorem may formalizations extracted program 
isabelle code generator extracted function compiled eciently executable ml program 
rest structured follows give overview logical system underlying isabelle object logic isabelle hol 
generic program extraction mechanism introduced describes adaption isabelle hol 
case study described 
preliminaries isabelle pure logical framework isabelle ers logical framework various di erent object logics formalized 
operators inference rules proofs object logic described meta logic isabelle pure 
isabelle meta logic essentially consists layers summarized fig 

isabelle pure ers simple types church type inference decidable 
set type constructors includes nullary type con tc tc fprop types terms 



proofs fig 

isabelle pure logical framework prop type meta level truth values binary type constructor function space 
layer terms simply typed calculus enriched additional constants usual typing rules 
connectives meta logic universal quanti cation implication just speci constants 
signature function mapping constant type possibly free type variables 
example prop prop prop prop prop 
isabelle ers schematic polymorphism referring constant may instantiate type variables occurring declared type 
expressive dependent type theories way explicitly type variables 
layer proofs built top layers terms types 
central idea proof layer curry howard isomorphism proofs represented terms 
consequently proof layer looks quite similar term layer di erence kinds abstractions kinds applications corresponding tion elimination universal quanti ers implications respectively 
proof checking rules seen non dependent variants rules formulae proof checking rules terms type prop 
proof constants axioms theorems proved 
function maps proof constant term type prop 
similar term constants may give instantiation free type variables occurring proposition corresponding proof constant 
background information isabelle proof term calculus 
formalizing object logics formalizing object logics usually introduces new type object level truth values bool object level logical connectives operating terms type bool bool bool 
inference rules speci ed meta logic 
fig 
shows inference rules constructive fragment isabelle hol 
rules typed insert impi mp alli spec exi exe conjunct conjunct noti false note false fig 

constructive inference rules isabelle hol coercion function bool prop right places 
coercion functions outermost quanti ers binding variables usually omitted sake readability 
rule impi reads proof term calculus introduced rules fig 
proof 
impi 


alli 

exe 



exi 


spec 


program extraction come de nition generic program extraction framework 
described fig 
consists ingredients function typeof maps logical formula type term extracted proof actual extraction function extr extracts term program proof extr typeof function realizes term logical formula speci cation returns logical formula describing term sense satis es realizes speci cation function corr yields proof program extracted proof realizes formula proved corr realizes extr extracting types function typeof speci ed set conditional rewrite rules 
easily adapted speci object logics adding new rules 
rewrite rules formulated isabelle term calculus introduced 
order explicitly encode type constraints level terms technique due wenzel 
introduce new polymorphic type constant type 
top add type type coercion function type 
typeof function type type form ip 
ip denotes set propositional types ip fprop bool introduce dummy type null constant null element 
noted functions typeof type de ned isabelle pure doing require kind meta logical framework serve syntax formulate rewrite rules 
intuitively program extracted proof function type parts formula computational content 
example formula 
premise merely veri es right value 
possibility simply assign formula function type dummy argument type null unfortunately lead considerable amount garbage appearing extracted program 
worse recursively extracting programs lemmas appearing proof forced extract useless dummy programs lemmas involved regardless actual computational content 
remedy type corresponding formula speci ed rules depending computational content subformulae 
example formula computational content simply correspond type null type constant null may occur extracted programs 
rules specify extracted type corresponding formulas isabelle pure 
read functional program earlier rules precedence rules appearing 
typeof type type null typeof type type typeof type type typeof type type null typeof type type null typeof type type typeof type type typeof type type typeof type type null typeof type type null typeof type type typeof type type typeof type type typeof type type need deal predicate variables occurring formula 
depends formula predicate variable instantiated contributes computational content formula occurs 
variable instantiated formula having computational content call variable computationally relevant computationally irrelevant 
computationally relevant predicate variable corresponds type variable type extracted program 
extraction computationally relevant predicate variable assigned speci type variable typeof type type 
contrast typeof type type null computationally irrelevant variable theorem predicate variables possibilities variables computationally relevant irrelevant 
may need extract di erent programs theorem depending context 
example program extracted proof type computationally relevant type just computationally relevant 
fortunately variants needed practice extraction mechanism generate demand 
function assigns theorem parameters set computationally relevant variables 
analogously yields suitable type substitution type variables corresponding computationally relevant predicate variables denote set predicate variables theorem fx ip typeof type type null ip typeof type type fx ipg extracting terms ready give de nition extraction function extr 
addition actual proof extr takes context argument associates term variables types proof variables propositions 
extracted term built recursion structure proof 
proof may refer theorems need extracted programs 
introduce function maps theorem name set predicate variables term 
assume contain terms complex theorems extracted term computed earlier invocations extr primitive inference rules exi corresponding term speci ed author object logic 
case result usually just constant referring complex program helps keep extracted program modular 
mentioned theorems predicate variables type corresponding program depends set relevant predicate variables passed additional argument predicate variables particular occurrence theorem relevant depends context extr takes additional list terms describing arguments theorem 
extr extr extr extr extr null extr typeof type type extr 
extr tt extr 
extr null extr extr typeof type type extr rst clause extr says proof variables term variables extracted program 
avoid clashes existing term variables map proof variable term variable occur original proof 
abstractions proof level turned abstractions program level 
case proof computational content extracted program degenerate function arguments 
analogously applications proof level elimination turned applications program level 
case elimination computational content function argument omitted 
case elimination term argument added list argument theorem constant 
encountering theorem constant corresponding program chosen respect current list term arguments 
correctness mentioned extracted program obtain correctness proof 
correctness proof sense rst clear meant correctness 
key understanding correctness extracted programs notion realizability 
realizability establishes connection program speci cation 
precisely specify predicate realizes relates terms called realizers logical formulae 
notion realizability rst introduced kleene study semantics intuitionistic logic 
original formulation realizers odel numbers somewhat hard 
improve kreisel introduced called modi ed realizability realizers actual terms kind programming language odel system characterization realizability described schwichtenberg inspired kreisel modi ed realizability 
set conditional rewrite rules characterizes realizability formulae isabelle pure 
earlier rules higher priority 
typeof type type null realizes realizes null realizes typeof type type typeof type type null realizes realizes realizes null realizes realizes realizes typeof type type null realizes realizes null realizes realizes example third clause de ning realizability thought speci cation input program speci es output 
give speci cation function corr produces correctness proof program computed extr 
similar structure function extr works recursion proof 
proof may refer theorems need function yields correctness proofs programs extracted theorems 
parameters function described 
corr corr corr corr realizes null corr null realizes corr typeof type type corr 
corr tt 
corr 
corr 
corr null corr 
extr 
corr typeof type type corr main correctness property relating functions extr corr stated follows provided realizes corr realizes null null corr realizes extr typeof type type realizes null null realizes typeof type type function express producing correctness proof may assume suitable realizers correctness proofs assumption corr depends context information theorems correctness theorem hold arbitrary occurrence theorem fully applied theorem term arguments outermost quanti ers 
proof correctness theorem induction structure fully applied proof lack space show particularly interesting cases proof 
case realizes null realizes required 
case typeof type type typeof type type 
null null realizes corr realizes extr induction hypothesis 
realizes corr realizes realizes extr required 
subcases similar 
program extraction isabelle hol far generic framework program extraction 
show instantiate speci object logic isabelle hol 
type extraction need assign types logical formulae hol add new equations characterizing typeof 
typeof typeof typeof type type null typeof type type typeof type type typeof type type typeof type type null typeof type type null typeof type type typeof type type null typeof type type typeof type type option typeof type type typeof type type null typeof type type option typeof type type typeof type type typeof type type typeof type type null atomic fx true false show equations equations quite similar look meta level counterparts introduced 
rst equation states typeof simply pushed coercion function 
computational content pair consisting witness computational content just witness 
computational content computational content disjoint sum datatype inl inr just computational content result type datatype option program satisfying speci cation return proper value signal error 
computational content result just boolean value element type datatype left right realizability order reason correctness programs extracted hol proofs need add equations realizes 
realizes realizes typeof type type null realizes realizes null realizes realizes snd fst typeof type type null typeof type type null realizes case left realizes null right realizes null typeof type type null realizes case realizes null realizes typeof type type null realizes case realizes null realizes realizes case inl realizes inr realizes equations similar look meta level counterparts 
atomic predicates set realizes null characterization realizes applied follows typeof type type null 
realizes null realizes null false fde nition realizes realizes null false fde nition realizes false fde nition realizes fde nition name name fp qg pq pq impi fqg fp qg pq pq mp fqg alli fpg spec fpg fpg exi fg fp qg pq pq fst snd exe fqg pq pq fp qg inl fpg fqg fg left fp qg inr fpg fqg fg right fp rg pq pr qr case pq inl pr inr qr fq rg pq pr qr case pq pr qr fp rg pq pr qr case pq qr pr frg pq pr qr case pq left pr right qr fpg arbitrary fig 

realizers basic inference rules isabelle hol null realizes null simply realizes null note computational content necessarily realizes null example realizes null realizing terms remains specify functions introduced act theorems isabelle hol 
means basic inference rule logic give realizing term correctness proof 
treat particularly interesting cases 
shows realizing terms corresponding inference rules hol 
mentioned may realizer inference rule 
proving correctness realizer corresponding inference rule predicate variables face problem 
known know realizes means 
set realizes instantiation known substitute realizes example correctness theorem correctness sum case sum case corresponding program fp rg shown case analysis applying rules sum case 
applying correctness theorem instantiate appropriately fp rg pq pr qr correctness 
realizes 
realizes 
pq 
realizes 
pr 
qr 

correctness programs fp qg fp qg follows directly rewrite rules sum case inl sum case inr induction principle suc natural numbers realized ps nat rec ps nat rec nat rec suc nat nat nat rec nat 
corresponding correctness theorem proved induction nat nat nat nat suc nat nat rec nat nat example warshall algorithm larger example show warshall algorithm computing transitive closure relation derived program extraction 
formalization inspired berger :10.1.1.35.5298
treated coq system paulin mohring 
sequel relation function mapping elements type boolean value 
datatype types rel emphasize relation decidable datatype built type bool hol purpose 
order write speci cation algorithm useful introduce function path path ys holds path intermediate nodes ys respect relation consts path rel list bool primrec path path ys path ys paths modeled triples consisting source node list intermediate nodes target node 
sequel nodes natural numbers 
auxiliary function path de ne function path path holds path intermediate nodes brevity path property called path 
introduce function conc concatenating paths 
path nat rel nat nat list nat nat nat nat bool path fst snd snd list fst snd path fst fst snd snd snd conc list list list conc fst fst snd fst fst snd snd snd main proof relies lemmas properties path 
example path suc path 
lemma lemma path path suc path relation edge connecting lemma lemma path path path concatenating paths yields suc path lemma lemma path path path conc suc lemma central proof main theorem 
says suc path path paths lemma lemma path suc path path path rst component conjunction proved induction list intermediate nodes path proof second component symmetric proof rst component reverse induction 
lemma proved constructively computational content main theorem 
emphasize rephrase writing lemma lemma path suc path path path main theorem stated follows relation nodes exists path path exists 
course trivial prove classically 
constructive proof statement yields function returns path returns 
proof induction base case nd path exist edge connecting nodes 
path lemma 
step case supposed nd suc path appeal induction hypothesis decide path case easily conclude lemma suc path 
appealing induction hypothesis times check paths paths combine get suc path lemma 
path suc path contradict lemma order formalize proof isabelle readable way proof language isar due wenzel :10.1.1.6.5746
theorem warshall path path proof induct case show case induction basis proof cases assume path simp add path def path 
thesis 
assume simp path rules dest lemma thesis 
qed case suc case induction step proof assume path path suc rules intro lemma case 
assume path suc show case proof assume path path suc rules dest lemma case 
assume path obtain path 
suc show case proof assume path path suc rules dest lemma case 
assume path obtain path 
path conc suc rule lemma pq path pq suc 
case 
qed qed qed qed proof program extracted isabelle warshall nat rec case case case case conc applying de nition realizability yields correctness theorem automatically derived proof case warshall path path related rst theorem provers support program extraction constable nuprl system martin type theory px system hayashi 
coq system calculus inductive constructions cic extract programs ocaml haskell 
paulin mohring realizability interpretation calculus constructions proved correctness extracted programs respect realizability interpretation 
possible principle check correctness proof corresponding extracted program inside coq implemented 
completely obvious practice coq allows omission termination arguments types extracted program may render program untypable cic due occurrence unguarded xpoints 
distinguishing relevant irrelevant predicate variables described coq system universes set prop inhabited computationally interesting computationally types respectively 
fern andez proposed extension calculus constructions called theory speci cations program extraction realizability 
built reduction relation calculus re ects behaviour functions corr extr de ned 
similar approach taken burstall mckinna theory deliverables :10.1.1.45.9064
deliverable pair consisting program correctness proof modeled strong types 
anderson describes embedding rst order logic program extraction elf proves meta theoretic properties extraction function typedness extracted program 
system schwichtenberg extract scheme programs proofs minimal rst order logic enriched inductive datatypes predicates 
extended produce correctness proofs extracted programs 
supports program extraction classical proofs 
isabelle implementing program extraction calculi past 
basin shown simulate manna waldinger deductive tableau isabelle hol 
coen formalized classical computational logic tailored speci cally program extraction framework applicable common object logics hol 
developed program extraction framework theorem prover isabelle shown applicability realistic examples 
tackle advanced case studies 
candidate algorithms graph theory 
example think extracting graph colouring algorithm proof colour theorem bauer nipkow 
important point study framework instantiated logics constructive versions zermelo fr set theory zf 
hol instantiation described matters particularly simple hol isabelle meta logic share type system 
contrast zf essentially untyped simulates concept type checking explicit logical reasoning set membership statements 
interesting examine program extraction classical proofs lines berger applied classical proofs hol 
laura tobias nipkow martin strecker markus wenzel commented draft version suggested improvements 
helmut schwichtenberg monika numerous discussions subject 
anderson 
program extraction logical framework setting 
pfenning editor proceedings th international conference logic programming automated reasoning volume lnai pages 
springer verlag july 
basin 
higher order interpretation deductive tableau 
journal symbolic computation may 
barras cornes courant de 
atre gim enez herbelin huet ere mu murthy parent paulin mohring sa bi werner 
coq proof assistant manual version 
technical report inria february 
bauer nipkow :10.1.1.45.9064
colour theorem isabelle isar 
mu editors theorem proving higher order logics volume lncs pages 
springer verlag 
berger schwichtenberg 
proof theory program development system 
bibel schmitt editors automated deduction basis applications volume ii systems implementation techniques applied logic series pages 
kluwer academic publishers dordrecht 
berger buchholz schwichtenberg 
re ned program extraction classical proofs 
annals pure applied logic 
berger schwichtenberg :10.1.1.35.5298
warshall algorithm dickson lemma examples realistic program extraction 
journal automated reasoning 
berghofer nipkow 
proof terms simply typed higher order logic 
harrison editors theorem proving higher order logics tphols volume lncs 
springer verlag 
berghofer nipkow 
executing higher order logic 
callaghan luo mckinna pollack editors types proofs programs types volume lncs 
springer verlag 
coen 
interactive program derivation 
phd thesis cambridge university november 
constable allen bromley cleaveland cremer harper howe knoblock mendler panangaden sasaki smith 
implementing mathematics nuprl development system 
prentice hall nj 
coquand 
une th eorie des constructions 
phd thesis universit paris january 
fern andez 
operational approach program extraction calculus constructions 
international workshop logic program development transformation lncs 
springer 
hayashi nakano 
px computational logic 
foundations computing 
mit press 
kleene 
metamathematics 
north holland 
mckinna burstall :10.1.1.45.9064
deliverables categorical approach program development type theory 
sokolowski editors mathematical foundations computer science th international symposium volume lncs pages poland aug sept 
springer 
paulin mohring 
extracting 
programs proofs calculus constructions 
sixteenth annual acm symposium principles programming languages austin jan 
acm 
paulin mohring 
extraction de programmes dans le calcul des constructions 
th ese universit paris jan 
paulin mohring werner 
synthesis ml programs system coq 
journal symbolic computation 
pfenning sch 
system description twelf meta logical framework deductive systems 
ganzinger editor cade th international conference automated deduction trento italy july volume lecture notes computer science pages :10.1.1.45.9064

studies theory speci cations built program extraction 
journal automated reasoning july 
wenzel 
type classes overloading higher order logic 
gunter felty editors theorem proving higher order logics tphols lncs 
wenzel :10.1.1.6.5746
isabelle isar versatile environment human readable formal proof documents 
phd thesis institut ur informatik tu unchen 
biblio tu muenchen de publ diss wenzel html 

