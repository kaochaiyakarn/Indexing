arrows robots functional reactive programming paul hudak antony courtney henrik nilsson john peterson yale university department computer science paul hudak yale edu antony courtney yale edu henrik nilsson yale edu john peterson yale edu 
functional reactive programming frp paradigm programming hybrid systems systems containing combination continuous discrete components high level declarative way 
key ideas frp notions continuous time varying values time ordered sequences discrete events 
yampa instantiation frp domain specific language embedded haskell 
describes yampa detail shows program particular kind hybrid system mobile robot 
performance critical robotic programming yampa uses arrows generalization monads create disciplined style programming time varying values helps ensure common kinds time space leaks occur 
previous experience robots expected reader basic understanding physics calculus assumed 
knowledge arrows required assume working knowledge haskell 
dedicated memory edsger dijkstra influential insight mathematical logic basis sensible computer program construction 
functional languages real world particular realtime systems 
specifically expressiveness functional languages advantageously systems performance issues overcome common applications 
past years trying answer questions affirmative 
developed general paradigm called functional reactive research supported part national science foundation ccr ccr defense advanced research projects agency dabt national aeronautics space administration ncc 
second author supported nsf graduate research fellowship 
programming suited programming hybrid systems systems continuous discrete components 
excellent example hybrid system mobile robot 
perspective mobile robots continuous components voltage controlled motors batteries range finders discrete components microprocessors bumper switches digital communication 
importantly logical perspective mobile robots continuous notions wheel speed orientation distance wall discrete notions running object receiving message achieving goal 
functional reactive programming manifested fran domain specific language dsl graphics animation developed conal elliott microsoft research 
frp dsl developed yale essence fran exposes key concepts bias application specifics 
fal frob fvision fruit dsls developed embracing paradigm ways suited particular application domain 
addition pushed frp real time embedded systems variants including real time frp event driven frp 
core ideas functional reactive programming evolved subtle ways language designs culminating call yampa main topic 
yampa dsl embedded haskell refinement frp 
distinguishing feature core frp concepts represented arrows generalization monads 
programming discipline induced arrows prevents certain kinds space leaks common generic frp programs making yampa suitable systems having real time constraints 
yampa program real industrial strength mobile robots building earlier experience frp frob 
robot simulator 
way reader able run programs new ones write having buy robot 
code simulator available yampa home page www haskell org yampa 
simulated robot refer simbot drive robot meaning wheels cart driven independent motor 
relative velocity wheels governs turning rate simbot velocities identical simbot go straight 
physical simulation simbot includes translational inertia simplicity rotational inertia 
motors simbot go kinds sensors 
bumper switch detect simbot gets stuck yampa river colorado long sections occasionally interrupted turbulent metaphor continuous discrete components hybrid systems 
prefer acronyms yampa started yale ended arrows programming 
earlier papers referred yampa 
simbot runs just signal program 
second range finder determine nearest object direction 
examples assume simbot independent range finders look forward backward left right query range finder angles 
third simbot call animate object tracker gives location possibly free moving balls certain distance simbot 
think tracker modelling visual subsystem see objects communication subsystem balls share coordinates 
simbot unique id capabilities introduce need 
yampa basics important concept underlying functional reactive programming signal continous time varying value 
think signal having polymorphic type signal time value type signal function mapping suitable values time double implementation value type conceptually value time just 
example velocity differential drive robot pair numbers representing speeds left right wheels 
speeds turn represented type speed robot velocity represented type signal speed speed 
program controlling robot provide value output 
able define manipulate continuous values programming language provides great expressive power 
example equations governing motion differential drive robot vr vl cos dt vr vl sin dt vr vl dt robot coordinates orientation respectively vr right left wheel speeds respectively distance wheels 
frp equations written integral vr vl cos theta integral vr vl sin theta theta integral vr vl values frp program implicitly time varying explicit time 
direct correspondence physical equations specification frp code implementation strong 
frp quite general concept signal lead programs conspicuous time space leaks reasons scope 
earlier versions fran fal frp various methods performance problem issue ultimately suffered problem way introduced problems result fixing 
yampa problem solved radical way signals simply allowed class values 
programmer access signal transformers functions 
signal function just function maps signals signals sf signal signal actual representation type sf yampa hidden sf directly build signal functions apply signals 
allowing user define arbitrary signal functions scratch easy introduce time space leaks provide set primitive signal functions set special composition operators combinators complex signal functions may defined 
primitive values combinators provide disciplined way define signal functions avoids time space leaks 
achieve structuring yampa arrows generalization monads proposed 
specifically type sf instance arrow class 
broadly speaking yampa program expresses composition possibly large number signal functions composite signal function run top level suitable interpreter 
analogy idea state io monad state hidden program consists linear sequencing actions eventually run interpreter operating system 
fact arrows general monads particular composition signal functions completely linear illustrated shortly 
signal functions implies sine cosine arithmetic operators loaded handle signals properly 
time leak real time system occurs time dependent computation falls current time value effect needed requires catching point time 
catching process take arbitrarily long time may may consume space 
destroy hope real time behavior managed properly 
concerned sufficient set combinators compose signal functions loss expressive power 
motivate set combinators compose signal functions analogy called point free functional programming example bird meertens formalism 
simplest possible example suppose writing write point free style familiar function composition operator code point free values points passed returned function directly manipulated 
level signal functions need primitive operator lift ordinary functions level signal functions arr sf primitive combinator compose signal functions sf sf sf write sf arr arr arr note represents reverse function composition arguments reversed comparison 
unfortunately programs simply linear compositions functions case input output needed 
example suppose point free style simplest way define combinator allows define simply yampa combinator sf sf sf analogous allowing write sf arr arr arr example suppose easily write point free version defined haskell standard fst snd operators fst snd signal functions need analogous versions fst snd achieve lifting sf arr arr fst arr snd arr fst arr arr snd arr argument wiring pattern captured fact common yampa provides combinator sf sf sf arr fst arr snd written simply arr arr andi derived andi respectively appealing intuition functions composition 
section formalize type classes 
arrow class go manner adding combinators needed solve particular argument wiring problems point ask minimal universal set combinators sufficient express possible 
note far introduced combinators arr definitions fourth defined terms 
combinators constitute minimal universal set 
minimal set 
fact defining original arrow class hughes chose set arr class arrow arr analogous function defined ordinary function level yampa type sf instance class arrow types consistent earlier 
help see set definitions second terms arrow class methods second arrow second arr swap arr swap swap pr snd pr fst pr arrow arr second addition instance declaration shows haskell normal function type treated arrow instance arrow arr instance declaration derivations andi previous section formally justified 
exercise 
define terms just arr terms just second terms just arr 
commonly combinators practice better think terms commonly set combinators minimal set 
shows set combinators yampa programming graphical wiring arguments imply 
yampa provides convenient library functions facilitate programming arrow framework 
identity sf constant sf time sf time arr arrow arrow arrow arrow second arrow arrow arrow loop arrow arr sf sf sf sf loop sf sf fig 

commonly arrow combinators identity signal function analogous identity function haskell fact equivalent arr id function useful generating constant signal functions analogous haskell const function fact equivalent arr const 
time signal function yields current time equivalent constant integral pre defined yampa signal function type integral sf double double signal function 
important note signal functions stateful accumulate information time 
integral perfect example function definition sums values signal time 
stateful signal functions defined arr lifts pure functions level arrows 
stateful functions pre defined defined terms stateful signal functions 
stated way stateful signal functions integration differentiation depend intimately underlying time varying semantics analogous forms 
easy lift unary functions level signal functions generally need provide special signal function versions 
example defining special sin arr cos furthermore binary lifting operator arr sf arr arr uncurry lift binary operators 
example arr type num sf simple example see action consider frp code earlier coordinates orientation mobile robot 
rewrite code coordinate yampa leaving coordinate orientation exercise 
suppose signal functions sf speed sf angle represents input state simbot say 
signal functions hand previous frp code integral vr vl cos theta rewritten yampa function overloaded vector space concern specialized double 
sf distance arr arr cos arr integral arr exercise 
define signal functions yampa correspond definitions theta respectively frp 
arrow syntax achieved goal preventing direct access signals argue lost clarity original frp code code certainly difficult understand complexity due need wire signal functions various pairing combinators 
precisely address problem paterson suggested special syntax arrow programming readable written preprocessor converts syntactic sugar conventional haskell code 
special arrow syntax yampa code rewritten sf distance proc inp vr inp vl inp theta inp integral vr vl cos theta quite readable original frp definition far better version 
things note structure code 
syntax proc pat analogous haskell lambda expression form pat 
defines signal function normal haskell function 

syntax pat expr expression signal function say type sf type pat type 
analogous pat expr expr haskell clause case expr type expr type pat type 

syntax proc pat pat expr pat expr expr defines signal function 
pat type expr type type signal function sf 
addition variable bound patterns pat expression expr expression expr inparticular signal function expressions important note arrow syntax allows get handle signal values samples signals 
words recalling signal function sf thought type signal signal turn thought type time time syntax allows getting handle values type values type time time signal flow diagram precisely represents wiring implied sugared definition 
reflects data dependencies original frp program 
shows diagram overlaid combinator applications implied definition clarity lifting arr primitive functions drawn circles omitted 
diagrams demonstrate nicely relationship sugared forms yampa programs 
exercise 
rewrite definitions previous exercise arrow syntax 
draw signal flow diagrams 
discrete events switching programming languages kind conditional choice capability yampa exception 
signal functions flag sf bool sf signal function sf sf sf proc flag behaves flag yields true value yields false 
completely satisfactory situations prefer signal function switch literally signal function continually alternate signal functions value boolean 
succession new signal functions switch succession particular events occurs state changes finite state automaton 
furthermore newly invoked signal functions start afresh time zero signal functions running inp vr vl theta cos sugared cos fig 

signal flow diagrams integral integral program began 
relates precisely issue previously discussed 
advanced functionality achieved yampa events switching combinators 
previous versions frp including fran frob fal significant distinction continuous values discrete events 
yampa distinction great 
events yampa just values isomorphic haskell data type 
signal type signal event called event stream signal point time yields event carrying value type signal function type sf event generates event stream called event source 
note event streams continuous values represented signals yampa important semantic differences 
example improper events may lead programs convergent allow underlying sampling rate show program behavior 
semantically speaking event streams yampa infinitely dense time practically speaking frequency exceed internal sampling rate buffering provided 
example defined event source signal function sf event generates event stream events correspond moments robot gets stuck event generated time robot motion blocked obstacle run 
event streams special special set functions event streams achieve various kinds switching 
simplest switching combinator called switch switch sf event sf sf expression sf es switch sf behaves sf event event stream es occurs point event value bound behavior switches sf 
example order prevent damage robot wheel motor may wish set speed zero robot gets stuck speed sf speed constant switch constant clear stateful yampa programs constructed switching combinators 
exercise 
set wheel speed zero robot gets stuck negate 
define recursively velocity gets negated time robot gets stuck 
certain input events key presses fact properly implementation lost 
switching semantics 
kinds switching combinators yampa 
arise choices semantics 
switch happens exactly time event infinitesimally just 
case delayed prefixed name switch 

switch happens just event event stream event 
case recurring prefixed name switch 
leads names types switch sf event sf sf sf sf event sf example switch 
delayed switching useful certain kinds recursive signal functions 
sec 
see example 
mentioned earlier important property switching time begins afresh signal function switched 
example consider expression time arr sin switch const left switch generates sinusoidal signal 
event generated happens time right time regardless time sinusoidal signal start time event 
useful event functions 
event instance class functor fmap change value carried event 
example increment value event event double writing fmap don care old value event creating new yampa provides tag event event tag fmap const desirable merge events example form disjunction logical events 
problem deciding simultaneous events 
general form merge event event event allows user decide handle simultaneous events providing function combine event values 
alternatively may choose give preference left right event event event event event event event possibility simultaneous events merge may generates error fact events occur merge event event event far considered pre existing events 
may come external sources bumper switch communications subsystem convenient define events 
yampa provides variety ways generate new events important edge sf bool event expression edge generates event time signal goes false true leading edge signal 
example sf temp signal function indicates temperature sf event arr edge generates alarm event temperature exceeds degrees 
useful event generation functions sf event sf event time sf event repeatedly time sf event event source generates event occurrences 
generates exactly event time occurrence zero value expression generates exactly event time occurrence value similarly repeatedly generates event seconds value close section point discrete continuous worlds interact important ways switching course fundamental 
yampa provides useful functions capture interaction 
hold sf event accum sf event event signal function hold initially generates signal constant value time event occurs value signal takes holds new value 
signal function accum event stream transformer 
input event generates output event 
fn function corresponding nth input event value vn nth output event just fn vn forn 
example signal function represents number alarms generated defined earlier sf int arr tag accum hold accum followed hold idiom common predefined yampa sf event init accum init hold init exercise 
suppose sf velocity represents scalar velocity simbot 
integrate velocity get measure far simbot traveled 
define alarm generates event simbot traveled meters gotten stuck 
recursive signals note fig 
presence loop combinator 
purpose define recursive signal functions fixpoint operator 
arrow syntax goes step allowing recursive definitions programmed directly preprocessor expands applications loop combinator 
case user include keyword rec prior collection recursive bindings 
example common need switching take snapshot signal switched computing value signal switched 
suppose event source sf event events correspond commands increment velocity 
define signal function responds commands follows vel velocity sf velocity vel proc inp rec inp constant inp tag constant note recursively defined 
requires rec keyword delayed switch ensure recursion founded 
note recurring version switch want velocity update happen event 
note tag update value event 
need delayed switch best motivated analogy recursively defined lists streams 
definition ones ones expresses usual infinite stream ones obviously founded list ones ones obviously founded 
value placed front list thought delay access ones 
idea delayed switch semantically delay intended infinitesimally small implementation avoid introducing delay affect performance 
exercise 
redefine vel rec keyword 
hint define vel recursively defining recursively 
programming robot simulator robot input output generally speaking dozens different robots real simulated different kinds functionality wheels wheels wheels cameras sonars bumper switches actuators speakers flashing lights 
differences captured input output types robot 
example kind simulated robot simbot input type output type 
note code described section works yampa version patches changes anticipated yampa versions higher 
particular module names change 
yampa known old names backwards compatibility reasons 
refer collection yampa libraries robot specific 
library written generic possible depend directly robot input output types 
type classes capture different kinds functionality 
robot type instance subset classes depending functionality offer 
example member type classes shown upper half fig 
member lower ones 
types velocity distance angle length acceleration speed heading synonyms type double 
synonym point position data point point deriving eq give examples operations type classes examples follow 
doing detail describe output classes 
note fig 
methods classes return type constrained 
allows incrementally specify certain fields record merge 
key operations mergeable records input classes related functions class battery status bool currently stuck data deriving eq show derived event sources sf event sf event sf event sf event class position current position heading current heading class angle distance distance derived range finders distance distance distance distance class angle distance angle distance class char char sf event char sf event char output classes related functions class brake wheels velocity velocity set wheel velocities velocity set vel 
rot 
class event string fig 

robot input output classes example expression vel vel merges velocity output console message 
turns velocity control message output things merged class may overkill 
robots may mergeable outputs functionality offered quite convenient 
common outputs merged result depends methods defined behave 
designer particular instance methods signal error accept output example merging calls yields value combine example merging calls 
robot controllers control robot define robot controller case type type sf 
properties accessed abstractly instance type class class type robot identity robot length distance wheels acceleration max translational acc speed max wheel speed type string type int simulator knows versions simbot properties slightly different 
field just string 
remaining fields self explanatory 
run simulator function io data type describes initial state simulator world 
list walls balls blocks locations centers type data position square obstacle position vertical wall position horizontal wall position ball simbot robot position heading simbot robot position heading constants bounds simulated world assumed meters 
currently values respectively world meters meters center coordinate 
walls currently fixed size blocks diameter simbot 
program structured follows module import import main io main just world rca rcb world world rca controller simbot rca rcb controller simbot rcb 
module imports yampa library 
module robot simulator 
note robots may created kind simbot simbot world template controller invoked 
want distinguish simply give different example simbot robots code controller rca structured rca rca case rca rca rca rca rca rca rca rca rca 
basic robot movement section write series robot controllers type 
designing controllers real robots art science 
science part includes control theory related mathematical techniques focus differential equations design optimal controllers specific tasks 
spend time control theory appeal reader intuition design functional optimal controllers simple tasks 
details kinematics mobile robots see 
go turn 
starters define world controller stationary simbot constant simbot move blindly forward constant velocity constant better determining maximal allowable wheel speeds running simbot say half speed rps max rps constant max max control simbot allows specifying simbot forward rotational velocities individual wheel speeds 
differential drive robot maximal rotational velocity depends vehicle forward velocity rotate quickly standing rotate going maximal forward velocity turn going maximal velocity wheels slow case longer going maximal velocity 
maximal wheel velocity vmax forward velocity vf show maximal rotational velocity radians second max vmax vf example simbot turns fast possible going speed velocity vel rps vmax rps rmax vmax vel rps constant vel rmax exercise 
link way perform seconds seconds 
hint generate event time interval 
simbot talks sort 
interesting define simbot gets stuck reverses direction displays message console velocity rps beh const rps beh proc sbi sbi tag note binding proc analogous binding haskell monadic syntax 
note recursive velocity reversed simbot gets stuck requires ensure recursion founded 
require rec keyword recursion occurs outside proc expression 
reason subtle uses control message printed controls switch switch happened instantaneously message missed 
preferred hard write arrow syntax rps arr fun const rps fun tag exercise 
write version knowing advance velocity takes snapshot velocity described sec 
moment stuck event happens negates value continue 
finding way odometry 
note fig 
odometry ability robot track location 
capability real robot approximated called dead reckoning robot monitors actual wheel velocities keeps track position incrementally 
unfortunately particularly accurate errors arise wheel slippage uneven terrain 
better technique gps global positioning system uses satellite signals determine vehicle position feet accuracy 
simulator assume simbot odometry perfect 
odometry readings feedback controller stabilize increase accuracy desired action 
example suppose wish move simbot fixed speed certain direction 
set speed easily shown examples directly specify direction 
read direction odometry function heading control rotational velocity 
note robot headings 
data types relate headings 
heading assumed radians aligned usual cartesian coordinate system radians corresponding positive axis positive axis 
normalized range 

bearing assumed degrees aligned conventional compass degrees corresponding north degrees east 
normalized range 

angle assumed radians relative measure aligned absolute 
provide conversion functions bearings headings bearing heading heading bearing headings relative angles 
getting back problem hd ha desired actual headings radians respectively heading error just hd ha 
positive want turn robot counter clockwise direction positive rotational velocity negative want turn robot clockwise direction negative rotational velocity 
words rotational velocity directly strategy called proportionate controller 
small complication scheme need normalize hd ha keep angle range 
easily achieved yampa function 
complete controller velocity heading vel hd rps vmax rps vel lim vmax vel proc sbi hd sbi vel abs pi vel vel lim max min parameter called gain controller adjusted give faster response risk fast unstable 
lim limits maximum absolute value example rewrite program way velocity heading vel hd rps proc sbi rps sbi vel hd sf velocity heading rps vmax rps proc sbi vel hd vel lim vmax vel hd sbi vel abs pi vel vel original definition vel hd constant lifetime signal function second version treated signals allowing time varying 
needed example need capability 
example odometry consider task moving simbot specific location 
computing trajectory current location desired location 
doing continually ensure drift caused imperfections robot floor surface cause appreciable error 
complication take account simbot translational inertia don may overshoot target 
slow approach target amounts designing proportionate controller 
code velocity position vd pd rps proc sbi vector pd 
sbi vel vd vd rps sbi vel note vector arithmetic compute difference desired position pd actual position sbi vector convert error vector distance heading vel speed approach target 
note defined move simbot desired velocity heading 
exercise 
behave little bit funny simbot reaches destination differential drive robot able maneuver slow velocities compare difficulty parallel parking car ease switching lanes high speed 
modify gets reasonably close target stops 
exercise 
define controller cause robot follow sinusoidal path 
hint feed sinusoidal signal 
exercise 
define controller takes list points causes robot move point successively turn 
exercise 
define controller chases ball 
hint method class find location ball 
ball hit simulator robot create event 
modify controller restarts robot gets stuck backs restarts 
home range 
recall range finders able determine distance nearest object direction 
assume looking forward backward left right distance distance distance distance intended simulate sonar sensors far accurate conventional sonar broad signal 
similar capability laser range finder 
range finder degree autonomous navigation unknown terrain navigation area precise map 
situations certain degree navigation done local features robot sees walls doors objects 
example define controller causes simbot follow wall left 
idea move forward constant velocity desired distance wall varies left range finder reading adjustments rotational velocity keep simbot line 
task quite simple previous ones reasons scope desirable known pd proportionate derivative controller means error signal fed back proportionately derivative 
precisely show small deviations norm kp kd dr dt kp kd proportionate gain derivative gain respectively 
generally speaking higher gain better care taken avoid responding quickly may cause shooting mark worse unstable behavior oscillatory diverges 
shown optimal relationship kp kd kp vk 
pragmatic reasons put limit absolute value limiting function lim 
assuming mathematics correct writing controller fairly straightforward velocity distance proc sbi sbi dr derivative omega kp kd dr kd kp kd lim omega exercise 
enhance wall follower controller left right turns maze constructed horizontal vertical walls 
specifically 
simbot sees wall directly front slow approaches wall stopping distance wall 
turn right continue wall left 
inside corner right turn 

simbot loses track wall left continues straight ahead turns left goes straight distance follows wall left 
outside corner left turn 
test controller appropriately designed world template 
exercise 
mentioned derivation controller useful robot close track proper distance wall proper heading 
robot far wall tend turn trying get closer left range finder see greater distance system unstable 
designing robust wall follower tricky business best treated multi mode system robot seeks wall aligns parallel wall tries follow 
design controller 
mass 
mentioned earlier simulator handle number simultaneously 
groups robots exhibit kinds interesting productive group behavior possibly mass limited cleverness designer 
describe simple kind group behavior leaving soccer match described ex 

behavior define convergence 
assume initially moving arbitrary directions speeds 
simbot look positions move centroid average positions 
robot continuously independently converging point 
achieve recall class class angle distance angle distance operations permits determine angle distance 
converting measurements vectors add take average steer robot resulting centroid 
dealing numeric conversions final code fairly straightforward velocity rps proc sbi neighbors sbi vs map vector polar neighbors avg vs foldl vs length vs heading vector theta avg sbi rps sbi heading frominteger observing world robot sensors assumptions going see noise varying light conditions occlusion destroy expectations 
example case simulator guarantee robots visible animate object tracker 
time step visible 
reasons causality sensor data delayed time step time step previous data report animate object tracker returns empty list robots 
code list vs tested empty 
exercise 
write program traveling straight path paths continually interleave braid rope 
hint treat velocities vectors determine proper equations circle maintaining specified distance 
add velocities forward velocities yield desired behavior 
exercise 
write program play robocup soccer follows 
wall segments create goals field 
decide number players team write controllers 
may wish write couple generic controllers goalkeeper attack defense 
create initial world ball center mark players positioned strategically side defensive players outside center circle 
team may controller different ones 
pit controller writing skills friends recommend betting money game outcome 
wish members yale haskell group support feedback ideas 
particular wan undoubtedly deeply involved busy writing thesis 
greg hager johns hopkins believed ideas try real robots 
conal elliott started path continuous despite discrete moments trauma 

richard bird 
calculus functions program derivation 
david turner editor reseach topics functional programming 
wesley 

antony courtney conal elliott 
genuinely functional user interfaces 
proc 
haskell workshop september 

gregory dudek michael jenkin 
computational principles mobile robots 
university press new york 

conal elliott 
functional implementations continuous modeled animation 
proceedings plilp alp 
springer verlag 

conal elliott paul hudak 
functional reactive animation 
international conference functional programming pages june 

paul hudak 
haskell school expression learning functional programming multimedia 
cambridge university press new york 

john hughes 
generalising monads arrows 
science computer programming may 

henrik nilsson antony courtney john peterson 
functional reactive programming continued 
acm sigplan haskell workshop october 

ross paterson 
new notation arrows 
icfp international conference functional programming pages firenze italy 

henrik nilsson hager 
functional reactive robotics exercise principled integration domain specific languages 
principles practice declarative programming ppdp october 

john peterson gregory hager paul hudak 
language declarative robotic programming 
international conference robotics automation 

john peterson paul hudak conal elliott 
lambda motion controlling robots haskell 
international workshop practical aspects declarative languages 
sigplan jan 

john peterson wan paul hudak henrik nilsson 
yale frp user manual 
department computer science yale university january 
available www haskell org frp manual html 

alastair reid john peterson greg hager paul hudak 
prototyping realtime vision systems experiment dsl design 
proc 
int conference software engineering may 

wan 
functional reactive programming real time embedded systems 
phd thesis department computer science yale university december 

wan paul hudak 
functional reactive programming principles 
proceedings acm sigplan conference programming language design implementation pldi pages vancouver bc canada june 
acm acm press 

wan walid taha paul hudak 
real time frp 
proceedings sixth acm sigplan international conference functional programming florence italy september 
acm 

wan walid taha paul hudak 
event driven frp 
proceedings fourth international symposium practical aspects declarative languages 
acm jan 
