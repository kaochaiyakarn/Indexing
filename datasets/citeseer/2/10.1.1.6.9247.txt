system extensible parsing transformation claus brabrand michael schwartzbach mads brics department computer science university aarhus ny munkegade building dk aarhus denmark tool specifying flexible safe cient syntactic transformations languages defined context free grammars 
transformations guaranteed terminate map grammatically legal input grammatically legal output 
rely novel parser algorithm designed support gradual extensions grammar allowing productions remain natural style statically reporting ambiguities errors terms individual productions added 
tool may parser generator resulting parser automatically supports flexible safe cient macro processor extensible lightweight compiler generator domain specific languages 
show substantial examples kinds 
tool specifying safe flexible cient extensible syntactic transformations languages defined context free grammars 
safety means statically guarantees transformation grammatically legal input terminate produce grammatically legal output 
flexibility means expressive power su cient realistic tasks source target languages may extended little overhead 
ciency means grammar transformation parsing transformation linear size input generated output 
extensibility means post hoc extensions email brabrand brics dk email mis brics dk email brics dk brabrand schwartzbach source language easily reflected similar extensions transformation 
main usage scenarios mind versatile tool 
lightweight domain specific compiler prototypes translating java programs html documentation style javadoc 
second source language small extension target language syntactic transformation equivalent powerful macro mechanism 
cases programmer may greatly benefit advantages ers 
tool captures niche full scale compiler generators general simpler techniques syntactic transformation expressive er su cient safety guarantees 
language design tool works kinds files definitions languages definitions transformations 
languages defined fairly standard context free grammars nonterminals terminals productions 
simple module system allows languages defined dag sublanguages refer 
classes terminals defined full regular expressions including intersection complement 
central part tool course parsing algorithm employed 
led develop novel algorithm called specificity parsing scannerless top parser ambiguities resolved notions specificity 
stage remainder input string confronted set candidates sentential forms stemming di erent right hand sides productions 
candidate suggests token specific wins 
candidates accept token suggest action take specific action wins 
action performed candidates agreed choice survive challenge round 
method parsing tailored intended applications languages extended di erent programmers 
requires syntax written natural style errors ambiguities explained sensibly terms individual productions added 
employ top approach course handle left recursive nonterminals apart restriction productions may written quite intuitive manner 
new production added statically decide may cause ambiguities subsequent parsing 
furthermore error messages phrased locally terms added production 
transformations specified relative source target language imported files 
production source language instrumented transformation rule 
parse trees correspond brabrand schwartzbach nonterminals right hand side inductively subjected transformations results inserted template constructs parse tree target language 
transformation rules may accept parse trees arguments produce parse trees results 
users specify transformations extended language core language source production identity default transformation rule 
important characteristics notion transformations 
designed allow elaborate founded induction termination ensured 
second statically decide transformation guaranteed map grammatically legal input grammatically legal output 
third rules expressive allow sophisticated transformations rearrange trees non local manner 
tool accepts arguments transformation term input language 
analyze source target grammars transformation rules provide error diagnostics construct corresponding term target language 
related main bodies relate parser generators macro processors compiler generators 
di er parser generators javacc lex yacc family automatically instrumenting generated parser powerful syntactic macro processor similar earlier hardwired language 
formally parsing algorithm incomparable ll lr parsers claim unique benefits outlined 
traditional parser generators allow productions instrumented action code allow inductive transformations 
basis safety guarantees able provide 
case action code emulated performing transformation java code executed guarantees syntactic correctness course 
regarding macro processors refer comprehensive survey provide 
tool unique simultaneously parameterized grammar host language providing strong safety guarantees 
compiler generators wider ambitions supporting specifications full scale compilers including static dynamic semantics 
invariably involves turing complete computations parse trees course precludes level safety guarantees 
extensible grammars share aims ways 
resulting tool parser generator allows subsequent extensions language desugared original language 
ers safety guarantees similar handle arbitrary source target brabrand schwartzbach languages provides expressive transformations 
system closely compares compiler generator asf sdf 
uses scannerless generalized lr parser produce forest parse trees continually filtered transformed respect set rewrite rules 
result hoped single normalized parse tree 
imaginative rewriting syntactic encodings possible construct complete compilers including symbol tables type checking code generation 
course possible encode kinds transformations supports 
source target languages possible encodings define transformations rewritings combined language st asf sdf statically guarantees rewrite step respect grammar kinds termination problems 
transformation may loop statically determined rewritings turing complete 
second transformation may terminate soon leaving unprocessed pieces input language 
undecidable determine problem may occur 
parser algorithms di erent characteristics 
generally asf sdf parser generates forest parse trees undecidable filtering results single tree 
scannerless processing character separate token results overhead 
comparison tokenize input string ordinary dfas selected dynamically parser context 
asf sdf parser running time depends number parse trees produced 
parser guaranteed run linear time course restricted certain class grammars 
summary domain specific language focusing syntactic transformations subset compiler generator applications ering advantages terms flexibility safety ciency 
parsing mentioned place key emphasis extensibility want di erent kinds users able incrementally add new productions new user defined terminals nonterminals 
achieve language designers read grammar find hooks new extensions transformations may attached 
requires grammar phrased natural style 
additionally error messages involve part grammar written user 
requirements satisfied common parsing strategies 
lr family bottom parsing algorithms unable provide localized error messages 
consider example yacc version lalr grammar java contains production synchronized expression statement brabrand schwartzbach tried allow synchronization multiple objects adding production synchronized expression expression statement yacc tool reacts producing shift reduce reduce reduce errors 
errors occur parser states corresponding inserted production seemingly arbitrary places involving nonterminals 
reason avalanche non local errors lalr parser errors arise terms table derived grammar terms grammar 
necessary rewrite grammar natural style 
evident ll family top parsing algorithms example productions class class identifier 
class identifier extends identifier 
rewritten intuitive form class class identifier 
extends identifier susceptible extension nonterminal instance concept anonymous classes class 
syntax may subsequently added 
contrast earley algorithm generalized lr parsing allow grammar sacrifice linear time processing 
ignore ambiguities constructing parse trees choosing right requires non local reasoning 
goal obtain cient parsing algorithm allows productions added incrementally locally statically detects reports ambiguity errors 
specificity parsing specificity grammar tuple finite set symbols known alphabet reg finite set regular languages known set terminal languages finite set nonterminals start nonterminal production function identifying grammar rules nonterminal 
definition resembles definition context free grammars explicit notion lexical structure described separately set terminal languages separation plays crucial role specificity parsing works brabrand schwartzbach integrated levels lexical syntactic notion specificity deterministic ambiguity resolution independent definition order 
terminal languages induce lexical specificity relation deterministically select terminal language input tokenization case multiple choices 
specifically lexical specificity relation lex see appendix defined triples comprised terminal languages concrete input tokens remainder input 
lexical specificity ordering defined lexicographical composition longest consumable token terminal regular language inclusion 
hardwired preference longer tokens due general consensus programming languages evident scanner generators lex 
simplicity terminals assumed include empty string amended minor modifications algorithm 
lexical layer rest parser handles syntactic aspects notion head sets see appendix resemble sets sets terminal languages nonterminals contrast set subset special terminal represents sentential form included head set token path 
head sets induce syntactic specificity relation sentential forms deterministically pick production multiple choices 
specifically syntactic specificity relations syn see appendix defined terms head set inclusion 
nonterminals head sets order define relation guide parsing nonterminal gaps introduced section 
consequence nonterminals ordered related token path happen related head terminals 
specificity parsing algorithm specificity parsing algorithm evaluate section 
algorithm depicts steps called specificity parsing challenge round set sentential forms confronted input string 
algorithm parses input possible returns remainder input 
steps lexical level defining context sensitive scanner determines comprised terminal language actual input token remainder input token consumed 
calculate union head sets sentential forms defined appendix 
set corresponds looking terminals brabrand schwartzbach algorithm specificity parsing algorithm parse 
head set find head sets 
find possible 

return return option 
error issue error message 
select sent 
form 
specific terminal select best 
head set find applicable sent 
forms 
specific entity select best head entity 
case parse winner entity 
consume input token 
parse parse recursively 
advance tails head 
return parse parse challenge round 
directions current parsing context 
context sensitive terminals visible current parsing context considered 

set visible terminals determine set terminals applicable current input string capable consuming input remains 

case applicable terminals cases 
empty sentential form option parsing return previous challenge round parse 
get sentential form parser stuck generate error message containing precisely set terminals expected current position parser 

select guided sentential form 

set possible non empty select specific lexical specificity see appendix uniqueness specific choice statically ensured section 
steps syntactic level responsible parsing challenge round determining entity parse round reacting appropriately 
rest input parse left 
determine non empty set sentential forms capable brabrand schwartzbach consuming winner terminal 
set applicable sentential forms select specific ones syntactic specificity see appendix defined terms inclusion sentential form head sets 
may di erent sentential forms head set head element unique extracted uniqueness statically ensured section 
ready parse winner head entity terminal nonterminal 
winner entity terminal consume input token assigning remainder input rest input parse head set cf 
step know 
winner entity nonterminal recursively parse production right hand sides 
steps prepare parse challenge round 
advance parser see appendix extracting tails sentential forms winner entity head resulting set may elements 

recursively parse challenge round surviving set sentential form tails 
evaluation evaluate specificity parsing algorithm respect flexibility safety ciency 
flexibility important advantage specificity parsing extensibility 
lexical syntactic specificity deterministic disambiguation mechanisms provide local conflict resolution extensions local ect errors guaranteed involve locally extended parts grammar 
specificity selection independent definition order language composition symmetric language modules may loaded order 
properties permit incremental modular grammar design grammar level parsing reasoning disambiguation 
specificity parser operates relative set sentential forms syntax conveniently overloaded addition syntactic variants anonymous classes section 
specificity parsing scannerless scanner implicitly synthesized grammar 
alleviates tedious error prone tasks manually keeping state correspondence scanner parser lex correspondence emulated notion start conditions 
having truly context sensitive scanner avoids meaning keywords necessarily global di erent parts program may dif brabrand schwartzbach ferent keywords 
languages di erent constituent dsls 
previously mentioned scanner may extended cope terminals containing empty string 
safety perform static analyses grammars nlr intercepts left recursion checks nonterminals finite derivations ensures lexical syntactic specificity unique final winners 
specificity grammar wellformedness safety checks formalized appendix left recursion wellformedness check nlr ensures termination parsing strategy essentially making sure parser unable nonterminals consuming input 
termination obtained fact grammar input finite 
derivability check implications safety just included convenient sanity check 
unique specificity winner check guarantees parser deterministic choice terminals productions 
ciency grammar algorithm parses input linear time backtracking 
section show add controlled backtracking compromising time bound 
challenge round unique winner step parser commits entity state explosion 
head set unions step statically precomputed finitely challenge round parser positions 
information statically factor dynamic syntactic specificity checks topologically sorting productions partial ordering 
parse time algorithm may test sequence dispatch applicable entity 
scannerless parser retains ciency benefits approach employing minimized deterministic finite automata dfas deciding regular language membership 
fact regular expressions may compiled big dfa accepting states annotated set applicable terminal languages 
head set terminals visible current parser context scanner may run big automaton input determine current states accepting intersection terminal sets 
terminal sets may represented bit vectors topologically ordered precomputed regular expression language inclusion 
intersection bitwise disjunction dfa acceptance numeric non zero specific terminal position bitvector 
recursive parser calls step consume input increase head sets steps may cached brabrand schwartzbach terminal wins 
global analysis grammar may lead optimization inlining nonterminals 
comments whitespace comments whitespace handled special terminal omit may assigned regular expression tokens omit 
di erent parts program may di erent omit structure omits global ect bound subsequently defined nonterminals implicitly added entities sentential forms 
terminal whitespace 

omit fragment defines java omit structure discarding standard whitespace multi line comments line comments 
binary infix regular expression operator convenient construction defined added self application 
omit construction defaults regular expression whitespace defined 
example lambda calculus simple extensions untyped lambda calculus show complete contents files 
basic syntax defined language lambda terminal id nonterminal exp exp id lambda apply extend base language numerals simply adding required productions language extends lambda exp zero succ succ pred pred attractors consider subset java grammar brabrand schwartzbach language statement decl exp declaration var expression id language statically intercepted see appendix produces error specificity clash statement decl vs exp round reason discern statement decl statement exp looking terminal 
solve rearranging grammar introducing nonterminals introduce limited form lookahead concept attractors 
syntax terminal language nonterminal integer constant 
attractors placed right hand sides productions example statement decl solves problem 
parser successfully consume specified prefix input string case tokens declaration backtracks continues rest sentential form disregarding candidates 
attractor fails candidate removed 
statically check attractors correspond disjoint prefixes ambiguity introduced see appendix 
notation preferable explicit alternative updates grammar automatically reflected 
attractors evaluated ciently running ordinary parsing algorithm maintaining counter tokens consumed 
note complete parsing algorithm remains constant time lookahead bounded constant traps computing head sets sentential forms including attractors rule head set head set 
allows attractors traps 
illustrate consider standard java grammar causes problem parsing algorithm 
operator prefix operator higher precedence 
means expression parsed correctly exp steal get parse error 
solution add conjunction attractor terminal forces consume empty string 
different situation arises switch statements parsing branch brabrand schwartzbach terminate case construct statement switch switch statements case case case happen case recognized identifier belongs head set statements 
solution apply trap terminal case statements mechanism exclude keywords identifiers specific parts grammar 
transformation transformations typed input output languages transform syntactically legal input terms syntactically legal output terms 
input term steps performed parsed produce syntax tree input language secondly input tree subjected syntax tree transformer producing syntax tree output language output tree unparsed see section output syntax produce output term 
actual transformer run parse trees input language production kind dispatches corresponding rule syntax tree transformer names immediate constituent parse trees inductively applies transformers transformed results resulting output syntax tree 
order specify result syntax trees output terms augmented place holder gaps inductively transformed terms extend algorithm parse relative gap environment formalized appendix 
gap environment maps finite set gap names gap types terminals nonterminals 
example illustrates basic concepts transformation numeral extensions calculus transforming basic lambda calculus lambda 
line names transformation lambda specifies type designating source target languages instructs load language definitions 
second line declares transformer action specifies source target nonterminals respectively belonging source target languages called exp example 
comes actual rules transform exp syntax tree lambda exp rule production source nonterminal 
individual rule parts brabrand schwartzbach example transformation lambda transformation lambda lambda transform exp exp id lambda apply zero succ pred productions bindings inductive transformers result construction production name binding part naming constituent terminal nonterminal variables number inductive transformer applications result construction part 
consider second rule succ 
rule name succ refers production name source nonterminal exp production terminal nonterminal variable nonterminal bound binder part rule names inductive transformer part means syntax tree contained inductively subjected transformer produce output syntax tree named result transformer rule obtained inserting syntax tree held result construction place holder gap lexical transformation terminals source target languages need related way 
syntactic transformation perform lexical transformations 
example specification transform esc string pcdata transform escape pcdata esc escape transformers typed terminal languages 
case processing token specific input terminal chosen 
brabrand schwartzbach structural restrictions apply transformation rules 
input productions required constitute regular grammar output productions constitute regular left linear grammar 
ensures compute regular languages describing possible input output strings 
provide desired static safety guarantee check languages appropriate contravariant relationship declared source target terminal languages 
evaluation divided evaluation flexibility safety ciency 
flexibility transformations su ciently expressive handle useful cases 
course limited compared turing complete alternatives 
note perform linear transformations output term may exponentially larger input term 
liberal grammar structure parsing algorithm allows essential specify transformations 
forced write class extends extends simple straightforward simple class extends class extends specify independent transformations kinds classes 
inherent extensibility helps structuring transformations 
safety transformations statically checked type safe respect input output languages 
done parsing right hand sides transformations relative environment mapping place holder gaps terminals nonterminals 
termination guaranteed inductive transformations invoked subtrees 
ciency transformation input transformation runs optimal time 
current implementation prototype parsing ample opportunities optimizations 
brabrand schwartzbach default transformations macro mechanism source extension target language want write transformations extended syntax 
take measures 
tool defines identity transformers name nonterminals overlapping productions 
second provide short hand notation name nonterminal type naming transformer possibly generated default 
lambda calculus transformation written transform lambda lambda exp zero succ pred measures achieved self application tool 
unparsing control unparsing augmented production right hand sides pretty print directives ignored parser increasing indentation newlines decreasing indentation newlines inserting newlines followed indentation whitespace printing sentential form entities default 
convenience directives may grouped sequentially examples illustrate sketching number small larger examples 
full details examples available project web site www brics dk 
lambda extensions continuing lambda calculus add syntax booleans language extends exp true true false false extend desugaring accordingly transformation exp true false brabrand schwartzbach example course extended full language operators functions 
java extensions substantial examples involve full java syntax 
grammar copied directly language definition ebnf constructions desugared away 
full grammar contains nonterminals productions 
specificity parser reported specificity clashes places added attractors traps disambiguate grammar 
extension add foreach construction language foreach extends java statement foreach foreach desugared corresponding small transformation transformation foreach java foreach java statement foreach xt xe xs iterator iterator iterator iterator hasnext iterator larger java extension originates project uses domain specific syntax manipulate xml fragments web services 
extension involves numerous modifications various levels java grammar 
small part introduces new operator xml fragment values language extends java nonterminal plugs plug plugs uses transformation produce nested invocations plug method transformation java java transform plugs plugs plug xe xp brabrand schwartzbach plugs xe xe xp example shows need multiple transformations 
extend java hypothetical mechanism reserving named resources 
avoid deadlock sequence released opposite order acquired 
java extension looks follows language reserve extends java nonterminal identifiers statement reserve reserve identifiers transformation defined follows transformation reserve java reserve java transform identifiers statement transform rels identifiers statement statement reserve xa xs rels xr xa rels rels xr release java enumerations example involving arguments transformers definition enumeration types java language enum extends java declaration enum enum transformation uses argument build appropriate enumeration constant expressed simple sums transformation enum java enum java transform enums expression identifiers declarations declaration enum enums static final int enums empty brabrand schwartzbach enums static final int questionnaires complete example domain specific language involves online questionnaires 
defined syntax asking series questions fixed number options possible answers 
dependency relation ensures question may asked questions certain answers 
defined transformation mentioned extension java turn generates customized interactive web service permits users answer questionnaires administrators view statistics 
self applications observed occasions applying 
defined transformation html syntax provides online documentation files style javadoc 
transformations interesting 
common cases language extensions desugared tool provides useful default transformations productions 
mentioned section defined explicit preprocessing defined transformation 
similarly extend syntax grammars include ebnf right hand sides 
ambitious self application introduces explicit directives precedence associativity operators 
semantics transformation basic language 
plan implement optimizations mentioned section interpreting code generate parser uses tables control flow embedded dfas 
resulting parser obtain performance comparable lex yacc combinations 
want create typed algebra languages transformations allowing operators products compositions 
extends mechanism induce subtype relation 
possible allow transformations symbol tables derived links retaining safety guarantees 
extend expressive power considerably enable transformations read write brabrand schwartzbach typed trees links 
provide alternative characterizations class languages specificity parsing recognize 
tool provides flexible safe cient means parsing performing syntactic transformations designed special emphasis extensibility 
implementation available lines java code opensource license 
lex 
elegant compiler generator system 
attribute grammars applications volume lncs 
springer verlag 
claus brabrand anders mller michael schwartzbach 
project 
acm transactions internet technology 
see dissertation chapter 
claus brabrand michael schwartzbach 
growing languages metamorphic syntax macros 
proc 
acm sigplan workshop partial evaluation semantics program manipulation pepm january 
luca cardelli florian matthes martin abadi 
extensible syntax lexical scoping 
src research report 
simon christensen anders mller michael schwartzbach 
extending java high level web service construction 
technical report rs brics march 
earley 
cient context free parsing algorithm 
cacm 
gray levi sloane waite 
eli complete flexible compiler construction system 
cacm 
sriram sankar 
javacc java grammar 
www cs ucla edu pub javacc java 
friedrich wilhelm 
gentle compiler construction system 
oldenbourg verlag 
van den brand visser 
disambiguation filters scannerless generalized lr parsers 
proc 
compiler construction 
springer verlag 
brabrand schwartzbach van den brand van deursen heering de jong de jonge kuipers klint moonen olivier visser visser 
asf sdf meta environment componentbased language development environment 
proc 
compiler construction 
springer verlag 
brabrand schwartzbach specificity grammar finite set characters alphabet reg finite set regular languages finite set nonterminals start nonterminal production function head sets epsilon definitions epsilon epsilon determine entity sentential form derive empty string epsilon epsilon false functions satisfying epsilon false epsilon epsilon true epsilon epsilon head sets head set head set head set functions satisfying head set head set head set head set epsilon head set head set epsilon head set head set advance advance advance brabrand schwartzbach advance advance advance specificity relations lexical specificity relation lex defined lex syntactic specificity relations syn defined head set head set syn head set head set specificity grammar wellformedness nlr left recursion requirement ensures termination parser 
nlr nlr false functions satisfying nlr nlr nlr true true nlr epsilon nlr nlr epsilon derivability just sanity check ensure nonterminals derive 
der false functions satisfying brabrand schwartzbach der der true der der unique specificity winner ensures challenge round unique final entity winner 
defined false true true spec head set head set spec defined spec attractor disjunction prefix prefix specificity parsing gaps set gap names extend algorithm parse relative gap environment input expected gap select gap steps gap unexpected gap skip past gap steps gap wrong gap type 
