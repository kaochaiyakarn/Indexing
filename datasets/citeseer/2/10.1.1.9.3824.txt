shortest path algorithms engineering aspects andrew goldberg star lab technologies patrick henry dr santa clara ca usa 
goldberg com 
review shortest path algorithms multi level bucket data structure discuss interplay theory engineering choices leads cient implementations 
experimental results suggest heuristic adaptive parameter selection give cient algorithm typical hard inputs wide range arc lengths :10.1.1.10.3772
common ways evaluate algorithm performance worst case analysis average case analysis experimental evaluation 
ective way evaluate algorithm approaches 
algorithm engineering combines theoretically justified ideas common sense heuristics experimental feedback develop cient robust code 
study important problem finding shortest paths source vertices directed graph nonnegative arc lengths nsp problem 
problem studied 
worst case bounds problem long history see 
currently best bounds 
denote number vertices arcs input graph respectively 
input arc lengths integral denote maximum arc length 
denote ratio biggest smallest nonzero arc lengths 
pointer model computation get log time bound 
ram model word operations fastest currently known algorithms achieve bounds log log log log log log log log 
special case graph undirected thorup algorithm runs linear time 
average case results nsp problem interesting apply natural input distributions potentially practical algorithms 
particular shows relatively weak assumptions input distribution average case bound binary heap implementation dijkstra algorithm better worst case bound 
mayer shows problem solved linear average time input arc lengths independent uniformly distributed 
goldberg shows simple modification algorithm yields algorithm average running time uniform arc length distribution independence assumption :10.1.1.10.3772
refer algorithm smart queue algorithm :10.1.1.10.3772
computational nsp problem received lot attention see 
leads general agreement problem solved practice 
show close existing nsp algorithm implementations practical lower bound 
focus attention nsp algorithms multi level bucket mlb data structure variants 
data structure originally proposed fox 
enhancements proposed 
long time folklore originating original fact computer memories small mlb data structure competitive practice 
cherkassky followup suggest level mlb variants competitive problems 
review mlb data structure discuss implementation mlb data structure takes advantage newer theoretical results improves previous implementations 
discuss implementation smart queue version algorithm 
experimental results show smart queues mlb algorithm large number levels practical 
particular implementation number levels optimized worst case theoretical performance works typical bad case inputs 
example bit arc lengths code runs time times breadth search hardest problems able construct 
results lead better understanding nsp algorithm implementations show close performance lower bound provided breadth search 
multi level bucket data structure assuming reader familiar labeling method see dijkstra algorithm review mlb algorithm related results 
details see :10.1.1.10.3772
mlb structure implements priority queue operations insert decrease key extract min 
bucket structure parameters number levels base 
level structure contains regular levels special top level 
input graph maximum arc length parameters related log 
top level level contains buckets 
conceptually top level contains infinitely buckets 
show consecutive top level buckets nonempty time maintain buckets 
denote bucket level ranges bottom level top ranges 
bucket contains set vertices maintained doubly linked list 
maintain lower bound distance labels labeled vertices 
initially 
time extract min operation removes vertex set distance label consider base representation distance labels number digit positions starting significant digit 
show significant digits base representation uniquely determine 
define position vertex respect respectively truncated significant digits 
index significant digit di er match 
digit position say position 
inserted inserted 
vertex store position 
bucket corresponds range values depends suppose position 
say belongs range width bucket level equal bucket contains distinct values 
compute position vertex constant time 
gives simple constant time implementation insert decrease key operations 
implement extract min operation find lowest nonempty level nonempty bucket level 
starting bucket range contains scanning consecutive buckets nonempty 
level bottom level delete return vertex 
expand bucket finding deleting vertex smallest label bucket setting distance label vertex moving remaining vertices new locations 
important fact vertices lower levels 
analysis algorithm amortizes vertex scans scanning empty buckets involved moving vertices bucket expansion operation 
theorem 
algorithm runs time number empty bucket scans number times vertices move bucket lower level bucket 
charge scanning empty buckets vertex algorithm finds scans immediately get bound 
fact vertices move lower levels implies kn bound 
improve ciency balance 
worst case analysis point view setting minimizes running time 
log log log algorithm runs log log log time 
discuss heuristics improve mlb algorithm performance 
define vertex minimum length arc entering infinity arc enters say distance label labeled vertex exact label equal distance source vertex 
lemma implicit explicitly stated :10.1.1.10.3772
lemma allows relax dijkstra minimum distance label selection rule maintaining invariant vertex scanned 
lemma 
suppose nonnegative lower bound distance labels labeled vertices 
vertex 
exact 
previous implementations mlb algorithm described wide bucket heuristic 
smallest nonzero arc length pick mlb algorithm remains correct multiplies bucket width level heuristic algorithm needs log log levels replace time bounds 
heuristic uses lemma detect scan vertices exact distance labels :10.1.1.10.3772
heuristic modify mlb algorithm keep labeled vertices places set priority queue implemented mlb structure 
refer modified algorithm smart queue algorithm 
high level algorithm works follows 
vertices exact distance labels 
nonempty remove scan vertex empty remove scan vertex minimum distance label 
suppose distance label vertex decreases 
note belong belongs apply decrease key operation operation relocates discovers distance label exact moves apply insert operation inserted depending lemma applies 
heuristic provably improves algorithm performance certain input distributions 
example constant arc lengths distributed uniformly arcs expected running time mlb algorithm heuristic 
algorithm implementations implemented variants mlb algorithm 
mb code implements algorithm wide bucket heuristic sq code adds heuristic 
discuss codes engineering considerations involved development 
implementation mb similar details insert operation :10.1.1.10.9520
previous implementation maintained range distance values level updating ranges value changed 
insert vertex looks lowest level vertex belongs computes set bucket vertex belongs 
mb implementation computes vertex position respect described 
slightly cient number levels large 
ciency gain bigger sq necessarily examine levels value new implementation simpler old 
set power 
allows bit shifts divisions 
codes set biggest power exceeding array represent level buckets 
give mb parameter 
mb sets input arc lengths 
refer code number levels set mb code set mb 
extreme cases study 
study single level case needed memory time 
alternatively mb chose values input 
refer adaptive variant mb 
adaptive variant algorithm uses relationship suggested worst case analysis 
chose constant hidden location observe 
examining empty buckets involves looking single pointer locality properties access buckets sequentially 
moving vertices lower levels hand requires changing pointers poor locality 
suggests substantially greater experiments confirm 
detail mb sets follows 
find smallest value power set 
point may larger need 
reduce 
reduce typically leads works tests 
obtain sq code adding heuristic mb 
modification mb relatively straightforward 
stack implement set needed heuristic 
adaptive variant code sq uses procedure set mb 
experimental methodology setup moret shapiro baseline code breadth search bfs case measure running times shortest path codes input relative bfs running time input 
bsf code computes distances shortest path tree unit length function 
breadth search problem simple special case nsp modulo bfs implementation ciency bfs running time lower bound nsp codes 
baseline running times give indication close optimal running times removes dependencies low level implementation architecture details 
dependencies particular cache dependencies remain 
codes put arc vertex records consecutive locations 
input ids vertices determine ordering memory 
general breadth search examines vertices di erent order nsp algorithm 
may cases lead di erent caching behavior codes certain vertex orderings 
deal dependency input ids generators permute ids random 
problem generators randomized 
input problem type set parameter values run corresponding generator times report averages 
report baseline bfs time seconds times units bfs time 
addition count operations determine theo rem 
operations give number operations divided number vertices amortized operation cost immediate 
kinds operations count examinations empty buckets number vertices processed bucket expansion operations 
bit integers internal representation arc lengths distances 
graph contains paths longer codes may get overflows 
note bit input arc lengths overflow happen number vertices exceeds fit memory modern computers 
experiments conducted mhz pentium iii machine memory cache running redhat linux 
shortest path codes baseline code written style compiled gcc compiler optimization option 
bfs code uses data structures mlb code 
problem families report data problem families produced problem generators 
interested ciency shortest path data structures restrict study sparse graphs data structure manipulation time apparent 
generator builds hamiltonian cycle adds arcs random 
generator may produce parallel arcs self loops 
arc lengths chosen independently uniformly 
vertex source 
number arcs large graphs expanders average number vertices priority queue shortest path computation large 
generate problem families rand rand 
families 
rand increases factor set parameter values 
chose initial value large running time final value large possible subject constraint codes run paging 
rand starts takes integer multiples 
minimal arc length test inputs 
greater inputs 
greater 
note expected value fff ff ff fig 

example hard problem instance 
arc lengths hexadecimal 
omit extra vertex arcs designed manipulate vertex 
change results similar 
second generator produces grid graphs 
grid graph contains vertices vertex connected adjacent vertices layer mod mod 
addition vertex connected vertex 
arc lengths chosen independently uniformly 
vertex source 
generate problem families long long 
families contain long grid graphs large 
graphs average number vertices priority queue small 
long long problem families similar randi rand families 
long increases factor value yields reasonable running time maximum value cause paging 
long problem family uses values rand problem family reasons 
problem generator 
generator produces problems aimed hard mlb algorithms certain values 
graphs produced generator consist paths source connecting path 
see example 
paths number arcs adjusted get graph desired size 
path arcs length 
lengths source arcs follows 
arc zero length 
remaining arcs arcs base representation 
digits remaining digits 
arcs digits th digit remaining digits 
graph contains extra vertex incoming arcs connected vertex graph 
length arc connecting vertex bfs mb sq mb sq mb sq time emp sec 
exp time emp sec 
exp time emp sec 
exp time emp sec 
exp time emp sec 
exp bfs mb sq mb sq mb sq time emp sec 
exp time emp sec 
exp time emp sec 
exp time emp sec 
exp time emp sec 
exp table 
rand left long right family data source zero sure minimum arc length zero 
lengths arcs 
lengths zero force vertex zero large determined arcs 
note generator parameters produces input adaptive codes may select di erent parameters 
log problem produced bit lengths 
lengths determine parameters selected adaptive codes 
problem families study hard hard hardest sq 
problem families di er length arcs determine vertex length large family zero second 
problems family approximately vertices number arcs approximately problems 
create problem family chose generate problem hard mb levels 
exclude 
problem approximately vertices 
problems family di er values 
values selected generator adaptive codes parameters 
experimental results previous suggests mb performs problems large arc lengths 
experimental results confirm bits bfs mb sq mb sq mlb sq time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp bits bfs mlb sq mlb sq mlb sq time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp table 
rand left long right family data suggest heuristic combined adaptive selection parameters leads robust code 
empty bucket scans cause bad performance mb 
example data table shows mb performs similarly sq small code faster large 
hard hard problems table show worst case di erence huge 
compare performance mb sq codes 
data hard hard problems table shows heuristic give significant savings number operations savings 
case sq faster mb 
case sq little slower 
looking uniform arc length data tables see heuristic provides significant improvement number levels large theoretical analysis bfs mb sq time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp bfs mb sq time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp bits log bfs sq time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp time emp 
sec 
exp table 
hard left hard center hard sq right data 
predicts 
heuristic bucket structures levels practical 
particular sq practical 
number empty bucket examinations vertex moderate amortized operations vertices noticable ect running time 
number operations reaches vertex ect 
see table 
table shows processing vertices bucket expansion expensive 
processing vertex influences running time scanning empty buckets 
observations justify choice adaptive algorithms 
hard problems table illustrate adaptive selection important worst case point view 
bit lengths hard hard problems adaptive codes set 
far typical performance goes adaptive codes significantly slower significantly faster corresponding nonadaptive codes 
see table 
concluding remarks data suggests heuristic mlb algorithm adaptive parameter selection practical 
hardest problem input arc lengths fit bit words running time sq factor running time breadth search 
conjecture input code run longer baseline code factor problem size bigger cache size smaller memory size 
real life problems code run factor baseline code 
experimented hot queue version code 
give details due lack space code performs better sq bad case problems typical problems 

ahuja mehlhorn orlin tarjan 
faster algorithms shortest path problem 
assoc 
comput 
mach april 

van emde boas 
design implementation cient priority queue 
math 
systems theory 

cherkassky goldberg 
negative cycle detection algorithms 
math 
prog 

cherkassky goldberg 
shortest paths algorithms theory experimental evaluation 
math 
prog 

cherkassky goldberg silverstein 
buckets heaps lists monotone priority queues 
siam comput 

fox 
shortest route methods 
reaching pruning buckets 
oper 
res 

dial 
algorithm shortest path forest topological ordering 
comm 
acm 

dial glover 
computational analysis alternative algorithms labeling techniques finding shortest path trees 
networks 

dijkstra 
note problems connexion graphs 
numer 
math 

dinic 
economical algorithms finding shortest paths network 
yu editors transportation modeling systems pages 
institute system studies moscow 
russian 

ford 
network flow theory 
technical report rand 

ford jr fulkerson 
flows networks 
princeton univ press princeton nj 

fredman tarjan 
fibonacci heaps uses improved network optimization algorithms 
assoc 
comput 
mach 

fredman willard 
trans dichotomous algorithms minimum spanning trees shortest paths 
comp 
syst 
sci 

gallo pallottino 
shortest paths algorithms 
annals oper 
res 

glover glover 
computational study improved shortest path algorithm 
networks 

goldberg 
simple shortest path algorithm linear average time 
technical report star tr star lab tech santa clara ca usa 

goldberg silverstein 
implementations dijkstra algorithm multi level buckets 
pardalos hearn editors lecture notes economics mathematical system refereed proceedings pages 
springer verlag 

hagerup 
improved shortest paths word ram 
th int 
colloq 
automata languages programming geneva switzerland pages 

johnson 
cient algorithms shortest paths sparse 
assoc 
comput 
mach 

meyer 
single source shortest paths arbitrary directed graphs linear average time 
proc 
th acm siam symposium discrete algorithms pages 
full version available tr mpi max fur informatik germany 

moret shapiro 
empirical analysis algorithms constructing minimum spanning tree 
proc 
nd workshop algorithms data structures 


theorem expected complexity dijkstra shortest path algorithm 
algorithms 

raman 
fast algorithms shortest paths sorting 
technical report tr king london 

raman 
priority queues small monotone trans dichotomous 
proc 
th annual european symposium algorithms pages 
springer verlag lect 
notes cs 

raman 
results single source shortest paths problem 
sigact news 

tarjan 
data structures network algorithms 
society industrial applied mathematics philadelphia pa 

thorup 
undirected single source shortest paths positive integer weights linear time 
assoc 
comput 
mach 

thorup 
ram priority queues 
siam journal computing 

williams 
algorithm heapsort 
comm 
acm 

zhan noon 
shortest path algorithms evaluation real road networks 
transp 
sci 
