llva low level virtual instruction set architecture vikram adve chris lattner michael anand shukla brian computer science department university illinois urbana champaign lattner cs uiuc edu virtual instruction set architecture isa implemented processor specific software translation layer provide great flexibility processor designers 
examples crusoe daisy existing hardware instruction sets virtual isas complicates translation optimization 
fact little research specific designs virtual isa processors 
proposes novel virtual isa llva translation strategy implementing arbitrary hardware 
instruction set typed uses infinite virtual register set static single assignment form provides explicit control flow dataflow information uses low level operations closely matched traditional hardware 
includes novel mechanisms allow flexible optimization native code including flexible exception model minor constraints self modifying code 
propose translation strategy enables offline translation transparent offline caching native code profile information remaining completely os independent 
supports optimizations directly representation install time runtime offline executions 
show experimentally despite rich information content virtual object code comparable size native machine code virtual instructions expand ordinary hardware instructions average simple translation costs total execution time short runs 

years traditional superscalar processors compilers resort increasingly complex designs small improvements performance 
spurred wide range research efforts exploring novel microarchitecture system design strategies search cost effective long term solutions 
proceedings th international symposium microarchitecture micro ieee outcome far clear clear extensive rethinking processor design begun 
design alternatives microarchitecture system architecture believe important rethink instruction set architecture software sole interface processor 
traditional processor instruction sets jacket hardware software 
provide little useful information program behavior execution engine processor difficult hardware designers develop innovative mechanisms modify instruction sets difficult compiler developers design optimizations require hardware support expressed machine instructions 
fundamental problem instruction set hardware isa different purposes persistent representation software interface primitive hardware operations specified sequenced 

virtual instruction set computers step loosening restrictions research commercial groups advocated class architectures term virtual instruction set computers 
architecture defines virtual instruction set called isa smith terminology user operating system software illustrated fig :10.1.1.19.6586

implementation architecture includes hardware processor instruction set implementation isa isa implementation specific software translation layer translates virtual object code isa 
translation layer hardware processor designed smith refer implementation strategy virtual machine :10.1.1.19.6586
fisher described closely related vision building families processors customized specific application areas maintain compatibility performance software translation 
basic level architecture decouples program representation isa actual hardware interface isa allowing focus cap application software operating system processor specific translator hardware processor kernel virtual isa isa implementation isa isa 
system organization virtual architecture 
similar fig 
fig :10.1.1.19.6586:10.1.1.19.6586
:10.1.1.19.8041
turing program behavior focuses software control hardware mechanisms 
brings fundamental benefits hardware processor design software translation layer 
virtual instruction set include rich program information suitable direct hardware implementation independent implementation specific design choices 

isa translator provide truly cooperative hardware software design translator provide information hardware implementation specific mechanisms instruction encodings hardware expose novel microarchitectural mechanisms allow cooperative hardware software control assist translator 
fundamental benefits exploited potentially unlimited ways processor designers 
prior discussed potential hardware design options enabled approach impractical conventional architectures :10.1.1.19.6586:10.1.1.13.7848
furthermore isa instruction encodings software controlled mechanisms changed relatively easily processor design quite difficult current processors 
cooperative hardware software techniques including examples proposed literature easier adopt 
external compilers focus machine independent optimizations translator serves common back customized processor implementation 
cost increased flexibility possible overhead software translation done online 
advances dynamic compilation program optimization hardware speed mitigate performance penalty idea viable today past 
furthermore hardware mechanisms assist tasks ways :10.1.1.26.786:10.1.1.13.7848
proceedings th international symposium microarchitecture micro ieee 
contribution design virtual instruction set virtual architectures discussed long time real implementations exist viz ibm daisy transmeta crusoe little research exploring design options isa 
daisy crusoe traditional hardware isas isa 
ibm machines specially developed isa explain section extremely complex os dependent requires complex os services translation 
furthermore explain section os dependent design enables translation strategy integrated os impractical os independent designs 
believe careful design isa driven needs compiler technology universal support arbitrary user os software crucial achieve full benefits virtual architecture strategy 
common question java bytecode suggested smith microsoft common language infrastructure cli isa processors :10.1.1.19.6586
processor isa support external user software arbitrary operating systems believe answer 
representations designed certain class languages sufficiently languageindependent processor interface 
include complex runtime software requirements garbage collection extensive runtime libraries difficult implement operating system support 
generally suited low level code operating system trap handlers debuggers performance monitoring tools 
proposes virtual isa called low level virtual architecture llva accompanying translation strategy assume particular hardware support 
specifically contributions proposes isa design rich support sophisticated compiler analyses transformations low level closely matched native hardware instruction sets support external code including os kernel code 
carefully defines behavior exceptions code minimize difficulties faced previous translators daisy crusoe :10.1.1.13.7848
describes translation strategy allows offline translation offline caching native code profile information daisy crusoe os independent interface access external system resources 
developing complete compiler framework link time install time runtime offline idle time optimization ordinary processors essentially code representation :10.1.1.152.2608
discuss translation strategy proposed directly leverage optimization techniques 
virtual instruction set propose uses simple operations fully typed simple languageindependent type system includes explicit control flow graphs dataflow information form static single assignment ssa representation 
equally important isa include fixed register set stack frame layout low level addressing modes limits immediate constants delay slots speculation predication explicit interlocks 
better suited isa isa 
isa low level permit extensive machine independent optimization source level link time compilers java bytecode example reducing amount optimization required translation isa isa 
benefits isa design determined developing new processor design options software hardware techniques exploit potential 
goal evaluate design terms suitability isa 
implemented key components compilation strategy sparc intel ia hardware processors including aggressive interprocedural optimization framework operates isa directly native code generators run offline jit mode software trace cache sparc support trace runtime optimizations 
components address questions qualitatively instruction set rich enable machine independent dependent optimizations code generation 
experimentally instruction set low level map closely native hardware instruction set enable fast translation native code 

design goals virtual isa shows overview system processor 
architecture defines external instruction set isa binary interface specification abi 
implementation architecture includes hardware processor plus translator collectively referred processor external software mean software translator 
translator essentially compiler translates virtual object code isa native object code isa 
proposed system architecture external software may isa 
rigid constraint external software important reasons proceedings th international symposium microarchitecture micro ieee 
ensure hardware processor evolve isa implementation details visible translator changed requiring external software recompiled 

ensure arbitrary operating systems conform abi run processor 
primary consumer isa software translation layer design isa driven understanding compiler technology 
non trivial optimization code generation tasks rely information global control flow dataflow data dependence properties program 
properties extremely difficult extract native machine code 
challenge design isa provides high level information program behavior appropriate architecture interface external software including applications libraries operating systems 
propose set design goals isa 
simple low level operations implemented runtime system serve instruction set arbitrary software enable implementation operating system support isa simple low level operations mapped directly small number hardware operations 

execution oriented features obscure program behavior isa exclude isa features program analysis difficult managed translator limited numbers types registers specific stack frame layout low level calling conventions limited immediate fields low level addressing modes 

portability family processor designs impractical design universal isa conceivable hardware processor designs 
isa design enable broad class processor implementations maintain compatibility level virtual object code processors class key challenges include pointer size 

high level information support sophisticated program analysis transformations high level information important optimizations machine code generation effective instruction scheduling register allocation 
furthermore improved program analysis enable powerful cooperative software hardware mechanisms described 

language independence despite including high level information especially type information essential isa completely language independent types low level general implement high level language operations correctly reasonably naturally 

operating system support isa fully support arbitrary operating systems implement virtual application binary interface abi associated isa discussed section 
provide necessary low level mechanisms traps memory management lowlevel device note high level virtual machines jvm cli fail meet goals complex high level operations large runtime libraries jvm cli tailored object oriented languages particular model complex runtime systems require significant os support practice 
contrast traditional machine isas fail meet goals satisfy limited extent existing programs exploit new hardware instructions larger architected register files 

llva isa high performance 
components isa llva virtual instruction set source low level orthogonal address instruction set 
shows example function corresponding llva code 
basic components instruction set follows 
register set memory model llva uses infinite typed register file registers static single assignment ssa form described 
registers hold scalar values viz boolean integer floating point pointer 
type information ssa representation provide information needed simple aggressive register allocation algorithms 
support infinite register set self extending instruction encoding define fixed size bit format hold small instructions compactness translator efficiency 
memory partitioned stack heap global memory memory explicitly allocated 
llva load store architecture load store instructions access data values memory 
llva instructions llva small orthogonal instruction set consisting instructions listed table 
orthogonality optimal pattern matching instruction selectors easier 
instructions simple address instructions register operands add mul translation process primarily concerned combining multiple llva instructions complex isa instructions proceedings th international symposium microarchitecture micro ieee possible 
furthermore simple low level operations allow arbitrary machine independent optimizations performed ahead time static compilers generating jvm bytecode operations array bounds checks virtual function call resolution inlining difficult eliminate statically 
llva provides low level operations implement high level language features machineindependent manner 
example array structure indexing operations lowered typed pointer arithmetic instruction explained 
source level array bounds checks turned explicit comparisons 
virtual function dispatch pair loads retrieve function pointer followed call optimizations eliminate static compiler translator 
type name arithmetic add sub mul div rem bitwise xor shl shr comparison control flow ret br mbr invoke unwind memory load store getelementptr alloca cast call phi table 
entire llva instruction set global data flow ssa control flow information key feature llva enables efficient dynamic translation ssa form primary representation scalar register values 
ssa form widely compiler optimizations allows efficient sparse algorithms global dataflow problems provides explicit def chains 
represent ssa information directly code llva uses instruction merge values controlflow join points 
example ret value 
translator nodes introducing copy operations predecessor basic blocks 
copies usually eliminated register allocation 
exposing explicit control flow graph cfg crucial feature llva function llva list basic blocks basic block list instructions single control flow instruction explicitly specifies successor basic blocks 
control flow instruction branch multi way branch function return invoke invoke implement source language exceptions stack unwind contrast extracting control flow graph normal machine code quite difficult practice due indirect branches 
quadtree double data quadtree qt void sum qt double double ret ret qt hild double sum child ret data ret example function ing manner explicit portable translated efficient native code :10.1.1.152.2608
llva type system llva instruction set low level source language independent type system 
type system simple consisting primitive types predefined sizes uint float double 
derived types pointer array structure function 
chose small set derived types reasons 
believe high level language data types eventually represented combination low level types class base classes virtual functions usually represented nested structure type data fields pointer constant array function pointers 
second standard language independent optimizations subset types including optimizations require array dependence analysis pointer analysis field sensitive algorithms call graph construction 
instructions isa strict type rules overloaded type add int vs add float 
mixed type operations implicit type coercion 
explicit cast instruction sole mechanism convert register value type integer floating point integer pointer 
important purpose type system enable typed memory access 
llva achieves type safe pointer arithmetic getelementptr instruction 
enables pointer arithmetic expressed directly llva exposing implementation details pointer size 
offsets specified terms type properties field number structure element index array 
quadtree type double qt qt type quadtree void sum qt double double double tmp qt bool br bool tmp tmp children tmp qt long long hild load qt tmp void sum qt child double tmp load double tmp qt long tmp load double tmp ret add double tmp tmp br ret phi double ret double ret double void return corresponding llva code 
llva code function proceedings th international symposium microarchitecture micro ieee example tmp getelementptr instruction calculates address children symbolic indexes 
index result numbering fields structure 
systems bit bit pointers offset pointer bytes bytes respectively 

representation portability noted section key design goal isa maintain object code portability family processor implementations 
llva broadly aimed support general purpose uniprocessors section discusses possible extensions 
designed away implementation details processors including number types registers pointer size stack frame layout machine level calling conventions 
stack frame layout abstracted explicit alloca instruction allocate stack space return typed pointer making stack operations explicit 
example variable allocated stack virtual register address taken passing 
practice translator fixed size alloca objects function stack frame compile time 
instruction provides simple calling convention virtual register constant operands 
actual parameter passing stack adjustment operations hidden low level instruction 
pointer size hardware implementation difficult completely away 
typesafe programs compiled llva object code automatically portable exposing isa details 
non type safe code machine dependent code conditionally compiled different platforms requires exposing details actual isa configuration 
reason llva includes flags properties source language compiler expose source program currently pointer size 
information encoded object file information translator different hardware isa correctly execute object code emulation incur substantial performance penalty isas hardware support 

exception semantics previous experience virtual processor architectures particularly daisy transmeta show especially difficult features emulate traditional hardware interfaces load store dependences precise exceptions self modifying code 
llva isa simplifies detecting load store dependences key way type control flow ssa information enable sophisticated alias analysis algorithms translator discussed 
issues opportunity minimize impact isa design 
precise exceptions important implementing programming languages correctly overly complex inefficient code maintaining precise exceptions greatly restricts ability compiler optimizations reorder code 
static compilers knowledge operations cause exceptions load valid global operations exceptions ignored particular language integer overflow languages 
simple isa rules retain precise exceptions expose non excepting operations translator llva instruction defines set possible exceptions caused executing instruction 
exception delivered program precise terms visible state llva program 
llva instruction boolean attribute named 
exceptions generated instruction ignored false instruction exception conditions delivered program 
exceptions enabled true default load store div instructions 
false default operations notably arithmetic operations 
note static attribute provided addition mechanisms provided abi disable exceptions dynamically runtime trap handlers 
second attribute instructions considering allow exceptions caused instruction proceedings th international symposium microarchitecture micro ieee delivered precise 
static compilers languages flag exception conditions memory faults manner allowing translator reorder operations freely hardware supported precise exceptions 

self modifying self extending code term self modifying code smc program explicitly modifies pre existing instructions 
term self extending code sec refer programs new code added runtime modify pre existing code 
sec encompasses behaviors class loading java function synthesis higher order languages program controlled dynamic code generation 
sec generally problematic virtual architectures smc 
furthermore commonly cited examples self modifying code dynamic code generation high performance kernels dynamic code loading operating systems virtual machines really examples sec smc 
smc useful implementing runtime code modifications certain kinds tools runtime instrumentation tools dynamic optimization systems 
llva allows arbitrary sec allows constrained form smc exploits execution model isa 
particular program may modify virtual instructions set intrinsic functions change affects invocations function currently active invocations 
ensures smc implemented efficiently easily translator simply marking function generated code invalid forcing regenerated time function invoked 

support operating systems llva uses key mechanisms support operating systems user space applications intrinsic functions privileged bit 
llva uses small set intrinsic functions support operations manipulating page tables kernel operations 
intrinsics implemented translator particular target 
intrinsics defined valid privileged bit set true causing kernel trap 
trap handler ordinary llva function arguments trap number pointer pass additional information handler 
trap handlers refer register state llva program standard program independent register numbering scheme virtual registers 
intrinsic functions traverse program stack scan stack frames isa independent manner register entry points trap handlers 
isa isa application software code generation kernel execution manager profiling hardware processor operating system static dynamic optimization storage api storage isa code profile info optional translator components 
llva execution manager interface offline storage 

possible extensions isa important kinds functionality added isa 
architecture certainly requires definition synchronization operations memory model support parallel programs 
second packed operations referred subword parallelism valuable media signal processing codes 
operations encoded isa difficult translator automatically synthesize ordinary sequential code 
developing isa extensions provide machine independent abstractions chip parallelism 
extensions valuable explicit chip parallelism prevalent raising potentially serious challenges preserving portability achieving highest possible performance different generations processors 

translation strategy goals translation strategy minimize need online translation exploit novel optimization capabilities enabled rich persistent code representation 
aim develop new optimization techniques 
developing techniques ongoing research part complete framework lifelong code optimization ordinary processors 
focus translation strategy implications optimization capabilities designs 
describing chip runtime execution engine manages translation process 
focus particular strategies interacts surrounding software system get access offline storage enable offline translation 
describe translation strategy exploits optimization capabilities enabled rich persistent code representation 

os independent translation system distinguish scenarios different primary constraints translation system 
processor designed optimized particular os proceedings th international symposium microarchitecture micro ieee customized systems running ibm os 
processor scenario translator live offline storage part os invoked perform offline translation interfaces directly read write translations profile information offline storage 
exploit optimization mechanisms enabled isa described 
processor obtain benefits design need online translation 
commonly processor designed assumptions os available storage 
lack knowledge places constraints translator seen daisy crusoe translation schemes 
entire translator program located rom translated code associated profile information live memory cached persistent storage executions program 
consequently programs translated online launched translation exist memory cache 
propose translation strategy situation enable offline translation caching os ported llva chooses exploit 
developed transparent execution environment called embodies strategy currently implemented user level standard posix system described 
depicted 
translation strategy summarized offline translation possible online translation necessary subset translator sufficient translation set optimizations live rom flash memory processor chip 
invoked 
abi defines standard storage api set routines enables read write validate data offline storage 
os ported llva choose implement routines higher performance strictly optional system operate correctly absence 
briefly basic storage api includes routines create delete query size offline cache read write vector bytes tagged unique string name cache check timestamp llva program cached vector 
routines implemented os linked translator define special llva intrinsic routine recall intrinsic function implemented translator os startup register address storage api routine translator 
api routine called directly translator query addresses api routines startup 
provides simple indefinitely extensible linkage mechanism translator os 
translation process follows 
os loads transfers control llva executable memory invoked processor hardware 
os storage api implemented uses look cached translation code checks timestamp exists reads memory translation date 
successful performs relocation necessary native code transfers control directly 
condition fails invokes jit compiler entry function 
new translated code generated jit compiler written back offline cache storage api available 
idle times os notify perform offline translation llva program initiating execution flagging translation actual execution 
implementation faithful description user level shared library loaded starting shell 
library overrides execve new version recognizes llva executables invokes jit executes cached native translations disk user level version storage api 
jit offline compilers ordinary programs running solaris linux offline compiler reads writes disk files directly 
llva executables invoke native libraries compiled llva library 
storage api allow parts translator live offline loaded needed minimizing portion needs live rom flash memory 
component required correct execution aggressive optimizations live offline installed little os cooperation 

optimization strategy important new optimization opportunities created rich isa code representation architecture exploit difficult programs compiled directly native code :10.1.1.152.2608
include 
compile time link time machine independent optimization outside translator 

install time isa specific optimization translation 

runtime trace driven machine specific optimization 

idle time executions profile guided isa specific optimization profile information reflecting actual user behavior 
noted earlier llva representation allow substantial optimization performed translation minimizing optimization performed online 
optimization link time particularly important time modules application simultaneously available requiring changes proceedings th international symposium microarchitecture micro ieee application makefiles sacrificing key benefits separate compilation 
fact commercial compilers today perform interprocedural optimization exporting proprietary compiler internal representation static compilation 
solutions unnecessary llva retains rich information support extensive optimizations demonstrated 
install time optimization just application translator optimization code generation capabilities generate carefully tuned code particular system configuration 
direct benefit retaining rich code representation software installed retaining ability offline code generation 
trace driven runtime optimizers native binary code dynamo rich isa cooperating code generator :10.1.1.12.7138
isa provides ability perform static instrumentation assist runtime path profiling cfg runtime perform path profiling frequently executed loop regions avoiding interpretation 
lets develop aggressive optimization strategy operates traces llva code corresponding hot traces native code 
implemented tracing strategy software trace cache including ability gather traces developing runtime optimizations exploit traces 
rich information llva enables idle time profile guided optimization translator optimization code generation capabilities 
important advantage step profile information gathered executions user system 
distinct advantages static profile information reflect user behavior hypothetical profile information generated developers predicted input sets developers profile guided optimization limited ways idle time optimization completely transparent users combined low overhead profiling techniques idle time optimization combine profile information detailed information user specific system configuration 

initial evaluation believe performance implications virtual isa design evaluated meaningfully processor design hardware mechanisms support translation optimization preferably basic cooperative hardware software mechanisms exploit design 
key contribution design llva focus evaluating features design 
particular consider questions listed representation enable high level analysis optimizations representation low level closely match hardware translated efficiently 

supporting high level optimizations llva code representation internal representation sophisticated compiler framework call low level virtual machine llvm 
llvm includes front ends gcc code generators intel ia sparc run offline jit compiling functions demand sophisticated link time optimization system software trace cache 
compared instruction set section differences compiler ir compiler extracts type information memory allocation operations converts instructions back ends translate back library calls bit hardcoded instruction opcode 
compiler system uses equivalent internal external representations avoiding need complex translations stage compilation process 
compiler uses virtual instruction set variety analyses optimizations including classical dataflow control flow optimizations aggressive link time interprocedural analyses transformations 
classical optimizations directly exploit control flow graph ssa representation choices pointer analysis 
usually performed module basis linking different llva object code modules performed stage program lifetime llva code available 
perform novel interprocedural techniques llva representation operate link time 
data structure analysis efficient contextsensitive pointer analysis computes accurate call graph points information 
importantly able identify information logical data structures entire list hashtable graph including disjoint instances structures lifetimes internal static structure external 
automatic pool allocation powerful interprocedural transformation uses data structure analysis partition heap separate pools data structure instance 
shown llva representation rich perform complete static analysis memory safety large class type safe programs 
uses techniques plus interprocedural array bounds check removal algorithm custom interprocedural dataflow control flow analyses 
interprocedural techniques listed traditionally considered difficult source level im proceedings th international symposium microarchitecture micro ieee languages impractical machine code 
fact techniques fundamentally require type information pointers arrays structures functions llva plus control flow graph 
ssa representation significantly improves precision speed analyses transformations 
examples amply demonstrate virtual isa rich support powerful language independent compiler tasks traditionally performed source level compilers 

low level nature instruction set table presents metrics evaluate low level nature llva isa 
benchmarks include benchmarks spec cint benchmarks omit spec codes code versions fail link currently 
columns table list benchmark names number lines source code 
columns table show fully linked code sizes statically compiled native executable llva object program 
native code generated llva object program static back sparc 
numbers comparable llva optimizations applied cases 
numbers show virtual object code significantly smaller native code roughly larger programs table smaller programs larger ratios despite containing extra type control flow information ssa form virtual code quite compact reasons 
instructions usually fit single bit word 
second virtual code include verbose machine specific code argument passing register saves restores loading large immediate constants columns show number llva instructions total number machine instructions generated back ratio similarly sparc 
back performs virtually optimization simple register allocation resulting significant spill code 
sparc back produces higher quality code requires instructions risc architecture 
llva instruction translates isa instructions average sparc 
furthermore llva instructions translated directly native machine code emulation routines 
results indicate llva instruction set uses low level operations match closely native hardware instructions 
columns table show total code generation time taken jit compiler gcc compiler generates compact sparc code roughly equal size bytecode :10.1.1.152.2608
program loc native llva ratio sparc ratio translate run ratio size kb size kb inst 
inst 
inst 
time time anagram ks ft yacr bc art equake mcf bzip gzip parser ammp vpr twolf crafty vortex gap table 
metrics demonstrating code size low level nature isa compile entire program regardless functions executed total running time program compiled natively ratio 
table shows jit compilation times negligible large codes short running time 
furthermore behavior extend larger programs jit translates functions demand unused code translated show compilation time entire program data easier understand 
data shows possible fast non optimizing translation llva code machine code low cost 
support translate code offline cache translated code offline reduce impact translation cost 
instruction count ratio jit compilation times show llva isa closely matched hardware instruction sets terms complexity operations previous subsection showed includes high level information sophisticated compiler optimizations 
combination high level information low level operations crucial feature believe llva instruction set design virtual instruction set architecture 

related virtual machines different kinds widely software systems including operating systems os language implementations os hardware emulators 
uses define virtual isa hardware level directly benefit processor design may influence 
challenges important examples java virtual machine microsoft cli processor level virtual isa discussed 
proceedings th international symposium microarchitecture micro ieee know previous examples architectures defined section ibm system family daisy project ibm research smith proposal virtual machines strata project transmeta crusoe family processors :10.1.1.19.6586
distinguish virtual physical isas fundamental processor design technique 
knowledge ibm designed virtual instruction set architectures 
ibm building early ideas defined machine interface mi high level hardware independent registers storage locations 
sole interface application software os 
design differed fundamental ways meet goals laid section 
mi targeted particular operating system os designed implemented complex operating system database services just translator designed best support particular workload class viz commercial database driven workloads 
far complex instruction set cisc processors including string manipulation operations object manipulation operations classes objects programs files 
contrast isa philosophically closer modern processor instruction sets minimal orthogonal load store architecture requires software translator designed support modern static dynamic optimization techniques general purpose software 
daisy developed dynamic translation scheme emulating multiple existing hardware instruction sets powerpc intel ia vliw processor 
developed novel translation scheme global vliw scheduling fast online hardware extensions assist translation 
translator operated page granularity 
daisy transmeta translators stored entirely rom chip 
focus existing isas existing os hardware interface specifications assume os support cache translated code profile information processor storage perform offline translation 
transmeta crusoe uses dynamic translation scheme emulate intel ia instructions vliw hardware processor 
hardware includes important supporting mechanisms shadowed registers gated store buffer speculation rollback recovery exceptions alias detection hardware load store pipeline 
translator called code morphing software cms exploits hardware mechanisms reorder instructions aggressively presence challenging features identified section precise exceptions memory dependences self modifying code memory mapped 
trace driven reoptimization scheme optimize frequently executed dynamic sequences code 
crusoe perform offline translation offline caching noted 
smith strata project clearly articulated potential benefits processor designs particularly benefits translator hardware processor implementation dependent isa :10.1.1.19.6586
describe number examples illustrating flexibility hardware designers derive strategy 
developed hardware mechanisms valuable implementing architectures including relational profiling microarchitecture hierarchical register file instruction level distributed processing hardware support working set analysis 
propose specific choice isa suggest choice java vm isa option discussed 
previous authors developed typed assembly languages goals generally differ significantly 
goals enable compilation strongly typed high level languages typed assembly language enabling sound type preserving program transformations support program safety checking 
type systems higher level attempt propagate significant type information source programs 
comparison isa uses simpler lowlevel type system aimed capturing common low level representations operations implement computations high level languages 
designed support arbitrary non type safe code efficiently including operating system kernel code 
binary translation widely provide bi proceedings th international symposium microarchitecture micro ieee nary compatibility legacy code 
example fx tool uses combination online interpretation offline profile guided translation execute intel ia code alpha processors 
systems architecture binary translation essential part design strategy codes just legacy codes 
wide range software hardware techniques transparent dynamic optimization programs 
transmeta cms dynamo identify optimize hot traces runtime similar reoptimization strategy benefits rich isa :10.1.1.12.7138
jit compilers java self languages combine fast initial compilation adaptive reoptimization hot methods see 
hardware techniques proposed improving effectiveness dynamic optimization 
combined rich isa supports effective program analyses transformations software hardware techniques enhance benefits architectures 

trends modern processors indicate cpu cycles raw transistors increasingly cheap control complexity wire delays power reliability testing cost increasingly difficult manage 
trends favor virtual processor architectures extra cpu cycles spent software translation extra transistors spent mechanisms assist translation cooperative hardware software design supported rich virtual program representation numerous ways reduce hardware complexity potentially increase performance 
llva design languageindependent target independent virtual isa 
instruction set low level map directly closely hardware operations includes high level type controlflow dataflow information needed support sophisticated analysis optimization 
includes novel mechanisms overcome difficulties faced previous virtual architectures daisy transmeta crusoe including flexible exception model minor constraints self modifying code dovetail compilation strategy os independent interface access offline storage enable offline translation 
evaluating benefits llva requires long term research program 
main goals near develop evaluate cooperative software hardware design choices reduce hardware complexity assist translator achieve high performance 
extend isa machineindependent abstractions fine medium grain parallelism suitable mapping explicitly parallel processor designs mentioned section 
port existing operating system incremental steps top llva architecture explore os design implications implementation 
jim smith sarita adve john anonymous referees detailed feedback 
supported nsf ca award eia nsf operating systems compilers program number ccr sia marco focus center program 

adl tabatabai fast effective code generation just time java compiler 
pldi may 
austin pointer intensive benchmark suite 
available cs wisc edu austin html sept 
ayers de jong peyton schooler 
scalable cross module optimization 
acm sigplan notices 
bala duesterwald banerjia :10.1.1.12.7138
dynamo transparent dynamic optimization system 
pldi pages june 
burger goodman 
transistor architectures 
computer sept 
burke 
choi fink grove hind sarkar serrano sreedhar srinivasan whaley 
jalape dynamic optimizing compiler java 
java grande pages 
chen wu appel fang 
provably sound tal back optimization 
pldi san diego ca jun 
chernoff fx profile directed binary translator 
ieee micro 
clark 
application system performance characteristics 
ibm systems journal 
cytron ferrante rosen wegman zadeck 
efficiently computing static single assignment form control dependence graph 
toplas pages october 
transmeta code morphing software speculation recovery adaptive address real life challenges 
proc 
st ieee acm symp 
code generation optimization san francisco ca mar 
smith 
managing hardware dynamic working set analysis 
isca alaska may 
adve lattner 
memory safety runtime checks garbage collection 
san diego ca jun 
ebcioglu altman 
daisy dynamic compilation architectural compatibility 
isca pages 
proceedings th international symposium microarchitecture micro ieee fisher 
walk time techniques catalyst architectural change 
computer sept 
ghiya sehr 
importance points analysis memory disambiguation methods programs 
pldi 
acm press 
gosling joy steele bracha 
java language specification nd ed 
addison wesley reading ma 
griswold 
java hotspot virtual machine architecture 
heil smith 
relational profiling enabling thread level parallelism virtual machines 
micro pages monterey ca dec 
ibm xl fortran ways boost performance 
white 
intel special issue intel technology pentium processors 
intel technology journal 

kim smith 
instruction set microarchitecture instruction level distributed processing 
isca alaska may 

technology crusoe processors 
adve 
ensuring code safety runtime checks real time control systems 
cases grenoble france oct 
lattner adve 
automatic pool allocation disjoint data structures 
proc 
acm sigplan workshop memory system performance berlin germany jun 
lattner adve 
llvm compilation framework lifelong program analysis transformation 
tech 
report uiucdcs computer science dept univ illinois urbana champaign sept 
trick nystrom barnes hwu 
hardware mechanism dynamic extraction program hot spots 
isca pages jun 
morrisett walker crary glew 
system typed assembly language 
toplas may 
sohi 
parallelism front 
isca june 
patel 
replay hardware framework dynamic optimization 
ieee transactions computers jun 
nagarajan liu kim huh 
exploiting ilp tlp dlp trips architecture 
isca june 
smith heil sastry :10.1.1.19.6586
achieving high performance designed virtual machines 
international workshop innovative architecture 
fields jr le 
power system microarchitecture 
ibm journal research development 
ungar smith 
self power simplicity 
oopsla 
zilles sohi 
programmable coprocessor profiling 
hpca jan 
