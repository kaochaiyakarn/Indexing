basic observables calculus global computing rocco de nicola daniele rosario pugliese dipartimento di sistemi informatica universit di firenze email pugliese dsi december discuss basic process calculus useful modelling applications global computing systems associated semantic theories determined basic notions observation 
main features calculus explicit distribution remote operations process mobility asynchronous communication distributed data spaces 
introduce natural notions extensional observations study closure operational reductions language contexts obtain barbed congruence may testing 
equivalences provide alternative tractable characterizations labelled bisimulation trace equivalence 
discuss induced equational laws relate design choices calculus 
particular show laws hold longer language rendered introducing asynchronous undetectable failures implementing remote communications process migrations local exchanges 
cases investigate adaptation tractable characterizations barbed congruence may testing lower level scenarios 
contents process language cklaim syntax 
operational semantics 
touchstone equivalences bisimulation equivalence soundness barbed congruence 
completeness barbed congruence 
trace equivalence soundness may testing 
completeness may testing 
verifying distributed protocol dining philosophers equational laws impact richer contexts related programming computational infrastructures available globally offering uniform services main issues computer science 
challenges come variable guarantees communication operation mobility resource usage security policies mechanisms taken account 
key issue definition innovative theories computational paradigms linguistic mechanisms implementation techniques design realisation deployment management global computational environments application 
foundational side demand development tools techniques build safer trustworthy global systems analyse behaviour demonstrate conformance specifications 
theoretical models calculi provide sound basis building systems sound construction behave predictable manner 
crux identify abstractions appropriate programming global computers supply effective tools support development certification global computing applications 
considered contribution line research 
distinguishing feature applications called global computers necessity dealing dynamic unpredictable changes network environment due unavailability network connectivity bandwidth fluctuations lack resources failure nodes network reconfigurations 
issues considered traditional ones distributed applications heterogeneity operating systems application software scalability huge number users nodes autonomy resources managed different administration domains 
global computers fostering new style distributed programming key principle network awareness applications information network location latency congestion adapt variations 
applications support disconnected operations permit software components remotely executed owner connected 
view language global computing equipped primitives support network awareness locations explicitly referenced operations remotely invoked disconnected operations code moved location remotely executed flexible communication mechanisms distributed repositories storing content addressable data remote operations asynchronous remote communications 
semantic theories needed stating proving observable properties reflect listed distinctive features global systems user application level ignore issues routing network topology hardly observable user level 
foundational languages process calculi strongly developed improved formal understanding complex mechanisms underlying global computers 
want mention ambient calculus nomadic pict 
equipped primitives represent various abstraction levels execution contexts net applications roam run provide mechanisms coordinating monitoring resources support specification implementation security policies 
contrasts list distinguishing features languages global computers realizes fall short targets 
want develop semantic theory alternative model takes origin formalisms opposite objectives programming language klaim full fledged programming language klaim calculus generally recognized minimal common denominator calculi mobility 
resulting model called cklaim core klaim thought variant calculus process distribution mobility remote operations asynchronous communication distributed repositories 
direct correspondence cklaim klaim believe tractable behavioural equivalences develop provide powerful tools write sound programs global computers 
programs written klaim mapped cklaim verified behavioural equivalences formalize prove properties run actual global computer internet exploiting java translation 
develop semantic theory proposed language defining behavioural equivalences terms maximal congruences induced basic observables dictated relevant features global computers 
approach summarized follows 
define set observables values normal forms actual communications 
term evaluate means successive reductions 

define basic equivalence terms stating terms equivalent exhibit set basic observables 

consider largest congruence language induced basic equivalence inductive closure 
similar approach study models concurrent systems ccs calculus 
obviously designation basic observables critical 
draw inspiration everyday experience user observe behaviour global computer application level testing specific site running provides data kind ii 
specific information site iii 
specific information specific site 
calculi global computers rely barbed congruences induced similar observables example ambient uses barb related barbs calculus strongly related iii 
question naturally arises observables yield interesting congruences 
basic observables discriminating power provided cklaim contexts yield congruence similarly 
indication robustness resulting semantic theories 
show observables sufficiently powerful give rise interesting semantic theories considering lower level features failures 
due intuitive appeal rest shall kind observable 
major drawback approach relying basic observables context closures resulting congruences defined universal quantification language contexts programming notation cklaim turn calculus equipping lts operational semantics behavioural equivalences 
process language cklaim nets components processes nil rec actions eval new input parameters table cklaim syntax checking hard 
important devise proof techniques avoid quantification 
shall define labelled transition system labels indicating performed action exploit labels avoid quantification contexts 
shall tractable characterizations touchstone congruences barbed congruence may testing terms non standard labelled bisimilarity trace equivalence respectively 
doing face problems raised presence explicit localities fact cklaim asynchronous communication mobility paradigm higher order processes migrate 
rest organized follows 
section cklaim syntax reduction semantics 
section define barbed congruence may testing sections alternative characterizations 
section discuss equations induced semantic theories show break rendering language implementing remote communications process migrations local exchanges introducing asynchronous undetectable failures 
section discuss related 
process language cklaim section syntax cklaim operational semantics structural congruence labelled transition system lts 
syntax syntax cklaim reported table 
countable set names 



assumed 
names provide counterpart set communicable objects localities basic variables process variables distinguish kinds objects 
notationally prefer letters 
want stress name locality 
want stress name basic variable 
want stress name process variable 
basic variables localities 
processes ranged cklaim active computational units may executed concurrently locality different localities 
built terminated process nil basic actions prefixing parallel composition recursion 
actions permit removing adding data node repositories activating new threads execution creating new nodes 
action new indexed address acts locally actions explicitly indicate possibly remote locality take effect 
notice evolves datum form name matching operator derived linda pattern matching 
process language cklaim fn bn 
eval fn bn new fn bn nil fn bn fn fn bn bn fn bn fn bn nil fn bn fn bn bn fn fn bn bn rec fn bn table free bound names nets ranged finite collections nodes 
node pair locality address node parallel component located components ranged processes data denoted net scope name restricted intended effect considers net locality immediately referred powerful calculus mechanism restricted names 
names occurring cklaim processes nets bound 
precisely prefix binds prefix similar abstraction calculus 
prefix new binds similarly net restriction binds rec binds name bound called free 
sets fn bn respectively free bound names term defined accordingly definitions shown table 
set names term union sets free bound names 
usual say terms alpha equivalent written obtained renaming bound names 
shall say name fresh 
sequel shall terms bound names distinct different free ones 
notation write mean form notation assign symbolic name term shall notation denote tuples objects tuple names written xi appropriate index set ln shall assume li 
xn 
ym denote tuple pairwise distinct elements 
xn 
ym 
convenient shall regard tuple simply set write mean components 
shall write mean argument actions datum irrelevant 
omit trailing occurrences process nil write parallel composition terms components nets resp 
wj 
operational semantics cklaim operational semantics terms structural congruence reduction relation 
structural congruence identifies nets intuitively represent net 
defined congruence relation nets satisfies laws table 
laws process language cklaim alpha pass ext fn abs nil rec rec rec nil clone table nets structural congruence taken calculus see law abs equivalent law law rec freely folds unfolds recursive definitions 
additionally law saying restricted name address node law clone transforms parallel located components parallel nodes 
notice commutativity associativity obtained pass clone 
sequel exploiting notation law shall write denote net possible empty set restricted localities 
follows shall consider nets bound name associated node virtue rule possible 
reduction relation table 
rules eval existence node target action necessary place spawned component 
notice existence target node checked run time 
approach fit global computing setting relies typing mechanism require knowledge net 
rules match require existence matching datum target node 
rule match says action consumes exactly datum 
rule says action 
consume datum replace free occurrences continuation process performing action 
rule new says execution action new simply adds restriction net new node locality allocated deallocated law 
cklaim adopts linda communication mechanism communication asynchronous data anonymous 
notice exist prefixes placing data nodes synchronization takes place sending receiving processes 
contrary sort synchronization takes place sending process target node see rules eval 
similar synchronization takes place node hosting datum process looking see rules match 
restricted names thought private network addresses corresponding nodes activated needed successively deactivated owners resource nodes included scope restriction 
names represent localities communicable objects law slightly modified deal bound locality names 
touchstone equivalences nil eval eval nil nil match nil new new nil touchstone equivalences table cklaim operational semantics par res struct section weak equivalences yielding sensible semantic theories cklaim 
approach follow relies definition observation called barb intuitively formalises interactions process engaged 
observables define equivalences equate nets taken apart basic observation computations ii net context iii computations net context 
notationally shall denote reflexive transitive closure 
definition barbs net contexts predicate holds true predicate holds true net context cklaim net occurrence hole filled net 
formally chosen basic observables inspiration corresponding ones asynchronous calculus 
may wonder choice correct argue alternative notions basic observables quite natural discussed 
alternative consider equivalent nets available set data possibly different nodes 
second alternative consider equivalent nets exactly data localities 
shall prove congruences induced alternative observables coincide 
means results quite independent observable chosen choice 
notice kinds observation predicates sophisticated equivalences come picture 
example shown testing fair testing obtained ccs changing basic observable 
say binary relation nets barb preserving imply reduction closed imply context closed implies context 
touchstone equivalences touchstone equivalences relate nets observable behaviour barb preserving 
equivalence defined terms property hardly considered touchstone set barbs changes computations usually shrinks interacting external environment usually widens 
sake compositionality touchstone equivalences congruences 
requirements lead definitions 
definition may testing largest symmetric barb preserving context closed relation nets 
definition barbed congruence largest symmetric barb preserving reduction context closed relation nets 
want definition barbed congruence standard see 
may testing usually defined terms observers experiments possible successes experiment 
denote equivalence cklaim nets defined prove definitions coincide 
inclusions touchstone equivalences reflect inclusions hold calculus 
define may testing test fresh reserved name report success experiment computation net observer 
net containing node address test host datum test ii processes may emit datum test test 
computation reports success execution datum test node test appears written ok definition observer holds ok ok proposition proof sub relation trivially follows definitions 
inclusion strict equivalence abstracts branching structure equated nets reduction closure 
standard process calculi ccs calculus 
start proving pick observer ok contextuality barb preservation test comes ok implies test 
test name occuring definition observers ok required 
viceversa need prove barb preserving context closed 
barb preservation 
consider test test test 
ok hypothesis implies ok freshness test possible context closure 
proof induction structure context 
base case trivial 
inductive case possibilities induction pick observer prove ok implies ok symmetry suffices 
consider observer definition induction fact ok ok thesis easily follows rule pass bisimulation equivalence 
induction pick observer prove ok implies ok bound assume alpha equivalence fn particular test 
ok ok similarly replacing 
suffices conclude 
problem barbed congruence may testing context closure hardly tractable universal quantification net contexts 
sections shall provide tractable characterisations equivalences bisimulation trace equivalence 
doing show change observables changing congruences induce proves robustness touchstone equivalences supports choice 
shall give explicit proof barbed congruence arguments hold may testing 
recalling reasonable observables global computing framework existence specific visible datum node net existence specific visible datum specific node net 
definition alternative reduction barbed congruences reduction barbed congruences obtained replacing observable definition respectively ones 
iff 
iff prove contextuality coincide 
proposition 
proof notice need consider barb preservation 
reduction closure contextuality ensured definition reduction barbed congruences considering 

suppose implies hypothesis definition implies 
context fresh break 

means 
hold context fresh distinguish 
bisimulation equivalence coinductively capture barbed congruence introduce labeled transition system lts apparent action net willing perform order evolve 
sake presentation introduce syntactic category inert components nil bisimulation equivalence lts lts eval eval lts lts match 
nil nil lts new lts exists new nil lts send lts res nil lts par bn fn nil lts comm lts open lts struct table labelled transition system grouping components unable perform basic operation 
labelled transition relation defined relation nets induced inference rules table 
transition labels take form write bn fn defined accordingly 
definition lts easily follows form bound net executing 
briefly comment rules lts adapted calculus 
rule lts exists signals existence nodes label nil data label 
rules lts lts eval express intention spawning component require existence target node complete successfully rule lts send 
similarly rules lts early style lts match express intention performing input input performed rule lts comm chosen datum target node 
notice right hand side rules lts lts match existence node target assumed provides datum implies exist 
rule lts open signals extrusion bound names presentation calculus rule investigate capability processes export bound names extend scope bound names 
aim law ext fact rule lts comm labels carry restriction names scope previously extended 
rules lts res lts par lts struct standard 
structural congruence involved rule lts struct section 
notation shall write mean exists net alternatively say perform step 
shall usually denote relation composition bisimulation equivalence juxtaposition means exists net shall convention putting bar relation means relation hold means reduce performing 
usual stand stand stand 
lts just defined correct operational semantics cklaim stated proposition 
notice actual semantics cklaim lts table thought technical device deployed give tractable formulation barbed congruence 
proposition proof directions proved easy induction inference judgements 
prove relationships transitions lts syntactical form net performing 
proposition facts hold 
nil nil 
nil 

nil 
proof statements part straightforward lts exists lts struct lts par lts open lts res 
converse explicitly consider case cases similar 
proof proceeds induction length inference reduction 
base derivation inferred just rules rules lts exists lts open 
conclude 
induction reason case analysis rule applied nil 
triv lts res case 
induction nil nil 
lts par case fn 
thesis easily follows inductive hypothesis 
lts struct case induction transitivity 
thesis follows characterize barbed congruence labels lts universal quantification contexts 
way obtain alternative characterization terms labelled bisimilarity 
definition bisimilarity symmetric relation cklaim nets weak bisimulation holds bisimulation equivalence 

nil 
bisimilarity largest bisimulation 
bisimulation inspired 
key idea sending operations asynchronous evolution simulated net context locality execution internal actions lead want bisimulation congruence context provides target locality sending action tell apart nil nil hold transitions similar considerations hold input actions third item definition context lts developed labels containing processes 
bisimulation just defined clearly tractable strongly conjecture decidable proper assumptions techniques similar 
soundness barbed congruence key result subsection lemma easily allow conclude bisimilarity sound proof technique barbed congruence 
prove result need technical tools 
introduce notion bisimulation structural congruence defined labelled bisimulation fact consequents definition replaced relation 
lemma shows bisimulation bisimulation 
lemma characterizes possible executions net terms evolutions separately 
lemma nets holds proof ni 
shall prove labelled bisimulation 
lts struct 
consider case cases similar 
hypothesis 
reflexivity 
lemma conditions hold 
bn 

fn bn 

nil bn nil bn 
bn bisimulation equivalence 
bn resulting net respectively structurally equivalent cases 
cases 
proof part trivial lts table observing bn implies 
part proved induction length inference base case length obviously fall case 
lemma 
inductive step reason case analysis rule applied inference lts res 
case apply induction reason analysis case lemma 

bn 
fall case 
context 


fall case 
contexts 

bn 
fall case 
contexts 
nil 
bn 
fall case 
contexts 


similar 
lts open 
case apply induction reason analysis case lemma consider cases 

bn 
fall case 
contexts 

fall case 
contexts 

lts par 
case inferences hold bn bn bisimulation equivalence inference fall case 
resulting context second inference apply inductive arguments similar lts res case context consider 
lts send 
case inferences hold nil nil apply induction notice consider cases lemma actions fired different restricted names 
reduction cases 
nil 
bn 
fall case 

nil fall case 
resulting context second reduction similar cases just list differences 

fall case 

resulting context 
lts comm 
case inferences hold just possible inductive cases reduction lemma 
reduction cases 

bn 
fall case 


fall case 
resulting context second reduction similar cases 
difference case 
induction leads case 

lts struct 
case proceed induction structure context 
base case trivially falls case 
lemma 
inductive case reason case analysis structure 
identify sub cases bisimulation equivalence bn apply structural induction fall cases lemma 
rule lts open conclude falls cases 

lemma 
bn apply structural induction falling cases lemma 
lts res conclude falls case lemma 
prove longer inference possibly structural laws 
reduce case previous 
structure cases case trivially case 
lemma 
case structural induction 
cases possible nil structural induction 
cases easy conclude 

case similar previous 
nil structural induction cases lemma easily conclude 
previous 
lemma congruence relation 

case similar proof start proving substitutive net contexts implies 
aim prove bisimulation 
lemma examine cases 

bn reason case analysis 

hypothesis bisimilarity trivially definition holds 
hypothesis bisimilarity nil bn nil nil structural equivalence 
hypothesis bn 
hypothesis bisimilarity 
bisimulation equivalence 
trivially 
definition 
nil 

bn 
hypothesis bisimilarity 
thesis easily follows 
nil 
hypothesis bn 
proposition nil nil 
hypothesis bisimilarity nil 

bisimilarity follows 
nil bn 
hypothesis nil 
thesis easily 
bn 
proposition nil 
hypothesis bisimilarity 

bn 
hypothesis bisimilarity 
left proving equivalence relation 
reflexivity symmetry follow definition 
prove transitivity consider relation prove bisimulation 
reason case analysis 
case conclude 
hypothesis nil context closure nil nil nil easy conclude similarly implies theorem soundness proof shall prove barb preserving reduction closed contextual 
definition implies 
bisimulation equivalence hypothesis bisimilarity implications rely proposition definition 
proposition implies turn implies hypothesis bisimilarity proposition means lemma net context holds 
completeness barbed congruence want prove converse barbed congruent processes bisimilar 
aim need technical results 
gives simple equations hold true barbed congruence 
second result gives alternative characterization contextuality property definition 
third result states throw away fresh localities hosting restricted data breaking barbed congruence 
proposition facts hold 

nil 
eval nil 
fn proof equations easily proved providing proper bisimulation containing fact theorem proves part 
equation proved observing easily proved 
nil nil nil easily verified 
inclusion transitivity claim holds 
lemma relation contextual 
implies name process 
implies name proof trivial prove contextuality implies points lemma 
converse assume pick context 
proceed induction structure 
base case trivial 
inductive case possibilities 
induction 
proceed induction structure base case trivial 
inductive case case point lemma holds second induction conclude 
second case assume fresh possible alpha equivalence 
second induction point lemma conclude 


induction point lemma holds 
lemma fresh bisimulation equivalence proof suffices prove barb preserving reduction closed contextual 
barb preservation 
trivially holds freshness 
argument hold consider context fresh 
hypothesis freshness reduction closure 

hypothesis fact implies involved transition follows 
claim proved 
contextuality 
lemma prove just cases 

holds assume fn 
case easy conclude similarly replacing transitivity 
consider case fn context nil fresh name 
nil 
equalities hold true resp proposition 
similarly 
transitivity implies case dealt similarly 
uses context eval fresh name proposition 

holds similarly replacing 
transitivity easily conclude 
consider context new fresh 
similarly replacing 
conclude implies consider context fresh 
similarly replacing 
conclude 
theorem completeness proof prove bisimulation 
pick transition reason case analysis 
trace equivalence 
case simple reduction closure 
case consider context new fresh reduction 
contextuality reduction closure implies possible 
freshness state 
lemma 
consider context fresh reduction 
arguments similar ensured prove weakly offers restricted locality 
contradiction assume offers free names pick names say context bound alpha convert possible assuming bound names pairwise distinct different free ones 
lemma conclude 
nil consider context eval nil new 
fresh reduction 
nil suffices conclude 
consider context nil reduction nil contextuality reduction closure nil suffices conclude see definition 
case similar previous just consider context reduction corollary tractable characterization barbed congruence trace equivalence section develop tractable characterization may testing 
known process calculi may testing coincides trace equivalence section show similar result obtained setting cklaim :10.1.1.41.3086
best knowledge tractable characterization may testing distributed language process mobility 
idea trace equivalence related sets traces coincide 
put form exhibits sequence visible actions exhibit viceversa 
asynchronous setting requirement properly weakened discriminating power asynchronous contexts weaker asynchronous calculus example contexts observe input actions :10.1.1.41.3086
define proper trace equivalence slightly modify lts table adding rule lts rcv fn nil trace equivalence laws stands rule stands nil respectively rule table ordering relation traces permits distinguishing reception free name reception bound name akin asynchronous calculus 
case received name fresh receiving net law considered address node course bn notice rule lts rcv needed bisimulation introduced previous section capture barbed congruence 
new transition system exploits labels collects visible labels 
clearly rules lts res lts par lts struct table exploit 
define complementation function labels lts 
formally nil nil range possibly empty sequences visible actions denotes empty sequence actions represents concatenation 
usual denotes denotes naive formulation trace equivalence strong asynchronous setting example distinguish may testing equivalent 
weaker trace equivalence defined follows 
definition trace equivalence largest symmetric relation cklaim nets holds implies 
crux identify proper ordering traces may testing exactly captured 
ordering obtained reflexive transitive closure ordering defined table 
intuition context interact net exhibits context interact net exhibits ordering relies function trace equivalence laws moving removing label form case information fresh received value kept remaining trace 
formal definition fn fn better understand motivations underlying definition consider example justifies side condition law similar arguments hold laws 
trace performed net input action erased 
fresh see meaning label get knowledge performing input consequently perform action hand receive communication node perform action input action erased intuition rules table follows 
laws inspired ones strictly related difference pure name name node address 
law states input output migration directly observed effect output observed accessing datum produced output 
law states execution input output migration delayed computations noticed observer 
law states adjacent complementary actions deleted terminology ccs say complementary synchronize yield see rules lts comm lts send 
law states bound names node addresses reception transmission bound name enables outputs migrations law states input enables outputs migrations datum retrieved exists output migration enabled 
course output migration enables outputs migrations similarly law states output migration enabled action form output migration fired 
possible created extruded 
remarkably may testing synchronous asynchronous calculus distinguish bound names free ones bound name replaced name trace 
case bound names considered addresses nodes free names 
difference external observer law mutatis mutandis holds asynchronous calculus hold cklaim 
soundness may testing prove trace equivalence exactly captures may testing rely classical definition equivalence proposed definition 
lts ok corresponds test test convenient ok denote label test test extend complementation label traces trace equivalence remarkably 
give lemma describes sufficient necessary condition success experiment 
lemma net observer 

ok imply ok 
ok implies exists proof ok 
proof induction lenght 
base step trivial 
inductive step consider possibilities 
cases trivial fn ok induction ok proposition nil ok observer emit test test test 
case similar 

definition ok proof induction base step simple 
inductive step subcases induction ok possibilities step case pick 

nil pick nil pick nil 
pick 
pick 
steps remove restrictions test 
ok induction ok possibilities step definition lts extend scope passing rule ext 
fn rule lts rcv pick 
case similar 
lemma states laws table sound sense observer observe trace provide observe trace 
trace equivalence lemma proof definition proceed induction base step trivial reflex 
inductive step suffices prove implies induction judgement implies required 
reason case analysis law table infer 
notice laws hide double formulation explicit proof 

definition nil 
fn fn 
definition nil required 

definition nil 
fn nil 
definition nil 
implies nil nodes disappear reductions nil required 
nil 
definition nil 
nil 
fn obtain reason case 
nil 
definition nil nil 
implies easily conclude 

rule nil nil 
nil nil nil needed 
trace equivalence 
nil rule lts rcv holds nil 
nil needed 

definition nil 
easily nil required 

similar case 

definition nil nil 
node nil nil 
nil required 
nil nil 
similar case main theorem follows 
theorem soundness proof ok lemma exists ok definition exists suffix closure easily proved test test test test lemma ok lemma ok required definition 
proposition implies completeness may testing define canonical observer written test trace equivalence actual observer process context enabling observation returned inductively defined follows ol test test nil ol nil eval nil ol ol ol ol ol ol nil ol ol new nil new ol finite set names extruded trace names created net emitted offered datum visible location 
convention new stands 
context provide localities observed net place data code form observer process place data observed net needs form 
context provide locality case observed net provides extruded action 
key property canonical observer reports success run parallel net offers stated proposition 
proposition ok proof proof induction easily follows definition canonical observers 
distinguish label generated rule lts label generated rule lts eval 
shall write 
needed technical reasons see case iv proof lemma labels exactly 
start adapting lemma order exclude labels form lemma ok exists contain labels form ok proof lemma know exists trace ok proof proceeds induction number labels form generic base step trivial 
inductive step contain labels form consider cases trace equivalence names 
contain labels form test test test definition canonical observers nil action canonical observer node address provided name observer extruded trace case 
side nil thesis holds induction label form names 
lk 

lk proof case li 
li li li li nil test li li li test li li li nil li li nil possible name li restricted address node law 
node address li li nil disappear computations holds li li correspondingly apply induction conclude 
main lemma prove completeness trace equivalence may testing stating report success execution trace 
lemma ok test contain labels form 
proof proof induction 
base step trivial 
inductive step reason possibilities 
nil test eval nil 
trace ok produced ways 
test ok test ok induction implies inequality holds prefix closure inverse second inequality holds repeated applications law 
just parallel nodes components contains labels form nil contains labels form 
nil test ok test nil ok induction implies prefix closure repeated applications law previous case law required 
symmetry denomination extruded names call name received rule lts rcv name trace equivalence ii test nil 
test test test nil ok test ok trace obtained removing labels nil possibly adding label form necessarily case 
nil labels nil generated test similarly necessary add label production test needs place data process 
induction desired 
notice second inequality obtained repeated applications laws times number labels nil removed obtain possibly applying laws label form introduced 
inequality relies law 
iii subcases 

test 
test test test ok ok induction prefix closure law labels form 

test 
test test test nil ok construction fn test 
easy inspection definition canonical observers holds structurally equivalent test nil test contains labels form 
case ok thesis follows induction prefix closure applications law 
second case proceed case ii ok obtained removing actions nil possibly adding action proof similar uses place right place 
iv test new nil 
case tedious lot possible evolutions forms 
hypothesis contain labels form particular contain action generate visible action forces reduce test order report success 
consider case complicated 
keep account test interact extruded 
possibilities total 

involved generation extruded test case simplest ok easy induction conclude notice fn trace equivalence extruded test case ok induction prefix closure second inequality relies law 

contribution label nil datum extruded case nil ok obtained case ii 
induction prefix closure second inequality holds law third inequality holds law appear follows fourth inequality holds law fifth obtained case ii 
ii 
extruded case nil ok obtained ii 
induction prefix closure steps similar case prove difference previous inference thrown away captured desirable 
nil 
case easily adapted considering ok obtained ii 
offers datum label case nil ok obtained ii 
laws possibly iterated times law needed 
offers datum label previously extruded case nil obtained corresponding ii 
proof proceeds previous cases 
case ii restriction captured required 
case ii proof radically changed consider nil 
datum passed test communication extruded case nil ok obtained ii 
second step relies law third step laws needed fourth step relies rule 
notice extruded fn 
extruded communication form ok verifying distributed protocol dining philosophers 


proof carries way 
ii 
previously extruded case nil ok obtained corresponding ii 
proof carried similarly previous cases 
situation extrusion proceeds label nil similar 

contribution case ok obtained ii 
thesis follows induction prefix closure law possibly repeated applications laws 

contribution previously extruded case ok obtained ii 
situation previous case restriction remains associated needed 

contribution production passing datum test communication extruded case similar simpler 
ok situation radically change extruded communication see case 
previously extruded case similar ii 
ok prove trace equivalence sound proof technique may testing see theorem exactly captures 
theorem completeness proof trace ok proposition lemma ok proposition definition holds ok lemma exists ok contain labels form lemma notice test fresh holds test required definition corollary tractable characterization may testing verifying distributed protocol dining philosophers proof techniques just state prove properties classical problem distributed systems dining philosophers 
follows historically problem formulated solved dijkstra motivate semaphores 
verifying distributed protocol dining philosophers shall bisimulation finer easier prove 
done trace equivalence 
elegant implementation protocol easier verification section shall polyadic data shall consider data form 
ln prove feature radically improve expressive power calculus 
terminology linda extended syntax cklaim tuples templates actions eval new remaining productions table 
tuple retrieved means template number fields corresponding fields match bound variable matches name names match identical 
case write match 
rules lts lts match joint rule match process obtained replacing occurrences variables bound corresponding name similar adaption needed rules match 
bisimulation barbed congruence polyadic case 
trivial prove follows justified problem 
dining philosophers classical synchronisation problem luck derives fact naturally models synchronisation problems arising allocating resources concurrent distributed systems 
problem described follows 
say philosophers spend lives alternating thinking eating 
seated circular table fork placed pair neighbouring philosophers 
philosopher access forks left right philosopher wants eat acquire forks near possible neighbours forks done eating philosopher puts forks back table begins thinking 
challenge dining philosophers problem design protocol philosophers deadlock entire set philosophers wait indefinitely philosopher philosopher eventually gets hands pair forks 
additionally protocol efficient possible words time philosophers spend waiting eat minimised 
solution 
propose protocol klaim solve problem spirit dijkstra solution 
shall associate philosopher distinct locality taken set 
ln 
restricted locality record tuple length allocation forks status philosopher precisely th component tuple th philosopher thinking th philosopher eating 
access tuple allow processes act resources allocation mutual exclusion 
node li host process implementing behaviour th philosopher rec think ti ti eat verifying distributed protocol dining philosophers ti ti 
xn 
xi xi 
xn 
xn 
xn 
xi xi 
xn 
xn 
yn 
yi yi 
yn 
yn 
yn 
yi yi 
yn 
yn intuitively action verifies neighbors th philosopher eating acquires lock tuple action sets status th philosopher releasing lock 
actions release resources completion eating phase protocol iterates 
sake simplicity model think phase eat phase just action fresh locality system starts philosophers thinking state net implementing system 
li pi pi rec ti ti li soundness solution 
shall verify correctness protocol deadlock starvation occur resources properly neighboring philosophers eat time protocol enables highest level parallelism philosophers eat 
possible 
shall prove nil li 
equation proved showing relations li nil id weak bisimulations done easily 
means computations get stuck deadlock occur philosopher eat unbounded number times starvation occur 
deadlock freedom prove proceed contradiction suppose exists computation leading deadlock 
computation finite find integer upper bound number steps performed reaching deadlock 
iterate times equation polyadic case theorem obtain nil li equivalence contradicted letting nil follow computation leading deadlock 
nil performs steps computation impossible produce data recall fresh hand computation li remove data chosen fresh 
resulting nets exhibit different data equivalent 
equational laws impact richer contexts starvation freedom proof similar 
exists computation starving philosopher letting eat times computation contradicts nil li 
fresh locality 
define 
li pi nil nil 
xn 
xn 

xn notice nil restricted node interested observing eating simplifies formulation equation show fact implies access resources properly 
want prove produce data 
intuitively produce datum happens philosophers eat equation implies resource misused 
equation proved showing relation bisimulation easy task 
suppose exists computation resources means 
net adjacent philosophers eating 


adjacent modulo 

target contradicting equation 

easiest way prove philosophers eat simultaneously show computation leading tuple exactly items kind respecting correct resources 
wanted reduction obtained letting philosophers accessing turn status tuple 
possible philosopher surrounded modulo eating odd philosophers 



li pi li pi li li pi odd li pi equational laws impact richer contexts section want discuss equational laws easily proved exploiting bisimulation trace equivalence 
concentrate bisimulation finer virtue equational laws impact richer contexts proposition theorems 
law inspired asynchronous calculus rec nil states repeatedly accessing datum putting back original location observationally equivalent performing operation 
course heavily exploits fact communication cklaim asynchronous 
law motivates choice omit cklaim klaim action read 
fact action read relevant security reasons removing datum accessing requires different capability simply accessing read ignored 
significant laws easily derived second third nil eval nil nil eval nil nil laws state impossible know data processes allocated outset computations 
law states net fixed actual distribution processes irrelevant law states remotely executing process observationally equivalent executing process locally 
sight laws quite surprising contradict design principles basis cklaim 
explained observing net high level level user applications 
observing functionalities net offers terminal user 
allocation processes observed law advantages exploiting mobile processes efficiency reduced network load support disconnected operations perceived law 
circumstances level abstraction exactly need 
example studied dining philosophers interested behaviour system properties enjoyed ignore implementation details take account functional aspects protocol 
want details distributed environment underlying cklaim application refine observation level 
consequently study lower level aspects routing problems failures adapt language semantic theories developed 
aim studied variants cklaim communication take place locally ii failures components nodes occur iii dynamically evolving connections nodes explicitly modelled 
shall give hints variants leave elaborated treatment third scenario companion 
predictably laws hold lower level settings 
local communications 
start modifying syntax table order forbid remote executions actions 
productions process actions eval new rules match modified accordingly match equational laws impact richer contexts barbed congruence may testing resulting calculus 
show proof techniques developed sections hold localised framework 
aim need modify lts table rules lts lts lts match lts lts lts match letting bisimulation testing equivalences defined sections top modified lts prove analogous main results 
theorem proof proofs claims easily adapted theorems exploiting proposition 
easy check nil nil eval nil nil reasonable communications local moving process change execution environment 
observable behaviour change node runs 
notice order disprove laws may testing 
theorem implies failures 
consider setting enrich cklaim mechanism modelling various forms failures 
achieved adding rules definition reduction relation lts fail lts fail rules model corruption data message omission 
dn node fail silent failure collects components located abnormal termination processes running 
way model failures disappearance resource datum process node 
simple realistic way representing failures specifically fail silent message omission global computing scenario 
presence data nodes ascertained absence scenario practical upper bound communication delays 
failures distinguished long delays modelled totally asynchronous undetectable events 
easy prove laws cklaim hold anymore concrete setting 
failure easily modify behaviour equated nets 
examine happens characterization barbed congruence may testing new framework 
definition bisimulation equivalence need modified exactly capture barbed congruence 
recursive closure barbed congruence bisimulation forces corruption data failure nodes take place time regards process abnormal termination evolution involved nets affect equivalence 
trace equivalence characterization breaks trace equivalence sound complete proof technique may testing 
related problem lemmas hold anymore lower level setting 
mean trace equivalence strictly finer may testing believe means proof theorem carefully re examined 
precise statement aspect left 
denote labelled bisimilarity barbed congruence trace equivalence may testing calculus failures theorem proof proof formally identical theorems step reduction generated applying rule lts fail fail respectively 
related semantic theories cklaim process calculus process distribution process mobility remote operations asynchronous communication distributed repositories 
combination design choices proved valuable applicative point view 
semantic theories introduced defined uniform fashion defined user basic observables global computing setting closed possible contexts reductions obtaining touchstone equivalences barbed congruence may testing gave tractable characterisations equivalences means labelled bisimulation trace equivalence 
discussed theories change extending cklaim lower level mechanisms modelling failures implementing remote communications migrations local exchanges 

possible developments include study abstractions administrative domains security policies determine virtual networks top effective 
aim dynamically evolving type environments exploited constraint behaviours processes observations environment 
direction done 
interesting analyze efficiency issues better clarify advantages mobile code process distribution 
possible application laws section find possible rearrangements processes net minimize number remote operations 
fact reasonable assume local operations cheaper faster remote ones 
re locate parallel components spawn processes running locality improve net behaviour 
related 
conclude reviewing related observational equivalences calculi process distribution mobility surveyed 
nineties ccs process calculi enriched localities explicitly describe distribution processes 
aim mainly provide calculi non interleaving semantics differentiate processes parallel components obtaining semantics interleaving ones 
line research far cklaim falls localities mean processes network aware enabling refer network locations target remote communication destination migrations 
localities considered units distribution case units mobility communication failure security 
related extend resp ccs calculus process distribution mobility 
cases processes run nodes explicit flat dynamically evolving net architecture 
nodes fail causing loss hosted processes 
explicit operations kill nodes query status node 
failures detected suitable distributed computing clashes assumptions underlying global computing 
papers labelled bisimulation akin bisimulation ccs calculus capture standardly defined barbed congruence 
distributed version calculus resulting calculus contains primitives code movement creation new localities channels net flat architecture 
lts defining semantics calculus typed bisimulation tractable formulation defined exactly capture typed barbed equivalence 
types illustrates importance having rights observe behaviour different typings observation rights generate different bisimulations finer long typing restrictive 
distributed join calculus located mobile processes hierarchically structured form tree structure evolving computation 
entire subtrees single processes move 
technically nets flat collections named nodes name node indicates nesting path node node name 
lk represents node unique name contained lk node contained lk 
communication takes place steps firstly sending process sends message channel ether environment containing nodes delivers message unique process receive channel 
fact net unique process capable receive channel communication similar cklaim channels role similar cklaim localities 
failures modelled tagging locality names compound name states node contained failed node li failed 
li caused execution primitive halt process running li 
failures detected primitive ail 
failed nodes host running computations receive data code arrived failed node definitely stuck 
interesting laws properties proved contextual barbed equivalence tractable characterization equivalence obvious extend characterization barbed bisimulation non distributed join calculus introduced account distribution agent mobility 
ambient calculus elegant notation model hierarchically structured distributed applications 
definition reduction semantics simple formulation reasonable possibly tractable observational equivalence hard task 
calculus centered notion connections ambients containers processes data 
primitive executed ambient hierarchy structured precise way ambient enter ambient sibling contained ambient 
fact greatly complicates definition tractable equivalence 
bisimulation capturing ambient barbed congruence defined 
done structuring syntax levels processes nets ones particular cases ones exploiting involved lts different kinds labels containing process contexts 
defined bisimulation standard suffers quantification possible processes fill holes generated operational semantics 
similar bisimulations developed calculi derived ambient safe ambients boxed ambients seal calculus calculus mobile re sources 
papers bisimulation sound complete proof technique barbed congruence 
conclude want best knowledge characterization may testing terms trace equivalence asynchronous distributed language process mobility 
theory may testing corresponding characterization developed actors model 
done reducing actors typed asynchronous calculus trace characterisation follows 
agha 
model concurrent computation distributed systems 
mit press 
agrawal seth editors 
fst tcs foundations software technology theoretical computer science nd conference kanpur india december proceedings volume lecture notes computer science 
springer 
amadio 
modelling mobility 
theoretical computer science 
amadio castellani sangiorgi 
bisimulations asynchronous calculus 
theoretical computer science 
extended appeared proceedings concur lncs 
bettini bono nicola ferrari moggi pugliese 
klaim project theory practice 
priami editor global computing programming environments languages security analysis systems number lncs 
springer verlag 
bettini de nicola ferrari pugliese 
interactive mobile agents klaim 
ciancarini tolksdorf editors proc 
th int 
ieee workshops enabling technologies infrastructure collaborative enterprises pages stanford 
ieee computer society press 
bettini de nicola pugliese 
java package distributed mobile applications 
software practice experience 
boreale de nicola 
testing equivalences mobile processes 
journal information computation 
available report si rr universit la sapienza di roma extended appeared proceedings concur lncs 
boreale de nicola pugliese 
trace testing equivalence asynchronous processes 
information computation 
boreale nicola pugliese 
basic observables processes 
information computation 
sassone 
communication interference mobile boxed ambients 
agrawal seth pages 
cardelli 
abstractions mobile computation 
vitek jensen editors secure internet programming security issues mobile distributed objects number lncs pages 
springer 
cardelli gordon 
mobile ambients 
theoretical computer science 
extended appeared proceedings fossacs number lecture notes computer science pages springer 
castagna 
seal calculus revisited contextual equivalence bisimilarity 
agrawal seth pages 
castellani 
process algebras localities 
bergstra ponse smolka editors handbook process algebra pages 
elsevier science 
castellani hennessy 
testing theories asynchronous languages 
arvind ramanujam editors proceedings volume lncs pages 
springer dec 
castellani ciancarini rossi 
shape shade coordination system 
technical report ublcs dip 
di scienze dell informazione univ di bologna italy 
davies wade friday blair 
tuple space platform adaptive mobile applications 
int 
conference open distributed processing distributed platforms 
de nicola ferrari pugliese 
klaim kernel language agents interaction mobility 
ieee transactions software engineering 
de nicola pugliese 
bisimulations calculus global computing 
draft 
de nicola pugliese 
expressive power klaim calculi 
corradini baeten editors proc 
express entcs 
elsevier 
de nicola hennessy 
testing equivalence processes 
theoretical computer science 

choosing mobile agent messaging model 
proc 
pages 
ieee 
fournet gonthier 
vy 
calculus mobile agents 
montanari sassone editors proceedings concur volume lncs pages 
springer 
fournet laneve 
bisimulations join calculus 
theoretical computer science 
gelernter 
generative communication linda 
acm transactions programming languages systems 
hildebrandt sassone 
calculus mobile resources 
kucera editors concur volume lncs pages 
springer 
hennessy 
behavioural theory access mobility control distributed systems 
proceedings fossacs volume lncs pages 
springer 
full version cogs computer science technical report 
honda yoshida 
reduction process semantics 
theoretical computer science 
extract appeared proceedings lncs 
hennessy 
bisimulation congruences safe ambients 
proceedings popl 
acm 

bisimulation proof methods mobile ambients 
proc 
icalp lncs 
springer 
full version cogs technical report university sussex brighton 
milner 
communication concurrency 
prentice hall 
milner parrow walker 
calculus mobile processes ii 
information computation 
milner sangiorgi 
barbed bisimulation 
kuich editor proceedings icalp volume lncs pages 
springer 
montanari pistore 
finite state verification asynchronous pi calculus 
cleaveland editor proc 
tacas volume lncs pages 
springer 
nestmann pierce 
decoding choice encodings 
journal information computation 
available report brics rs universities aalborg denmark 
extended appeared proceedings lncs pages 
park 
personal disconnected operations mobile agents 
proc 
rd workshop personal wireless communications pwc tokyo 
parrow 
pi calculus 
bergstra ponse smolka editors handbook process algebra pages 
elsevier science 
hennessy 
distributed processes location failures 
theoretical computer science 
sangiorgi 
expressing mobility process algebras order higher order paradigms 
phd thesis lfcs university edinburgh 
cst published ecs lfcs 
sewell pierce 
location independence mobile agents 
bal cardelli editors proceedings iccl workshop internet programming languages chicago il usa may volume lncs 
springer sept 
full version title location independent communication mobile agents level architecture appeared technical report computer laboratory university cambridge april 
agha 
theory may testing actors 
proc 
pages 
kluwer 
