crosswalk tool performance profiling user kernel boundary alexander barton miller bart cs wisc edu computer sciences department university wisconsin madison wisconsin usa performance profiling applications challenging task 
problem analysis applications spend significant amount time operating system 
result conventional user level profilers best trace performance bottleneck particular system call 
information insu cient programmer deal performance problem system calls quite complex making hard pinpoint cause problem 
address deficiency designed tool called crosswalk able performance analysis kernel boundary 
crosswalk starts profiling user level profiles main function callees walks application call graph refining performance problem particular function 
determines function system call walks kernel code starts traversing kernel call graph locates ultimate bottleneck 
key technologies crosswalk dynamic application instrumentation dynamic kernel instrumentation 
existing library called dyninst api 
designed new framework called kerninst api interface modeled dyninst 
combined libraries provide unified powerful interface building cross boundary tools 
demonstrate usefulness cross boundary approach analyzing squid proxy server crosswalk 
drilling kernel able identify ultimate cause squid performance problems remove modifying application source code 

applications heavy functions provided operating system 
naturally performance applications depends functions ciently functions implemented operating system 
example key ciency high performance applications 
network performance constraining factor tools web proxy servers cient synchronization primitives crucial multithreaded applications 
finding performance problems os bound applications challenging task 
user level profiler locate region application code system time spent unable explain happening fix problem 
example application spent time open system call profiler able detect report programmer 
open complex system call create new files truncate existing ones network distributed file systems 
knowing exact cause problem programmer may know fix 
opaque boundary user kernel spaces continued profiling kernel 
refining open bottleneck profiler find performance problem file truncation happens option open 
information programmer may able modify application bottleneck 
example may possible avoid truncating files open necessary 
alternatively programmer tune certain kernel parameters problem go away 
tuning done standard operating system interface obviating need kernel recompilation reboot 
refine main refine final bottleneck current bottleneck current bottleneck main main main 
walking call graph goal demonstrate cross boundary profiling feasible ective finding performance problems 
approach idea dynamic instrumentation traverse call graph search bottlenecks 
technique studied call graphs user applications 
generalize seamlessly walk joined call graph application kernel 
key technologies dynamic application instrumentation dynamic kernel instrumentation 
existing library called dyninst api 
designed new framework called kerninst api interface modeled dyninst 
synergy libraries provides unified powerful interface developing cross boundary tools 
bringing pieces designed tool called crosswalk locate bottlenecks application seamlessly cross kernel boundary find corresponding bottlenecks kernel code 
crosswalk performance bottleneck refined main application entry point application code way kernel space kernel function ultimate problem 
crosswalk simple prototype proved valuable finding performance problems study squid proxy server 
crosswalk results able boost squid performance standard workload factor 
related exist tools accomplish certain parts goal combined 
example profile application gprof profile kernel 
analysis find set bottlenecks user space set kernel space bottlenecks 
understanding sets related easy task 
fact possible kernel bottlenecks induced processes connection process study 
disjoint tools insu cient understanding cause problem 
complete tools cross boundary analysis exist di erent technologies implementing tools 
sampling tracing profiling source code modification dynamic instrumentation 
crosswalk dynamic instrumentation works production systems provides cycle accurate timing results little overhead 
narrowing choice dynamic instrumentation choose application instrumentation frameworks 
number options kernel instrumentation smaller 
appears currently maintained 
su cient functionality purposes instrumentation trap 
experience overhead traps prohibitively high performance monitoring 

basic technology ective way search performance bottlenecks walk application call graph dynamic instrumentation 
paradyn uses technique look bottlenecks user code 
sections describe call graph walking dynamic instrumentation greater detail 
instrumentation code instrumentation tool application user ld st dyninst system instrumentation tool instrumentation code os kernel st ld kerninst system 
frameworks dynamic application kernel instrumentation 
call graph walking assume searching performance bottleneck function takes certain amount wall clock time total running time application 
call graph approach experienced performance analyst searching bottleneck 
corresponding step step diagram shown 
method examines functions called directly main application entry point 
inclusive time spent function threshold search marks bottleneck 
tries refine bottleneck examining immediate callees function 
bottleneck search descend function continue doing reaches function callees threshold callees 
function final user space bottleneck searching 
identified function system call crosswalk analysis 
tool seamlessly walks kernel starts system call entry point descends callees necessary keeps doing final kernel bottleneck identified 
result analysis chain functions connecting main located bottleneck 
collect performance data dynamic instrumentation 
application running tool injects code function entry point start timer code exit points timer 
code removed longer needed 
approach require source code modification recompilation 
discuss detail 

application instrumentation dyninst api crosswalk uses dyninst api application instrumentation 
dyninst library allows write instrumentation tools 
typical structure tool shown 
library lets attach running application perform operations instrument tool generate instrumentation code ask library inject specified point application 
crosswalk puts timing code functions 
browse code resources tool locate application modules functions basic blocks retrieve control flow information 
example crosswalk uses functionality locate main identify functions called function walk call graph 
inspect modify application data tool read write application variables application running 
facility crosswalk values timers instrumentation code created 

kernel instrumentation kerninst api dyninst api allows instrument user applications drill kernel needs mechanism 
experience kernel instrumentation designing kernel performance monitor called 
reasonable amount ort factored instrumentation related functionality library called kerninst api 
kerninst api closely modeled dyninst api 
provides functionality interface syntax possible programmer single consistent model timer variable function total tick start start tick instrumentation total time start time timing function hash table call push regular call indirect call callee caller hash table call instrumentation function ld identifying callees function 
major building blocks crosswalk application kernel instrumentation 
enable tools crosswalk designed kerninst api coexist dyninst application necessary 
typical kerninst system shown 
system important properties 
instrumentation tool injects code kernel tool user space application 
second kerninst works standard production operating system 
need recompile kernel reboot machine 
tool simply attaches kernel starts instrumenting 
third kerninst requires user root privileges system 
allowing user insert execute code kernel security hole 

implementation major issues implementing crosswalk time function find function callees walk call graph 
similarity dyninst kerninst apis implement features unified way kernel user spaces 

timing crosswalk shows sketch instrumentation insert function interest 
provide cycle accurate results low overhead code uses processor hardware counters timer readings 
samples cycle counter entry point function samples exit point computes delta 
code executes function timer variable accumulates total number wall clock cycles spent function 
note approach easily extended handle types performance metrics cpu time number cache misses 
crosswalk uses similar primitives timing application kernel code 
di erence kernel constrain timing process study 
multiple threads execute kernel function timer reflect time spent process thread 
crosswalk achieves goal wrapping kernel start primitives check proper process identifier currently running thread 
check fast instructions 

identifying function callees function proves bottleneck crosswalk try refine looking function callees 
dyninst kerninst api provide method identifying callees static analysis 
method locates call instructions function extracts destination addresses 
static analysis works cases fails analyze indirect calls destinations computed run time 
constructs common practice calls function pointers callbacks virtual functions get translated indirect call instruction 
crosswalk solves problem way paradyn instruments indirect call sites identify callees run time 
shows call site instrumentation invoked callee address computed instrumentation simply adds hash table 
result hash table soon contain callees invoked watched sites 
approach worked 
support indirect calls crosswalk able advance past system call entry point system call handlers dispatched indirect call 
main open open copen syscall trap ufs create bottlenecks original version syscall trap select main poll cv sig bottlenecks tuned version 
squid bottlenecks 
links dashed functions omitted brevity 

experimental results squid popular technique optimizing web transfers proxy caching 
places intermediary proxy server web servers clients caches server responses clients 
technique takes extra load web servers network infrastructure ectiveness heavily depends performance proxy server 
study years ago fixed performance problems popular open source proxy called squid 
crosswalk see current version application enhanced 
ran squid stable sun ultra workstation ultrasparc iii mhz processor mb ram gb ide hard drive mbit network card bit version solaris 
model typical web activities subjected standard workload known wisconsin proxy benchmark 
workload issues concurrent requests clients di erent web servers squid 
benchmark measure performance wall clock time takes serve requests requests client 
crosswalk attached squid chain functions shown wall clock time threshold white nodes belong application gray kernel 
functions receive object web server store disk cache appear bottlenecks 
network read file write problem surprisingly bottleneck open system call 
skimming source code squid realized calls open correspond opening individual cache files creating new objects 
point user level profiler crosswalk able drill kernel traced open bottleneck ufs create routine 
apparently squid spends time creating new files disk cache 
possible way remove bottleneck crosswalk pre create files squid cache 
new object comes web server squid open existing zero sized file save object avoiding need create new file 
obstacle approach squid removes old files cache periodically keep cache size control 
result eventually fall back original mode creating files 
obstacle minor modify squid source remove old files simply truncate zero size 
discovered squid provides support truncation strategy enabled default 
turned recompiling squid appropriate parameters running time wisconsin proxy benchmark dropped factor seconds original scheme removing files seconds modified truncating files 
optimize squid ran crosswalk discovered problems shown 
new user space bottleneck function calling select 
refinement kernel suggests squid simply blocks condition variable cv sig gets switched doing 
chain indicates little kernel activity problem application 
examined source waiting squid helper daemon consumes file truncate requests filled queue 
requests come bursts give chance catch simply making queue longer 
extended entries recompiled squid running time benchmark dropped additional seconds 
crosswalk correctly identified cause performance problem provided information fix 
estimate overhead profiling ran benchmark multiple times cross walk determined crosswalk increased total running time approximately 
isolate individual contributions application kernel instrumentation modified crosswalk perform application kernel call graph walks 
application instrumentation accounted approximately total slowdown kernel 
overhead reasonably low prevent crosswalk finding correct bottlenecks 

identified directions improvement crosswalk 
support analysis multithreaded applications increasingly common 
paradyn search user space bottlenecks applications 
providing matching support analysis relatively straightforward 
second direction account asynchronous kernel activities 
applications spend lot time kernel perform system calls 
typical example core application fit main memory su ers excessive paging activities 
application crosswalk narrow problem user level function takes time able refine kernel system call entry point bottleneck 
possible way account activities walk kernel call graph entry points simultaneously feasibility approach studied 
almeida cao wisconsin proxy benchmark technical report computer sciences department university wisconsin madison april 
buck hollingsworth api runtime code patching journal high performance computing applications pp 
winter 
cain miller wylie callgraph search strategy automated performance diagnosis euro par munich germany august 
derose hollingsworth hoover dynamic probe class library infrastructure developing instrumentation performance tools international parallel distributed processing symposium april 
graham kessler mckusick gprof call graph execution profiler sigplan symposium compiler construction boston june pp 

oss sgi com projects mckusick gprof tune bsd kernel european unix users group meeting april 
miller clark hollingsworth 
lim ips second generation parallel program measurement system ieee transactions parallel distributed systems pp 
april 
mohr brown tau portable parallel program analysis environment pc vi linz austria september 
moore dynamic probes generalised kernel hooks interface linux th annual linux showcase conference atlanta october 
pearce kelly field harder dynamic instrumentation tool linux kernel th international conference computer performance evaluation april 
reed noe roth shields schwartz scalable performance analysis pablo performance analysis environment scalable parallel libraries conference los alamitos ca october pp 

de robust just time instrumentation technique workshop binary translation philadelphia october 
miller dynamic kernel instrumentation kernel application tuning international journal high performance computing applications fall 
wessels squid internet object cache squid nlanr net squid august 
xu miller dynamic instrumentation threaded applications th acm sigplan symposium principles practice parallel programming atlanta may 
