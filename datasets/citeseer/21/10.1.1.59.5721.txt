sequential programs multi tier applications program transformation modern applications designed multiple tiers separate concerns 
tier may run separate location middleware required mediate access tiers 
introducing middleware tiresome error prone 
propose multi tier calculus splitting transformation address problem 
multi tier calculus serves sequential core programming language constructing multi tier application 
application developed sequential setting 
splitting extracts process tier sequential program concurrent execution behaves original program 
splitting transformation starts assignment primitive operations tiers 
program analysis determines communication requirements inserts remote procedure calls 
transformation step performs resource pooling optimizes communication behavior transforming sequences remote procedure calls stream protocol 
final transformation step splits resulting program separate communicating processes 
multi tier calculus applicable construction interactive web applications 
facilitates development providing uniform programming framework client side server side programming 
categories subject descriptors programming techniques concurrent programming distributed programming programming techniques automatic programming program transformation logics meanings programs semantics programming languages operational semantics general terms design languages theory permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl january long beach california usa 
copyright acm 
matthias neubauer peter thiemann institut informatik universit freiburg germany neubauer thiemann informatik uni freiburg de keywords type systems concurrency application 
building modern application longer task programming isolated machine 
cases application distributed multi tier architecture 
accesses data database servers business logic runs application server presentation logic deployed web server user interface runs web browser 
software tier developed separately application specific communication interfaces tiers 
designers create interfaces programmers implement middleware 
top usual coding testing activity programmers burdened quirks distribution testing difficult flaws middleware code created third party programmers potentially additional source errors final application 
programmer task alleviated programming framework automatically prepares program physical distribution 
main development activity takes place simpler non distributed setting 
integration testing performance testing course final deployment application involves distributed production setting 
proposes programming framework consisting calculus static analysis performs assignment code locations range program transformations automatically insert communication primitives perform resource pooling split program separate processes run separate locations 
locations sense abstraction different physical logical places tiers final application supposed reside 
starting point assume application consists sequential programs run concurrently single server 
program runs independently behalf particular client 
programs communicate explicitly access modify common resources server 
task transformation split sequential program pieces run independently different hosts equip communication primitives sequential semantics original program preserved 
operation sequential program carries annotation indicates operation location independent 
location independent operation side effects depend data stored particular location 
example operation primitive datatypes location independent accessing modifying 
location dependent operations carry location annotation indicates operation safely take place 
interplay location annotations drives static analysis program 
operations different locations interfere 
example database queries run application server database connection sense outside application server 
contrast gui operations run client gui objects server 
principle result splitting transformation directly applicable annotated programs lead programs sprinkled short communications 
repeated connection establishment expensive separate program transformation performs resource pooling reusing established connections locations 
describe algorithm abstractly terms transformation steps program calculus 
calculus lambda calculus equipped synchronous communication primitives 
inspired gay hole calculus session types 
calculus simply typed variant calculus subtyping models asynchronous communication ports channels 
channels transmit heterogeneous data prescribed session type 
gay hole chosen lambda calculus trivial embed sequential programs 
particular variant simply typed applied call value lambda calculus normal form 
communication calculus stream ports channels similar operations calculus session types 
normal form simplifies definition static dynamic semantics intermediate language compilers 
result transformation program explicit uses typed communication primitives analogous socket communication paradigm 
implementation map communication primitives communication architecture provided chosen middleware 
alternatively direct implementation terms socket api possible 
web application special case multi tier application tiers run web browser 
framework applicable case suitable mediator implements channels top 
special case splitting transformation yields client side slice server side slice application 
client slice may implemented applets server slice arbitrary server side scripting technology 
main contribution partitioning algorithm 
presentation consists steps specify location analysis infers required communications locations 
analysis stated terms annotated simple type system subtyping 
proved correct respect location aware operational semantics argument 
suite typed transformation rules merge communications identical partners larger sections stream communi rec show topic db tid tpc stmt string append select messages tid tid msgs sql exec db stmt hdr string append topic tpc frame gui create frame hdr show rows db frame msgs gui show frame frame show rows db frame msgs sql cursor elements db msgs row sql cursor get row db msgs cts sql cursor get column db row contents lab gui create label cts gui frame add frame lab show rows frame msgs 
original sequential program cation 
rules proven correct respect location aware semantics extended synchronous communication 
splitting transformation extracts concurrently running processes transformed expression 
transformation proved correct 
target calculus language channel communication 
type system novel variant system session types 
rest motivate suite transformations excerpt client server application section 
section introduces source calculus simply typed linearized call value lambda calculus 
section develops annotated type system specifies location analysis source calculus 
formalizes static dynamic semantics proves type soundness 
section introduces multi tier calculus extends source calculus explicit channel communication primitives 
section defines transformation steps implement connection pooling section presents splitting transformation 
section discusses related section concludes 

tiny multi tier application section introduces example application message board shows discusses results location analysis splitting transformation 
concreteness example programmed ocaml easy translate formal calculus introduced section 
message board application enables users view post messages attached certain topics centrally accessible virtual blackboard 
message starts new topic responds message existing topic 
application draws kinds resources usually reside different physical locations central database server windowing environment handling user rec show topic db tid tpc stmt string append select messages tid tid msgs sql exec db stmt tpc trans tpc hdr string append topic tpc frame gui create frame hdr show rows db frame msgs gui display frame frame show rows db frame msgs sql cursor elements db msgs trans row sql cursor get row db msgs cts sql cursor get column db row contents cts trans cts lab gui create label cts gui frame add frame lab show rows frame msgs 
program location analysis fat client interactions 
database accessible textual sql interface windowing environment provides usual gui widgets 
database contains relation messages tuple describes message topic contents author 
administrative fields include topic id tid flag indicating message starts new topic 
shows functions taken program 
show topic implements basic operation message board display list messages topic 
queries database existing database connection db topic id tid presents content fields resulting message set new gui frame 
relies show rows populate gui frame text label message topic id code relies library functions access database perform gui operations 
particular function sql exec returns cursor result sql query functions sql cursor access relation underlying cursor gui functions create manipulate appropriate gui widgets 
library functions location independent 
sql operations take database connection db parameter 
annotation indicates connection available server location analysis prescribes sql operations take place server 
contrast gui widgets created gui create frame gui create label gui frame add operation gui display frame run ocaml left hand side pattern match value right hand side 
pattern wildcard pattern matches value 
client machine indicated annotation 
operations string append location independent may execute 
location analysis assigns operation set locations operation take place 
starting operations fixed initial assignment location information propagated program implicit communication trans inserted data available required available location outcome analysis determined propagation strategy 
depending strategy analysis may produce fat clients thin clients may choose duplicate operations multiple locations avoid overhead transmitting results 
shows possible outcome analysis gui widgets constructed client 
point program may split client process server process 
doing inefficient trans builds connection client server transmit data item 
joining transformation addresses inefficiency 
joins adjacent communications switching style stream style 
main idea joining transformation introduce explicit channels open close operations float open operations close operations hopes merging 
transformation go complication deal smoothly conditionals recursion 
splitting transformation extracts annotated program slice location 
running slices parallel equivalent running original program 
contains final program example 
contains processes share communication port process structure essentially slice original program 
server process opens server channel port listen 
slice show rows sends boolean indicating data 
case sends tuple attempts process tuple recursively 
show rows exits channel closed 
client process performs exactly converse communications opens client channel receives data sent 
technically communication typed session type form string boolean true tuple false 
type describes possible sequences communication events channel read string repeatedly read boolean read tuple continue close channel 
choice depends communication labels true false type applications chan true chan false 
indicate type level branch conditional taken 
true false values communication labels status record labels 
explanation glossed intermediate technical steps introduce additional infrastructure term 
example step introduces channels open operations 
defer closer discussion intermediate steps subsequent sections section 
newport expression written calculus 
newport server process rec show topic db tid tpc chan listen stmt string append select messages tid tid msgs sql exec db stmt send chan tpc show rows chan db msgs close chan show rows chan db msgs sql cursor elements db msgs send chan chan true row sql cursor get row db msgs cts sql cursor get column db row contents send chan cts show rows chan db msgs chan false 

source calculus underlying programming model simply typed call value lambda calculus integers primitive operations recursion 
simplify matters calculus intermediate language 
syntax var expressions halt statements op rec expression sequence bound statements halt instruction conditional jump parameters 
statement performs primitive function operation introduces set mutually recursive jump labels 
argument subterms expressions statements restricted variables 
primitive function free side effects 
nullary primitive functions serve constants 
operation op unspecified side effects 
arguments results primitive functions operations restricted order values 
notation stands sequence 
xn derives context 
refrain stating type system semantics source calculus straightforward derive definitions extended calculi subsequent sections 

introducing locations expression describes computation location 
section extends express certain computations run specific locations tiers 
client process rec show topic chan connect tpc recv chan hdr string append topic tpc frame gui create frame hdr show rows chan frame close chan gui display frame frame show rows chan frame recv chan chan true cts recv chan lab gui create label cts gui frame add frame lab show rows chan frame chan false 
program split separate processes program executing centralized locus control 
location subset program effect visible 
values variables available subset locations operations available specific locations data moved explicitly location 
syntactically new statement modification trans op statement trans transmits value location location finite set locations 
value available executing statement 
value available location locations available typically trans statement just extends availability include base values transmitted locations 
functions pointers transmitted 
statement op performs operation side effect location available location 
values available executing statement result operation available 
side effect op visible location 
rest section introduce dynamic semantics terms labeled transition system 
type system tracks location values addition actual type 
type system extends system simple types location annotations annotation subtyping 
prove type soundness system 
dynamic semantics dynamic semantics defined small step transition system 
intermediate states system require extension syntax usual 
kinds computed values system val fun rec value constant set locations indicates value available function consisting function name set mutually recursive function definitions selects function 
functions carry set locations assumed available locations 
original expressions statements extended admit values bound occurrences variables allowed original syntax 
evaluation steps produce traces observations 
traces observations words observations halt op halt intended register halting expressions op register particular call pattern operation op executed location locs denote set locations observations operations op occurring trace specify reductions families relations indexed trace 
defines notions reduction relation core reduction relation remains constant rest 
describes evaluation steps transform producing side effect 
reduction deals trans statement 
relation op describes operations side effects 
op denote reductions operations location addition combined relations imp core op pure core imp 
rule primitive functions substitutes result function determined partial function rest term 
result available locations arguments available 
primitive operation happens designated location leaves trail trace 
operations behave nondeterministically modeled relation 
choice may odd 
model include possibility location processes run parallel program 
model side effects passing state location state may change operations program due effects process 
nondeterministic model avoids passing state explicitly encompasses arbitrary effects processes 
definition set mutually recursive labels substitutes function value defined label 
function value consists label identifier paired definition group 
conditional dispatches evaluation true false branch usual 
function call extracts selected function definition definition group substitutes arguments function body 
function body may refer functions definition group wrapped new definitions subtyping argument rules definition group 
static semantics type system model facets value shape locations available 
keeps track shape underlying simply typed system adds location annotations effects keep track locations 
annotation subtyping produces precise analysis results 
annotated type base type paired set locations function type location set latent effect 
meaning annotation associated data item locations effect function type indicates set locations may execute operations function applied 
typing judgments 
states uses variables correctly may perform operations locations states transforms may perform operations infers type argument position 
subtyping system structural induced solely location annotations 
subtyping formalized judgment expresses value location set substitute value expected subset effect annotation subtype included annotation supertype 
figures contain subtyping rules typing rules expressions statements 
halt expression requirements perform effect location 
effect statement union effects statement body expression 
conditional needs executed location branches contains code executed location 
value condition needs available locations mentioned effect branches 
function application latent effect function 
rules primitive functions operations reflect operational semantics subtyping intersect location sets implicitly 
recursive label implicitly available locations 
trans statement copies value available location location binds appropriately changed type 

val ij nj 
rec fi xi ei val val fun rec fi xi ei fj op 
val ij nj 
trans val halt nd ne nd ne xi 
xn xi op 
xn fi xj ej nj ni rec fi xi ei fi trans typing rules properties connect requires erasure function maps expression expression forgetting locations removing trans statements 
types erasure function strips away location sets effects 
erasure properties respect underlying unannotated calculus typing judgment indicated 
lemma 


exists 
expression constructed second part completion existence completions shown inserting transmission statements location statement 
completions uniquely defined general 
example consider operations core val nj nj core fj fun rec fi 
fj core core core rec fi xi ei ej xj op op val op nj val reduction rules available respectively 
source halt completion trans halt second completion trans halt completions perform additional useless transmissions 
example shows obvious notion optimality minimality completions 
completion may perform fewer operations second performs fewer operations clear preferable information moment leave question implementation analysis 
implementation choice formalized preferences locations 
implementation may introduce redundancy performing computation location 
choice trades communication computation 
routine prove type soundness calculus evaluation typed closed expression reaches halt finite number steps keeps reducing forever 
typing rules values intermediate states straightforward 
lemma type preservation 
suppose locs lemma progress 
halt exists locs furthermore define reflexive transitive closure evaluation relation follows type soundness follows straightforward induction 
theorem 
halt locs exists locs label var statements op rec open openp close trans expressions halt types type environments session types session type environments li syntax mt 
multi tier calculus multi tier calculus mt calculus explicit communication instructions 
previous calculus statement trans just states necessity communication nodes declarative way 
contrast mt augments trans channel argument provides primitives explicitly open close communication channel 
defines syntax multi tier calculus mt main extension calculus respect consists statements open channel open transfer data connection trans close connection close 
comparison trans statement obtains channel parameter functions receive additional channel parameters channel value bound normal variable channel changes type communication 
channel variables treated linearly simplify tracking change type 
extensions added time remaining transformation steps expressed leaving calculus mt splitting open statement yields statements open channels matching type 
calculus expression introduces fresh port name openp statement opens channel type prescribed port opening channels port ensures channels session types match occur different places program 
freshness port names ensures port value occurs run program 
usual fresh names commutative consider expressions modulo smallest compatible equivalence relation containing fv statement applies channel statically known label 
type application operational effect 
intuitively selects labeled types channel session type 
type changes channel application 
section explains role typing 
translation mt straightforward 
halt nd ne nd ne port typing rules target mt expressions replaces occurrence statement trans sequence statements opens explicit channel locations transmits current value binds value closes ends connection open trans close dynamic semantics definition dynamic semantics requires extension syntax values ain section 
additionally new binder needed model open communication channel 
expression 
introduces fresh linear name channel locations contains reduction rules handle new communication statements evaluation contexts extend reduction rules binding constructs 
opening channel introduces fresh channel name 
transmission value possible channel connecting appropriate locations 
closing channel amounts removal channel binder application channel label operational effect 
mt notions reductions mt pure compatible closure core mt compatible closure imp mt compatible closure core op static semantics judgments static semantics mt extend judgments expressions statements new type linear environment associates channel open openp trans val close xi 
xn xi op 
xn op cj fi val reduction rules mt xj ej nj rec fi ci xi ei fi trans trans open port openp close li lj typing rules target mt statements variable session type pair locations connected channel 
session type denotes regular language describes sequence types rest session communicates channel 
type indicates communication take place channel sends base value continues receives value continues 
type 
conditional session type guarded labels 
channel application li changes type application recursion operator expansive formed session type subterms form 

subterms correspond regular trees 
example type section string boolean true tuple false denotes language string boolean tuple boolean string boolean tuple boolean communication channel changes session type variables obey linear typing discipline 
contains annotated typing rules expressions 
rules reflect previous rule set impose additional demands channels 
halt expression requires channels closed 
conditional requires branches channels way 
rule indicates statement transforms environments 
function call pass channels function 
annotated typing rules statements appear 
original rules rule function definitions changes significantly 
additional requirement function may refer channels passed parameters function free channel variables 
transmission value changes type channel expected 
closing channel requires session type opening channel invents session type 
applying channel label selects corresponding alternative channel session type 
subtyping rules remain unchanged 
argument typing rules change marginally 
notion bisimilarity prove correctness program transformations need state relationships source programs transformed counterparts 
consider programs equivalent perform side effecting operations order 
notion equivalence best captured weak bisimulation 
definition suitable bisimulation requires split transition rules parts reductions side effect 
corresponding observation relation transitions reach transition keeping final observation 
formally relation defined follows halt halt halt expression related non terminating term 
observable step related expressions observation relation 
unobservable steps may prepended observation relation 
milner gordon define weak bisimilarity inductively greatest fixed point functions parame respect transition relations def def op op def denotes pairs reach pair simulated common step restriction simulation ways 
weak bisimilarity greatest relation properties greatest fixpoint technical results type soundness established usual way type preservation result progress result 
lemma type preservation 
mt locs lemma progress 
halt exists mt locs translation defined section preserves typing results programs observational behavior 
lemma 
lemma 
pure op mt pure op 
datagrams streams transformation previous section works correctly produces inefficient programs 
value location needed location program sends datagram opens channel sends value closes channel 
inefficiency lies cost connection establishment 
cost higher cost transmitting value better cost connection establishment amortized value transmissions possible 
avoid repeated connection establishment define set transformation rules mt terms seek join close open statements channel goal reusing channel multiple communications 
essentially transformation turns sequence datagram transmissions hosts stream connection 
specifies transformation terms relation es 
strategy applying transformation rules float open statement upwards list statements holds 

open meets close matching reversed locations 
case channels joined statements eliminated 

open reaches function body 
function recursive open split separate non recursive wrapper function 
standard inlining transformation transport open call sites function 
transformation stops functions certain toplevel functions 

open reaches top branch conditional 
possibilities 
branch matching open transformation rule inserts channel application label true branch false branch 
original types channels true false branch type channels joined hoisted front conditional 
matching open available branch transformation rule may introduce new channel source destination host opened immediately closed 
joining takes place 
typing preserved compatible closure es relation es 
transformation es leads weakly bisimilar programs 
lemma 
es exists lemma 
es mt pure op mt pure op 
splitting transformation type derivation mt program splitting transformation extracts location program slice running slices parallel respective locations equivalent running original program 
transformation proceeds steps 
step introduces global port names connection 
port names serve globally visible points contact processes generated step number 
second step pools introductions port names program 
third step extracts slices type derivation slice contains separate process location 
port step splitting transformation ports replaces occurrence open 
expression openp header refers explicit port name surrounded abstraction introducing precisely port name openp 
translation preserves typing 
translation produces weakly bisimilar programs 
lemma 
lemma 
mt pure op mt pure op port floating step moves port binders program 
specifies transformation terms relation pb 
second rule lifts port binder arbitrary function definition block 
typing preserved compatible closure pb relation pb 
transforming pb leads weakly bisimilar programs 
open es open var open es open close open es rec open open open es rec open es open es open close extending scope channel mt pb var rec pb rec lemma 
pb lemma 
pb mt pure op mt pure op mt magic preparation splitting transformation replace multi location communication operations mt traditional communication operations add operator concurrent execution 
example trans statement mt specifies sending location receiving location channel time 
open close statements perform operations locations 
additional syntax final calculus mtc 

close listen connect send recv 
expression specifies interleaved execution 
statements sided versions previous communication statements 
unspecific open statement establishing channel locations listen connect create server client channel specific port 
manner separate communication operations send outbound message recv inbound message established channel 
dynamic semantics intermediate states need additional syntax expression introduces pair fresh linear names model ends channel 
notions reduction mtc mtc pure compatible closure core mtc compatible closure imp cf 

evaluation contexts defined relations consider expressions modulo smallest compatible equivalence relation satisfying floating port binders kinds 
var fv fv fv 
reduction rules fig 
follows 
pairing listen command connect command port results channel abstraction channel names replaced paired names send recv pair channel results transferring value 
closing ends channel amounts dropping channel entirely 
application channel label synchronization construct 
requires label application channel proceed 
mtc mtc compatible closure core op notion reduction 
static semantics contain typing rules new statements expression 
port created fixed session type associated 
port globally available type port carry location set 
idea listen binds server channel location channel inherits session type port connect creates client 
sending receiving data exactly reversed client session type mirrored indicated cf 
assigned new client 
send recv operations peel communication event channel type send outbound event recv inbound event 
revised close operation closes channel 
rule concurrent execution splits linear channel environment disjoint parts subprocess indicated operator 
value environment listen connect send recv close close port listen port connect send recv close typing extended target syntax mtc li li mirroring channel types copied subprocesses effect gathered 
slice extraction final step starts type derivation transformation skips leading port binders extracts ai slice location ai puts parallel 
resulting program form 

strictly speaking transformation requires type derivation input 
avoid clutter input term carries annotations 
annotation provides inferred effect expression statement 
handling channel transformation needs know source target locations channel 
annotation provides information 
pieces information type derivation 
lemma 
suppose transformed program weakly bisimilar original consider effects location separately 
lemma 
location holds mt op mt op reduction rules mtc 
related splitting transformation closely related program slicing 
advances slicing deal concurrent programs slicing introduce new operations transformation maps sequential program multi threaded program 
difference slicing usually driven program dependency graph transformation driven location analysis includes dependency information typing rule conditional 
secure program partitioning spp closely related transformation maps sequential program distributed program 
goals spp quite different 
spp starts program confidentiality integrity annotations functions data number hosts 
annotations spp partitions program host runs part program credentials appropriate 
partition ensures host receives data confidentiality level data host trusted integrity level 
extension authors replication increase scope spp 
binding time analysis seen special case location analysis 
example trans construct closely related lifting 
binding time analysis distinguishes modes computation static dynamic location analysis locations distinguishes different modes 
calculus may viewed instance capability calculus restricted simple types specialized particular resources channels locations 
specialization enables exploit properties reach capability calculus 
session types emerged expressive typing discipline heterogeneous bidirectional communication channels 
message may different type possible sequences messages determined channel session type 
type discipline subsumes typings datagram communication homogeneous channels 
research parallel implementation functional languages concerned automatic detection implicit parallelism speculative evaluation expressions 
analysis detect parallelism determines independent slices programs explicit communication interfaces 
speculative evaluation transformed programs splitting transformation guided location analysis may introduce redundancy performing location independent operations location simultaneously 

location analysis enables splitting application slices execute independently toplevel expressions am 
am expressions halt halt ta halt ta halt statements rec op op rec openp listen connect rec close close rec rec fi ci xi ei rec fi ci xi ei trans send recv rec lj jc lj rec parameter lists ta slice extraction mtc parallel communicate typed streams 
analysis accompanying transformations enable development distributed applications local setting 
transformation steps proven correct 
ongoing considers efficient implementation location analysis 
challenge analysis configurable respect location preferences communication requirements 
gives specification 
practical experience show polymorphic analysis required 
general mapping tiers multi language issue requires additional translation step framework language desired target languages 
alternatively heterogenous framework considered analysis applies directly different languages 
acknowledgment indebted anonymous reviewers numerous extensive comments helped improve presentation significantly 

flanagan sabry duba felleisen 
essence compiling continuations 
proceedings conference programming language design implementation pages albuquerque new mexico june 
gay hole 
types subtypes client server interactions 
swierstra editor proceedings european symposium programming number lecture notes computer science pages amsterdam netherlands apr 
springer verlag 
gordon 
bisimilarity theory functional programming 
theoretical computer science oct 
greiner blelloch 
provably time efficient parallel implementation full speculation 
acm transactions programming languages systems 
henglein 
efficient type inference higher order binding time analysis 
hughes pages 
hughes editor 
functional programming languages computer architecture number lecture notes computer science cambridge ma 
springer verlag 
jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall 
krinke 
context sensitive slicing concurrent programs 
proceedings th european software engineering conference pages 
acm press 
leroy 
objective caml system release documentation user manual 
inria france july 
pauillac inria fr caml 
milner 
communication concurrency 
prentice hall englewood cliffs nj 
ramesh 
slicing concurrent programs 
proceedings international symposium software testing analysis pages 
acm press 
park 
concurrency automata infinite sequences 
proceedings th gi conference theoretical computer science number lecture notes computer science pages 
springer verlag 
peyton jones 
parallel implementations functional programming languages 
computer journal 
peyton jones launchbury 
unboxed values class citizens non strict functional language 
hughes pages 
stevens 
unix network programming 
prentice hall software series 
tang jouvelot 
effect systems subtyping 
scherlis editor proc 
acm sigplan symposium partial evaluation semantics program manipulation pepm pages la jolla ca usa june 
acm press 
tip 
survey program slicing techniques 
programming languages 
walker crary morrisett 
typed memory management static capabilities 
acm transactions programming languages systems july 
zdancewic zheng nystrom myers 
secure program partitioning 
acm transactions computer systems 
zheng chong myers zdancewic 
replication partitioning build secure distributed systems 
proceedings ieee symposium security privacy page 
ieee computer society 
