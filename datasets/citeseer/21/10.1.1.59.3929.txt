soundness completeness formal logics symmetric encryption bana dissertation mathematics faculties university pennsylvania partial fulfillment requirements degree doctor philosophy andre scedrov supervisor dissertation david graduate group chairperson copyright bana andre scedrov tremendous support thesis advisor introducing subject information security cryptography community 
pedro ad university lisbon great hours research spent subject reading manuscript providing valuable suggestions 
due richard learned math life matters 
thesis supported onr cip sw uri software quality infrastructure protection diffuse computing onr additional support nsf ccr 
iii soundness completeness formal logics symmetric encryption bana supervisor andre scedrov decades major directions cryptography developed formal com putational 
formal approach uses simple manageable formal languages describe crypto graphic protocols approach amenable automatization suitable computer tools accuracy unclear 
computational approach harder handle mathematically involves probability theory considers limits computing power proofs done hand accurate widely accepted 
effort bridge gap approaches including martin abadi philip rogaway considered formal logic symmetric encryption interpretations cryptosystems computational complexity 
abadi rogaway setting important ingredients formal language equivalence notion formal expressions computational cryptosystem notion computational equivalence ensembles random distributions interpreting function assigns formal expression ensemble distributions 
say interpretation satisfies soundness equivalence formal expressions implies computational equivalence interpretations satisfies completeness computational equivalence interpretations requires equivalence expressions 
consider expansions abadi rogaway logic indistinguishability formal crypto graphic expressions 
formal language logic uses box notation strings formal equivalence defined 
expand logic considering differ ent kinds boxes corresponding equivalence classes formal ciphers 
consider computational purely probabilistic information theoretic interpretations 
general systematic treatment expansions logic symmetric encryption 
establish general soundness completeness theorems interpretations 
applications specific settings covered earlier works purely probabilistic iv formal expressions time pad computational settings called type key revealing cryptosystems computational complexity 
contents iii iv contents vi views cryptography abadi rogaway formal language 
formal model messages expressions 
formal adversary distinguish equivalence 
expansions abadi rogaway formal language 
proper equivalence ciphers 
computational framework cryptographic schemes 
symmetric encryption schemes 
levels security 
hiding 
information theoretic treatment 
time pad 
general probabilistic framework symmetric encryption 
interpretations soundness computational interpretation formal expressions 
vi soundness type encryption scheme 
interpretation expressions time pad 
soundness time pad 
interpretation soundness general 
interpretation 
soundness 
completeness parsing process 
completeness 
completeness type encryption schemes 
completeness time pad 
general case 
bibliography vii designing verifying security protocols complex problems certain level idealization needed order provide manageable mathematical treatment protocols notion security 
idealizations necessarily omit properties real system lead leaks security 
protocols quite simple case security properties supposed achieve subtle hard formulate checking really achieve may impossible task 
difficulties typically arise subtleties cryptographic primitives combining security protocols required properly multiple instances carried parallel case malicious intruder may combine data separate sessions order confuse honest participants 
number methods different levels idealizations analyzing security protocols main highly treatment help formal logic detailed description complexity probability theory 
cryptographic operations modeled functions space symbolic formal expressions security properties treated formally 
examples :10.1.1.27.6385:10.1.1.115.3569
cryptographic operations act strings bits security properties defined terms probability computational complexity 
examples treatment 
approach labeled literature formal view second computational view 
computational view gives detailed description cryptographic operations limited computing power account probability plays important role 
pro adversaries bad efficiently 
keys plaintexts ciphers strings bits encryption decryption adversaries probabilistic algorithms mathematically defined notion computability poly nomial time imposed algorithms 
view originates blum goldwasser micali yao 
major achievement approach common notions security secrecy authentication mathematically precise definition clarifying making amenable mathematical analysis 
hand detailed structured nature view analyzing complex protocols hard task calls higher level treatment 
formal methods introduced works dolev yao demillo lynch merritt millen clark freedman kemmerer burrows abadi needham meadows different approaches techniques 
main formal approaches include specialized logics ban logic special purpose tools designed security protocol analysis theorem proving model checking methods general purpose tools described multiset rewriting framework strand spaces framework 
methods differ significantly ways rely basic assumptions adversary may interact protocol 
common model largely derived suggestions protocol adversary allowed choose possible actions nondeterministically set messages may interfere protocol restricted severely 
idealized assumptions protocol analysis tractable possible verify protocols fact susceptible simple attacks lie outside adversary model 
necessary establish criteria limitations applicability formal methods 
hoped clarifying relationship formal computational views lead better understanding problem 
research efforts relate highly idealized formal model cryptographic techniques computational probabilistic polynomial time computability including :10.1.1.5.7484
efforts developing rigorous mathematical treatment relationship models 
hoped eventually lead new generation high fidelity automated tools security analysis able express implement methods concepts modern cryptography 
go details relationship model discuss third model 
called information theoretic view 
computational security cryptographic system relies computational infeasibility breaking information theoretic security requires system theoretically 
condition course stronger rely assumption computational security problems hard solve proved 
origins approach go back foundations cryptography science shannon communication theory secrecy systems companion laid foundations information theory 
shannon proof perfect secrecy requires secret key length plaintext considered evidence perfect security practical 
research shows see possibilities applications information theory cryptography 
explore information theoretic interpretations formal cryptographic expressions 
previous original approach abadi rogaway thesis attempt give fairly complete analysis uses simple formal structure building messages formal keys bits repeated pairing encrypting constructing set formal expressions way 
formal expressions interpreted computational framework symmetric encryptions 
interpretation ensemble probability distributions parametrized security parameter set finite bit strings assigned formal expression 
formal computational view notion equivalence expresses security 
formal view equivalence formal expressions defined computational equivalence ensembles probability distributions 
question happens equivalence interpretation 
true equivalence formal expressions imply computational equivalence interpretations say soundness holds 
direction true computational equivalence interpretations formal expressions implies formal expressions equivalent say completeness holds 
soundness formal logic interpretation proved abadi rogaway case computational encryption scheme formal expressions interpreted called type essentially means partial information revealed encrypted plaintext encrypting keys impossible detect encrypting keys plaintext repeated 
little micciancio warinschi showed completeness situation requiring called confusion freeness encryption scheme requirement ensures decrypting wrong key detectable 
authors indicated expand abadi rogaway formalism length plaintext revealed 
condition confusion freeness relaxed new completeness proof method horvitz gligor replacing confusion freeness weak confusion freeness 
extensions method includes micciancio warinschi considered public key encryption laud corin composite keys works herzog liskov micali plaintext aware cryptosystems connection symbolic information theoretic view explored guttman thayer zuck 
consider original approach abadi rogaway provide complete general systematic treatment hoping serve inspiration dealing complex formal cryptographic languages interpretations similar generality 
extends applicability ar language directions orga single formalism 
hand interpretations computational frame works consider interpretations purely probabilistic information theoretic encryption schemes 
hand expanding ar language changing basic frame show adjust formal notion equivalence order maintain soundness completeness encryption scheme hosts interpretation computational information theoretic leaks partial information 
order extend applicability ar language change notion mal equivalence language abadi rogaway logic uses box formal notation undecryptable expressions equivalence formal expressions expresses notion security defined help box 
expanded formalism adopt different kinds boxes allowed loosely speaking correspond different kinds able expressions 
idea new micciancio warinschi give treatment encryption schemes reveal length plaintext 
establish soundness completeness specific interpretations 
give treatment handle different boxes general general soundness completeness theorems established 
specific interpretations discussed detail information theoretic interprets formal expressions time pad called type key revealing cryptosystems computational complexity 
examples shed light expansions ar logic interpretations different angles prepare general treatment 
name type cryptosystem stands encryption scheme reveal key encrypt twice 
show soundness abadi rogaway interpretation expanded logic includes separate box key case 
show completeness expanded logic weakly confusion free strictly key revealing cryptosystems 
strictly key revealing mean exists probabilistic polynomial time adversary distinguish pairs oracles encrypting key encrypting different keys 
completeness assume decryption wrong key computationally distinguishable correct decryption horvitz gligor called weak confusion freeness 
case time pad time pad means plaintext length key length generated uniformly xor ed plaintext natural expansion abadi rogaway logic involves boxes indexed length encrypted message matching length encrypting key formal length function introduced 
hand define formal equivalence expressions help boxes 
hand postulate time pad realizations formal expressions equivalent probability distributions identical 
show soundness completeness interpretation specific implementation otp 
general treatment index boxes equivalence classes formal ciphers equivalence relation expresses inability adversary distinguish ciphers 
equivalence relation chosen keeping mind security level encryption scheme host interpretation 
example case time pad cryptosystem reveals length equivalence relation corresponds length formal ciphers 
interpret formal expressions type cryptosystems equivalence relation render ciphers encrypted key equivalent 
scheme reveals key length equivalence relation defined formal ciphers equivalence holds iff ciphers lengths encrypted key 
general probabilistic framework introduced contains computational purely probabilistic treatments special cases 
advantage need formulate general statements twice true computational information theoretic models 
literature computational complexity considered probability distributions indexed security parameter ensembles distributions dealt information theoretic models notion security parameter ensembles distributions single distributions handled 
overcome discrepancy show hide security parameter deal single distributions computational view 
prove general soundness general completeness theorem 
theorems essentially claim soundness completeness holds certain subset formal ex soundness completeness valid expressions 
necessary assume soundness greater subset subexpressions completeness order derive theorems 
reason probabilistic view detailed description indistinguishability distributions tuples random variables follow fact corresponding pairs tuples indistinguishable identical equivalence tuples formal expressions built pairwise equivalence 
layout dissertation structured way section review formal language abadi rogaway formal expressions built equivalence defined introduce treatment expansions prove propositions notions introduce 
propositions essential general soundness completeness results 
section review definition symmetric encryption schemes security computational framework subsection explain hide eta computational formalism compatible information theoretic 
section specific implementation time pad show handle computational information theoretic encryption schemes 
sections chapter devoted interpretations soundness theorems type encryptions time pad 
subsection proving soundness type systems detailed example showing major steps proof 
section devoted general interpretation general soundness theorem examples type cryptosystems 
chapter devoted completeness results 
need formalize mathematically process decrypting possible sample interpretation formal expression 
done section section completeness theorems type schemes time pad general case 
elaborate concrete example section section steps theorems 
chapter views cryptography abadi rogaway formal language formal model messages expressions abadi rogaway introduced simple formal language model symmetric cryptographic protocols 
language simple describe realistic situations suitable isolate subtleties relationship formal computational treatments cryptography 
formal setting set expressions correspond messages transmitted cryptographic protocol 
encryption operates set expressions resulting new expressions 
expressions built keys blocks bits pairing encryption 
accordingly formal definition expressions 
definition expression 
keys discrete set symbols keys 
blocks nonempty subset finite bit strings blocks define set expressions exp grammar expressions key keys block blocks pair encryption keys set expressions denoted exp denote keys set keys occurring ciphers denote set encryptions 
set blocks model fixed set strings messages keys stands encrypting keys usually random variables reality 
emphasize formal view sets purely sets symbols 
example expression looks example 
course necessary keys 
case keys 
expressions unambiguous means means need notion subexpression defined follows definition sub expression 
define set sub expressions expression sub inductively follows sub keys sub blocks sub sub sub sub sub 
say sub expression denote sub 
order able formulate statements expressions conveniently need terminology definition encrypted expressions cyclic set keys 
say key encrypts expression expression subexpression subexpression expression say subset keys cyclic exists ln li encrypts li encrypts ln keys lead serious difficulties practice better avoid 
try reduce conditions minimal theorems indicate condition needed theorem true 
problem suggests useful restrict attention valid expressions exp subset exp defined set restricting rules excluded 
definition valid expressions valid ciphers 
set valid expressions subset exp exp keys blocks contained exp ii exp subexpressions exp number pairs subexpressions exp set valid expressions set valid ciphers ciphers ciphers exp formal adversary distinguish equivalence continue presentation abadi rogaway logic introducing notion equivalence expressions meant capture adversary distinguishing parts expressions 
adversary looks expression built keys blocks see keys encrypted 
help unencrypted keys decrypt messages encrypted keys unable decrypt 
adversary sees message see inside encrypted part revealed 
hand sees decrypt encryption see inside 
previous example adversary see help decrypt encryption counting left revealing help reveal see encryption left contains 
recover decrypt parts encrypted keys 
accordingly see need notion recoverable keys keys extracted expression succession descriptions 
precise definition need key recovering function exp keys keys pair expression set keys assigns set keys union keys recoverable help keys keys blocks 
help function expression define succession sets keys ki 
clearly ki ki 
expression finite length natural definition recoverable keys 
definition 
expression keys keys kn kn kn 
keys ki 
expression unrecoverable key encrypts position consider equivalence expressions 
equivalence sup posed express expressions look adversary point view 
formalism abadi rogaway considered adversary undecryptable encryptions look equivalence formulated replacing undecryptable parts mes sage box 
formula obtain way called pattern 
formal definition definition pattern 
define set patterns pat grammar patterns key keys block blocks pair encryption keys undecryptable notation pat define patterns may contain kinds boxes 
define function patt set keys creates pattern expression replacing encryptions decrypted keys box definition 
keys 
define function patt exp keys pat inductively patt keys patt blocks patt patt patt patt patt pattern expression defined definition pattern expression 
expression pattern defined pattern patt keys 
exactly means encryptions decrypted keys recoverable replaced box 
example 
continuing example set recoverable keys pattern pattern keys ready define equivalence expressions route taken abadi rogaway 
treatment elements keys model randomly generated keys distribution 
model key generation algorithm 
replacing key expression occurrence replaced result equivalent expression 
definition key renaming function 
bijection keys keys called key renaming function 
expression pattern denotes expression pattern obtained replacing keys 
definition equivalence expressions 
say expressions equivalent respect pattern denote key renaming pattern pattern 
example 
previous example pattern pattern keys changes pattern turns pattern equivalent 
hand pattern equivalent bijection keys transfers pattern pattern expansions abadi rogaway formal language equivalence expressions defined previous section suitable situation formal language models protocols adversary distinguish encryptions unknown encrypting keys 
may case 
example adversary detect encryptions keys different ones simply replace encryptions single box need differentiate boxes keys encryption 
immediate concern single key generation algorithm may group set keys kind key generation processes represent 
example see case time pad length key needs matched length encrypted plaintext 
naturally equivalence defined case key renaming function allowed shuffle keys group 
expand logic abadi rogaway way exp subset valid expressions exp assume equivalence relation set keys 
simplicity assume equivalence class contains infinitely keys 
keys example 
see formal language time pad includes length function keys 
keys ultimately valid expres sions 
keys equivalent length 
modify notion key renaming function keys allowed renamed keys sort 
definition key renaming function relative 
bijection keys keys called key renaming function keys 
expression denotes expression obtained changing keys images 
restrict definition valid expression want require valid valid definition valid expressions valid ciphers 
set valid expressions subset exp exp keys blocks contained exp ii exp subexpressions exp number pairs subexpressions exp iii key renaming function relative exp exp set valid expressions set valid ciphers ciphers ciphers exp assume equivalence relation set valid ciphers property form ciphers key renaming function relative 
purpose relation capture ciphers adversary distinguish words partial information length key 
adversary receive cipher 
ciphers example 
consider cryptosystems adversary recognize ciphers encrypted different keys 
case need define ciphers equivalent encrypted key 
example 
authors find useful define length function exp way keys blocks ciphers considered indistinguishable adversary length 
chosen equates ciphers length element contain ciphers specific length 
naturally require condition renaming keys carry equivalent ciphers equivalent ones ciphers key renaming function relative 
key renaming function generates renaming denote 
definition formal logic symmetric encryption 
formal logic sym metric encryption triple exp exp set valid expressions equivalence relation keys equivalence relation ciphers require elements infinite sets key renaming function relative exp exp exp ii ciphers 
patterns need reflect fact ciphers contained different elements distinguished adversary 
need introduce different box element 
accordingly set pat defined definition patterns 
proceed induction patterns key keys block blocks pair encryption keys undecryptable 
corresponding pattern creating function defined way definition 
keys 
patt exp keys pat defined inductively patt keys patt blocks patt patt patt patt patt definition pattern valid expression 
pattern valid expres sion pattern pattern patt keys 
example 
case elements contain ciphers encrypted key correspondence keys index boxes keys element keys 
pattern pattern keys definition equivalence valid expressions 
say valid expressions equivalent denote key renaming pattern pattern pattern denotes pattern obtained renaming keys box indexes 
example 
previous example defining set recoverable keys pattern pattern keys changes pattern turns pattern equivalent 
proper equivalence ciphers section introduce natural property equivalence satisfied large class expanded abadi rogaway logics known significance 
definition proper equivalence ciphers 
say equivalence relation ciphers proper finite set keys contains element form contains element keys words contains element encrypted key representative key appears may appear encrypting key subexpression 
example 
denotes equivalence example ciphers equivalent iff encrypting key clearly proper works assumed infinitely keys 
blocks choice blocks empty 
example 
denotes equivalence example clearly proper choice constructed pairing times assumed infinitely keys 
propositions useful proving general soundness completeness results 
set able state proposition introduce key keys valid expression proposition 
exp proper 
equivalence relation equivalence class key infinitely elements 
proof 
assume encrypting keys different keys valid expressions 
proper assume keys 
assumed equivalence class contains infinitely elements key keys keys 
defining switch keys 
true 
hold 
infinitely choices infinitely encrypting keys 
proposition 
exp proper 
key renaming function relative key key 
proof 
key key 
bijection contains infinitely elements claim follows 
meaning proposition proper set valid ciphers ni li encrypting keys equivalence classes elements possible choose representative denoted key occurs li occurs subexpression key occurs corresponding equivalence classes single encrypting key 
proposition 
exp proper 
ni li set valid ciphers finite set keys li 
denote set equivalence classes respect elements element keys ii li iii keys keys key key set containing key case keys keys 
form subexpression 
proof 
observe ni li denotes equivalence class ni li ni li 
proof goes induction 
statement clearly true proper 
suppose true 
nn ln valid expressions set keys li loss generality assume numbering nn ln assume lm ln 
statement assumed true choose ni conditions ii iii hold ni nn ln ni li prove nn ln ni chosen 
consider sn keys ni li ln assumption nn ln keys sn ln implies nn ln choice follows fact keys sn 
ii true lm ln ensured way allows choose li keys sn ln ni assumed lm ln lm ni induction hypothesis 
iii follows keys ni keys sn keys implies ln 
clearly case ni form ln ln subexpression way allows chose holds lm ln nn ln ln satisfy conditions induction hypothesis 
nn ln loss generality assume lm ln nn ln ln satisfy conditions induction hypothesis 
cases choose ni conditions ii iii hold replacing nn ln ni li prove nn ln ni chosen iii obviously satisfied ii holds ln consider sn keys ni li assumption nn ln keys sn implies nn ln choice follows fact keys sn 
ii true ln li keys sn ln ni keys ni ln induction hypothesis 

iii follows keys ni keys nn ln case 
set sets conditions proposition denote nonempty satisfy conditions ii iii proposition useful property satisfied common logics need com result definition independent 
say independent finite set keys finite set ciphers key appears element key renaming function key renaming words independent finite set keys finite set ciphers key appears element possible alter key renaming function altered key renaming leaves elements unchanged thing original 
need property general completeness theorem 
computational framework cryptographic schemes symmetric encryption schemes computational modeling encryption schemes provides detailed description cryptographic protocol formal language previous section 
captures fact key generation encryption probabilistic includes fact computers limits computational power 
key generation algorithms represented random variables messages bit strings finite length algorithms encryption decryption key generation computable polynomial time relative called security parameter 
field actions set strings fixed subset plaintext strings represents messages allowed encrypted 
fix element plaintext 
subset keys strings chosen possible encrypting keys 
order able build messages basic ingredients assume injective pairing function strings strings strings 
range pairing function called pairs pairs ran 
symmetric encryption scheme constituents security parameter 
security parameter takes values natural numbers 
computationally represented finite string containing value purpose security parameter measure difficulty computations 
functions defined terms tested computable time interval larger polynomial function 
key generation algorithm 
keys encryptions assumed randomly generated 
random generation computable polynomial time respect security parameter 
mathematically key generation represented random variable keys keys discrete probability field prk 
denote function index probability field indicates probability field depend security parameter 
put index remind probability field key generation consider probability fields 
encryption algorithm 
encryption works follows keys plaintext ek encryption encrypting key random variable discrete probability field pre 
values random variable strings denoted ek assume ek sense pair denote dome subset keys plaintext ek defined 
rv strings stands set random variables values strings dome rv strings dome keys plaintext 
assume sequence keys plaintext keys ek polynomial time computable defined 
ciphers dome ran ek decryption algorithm 
encryption assume keys function dk subset domd keys strings satisfying dk ek dk polynomial time computable 
computational equivalence computational setting assume adversary access computers limited computing power 
purpose security adversary small probability getting valuable information encrypted messages expressed mathematically having little chance tell different ciphers apart 
messages random variables key generation encryption random exactly ensembles random variables security parameter adversary trying distinguish random ensembles 
order express means little chance distinguish ensembles need notion negligible function definition negligible function 
function said negligible nc nc 
formulate little chance tell ensembles apart 
definition usual notion computational indistinguishability formulate random variables take values general set strings need proofs 
consider random variables values set cartesian product strings finitely times sets strings strings strings strings identify strings 
definition computationally equivalent probability ensembles 
str set obtained cartesian products strings finitely times 
str str sequences random variables prf prg respectively 
dist dist denote probability distributions 
say ensembles dist dist computationally equivalent probabilistic polynomial time adversary function str computable polynomial time pra probability field pra prf pra prg negligible function 
tensor product stands product probability 
definition encryption scheme 
computational encryption scheme quadruple key generation algorithm encryption algorithm decryption algorithm decrypts ciphers encrypted relation computational equivalence 
require probability distribution distinguishable constant string distribution distinguishable distribution independently generated 
furthermore require property rank dom rank dom holds plaintext 
condition domain express requirement value security parameter defined defined defined 
words encrypted certain outcome key generation algorithm outcomes algorithm values security parameter 
levels security security computational encryption schemes formulated notion encryption oracles 
key keys encryption oracle ek assigns element plaintext xl encrypted ek ek ek xl xi dome ek xi ek 
denote ek oracle outputs ek ek ek receiving xl 
definition type security 
say computational encryption scheme type secure probabilistic polynomial time adversary distinguish pair oracles ek ek ek ek randomly generated 
probabilistic polynomial time algorithm querying ek ek ek ek pr ek pr ek ek negligible function 
formula means adversary pairs oracles ek ek ek ek keys randomly generated prior handing pair adversary know 
query pair try pair flipping coins doing polynomial time computations responses oracles 
queries adversary submits may depend previous responses oracles 
keys oracles encryption change adversary queries oracles 
come number 
adversary probabilistic encryptions done oracles keys randomly chosen case pair oracles certain probability adversary comes 
emphasize probability includes randomness key generation done oracles 
difference probabilities negligible function say pairs indistinguishable adversary encryption type secure 
type security meant express adversary tell oracles encrypt plaintexts adversary submits encrypt tell encryptions pair done key keys separately generated 
require encryption scheme repetition keys detected security level get way called type security definition type security 
say computational encryption scheme type secure probabilistic polynomial time adversary distinguish oracles ek ek randomly generated 
probabilistic polynomial time algorithm querying ek ek negligible function 
pr ek pr ek important notion literature type security key repetition concealed length encrypted message may revealed 
case require adversaries distinguish pairs oracles ek ek ek ek ek denotes oracle receiving xl returns ek ek ek xl ek xi denotes encryption string length xi xi dome ek xi dome definition type security 
say computational encryption scheme type secure probabilistic polynomial time adversary distinguish pair ora cles ek ek ek ek randomly generated 
probabilistic polynomial time algorithm querying ek ek ek ek pr ek pr ek ek negligible function 
combination type type security results type security reveal key repetition length definition type security 
say computational encryption scheme type secure probabilistic polynomial time adversary distinguish oracles ek ek randomly generated 
probabilistic polynomial time algorithm querying ek ek negligible function 
hiding pr ek pr ek subsection mention possible formulate computational theory considering single probability spaces ensembles 
trick considering random variables probability fields pr simply consider single random variable field pr 
random variables independent distribution coincides distribution 
probability space constructed infinite cartesian product spaces pr product measure pr 
terminology considering basic set encryption decryption operates take key generation results element keys encryption assigns element keys plaintext element strings encrypting component element plaintext corresponding component element keys decryption done similarly component wise 
computational equivalence random variables form 
course defined component wise 
advantage formalism way incorporate computational information theoretic formalism section single formalism 
information theoretic treatment information theoretic treatment cryptographic protocols similar computational condition computational power assumed security param eter appears 
consider specific example case time pad otp idea originates shannon proved perfect secrecy encrypting keys long encrypted message time pad name encryption scheme plaintext certain length generates uniformly distributed random key length plaintext xor ed 
time key generated avoid leaking information 
consider special implementation otp suits purposes 
time pad consider realization time pad strings pairing strings strings define pairing 
denotes concatenation strings separated commas stands denotes length string 
number indicate long second string pair separates strings suppose fixed natural number blocks ends just tag shows meaning string block 
case time pad plaintext encrypted generating uniformly random binary string key length plaintext key plaintext xor ed 
need tag keys fact generate key digits longer plaintext encrypt drop digits 
keys strings ends 
keys strings ends 
key generation 
key length separate key generation algorithm kn random variable prk values equally distributed keys keys core denote string get cutting 
encryption 
domain encryption elements keys strings dome keys strings expresses keys encryption length encrypted message 
encryption function defined ek core tag informs string cipher 
notice encryption probabilistic ek random variable 
ciphers strings ends ciphers ciphers 
observe pairs keys blocks ciphers disjoint 
decryption 
decryption function dk defined naturally value dk bits equivalence time pad say probability distributions equivalent identical 
encryption scheme realization time pad quadruple ki elements quadruple defined set key generations encryption decryption equivalence 
general probabilistic framework symmetric en seen possible reformulate computational view probability fields random variables parametrized security parameter built 
fact allows give formalism includes computational information theoretic view 
list mathematical objects formalism slight modifications seen computational information theoretic framework 
field actions general set strings 
case computational framework information theoretic case fixed subset plaintext strings represents messages allowed encrypted 
subset keys strings chosen possible encrypting keys 
order able build messages basic ingredients assume injective pairing function strings strings strings 
range pairing function called pairs pairs ran 
symmetric encryption scheme constituents key generation 
keys encryptions assumed randomly generated 
mathe matically key generation represented random variable keys discrete probability field prk 
put index remind probability field key generation consider probability fields 
protocol key generation allowed 
encryption 
encryption works follows keys plaintext ek random variable discrete probability field pre 
values random variable strings denoted ek assume ek sense pair denote dome subset keys plaintext ek defined 
rv strings stands set random variables values strings dome rv strings dome keys plaintext 
decryption 
encryption assume keys function dk subset domd keys strings satisfying dk ek equivalence 
just case computational equivalence assume equiv relation defined distributions finite cartesian products strings 
call notion indistinguishability denote matter carte sian product lead confusion 
str cartesian product 
say random variables values str indistinguishable distributions equivalent indistinguishable denoting equivalence random variables 
require followings random variables distribution indistinguishable 
ii constant random variables indistinguishable constants 
random variables values str followings hold iii invariance projections denotes projection str components str str str iv invariance coupling str 
str str indistinguishable random variables independent independent indistinguishable random variables str str arbitrary functions preserve indistinguishable random variables 
invariance pairing str strings strings 
vi invariance str strings think relation generalized notion computational information theoretic equivalence 
needs satisfy properties encryption decryption specify definition encryption schemes definition symmetric encryption scheme 
symmetric encryption scheme quadruple set key generations index set encryption decrypts ciphers encrypted gives equivalence relation defined 
require probability distribution distinguishable constant strings distributions distinguishable distribution distinguishable distribution independently generated ki kj require properties ran dom ran dom holds plaintext 
property express requirement defined defined 
words encrypted certain outcome key generation algorithm outcomes algorithm values security parameter 
equivalence relation satisfying properties previous paragraph needs random variables values strings key generation joint distribution indistinguishable joint distribution random variables 
ii eki equivalent dki equivalent random variables 
probability joint probability necessarily independent 
similarly encryption course independent 
chapter interpretations soundness chapter define transition formal probabilistic views called interpretation 
prove soundness theorems interpretations 
proves motivated soundness proof abadi rogaway hybrid argument computational interpretation formal expressions relate formal computational formalisms 
purpose consider computational encryption scheme key generation algorithm 
naturally want give computational realization method building messages encryption pairing 
order assume keys plaintext ciphers plaintext blocks plaintext plaintext plaintext plaintext keep encrypting keys ciphers 
formal logic exp suitable interpreted computational encryption schemes exp exp particular reason restriction key generation algorithm distinguish formal keys taken equivalent 
section assume 
talk equivalence formal ciphers come security assumptions 
assume definition interpretation computational encryption schemes 
computational symmetric encryption scheme index set prk denoting probability fields key generation pre denoting probability field randomness encryption 
valid expression exp exp probability space prm defined inductively prk keys prb blocks pr prm prn pr pre prm 
just trivial probability space elementary event tensor product stands product probability 
keys keys keys prk keys keys bijection enumerating keys keys 
function keys strings defined interpreting function computational encryption satisfies properties blocks valid expressions arbitrary keys keys 
keys 
keys 
keys 
keys 

distribution denote ensemble denote clearly equation necessarily defined depending dome simply assume dome cause problem possibility restrict set valid expressions elements interpretation defined 
intuitively random variable 
run key generation key keys 
outputs key generations translate formal expressions rules time see key output corresponding key generation 
blocks just block 
see pairing pair translations expressions inside formal pair 
see formal encryption run encryption algorithm key string output key generation encrypting translation formal expression inside formal encryption 
randomness comes initial key generation running encryption algorithm independently time encounter formal encryption 
conversion algorithm defined abadi rogaway results random variable conversion algorithm abadi rogaway 
computa tional encryption scheme 
interpretation expression encryption scheme defined follows algorithm interpretation keys convert return algorithm convert keys return blocks return convert convert return convert return distribution sampling interpretation identical distribution 
soundness type encryption scheme remind reader definition type security defined section definition type security 
say encryption scheme type secure polynomial time adversary function negligible function adv pr ek pr ek type secure cryptosystem adversary may distinguish ciphers encrypted different keys 
mentioned example distinguish formal undecryptable ciphers assigning different boxes 
set formal patterns look definition pattern 
define set patterns pat grammar patterns key keys block blocks pair encryption keys undecryptable keys process assigning pattern expression definition 
keys 
define function patt exp keys pat inductively follows patt keys patt blocks patt patt patt patt patt definition 
define pattern expression pattern pattern patt keys ready state lemma soundness theorem system proposition 
consider expression key keys 
suppose expressions ml exp ml subexpressions assume occur denoting expression get replacing mi contained mj true interpretation type encryption scheme proof 
assume loss generality mi 
subexpression mj assume true 
suppose means adversary distinguishes distributions pr pr non negligible function 
show contradicts type security 
construct adversary distinguish oracles ek ek 
adversary probabilistic algorithm oracle algorithm keys convert return algorithm convert keys return blocks return convert convert return convert return convert return note algorithm convert algorithm convert convert carries necessary encryptions convert oracles carry encryptions 
case oracle ek convert random sample oracle ek convert random sample pr ek pr ek pr pr assumption distinguished pr pr non negligible function adv non negligible function 
implies scheme type secure contradicts assumption 

theorem soundness type schemes 
expressions keys keys cyclic respectively 
type secure encryption scheme interpretation exp type systems 
implies 
proof 
definition exists key renaming bijection keys pattern pattern 
means boxes occurring pattern occur pattern vice versa 
keys keys keys hand subexpressions pattern pattern outside boxes agree 
keys keys keys 

lb denote keys keys keys 
keys keys keys cyclic hypothesis loss generality assume li numbered way li encrypts lj detailed argument see means keys keys deeper higher number 
expression obtained replacing subexpressions form 
mi expression obtained mi replacing subexpressions mi form li li easy see mb replacing subexpressions form li pattern 
li arrive note mi li occur encrypting key 
reason li subexpression encrypted non recoverable key li recoverable encrypted key keys subexpression recoverable ends box construct pattern 
element keys encrypts li lj subex form lj replaced lj constructed mj li appear mi place encrypting key 
lemma follows mi mi mb 
carrying process arrive 
supposed pattern pattern mb pattern pattern clearly true mb 
permuting keys effect distributions 
putting equa tions soundness result follows 
illustrate example theorem works example 
consider expressions follows left parentheses convenience significance proof course positions respective patterns see pattern pattern substitution keys 
keys keys 
keys 
keys keys 
soundness theorem mentioned possible assume loss generality keys keys renamed 
lb way li encrypts lj means keys keys deeper higher number 
rename way obtain renamed expressions continuing argument define mi result replacing expressions form li mi li clearly key renaming 
lemma follows 

interpretation expressions time pad kn realization otp discussed section 
case otp lengths messages keys vital importance 
notion reflected formal view defined section 
expand logic talk length expression 
definition formal length function otp 
assume length function keys 
keys symbols 
lengths expression defined 
added match length tag 
define length function expression exp induction valid expressions defined expressions length en subexpressions match length encrypting key key twice encrypt 
condition necessary prevent leaking information properties otp 
definition valid formal expressions otp 
exp otp exp implies key encrypts equivalence relation defined keys ki kj iff ki kj 
equivalence classes contain keys length correspond different key generation algorithms 
definition interpretation expression 
expression exp otp create interpretation way 
suppose keys ki ki kin 
take keys keys kij probability measure space taken product probabilities kij 
keys denote projection th component 
define kij keys keys kij kij keys subexpression inductively define random variable keys strings block blocks keys keys defined pairs subexpressions encryptions keys blocks kl 
denote distribution 
formulate interpretation help algorithm algorithm keys return algorithm keys return blocks return return return sampling distribution 
soundness time pad case type cryptosystems define equivalence formal expressions suitable otp 
mean differentiating boxes assigning different boxes ciphers different length 
ciphers defined ciphers equivalent iff length just example 
definition pattern 
define set patterns grammar patterns key keys block blocks pair encryption keys undecryptable process assigning pattern expression definition 
define function patt otp exp otp keys inductively follows patt otp keys patt otp blocks definition 
define pattern expression pattern otp pattern otp patt otp keys opt denote equivalence expressions expressions equivalent patterns length preserving key renaming 
prove soundness theorem lemma proposition 
consider valid expression exp otp key keys 
suppose expression subexpression assume occur denoting expression get replacing denotes string consisting true interpretation otp defined section 
proof 
basic properties otp ensure evenly distributed ciphers matter distribution agrees dis tribution 
assumed occur independent interpretation rest expression independent interpretation rest expression 
replacing effect distribution 
theorem 
valid expressions exp otp keys keys cyclic respectively 
otp implies probability distributions otp interpretation 
proof 
otp definition exists length preserving bijection keys pattern otp pattern otp 
means subexpressions pattern otp pattern otp outside boxes agree 
keys keys 
lb denote keys keys 
keys cyclic hypothesis assume li numbered way li encrypts lj expression obtained replacing subexpression form encrypting twice key permitted 
mi pattern obtained mi replacing subexpression mi form li li li easy see mb replacing subexpressions form li li li arrive pattern 
note mi li occur encrypting key 
reason li subexpression encrypted non recoverable key li recoverable visible encrypted key keys subexpression visible ends box construct pattern otp 
element keys encrypts li lj subexpressions form lj replaced lj lj constructed mj li appear mi place encrypting key 
previous proposition follows mi mi mb 
carrying process arrive 
supposed otp pattern otp pattern otp mb equals key renaming clearly true mb 
permuting keys keeping length effect distributions 
putting equations soundness result follows 
interpretation soundness general interpretation idea general interpretation type case time pad 
give specific interpretation just say function interpretation satisfies certain properties 
interpretation random variable 
assume function fixed advance assigns formal key key generation algorithm 
assume blocks 
rest determined way run key generation algorithm assigned key keys 
outputs key generations translate formal expressions rules time see key output corresponding key generation 
blocks just 
see pairing pair translations expressions inside formal pair 
see formal encryption run encryption algorithm key string output key generation encrypting translation formal expression inside formal encryption 
randomness comes initial key generation running encryption algorithm independently time encounter formal encryption 
definition interpretation general framework 
ki general symmetric encryption scheme index set ki denoting probability fields key generation pre denoting probability field randomness encryption 
exp set valid expressions 
valid expression probability space prm defined inductively prk keys prb blocks pr prm prn pr pre prm 
just trivial probability space elementary event tensor product stands product probability 
suppose function keys ki assigning key generations keys 
keys keys bijection enumerating keys keys 
keys 
keys pr pr keys function keys strings defined called interpreting function satisfies proper ties blocks valid expressions arbitrary keys keys 
keys 
keys 
keys 
keys 

clearly definition necessarily defined depending dome simply assume dome cause problem possibility restrict set valid expressions elements interpretation defined 
soundness key soundness theorem boxes definition formal equivalence elements 
clear extreme case equivalence ciphers defined ciphers equivalent iff soundness holds trivially interpretations completely impractical assume formal adversary see inside encryption 
immediate soundness holds interpretation formal ciphers implies keeping interpretation soundness holds new results boxes 
concrete situation aim introduce boxes achieve soundness sustain practicality 
way avoid having boxes require completeness see obtaining completeness requires boxes 
theorem claims equivalence conditions 
trivial condition implies condition ii 
claim ii implies summarized way soundness holds pairs valid expressions special relation described ii soundness holds expressions certain acyclicity 
words implies certain specified pairs implies pairs valid expressions definition see section 
theorem 
exp formal logic symmetric encryption 
assume proper 
ki general encryption scheme tation exp 
assume keys keys ki assume replacing undecryptable cipher valid expression equivalent undecryptable valid cipher results valid ex pression 
conditions equivalent soundness holds exp keys keys cyclic respectively implies 
ii ni li set valid ciphers finite set keys li element holds nij expv ni ni nil keys occur keys cyclic denote expression obtained replacing nij contained ni nij 
proof 
condition ii follows easily set nij provided proposition encrypting key nij contained recoverable key computing pattern nij replaced box nij box replaces nij pattern computed 
soundness assumed keys cyclic 
order prove follows ii consider equivalent valid expressions definition exists bijection keys preserving pattern pattern 
means boxes occurring pattern occur pattern vice versa 
subexpressions pattern pattern outside boxes agree 
keys keys keys 

lb li lj denote keys keys 
denote keys keys 
keys keys keys cyclic hypothesis loss generality assume li numbered way li encrypts lj encrypts detailed argument see means keys keys deeper higher number 
consider set expressions subexpressions form li set condition ii provides set elements form 
expression obtained replacing subexpressions form assumption 
mi expression obtained mi replacing subexpressions mi form li 
easy see mb replacing subexpressions form arrive pattern 
note mi li occur encrypting key 
reason li subexpression encrypted non recoverable key li recoverable encrypted key keys subexpression recoverable ends box construct pattern 
element keys encrypts li lj subex form lj replaced constructed mj 
properties listed proposition li may appear encrypting key li lj contradiction 
li appear mi place encrypting key 
observe keys mi keys 
assumption ii follows mi mi mb 
carrying process arrive 
supposed pattern pattern mb pattern pattern clearly true mb 
permuting keys effect distributions 
putting equa tions soundness result follows 
example type cryptosystems 
general theorem give proof soundness type cryptosystems earlier discussed section 
see condition ii theorem satisfied case 
equivalence relation case proper mentioned example 
equivalence relation trivial 
elements correspondence keys say keys 
set ni li cli li proposition condition ii satisfied 
condition ii take example time pad 
soundness theorem proved time pad section example general theorem 
reason condition ii need single length otp 
hand case otp encrypting key twice replace equivalent ciphers expression 
possible define formal equivalence interpretation time pad theorem ensures soundness 
trick define formal ciphers equivalent iff ciphers encrypting key 
equivalence keys stays 
case boxes indexed encrypting keys 
set ni li ni condition ii take cli li li proposition condition ii satisfied 
example type type cryptosystems 
discussion type systems recall example cited length function micciancio warinschi 
assumed encryption scheme views plaintext sequence basic message blocks ciphertext block longer corresponding plaintext 
practical encryption schemes cbc ctr satisfy property 
interpretation assumed block symbols key symbols mapped bit strings size equal basic message block 
length function defined keys blocks equivalence ciphers type case defined equivalence holds iff formal length ciphers 
gives proper equivalence 
proof analogous proposition shows condition ii general theorem satisfied 
clear order able define equivalence ciphers length length function needed track change length pairing encrypting 
easy previous example 
general necessarily true formal length function defined 
problem length function assigns specific length expression interpretation expression random variable may varying length 
example case time pad keys may generated uniformly length outcome key generation varies require encrypting key long plaintext length cipher vary 
type cryptosystems equivalence ciphers defined equivalence holds iff encrypting keys lengths agree 
proposition similar shows condition ii general theorem holds 
chapter completeness proving completeness interpretation formal expressions means proving interpretations expressions indistinguishable expressions equivalent 
clearly task completed having received sample interpretation method reveal information contained sample string re keys decrypting ciphers 
section method systematically revealing possible information sample interpretation expression 
parsing process technique chapter useful course proving completeness results 
idea summarized follows sample element built blocks randomly generated keys paired encrypted 
keys encryption built explicitly contained case keys decrypt ciphers encrypted revealed keys 
problem looking possible tell blocks keys ciphers pairs string bits assume general tag strings otp 
exploit fact repeatedly proofs know sampled fixed known expression looking find locations blocks keys ciphers pairs tell key decrypting certain cipher located 
couple pages machinery form expression extracts possible decryption distributes extracted elements special cartesian product copies strings 
section assume exp interpretation general symmetric encryption scheme ki 
chapter notion subexpression occurrence means subexpression position reason distinction subex pression occur times want distinguish occurrences 
avoid cumbersome notation denote subexpression occurrence just sion 
start defining notion level subexpression occurrences expression definition level subexpression occurrences 
expression call level subexpression occurrences subexpression occurrences encrypted 
sub denote set level subexpression occurrences write level subexpression occurrence receiving element thing extract encrypted means break pairs replace mathematical pairs 
process reveals unencrypted blocks keys ciphers computational statistical realizations level subexpression occurrences 
definition blowup function 
valid expression define blowup func tion strings inductively follows key block denotes function 
element element define inductively way definition associated tree 
tree associated pair expressions denoted define mm 
strings strings strings remind reader identify strings strings strings strings strings strings note expressions 
included definition higher order trees shall define second argument difference 
example 
expression sub strings strings strings strings strings blocks keys ciphers replaced strings pairs replaced 
element sampled looks sample sample sample sample sample 
apply blow function element receive element 
proposition 
expression 
proof 
immediate definitions 
clearer label copies strings formal expressions belong example strings strings strings sk shorthand strings 
previous example random sample function projects copy strings strings extracts blow 
similarly projecting copies strings extract samples form implement idea general situation define call get function expression subexpression occurrence encrypted extract sample computing precise definition goes induction usual definition get function 
subexpression occurrences define get function associated triple inductively induction id occurs really interested 
example 
previous example strings projects strings projects strings observe expressions sub unique sub 
motivates definition definition position subexpression occurrences 
expressions say sub sub position level denote unique bijection sub 

sub sub example 

denotes expression previous examples 
enumerating get subexpression occurrences 
expression cm denote set subexpression occurrences ciphers encrypted recoverable keys 
cm keys 
emphasize mean subexpression occurrences encryption encrypted recoverable key occurs twice listed twice cm assume elements set encrypted recoverable keys possible decrypt elements information containing possible enumerate elements set order decrypt keys decrypting possible keys revealing keys decrypting keys total number set denoted 
cn 
note enumeration unique 
note numbering mean decrypt ciphers order 
key text denote encrypted expression 
denote key encryption example 
example possible way enumerate 
expression associate decrypting function 
acts 
takes takes key strings key decrypts possible right form cipher key result broken mathematical pairs get way put component set strings text key goes component 
element created key text dg key key domd outputs 
rest left untouched 
introduce notation key domd definition decrypting function 
expressions define map inductively follows 
keys key text key introduce notation interested 
important define need 
chose just convenience 
example 
example choice dx domd target set naturally copy strings corresponding set form strings text 
call new set right extend definition higher order 
need definition level subexpression occurrences 
say subexpression occurrence level respect cm denote relation occurrence occurrence denote set level subexpression occurrences 
notice level subexpression occurrences revealed 
decrypted 
definition associated tree 
inductively define tree associated pair expressions denote ti ti ti 
ti strings ti strings ti ti ti ti strings ti text strings ti strings keys note open encryptions keys step open fact 
expressions ti ti ti ti 
similarly need define gi di 
projects copy strings ti corresponds second maps element ti ti decrypting string corresponding appropriate key 
definition get function 
subexpression occurrences occurs define map get function associated triple gi ti ti inductively define gi gi gi ti ti gi ti ti gi gi text ti key ti cj text cj gi gi 
definition position subexpression occurrences 
expressions ti ti say position level denote unique bijection 
gi gi 
gi gi ci ti gi key gi domd definition decrypting function 
expressions define map di ti ti inductively follows ti di gi di gi di gi keys di di di di gi key di gi key ci text key gi ci gi ci functions di decrypt ciphers encrypted recoverable keys 
decrypts ciphers encrypted recoverable keys input sampling 
example 
going example sample form outcomes key generation algorithms respectively undecryptable sample element undecryptable sample 
indicates key encrypts plaintext indicates key encrypts plaintext key 
lemma essentially claims interpretation conditions ii bellow hold valid expressions distribution sampled denote distribution indistinguishable distribution sampled 
function strings denote probability sampled 
lemma 
exp formal logic symmetric encryption interpretation exp ki 
suppose realization satisfies properties keys blocks exp pair equivalent respect keys blocks pairs ciphers distinguishable 
ii valid formal expressions 
cm cc enumeration ciphers encrypted recoverable keys decrypted order 
implies cn cc enumerated order decryption ci enumeration cn di di proof 
expressions 
assumed condition equivalence assumed invariant pairs encrypted positions hold 
blow function received repeated application inverse pairing function projecting coupling 
mentioned proposition sampled 

unique bijection satisfies sub sub 
text key consider key key reason key key apply function key function projecting coupling 
left hand side clearly right hand side key key key 
assumption key 
similarly 
left hand side equals need interpretation cipher right implying expression key 
foregoing key key left hand side equals key right hand side key 
assumption ii follows text choose key element cn occurrence choice 
gives distribution gives distribution 
argument similar shows unique bijection 
sub sub satisfying 
just proved key expression implying 

key functions applied projecting coupling decrypting 

reversing role argument get 

indicate proof goes example 
example 
suppose assume conditions ii lemma satisfied 
suppose valid expression 

pair expressions 
condition lemma ensures pair 
strings strings strings strings denotes projection component strings strings strings strings assumed preserved projecting follows 
pair pair 

way conclude unencrypted pairs position unencrypted pairs follows 
strings strings strings strings strings 
point know form took corresponding string cipher located component 
key string decrypts cipher located third component 
true key preserves follows 

key assumption lemma follows key denote 
similarly cipher expression key get consider 
left hand sides equivalent conclude means condition ii lemma 
define keys decrypt position 
remember example dx domd sampled form strings strings strings strings strings strings continue process show 
completeness section prove completeness results help lemma 
just case soundness start completeness type case time pad section section respectively 
section prove general completeness theorem 
completeness type encryption schemes remind reader type encryption scheme characteristic pr ek pr ek negligible function 
require key repetition concealed 
hand may concealed definition forbid 
proved soundness result logic expanded boxes indexed keys 
introducing boxes ensured formal ciphers equivalent encrypted key prove computational indistinguishability interpretation 
want show computational equivalence implies formal formal implies computational 
logic ciphers different encrypting keys inequivalent sure inequivalent interpretations 
completeness need property encryption scheme definition strictly key revealing scheme 
say encryption scheme strictly key revealing type secure exists polynomial time adversary function negligible function adv pr ek pr ek ek proposition 
suppose cryptosystem strictly key revealing 
expressions keys implies 
proof 
assume contrary 
assumed system key revealing adversary pr ek pr ek ek negligible 
adding subtracting terms arrive pr ek pr pr pr pr pr pr pr ek ek pr ek ek aek aek aek aek ek ek ek pr ek ek pr ek ek pr ek ek left hand side equation supposed non negligible right hand side non negligible 
right hand side second fourth fifth differences negligible type security third difference pr pr negligible proves lemma 
aek aek ek theorem characterizes necessary requirements type encryption scheme formal language introduced type case interpretation com plete 
condition ii theorem horvitz gligor proving completeness type case called weak confusion freeness 
observe cryptosystem strictly key revealing condition iii satisfied previous proposition 
theorem 
type encryption scheme interpretation exp keys equivalent means equivalence iff encrypting keys identical 
completeness holds keys blocks exp pair equivalent respect keys blocks pairs ciphers distinguishable ii iii expressions keys implies 
proof 
direction trivial 
order prove part consider expressions 
condition ii lemma applicable 
entry distribution corresponds interpretation key block undecryptable cipher corresponds box 
naturally blocks positions distributions indistinguishable condition 
patterns contain blocks positions 
indistinguishable entries containing strings sampled key generation places 
furthermore indistinguishability implies repetitions key generation outcome occur positions 
consequence properties key generation definition 
key symbols patterns change possible rename recoverable keys keys pattern keys pattern distributions indistinguishable condition implies pairs indistinguishable undecryptable ciphers occur exactly entries 
means condition iii undecryptable ciphers encrypted identical different keys position undecryptable ciphers encrypted identical different keys 
identical boxes pattern located exactly places identical boxes pattern renaming recoverable keys effect boxes indexed non recoverable keys 
possible rename keys appear box indexes keys keys box indexes patterns agree 
patterns agree key renaming 
order see clearly proof works introduce example example 
consider earlier chapter expression pattern pattern assume expression 
show lemma saw examples section sample form sampled outcomes key generation algorithms respectively undecryptable sample element undecryptable sample 
case sampled form expression shows counting left occurrence second occurrence second occurrence samples interpretations keys 
different occurrences elements vary sample elements assumed distribution separate key generations distinguished key generation twice definition get different occurrences stand subexpression keys call respectively 
different keys vary separately 
formula shows form comparing sample element sample element sample 
follows 
assumed conditions theorem holds implies subexpressions keys equal continued decryption process 
equation implies condition iii receive 
key renaming looks pattern shows pattern completeness time pad section show completeness time pad 
method proof quite similar proof method type case 
observe conditions iii theorem missing 
reason considered specific implementation time pad fact encryption scheme type specify scheme completely specific otp implementation satisfy corresponding conditions see course proof 
theorem 
kn time pad encryption scheme section interpretation exp otp otp 
completeness holds 
proof 
consider expressions 
order able apply lemma need show conditions ii lemma hold time pad 
reason samples interpretations expressions tagged tag ends case pairs 
keys blocks pairs ciphers clearly distinguishable condition holds 
see condition ii satisfied consider 
digit constant digit changes probability condition ii satisfied 
apply lemma 
lemma 
entry distribution corresponds interpretation key block undecryptable cipher corresponds box 
naturally blocks positions distributions identical patterns contain blocks positions 
entries identical keys outcomes key generation occur exactly places identical keys occur key symbols patterns change possible rename recoverable keys length preserving keys pattern keys pattern distributions identical ciphers length occur entries 
boxes length appear position patterns needed prove 
general case theorem 
exp formal logic symmetric encryption assume proper independent 
interpretation ki 
completeness holds conditions satisfied keys blocks exp pair equivalent respect keys blocks pairs ciphers distinguishable 
ii 
iii pairs valid ciphers mi li ni implies 
proof 
part trivial 
order prove part consider expressions 
condition ii lemma applicable 
entry distribution corresponds interpretation key block undecryptable cipher corresponds box 
naturally blocks positions distributions indistinguishable condition 
patterns contain blocks indistinguishable entries containing strings sampled key generation places 
furthermore indistinguishability implies repetitions key generation outcome occur positions 
consequence properties key generation definition 
key symbols patterns change possible rename recoverable keys preserving function keys pattern keys pattern distributions indistinguishable condition implies undecryptable ciphers occur exactly entries 
means pattern boxes appear position 
previous paragraph means apart boxes pattern 
replacing assume recoverable keys identical pattern outside boxes 
show key renaming carries boxes boxes changing recoverable keys 
say boxes altogether pattern pattern 
ml ll corresponding undecryptable ciphers turn boxes nl corresponding ciphers mi li mj lj ni nj holds indistinguishable 
means condition iii mi li mj lj ni nj key renaming ij implying ij ni mi li ij nj mj lj mi mj ij ni ij nj 
assumed proper proposition box index representative contain element keys keys different common element keys keys may encrypting key possible encrypting key elements 
define inductively 
assumed independent possible modify get leaves keys ni keys untouched keys keys hold 
suppose defined keys ni keys ni mi li order define find smallest na ni keys ni holds process stops consider aj independent possible alter aj aj aj na ma la keys ni aj keys ni keys na 
keys key keys ni changed aj may happens propositions na key ni key 
aj na ma la follows proposition ma la key la hold 
follows implies aj la ia ni mi li ia li ia na ma la ia la li la ia li la ia take value interesting element change 
define key renaming job ia 
way keys ni keys keys ni ni mi li process stops na ni holds satisfies required properties leaves recoverable keys untouched maps boxes pattern corresponding boxes pattern needed complete proof 

observe condition iii theorem trivially satisfied box ciphers equivalent completeness holds certain choice implies results fewer boxes completeness holds key completeness boxes 

say example type cryptosystems 
comparing proof type cryptosystems clear theorem type systems special case general theorem 
formal language type case proper independent mentioned section 
conditions ii general theorem appear conditions type completeness conditions iii theorems identical type case reason pattern pattern formally equivalent identical exactly identical 
conditions iii theorems really mean thing 
example time pad 
conditions general completeness theorem satisfied formal language otp mentioned section proper independent 
furthermore condition ii general theorem exactly conditions ii parsing theorem satisfied otp case saw course proving completeness otp 
condition iii satisfied pairs ciphers encrypted different keys otp keys twice equivalence implies corresponding lengths ciphers implying 
otp 
example type type cryptosystems 
case type cryptosystems assume length revealed distributions ek ek distinguished different length call condition strictly length revealing corresponding condition iii satisfied case 
cryptosystem conditions ii satisfied completeness holds formal logic interpretation boxes indexed length cipher 
type system completeness holds assume system satisfies conditions ii just reveal key length really reveal strictly key revealing strictly length revealing 
showed possible give general treatment expansions equivalence notion abadi rogaway logic interpretations computational information theoretic encryption schemes 
non trivial general soundness theorems es 
theorems derive soundness completeness assuming hold special subsets formal expressions 
key soundness boxes definition formal equivalence completeness holds boxes 
fact computational information theoretic views give detailed description cryptographic schemes formal results interesting skewness conditions soundness completeness 
conditions completeness involves pairs formal keys blocks ciphers reflecting equivalence formal expressions paired arbitrarily times derived equivalence simple pairs 
hand conditions soundness requires expressions constructed keys blocks ciphers arbitrarily large number pairing ultimate reason indistinguishability joint distributions tuples random variables follow indistinguishability joint distributions corresponding pairs tuples 
abadi rogaway logic due simplicity suitable start analyzing relationship formal probabilistic views cryptography simple description realistic protocols 
hope analysis serve motivation guideline treating complex formal cryptographic systems interpretations 
bibliography abadi gordon 
calculus cryptographic protocols spi calculus 
infor mation computation 
abadi 
formal eavesdropping computational interpretation 
proc 
fourth international symposium theoretical aspects computer software tacs lecture notes computer science university sendai japan 
springer 
abadi rogaway 
reconciling views cryptography computational soundness formal encryption 
journal cryptology 
backes jacobi pfitzmann 
deriving cryptographically sound implementations composition formally verified bisimulation 
formal methods europe volume lecture notes computer science pages 
springer verlag 
backes pfitzmann waidner 
composable cryptographic library nested operations 
proceedings th acm conference computer communications security pages washington usa october 
acm press 
long version iacr eprint archive report jan 
backes pfitzmann waidner 
universally composable cryptographic library 
manuscript available eprint iacr org 
bellare kilian rogaway 
security cipher block chaining 
desmedt editor advances cryptology crypto th annual international cryptology con ference volume lecture notes computer science pages santa barbara california usa august 
springer verlag 
blum micali 
proceedings fourteenth annual ieee symposium logic computer science 
proc 
rd annual symp 
foundations computer science pages 
burrows abadi needham 
logic authentication 
proceedings royal society series 
appeared src research report shortened form acm transactions computer systems february 
canetti 
universally composable security new paradigm cryptographic protocols 
nd annual symposium foundations computer science focs pages 
ieee press 
full available eprint iacr org 
canetti lindell ostrovsky sahai 
universally composable party multi party secure computation 
th acm symposium theory computing pages 
full available eprint iacr org 
cervesato lincoln mitchell scedrov 
meta notation protocol analysis 
th ieee computer security foundations workshop 
ieee computer society press 
demillo lynch merritt 
cryptographic protocols 
proc 
th annual acm symp 
theory computing 
acm press 
dolev yao 
security public key protocols 
proc 
nd annual ieee symposium foundations computer science focs pages 
dolev yao 
security public key protocols 
ieee transactions information theory march 
lincoln mitchell scedrov 
multiset rewriting complexity bounded security protocols 
journal computer security 
mitchell pavlovic 
compositional logic protocol correct ness 
th ieee computer security foundations workshop cape breton nova canada june 
thayer herzog guttman 
strand spaces proving security protocols correct 
journal computer security 
hirt maurer 
general adversaries unconditional multi party computa tion 
kwok yan lam okamoto xing editors advances cryptology asiacrypt volume lecture notes computer science pages 
springer verlag november 
goldreich micali 
play mental game 
proc 
th acm symp 
theory computing pages 
goldwasser micali 
probabilistic encryption 
journal computer system sciences 
previous version stoc 
goldwasser micali wigderson 
proofs yield validity languages np zero knowledge proof systems 
journal acm 
guttman thayer zuck 
faithfulness protocol analysis message authentication 
samarati editor proceedings th acm conference computer communications security pages philadelphia pennsylvania usa november 
acm press 
herzog 
computational soundness standard assumptions formal cryptography 
phd thesis massachusetts institute technology 
herzog liskov micali 
plaintext awareness key registration 
advances cryptology crypto volume lecture notes computer science pages 
springer verlag august 
horvitz gligor 
weak key authenticity computational completeness formal encryption 
boneh editor advances cryptology crypto rd annual international cryptology conference volume lecture notes computer science pages santa barbara california usa august 
springer verlag 
kemmerer 
analyzing encryption protocols formal verification techniques 
ieee journal selected areas may 
kemmerer meadows millen 
systems cryptographic protocol analysis 
journal cryptology 
laud corin 
sound computational interpretation formal encryption com posed keys 
lim lee editors information security cryptology th international conference volume lecture notes computer sci ence pages seoul korea november 
springer verlag 
lincoln mitchell mitchell scedrov 
probabilistic polynomial time frame protocol analysis 
reiter editor th acm computer communication security pages 
acm press 
lowe 
breaking fixing needham schroeder public key protocol csp fdr 
tiziana margaria bernhard steffen editors nd international workshop tools algorithms construction analysis systems volume lecture notes computer science pages 
springer verlag 
mitchell scedrov 
composition cryptographic protocols probabilistic polynomial time process calculus 
roberto amadio denis editors th international conference concurrency theory volume lecture notes computer science pages marseille france september 
springer verlag 
maurer 
information theoretic cryptography 
wiener editor advances crypto volume lecture notes computer science pages 
springer verlag 
maurer 
indistinguishability random systems 
lars knudsen editor advances cryptology eurocrypt volume lecture notes computer science pages 
springer verlag 
extended version available 
maurer 
impossibility results reduc tions applications random oracle methodology 
moni naor editor theory cryptography tcc volume lecture notes computer science pages 
springer verlag february 
maurer wolf 
information theoretic key agreement weak strong secrecy free 
bart preneel editor advances cryptology eurocrypt volume lecture notes computer science pages 
springer verlag 
meadows 
system specification analysis key management protocols 
proceedings ieee symposium research security privacy pages 
ieee computer society press 
meadows 
analyzing needham schroeder public key protocol comparison approaches 
proc 
european symposium research computer security pages 
springer verlag 
micciancio warinschi 
completeness theorems abadi rogaway logic encrypted expressions 
journal computer security 
preliminary version wits 
micciancio warinschi 
soundness formal encryption presence active adversaries 
naor editor theory cryptography theory cryptography conference tcc volume lecture notes computer science pages cambridge massachusetts usa february 
springer verlag 
millen clark freedman 
interrogator protocol security analysis 
ieee transactions software engineering se february 
mitchell ramanathan scedrov 
probabilistic polynomial time calculus analysis cryptographic protocols 
electronic notes theoretical computer science 
mitchell mitchell stern 
automated analysis cryptographic protocols mur 
proc 
ieee symposium security privacy pages 
needham schroeder 
encryption authentication large networks computers 
communications acm 
paulson 
mechanized proofs recursive authentication protocol 
th ieee computer security foundations workshop pages 
paulson 
proving properties security protocols induction 
th ieee computer security foundations workshop pages 
pfitzmann waidner 
cryptographic security reactive systems 
electronic notes theoretical computer science 
pfitzmann waidner 
composition integrity preservation secure reactive systems 
th acm conference computer communications security pages 
acm press 
roscoe 
modeling verifying key exchange protocols csp fdr 
csfw page 
ieee computer society press 
schneider 
security properties csp 
ieee symposium security privacy oakland california 
shannon 
mathematical theory communication 
bell system technical journal july october 
shannon 
communication theory secrecy systems 
bell system technical journal 
yao 
theory applications trapdoor functions 
rd ieee symposium foundations computer science focs pages 
ieee press 

