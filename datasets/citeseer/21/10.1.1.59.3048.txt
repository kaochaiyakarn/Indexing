annals mathematics computing teleinformatics vol pp complexity results agent design problems paul dunne michael laurence michael wooldridge agent design problem involves determining possible construct agent capable accomplishing task environment 
simplest examples tasks agent required bring goal achievement tasks agent required maintain invariant condition maintenance tasks 
previous considered complexity achievement maintenance agent design problems range environmental properties 
investigate computational complexity agent design problem settings 
investigate issue tasks specified boolean combinations achievement maintenance tasks 
second investigate extent agent information history environment operates affects complexity problem bounded agent design problem agent constrained bound permitted remember history system 
investigate complexity stochastic agent design problems ask agent probability success index terms multiagent systems computational complexity 
concerned computational complexity particular issue arises agent systems agent design problem 
problem informally understood follows representations environment task carried exist agent guaranteed carry task environment 
related markov decision problems problems ai planning agent design fact quite distinct akin game nature nature agent assumed computational entities comment relationships section vi 
department computer science university liverpool liverpool zf uk ped csc liv ac uk issn tei wooldridge dunne investigated computational complexity agent design problem range different settings range different types tasks 
important types tasks considered achievement tasks agent required bring goal state maintenance tasks agent required maintain invariant environment 
complexity problems shown vary nl complete tractable simplest case non recursive undecidable worst depending assumptions environment 
main issues investigated date relate environment deterministic non deterministic state environment uniquely determined multiple successors possible history dependent history independent environment allowed observe entire history environment order choose possible successors just final state history available unbounded bounded polynomially bounded run agent guaranteed terminate guaranteed terminate polynomially actions 
intuitively non deterministic environments harder deterministic environments history dependent environments harder history independent environments unbounded environments harder bounded environments turn harder polynomially bounded environments 
complexity results obtained previously bear intuitions fairly accurately 
worst agent design problem shown undecidable surprisingly extent environment annals mathematics computing teleinformatics vol pp bounded major factor determining undecidability 
reasonable assumptions nondeterministic polynomially bounded history dependent environment agent design problem achievement maintenance tasks shown pspace complete 
easiest case considered deterministic history dependent environments achievement maintenance design problems shown decidable polynomial time 
extend previous studies ways consider richer task specifications 
idea specify tasks arbitrary boolean combinations achievement maintenance tasks 
settings task specified formula propositional logic atomic propositions denote sets environment states positive literals interpreted achievement tasks bring states negative literals interpreted maintenance tasks avoid states 
example task agent bring states denoted avoid states denoted second consider restrictions power agents 
ask exist weak bounded agents accomplish task cf 

specific notion boundedness consider involves exist agents capable successfully accomplishing task memory bounds bounds length history permitted recall order decision 
extremal case consider agents permitted observe history required decision knowledge way system evolved 
third consider variants stochastic agent design problem 
previous considered agents guaranteed succeed task chance success 
stochastic agent design problem rational probability asked agent succeeds probability introducing formal model agents environments tasks results established 
summarize results examine computational complexity agent design problem boolean task specifications permitted 
consider bounded agent design problems section iv section turn attention stochastic agent design problems 
appendix provide summary problems studied results obtained 
assume familiarity theory computational complexity :10.1.1.32.420
ii 
agents environments tasks section formal model agents environments occupy model frame decision problems study 
systems interest consist agent situated particular environment agent interacts environment performing actions environment responds actions changes state 
assumed environment may finite set en instantaneous states 
agents assumed repertoire possible actions available transform state environment 
ac finite set actions 
behaviour environment defined state transformer function 
case simply function environment states actions sets environment states runs actions sets environment states 
allows behaviour environment dependent history system previous states environment previous actions agent play part determining environment behaves 
definition environment quadruple env ac finite set environment states distinguished initial state ac finite set available actions 
denote sequences form initial state ei ac 
subset sequences state 
state transformer function environment total mapping ac focus set runs environment 
set ac environment bounded unbounded 
denote ac set subsequently interpret total mapping ac describing possibly empty set states may result performing action ac run 
dunne laurence wooldridge complexity results agent design problems run terminated ac 
subset comprising terminated runs denoted tenv 
bounded environments run prefix set terminated runs 
length run total number actions states occurring denoted 
stated assumed environments bounded 
state transformer function encoded input instance deterministic turing machine description characteristics input form ac separator symbol 
program accepts 
number moves bounded polynomial 
set states constructed steps 
view agents performing actions environment causing state environment change 
general agent attempting control environment way order carry task 
agent best partial control environment 
definition agent ag environment env ac mapping ag ac symbol indicate agent finished operation agent invokes terminated runs tenv event referred agent having allowable actions 
system sys pair env ag comprising environment agent operating environment 
sequence ac called possible run agent ag environment env satisfies initial state ag ek ag ek noted general state transformer function domain ac nondeterministic agents deterministic 
agent may number different possible runs environment 
denote ag env set possible runs agent ag environment env ag env subset terminated belong tenv 
agent ag define allowable action ac run ag env tenv agents may choose halt arbitrarily 
concentrate behaviour agents bound placed number actions performed 
precisely set critical runs agent ag environment env set ag env defined runs agent exactly actions performed terminated actions 
stated bounding function ac 
iii 
boolean task specifications build agents order carry tasks 
task carried specified 
obvious question specify tasks 
concerned predicate task specifications 
specifications take form predicate runs condition runs satisfy fail satisfy 
denote predicate specification write indicate run satisfies 
intuitively means task specified successfully accomplished run concerned representation logical formula 
task environment pair env env environment predicate runs 
task environment specifies properties system agent inhabit environment env criteria agent judged failed succeeded specification 
final consideration may informally phrased limits wish place long agent may take succeed context consider basic decision problem formulations agent eventually succeeds task 
agent succeeds number actions 
define boolean task specification language formulate decision problems studied 
xn xn set boolean variables 
propositional formula xn xn inductively defined rules xn consists single literal xn 
xn xn xn propositional formulae 
xn denote total number occurrences literals boolean logic function variables represented 
say xn nontrivial equivalent boolean constant 
definition env ac environment state set actions ac 
annals mathematics computing teleinformatics vol pp en ordered collection pairwise disjoint subsets note partition xn non trivial formula 
run instantiation bn boolean values xn induced defined bi contains state ei contain state ei 
run succeeds respect 
task specification agent environment ac consists pair ordered collection pairwise disjoint subsets non trivial formula variables 
agent ag satisfies task specification ag env example consider environment state transformer function illustrated graph 
environment agent just available actions respectively environment states 
history dependence environment arises agent allowed execute action twice 
arcs states labelled actions cause state transitions note environment non deterministic 
suppose allow primitive proposition letters corresponds environment states corresponds corresponds 
consider task specifications achievement task goal states 
corresponds agent reliably achieve performing result 
results agent perform take take 
results simply perform 
essentially maintenance task bad states 
agent perform agent guarantee avoid 
agent guaranteed succeed task agent guaranteed succeed task 
task involves achieving 
agent guaranteed succeed task 
task involves achieving 
exists agent successfully achieve task 
task involves achieving achieving 
exists agent achieve exists agent succeed task 
consider decision classes agent design problem design tasks implicit specification design tasks explicit specification 
definition non trivial propositional formula variables 
decision problem finite design fd takes instance environment env ordered collection pairwise disjoint subsets fd env returns true ag ac ag env important note part instance specific defines design task agents env 
contrast decision problem 
definition decision problem finite agent design explicit task specification fed takes instance non trivial propositional formula xn environment env ordered collection pairwise disjoint subsets fed env returns true ag ac ag env 
employ shorthand order simplify subsequent notation 
fd fed det non det denote qx decision problem having property instance 
example denotes decision problem finite agent design explicit task specification deterministic 
computational complexity results wooldridge dunne considered special cases setting restriction placed number actions successful agent allowed considered problem design instances pairs env subset concerned question agent exists guaranteed reach respectively avoid states theorem summarises results proved special cases 
theorem design resp design denote cases unbounded environments may resp may occur instances design recursively enumerable recursive 
design recursively enumerable 
design recursive 
dunne laurence wooldridge complexity results agent design problems fig 

state transitions example environment arcs environment states labelled sets actions corresponding transitions 
note environment history dependent agents allowed perform action twice 
example agent reached state performing able perform order reach 
total recursive function deterministic turing machine program deciding design exceeds moves infinitely number bits encoding instance 
case finite design problems 
det non det fdx log fdx 
det pspace complete 
np complete 
history independent environment state dependent current state chosen action sequence states actions reached 
det nl complete 
complete 
principal concern section generalize theorem arbitrary variable propositional functions 
note generalisation theorem case definition design modified apply unbounded environments restriction number actions agent perform 
theorem design denote decision problem design instances unbounded environments allowed 
design recursive trivial 
design recursively enumerable monotone 
show decision problems fdx polynomial time equivalent decision problems fdx fdx irrespective specific non trivial concerned 
theorem det non det nontrivial formula fdx fdx fdx proof omit full technical details simply outline construction establishing fdx fdx fdx harder fdx non trivial 
instance env fdx form instance fdx adding new state accept action test 
set contains single state accept 
modify transition function instance fdx run test accept 
way instance fdx true returned constructed instance true returned 
corollary non trivial formula det pspace complete 
np complete 
proof immediate theorem theorem 
theorems extend results theorem regards environments state transition function history dependent 
remainder deal remaining cases involving history independent 
history independent environment transition function acts current state action determine state environment 
environments directed graph vertices labelled environment states edge labelled ac ei ej ej ei 
retaining assumption environments bounded follows acyclic directed graph 
case arbitrary non trivial formulae theorem history independent np complete proof show instance xn env having history independent transition function decided np 
np algorithm simply guesses action ac perform state 
graph strictly accurate define sequence nontrivial variable propositional formulae decision problem env sn np complete 
annals mathematics computing teleinformatics vol pp choices determine single path deterministic 
evaluating xn path easily done polynomially steps env 
show history independent np hard reduction paths forbidden pairs restricted directed acyclic graphs pfp dag 
instance pfp dag consists directed acyclic graph specified vertices collection bn pairs vertices instance accepted path contains vertex pair instance pfp dag construct time polynomial instance xn env history independent agent satisfying xn env path contains vertex pair set env ac ac maximum outdegree 
degree vi vi edge set vi 
additional action influences vertex single action entering final state initial state set state corresponding vertex 
graph defined identical addition edge going edge vertex labelled action 
formula constructed instance uses ai bi variables number pairs bn denote resulting variables may case bn bn 
bn bi final stage construction define set pairwise disjoint subsets form total number distinct vertices referred depends exactly variables 
si ai odd vertex ai occur pair cj si bi vertex bi occur pair cj sm 
construction ensures state vertex occurs si set 
claim agent satisfying specification xm environment just defined directed path containing vertex pair instance pfp dag 
suppose agent exists 
actions define directed path initial state final state 
path contain state corresponding st variable defining 
consider corresponding path 
path contain vertex state reached agent accessed state corresponding environment 
agent describes path 
path contains vertices pair ai bi xi xj propositional variables associated xm false instantiation induced agent due presence clause equivalent xi xj 
follows agent satisfying specification find path meeting forbidden pair requirements 
hand suppose contains path containing vertex pair path construct sequence actions state action corresponding going edge vertex path 
agent defined reaches state carrying action completes transition required final state consider det problem history independent environments 
technical definitions required 
definition set en ordered collection pairwise disjoint subsets boolean formula set xn xn 
define boolean formula follows 
express dnf conjunction elements xn xn 
define defined follows 
el literal xl occurring define false 
em literal xm occurring obtained deleting xm 
cases occurs simply define definition env environment state set env environment identical env initial state env 
motivation definitions easily proved result 
lemma env ac bounded environment state ac 
en ordered dunne laurence wooldridge complexity results agent design problems collection pairwise disjoint subsets boolean formula set xn xn 
agent ag solving problem det instance env satisfying ag agent solving problem det instance env state 
result allows establish 
theorem det problem environments proof history independent bounded environment env ac ordered collection en pairwise disjoint subsets algorithm defines predicate eval true false state boolean formula set xn xn eval true agent solving problem det instance env pair sink acyclic directed graph defined env define eval true path satisfies 
set initially set set sinks acyclic directed graph defined env 
choose state state edge ac lies boolean formula define eval true exists ac eval true state edge add go 
lemma algorithm computes function eval correctly 
loop steps executed times algorithm requires polynomial time 
iv 
bounded agent design far said agents implemented viewed simply mathematical structures 
ideally able say precise hard practice implement agent task environment 
just theory computational complexity really say hard implement programs specific problems general really address problem mathematical tools available 
fairly close 
study complexity agent design problem assuming precise bounds complexity agents designed 
ask bounded agent accomplish task notion bound precise meaning 
idea considering bounded agents arises literature autonomous agents known distinction called deliberative cognitive agents behavioural reactive agents 
deliberative agents typically assumed employ explicit symbolic representations environments generally decisions action perform manipulating representations typically means symbolic reasoning 
widely accepted approaches merits drawbacks deliberative logic approaches benefit clear theoretical underpinning associated engineering methodology computationally costly contrast reactive agents tend economical computational resources frequently robust suffer lack engineering methodology 
little research addressed relative merits approaches standpoint computational complexity russell subramanian important steps direction 
formally considering perfect recall agents prescribe action possible run consider reactive agents prescribe actions predicated constant length section current run reactive agent action determined solely final sequence state action pairs entirety 
primary virtue reactive agents programs implemented worst look table length number state action pairs 
serious proposal implement agents way see critique proposal see 
reactive agent design bound introduce requires agents decision action perform current state environment 
term literature autonomous agents refer agents reactive 
example better understand notion reactive agent recall environment state transformer function illustrated 
consider achievement task goal states 
clearly reactive agent accomplish task defined rules annals mathematics computing teleinformatics vol pp formally 
definition agent ag reactive pairs ag env holds ag ag 
reactive agent considers current state choosing action perform history leading 
important note environments tasks exists successful agent general sense successful reactive agent exists 
requirement environment history independent sufficient guarantee existence successful reactive agent task 
history independent environments tasks successful reactive agent successful non reactive agent example illustrates 
limiting attention reactive agents disadvantage potentially successful non reactive agents may overlooked significant gain program agents requires log ac bits single action associated state assuming history dependent denote decision problem qx solution agents required reactive 
recall complexity class comprises languages membership decidable np program having unit cost access np oracle 
alternatively defined ternary relation rl rl decided deterministic polynomial time rl satisfies rl theorem fd non det complete 
proof show fd non det suffices observe instance ac accepted exists reactive agent ag ac critical runs pass element reactive agent ag defined mapping ag ac 
ternary relation env ag ac ag env includes ag reactive agent defined mapping ag 
certainly case env ag decided env positive instance fd non det ag ac ag env env ag decidable program 
show problem hard give reduction complete problem 
instance boolean formula disjoint variable sets accepted holds instantiation instantiations render true 
completeness demonstrated 
instance xn yn construct instance env fd non det follows 
env ac set xn ac eval transition function xi xi xi eval eval instantiation defined xk eval xi yi suppose env positive instance fd non det reactive agent ag critical run reaches state 
consider mapping ag ac defining agent 
certainly case ag xi xi furthermore ag ag ag ag eval allowable actions states 
consider critical run agent ends state instantiation induced satisfies 
setting xi ag xi yields instantiation holds 
hand positive instance witnessed setting reactive agent defined xn ag eval achieves state witnesses positive instance fd non det dunne laurence wooldridge complexity results agent design problems theorem indicates deciding reactive agent exists usual complexity theoretic assumptions significantly easier complete nondeterministic cases deciding agent freedom determine actions entire history pspace complete 
contrast result shows deterministic environments difference complexity cases 
theorem fd det np complete 
proof membership np obvious instance env fd det simply non deterministically guess action state env define reactive agent 
env deterministic agent determines unique run suffices check contains state prove np hardness give reduction sat 
xn instance sat 
define instance env fd det env having state set xn initial state actions 
transition function xi xi xn requiring agents specify single re action state gain guaranteed short program appropriate agent exists potential cost missing alternative solutions reactive agent possible 
case agent reacting current state agents solving specified design problem need specify actions predicated action state pairs run having examine history 
reactive agents described programs size ac log ac bits realistic small values consider generalisation concept reactivity encompass reactive agents 
definition environment env positive integer agent ag reactive ag env el el el el holds ag ag 
denote agent design problem solution agents required reactive 
theorem non det det fd log fd proof show fd log fd instance consists environment env subset define new environment env follows 
basic idea state env corresponds sequence states env state env new environment env states 
initial state env usual initial state env 
env action addition actions env set legal runs defined follows 
suppose env run en env run en en 
observe env deterministic env easy see reactive agent env exists runs pass contain state reactive agent env exists runs xn easy see env positive instance fd det formula xn satisfiable proving theorem 
note easy corollaries theorems 
corollary fd non det complete 
fd det np complete 
proof proof derives constructions contain state 
show fd omit details 
reactive agent design log fd instance env create instance env state env corresponds distinct actions states env 
omit details straightforward simulation establishing reactive agent solves env reactive agent solves env obtain 
corollary fd non det complete 
fd det np complete 
proof immediate theorems 
oblivious agent design concept reactive agent offers mechanism concise solutions agent design tasks may described history dependent environments 
consider superficially similar idea oblivious agent solution 
informally oblivious agent takes account current state choosing action number actions performed far 
regard oblivious agent respect concept reactivity reactive 
example recall example earlier 
environment oblivious agent accomplish achievement task goal states simply performing 
formally 
annals mathematics computing teleinformatics vol pp definition agent ag oblivious pairs ag env ag ag 
settings agents cease operations maximum number actions say oblivious agent specified mapping ac describing action performed stage initial state onwards 
design problem fdx focused introduce oblivious variant follows 
definition instance oblivious achievement design problem fd consists environment env ac subset positive integer instance accepted mapping ac ag agent defined ag run ag env contains state oblivious agent specified ac bits ac may represent significant saving reactive agents 
earlier results turns deciding oblivious agents exist easier deciding reactive ones 
theorem fd non det complete 
fd det np complete 
proof reduction theorem construct instance fd 
non det suffices observe xi actions determined odd indexed moves applicable actions indexed moves eval 
oblivious agent specified instance env results accepted 
proof similar 
far considered agents realise specified task achievement maintenance limited number actions respect critical runs length ac 
course deterministic environments oblivious agents determining exists agent eventually realises achievement task easily shown undecidable 
situation changes consider agents operating history independent environments change environment state specified depends current state action chosen 
conclude section presenting results concerning oblivious agent design tasks history independent non deterministic environments 
environment form naturally modeled directed graph vertices correspond possible states edge ei ej labelled ac ej ei 
oblivious agents setting may regarded simply mappings ag ac 
course nondeterministic environments happen agent reaches different states ei ej actions performed ei ag ej ag convenient pre possibility adding special dead state environment pair ac directed graph contains edge labelled additionally edges labelled ac 
noted require assume acyclic 
general form oblivious agent design problem consider context history independent non deterministic environments defined 
definition xt non constant propositional logic function variables 
instance oblivious agent design problem oad consists edge labelled directed graph arising history independent non deterministic environment ac partial mapping xt associating state variable xi 
instance accepted value oblivious agent ag ac ag ac ag sm sequence states traversed ag instantiation xt defined xk state xk occurs xk state 
reasons limited space results merely stated proof 
theorem propositional functions xk problem oad decidable 
theorem oad pspace hard 
remarks regarding relationship theorem theorem may order appearing claim history independent version problem difficult history dependent counterpart 
important difference cases contrast oad instance fd non det include stated bound number actions oblivious agent allowed perform oad bound exists dunne laurence wooldridge complexity results agent design problems decided 
noted earlier exact oad history dependent environments fact undecidable relevance theorem 
history independent environments reactive agents write fc refer finite conjunction problem problem set states set bad states asked exists agent bring state avoiding bad states 
clearly fc special case det formula form definition environment env ac sets say agent ag solves conjunction problem tuple env run env ag passes passes subsection consider fc problem restriction agent reactive environment history independent 
sense captures idea agent environment power 
result follows 
lemma env ac bounded environment exists agent ag solving det instance env exists reactive agent solving problem instance 
proof suffices prove agent ag run env permitted ag sink directed graph defined env passes reactive agent satisfying condition 
define follows run permitted ag ends define action arbitrarily 
exist run permitted ag runs pass point run define ag 
lastly run permitted ag pass define ag 
run permitted passes states en succession easily proved induction run permitted ag passing en states ei lies exists run permitted ag en pass assertion follows run permitted passes show run permitted passes assume false 
env bounded run permitted passes states en succession state en sink directed graph defined env 
second assertion run permitted ag ends sink en pass contradicting hypotheses 
prove 
theorem state transformer function history independent respect reactive agents 
det respect reactive agents 
proof instance env problem acyclic directed graph defined env states incident edges deleted 
prove problem solvable nl space 
assume 
problem solvable instance env directed path initial state env directed path sink env 
problems decidable nl space general problem arbitrary lies class 
show problem nl space hard observe graph problem finite directed graphs nl space hard easily reduced instance problem 
lemma restriction agent reactive may ignored 
membership follows theorem 
proof hardness follows reduction monotone circuit reduction problem 
lemma generalise arbitrary formulae 
give example show requirement agent reactive real restriction det example env history independent environment state set initial state 
env action set transition function returns empty set cases 
consider problem det solvable instance env agent solving non reactive agent ag defined ag ag 
get partial result 
definition xn xn formula 
restricted det problem defined normal det problem subject additional constraint set states defined atomic proposition xi particular environment singleton 
annals mathematics computing teleinformatics vol pp lemma env ac history free bounded environment xn xn formula 
en ordered collection pairwise disjoint subsets satisfying ei 
exists agent ag solving det instance env exists reactive agent solving problem instance 
proof state call agent env reactive image run env history free bounded underlying graph acyclic agent ag reactive state ag reactive reactive state reachable underlying graph env 
construct agent ag solving det instance env reactive differs ag runs state repeating process eventually construct reactive agent 
runs permitted ag 
suppose passes singleton ei 
extended run ss permitted ag passes ei 
ag reactive state reachable underlying graph env run rs permitted ag passes twice singleton ei giving contradiction underlying graph env acyclic 
shown runs runs permitted ag pass ei 
define new agent ag follows 
ag ag run permitted ag chosen follows 
run runs ss permitted ag pass element passes element arbitrary 
case run permitted ag passing pass element case choice ag run passing pass element 
passes ei observation runs passing permitted ag pass ei maximal extension permitted ag pass ei maximal runs passing permitted ag pass ei similarly runs permitted ag shown pass en 
lastly run permitted ag pass permitted ag 
shown ag solves det instance env required 
theorem xn xn formula 
restricted det problem history free environments reactive agents lies proof follows immediately lemma theorem 
stochastic agent design far considering pessimistic notion success respect tasks agent guaranteed satisfy task runs deemed 
extreme optimistic notion success studied agent considered acceptable succeeded accomplish designated task run 
shown optimistic agent design problem easier pessimistic agent design versions agent design problem pspacecomplete considering pessimistic agent design merely np complete optimistic case 
strict pessimistic notion success discussed far strong optimistic agent design problem weak 
practice probably want know agent expected succeed rational number agent succeed greater refer problem stochastic agent design 
critical assumption order study problem immediate outcomes action equiprobable 
definition stochastic agent design problem sad takes instance environment env state sets en formula atomic propositions xn rational returns true agent succeeds task sense definition probability greater 
noted runs environment probability occurring agent having probability success greater equivalent agent succeeding proportion runs 
see give example 
consider environment single action leads states initial state available actions value leads binary computation tree height states leaves state unique agent environment runs majority succeed 
probability success state available actions chosen probability non zero probability run state succeed 
definition boolean formula set xm xm 
stochastic agent design problem sad takes instance tuple env dunne laurence wooldridge complexity results agent design problems env bounded environment em ordered collection pairwise disjoint subsets state set env rational number lying 
problem answer agent ag pair env ag satisfies respect set sequence probability greater refer sad achievement stochastic agent design problem refer sad stochastic agent design problem 
lemma sad lies pspace boolean formulae 
proof env instance sad ac 
show sad pspace boolean formula set xm xm consider function ext maps possible runs state env rational values range 
function ext value length exceeds actions ext set satisfies respect 
cases ext max ext function ext maximum probability agent continuing run attains goal states 
follows env positive instance sad ext suffices show value ext computed pspace 
order simplify algorithm presentation non deterministic machine guess maximising action input run certainly pattern guesses correctly compute ext 
algorithm recursive run boolean formula set xm xm proceeds follows 
return return set satisfies respect 
non choose available action 
count 
count count ext return count remains observe computation carried rational values involved representation integer values numerator denominator value denominator exceeds stored nlog bits 
depth recursion computation requires polynomial space entire procedure realised polynomial space 
pspace membership proof completed 
lemma problems pspace hard 
proof give proof problem give slight modification needed proof 
show problem stochastic satisfiability reduced 
instance construct probability 
instance formula form rx rx 
xn xi boolean variable need collection variables random quantifier intended interpretation randomly selected value odd 
goal determine strategy assigning values existentially quantified variables true probability great rx rx 
prob xn give outline reduction 
reduce instance proceed follows 
idea create environment forces agent environment take turns starting agent assign values truth falsity variables agent assigns values quantified variables environment assigns values quantified variables 
environment non deterministic actual assignment values done random 
variables assigned values environment returns goal state formula xn true valuation traced agent environment dummy fail state 
run corresponds possible valuation variables possible valuations runs 
recall goal problem determine strategy assigning values variables formula true majority runs clearly case just case agent succeed task formula true probability greater 
details follows 
quantified variable xi create actions corresponding assignment truth falsity xi annals mathematics computing teleinformatics vol pp respectively 
quantified variable xj create environment states corresponding assignment truth falsity xj 
create additional environment states initial state set goal states singleton containing state transformer function environment behaves follows 
agent environment alternate give valuations quantified variables agent going working outermost variable innermost 
agent allowed pick value performing environment responds agent respond 
variables values environment responds xn true valuation traced 
example run run variables assigned values true true false respectively environment indicates formula question true valuation 
ensure environment respond final valuation pad runs allowing additional dummy action agent 
case environment constructed identical bad state set defined 
lemma boolean formula set xm xm 
constant tautology unsatisfiable interpretation xj tj true false boolean formula xj tj equivalent xi xi 
proof follows induction lemma false interpretation xj tj true false formula xj tj true false equivalent true false equivalent non constant formula contain 
lemma follows inductive hypothesis applied 
theorem sad pspace complete boolean formulas 
proof membership pspace lemma 
show pspace hardness show boolean formula problem instance regarded instance sad 
lemma 
assume set xm xm atoms 
interpretation xj tj true false boolean formula xj tj equivalent xi xi 
assume case similar 
instance env si xi sad defines answer instance env sm sad provided set sj tj true sj state set env 
instance env sm constructed polynomial time env si pspace hard lemma shown sad pspace hard 
expect consider problem stochastic finite agent design problem deterministic environments 
deterministic environments stochastic agent design problem meaningful agent run deterministic environment sense ask agent succeeds probability exceeding probability success 
ask closely related question agents satisfy task deterministic environment 
deterministic environment particular achievement task majority agents satisfy task environment 
way looking problem say selected agent random chances better agent succeed task environment 
call problem majority agent design definition majority agent design problem takes instance achievement agent design task environment env goal states returns true majority agents achieve task 
immediately show theorem pp complete 
proof show problem pp 
pp algorithm decides problem see pp definition class pp computation non deterministically guesses run consistent state transformer function environment computation accepts task accomplished run rejects 
pp machine accepts majority computations accept 
different run corresponds different agent 
considering finite runs run guaranteed length polynomial ac machine decides problem 
show problem pp hard reduce problem 
instance simply propositional logic formula boolean dunne laurence wooldridge complexity results agent design problems variables xn 
goal answer formula true valuations variables 
create instance follows 
idea agent simply traces valuation variables different agent corresponds different valuation 
formally environment create states initial state states respectively indicate valuation traced formula true false respectively set goals states singleton containing agent completed assigning values variables environment responds assignments 
boolean variables assigned values environment responds formula true assignment traced run ends 
problem gives somewhat crude measure inherent hardness easiness task better evens chance agent selected random succeed task task easy solve 
vi 
related relationship ai planning ai literature closely related complexity planning problem bylander probably undertake systematic study complexity planning problem showed propositional strips planning problem pspace complete 
building variants planning problem studied examples include 
main differences ai planning follows notion agent function maps runs selected actions general notion plan commonly appears planning literature 
agents akin notion strategy game theory 
obvious advantage approach results bound particular plan representation 
obvious disadvantage having positive answer agent design problems imply agent carry task implementable cf 

complexity results planning literature bound particular representations goals actions 
strips notation bylander example baral action description language littman representation chosen st 
cases clear results reflect complexity decision problem part artifact representation 
adopted general representations possible example representing achievement maintenance tasks sets states particular logical formalism consider possible representations environment 
complexity results planning assume simple deterministic history independent environments 
focus planning literature exclusively achievement tasks 
considered maintenance tasks considered richer task specifications 
relationship game decision theory computational complexity literature relevant problems determining player winning strategy particular player game 
pspace completeness appears characteristic complexity result problems pp 
vii 
extended results ways 
considered specification task arbitrary boolean combinations achievement maintenance problems 
shown environments decision problem arbitrary non trivial formulae harder single variable formula specifications 
contrast setting problems history independent environments gives rise np complete decision problems 
second considered bounded agent design problems successful agent constrained memory bound 
showed nondeterministic history dependent environments agent design problem bounded agents easier standard complexity theoretic assumptions general counterpart 
deterministic environments complexity problems coincided 
considered stochastic variants agent design problems ask agent succeeds probability greater rational interval 
issues demand attention 
relationship solving markov decision problems 
key problem determining extent positive polynomial time results exploited annals mathematics computing teleinformatics vol pp practice 
extending task specification framework allow richer complex tasks 
research supported epsrc gr algorithmics agent design verification 
appendix convenience provide summary problems studied results obtained 
recall xn xn set boolean variables notation xn denote propositional logic formula variables xn 
note assume bounded environments explicitly stated 
frequently achievement maintenance task recall achievement task specified set goal states agent succeeds problem environment possible run agent environment states occurs need state run contrast maintenance task specified set bad states idea agent succeeds task possible run agent environment bad state occurs 
distinguish non deterministic deterministic environment 
non deterministic environment potentially possible successor states deterministic environment possible successor state 
particular problem notation det distinguish variants problem corresponding assumption deterministic non deterministic environments respectively 
distinguish environments history dependent history independent history dependent environment permitted decision possible states environment entire run far history independent environment decision final state environment action performed 
completeness summarising results obtained previous design achievement design problem unbounded environments 
recursively enumerable recursive 
theorem 
design maintenance design problem unbounded environments 
recursively enumerable 
theorem 
design achievement maintenance design problem finite environments observe propositional logic formula variable 
recursive non elementary general 
theorem 
fdx det non det achievement design problem deterministic non deterministic bounded environments 
pspace complete non deterministic environments np complete history dependent deterministic environments nl complete history independent non deterministic environments complete deterministic environments 
theorem 
fdx det non det maintenance design problem deterministic non deterministic bounded environments equivalent logspace reductions corresponding achievement design problem see preceding entry pspace complete history dependent non deterministic environments npcomplete history dependent deterministic environments nl complete history independent non deterministic environments complete history independent deterministic environments 
theorem 
results obtained design agent design problem unbounded environments task specified arbitrary propositional logic formula formula fixed form part problem instance 
recursive trivial logically equivalent boolean constant recursively enumerable boolean function corresponding monotone 
theorem 
fdx det non det agent design problem task specified arbitrary propositional logic formula formula dunne laurence wooldridge complexity results agent design problems fixed form part problem instance 
equivalent polynomial time reductions fdx history dependent environments pspace complete history dependent non deterministic environments np complete deterministic environments 
theorem 
history independent environments fdx environment nondeterministic non det theorem 
det non det agent design problem task specified arbitrary propositional logic formula forms part problem instance explicitly 
history dependent environments equivalent polynomial time reductions fdx pspace complete nondeterministic history dependent environments np complete non deterministic history dependent environments 
theorem 
history independent environments problem deterministic environments np complete apparently harder case task specification implicit 
theorem 
fd det non det agent design problem nondeterministic environments bounded agents tasks implicitly specified propositional formula problem determining agent exists accomplish task agent allowed remember final states environment 
achievement maintenance tasks non deterministic history dependent environments theorems np complete deterministic history dependent environments theorems 
oad oblivious agent design problem history independent non deterministic environments tasks specified propositional logic formula task implicit form part input 
recall agent oblivious bounded permitted information way system evolved 
problem decidable propositional formulae pspace complete form fc finite conjunction problem ask agent bring state avoiding bad state special case fd form 
history independent environments considering reactive agents problem complete non deterministic environments nl complete deterministic environments 
theorem 
sad stochastic agent design problem task specified propositional logic formula assumed implicit part instance rational number range 
asked exists agent succeeds task probability greater non deterministic environments problem pspace complete 
theorem 
special cases sad corresponding achievement maintenance denoted respectively 
problem determining majority agents accomplish achievement task deterministic environment 
problem pp complete 
theorem 
baral 
computational complexity planning approximate planning presence incompleteness 
proceedings sixteenth international joint conference artificial intelligence ijcai stockholm sweden 
brooks 
cambrian intelligence 
mit press cambridge ma 
bylander 
computational complexity propositional strips planning 
artificial intelligence 
dunne wooldridge laurence 
computational complexity boolean stochastic agent design problems 
proceedings international joint conference autonomous agents multiagent systems aamas pages bologna italy 
garey johnson 
computers intractability guide theory np completeness 
freeman new york 
genesereth nilsson 
logical foundations artificial intelligence 
morgan kaufmann publishers san mateo ca 
ginsberg 
universal planning universally bad idea 
ai magazine 
johnson 
catalog complexity classes 
van leeuwen editor handbook theoretical computer science volume algorithms complexity pages 
elsevier science publishers amsterdam netherlands 
kaelbling littman cassandra 
planning acting partially observable stochastic domains 
artificial intelligence 
annals mathematics computing teleinformatics vol pp littman goldsmith mundhenk 
computational complexity probabilistic planning 
journal ai research 
papadimitriou :10.1.1.32.420
computational complexity 
addison wesley reading ma 
russell subramanian 
provably bounded optimal agents 
journal ai research 
schoppers 
universal plans reactive robots unpredictable environments 
proceedings tenth international joint conference artificial intelligence ijcai pages milan italy 
wooldridge 
computational complexity agent design problems 
proceedings fourth international conference multi agent systems icmas pages boston ma 
wooldridge 
multiagent systems 
john wiley sons 
wooldridge dunne 
optimistic disjunctive agent design problems 
castelfranchi lesp rance editors intelligent agents vii proceedings seventh international workshop agent theories architectures languages atal lnai volume pages 
springer verlag berlin germany 
wooldridge dunne 
complexity agent design problems determinism history dependence 
technical report university liverpool dept computer science 
wooldridge dunne 
computational complexity agent verification 

ch 
meyer tambe editors intelligent agents viii proceedings eigth international workshop agent theories architectures languages atal lnai volume pages 
springer verlag berlin germany 
wooldridge jennings 
intelligent agents theory practice 
knowledge engineering review 

complete sets polynomial time hierarchy 
theoretical computer science 
