sequences games tool taming complexity security proofs victor shoup november brief tutorial technique structuring security proofs sequences games 
past years researchers cryptography organizing security proofs sequences games 
certain circumstances proved useful tool taming complexity security proofs messy complicated subtle nearly impossible verify 
meant serve brief tutorial technique 
outset noted technique certainly applicable security proofs 
technique applicable tool organizing proof actual ideas cryptographic construction security analysis come 
basic idea security primitives typically defined attack game played adversary benign entity call challenger 
adversary challenger processes communicate model game probability space 
typically definition security tied particular event security means efficient adversary probability event occurs close specified target typically probability event game adversary interacting different challenger 
formal definitions security parameter integer tending infinity previous paragraph efficient means time bounded polynomial security parameter close means difference smaller inverse polynomial security parameter sufficiently large values security parameter 
term art negligibly close quantity close zero just computer science dept nyu 
shoup cs nyu edu called negligible 
simplicity shall part avoid discussion security parameter shall assumed algorithms adversaries take value implicit input 
prove security sequence games approach follows 
constructs sequence games game game 
game game original attack game respect adversary cryptographic primitive 
event 
construction defines event si game usually way naturally related definition proof shows pr si negligibly close pr si 
pr sn equal negligibly close target probability fact constant follows pr negligibly close target probability security proved 
general framework proof 
constructing proofs desirable changes games small analyzing change simple possible 
experience transitions successive games restricted types transitions indistinguishability 
transition small change detected adversary imply efficient method distinguishing distributions indistinguishable statistically computationally 
example suppose assumed computationally indistinguishable distributions 
prove pr si pr si negligible argues exists distinguishing algorithm interpolates game game element drawn distribution input outputs probability pr si element drawn distribution input outputs pr si 
indistinguishability assumption implies pr si pr si negligible 
usually construction obvious provided changes transition minimal 
typically designs games easily rewritten single hybrid game takes input input drawn get game drawn get game 
distinguisher simply runs single hybrid game input outputs appropriate event occurs 
transitions failure events 
transition argues games proceed identically certain failure event occurs 
type argument cleanly possible best games defined underlying probability space differences games rules computing certain random variables 
done way saying games proceed identically occurs equivalent saying si si true fact completely trivial types proofs deserves name lemma difference lemma 
events defined probability distribution suppose pr pr pr 
proof 
simple calculation 
pr pr pr pr pr pr pr pr pr 
second equality follows assumption particular pr pr 
final inequality follows fact pr pr numbers pr 
prove pr si negligibly close pr si suffices prove pr negligible 
done security assumption occurs adversary collision hash function forged mac times done purely information theoretic argument 
usually event defined analyzed terms random variables adjacent games 
choice arbitrary typically games suitable terms allowing clear proof 
particularly challenging circumstances may difficult analyze event game 
fact analysis may require sequence games different direction sequence games may coincide sequence games pr gets pinned game 
technique crucial side stepping potential circularities 
bridging steps 
third type transition introduces bridging step typically way restating certain quantities computed completely equivalent way 
change purely conceptual pr si pr si 
reason doing prepare ground transition types 
principle bridging step may unnecessary proof harder follow 
mentioned transition failure event best successive games understood defined underlying probability space 
common practice simply games sequence defined underlying probability space 
sequences games author proofs organized sequences games extensively sho ss sho sho cs cs cs gs indispensable tool proofs papers structured differently hard imagine done clear convincing way sequences games 
authors technique afp bk bcp bcp bcp cpp df den kd pp swp 
mathematically speaking really new sequence games technique variations earlier papers nice example analysis kilian rogaway kr 
trend growing sequence games technique highly disciplined intensive fashion general pattern style notation philosophy exhibited papers cited previous paragraph sequences games quite lengthy games cs basic principles outlined apply game complicated sequence games long differences games small easily analyzed 
author sequence games technique extensively teaching courses cryptography 
classical results cryptography fruitfully analyzed technique 
generally speaking students enjoy approach easily learn apply 
consistent framework analysis instructor easily focus ideas unique specific application 
outline rest recalling fairly standard notation section sections illustrate sequence games technique analysis number classical cryptographic constructions 
compared technically involved examples literature technique mentioned applications really just toy examples 
serve illustrate technique concrete way believe proofs results easy follow proof 
examples extreme level detail examples give complete detailed descriptions game 
typically produce compact proof simply describe differences games describing game entirety 
examples mainly lectures courses cryptography taught author 
notation fairly standard notation follows 
describing probabilistic processes write denote action assigning variable value sampled distribution finite set simply write denote assignment element sampled uniform distribution probabilistic algorithm input denotes output distribution input write denote action running algorithm input assigning output variable shall write pr 
xn xn 
xn 
xn denote probability drawn certain distribution drawn certain distribution possibly depending particular choice way xn predicate 
xn true 
allow predicate involve execution probabilistic algorithms 
probability distribution sample space denotes subset elements occur non zero probability 
elgamal encryption basic definitions recall basic definition public key encryption scheme notion semantic security 
public key encryption scheme triple probabilistic algorithms keygen 
key generation algorithm keygen takes input implied security parameter system parameters outputs public key secret key pair pk sk 
encryption algorithm takes input public key pk message selected message space outputs ciphertext 
decryption algorithm takes input secret key sk ciphertext outputs message basic correctness requirement decryption undoes encryption 
pk sk keygen pk sk definition relaxed number ways example may insist computationally infeasible find message decryption undo encryption 
notion semantic security intuitively says adversary effectively distinguish encryption messages choosing definition comes gm called polynomial indistinguishability semantic security name syntactically different equivalent characterization 
formally defined game adversary challenger 
challenger computes pk sk keygen gives pk adversary 
adversary chooses messages gives challenger 
challenger computes pk mb gives target ciphertext adversary 
adversary outputs 
define ss advantage adversary pr 
semantic security means efficient adversary ss advantage negligible 
elgamal encryption scheme recall elgamal encryption 
group prime order generator view descriptions including value part set implied system parameters 
key generation algorithm computes pk sk follows zq pk sk message space algorithm encrypt message encryption algorithm computes ciphertext follows zq 
decryption algorithm takes input ciphertext computes follows clear decryption undoes encryption 
security analysis xy xy elgamal encryption semantically secure decisional diffie hellman ddh assumption 
assumption hard distinguish triples form xy triples form random elements zq 
ddh assumption precisely formulated follows 
algorithm takes input triples group elements outputs bit 
define pr zq xy pr zq 
ddh assumption assumption efficient algorithm dh advantage negligible 
give proof semantic security elgamal encryption ddh assumption sequence games 
game 
fix efficient adversary define game attack game definition semantic security 
things precise concrete may describe attack game algorithmically follows zq zq mb modeled adversary deterministic algorithm takes input random coins sampled uniformly set evident algorithm faithfully represents attack game 
define event adversary ss advantage pr 
game 
transition indistinguishability 
small change game 
computing compute randomly chosen zq 
describe resulting game algorithmically follows zq zq zq mb event game 
claim 
pr 
follows fact game effectively time pad adversary output independent hidden bit prove rigorously suffice show mutually independent follows independent 
observe construction mutually independent 
suffice show conditioned fixed values conditional distribution uniform distribution fixed determined independence conditional distribution uniform distribution sees conditional distribution mb uniform distribution claim 
pr pr ddh ddh ddh advantage efficient algorithm negligible ddh assumption 
proof essentially observation game triple form xy game form adversary notice difference ddh assumption 
precise distinguishing algorithm works follows algorithm mb output output algorithm effectively interpolates games 
input form xy computation proceeds just game pr zq xy pr 
input form computation proceeds just game pr zq pr 
follows ddh advantage equal pr pr 
completes proof claim 
combining claim claim see pr ddh negligible 
completes proof security elgamal encryption 
hashed elgamal number reasons convenient messages bit strings say length group elements 
may choose hashed version elgamal encryption scheme 
scheme family keyed hash functions hk hk function mapping key generation algorithm computes pk sk follows zq pk sk 
encrypt message encryption algorithm computes ciphertext follows zq hk 
decryption algorithm takes input ciphertext computes follows hk reader may easily verify decryption undoes encryption 
semantic security proven ddh assumption assumption family hash functions entropy smoothing loosely speaking means hard distinguish hk random element random element random element formally algorithm takes input element element outputs bit 
define es advantage pr hk pr 
say entropy smoothing efficient algorithm es advantage negligible 
fact possible construct entropy smoothing hash function families additional hypothesis leftover hash lemma may iz 
may somewhat practical ad hoc hash function families entropy smoothing property perfectly reasonable conjecture definition allows entropy smoothers pseudo random bit generation techniques 
sketch proof semantic security hashed elgamal encryption ddh assumption assumption entropy smoothing 
game 
original attack game state algorithmically follows zq zq hk mb define event game 
game 
transition indistinguishability 
transform game game computing random zq 
state game algorithmically follows zq zq zq hk mb event game 
claim pr pr ddh ddh ddh advantage efficient algorithm negligible ddh assumption 
proof identical proof corresponding claim plain elgamal 
algorithm interpolates game game ddh advantage equal pr pr algorithm hk mb output output game 
transition indistinguishability 
transform game game computing simply choosing random hash 
algorithmically game looks zq zq zq mb observe plays role game 
event game 
claim pr pr es es es advantage efficient algorithm negligible assuming entropy smoothing 
proved idea difference pr pr corresponding es advantage 
easy see algorithm interpolates game game es advantage equal pr pr algorithm zq zq mb output output acts time pad game evident combining obtain pr 
pr ddh es negligible ddh es negligible 
proof illustrates utilize intractability assumption proof security clean simple way 
pseudo random functions basic definitions positive integers polynomially bounded functions security parameter 
fs family keyed functions function fs maps denote set functions informally say pseudo random hard distinguish random function drawn random function drawn black box access function notion introduced 
formally consider adversary oracle access function suppose outputs bit 
define prf advantage pr fs pr af 
say pseudo random efficient adversary prf advantage negligible 
extending input length universal hash function construction allows stretch input length pseudorandom family functions 
positive integer 
hk family keyed hash functions hk maps assume uh universal family hash functions uh negligible 
means pr hk hk uh 
ways construct families hash functions 
define family functions function sends fs hk 
shall prove pseudo random pseudo random 
game 
game represents computation adversary oracle access function drawn random loss generality may assume adversary exactly queries oracle repeats queries regardless oracle responses 
may computation algorithmically follows 
wi 
yi xi hk wi yi fs xi 
yq output idea notation adversary modeled deterministic algorithm supply random coins input loop iteration adversary computes query wi function coins results 
yi previous queries 
wi 
assuming operates way values 
wq distinct 
event output game 
goal transform game game equivalent computation adversary oracle access random element probability game negligibly close pr 
game 
transition indistinguishability 
modify game truly random function bits bits place fs 
intuitively pseudo randomness property guarantee modification negligible effect behavior adversary 
algorithmically game looks 
wi 
yi xi hk wi yi xi 
yq output claim pr pr prf prf pdf advantage relative efficient adversary negligible assuming pseudo random 
adversary essentially interpolates games prf advantage respect exactly equal pr pr oracle machine 
wi 
yi xi hk wi yi xi 
yq output game 
transition bridging step 
purely conceptual change game 
intuitively think black box containing random function box little gnome inside gnome keeps table previous input output pairs query matches previous inputs corresponding output returned output value chosen random new input output pair added table see 
get equivalent formulation game 
yq 
wi 
yi xi hk wi xi xj yi yj yi yi 
yq output event game 
change going game game purely conceptual clearly pr pr 
gnome implementation random function game 
transition failure event 
modify game gnome forgetful perform consistency checks calculating yi values 
yq 
wi 
yi xi hk wi yi yi 
yq output define event game 
define event game xi xj observe 
xq play role game define event particular random variables 
yq mutually independent 
view games operating underlying probability space values 
yq identical games 
hard see games proceed identically event occurs 
particular occur output games identical 
fairly obvious example technique formal argument examples 
select fixed values 
yq occur 
prove induction 
values 
wi xi yi computed identically games 
case trivially true 
assume claim prove claim holds value wi computed way 
yi games xi computed way hk wi games 
comes computing yi see hold values 
xi distinct computed way games games yi assigned value yi 
completes induction proof 
follows occur games compute 
yq way compute 
yq way 
previous paragraph argued occur games output value 
saying difference lemma pr pr pr 
show pr uh 
analysis done respect game 
prove inequality suffices prove conditioned fixed values 
yq 
conditional probability distribution values 
wq fixed determined 
yq uniformly distributed independence 
fixed pair indices universal hash property assumption wi wj pr hk wi hk wj uh 
pairs indices inequality follows union bound 
note carried analysis respect game conceptually easier carry game 
general applying difference lemma choose analyze probability failure event adjacent games usually easier 
values 
xq play role game hard see fact game equivalent computation adversary oracle access function drawn random successive assumption distinct query yields random result 
pr pr equal prf advantage adversary 
follows prf advantage adversary bounded prf uh negligible 
pseudo random permutations positive integer 
ps family keyed functions ps permutation denote set permutations informally say pseudo random hard distinguish random permutation drawn random permutation drawn black box access permutation 
formally consider adversary oracle access function suppose outputs single bit 
define prp advantage pr ps pr 
say pseudo random efficient oracle machine prp advantage negligible 
random functions vs random permutations things want proof pseudo random permutation family pseudo random function family 
consider slightly simpler problem distinguishing random functions random permutations 
suppose black box contains random function bits random permutation bits task determine case 
queries birthday paradox expect see outputs equal box contains function permutation 
allow determine reasonably high probability contents box 
want rigorously prove really better way determine inside box 
adversary oracle access function 
define rf rp advantage pr pr 
shall show oracle machine queries oracle rf rp advantage usual argument considering sequence games 
game 
game represents computation adversary oracle access random permutation 
assume precisely queries queries distinct 
may write game algorithmically follows 
xi 
yi yi xi 
yq output assuming queries 
xq distinct 
define event game 
game 
transition bridging step 
transform game new game involving 
strategy build game uses faithful gnome appropriate consistency checks 
game forgetful gnome consistency checks identical 
idea model oracle access random permutation little gnome keeps track input output pairs gnome sure outputs inputs consistent 
yq 
xi 
yi yi 
yi yi 
yq output 
yi yi yi recall assuming inputs 
xq distinct gnome watch duplicate inputs 
gnome uses random value yi default value xi value previous output case gnome chooses value xi random unused output values 
event game 
evident game equivalent game point view adversary pr pr 
game 
transition failure event 
promised gnome forgetful simply dropping output consistency checks 
yq 
xi 
yi yi yi 
yq output event game 
event yi yj view games operating underlying probability space values 
yq identical games 
evident games proceed identically event occurs difference lemma pr pr pr 
furthermore union events occurs probability union bound pr 
note game fully equivalent computation adversary oracle access random function 
rf rp advantage equal pr pr pseudo random functions vs pseudo random permutations show suitably large negligible pseudo random permutation family ps pseudo random function family 
follows quite easily definitions fact proved bounding rf rp advantage adversary 
fix efficient adversary show prf advantage respect negligible 
assume oracle machine queries adversary efficient means bounded polynomial security parameter 
prf pr ps pr prf advantage want show prf negligible 
prp pr ps pr prp advantage assumption prp negligible 
rf rp pr pr rf rp advantage analysis know rf rp negligible assuming negligible 
easy see triangle inequality negligible 
prf pr ps pr ell pr ps pr pr pr prp rf rp luby rackoff construction give analysis luby rackoff construction building pseudo random permutation family pseudo random function family lr 
really harder analyze variation naor reingold nr uses pairwise independent family hash functions slightly weaker stages construction 
fs pseudo random family functions fs maps bit strings bit strings 
hk xor universal family hash functions bits meaning hk maps bit strings bit strings pr hk hk 
assume negligible 
luby rackoff construction builds pseudo random permutation family acts bit strings follows 
luby rackoff key consists triple interpret inputs outputs pairs bit strings 
input luby rackoff algorithm runs follows hk fs fs output easy verify function computed algorithm permutation easy invert permutation key 
want show construction pseudo random permutation family assumptions assumption negligible 
result suffice show construction pseudo random function family 
game 
game represents computation adversary oracle access luby rackoff construction random keys 
assume adversary exactly oracle queries distinct 
game algorithmically follows 
ui vi 
xi yi wi ui hk vi xi vi fs wi yi wi fs xi 
xq yq output assuming may ui uj vi vj 
event game 
game 
transition indistinguishability plus bridging step 
modify game replacing fs truly random function 
save steps implement random function directly faithful gnome 
xq 
ui vi 
xi yi wi ui hk vi wi wj xi xi vi yi wi fs xi 
xq yq output intuition represents output random function input wi 
default value xi default value overridden wi equal previous input wj 
event game 
familiar argument pr pr prf prf prf advantage efficient adversary negligible 
evident adversary job oracle machine 
ui vi 
xi yi wi ui hk vi xi vi wi yi wi fs xi 
xq yq output game 
transition indistinguishability plus bridging step 
naturally replace fs truly random function 
implement random function directly faithful gnome 
xq 
yq 
ui vi 
xi yi wi ui hk vi wi wj xi xi vi xi xj yi yi wi 
xq yq output event game 
pr pr prf prf prf advantage efficient adversary negligible 
evident adversary job oracle machine 
xq 
ui vi 
xi yi wi ui hk vi wi wj xi xi vi yi wi xi 
xq yq output critical proof jump directly game game 
adversary prf advantage equal pr pr oracle machine output output leave reader verify 
special case generally called hybrid argument allows replace number non constant number pseudo random objects random objects single step 
exactly hybrid arguments applicable depends circumstances requirement objects basic type 
see gol hybrid arguments 
game 
transition failure event 
forgetful eliminate input consistency checks 
get 
xq 
yq 
ui vi 
xi yi wi ui hk vi xi vi xi yi wi yi 
xq yq output event game 
claim 
game random variables 
xq yq mutually independent 
observe independent construction 
condition fixed values query fixed easily seen uniformly independently distributed conditional probability distribution uniformly independently distributed 
continues argument conditioning fixed values observing fixed uniformly independently distributed 
claim clear 
event wi wj game 
event xi xj game 

games proceed identically long occur difference lemma union bound pr pr pr pr pr 
fact 
xq mutually independent see claim obvious analyze event 
claim pr 
pr 
prove suffices prove conditioned fixed values 
xq yq 
values fixed 
uq vq 
independence see claim variable uniformly distributed consider fixed pair indices suppose vi vj 
assumption ui uj easy see wi wj suppose vi vj 
xor universal property pr hk vi hk vj ui uj 
shown pairs pr wi wj 
inequality follows union bound 
consequence claim observe game represents computation adversary oracle access random function 
adversary equal pr pr 
conclude prf advantage adversary negligible 
prf prf concludes proof proof strategy tempted take smaller steps making gnome forgetful step making second gnome forgetful second step 
convenient 
gnome forgetful resulting game nice allow easily establish bound failure probability better forgetful getting nice game easy analyze failure probabilities general finding strategy modify games order modify bit black art chosen ciphertext secure symmetric encryption close elaborate example 
basic definitions symmetric key encryption scheme triple probabilistic algorithms keygen 
key generation algorithm keygen takes input implied security parameter system parameters outputs key encryption algorithm takes input key message selected message space outputs ciphertext 
decryption algorithm takes input key ciphertext outputs message encryption scheme basic correctness requirement decryption undoes encryption 
keygen notion chosen ciphertext security defined game adversary challenger challenger computes keygen 
adversary sequence queries challenger 
query types encryption query adversary submits messages challenger 
challenger sends back mb adversary 
decryption query adversary submits challenger subject restriction equal ciphertext output previous encryption query 
challenger sends back adversary 
adversary outputs 
define cca advantage adversary pr 
chosen ciphertext security means efficient adversary cca advantage negligible 
simple construction easily build chosen ciphertext secure symmetric encryption scheme components 
component pseudo random family functions fs fs maps bit strings bit strings 
assumed negligible 
message space encryption scheme second component message authentication code shall define unpredictable function family hk hk function mapping bit strings bit strings 
property assuming defined terms game adversary challenger challenger selects adversary sequence queries challenger 
query string challenger gives adversary hk 
adversary outputs pair 
adversary wins game hk equal value submitted challenger game 
adversary uf advantage defined probability adversary wins game 
assumption unpredictable function family assumption efficient adversary negligible 
encryption scheme works follows 
key scheme pair chosen random 
encrypt message encryption algorithm computes ciphertext follows fs hk 
decrypt ciphertext may assume form decryption algorithm computes follows hk fs reject may assume reject default message encoded bit string may assume allow decryption algorithm return special value message space purposes matter 
reader may easily verify decryption undoes encryption 
security analysis give security proof sequence games 
unwieldy give explicit algorithmic description games clear done principle 
game 
original attack game respect efficient adversary game challenger computes 
assume exactly encryption queries 
ith query mi mi corresponding ciphertext xi ci ti computed challenger encrypting mib key assume adversary exactly decryption queries 
jth query challenger decrypts key 

define qj number encryption queries prior jth decryption query 
assume queries syntactically formed submits decryption qj 
game adversary outputs 
event game 
game 
game modify way challenger responds decryption queries 
challenger respond reject submitted ciphertexts performing steps decryption algorithm 
event game 
event game 
hk clear games proceed identically occurs usual games understood defined underlying probability space difference lemma remains bound pr 
claim pr pr pr 
pr uf uf uf advantage efficient adversary assumption negligible 
prove observations 
consider jth decryption query 
cases xi ci 
qj 
case ti ti hk xi ci hk 
xi ci 
qj 
case hk adversary effectively predicted value hk new point build adversary corresponding uf advantage 
discussion easily construct efficient adversary uf advantage pr proves 
describe oracle machine oracle machine 
run adversary ith encryption query mi mi xi ci fs xi mib ti xi ci give xi ci ti jth decryption query give reject output halt analyze oracle access hk randomly chosen 
denote decryption queries processed run halting th query 
value 
completely determined coins values independent event hk 
construction pr pr 
occurs define hk know queries oracle hk processing encryption queries prior processing decryption query 
pr independence probability equal pr game 
game replace fs truly random function save step implement faithful gnome challenger computations ith encryption query mi mi obtain ciphertext xi ci ti xi pi xi xj pi pj pi pi ci pi mib ti hk xi ci event game 
familiar argument pr pr prf prf prf advantage efficient adversary assumption negligible 
adversary job oracle machine run adversary ith encryption query mi mi xi ci xi mib ti hk xi ci give xi ci ti jth decryption query give reject outputs output output halt game 
usual gnome forgetful modify way challenger responds encryption queries check collisions xi values xi pi pi pi ci pi mib ti hk xi ci event game 
event game xi xj clear games proceed identically occurs difference lemma pr pr pr 
xi values independent clear pr negligible 
game pi essentially time pad clear independent pr 
combining see cca advantage negligible 
acknowledgments pr uf prf alex dent comments preliminary draft 
afp abdalla 
pointcheval 
password authenticated key exchange party setting 
available eprint iacr 
org 
appear pkc 
bcp pointcheval 
dynamic group diffie hellman key exchange standard assumptions 
advances cryptology eurocrypt pages 
full version www 
di ens fr 
bcp pointcheval 
group diffie hellman key exchange secure dictionary attack 
advances cryptology asiacrypt pages 
full version www di ens fr 
bcp pointcheval 
security proofs efficient password key exchange 
proc 
th acm conference computer communications security pages 
full version www di ens fr 
bk boneh katz 
improved efficiency cca secure cryptosystems built identity encryption 
available eprint iacr org 
appear ct rsa 
cpp pointcheval 
isomorphisms password authenticated key exchange 
advances cryptology crypto pages 
full version www di ens fr 
cs cramer shoup 
universal hash proofs paradigm adaptive chosen ciphertext secure public key encryption 
advances cryptology eurocrypt pages 
full version eprint iacr org 
cs camenisch shoup 
practical verifiable encryption decryption discrete logarithms 
advances cryptology crypto pages 
full version eprint iacr org 
cs cramer shoup 
design analysis practical public key encryption schemes secure adaptive chosen ciphertext attack 
siam journal computing 
preliminary version eprint iacr org 
den dent 
designer guide 
proc 
th ima conf 
coding cryptography lncs 
full version eprint iacr org 
df dodis 
public key trace revoke scheme secure adaptive chosen ciphertext attack 
proc 
international workshop practice theory public key cryptography pkc 
full version eprint iacr org 
dodis freedman jarecki 
versatile padding schemes joint signature encryption 
proc 
th acm conference computer communications security 
full eprint iacr org 
dodis yung 
scalable public key tracing revoking 
proc 
nd acm symposium principles distributed computing 
full version eprint iacr org 
fujisaki okamoto pointcheval stern 
rsa secure rsa assumption 
journal cryptology 
mart abd 
fujisaki okamoto ind cca hybrid encryption 
available eprint 
iacr org appear int 
inf 

goldreich goldwasser micali 
construct random functions 
journal acm 
gm goldwasser micali 
probabilistic encryption 
journal computer system sciences 
gol goldreich 
foundations cryptography basic tools 
cambridge university press 
gs gennaro shoup 
note encryption scheme desmedt 
available eprint iacr org 
iz impagliazzo 
recycle random bits 
th annual symposium foundations computer science pages 
kd desmedt 
new paradigm hybrid encryption scheme 
advances cryptology crypto pages 
full version cis ibaraki ac jp 
kr kilian rogaway 
protect des exhaustive key search 
advances cryptology crypto pages 
lr luby rackoff 
construct pseudorandom pseudorandom functions 
siam journal computing 
nr naor reingold 
construction pseudo random permutations luby rackoff revisited 
journal cryptology 
pp phan pointcheval 
chosen ciphertext security redundancy 
advances cryptology asiacrypt pages 
full version www di ens fr 
sho shoup 
hash functions hedge chosen ciphertext attack 
advances cryptology eurocrypt pages 
sho shoup 
proposal iso standard public key encryption 
available eprint iacr org 
sho shoup 
reconsidered 
journal cryptology 
extended crypto 
available online eprint iacr 
org 
ss shoup 
ace advanced cryptographic engine 
available eprint iacr org 
swp wang 
efficient extension standard schnorr rsa signatures universal designated verifier signatures 
proc 
international workshop practice theory public key cryptography pkc pages 
full version eprint iacr 
org 

