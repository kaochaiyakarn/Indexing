supplying high availability standard network file system keith marzullo frank schmuck department computer science cornell university ithaca describes design network file service tolerant fail failures run top standard network file service 
fault tolerance completely transparent resulting file system supports set heterogeneous workstations applications chosen standard 
demonstrate design provide benefit highly available files reasonable cost user implemented prototype sun nfs protocol 
approach limited nfs 
methodology apply network file service built client server model 
approaches building fault tolerant distributed programs 
choose available programming abstraction reasonably fits problem hand transactions replicated procedure calls reliable objects implement program abstraction 
second follow methodology designing fault tolerant partial support provided national science foundation ccr defense advanced research projects agency dod arpa contract 
views opinions findings contained report authors construed official department defense position policy decision 
program implement program available programming abstractions 
project example second approach 
designed implemented network file service tolerant fail failures run top nfs standard network file service 
fault tolerance completely transparent resulting file system support set heterogeneous workstations applications nfs supports 
fault tolerance come performance cost cost limited files need highly available 
nfs chosen primarily available department simple stateless protocol task easier 
approach explained limited nfs 
model network file service built client server model 
purpose fold 
wish show flexibility design methodology chose state machine approach 
second wish demonstrate isis broadcast protocols toolkit routines building fault tolerant program 
turns resulting program interesting file system right 
rest proceeds follows 
section general fault tolerant design methodology reviewed 
methodology applied nfs system section giving network file service resilient failure servers clients access files agent 
methodology applied section order file service resilient agent failure 
section look performance cost incurred prototype implementation system 
summarize results discuss plans system section 
design methodology design follows state machine approach building fault tolerant distributed systems 
section briefly outline part design methodology relevant 
fault tolerant network service developed steps 
design server state machine responds set messages 
point correctness server need considered messages assumed arrive correctly fifo order clients server 

replicate server set identical state machines 
clients communicate servers atomic broadcast protocol 
clients receive results set servers filtering responses 
filter depends failure model 
example fail model client need wait response byzantine model client needs receive majority identical responses 

knowledge semantics server reduce complexity broadcast protocol 
example operations state machine commutative atomic broadcast replaced broadcast preserve order 
case example server vote counter responded vote indication majority reached 
order individual votes reach different counters unimportant 
discussed applied methodology twice 
systems clearly resemble state machine model example 
fact cleanly described model 
replicating servers order build highly available file service top simple network file service replicate server 
treat network file server state machine referred step section 
sun nfs protocol nfs protocol provides rpc access unix file system 
main points importance protocol ffl stateless protocol 
client open session server file server 
example way open file append mode 
client provide absolute offset file read write operation 
ffl nfs protocol idempotent operations incremental effect 
nfs client order recover crashed server simply continue trying failed rpc server reappears 
ffl client accesses file handle called fhandle obtained server result lookup operation 
different implementations nfs interpret semantics differently treat true object names file may issue different fhandle different clients 
implementation assume fhandle serve true object name 
consistent current implementation nfs supplied sun 
ffl updates synchronous respect failure 
write rpc completes client assured data written 
property met nfs implementations current implementation supplied sun property 
agents achieve fault tolerance replicating server atomic broadcast protocol communication 
leave client unchanged possible 
client directly communicate servers need version rpc built atomic broadcast transport 
additionally nfs server strictly deterministic 
example new file created different servers issue different 
achieve replication servers transparently directing client requests intermediary called agent turn broadcasts servers 
client agent appears file server exceptionally reliable secondary storage 
reality agent uses set servers store replicas file 
agent uses virtual called identify file directory manages 
associated set replica file 
agent maintains replicated file list mapping vice versa 
lookup operation client presents file name asks handle file 
agent forwards request servers finds resulting fhandle replicated file list returns associated 
chose read write file replication scheme optimized read operations assuming failures 
agent performs write forwarding request server replaced appropriate fhandle 
agent replies client writes completed 
ensures nfs write semantics preserved 
complications due non deterministic behavior nfs servers 
example various time stamps kept file different replica order files kept directory different different servers 
agent create virtual values 
example agent stores maximum value replica time stamps replicated file list directory read server sorted passed client 
server failure server fails replicas server inaccessible 
happens agent notes replicas failing server unavailable 
write done file replica failed server agent marks unavailable replica invalid updates available replicas 
replica replicated file list associated state type fup theta 
part state caches status server holding replica second half indicates replica represents suitable latest version file 
failed server available agent changes state replicas server 
replica state invalid transferred valid state 
file recovery done concurrently file access write access file blocked short time invalid copy file recovered 
logging operations missed replica recover file replacing replica copy valid replica 
implementation recovery non directory files straightforward fits typical size usage unix files 
recovery directories copying complex 
necessary compare directories file creation deletion renaming effectively copy valid directory invalid 
agent failure information replicated file list 
order protect agent failure agent maintains stable version replicated file list called stable file list 
minimum stable file list contain mapping replica valid invalid 
file replicated servers expensive update changes stable file list necessary file created deleted changes state described 
agent fails state service remains latest version stable file list 
recovering agent locate replica latest version 
version protocol described locate server replica 
way valid replicas file different agent crashed writing file possible writes successful 
eliminate possibility running phase protocol expensive require changing server frequently writing stable file list 
rely fact client expect write stable receives response agent 
doing requires recovering agent ensure valid replica file identical 
file accessed recovering agent ensures property 
order avoid unnecessary recovery keep stable file list indication valid replicas file identical 
valid replicas identical write currently progress 
agent flag file stable file list time started write remove flag write completed add large overhead writes 
leave file flagged period time elapses activity file 
call flagged file active file passive 
file passive writing latest replica write time stable file list 
subsequent write automatically file active 
replicating agents obvious problem service described section agent critical process files inaccessible 
service slower robust nfs server 
methodology replicate agent 
servers guarantee copies theta delta theta gamma delta theta delta theta gamma delta theta delta theta gamma delta theta delta theta gamma delta cw delta delta delta delta deltaff ffl isis isis theta theta theta theta theta delta delta delta delta delta delta delta delta delta delta file servers agents clients nfs nfs client agent server interaction identical state need intermediate 
avoid changing clients atomic broadcast rpcs communication agents 
operations processed single agent making unnecessary broadcast request agents 
chose client select agent send requests 
necessary agent communicate agents atomic broadcast provided isis 
illustrates structure 
need modify client react agent failure 
special semantics nfs idempotency simplify problem making agent failure transparent 
client simply retries operation redirecting requests different agent 
isis isis system developed cornell provides set communication protocols tools developing fault tolerant dis tributed applications 
describe features isis design agent replication file service 
comprehensive description isis underlying principles may 
key features purposes ffl fault tolerant process groups 
agents structured fault tolerant process group isis 
isis provides location transparent communication process group members 
agent crashes isis failure detection mechanism completes pending broadcasts informs group members failure 
ffl group broadcasts 
agent maintains locally cached information kept consistent state agents example replicated file list current status servers 
isis supports management replicated data providing set broadcast primitives propagating updates members group 
depending consistency requirements programmer may choose atomic broadcast primitives guarantee global order updates strongly ordered efficient broadcast protocols 
ffl state transfer 
new agent added group agent restarted crash needs initialize local data structures 
isis state transfer tool allows agent integrated group system running 
accomplished transferring necessary data existing group member new agent 
ensures transfer atomic respect updates 
ffl coordinator cohort 
actions need performed single agent necessary guarantee action completed agent fails 
recovery server example action 
isis provides tool structuring computation 
member group coordinator chosen execute action members cohort monitor progress prepared take coordinator crash 
tokens clients don broadcast requests agents mechanism needed properly synchronize concurrent updates replicated file 
constrain agents exclude writing file associated file write token agent acquire updating replica file 
describe token passing mechanism detail provides example replicated data structure maintained isis broadcasts 
implementation ensure tokens lost agent crashes 
information current token holder replicated agent 
agent asks token broadcasting request message 
holder token completing current operation broadcasts message pass tox order transfer token agent 
agent listens broadcasts keeps track current token holder pending token requests 
holder token crash agent chosen arbitrarily inherit token 
notice necessary agents agree order pending requests current token holder decides agent get token decision part pass message 
allows choose efficient broadcast primitive isis protocol implementing token operations 
isis failure detection mechanism guarantees token operations atomic respect failures 
ensures agents view tokens agent holding failed 
token mechanism serves tool synchronizing updates stable file list 
furthermore allows detect possible inconsistencies replicas file 
inconsistencies caused failure agent update active file failed agent held write indirection replication synchronization read rpc write rpc gamma nfs isis bcast rpc gamma nfs write write rpc gamma nfs isis bcast create rpc gamma nfs isis bcast table overhead various nfs operations replicas token may inconsistent replicas 
agent inherits token resolves inconsistencies allowing updates file 
approach advantage deferring cost detecting recovering partially completed updates time failure occurs 
performance section show design provide benefit highly available files reasonable cost user 
table summarizes overhead operations compared nfs 
operations incur overhead due fact client requests pass agent 
cost extra level indirection standard rpc 
uses read write algorithm additional overhead involved case read operations 
write operations expensive replicas file updated 
degree replication file needs nfs calls servers order process single write request 
words overhead write due replication gamma nfs operations 
results higher network traffic increased load nfs servers 
agent uses broadcast style rpcs perform updates replicas parallel overhead directly affect total time takes process request 
delay observed client depend long takes slowest nfs update replica 
additional source delay updates cost synchronizing concurrent write agents 
agent start writing replicas file needs send isis broadcast order acquire write token file 
case client writes file cost paid write operation 
agent holding token perform updates interacting agents isis 
hand agents receive sequence requests update file token needs passed back forth agents 
worst case token passing overhead adds delay single write operation 
shows unix environment concurrent updates file rare file updated typically entire file written 
synchronization mechanism designed perform setting cost acquiring token amortized large number write operations 
consider cost creating new replicated file 
update replicated directory create operation involves kind overhead writing replicated file agent needs acquire write token directory forward create request servers 
addition new file needs inserted replicated file list 
cost extra isis broadcast sending replicated file list entry agents additional nfs operations update stable file list servers 
prototype supports full nfs protocol completed november 
table compares total time read write create operations standard nfs 
reads writes measured blocks data mbit ethernet sun workstations servers 
measurements performed caching client side 
prototype broadcast style rpc updating replicas nfs read ms ms ms ms write writer ms ms ms ms write writers ms ms ms ms create ms ms ms ms table nfs versus degree replication 
implemented 
consequently figures table show delay write create operations increases roughly linear degree replication 
adding broadcast rpcs bring cost updating multiple replicas cost updating single replica 
improvements expect times slower nfs 
belief system local caching client side performance perfectly acceptable typical user 
supporting fault tolerance top standard file system overly hard expensive 
total time needed design prototype months 
expect version file service robust fast widespread department months 
designing needed replicate service twice supply multiple servers supply multiple agents 
allowed assess power isis primitives replication step 
difficulty discussed section arises having deal lack support replication level 
extra replication step necessary nfs server deterministic 
exactly implement rule section 
extra replication step accommodate collection disparate file system protocols 
preliminary experiences encouraging 
workstations supply client side buffering extra cost replication part noticeable 
expect users want mainly text files system files password file replicated 
typical kind access files leads believe observed performance cost high availability small 
problem need address scaling larger networks 
clearly problem file system reasonable workstation environment 
current architecture modified put environment 
interesting see able incorporate architectural changes state machine methodology 
basic architecture designed authors armstrong 
armstrong eliot morrison implemented system ken birman tommy joseph helped design 
bernstein 
loosely coupled system reliably storing data 
ieee transactions software engineering se may 
ken birman 
replication availability isis system 
proceedings tenth symposium operating system principles pages 
acm sigops 
ken birman thomas joseph 
exploiting virtual synchrony distributed systems 
proceedings eleventh symposium operating system principles pages 
acm sigops 
eric cooper 
replicated distributed programs 
proceedings symposium operating systems principles pages 
acm sigops december 
ousterhout trace driven analysis fo bsd unix file system 
proceedings tenth symposium operating systems principles pages 
acm sigops 
john howard michael kazar menees david nichols satyanarayanan robert sidebotham michael west 
scale performance distributes file system 
acm transactions computer systems february 
barbara liskov scheifler 
guardians actions linguistic support robust distributed programs 
acm transactions programming languages systems july 
michael nelson brent welch john ousterhout 
caching sprite network file system 
acm transactions computer systems february 
fred schneider 
generals action implementing fail processors 
acm transactions computer systems may 
fred schneider 
state machine approach tutorial 
technical report tr cornell university dept computer science upson hall ithaca ny december 
dale skeen 
determining process fail 
acm transactions computer systems february 
sun microsystems garcia ave mountain view ca 
networking sun workstation revision edition february 
kevin wilkinson lee 
reliable servers distributed system 
proceedings seventh international conference distributed computing systems pages 
ieee computer society 
