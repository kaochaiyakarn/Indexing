reusable coordinator modules massively concurrent applications arbab blom burger cwi box gb amsterdam netherlands email kees cwi nl september isolating computation communication concerns separate pure computation pure coordination modules enhances modularity understandability reusability parallel distributed software 
manifold pure coordination language encourages separation 
real concrete running manifold programs demonstrate concept pure coordination modules advantage reuse applications different nature 
performance results examples show overhead manifold achieve enhanced modularity reusability practice small compared conventional paradigms design programming parallel distributed software 
keywords coordination reusability distributed computation performance measurements 
shortcomings common approaches design development parallel distributed applications stem fundamental properties various models communication construct software 
proper programming paradigm expressing coordination cooperation various active components comprise single concurrent application programmers forced low level communication constructs message passing directly code 
primitives generally scattered source code application typically intermixed non communication application code protocols coordination generally manifest tangible form easily identifiable pieces source code 
spite fact coordination protocols complex expensive develop part non trivial parallel distributed application treated separate commodity designed developed debugged maintained reused isolation rest application code 
communication concerns computation decreases comprehensibility maintainability reusability software modules 
targeted send primitives message passing models communication strengthen dependence individual processes environment 
diminishes reusability maintainability processes 
complicates debugging proving correctness programs process depends existence certain expected valid behavior processes correctness encapsulated concept 
coordination languages ameliorate problems extent 
variety interesting models languages systems language extensions proposed coordination 
interaction machines linear objects shared data tuple space models linda gamma bauhaus extensions enhance various flavors lowlevel message passing models additional concepts synchronizers contracts constraints rules events adaptations logic programming languages pms prolog multi prolog prolog shared prolog notably strand 
review related scope appears 
existing coordination languages go way support reusable pure coordination program modules 
coordination models languages grouped general categories data oriented control oriented primitives recognize constructs offer application programs manipulating 
independent performance issues specific coordination model language generally influences architectural design program structure parallel distributed application significant ways 
known established practically coordination languages linda variants induce data oriented approach software design may may natural fit application 
comparatively reported models languages coordination specific focus control oriented applications 
relevant takes message passing paradigm base modifies introducing additional notions synchronizers contracts constraints events 
major drawback approaches control oriented coordination models languages overcome deficiencies inherent underlying message passing paradigm 
goal demonstrate concept pure coordination modules reusability different applications real concrete running examples coordination language manifold iwim model communication 
expanding earlier version supplying performance measurements analysis results test case 
iwim model offers paradigm control oriented coordination 
brief summary iwim model 
overview manifold language appears 
detailed description iwim manifold appear 
overview earlier version manifold language implementation published contains series examples 
purpose syntax semantics relevant constructs manifold introduced trivial example program 
discuss quite non trivial example sorting show manifold encourages isolating communication computation concerns separate modules 
reusability pure coordination module developed sorting demonstrated manifold program applied coordinate parallel distributed numerical optimization application domain decomposition algorithm 
examples run change source code variety parallel distributed heterogeneous computing platforms 
performance results optimization example summarized compared results obtained alternative non manifold solutions problem 
close short 
iwim model communication iwim stands idealized worker idealized manager generic model communication supports separation responsibilities encourages weak dependence workers processes environment 
iwim model described terms significant characteristics 
defines concrete model communication family models 
various members family different significant characteristics regards synchronous vs asynchronous communication 
basic concepts iwim model processes events ports channels 
process instance black box defined ports connection exchanges units information processes environment 
port named opening bounding walls process units information exchanged standard type primitives analogous read write 
loss generality assume port exchange information direction input port output port process 
notation refer port process instance interconnections ports processes channels 
channel connects port producer process port consumer process 
write denote channel connecting port producer process port consumer process specific details inter process communication channels depends types channels communication 
iwim defines synchronous channel type basic protocols asynchronous channels 
specific concrete model iwim family support number different channel types subtype basic channel types iwim 
independent channels event mechanism information exchange iwim 
events broadcast processes environment broadcast yielding event occurrence broadcasting process event source 
principle process environment application pick broadcast event occurrence 
practice usually processes pick occurrences event tuned sources 
concrete details broadcast mechanism observers tune event sources details communication events automatically synchronizes source event occurrence observers intentionally left unspecified iwim 
iwim model supports anonymous communication general process need know identity processes exchanges information concept reduces dependence process environment processes reusable 
process iwim regarded worker process manager coordinator process 
responsibility worker process perform computational task 
worker process responsible communication necessary obtain proper input requires perform task responsible communication necessary deliver results produces proper recipients 
general process iwim responsible communication processes 
responsibility manager process arrange coordinate necessary communications set worker processes 
bottom layer worker processes called atomic workers application 
iwim model application built dynamic hierarchy worker manager processes top layer 
note manager process may considered worker process manager process 
communication channels channel communication link carries sequence bits grouped variable length units 
channel represents reliable directed buffered flow information time 
reliable means bits placed course prevents process identity part contents unit produces ports processes 
channel guaranteed flow loss error duplication order preserved 
directed means identifiable ends channel source sink 
channel established producer process consumer process operates autonomously transfers units source sink 
assumptions internal operation producer consumer channel possible contain pending units 
may may desirable channel immediately disconnect source sink soon connection opposite broken 
pending units channel delivered producer delivered consumer 
possibility existence pending units channel gives identity independent producer consumer meaningful channel remain connected ends disconnected 
types connection identified port channel keep type break type 
break type connection port channel breaks automatically connection channel breaks 
keep type connection hand persists connection channel breaks 
different types channels iwim model synchronous channel type asynchronous channel types bb bk kb kk 
channel pending unit channel type 
meaningless talk channel type complete producer consumer pair 

bb channel channel type disconnected producer consumer automatically soon disconnected 

bk channel channel type disconnected producer automatically soon disconnected consumer disconnection producer disconnect channel consumer 

kb channel channel type disconnected consumer automatically soon disconnected producer disconnection consumer disconnect channel producer 

kk channel channel type disconnected processes automatically disconnected 
letters name channel type respectively designate break keep type connections ports corresponding ends asynchronous channels type 
primitives workers managers means communication available process iwim ports events 
communication primitives allow process exchange units ports analogous traditional read write primitives 
process broadcast event processes environment raising event 
identity event identity process comprise broadcast event occurrence 
process pick event occurrences broadcast processes react 
process iwim raise event react event occurrences detected read write ports 
manager processes dynamically create process instances channels re connect channels ports processes managers primitives enable carry computation 
manager process typically controls communications dynamic number process instances data flow network 
processes generally unaware patterns communication may change time decisions respective manager processes 
manifold coordination language section briefly introduce manifold coordination language managing complex dynamically changing interconnections sets independent concurrent cooperating processes concrete model iwim family 
specifically manifold model concrete version iwim model 
basic concepts process event port channel iwim corresponds explicit language construct 

communication asynchronous 
synchronous communication channel type raising broadcasting reacting events synchronize processes involved 

separation computation communication concerns distinction workers managers strongly enforced 
manifold strongly typed block structured event driven language 
primary entities created manipulated manifold program processes ports events streams 
manifold system supports separate compilation 
manifold source file constitutes program module encapsulating declared locally scope 
module access entities defined modules importing definition exported share ones declared extern 
scope rules syntactic structure programs manifold influence broadcast events determine processes tuned observe event occurrences processes 
manifold application consists potentially large number light heavy weight processes running network heterogeneous hosts may parallel systems 
processes application may written different programming languages 
may know manifold fact cooperating processes manifold concurrent application 
manifold system consists compiler run time system library number utility programs libraries builtin predefined processes link file generator called run time configurator called config 
current implementation manifold system uses pvm number different thread packages various platforms 
implementation developed emphasis portability support heterogeneity execution environment 
ported platform supports thread facility functionally equivalent small subset posix threads plus inter process communication facility roughly equivalent small subset pvm 
environment currently runs sgi irix sun solaris ibm sp 
uses object files produced manifold language compilers produce link files needed compose application executable files required platform 
run time application utility program config consults user supplied host configuration file determine actual host processes dynamically created manifold application run 
library routines comprise interface manifold processes written languages automatically perform necessary data format conversions data routed various different machines 
processes manifold atomic workers iwim model called atomic processes 
operating system level process atomic process manifold processes called non compliant atomic processes 
manifold provides library functions called regular function running atomic process support appropriate interface atomic processes manifold world 
atomic processes interface called compliant atomic processes 
compliant atomic process run separate operating system level process heavy weight process thread light weight process operating system level process called task 
atomic processes produce consume units ports generate receive events compute 
way desired separation computation coordination achieved 
coordination processes written manifold language called manifolds 
manifold definition consists header body 
header manifold gives name number types parameters names input output ports attributes see 
body manifold definition block 
block consists finite number states 
state label body 
label state defines condition transition state possible 
expression match observed event occurrences event memory instance manifold 
body simple state defines set actions performed transition state 
body compound state nested block call parameterized subprogram known manner manifold 
manner consists header body 
subprograms languages header manner essentially defines name types number parameters 
manner atomic regular 
body regular manner block 
body atomic manner function interface manifold world interface library compliant atomic processes 
streams communication manifold asynchronous 
manifold asynchronous iwim channels called streams 
stream communication link transports sequence bits grouped variable length units 
stream represents reliable directed flow information source sink 
iwim model constructor stream processes general third process 
stream established producer process consumer process operates autonomously transfers units source sink 
sink stream requiring unit suspended units available stream 
suspended sink resumed soon unit available consumption 
attempt source stream place unit stream suspended infinite buffer capacity stream filled basic stream types designated bb bk kb kk corresponding basic asynchronous channel types iwim behaving slightly different protocol regards automatic disconnection source sink 
furthermore manifold bk kb type streams declared 
bk type stream infinite capacity stream really impractical 
volume units contained stream exceeds threshold surplus diverted file 
application generates buffered information fill capacity file system needs larger file system bit restructuring introduce synchronization buffered information 
remains connected sink disconnected source allows dangling reconnected source 
way output sources sent single sink order preserved 
likewise kb type stream remains connected source disconnected sink allows dangling reconnected sink 
way output single source distributed sinks desired order 
example kb streams appears 
connection stream port process connected severed stream process port belongs dies 
furthermore break type connection stream port corresponds occurrence letter name stream type severed stream realizes connection severed manifold process set connection 
case say stream preempted constructor 
preemption stream simply break type connections 
see details 
events state transitions manifold event raised process continues processing resulting event occurrence propagates environment independently 
definition process interested events broadcast process syntactic scope knows know name handle ports declared created known current scope defined global scope ports passed actual parameter ports received data unit dereferenced process called observer events process observer process interested event occurrence automatically receive event memory 
observed event occurrences event memory process examined reacted process leisure 
reaction event occurrence observer process transition labeled state 
control structure manifold language event driven state transition mechanism 
familiar control structures sequential flow control represented connective pascal conditional constructs loop constructs built event mechanism available manifold language convenience features 
transition state primitive actions specified body performed atomically non deterministic order 
state preemptable conditions transition state satisfied current state preempted meaning streams constructed preempted transition new state takes place 
important primitive actions simple state body creating activating processes generating event occurrences connecting streams ports various processes 
ports port regulated opening boundary process information produced consumed process exchanged processes 
regulated means information flow direction port flows process 
information exchanged process processes ports quantized discrete bundles called units 
unit packet containing arbitrary number bits produced transferred consumed integral fashion partial units 
ports structural properties processes defined owned 
ports belong particular process called local ports 
ports units flow process called input ports process 
similarly ports units flow process called output ports process 
standard ports input output error defined process instances manifold 
port distinct sides arrival side departure side 
normally process exclusive access departure side input ports arrival side output ports processes access opposite sides ports 
reason arrival sides input ports departure sides output ports called public sides ports departure sides input ports arrival sides output ports called private sides 
process may allow processes access private sides ports parameter passing sending port units 
port connectivity type stream connections side port controlled certain attribute port called connectivity 
connectivity values defined manifold header local ports attributes real ports process instances 
guarantees connection port instance manifold desired connection type 
condition name type meaning connect transitory connection arrival side 
connected non transitory connection arrival side 
disconnect transitory disconnection arrival side 
disconnected non transitory connection arrival side 
non transitory creation process instance condition connected true 
non transitory condition disconnected true condition true 
connect transitory connection departure side 
connected non transitory connection departure side 
disconnect transitory disconnection departure side 
disconnected non transitory connection departure side 
non transitory creation process instance condition connected true 
non transitory condition disconnected true condition true 
full non transitory unit available arrival side port transport 
empty non transitory stream containing units connected departure side 
transport transitory unit passed port 
table simple port conditions port conditions guards ports process interface topology communication network application 
generally topology changed dynamically manifold instances direct involvement affected processes 
knowledge certain facts topology local neighborhood port crucial proper operation process port belongs generally interest processes know port 
example process may want know stream connection ports notified connection broken 
natural process interpret disconnected status input ports initial connection cue wrap affairs terminate services longer required 
instance processes example described rely useful protocol termination 
useful facts status port stream connections available manifold port conditions 
port condition predicate true false port 
port condition simple composite see 
process access side port guard primitive action manifold receive notification specified port condition true port 
primitive action guard condition event installs creates activates special virtual process specified port 
virtual process waits necessary specified condition true 
condition true guard virtual process posts specified event event memory terminates 
installed guard remains port fires event removed subsequent guard installation port condition 
composite port condition simple port conditions binary sequencing operator 
composite port condition form applied port means wait necessary true wait necessary true wait necessary true composite port condition true simple port conditions available manifold language listed table 
simple port conditions full empty transport relate availability flow units port 
remaining simple port conditions relate incidents connect disconnect conditions status connected disconnected conditions history conditions connections disconnections sides port 
simple port conditions transitory non transitory 
transitory condition detected expected guard installed waiting transitory condition true 
words values transitory conditions remembered ports 
guard installed expecting transitory condition condition true guard able detect wait time condition true 
non transitory condition value remembered port 
means non transitory condition true time guard expecting installed guard recognize condition true 
application construction manifold supports structured programming coordination modules natural way 
scope rules language allow programmers localize names events manifolds manners processes bodies manifolds bodies manners inner blocks share declared entities source files share separately compiled source files familiar import export extern declarations 
manifold application typically composed separately compiled source files specific different host architec ture 
application construction consists separate stages compilation task composition run time configuration 
reason having separate stages enhance reusability delaying decisions mappings irrelevant higher levels abstraction 
instance manifold program reflects coordination protocol specifies things set logical connections independent data transport connections take place 
imposing appropriate constraints outside manifold language task composition stage application programmer ensure specific set communicating processes task instance guarantee realization specified connections shared memory effective data transport 
different set constraints processes running different hosts logical connections apply change source code manifold program necessary effective data transport case may go sockets 
result compilation stage bunch object files produced manifold fortran compilers 
manifold language provides constructs resource allocation host mapping object files independent constraints stage 
purpose task composition stage produce executable files application composing various necessary object files user supplied specification 
responsibility utility program 
input small text file specifies manifold atomic processes placed tasks executable files optionally gives various sets constraints number process instances housed task instance task instance new instance process created input user tailor composition application impose constraints reflecting platform dependent resource considerations achieve desired results 
output number source files plus makefile platform compile link proper object files libraries produce executable files application necessary platform 
concept task composition separate stage allows object files produced manifold language compilers application changing number contents executable files 
allows users experiment various load resource allocation constraints necessity change recompile programs 
result running makefile produced appropriate platforms number executable files suitable corresponding platform 
set executable files constitutes executable files tasks application 
execution manifold application starts running executable files compatible host 
running program invokes config utility tailor proper host configuration define mapping tasks hosts specified user supplied configuration map file 
changing host configurations constraints instances task may may run requires changing input map file config run time 
manifold system ensures subject constraints mappings specified application instances task necessary dynamically created appropriate hosts accommodate process instances application dynamically creates course execution 
hello world 
example consider simple program print message hello world standard output 
manifold source file program contains manifold import 
auto process print 
manifold main hello world 
print 
line code defines manifold named takes arguments states keyword import real definition body contained source file 
defines interface process type definition actual implementation 
actual implementation process atomic process function manifold irrelevant source file 
assume waits receive units standard input port prints 
detects incoming streams left connected input port done printing units received terminates 
second line code defines new instance manifold calls print states keyword auto process instance automatically activated creation deactivated departure scope defined case application 
declaration process instance print appears outside blocks source file global process known instance manifold body defined source file 
lines code define manifold named main takes parameters 
manifold definition process instance default ports input output error 
definition ports shown example ports defined main default 
body manifold block enclosed pair braces contains single state 
name main special manifold manifold name manifold application automatically created instance manifold called main process started application 
activation manifold instance automatically posts occurrence special event event memory process instance case main 
initial state transition possible main enters state state 
state contains single primitive action represented stream construction symbol 
entering state main creates stream instance default bk type connects output port process instance left hand side input port process instance right hand side 
process instance right hand side course print 
appears character string constant left hand side process instance conceptually constant manifold special process instance produces value unit output port dies 
having stream connection processes main waits stream connection state break ends 
stream breaks case source soon string constant delivers unit stream dies 
event occurrences event memory main default transition state reaching falling terminator period terminates process main 
print reads unit prints 
stream type bk ensures connection stream sink preserved preemption disconnection source 
stream empty disconnected source automatically disconnects sink 
print senses incoming streams dies 
point process instances left application terminates 
hello world print hello world example manifold note simple example consists process instances worker processes character string constant print coordinator process main 
shows relationship constant print established main 
note coordinator process main establishes connection worker processes 
transfer units stream creates interfere activities worker processes ways 
bucket sort example previous section simple require static pattern communication 
section illustrate dynamic capabilities manifold program sorting unspecified number input units 
particular algorithm example necessarily effective 
simple describe serves purpose demonstrating dynamic aspects manifold language 
sort algorithm follows 
sufficiently large theoretically infinite number atomic available atomic sorter able sort bucket units efficiently 
number may vary atomic sorter unpredictable way atomic sorter internally decide units willing sort consideration unpredictable ir relevant factors load system phase moon atomic sorter receives input input port raises specific event receives parameter inform processes filled input bucket sorts units produces sorted sequence units output port terminates 
parallel bucket sort program supposed feed input units atomic sorter take feed rest input input copy merge output sequences atomic sorter new copy produce resulting sequence output port 
merging sorted sequences done separate merger process subprogram manner called sorter 
assume application consists source files 
source file contains main manifold shown 
assume merger separate process 
merger atomic sorter written manifold language efficient written computation language concern details merger atomic sorter assume defined separate source file 
manifold import 
manifold readfile process filename atomic internal 
manifold sorter import 
manifold event atomic internal 
manifold port atomic internal 
manifold main auto process read readfile unsorted 
auto process sort sorter 
auto process print 
read 
sort 
print 
main manifold instance application creates read sort print instances manifold definitions readfile sorter respectively 
connects output port read input port sort output port sort input port print 
process main terminates connections broken 
process read expected read contents file named unsorted produce unit sort item file output port 
producing units read simply terminates 
process sort instance manifold definition sorter expected sort units receives input port 
process terminates input disconnected output units delivered output port 
input output output merge sorter input bucket sort manifold definition sorter shown main interest 
keyword export line allows separately compiled manifold source files import coordinator manifold 
state instance sorter connects input instance calls 
installs guard input port guard primitive action 
guard posts event finished empty stream connected departure side arrival side port stream connections connection 
means event finished posted instance sorter connection arrival side input connections arrival side input severed units passed port consumed 
connections state shown export manifold sorter event filled flushed finished 
process filled 
stream reconnect kb input 
priority filled finished 
activate input 
guard input empty finished input 
finished ignore filled 
possible event 
output output filled process merge output 

stream kk 
merge merge 
stream kk merge 
output 
activate merge input 
sorter 
merge 
merge merge 
output 
finished 
guard output flushed ensure flushing terminated void wait units flush output 
flushed halt 
events preempt state instance sorter incoming stream connected input disconnected incoming units reads units available incoming stream guard input posts event finished process read fill raise event filled 
normally events occurs number input units exactly equal bucket size finished filled occur simultaneously 
case priority statement line sure handling finished takes precedence filled 
assume number units input supplied instance sorter equal bucket size atomic sorter 
case event finished preempt state cause transition corresponding state sorter 
state ignore occurrence filled may raised number input units equal bucket size deliver output output sorter 
connections state shown suppose number units input supplied instance sorter greater bucket size atomic sorter 
case event filled preempt state cause transition corresponding state sorter 
state create instance merger process called merge 
new instance sorter created state nested block 
rest input passed input new sorter output merged output atomic sorter result passed output sorter 
connections state shown occurrence finished state preempts connected streams causes transition local finished state block 
preemption necessary inform new instance sorter breaking stream connects input input receive terminate 
empty body finished state means causes exit containing block 
state sorter instance installs guard output port post event flushed stream connected arrival side port connection 
means event flushed posted instance sorter connection arrival side units arriving port passed 
sorter instance waits termination special predefined process void happen special process void terminates 
effectively causes sorter instance hang indefinitely 
event terminate indefinite wait occurrence flushed indicates units pending go output port sorter instance 
print read atomic processes shows connections various instances execution sort program 
denote th instance respectively 
note dynamic way kb stream emanating read cascades output various atomic allowing fill bucket input units decides 
reconnection stream successive processes depicted dashed arrows 
shown instances sorter manifold 
th instance sorter coordinates th instance th instance st instance sorter 
final th instance sorter degenerate case coordinate th instance interesting aspect sorter manifold dynamic way switches connections process instances creates 
interesting fact spite name sorter knows sorting 
change name systematically change names identifiers uses realize knows divert input instance process creates instance raises certain event divert rest input new instance divert output processes third process output passed output 
sorter embodies protocol describes instances process definitions case communicate 
sorter manifold just happily orchestrate cooperation pair processes input output event behavior regardless computation perform 
cooperation protocol defined sorter simply chunks input stream instances knows output streams instances knows 
called needs really sort input units process called needs really merge produce units output receives input port 
computation want 
parameterizing names manifolds sorter changing name obtain general program export manifold manifold event manifold output 
event filled flushed finished 
process filled 
stream reconnect kb input 
priority filled finished 
activate input 
guard input empty finished input 
finished ignore filled 
possible event form 
output output filled process output 

stream kk 

stream kk 
output 
activate input 



output 
finished 
guard output flushed ensure flushing terminated void wait units flush output 
flushed halt 
new version bucket sort main program manifold import 
manifold manifold event manifold import 
manifold readfile process filename atomic internal 
manifold event atomic internal 
manifold port atomic internal 
manifold main auto process read readfile unsorted 
auto process sort 
auto process print 
read 
sort 
print 
concrete demonstration reusability coordinator modules section example uses coordinator numerical optimization problem 
domain decomposition consider optimization problem max gamma cos gamma cos shows landscape formed function domain 
function gamma cos gamma cos analytical solutions problems general non existent domain decomposition common search technique solve numerical methods 
domain decomposition imposes grid domain function splitting number sub domains determined size grid 
obtain number rough estimate highest value sub domain 
select sub domains promising values decompose smaller sub domains 
new estimates highest value sub domains recursively narrow search process smaller smaller regions hopefully tend area real maximum estimates obtained maximum values accurate 
single grid domain decomposition grid imposed successive sub domains 
multiple grid domain decomposition techniques allow different grid sub domain granularity properties may depend attributes sub domain function region 
example consider single grid method 
extension example multiple grid domain decomposition straight forward involves small change main program application 
need simple computation modules current example ap split 
instance ap simply prints units reads input describes sub domain values estimated maximum value sub domain 
instance split receives parameters specification grid case theta 
reads input port unit describes sub domain produces units output port describe sub domains obtained imposing grid input domain terminates 
th instance reads bucket sub domains simplicity input port raises specific event receives parameter inform processes filled input bucket sub domains descriptions 
finds best estimate optimum value sub domains producing ordered sequence units describing best solutions output port terminates 
example sampling simply evaluate number say sample points sub domain consider sample point maximum best estimate sub domain 
instance reads ports ordered sequences units describing sub domains best estimates produces sequence best sub domains output port 
need manifold program say eval coordinate cooperation instances solve optimization problem parallel distributed fashion 
eval receives input port units describing sub domains 
supposed feed input units atomic evaluator take feed rest input input copy merge output sequences atomic evaluator new copy produce resulting sequence output port 
similarity description eval sort suggests coordination module optimization problem 
eval merely version parameters 
manifold program shows single iteration domain decomposition application separately compiled 
manifold atomic internal 
manifold manifold event manifold import 
manifold split port port atomic internal 
manifold event atomic internal 
manifold port atomic internal 
manifold main auto process split split 
auto process eval 
auto process print 

split 
eval 
print 
output program shows result produced instances description single sub domain 
top lines show best estimates neighborhoods corners domain symmetric function 
domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point domain point straight forward generalization program repeats single step termination criterion maximum number iterations diminishing improvements threshold reached 
iteration selects best sub domain far input instance visualizer snap shot theta distributed domain decomposition split eval 
manifold program coordinates cooperation different instances eval split 
output produced program theta grid 
line output initial input unit representing domain 
succeeding group lines represents iteration 
best sub domain iteration fed input iteration 
line group representing fifth iteration shows best solution slightly better best solution single step theta grid 
domain domain point domain point domain point domain point domain point domain point domain point domain point 
domain point domain point domain point domain point highly modular structure application remarkable 
computation modules functions simple idea relate cooperate 
coordination module eval knows computation modules just happy coordinating sorter workers managing numerical optimization workers 
various processes comprising application run parallel distributed platforms change source code 
plumbing paradigm manifold easy divert flows units change coordination structures dynamically modify topology communication links computation coordination modules adapt application new requirements 
plug graphics modules display going computation 
small computational steering environment built example manifold coordinators generic graphics interaction modules 
user interface program graphically shows going activity various atomic evaluators may running different hosts allows user interactively direct focus attention program areas interest simply drawing box designate sub domain 
shows snap shot simple visualizer interface theta distributed domain decomposition optimization application moved fifth iteration top right corner sub domain run produced output 
computational steering interface includes capabilities simple visualizer allows user select domain mouse drawing rectangle start pressing mouse buttons recursive decomposition domain 
shows interaction user steers multiple grid domain decomposition computation manifold program working function shown 
performance evaluation difficult produce meaningful numerical measures fairly compare performance manifold application conventional parallel distributed versions application 
primary reasons manifold increase modularity reusability software components applications 
fact positive negative overhead manifold application compared incarnation application classified categories 
overhead incurred designing organizing software style snap shot multiple grid decomposition interactively defined domains separates computation coordination components smaller reusable modules 
overhead involved realization design manifold language execution existing manifold run time environment 
accepting moment premise isolating computation coordination concerns separate software modules desirable difficult program application style various tools including manifold 
case component overhead fixed fairly compare performance manifold tools 
measures useful implementors manifold indicating additional optimization improve performance implementation 
hand performance measures meaningless users 
comparing performance manifold application application done different conventional style parallel distributed programming tool may unfair generally manifold feel measures meaningful users 
goal advocate certain style software design results reusable pure coordination modules reusable pure compu tation modules responsibility show price enhanced modularity gained style heavy loss run time efficiency 
set carry number experiments compare performance domain decomposition program described versions application sequential version done pvm 
versions application exact computation code domain theta grid function 
version written different style reflects straight forward implementation application reasonable programmer way fits naturally respective underlying paradigm 
sequential version contains simple loop calls evaluator function evaluate maximum function sub domains chooses best result 
effective sequential algorithm evaluating function domain 
serves purpose providing meaningful base versions 
pvm version consists main task splitter task evaluator tasks 
main task spawns splitter waits receive results coming evaluators selects best result reports 
splitter task imposes theta grid spawns evaluators informs report results main task terminates 
evaluator works sub domain reports local maximum function domain main task 
coordination communication necessary version application directly coded pvm calls program modules reasonable pvm programmer 
compared manifold version application described roughly times fewer user processes pvm version manifold version 
bulk extra number processes overhead style overhead implementation application manifold overhead implementation manifold system 
fortunately implementation manifold uses threads considerably reduces overhead having processes application 
ignoring distinction categories overhead know unfair manifold version effectively comparing apples oranges 
experiments run sgi challenge mhz ip processors mips processor chip cpu mips floating point chip fpu 
bit machine megabytes main memory kilobytes instruction cache kilobytes data cache megabytes secondary unified instruction data cache 
machine runs irix network server computing interactive jobs 
sgi machines network function file servers 
fact manifold version times processes considering ones needed manifold run time system 
number samples axis versus elapsed time minutes axis seq pvm mani performance versions domain decomposition application results performance measurements summarized figures show elapsed time vs amount computation 
obtain results ran versions application number case points range theta representing gradually intensive computation 
case point example means evaluator uses sample points sub domain approximate maximum function case point theta means function evaluated theta random sample points sub domain find local maximum high sampling rates may unreasonably excessive domain decomposition problem note really interested particular function depicted domain decomposition general 
high sampling rates means increase computation intensity application order obtain performance measures 
experiments run quiet periods system real contemporary computing environment guaranteed users 
furthermore unpredictable effects network traffic file server delays eliminated reflected results 
random perturbations ran versions application case point period ran close real time ran version application times case point 
raw numbers obtained experiments shown tables 
noc result result result result result average table elapsed time sequential version domain decomposition noc result result result result result average table elapsed time pvm version domain decomposition tables column shows intensity computation performed evaluator terms number sample points 
results obtained case shown corresponding row columns labeled result result tables representing real elapsed time run application 
time data tables appear mm ss ss ss ss format mm minutes ss ss shows seconds decimal fraction notation 
results experiment sorted separately row tables best worst performance measures appear respectively noc result result result result result average table elapsed time manifold version domain decomposition result result columns 
best worst performance measures row discarded average remaining results appear average column table 
performance curves figures obtained average data 
curves represent real elapsed time sequential marked seq pvm marked pvm manifold marked mani versions experiments 
observation graph significant difference performance sequential versions 
note sequential version naturally consists single process definition run processor 
pvm manifold versions consist processes take full advantage parallelism offered processors machine 
observe real time data concurrent versions roughly times smaller sequential version application computation range get nearly linear speed increasing number processors 
achievement may 
folklore wisdom parallel programming community says achieve linear speedup indication parallel algorithm indication stupidity sequential algorithm compare 
sound theoretical basis maxim turns true practice annoying frequency certainly holds case 
reason inclusion trivially comparable sequential version experiment confirm expectation linear speed underlying thread facility implementation manifold sgi irix operating system allows thread run available processor 
pvm manifold versions number evaluator processes keep available processors machine busy time 
disappointing surprise occur case 
smart sequential version dismissed prematurely lower computation intensities shown sample points sequential version performs manifold version lower intensities sample points outperforms pvm version 
low computation intensities overhead having processes required underlying machinery simply high compared simple sequential version application 
number samples axis versus elapsed time minutes axis pvm mani performance parallel versions domain decomposition application closeness performance curves pvm manifold versions remarkable considering implementation manifold system uses pvm 
shows performance curves larger scale 
distance curves represents total overhead manifold version respect pvm version 
major contributor additional overhead difference styles versions translates times processes manifold version compared pvm version 
observe overhead diminishes curves overlap intensity computation increases overhead having extra processes spreads longer execution time application 
contributor difference tween curves currently optimal implementation manifold system 
straight forward optimizations agenda reduce amount dynamic memory allocation execution time importantly saves number expensive calls thread safe versions malloc free functions 
largest single source extra overhead due fact current version pvm implementation manifold designed conjunction threads 
leads situation thread manifold task ends wasting deal time making relatively expensive select system calls pvm receive polling loop 
project polling loop performance manifold version application slightly better pvm version higher computation intensities 
may paradoxical fact manifold uses threads means opportunity common address space threads task communication processes corresponding threads avoid expensive inter task communication pvm 
generally judicious grouping processes tasks programmers linking manifold application significantly improve performance application allowing manifold run time system pass pvm possible 
iwim model communication supports anonymous communication separation computation responsibilities communication coordination concerns 
manifold coordination language takes full advantage key concepts iwim 
coordination languages manifold encourages decomposition parallel distributed application hierarchy pure computation pure coordination modules contain hard coded dependencies environment 
leads highly reusable computation modules interestingly highly reusable coordination modules 
contrast insecure public communication supported shared data space coordination models linda iwim channels manifold streams provide private point point secure means communication 
coordination models languages shared data spaces securing communication coordination sub domain unintended clashes intra component communication serious problem larger especially distributed applications 
hand manifold coordination modules safely re components securely managing coordination sub domain larger applications 
manifold linda different number respects 
instance manifold encourages separating coordination computation aspects application different modules compiled units linda primitives intermixed computation code 
especially communication protocols applications grow trivial complex actual communication protocols applications implicit nebulous semantics computation protocols 
development reusable pure coordination protocols concrete program modules hindered linda 
examples show single pure coordination module different applications 
manifold successfully implement parallel distributed versions semi coarsened multi grid algorithm koren numerical mathematics department cwi 
represents real life heavy duty computational fluid dynamics application manifold enabled restructuring existing sequential fortran code pure coordination protocols allow run parallel distributed platforms 
results favorable modification computational fortran code simple small reusable manifold coordination modules linear speed total execution time respect number processors hours 
earlier results published extensive results available 
group researchers polish academy sciences manifold implement loosely coupled genetic algorithms parallel distributed platforms 
results positive 
usefulness iwim model particular manifold language applications encouraging 
performance results show applications realistic computation intensities overhead manifold achieve enhanced modularity reusability practice small compared conventional paradigms design programming parallel distributed software 
resulting programs easily scalable effective number available processors computers heterogeneous environments 
iwim manifold applied cooperative constraint solving modeling activities information systems 
plumbing paradigm inherent iwim easy compose manifold application adapt new requirements 
enhance effectiveness coordination language presently developing visual programming environment manifold takes advantage underlying plumbing paradigm 
arbab 
coordination massively concurrent activities 
technical report cs centrum voor wiskunde en informatica kruislaan sj amsterdam netherlands november 
available line www cwi nl ftp cs ps arbab 
iwim model coordination concurrent activities 
paolo ciancarini chris hankin editors coordination languages models volume lecture notes computer science pages 
springer verlag april 
gelernter carriero 
coordination languages significance 
communication acm february 
arbab ciancarini hankin 
coordination languages parallel programming 
parallel computing 
appear special issue coordination 

andreoli ciancarini pareschi 
interaction machines 
trends object concurrent computing pages 
mit press 

andreoli pareschi 
linear objects logical processes built inheritance 
new generation computing 
carriero gelernter 
linda context 
communications acm 

banatre le 
programming multiset transformations 
communications acm january 
carriero gelernter zuck 
bauhaus linda 
ciancarini nierstrasz yonezawa editors object models languages concurrent systems volume lecture notes computer science pages 
springer verlag berlin 
bergstra klint 
coordination architecture 
ciancarini hankin editors proc 
st int 
conf 
coordination models languages volume lecture notes computer science pages italy april 
springer verlag berlin 
agha 
language framework multi object coordination 
proc 
ecoop volume lecture notes computer science pages 
springer verlag 
atkinson maio 
object oriented concurrency distribution 
journal object oriented programming march april 
helm holland 
contracts specifying behavioral compositions object oriented systems 
sigplan notices october 
holland 
specifying reusable components contracts 
lehrmann madsen editor proc 
ecoop volume lecture notes computer science pages 
springer verlag july 

andreoli gallaire pareschi 
rule object coordination 
ciancarini nierstrasz yonezawa editors objectbased models languages concurrent systems volume lecture notes computer science pages 
springer verlag berlin 
wise jones 
pms prolog distributed prolog processes modules streams 
implementations distributed prolog series parallel computing pages 
wiley 

blackboard communication prolog 
parallel execution logic programs volume lecture notes computer science pages 
springer verlag 
sutcliffe 
prolog linda new embedding linda sicstus prolog 
proc 
workshop blackboard logic programming pages june 
ciancarini 
concurrent language shared prolog 
acm transactions programming languages systems 
foster taylor 
strand new concepts parallel programming 
prentice hall 
arbab 
influence coordination program structure 
proceedings th hawaii international conference system sciences 
ieee january 
arbab blom burger 
reusable coordinator modules massively concurrent applications 
robert editors proceedings europar volume lecture notes computer science pages 
springer verlag august 
arbab 
manifold version language manual 
technical report centrum voor wiskunde en informatica kruislaan sj amsterdam netherlands 
available line www cwi nl ftp manifold ps arbab herman spilling 
overview manifold implementation 
concurrency practice experience february 
geist beguelin dongarra jiang manchek sunderam 
pvm user guide manual 
technical report ornl tm oak ridge national laboratory september 
arbab 
coordination distributed parallel multiple grid domain decomposition 
ferreira saad yang editors proceedings irregular volume lecture notes computer science pages 
springer verlag august 
papadopoulos arbab 
control driven coordination programming shared dataspace 
proceedings pact lecture notes computer science 
springer verlag september 
papadopoulos arbab 
coordination distributed parallel activities iwim model 
international journal high speed computing 
arbab burger 
restructuring sequential fortran code parallel distributed application 
proceedings international conference software maintenance pages 
ieee november 
koren 
coordination parallelize methods cfd problems 
parallel computing 
appear special issue coordination 
pascal arbab 
distributed evolutionary optimization manifold rosenbrock function case study 
fea international workshop frontiers evolutionary algorithms part third joint conference information sciences march 
duke university usa 
pascal arbab 
parallel distributed evolutionary computation manifold 
editor proceedings pact volume lecture notes computer science pages 
springer verlag september 
arbab 
coordination cooperative constraint solving 
proceedings acm symposium applied computing special track coordination models languages applications atlanta georgia february march 
acm 
papadopoulos arbab 
coordination models languages 
advances computers volume 
academic press 
arbab 
visual environment coordination language 
paolo ciancarini chris hankin editors coordination languages models volume lecture notes computer science pages 
springer verlag april 
