code injection survey vulnerabilities countermeasures katholieke yves frank report cw july universiteit leuven department computer science celestijnenlaan heverlee belgium code injection survey vulnerabilities countermeasures yves frank report cw july department computer science leuven implementation errors relating memory safety common vulnerabilities attackers gain control execution flow application 
carefully crafting exploit vulnerabilities attackers application transfer execution flow code injected 
code injection attacks powerful common attacks software applications 
report documents possible vulnerabilities applications lead situations allow code injection describes techniques generally attackers exploit 
fairly large number defense techniques described literature 
important goal report give comprehensive survey available preventive defensive countermeasures attempt eliminate specific vulnerabilities entirely attempt combat exploitation 
report presents synthesis survey allows reader weigh advantages disadvantages specific countermeasure opposed easily 
cr subject classification contents implementation vulnerabilities exploitation techniques stack buffer overflows 
vulnerability 
exploitation 
countermeasures solutions stack buffer overflows 
heap buffer overflows 
vulnerability 
exploitation 
countermeasures solutions heap buffer overflows 
dangling pointer 
vulnerability 
exploitation 
countermeasures solutions dangling pointer 
format string vulnerabilities 
vulnerability 
exploitation 
countermeasures solutions format string vulnerabilities 
integer errors 
countermeasures solutions integer errors 
solutions countermeasures safe language solutions 
static analyzers 
annotated source code analyzers 
non annotated source code analyzers 
dynamic analysis testing 
sandboxing 
fault isolation 
policy enforcement 
anomaly detection 
compiler modifications 
bounds checking solutions countermeasures 
protection 
protection pointers 
operating system hardware modifications 
non executable memory 
randomized instruction sets 
randomized addresses 
protection return addresses 
library modifications 
protection 
protection dynamically allocated memory 
format string countermeasures 
safer libraries 
randomized addresses 
synthesis countermeasures categories 
vulnerability categories 
applicability limitations categories 
protection limitations categories 
type categories 
response categories 
deployment tools 
development tools 
related bibliography software vulnerabilities currently advent multiuser networked computing major cause computer security incidents 
software vulnerabilities traced back mistakes programmers 
documents books exist attempt teach programmers program securely problem persists continue major problem foreseeable 
document focuses specific subclass software vulnerabilities implementation errors countermeasures proposed developed deal vulnerabilities 
specifically implementation errors allow attacker break memory safety execute foreign code addressed report 
preventive defensive countermeasures proposed combat exploitation common implementation errors document examines 
main goal provide complete survey existing countermeasures 
describe ways proposed countermeasures circumvented 
countermeasures examined protect general case buffer overflows document focuses examining protection attacks attacker specifically attempts execute code application execute normal circumstances injecting code calling library specific arguments 
follows general overview types countermeasures examined document safe languages languages discussed implementation vulnerabilities hard impossible 
languages generally require programmer specifically implement program language port existing program language 
focus languages similar languages stay close possible referred safe dialects programs written dialects generally restrictions terms memory management programmer longer explicit control dynamic memory allocator 
static source code analyzers attempt find implementation vulnerabilities analyzing source code application simple looking library functions known vulnerable implementation error complicated making full model program prefix deciding constructs cause specific vulnerability 
dynamic analysis testing tools instrument program generate specific events error encountered 
sandboxing attempt prevent vulnerability prevent abuse attempts contain damage abuse vulnerability 
anomaly detection tries detect attacks trying find application showing irregular behavior attempting execute system calls supposed execute particular moment execution program 
compiler modifications modify way compiler generates code adding sanity checks code protects critical memory addresses 
operating system hardware modifications attempt injection foreign code running application harder impossible 
library modifications cover wide range possible modifications generally easily changes existing dynamically linked programs need recompilation library countermeasures range just replacing functions misused linking library change way program behaves run time 
document structured follows section contains overview implementation errors countermeasures section attempt defend 
describes typical ways implementation errors abused 
section contains survey countermeasures vulnerabilities cases ways circumvented suggestions prevent 
section presents synthesis results allows reader weigh advantages disadvantages specific countermeasures opposed easily 
section examines related field vulnerability countermeasure surveys 
section discusses plans presents 
implementation vulnerabilities exploitation techniques section contains short summary implementation errors shall examine countermeasures structured follows vulnerability describe particular implementation error vulnerability 
describe basic technique attacker exploit vulnerability mention advanced techniques appropriate 
mention advanced techniques circumvent countermeasures 
thorough technical examination vulnerabilities exploitation techniques technical examination countermeasures 
describe exploitation techniques section focus ia architecture 
details exploiting specific vulnerabilities architecture dependent main techniques applicable architectures 
give short overview techniques defend specific vulnerability described 
detailed discussion techniques survey section 
stack buffer overflows vulnerability array declared space reserved array manipulated means pointer byte 
run time information array size available compilers generate code allow program copy data array overwriting adjacent memory space 
interesting information stored adjacent memory space possible attacker overwrite 
stack usually case stores addresses resume execution function call completed execution 
ia architecture stack grows meaning newer variables lower address older ones 
stack divided 
stackframe contains information current function arguments function called registers values stored function calls local variables saved frame pointer return address 
array allocated stack usually contained section local variables stackframe 
program copies past array able overwrite stored able overwrite function management information return address 
shows example program stack executing function 
function called function placed arguments local variables executed call instruction 
call saved return address pointer instruction call stack 
function prologue piece code executed function executed saved old frame pointer stack 
value stack pointer moment saved frame pointer register 
space local variables allocated pointer pointing data array characters buffer 
function execute code call 
data value value stack return address saved frame pointer local variables arguments return address saved frame pointer pointer data stack layout ia higher addresses buffer lower addresses stackframe local stackframe variables normal 
colored part indicates written function buffer correctly 
exploitation basic exploitation shows happen attackers able program copy data array 
contents buffer attackers overwritten pointer saved frame pointer left unchanged case return address function 
continue write older stackframe desired cases overwriting return address attacker main objective easiest way gain control program execution flow 
attackers changed return address point code copied buffer probably copying operation copy past buffer 
function returns return address normal cases resume execution function ended 
return address function overwritten pointer attacker injected code execution flow transfered 
frame pointer overwriting cases possible attackers overwrite return address 
overwrite bytes reach return address return address protected countermeasure 
shows attacker manipulate code call 
data value value code call 
data value value stack return address saved frame pointer local variables arguments return address saved frame pointer pointer data injected code normal stack buffer overflow stack return address saved frame pointer local variables arguments return address saved frame pointer pointer data return address saved frame pointer injected code higher addresses stackframe buffer variables local stackframe lower addresses higher addresses stackframe buffer variables local stackframe lower addresses stack buffer overflow overwriting frame pointer frame pointer able gain control execution flow program saved frame pointer set point different location saved frame pointer previous stackframe 
function ends frame pointer register moved stack pointer register effectively freeing stack local variables 
subsequently old frame pointer register restored frame pointer register popping saved frame pointer stack 
function return popping return address instruction pointer register 
example attackers changed saved frame pointer point value control frame pointer stackframe 
function returns new saved frame pointer stored register points attacker controlled memory 
frame pointer register free stack function epilogue program read attacker specified saved frame pointer transfer control attacker return address returning 
indirect pointer overwriting attackers reason overwrite return address frame pointer directly overflow countermeasures prevent different technique illustrated called indirect pointer overwriting allow gain control execution flow 
code call 
data value value stack return address saved frame pointer local variables arguments return address saved frame pointer pointer data injected code higher addresses buffer lower addresses stack buffer overflow indirect pointer overwriting stackframe local stackframe variables overflow overwrite local variable holding pointer value 
pointer changed point return address pointing value 
pointer dereferenced value points changed point function attacker specified value change return address value choosing 
example illustrate technique overwriting return address indirect pointer overwriting overwrite arbitrary memory locations pointer code executed interesting attacker overwrite 
countermeasures solutions stack buffer overflows section contains short summary countermeasures stack buffer overflows 
described thoroughly section 
safe languages described document offer solutions buffer overflow problem combining static checks run time checking 
statically attempt decide array indexes pointer arithmetic operations safe 
force programmer modify code compiler prove safe add run time bounds checks ensure safety operations 
control hand provides array safety restricting operations performed arrays pointers statically ensuring restrictions 
static analyzers try detect possible buffer overflows development time analyzing code application operation buffer pointer considered safe reported place need extra verification programmer ensure performed operations safe 
analyzers require assistance annotation analyzing program try derive assumptions programmer 
dynamic analyzers instrument application checks run time information attempt find buffer overflows program run testing phases 
added information run time verify specific array indexation pointer operation write past array 
attempt limit amount damage attackers able exploit buffer overflow vulnerability able inject execute code 
enforce policy system calls application allowed execute making sure application execute system calls normally need 
attempt file accesses changing program root directory mirroring files directory structure program access 
anomaly detectors similar approach terminating program unusual system call performed attempt detect intrusions technique recording attempt 
bounds checking compilers best protection buffer overflows check array indexation pointer arithmetic ensure attempt write read location outside space allocated 
compiler patches try protect important information stack return address overwriting 
generally saving return address heap placing value stack return address verifying returning function 
encrypt pointers unusable stored memory decrypted operation 
hardware operating system modifications try protect buffer overflows mark stack data segments non executable prevent attacker executing injected code techniques compiler patches saving return address different location address returning function 
hardware modifications try injecting code hard encrypting instruction set making hard attacker guess correct machine code representation instruction injecting code 
memory randomizing countermeasures take advantage fact attackers know exactly code injected able change return address point injected code 
randomizing address stack starts randomizing parts memory start countermeasures harder attackers guess location injected code 
libraries offer kind memory randomization operating system modifications 
libraries attempt verify integrity stack frames performing string manipulations 
heap buffer overflows vulnerability heap memory dynamically allocated run time application 
case stack arrays arrays heap implementations 
technique overflowing heap grows upwards memory downwards 
return addresses stored heap attacker techniques gain control execution flow 
exploitation basic exploitation way exploiting buffer overflow located heap overwriting heap stored function pointers located buffer 
function pointers available ways exploiting heap overflows overwriting heap allocated object virtual function pointer pointing attacker generated virtual function table 
application attempts execute virtual methods execute code attacker controlled pointer refers 
dynamic memory allocators function pointers virtual function pointers available attacker encounters heap buffer overflow 
overwriting memory management information generally associated dynamically allocated block general way attempting exploit heap overflow 
countermeasures examining specific implementation dynamic memory allocator called 
describe allocator short describe attacker manipulate application overwriting arbitrary memory locations overwriting allocator memory management information 
library run time memory allocator divides heap memory disposal contiguous chunks change size various allocation free routines called 
invariant free chunk borders free chunk routines completed free chunks bordered coalesced larger free chunk 
free chunks kept doubly linked list free chunks sorted size 
memory allocator time requests chunk size free chunks chunk list removed list available program turn allocated chunk 
chunk lower addresses chunk size previous chunk size previous chunk chunk size chunk user data size chunk size chunk forward pointer backward pointer old user data higher addresses chunk heap containing free chunks size chunk forward pointer backward pointer old user data size previous chunk size chunk forward pointer backward pointer old user data memory management information including list free chunks stored band information stored chunks chunk freed memory normally allocated data store forward backward pointer 
illustrates heap unused chunks look 
chunk allocated chunk containing information size chunk stored size rest chunk available program write data 
chunk shows free chunk located doubly linked list chunk chunk 
chunk chunk chain backward pointer points chunk forward pointer points previous chunk list 
chunk chunk size allocated chunks multiple significant bits size field management information bit indicate previous chunk indicate memory mapped 
bit currently unused 
previous chunk bit modified attacker force coalescing chunks 
coalescing abused explained 
representation chunk entirely correct chunk store user data chunk size chunk 
elected represent way detail entirely relevant discussion 
forward pointer pointing chunk backward pointer pointing chunk 
chunk chunk example backward pointer points chunk list forward pointer points chunk 
chunk lower addresses chunk size previous chunk size previous chunk chunk size chunk code jump dummy dummy injected code size chunk size chunk forward pointer backward pointer old user data user data higher addresses stack return address saved frame pointer local variable local variable heap buffer overflow chunk higher addresses lower addresses size chunk forward pointer backward pointer old user data size previous chunk size chunk forward pointer backward pointer old user data shows happen array located chunk attacker overwritten management information chunk 
size fields left unchanged case modified needed 
forward pointer changed point bytes return address backward pointer changed point code jump bytes 
chunk subsequently freed coalesced chunk larger chunk 
chunk longer separate chunk coalescing removed list free chunks 
unlink macro takes care internally free chunk represented struct containing unsigned long integer fields order prev size size fd bk 
chunk unlinked follows chunk fd bk chunk bk chunk bk fd chunk fd struct chunk fd chunk bk chunk bk chunk fd value memory location located bytes location fd points overwritten value bk 
value memory location bytes location bk points overwritten value fd 
example return address overwritten pointer code jump place fd stored execute code attacker injected 
indirect pointer overwrite technique overwrite arbitrary memory locations 
countermeasures solutions heap buffer overflows techniques safe languages protect program buffer overflows protect heap buffer overflows 
true static analysis dynamic analysis sandboxing bounds checking compilers 
compiler modifications discussed encrypting pointers protect heap buffer overflows pointers encrypted meaning attacker reliably overwrite code pointer 
operating system hardware modifications offer encryption instruction sets randomization memory areas offer protection kind overflow harder attacker execute injected code 
library modifications main place countermeasures try protect exploitation allocated 
mainly dynamic memory allocator implemented library calls easily intercepted 
countermeasures offer similar solution compiler patches protect return addresses place value specific chunk verify exiting string memory copying function 
robertson protect chunks adding checksum value header sure memory management information left unchanged 
freeing chunk checksum verified 
types library modifications protect heap buffer overflows described 
dangling pointer vulnerability pointer memory location refer memory location deallocated explicitly programmer calling free code generated compiler function epilogue stackframe function removed stack 
dereferencing pointer generally unchecked compiler causing dangling pointer problem 
normal cases cause program crash exhibit uncontrolled behavior value changed place program 
double free vulnerabilities specific version dangling pointer problem lead exploitation 
double free vulnerability occurs freed memory deallocated second time 
allow attacker overwrite arbitrary memory locations 
chunk lower addresses chunk chunk size previous chunk size previous chunk size previous chunk size chunk forward pointer backward pointer old user data higher addresses size chunk forward pointer backward pointer old user data list free chunks size chunk forward pointer backward pointer old user data example list free chunks memory look memory allocator 
chunk bigger chunk chunk meaning chunk chunk list free chunks size 
new chunk size chunk freed placed list chunks size modifying backward pointer chunk forward pointer chunk 
chunk freed twice overwrite forward backward pointers allow attacker overwrite arbitrary memory locations point program 
exploitation mentioned previous section chunk chunk size chunk freed placed chunk list 
code snippet bk fd bk fd chunk bk bk chunk fd fd fd bk bk fd chunk backward pointer chunk set point chunk forward pointer backward pointer chunk fd chunk set forward pointer chunk 
backward pointer forward pointer chunk bk set chunk forward pointer backward pointer chunk fd set chunk 
illustrates chunk shown due space restraints 
chunk lower addresses chunk chunk size previous chunk size previous chunk size previous chunk size chunk forward pointer backward pointer old user data higher addresses size chunk forward pointer backward pointer old user data chunk added list free chunks chunk shown size chunk forward pointer backward pointer old user data chunk freed twice happen substitutions code listed bk chunk fd chunk fd chunk bk chunk chunk fd chunk fd chunk fd bk chunk fd chunk chunk lower addresses chunk chunk size previous chunk size previous chunk size previous chunk size chunk forward pointer backward pointer old user data higher addresses size chunk forward pointer backward pointer old user data list free chunks chunk freed twice size chunk forward pointer backward pointer old user data forward backward pointers chunk point 
illustrates list free chunks looks second free chunk 
program subsequently requests chunk size chunk chunk unlinked list free chunks chunk fd bk chunk bk chunk bk fd chunk fd chunk lower addresses chunk chunk size previous chunk size previous chunk size previous chunk size chunk forward pointer backward pointer old user data higher addresses size chunk forward pointer backward pointer old user data chunk reallocated chunk size chunk forward pointer backward pointer old user data chunk fd chunk bk point chunk point really unlinked 
allocator assumes program free user data part chunk 
illustrates program write 
attackers technique section exploit heap overflow set forward pointer point bytes return address change value backward pointer point code jump bytes overwritten 
program tries allocate chunk size try unlink chunk overwrite return address value chunk backward pointer 
countermeasures solutions dangling pointer safe languages attempt eliminate dangling pointer removing explicit control memory allocations 
safe languages free operation longer exists 
able deallocate memory longer region memory management garbage collection 
effectively prevents dangling pointer 
bounds checking compilers protect dangling pointer recording extra temporal state pointers denoting active 
pointer freed pointer marked deallocated dereferencing generate error 
sandboxing encryption randomization non executable memory countermeasures offer protection kind vulnerabilities harder attacker execute injected code 
chunk lower addresses chunk chunk size previous chunk size previous chunk size previous chunk size chunk forward pointer backward pointer old user data higher addresses higher addresses lower addresses size chunk forward pointer backward pointer code jump dummy dummy injected code stack return address saved frame pointer local variable local variable user data overwriting return address double free size chunk forward pointer backward pointer old user data invalid dangling pointer detected static dynamic analyzers 
format string vulnerabilities vulnerability format functions functions variable amount arguments expect format string argument 
format string specify format function format output 
format string character string literally copied output stream character encountered 
character followed format specifiers manipulate way output generated 
format specifier requires argument format function expects find argument stack consider call printf printf expects find integer second argument printf call stack read memory location output screen 
format string vulnerability occurs attacker able specify format string format function printf user supplied string 
attacker able control function pops stack program write arbitrary memory locations 
exploitation format specifier particularly interesting attackers specifier write amount characters formatted far pointer provided argument format function 
attackers able specify format string format specifiers print hex value integer pop words stack reach pointer value wish overwrite 
value overwritten crafting special format string specifiers 
addresses usually large numbers especially attacker trying execute code stack specifying large string probably possible 
get number things done firstly format functions accept minimum field width specifiers reading format specifiers amount bytes specified minimum field width taken account specifier printf print digit hexadecimal number decimal value printed 
field width specifier easier specify large format string number attackers required generate large effectively 
circumvent limitation write value times overwriting return address small value normal integers ia overwrite bytes overwriting return address byte integer return address bytes return address bytes 
attacker faces problem amount characters formatted far reset specifier written address attackers want write contains number smaller current value specifier cause problems 
attackers writing byte time byte value write larger values significant byte attackers want write value just write 
illustrates attacker write address technique 
overwriting addr overwriting addr overwriting addr overwriting addr overwriting value byte time specifiers countermeasures solutions format string vulnerabilities safe languages try prevent format string vulnerabilities allowing format function determine type arguments comparing type argument function type argument format specifier expects 
static analyzers try detect format string vulnerabilities checking format string argument format function literal string doing taint analysis 
taint analysis marks user input tainted report error variable expected untainted derived tainted value 
library wrappers format functions exist try prevent exploitation format string vulnerabilities 
attempts detect invalid format strings counting arguments format specifier expects stack comparing amount arguments really passed arguments passed expected error occurred 
checks format string supplied format function contain specifiers string located writable memory 
integer errors integer errors exploitable vulnerabilities exploitation errors lead situation program vulnerable previously described vulnerabilities 
kinds integer errors lead exploitable vulnerabilities exist integer overflows integer errors 
integer overflow occurs integer grows larger value hold 
iso standard mandates unsigned integers overflow modulo maxint performed new value stored 
cause program expect fail vulnerable conjunction memory allocation little memory allocated causing possible heap overflow 
integer overflows don usually lead exploitable condition 
integer errors hand subtle programmer defines integer assumed signed integer explicitly declared unsigned 
programmer passes integer argument function expecting unsigned value implicit cast occur 
lead situation negative argument passes maximum size test large unsigned value possibly causing buffer heap overflow conjunction copy operation memcpy expects unsigned integer size argument passed negative signed integer assume large unsigned value 
countermeasures solutions integer errors integer errors exploitable lead state buffer overflow possible countermeasures solutions buffer overflows applied implicitly protect integer errors 
static analysis tools attempt detect integer errors taint analysis variable derived user input array index possible error reported 
memcpy standard library function copy memory location solutions countermeasures section examines details solutions countermeasures proposed combat broad range vulnerabilities described previous section 
purpose document define solution complete solution problem ways bypassing 
countermeasure defined attempt harder exploit vulnerability 
divided different solutions countermeasures categories depending attempt solve problem try thwart attacker 
safe language solutions safe languages languages generally possible previously mentioned vulnerabilities exist language constructs prevent occurring 
number safe languages available prevent kinds implementation vulnerabilities discussed text entirely 
examples languages include java ml scope discussion document focuses 
discuss safe languages remain close possible safe languages referred safe dialects general techniques employed safe dialects shortly described specific implementations described 
attempt prevent dangling pointer memory management handled differently safe languages programmer explicit control deallocation anymore free operation replaced operation removed altogether 
languages described types memory management prevent dangling pointer region memory management deallocates regions memory locations longer deallocated separately 
pointer memory location dereferenced region memory address marked live 
garbage collection deallocate memory instantaneously defers scheduled time interval till memory constraints require collected 
garbage collection done memory exist anymore deallocated preventing pointers referring deallocated memory 
prevent implementation errors described section techniques usually combined firstly static analysis see section description performed determine specific construct proven safe 
construct prove safe generally run time checks added prevent errors run time specific array statically determined safe code run time bounds checking added 
jim 
cyclone cyclone designed prevent implementation errors described document :10.1.1.127.7825
static analysis source code insert dynamic checks places determine safe 
compiler unable determine program safe inserting run time checks refuse compile 
cases safe program rejected annotations provide information required allow static analyzer correctly verify safety 
way pointers treated changed pointer dereferenced null check performed prevent programs attempting null pointer cause segmentation violation 
type checks slow program new type pointer introduced null pointer indicated guaranteed contain null value null checks avoided 
prevent buffer overflows pointer arithmetic normal null pointers prohibited 
accommodate pointer arithmetic new kind pointer introduced indicated 
pointer contains extra bounds information allows cyclone insert bound checks relevant points program 
uninitialized pointers prevented performing static analysis determine pointer initialized 
dereferencing dangling pointers prevented region memory management :10.1.1.10.8871
types memory regions cyclone heap consists large region lives forever 
free operation defined support freeing heap allocated objects 
stack regions lifetime stackframe region created contains function arguments return address local variables 
returning function region deallocated entirely 
dynamic regions regions objects allocated independent heap stack 
objects region deallocated region deallocated 
longer freed individually 
format string vulnerabilities prevented tagged unions allow function determine type arguments 
format string functions compare format specifier type argument abort inconsistency detected 
specifying tagged unions format string function argument inconvenient programmers cyclone performs automatic tag injection sure compiler inserts correct tag argument compile time 
specific format string functions implemented check consistency tags format specifiers 
necula 
ccured ccured uses static analysis source code supposed protect just cyclone adds run time safety checks places statically determine safe :10.1.1.152.1345
main difference cyclone lies way pointers handled memory managed 
cyclone allows programmer control type pointers specific place ccured 
ccured safer pointers programmer control type pointer situation static analysis decide type pointer 
pointer safe casts arithmetic operations performed checking done types pointers null pointer check 
pointer marked sequenced arithmetic operations performed null pointer bounds checking done run time 
dynamic pointers pointers type determined statically 
dynamic pointers require extensive checking ensure correct null pointer checks bounds checking run time tag manipulation required 
main advantage ccured approach pointer usage compared cyclone legacy code written modified extensively able compile ccured 
prevent dangling pointer ccured uses garbage collector manage memory 
explicit deallocation memory ignored conservative garbage collector reclaim memory 
original ccured compatibility problems existing code solutions described avoid treating downcasts bad ccured uses physical subtyping determine valid object physical subtype concatenation equal allow downcasts new type pointer called run time type information pointer introduced 
run time type information determine downcast valid downcast physical subtype furthermore provide compatibility code compiled ccured compatible way representing arrays pointers introduced objects need passed non ccured compiled code metadata kept object ccured separated object stored similar structure object passed back forth unprotected code minimal effort 
deline hndrich vault vault cyclone uses region memory management 
different way implementing memory management mechanism 
vault allows programmer describe resource management protocols enforced statically compiler 
offering extension normal type system type type guard determines access object permitted 
guarded object key held key set global set keys currently available held object accessed 
function types pre postconditions denoting keys held function called keys set function returns 
vault implements region memory management keys region created key region held objects region type guarded key 
region subsequently deleted key removed held key set access object region cause compiler return error 
vault differs areas safe language variables initialized programmer specified default value preventing uninitialized values 
normal pointers contain null value point valid memory location 
allow programmer express pointers contain null values pointers provided 
type safety provided prohibiting arbitrary type casts type casts values types allowed byte char short int long long long string separate type vault opposed char 
adve lattner control aim approach taken control ensure memory safety untrusted programs run time checks annotations garbage collection 
tries statically guarantee memory safety achieve subset language supported specific assumptions system 
specifically designed real time control systems runs low level virtual machine llvm system memory register operations type safe 
efficiently assumptions run time system certain run time errors considered safe system kill untrusted code generating error 
stack heap grow available space safe run time error generated 
existence reserved address range access generates safe run time error 
certain standard library functions system calls assumed safe 
restrictions type safety variables assignments expressions strongly typed 
pointers may cast types 
unions may contain types cast 
compiler easily check type safety llvm system explicit cast instructions break type safety checked compiler 
pointer safety local pointers initialized dereferenced 
detect uninitialized local pointers data flow analysis 
easy global pointers pointers dynamically allocated structures 
ensure initialized run time code added initialize 
data type smaller size reserved address range 
follows second run time system assumption 
address stack location stored heap allocated object global variable returned function 
enforced doing data structure analysis directed graph memory objects function constructed location information point 
graph contains information function parameters return values reachable objects passed callers returned callees 
traversing graph possible determine stack allocated variable reachable pointed 
array safety value index array access lie inside bounds array 
dynamically allocated arrays positive size 
array accessed inside loop bounds loop affine transformation array size loop index variables 
index array access affine transformation loop index variables size array 
index value depends symbolic variable memory accessed independent variable 
array access outside loop index value affine transformation size array 
restriction ensures array safety follows conformance program subsequent restrictions 
dangling pointer problems prevented regionbased memory management 
explicit deallocation memory allowed reintroduce problem 
dangling problem violate type safety 
prevent variables type placed region contains variables homogeneous type 
implement algorithm called automated pool allocation different pool allocated type variable type allocated 
static analyzers static analyzers generally implementation audit phases application compilers decide specific run time check necessary seen previous section 
offer protection able point code vulnerable 
operate examining source code particular application 
simple just searching code specific known vulnerable functions strcpy gets 
complicated building complete model running application 
determining statically possible input program program contain overflow undecidable problem trivial reduce problem halting problem 
analyzers contain number false positives amount correct code incorrectly reported vulnerable false negatives vulnerable code reported 
main criteria determining effectiveness source code analyzer false positive false negative ratio scale larger real world software systems 
important difference sound unsound static analyzers sound analyzers find possible overflows usually expense generating false positives scalable unsound analyzers try find right balance false positives false negatives able analyze larger systems 
purposes divide analyzers groups annotated place analysis burden programmers forcing explicitly document assumptions non annotated try infer programmer implied source code 
annotated source code analyzers annotated source code analyzers expect programmer help analyzer determining assumptions specific code making 
programmer expect specific pointer equal null annotate 
source code analyzer attempt certify pointer null point code 
annotations life analyzer considerably easier guesswork programmer intended rely programmer tell expecting focus attempting assert expectations 
advantage technique allows analyzers quickly easily search source code specific places assumptions met 
evans splint splint 
lightweight static analysis tool analyzes program source code annotations describe assumptions specific objects specific value lifetime 
pre postconditions met specific function 
providing built annotations specific vulnerable functions strcpy requires size destination larger amount data read source splint minimum effort programmer verify source code commonly encountered implementation errors ones described section document 
format string vulnerabilities detected taint analysis 
user input considered tainted error reported tainted variable untainted expected 
definitions format functions changed expect untainted format strings arguments 
dor rodeh sagiv cssv cssv static source code analyzer designed detect buffer overflows report errors expense reporting false positives 
cssv expects programmer provide contract describes preconditions postconditions side effects function 
derive contracts 
analysis performed inlining contracts means asserts translating source code semantics preserving subset language simplified version possible programs transformed changing semantics 
allows simpler static analyzers source source translators subset language supported complete language 
translation pointer analysis performed detect pointers point base address 
results transform program integer program integer analysis performed 
analysis indicate inequalities variables guaranteed hold control point 
analysis asserts added inlining contracts verified 
assert fails existence possible error announced 
number false positives cssv return depends accurately contracts defined 
shankar talwar foster wagner extended extensible type qualifier framework 
authors extend tool find format vulnerabilities user controlled data marked tainted variables assigned value derived tainted data 
tainted data argument format string error raised 
tainting statically modeled extending type system new type qualifiers const volatile tainted untainted added 
easily backwards compatible tool comes default annotations library functions 
relieve programmer burden having specify type tainted untainted variable type inference default return value calls functions gets tainted variable derived variables marked tainted 
variables untainted expected error display reported allow programmer find error occurred 
technique find format string vulnerabilities format functions defined expect untainted variables format string specifiers 
example function printf const char format 
defined printf const untainted char format 
engler engler suggest allowing programmers write compiler extensions specify source code adhere specific rules 
compiler statically checks source code adheres restrictions 
belief inference attempt find faults checker guess programmer believed particular point code value read untrusted source sanitized programmer believes sensitive checker find call assumes check missed possibly dangerous operation reports 
demonstrate technique example specifications search integers untrusted sources tainted variables checks linux bsd kernels 
tainted integers cause integer errors array bounds violations indices arrays lead vulnerabilities exploited attacker 
non annotated source code analyzers kind source code analyzers require annotation specific assumptions programmer try determine code safe 
generally attempt assert code safe building model execution environment step code sort interpreter reducing program simpler system function buffers set constraints integer ranges 
possible execution paths normally able certify specific assumption holds 
example program dereferences pointer doing null check able certify pointer null point code code safe analyzer take predetermined action notifying programmer specific problematic code 
bush pincus prefix prefix wishes offer kind functionality purify describe section need run time execution program examined 
static source code analyzer meaning requires access underlying source code purify requires access object code 
prefix builds execution model examined source code sequential trace achievable execution paths actions simulated virtual machine 
results simulating execution paths build model function 
bottom traversal call graph performed starting leaf functions model function generate set constraints callers function 
means values unknown time function examined modeled 
prevent analyzer returning large amount false positives tests delayed constraint added model function tested model called 
approach full memory model possible execution flows entire program built possible inconsistencies expected actual values detected minimizing amount false positives reported 
pincus adaptation prefix designed speed 
prefix take long time analyze program developers want check code errors developing running prefix mature program exists 
prefix complementary tools run regularly development find simpler errors prefix scheduled run specific intervals perform complete analysis 
speed important objective developing lightweight analysis tool performs local analysis 
parses function code searches code cause errors 
xie chou engler archer archer designed look memory access errors 
transforms code intermediate representation side effects eliminated introducing temporary variables nested function calls flattened operators converted statements 
control flow graph approximation call graph built 
call graph analyzed bottom function analyzed possible errors 
traversal module archer explore function control flow graph perform actions condition encountered expression evaluated evaluation determined statically non reachable control paths eliminated memory access performed attempt determine access unsafe error returned statements statement converted set constraints update state 
archer interprocedural analysis actual parameters function known place function called set constraints kept parameters function 
function called parameters compared constraints needed error reported 
major limitation archer operates arrays pointers programs understand string operations 
memory size determined checked 
simon king simon king build done dor aims improve shortcomings possible changes buffer tracked definite changes rand string null different position character pointer actual value determined runtime 
remedy possible values tracked definite values 
perform analysis program reduced representation called string performs operations buffers 
pointer buffer represented triplet buffer starting point current position buffer buffer bounds 
valid accesses hold start current bounds 
information buffer expressed function triplet size buffer bounds start position zero buffer kept offset start buffer 
simplify analysis zero tracked opposed zero lead false positives 
wagner foster brewer aiken boon wagner propose unsound static analysis technique detecting buffer overflows 
model strings integer ranges string represented integers number bytes allocated string number bytes currently 
constraint language ranges defined specific string operations modeled language constraints hold specified 
program subsequently parsed system integer range constraints generated statement input program 
string represented variables string operations modeled regard values safe state len alloc 
simplify analysis authors decided flow insensitive analysis control flow ignored generating constraints brings problems functions strcat executed loop state relies previous execution 
alleviate problem call strcat flagged possible vulnerability generate false positives 
current technique limitations analyzing pointer operations handle pointer aliasing correctly ignores function pointers doubly indirected pointers unions 
generation constraints constraint system solved finding minimal bounding box solution encloses possible execution paths 
places constraints hold reported possible overflows 
rinard rinard describe static analysis framework designed detection errors parallelized programs 
focus data races array bounds violations bitwidth analysis allowing problem bits required 
pointer read write set analysis performed program determine memory regions accessed instruction procedure 
intraprocedural bounds analysis derive bounds information pointers array indexes point program 
initially upper lower bounds generated variables start procedure new bounds generated symbolically executing instructions generating bounds program point 
bounds build constraint system upper lower bounds 
constraint system solved linear programming arrive polynomial lower upper bounds bounds expressed terms values results previous program steps 
intraprocedural region analysis performed determine memory regions accessed directly reading writing function 
interprocedural region analysis determine regions accessed entire execution function including effects calls functions 
information gathered phase allows compiler determine program contain buffer overruns 
describe static analysis technique character buffer modeled numbers denoting maximum minimum amount bytes allocated maximum minimum amount bytes 
subsequently flow context insensitive analysis done generate constraints program terms variables 
specific string manipulation functions modeled terms constraints model effect call 
linear programming operate finite values constraint variables assume infinite value derived user input example removed taint analysis 
subsequently constraint system solved linear programming best constraints range range 
values determined solving constraint system values gathered taint analysis determine possible overflow result point bytes allocated string 
bloch mcgraw simple static analyzer attempts find unsafe code 
main idea design scanner lightweight feasible implement editor extension syntax highlighting 
static analyzers parse source code analysis limits doing lexical analysis matches code vulnerability database contains list unsafe functions functions misused cases potential risk factor description printed possible vulnerability encountered 
identified possibly vulnerable functions examine determine reported level severity 
example strcpy dst reported potential vulnerability source string fixed consequently potential risk factor extremely low 
wheeler similar 
examines code lexical level report known vulnerable functions back programmer possible security vulnerability 
prioritize output function potential risk poses 
secure software rats rats similar examine perl php python code code 
just previous countermeasures search vulnerable functions report risk factor 
dynamic analysis testing dynamic analyzers different approach analyzing programs trying determine presence vulnerabilities source code level generally instrument program output extra information run time 
possible vulnerability instrumented run reported back tester 
allows exact checking done statically errors execution paths executed testing 
bishop tool dynamically detect possible buffer overflows programs 
instruments source program creates version run behavior original program outputs information possible overflows 
generate different types warnings possible buffer overflow vulnerabilities situations 
source destination statically allocated called type 

source dynamically allocated destination statically allocated type 

destination dynamically allocated type 
course generate type warnings memory allocated destination possibly smaller source adequate size checking performed copying buffer 
size information available run time authors chose implement checking dynamically 
instrumentation keeps track static buffers sizes adding functions record existence right declaration source 
keep track dynamically allocated buffers calls memory allocation freeing functions replaced wrapper functions 
checking done dynamically problems generating high false positives false negatives static analyzers suffer eliminated 
hastings joyce purify purify software testing tool designed detect memory leaks access errors focus security security vulnerabilities examine document result memory access errors 
purify designed software debugger detects memory errors dynamically opposed detecting statically 
accomplish instruments program object code inserts function call checks memory access load store instruction 
function checks updates memory state table bit state code kept byte allocated heap stack data bss sections 
bits associate states byte memory unallocated unreadable allocated uninitialized writable unreadable allocated initialized writable readable 
write done uninitialized memory marked initialized 
write attempted unallocated memory diagnostic message generated 
detect heap array overflows small areas marked unallocated placed chunk returned malloc 
bytes read written memory access error occur tester notified 
larson austin muse extension larson austin suggest dynamic analysis technique source code instrumented detect invalid array accesses 
testing solutions rely current value entered data keep range possible values input variables possible error occur actual input value cause error generated 
example unsigned integer user variable array index program start range maxint 
value checked condition range modified reflect impact check result range 
narrowing depend value supplied user range compared array size index 
determine integer type variables input related integers types valid array index types form tainting described examination extended employed 
input variables assigned range possible values contain 
strings information size fact known contain null recorded occurs room left null byte known null state false 
particular null terminating operation manually setting null byte string occurs known null flag set true 
faults detected techniques possibly negative values memory copy allocation operations generate alerts 
integer overflows underflows detected checking result stored destination variable 
ghosh connor mcgraw fist fist attempts discover vulnerabilities software fault injection 
anomalous events injected execution program response events determined violation security policy occurred 
fist inject wide number errors changing boolean values exploiting buffer overflows 
program allows programmer monitor causes violation 
interesting injected faults document ability generate stack buffer overflow attack overwrite return address function attempt execute code causes event caught fist monitoring component 
major drawback order buffer overflow analysis fist programmer manually select buffers instrumented 
alleviate potential burden cause testers authors propose automatic way detecting buffers test 
source code parsed examined places vulnerable attacks instrumented accordingly 
fink bishop property testing property testing methodology test specific property holds program program validation 
properties test specified formally check properties hold test execution 
tests consist set executions program different input data time determine program functions correctly 
test fails property hold unwanted side effect generated 
program sliced code affecting property tested extracted data flow graph produced 
program instrumented keep track specific part code called result 
tests generated automatically human tester 
test executions coverage correctness evaluated specific parts tested executed coverage incomplete tests performed 
property violation recorded test reported error 
sandboxing sandboxing principle privilege application privileges needs able complete task 
enforced number ways policy enforcement clear policy defined way specifying application specifically 
fault isolation ensures program part program fails cause entire system malfunction 
common application fault isolation load isolated code address space 
kinds countermeasures attempt limit amount damage system component module introduced application application attacker able gain control 
fault isolation fault isolation ensures certain parts software cause complete system program collection programs operating system 
fail 
common way providing fault isolation address space separation cause expensive context switches occur incur significant overhead execution 
modules different address spaces communication modules incur higher overhead 
suggestions doing fault isolation examined 
completely protect program code injection proposed techniques useful applied limitation injected code mind run time monitoring opposed transforming source object code 
wahbe lucco anderson graham software enforced fault isolation concept software fault isolation sfi introduced wahbe 
techniques provided allow fault isolation need separate address space 
avoids need context switches allows expensive communication modules cost increased execution time 
wahbe isolation straightforward manner application address space divided segments addresses segment unique significant bit pattern 
enforce isolation techniques proposed segment matching address sandboxing 
segment matching adds check jump write instruction accesses address verified statically indirect addressing correct segment referred unsafe instruction 
check compares segment identifiers module instruction parameter cause exception fail match 
allows programmer find unsafe memory access occurred 
address sandboxing things little differently inserting check unsafe instruction unsafe instruction address parameter set current module segment identifier significant bits set segment identifier significant bits 
reduces execution time overhead associated enforcing sfi 
allow writable memory sharing read instructions modified fault domains technique called lazy pointer swizzling proposed hardware page tables modified map shared memory address space segment requires access shared region mapped offset segment 
techniques proposed implementation harder attacker exploit vulnerabilities described earlier options memory addresses overwrite limited address modification instructions checked modified run time 
probably able buffer overflow adjacent memory space contains return address overwritten 
attackers able inject code able gain complete control software system injected code contain fault isolation enforcement 
possible techniques possible countermeasure enforcing isolation run time monitoring execution replacing instructions checked isolated ones 
small misfit misfit extension sfi techniques described wahbe 
instructions limit read write memory regions module allowed respectively read write 
extra constraint added prevent code modifying write instructions argument points code segment 
prevent code jumping non entry point code sections data sections table valid functions provided module indirect function calls jump code entry points 
global data accessed function calls module requires access global data call permission table valid functions 
stack presents problem programs completely isolated falls outside memory region contains information return addresses changed module 
full control stack fault isolated module 
misfit solves part stack problem assigning module stack 
prevent overwriting return address call instruction replaced jump code saves return address stack outside module control space 
return instruction replaced jump code retrieves saved return address jumps 
policy enforcement compared fault isolation policy enforcement techniques things little differently specific policy program written subsequently enforced 
generally enforcement done monitor application access specific resource term resource broadest sense system call file hardware device 
regulated 
schneider sasi sasi merges enforcement policies object code application code check security policy adhered added application object code 
security policies defined security automata 
input alphabet defined events monitored read push ret 
translation relations describe actual policy events rejected automaton denied run time 
sasi merges policies applications phases automata inserted target instruction transition evaluated instruction follows irrelevant translations deleted automaton automata compiled code simulates automata 
sasi merges policy existing application code extra checks needed ensure application modify variables part security automata circumvent automaton simulation code altogether modify code 
checks implemented verifying object code ascertain possible modifying object code prevent 
checks added object code possible attacker aforementioned vulnerabilities circumvent protections added sasi 
run time solution appropriate current context 
schneider schneider examines policy enforcement mechanism execution system monitored modifying original program examining source code potential violation predefined policy recorded execution terminated 
execution monitors encompass broad range possible systems kernels firewalls monitors 
interest related application techniques programs attacked previously described vulnerabilities 
execution monitors able decide program violates security policy individual executions 
set individual executions called safety property 
schneider points execution monitoring enforce security policies safety properties 
defines formalism defining security policies security automata way sasi 
kind enforcement primarily focused execution untrusted code useful preventing attackers injecting code violate security policy defined program 
evans system architecture allows safety policies defined applications 
policies limit impact vulnerabilities described earlier software may constrained executing code allowed security policy 
enforcement security policy achieved implementing wrappers relevant system calls linking wrapped versions load run time 
prevent protected programs circumventing policy limited software fault isolation employed ensure application perform direct jumps unchecked system calls 
policy enforcement injected code wrapped system calls checked run time injected code probably unwrapped ones 
prevent buffer overflows generally system calls needed overflow buffer 
ideas easily incorporated defense intercepting calls run time wrapping modifying actual system calls directly 
goldberg wagner thomas brewer janus janus mechanism monitors untrusted applications disallows system calls application permitted execute 
janus framework read modules loaded configuration file 
modules decide system call execution wishes approve deny system calls wish comment 
subsequent modules configuration file reverse earlier decisions approving denying system calls original module specified decision final 
decision allow specific system call arguments system call call open harmless request open file application allowed access request open sensitive file hard disk 
framework allows administrator developer implement security policy application deployment time prevent attacker able inject arbitrary code application executing system calls application normally need execute 
janus framework starts reading configuration file building list system calls system calls read write allowed performance reasons associated values called dispatch table 
dispatch table run time application executed arrives system call dispatch table examined decision allow deny system call case denial reported back process 
systrace programs family unix operating systems require privileges user executing 
called privileged programs generally executed full privileges owner program 
lack granularity available brings major security problem programs require administrator privilege execute specific system call execute calls privileges 
cause problems attacker able inject foreign code application forces program execute vulnerabilities described section 
systrace introduces way eliminating need give program full administrator privileges allowing finer grained privileges application system calls executed arguments functionality offered janus 
defining policy system calls program able execute complex systrace offers training ability allowing user run program systrace learns system calls executed 
allows systrace generate base policy refined 
possible systrace interactively generate system policies user policy decision attempt execute system call described current policy performed 
tool unix operating systems implements file system sandbox applications 
runs modes passive gathers information files application opens adds files access list 
active file accesses files list allowed 
file access different file return non existent file error 
impractical active tool file list generated passive mode create environment 
means files application accesses copied directory path original files passwd sandbox passwd root directory application set directory 
prevent application reading files outside sandboxed directory 
active mode brings problems care taken running application passive mode extensively possible file accesses performed phase 
problem occurs application creates random temporary files change run hard specify access list 
directories marked non checked allowing application read write files directory discretion 
amarasinghe program shepherding program shepherding technique monitor execution program disallow control flow transfers considered safe 
program shepherding example ensure programs jump entry points functions libraries denying attacker possibility bypassing checks performed certain action taken function 
example program shepherding enforce return instructions return instruction call site 
program shepherding uses runtime binary interpreter monitor program control flow transfers 
shepherding techniques implemented addition rio run time dynamic optimizer runs code interpreter 
reduce overhead interpretation code executed cached native form 
authors program shepherding technique reduce overhead techniques 
checks performed code allowed pass placed cache checked anymore dates 
techniques implement program shepherding execution code dependent origin unmodified code loaded disk considered trusted code dynamically generated code modified loaded disk 
depending origins certain actions allowed denied 
control transfer restricted important ensure attackers bypass checks jumping directly code wish see executed executing sanity checks function wish perform executes code 
control transfers denied criteria 
sandbox implemented control transfer restrictions possible implement sandbox circumvented jumping past checks 
sandbox restrict operations particular piece code perform 
code adhere specific policy checks inserted code 
protect run time environment rio calls system calls modify memory protection prevented changing memory privileges pages contain rio code data 
anomaly detection techniques sandboxing anomaly detection 
cases execution system calls monitored correspond previously gathered pattern anomaly recorded 
threshold anomalies reached anomaly reported subsequent action taken program terminated system call denied 
forrest hofmeyr somayaji longstaff forrest define method anomaly detection short sequences system calls 
sliding window record system calls training period window sequence system calls specific size recorded 
window trace system calls application performs 
program deviates sequences calls subsequent runs anomaly detected 
smaller size window options attacker forming valid sequences system calls able execute useful code 
sequences exist actual program recorded anomaly short sequence calls technique 
programs different system calls orders cause problem 
allowable sequences large attacker really restricted anymore 
sekar sekar suggest finite state automata model system call sequences 
build automaton training period models sequence system calls performed program execution 
advantage automaton control flow structures loops branches captured model allowing automaton accurate decisions validity system calls 
main problem building automata modeling deciding specific system calls lead building inefficient automata 
able detect calls automaton needs contain information current program state just system call system call added automaton location program system call called recorded 
allows program decide calls system call call 
automaton built anomaly detection subsequent runs program 
runtime execution system calls intercepted location call looked 
transition current state new state automaton intercepted system call automaton placed new state 
transition anomaly recorded 
automaton program program location 
anomaly recorded isn immediately reported cause false positives anomaly threshold defined 
reached action taken 
authors implement weighted anomalies caused malicious user therefor weigh heavily anomaly index 
wagner dean wagner dean describe techniques detecting anomalous behavior 
detectors gather information need system calls statically dynamically 
technique simple detection system calls set system calls application executes recorded 
runtime detector checks intercepted system calls set system calls aren anomaly detected 
second technique builds non deterministic finite state automaton system call sequence performed application controlflow graph program 
technique proposed sekar program location system call recorded 
automaton generated statically contain paths reality executed 
static analysis hand able detect program paths ones dynamic followed training stage 
third technique attempts eliminate program paths executed augmenting information state call stack 
model extended system call sequences form context free language 
extended model represented non deterministic pushdown automaton 
call state tracked precision model increased impossible paths rejected automaton 
final technique described forrest static techniques dynamic ones build model 
wagner dean define attack anomaly detectors mimicry attacks 
attacks mimic behavior application modeled anomaly detector 
may able get application unsafe state mimicking behavior detector expect performed state reached reaching state 
example application performs execve system call lifetime attacker easily execute system calls detector expect see executing execve call 
compiler modifications compiler modifications encompass wide variety solutions countermeasures compiler place methods prevent overflows added modifying language vulnerable programs written 
compiler decides code look compiled important player generating execution environment program run time environment provided operating system run time libraries important players 
constructs compiler function calls stack return address generally ones attacker try exploit gain control program execution flow 
constructs assumptions run time system call machine model 
compiler generates code relies model ideal place add protection 
section discuss bounds checking solutions prevent buffer overflows completely countermeasures protect program machine model prevent attacker abusing vulnerabilities 
bounds checking solutions countermeasures bounds checking foolproof way eliminating buffer overflows size information array available run time perform run time checks ensure code write bounds array impossible overflow 
program calls execve system call current process replaced new process passed argument execve inherits permissions currently running process 
kendall bcc bcc source source translator perform bounds checking pointer dereferences array accesses 
source modified include calls functions perform bounds null alignment checking pointer dereference array access performed insert wrappers library functions misused 
alignment checking done sure pointer access properly aligned 
checking integer overflows performed doing pointer arithmetic 
main disadvantage bcc compilation time increased code generated run time execution program severely slowed 
lowlevel pointer representation remains unchanged code transformed bcc compatible existing non instrumented code 
steffen modification portable compiler adds run time array subscript pointer bounds checking 
implement pointers represented times normal value containing current value pointer memory addresses lower upper bounds 
pointers times normal size converted normal pointer system calls 
system calls wrapped pointers converted 
wrappers contain extra checks sure supplied arguments contain values system call expects 
pointer size poses problems integers pointers longer size explicitly cast pointer programmer 
simplify task compiler comes program find places integer pointer expected report locations programmer 
austin breach sohi safe austin implement bounds checking solution define kind safe pointer contains attributes value pointer base size storage class heap local global capability forever 
value attribute actual pointer base size attributes spatial checks writing outside array bounds 
valid pointer access lies base base size range 
storage class capability attributes temporal checks memory allocated 
pointers global objects receive capability forever freed pointers objects freed receive capability cause error dereferenced 
malloc free operations modified respectively set check attributes 
attempt dereference safe pointer check done see pointer valid check done sure pointer access memory past bounds 
jones kelly bounds checking solution proposed austin backwards compatible meaning code compiled different compiler linked code compiled austin bounds checking compiler 
jones kelly propose bounds checking solution backwards compatible pointer representation left unchanged code compiled bounds checking compiler compatible code 
accomplish bounds checking compiler keeps table known storage objects maps pointers descriptor object contains base size object 
pointer dereferenced arithmetic done pointer check done ensure pointer point outside object referring 
object created inside checked code added object table 
pointer representation kept unchanged pointers passed non checked checked code requiring modifications 
bounds checking done pointer arithmetic performed iso standard allows generation pointer past array occurs loop 
prevent compiler flagging error array padded extra byte 
extended jones kelly compiler support different implementation choices 
jones kelly implement checking language front harder implement checker languages significant code duplication 
moved instrumentation level compiler intermediate representation program generated 
author decided allow generation pointers point element past bounds object different approach supporting bounds pointer generation taken 
bounds address generated byte allocated heap stored object tree information object derived offset object fact bounds object 
address byte returned result arithmetic operation 
pointer subsequently arithmetic operations looked object tree 
real address object plus offset stored tree 
technique doing pointer comparisons 
chapin chapin propose compiler library modifications bounds checking 
approach consists modification preprocessor process source file debugging information turned extra debugging information generate type table associates function address information local buffers sizes offsets stackframe 
type table extended addresses static buffers sizes 
run time type table updated information dynamically allocated objects 
shared library loaded run time intercepts calls vulnerable string memory copying functions bounds checking arguments type table 
find size stack allocated buffer run time algorithm return address previous stackframe located vulnerable copying function called find size buffer looking function address type table 
yonezawa fail safe aim fail safe ansi compiler compiler supports full ansi standard prevents behavior marked undefined standard 
type memory safe compiler contiguous memory region contains size type information 
compiler pointer represented collection values base address contiguous region pointing offset region cast flag indicates pointer may refer value static type 
prevent dereferencing invalid pointer bounds checking size region base pointer points pointer offset type checking done pointer dereferenced 
integer interpretation pointer base offset 
pointer cast integer value representation copied integer allowing integer cast back pointer date meaning pointers integers size normal integers base value 
dangling pointer avoided marking freed memory regions released freeing allowing dangling pointer caught 
memory eventually deallocated garbage collector 
lam cred cred bounds checking countermeasure solution provided jones kelly 
relaxes ansi standard allows generation dereferencing bounds addresses programs bounds addresses calculations comparisons cause buffer overflows fail strict checking applied 
approach taken cred create unique bounds object bounds address value stored substitute value address address object 
object contains bounds address object refers 
jones kelly compiler object table kept pointer dereferenced table isn unchecked object non instrumented code error raised 
objects kept table pointers arithmetic comparison point object object table unchecked object value looked table subsequently stored value returned operation 
improve performance cred bounds check array ones containing string data ones usually involved buffer overflows 
ansi standard allows generation address immediately past array determine array loop dereferencing location undefined generating bounds addresses 
protection protection mechanisms attempt protect information stored stack exploited buffer overflow 
type protection comes observation commonly executed buffer overflow attack attack stack buffer buffer overwrite return address function 
countermeasures focus protecting return address extended protection protect information attacker gain control execution flow program frame pointer regular pointers stored local variables 
cowan 
stackguard stackguard attempts protect return address stored stack placing canary return address 
function prologue random canary bit random value generated program startup terminator canary bit value containing null lf cr aff 
values terminator canary generally mark input specific vulnerable string function 
function exits function epilogue check canary changed 
changed alert logged program terminated hasn canary removed stack function allowed return normally 
indirect pointer overwriting see section countermeasure bypassed pointer overwrite return address directly modifying canary 
remedy modification stackguard proposed return address protected random values 
values xored return address form canary named xor 
protect return address prevent attacker overwriting interesting memory locations 
describes additional techniques bypassing stackguard 
technique overwrites arguments function pointer passed argument indirect pointer overwriting overwrite memory location 
abused attacker overwrite memory location library calls function stack guard checking functions may call overwriting pointer 
describes techniques bypass stackguard overwriting frame pointer see section 
stack shield stack shield attempts protect return address stored stack modification 
methods available doing dynamically loaded libraries implemented position independent code pic rely loaded specific location 
execute calls library functions program uses global offset table got locate functions requires 
overwriting entry got cause program look function new location 
process function lookup dynamically loaded code complicated scope see 
global ret stack method program startup global array called return value table allocated heap 
function prologue function return address copied return value table 
function epilogue return address stack replaced compared depending option specified stored return value table return value table pointer decremented function return usual 
return value table static size function calls get done size array return value table pointer larger return value table top new function calls protected return value table pointer incremented 
return value table pointer gets smaller return value table top subsequent function calls protected 
ret range check method method protection stack shield offers place global variable data section 
function epilogue value return address compared address variable return address lower means points text section safe return 
higher means return address pointing data segment program terminated 
protecting return address possibility method protect function calls combat function pointer overwriting 
protections offered stack shield bypassed techniques described kil 
chiueh hsu rad return address defender rad uses approach stack shield copies return address return address repository rar function prologue 
returning function function epilogue stored address compared actual address function allowed return address 
protection attempts protect rar modification 
accomplish supports kinds protection rad global integer array declared rar pages rar marked read 
prevents overflows heap arrays overwriting middle rar return addresses stored 
read rad rar marked read unmarked read function prologue new address placed rar 
system calls setjmp longjmp cause problems rar stack inconsistency longjmp performs jump address setjmp executed 
longjmp executed popped return setjmp address 
cause inconsistency rar stack return addresses removed stack top rar causing mismatch false exploitation attempt reported 
mismatch occurs rad keep popping values rar match occurs rar empty 
rar empty match occurred safe assume return address modified 
return address valid return address currently stack opens rad possible attack attackers injecting code program execute code return addresses currently stack 
ideas stackguard extends provided countermeasures try prevent attacks described 
difference stackguard places canary frame pointer return address prevent attack frame pointer modified return address left unchanged 
prevent attacks changes firstly random xor canary supported prevent attack 
prevent attacks described organization stackframe changed arrays placed local variables stack meaning arrays closest canary 
prevent array overflowing pointer declared function overwrite values stored specific addresses 
function protected argument overwriting making local copy pointer arguments 
bray 
microsoft net stack protection microsoft added security mechanism visual studio net referred gs compiler flag 
mechanism works way stackguard random security cookie placed stack saved frame pointer protect saved frame pointer return address function 
protect application normal buffer overflow attacks protect attacks described 
attacks require specific situation code function pointer located stack array subsequent changing pointer generic way defeat protection exists described 
windows built exception handling system application 
application register exception handlers default handler set thread initialization 
information exception handlers stored stack linked list 
attackers overflow buffer security cookie return address keep overflowing overwritten exception handler pointer 
attackers cause exception function returns security cookie 
easily done attempting write past stack 
countermeasures implemented exception handlers module registered addresses stored calling exception handler address compared list stored addresses match exception executed 
handler address points outside module address space executed may stack 
allows attacker bypass protection pointing handler piece code outside address space current module jump attacker code 
protection pointers current attacks program execute injected code occur corrupting code pointers 
attacker modify code pointer point injected code program stage calling code pointer expecting point legitimate code execute attacker code 
cowan beattie johansen wagle attempts protect pointers encrypting memory decrypting loaded registers safe overwriting 
attacker able modify pointers stored memory pointers attacker provides decrypted point different possibly inaccessible memory locations 
encryption key attacker unable pointers decrypt predictable value 
encryption extremely simple cause significant overhead execution time program 
random value generated program start pointer xor ed value generally impossible attackers bypass protection process crash pointer decrypted wrongly subsequently 
program restarted new key generated making hard attackers guess key 
attackers able cause program print pointer information vulnerability able guess decryption key able encrypt pointers correctly 
yong horwitz security enforcement tool security enforcement tool suggested yong horwitz tool adds run time protection invalid pointer dereferences pointers dereferenced write operation 
implemented source translation adds run time checks pointers determining static analysis possibly unsafe 
run time checks added keeping status bit byte memory called mirror 
status bit determines writing specific memory region unsafe pointer allowed appropriate inappropriate 
static analysis performed tool divided steps firstly flow insensitive analysis performed gather points information set variables variable points time execution 
pointsto analysis determine variables possibly unsafe pointers may point invalid memory memory location written freed 
final step tracked variables identified correct variables time execution may unsafe pointer referring 
subsequently program instrumented place allocation tracked variable mirror updated mark memory appropriate mirror deallocation occurs memory marked inappropriate 
dereference writing free operation mirror target memory checked appropriateness 
write free done memory marked inappropriate program terminated 
operating system hardware modifications observation attackers wish execute code led proposed countermeasures try prevent vulnerability exploitation try prevent execution injected code 
text focus ia architecture mainly attacks solutions implemented architecture 
non executable memory operating systems divide process memory code called text data segment mark code segment read preventing program modifying code loaded disk segment program explicitly requests write permissions memory region 
attackers inject code data segment application 
applications require executable data segments code code segment countermeasures suggest marking memory non executable harder attacker inject code running application 
solar designer non executable stack marking stack non executable way preventing buffer overflows inject code stack variable usually buffer overflowed processor operating system allow instructions executed specific memory region 
implementation stack solar designer linux kernel ia architecture detailed analysis code segment size limit reduced default gb gb mb 
stack linux ia starts gb mb large default grows downwards stack marked non executable 
marking stack non executable cause programs rely executability break gcc compiled programs nested functions lisp compilers linux kernel signal handling 
setting stack non executable zero cost operation done kernel load time easily bypassed 
injecting code stack pointing return address code desired parameters placed stack return address pointed existing code simple example call libc wrapper system system call pass executable execute attacker code argument 
pax team pax pax kernel patch linux implements non executable stack heap non executable pages ia architecture native support 
hardware support non executable pages attacker injecting foreign code application platforms text section contains code application marked read 
ia architecture natively support non executable pages patch uses page privilege flags implement 
marks pages non executable requiring superuser privileges application tries access pages page fault exception generated 
pax intercept exception check processor attempted execute instruction page access data attempted 
case instruction execution attempt application terminated 
data access attempted page user privileges dummy access page performed stored data cache page marked requiring superuser privileges 
detailed analysis available 
randomized instruction sets technique prevent injection attacker specified code randomized instruction sets 
instruction set randomization prevents attacker injecting foreign code application encrypting instructions process basis memory decrypting needed execution 
attackers unable guess decryption key current process instructions decrypted cause wrong instructions executed 
prevent attackers having process execute payload large chance crashing process due invalid instruction executed 
implementations describe incur significant run time performance penalty instructions implemented emulators entirely possible cases desirable implement hardware level reducing impact runtime performance 

rise implement proof concept implementation randomized instructions emulators emulate processor 
rise built valgrind binary translator detect memory leaks 
rise instructions load time execution 
scrambling load time binaries remain disk unmodified scrambled binary examined potential attacker 
kc keromytis approach kc proof concept implementation emulator 
mainly differs rise fact binaries scrambled disk load time 
key extracted header load time stored process control block pcb key stored special register written special instruction data structure stored kernel memory containing information process process access modify 
read 
storing encrypted binaries disk major drawbacks attacker local access examine encrypted binary extract key 
importantly current implementation statically linked binaries dynamically loaded libraries encrypted key executable means programs libraries key 
result entire system probably just single key programs 
randomized addresses exploits expect memory segments start specific address attempt overwrite return address function interesting address address points code 
base address generated randomly program executed harder exploit direct execution flow injected code 
pax team pax pax kernel patch offers non executable stack heap described previous section offers address space layout randomization 
expects compiler generate position independent code randomizes specific bases addresses specific memory segments stack heap code memory mapped segments program loads program memory 
attackers able cause victim program print part memory able deduce base address desired segment modify attack accordingly 
kernel modification seen operating system modification 
modifies dynamic program loader linux load programs memory execution 
randomizes memory locations attacker place code attacker modify execute code user stack set kernel randomized allocating new stack random location current 
contents copied new pointers adjusted accordingly 
stack pointer set point new stack old stack freed 
heap randomized randomly growing 
location shared libraries randomized allocating random sized region loading shared libraries program address space 
global offset table got locate information needed execute position independent code pic pic access data loaded fixed position 
randomize got positions access got directly rewritten access new position 
chew song chew song propose operating system randomization randomization system call mappings making harder remote attacker call system calls injected code 
dynamically applications call system calls libc wrappers code system call numbers rewritten fly load time generated correctly compile time 
technique suggested libc calls location changed original program rewritten dynamic program loader 
stack location modified allocating random size region program load time 
change operating system suggested timed capabilities 
verifying permissions system call open file program starts program ability add timeout call open 
timeout passed permissions longer available error occur 
protection return addresses buffer overflows attempt overwrite return address function countermeasures focus protecting return address compiler modifications run time checks added verify correctness return address detrimental system performance 
section examine hardware modification protects return addresses changes detects changed return addresses 
xu iyer xu suggest different countermeasures defend buffer overflow attacks splitting control data stack straightforward approach return addresses stored stack function data arguments local variables stored stack 
splitting done software hardware level authors implemented compiler modification extra code generated function prologue save return address control stack function epilogue return address copied control stack back normal data stack 
hardware supported version changes needed ia architecture compatible approach described extra register called csp esp control stack needed call instructions need modification return address pushed control stack ret instruction pop return address control stack 
handled way done currently multithreaded applications thread stack case separate control data stack 
secure return address stack hand attempts detect buffer overflows occurring processors support return address stack 
processors predict return address call instruction fetched processor allow processor predict instructions prefetch executing return 
possible extensions ras mechanism proposed detect buffer overflows 
ras misprediction occurs actual return address different return address predicted processor cause exception misprediction occurs allowing exception handler verify buffer overflow really occur 
cause significant performance hit processor prediction mechanism accurate 

prevent keeping non speculative ras proposed updating ras done commit stage opposed fetch stage processor 
cause mismatches ras return address stored stack ras overflows 

prevent overflowing causing mismatch return addresses ras actual return addresses ras copied memory overflow 
new ras subsequently underflows memory stored ras restored 
glu similar suggestions glu 
lee 
differing system calls setjmp longjmp handled 
authors suggest similar technique rad mismatch occurs move stack finds correct value reaches stack 
match return address actual return address particular longjmp stack 
combat authors suggest storing frame pointer matching 
lee mcgregor shi lee offer possible options handling setjmp longjmp calls 
option prohibit calls 
second option allow extra instructions allow compiler manually push pop values generating code longjmp setjmp similar calls 
third option push pop instructions suggests injecting calls run time software filter dynamically identifies calls setjmp longjmp 
final suggested option allow users turn particular application 
stackghost stackghost operating system modification designed sparc architecture 
architecture function calls handled stack cases nesting recursiveness deep register windows 
sparc global integer registers visible program 
function available integer registers called register window divided groups input registers local registers output registers 
improve execution time function calls processor supports register windows function call executed new window allocated output registers calling function input registers called function new registers allocated called function 
speeds execution processor write register data stack retrieve function return 
processors runs registers usually windows generate register window overflow interrupt operating system write oldest window stack 
long register windows available possible overflow overwrite function return address frame pointer contained registers 
oldest window saved stack vulnerable overwriting 
authors suggest solving encrypting return address trivially broken detrimental system performance 
therefor suggest solution hashtable stored process control block kernel structure 
register window saved stack return address saved hashtable random value key hashtable written stack address 
window restored return address looked hashtable stack stored random value 
library modifications protection singh tsai replaces string manipulation functions prone misuse functions prevent buffer outside stackframe 
done calculating size input string making sure size source string upper bound destination string space variable stack location saved frame pointer 
smaller program terminated 
case countermeasures protection bypassed indirect pointer overwriting 
offers kind protection stack shield entering function saves return address return address stack calls canary stack exiting function saved return address compared actual return address 
main difference stack shield lies way check added require access source code application checks added dynamically linking process library run time 
copy function heap memory overwrite instruction original function jump function entry code saves return address canary stack 
rest original function overwritten trap instructions prevent absolute jumps transferring control original function 
trap handler return execution flow copied function 
overwrite return instruction copied function jump function exit code check return address unchanged 
changed program terminated 
wrote patch freebsd implementation libc integrity check returning libc string copying functions strcpy sprintf gets known vulnerable buffer overflows misused 
returning functions patch checks sure contained memory range written functions 
extension idea integrity patch author 
modifies vulnerable libc string copying functions frame pointer return addresses saved data segment maximum frames deep saved string manipulation performed frame pointers return addresses compared stored values changed program terminated 
protection dynamically allocated memory robertson countermeasure attempts protect attacks library management information 
done changing layout allocated unallocated memory chunks 
protect management information checksum padding chunks double word length added chunk 
checksum checksum management information seeded global read random value prevent attackers generating checksum 
chunk allocated checksum added freed checksum verified 
attacker overwrites management information buffer overflow subsequent free chunk abort program checksum invalid 
attempts protect memory allocated heap buffer overflows overwrite memory management information associated chunk allocated memory 
uses technique proposed stackguard protect memory regions 
places randomly generated canary memory region protects 
exiting string memory copying function check done ensure destination region heap canary stored region matches canary stored region 
program aborted 
electric fence electric fence debugging library replaces default implementation malloc library version changes behavior time portion memory allocated places inaccessible virtual memory page immediately preceding allocated memory immediately 
results immediate error overrun occurs 
memory freed page contained marked inaccessible detect dangling pointer 
approach meant production environment memory allocation take virtual memory pages total kb ia machines memory freed resulting program uses enormous amount resources 
fetzer xiao fault containment wrapper designed improve security robustness application 
takes number measures calls library intercepted replaced versions checking arguments ensure correct api 
wrap calls libraries fault injection gather information correct library generate wrappers perform checks ensure application call api arguments cause misbehave 
wrapper protect programs attacks overflows 
replaces library functions overflow heap buffer bounds checked version 
wrappers implemented malloc free functions memory allocated size position memory recorded table memory freed information removed table 
overflowing heap allocated memory copying functions detected checking area written heap comparing range memory region area written 
area lies outside range overflow occur program terminated 
format string countermeasures countermeasures attempt prevent format string vulnerabilities intercepting calls format functions performing sanity checks executing format function 
cowan 
offers countermeasures format string attacks described section 
countermeasures observation format string attacks specifiers format string arguments passed format function 
tries prevent format string attacks counting amount arguments format string expects compares amount arguments passed function 
expected provided attempting exploit format string vulnerability program terminated 
robbins library intercepts calls format functions checks supplied format string 
string located writable segment program contains specifier program terminated 
safer libraries buffer overflows occur due misuse standard string manipulation functions 
safer libraries attempt prevent vulnerabilities offering developers new libraries string manipulation prone misuse 
miller de solve problems associated standard string manipulation functions strcpy strcat sprintf 
bounded string copying functions exist 
functions accept argument denotes maximum size may copied destination string 
problems occur functions example common mistake assume destination strings passed null terminated true size source string smaller size parameter 
behaves differently standard strcpy implementation size source string smaller size parameter rest destination string filled null bytes causing loss performance standard strcpy suffer 
similar problem guarantees null termination size parameter passed take account 
attempt solve inconsistency offering programmers string manipulation functions accept size parameter guaranteed null terminated fill remaining memory null bytes 
vega library replacement string library immune buffer overflows format string vulnerabilities 
strings longer defined array characters defined type cast char back 
type extra accounting information actual length allocated length string 
string manipulation functions library safe counterpart bounds checking type accounting information 
format string vulnerabilities stopped having safe versions printf allow specifier sanity checking printing string 
library supports kind tainting strings flagged trusted untrusted flag subsequently checked trusted string needed 
randomized addresses randomization addresses kernel level see section possible library level 
countermeasure describes address obfuscation technique implemented library level 
sekar describe address obfuscation techniques harder attacker exploit vulnerabilities described earlier 
opposed pax implementation done kernel level library level 
support kind randomization pax extend idea 
firstly order static variables local variables stackframe shared library functions randomized 
harder attacker overwrite adjacent variables 
objects moved system expects specific order 
harder attacker overwrite random sized gaps introduced objects 
implementation purposes authors chosen implement randomization link time important shortcoming randomization static program randomized execution contain randomization 
easier attacker base address relative distances variables order examining program binary exploiting vulnerability causes victim program print parts memory 
reason authors suggest plan different method implementation randomization execution different time program run supports run time 
note authors mention suggested techniques proof concept implementation synthesis countermeasures categories divided countermeasures section categories vulnerabilities address limitations applicability limitations protection type protection offer preventive defensive mitigating type response problem detected 
summarized results tables countermeasures deployment time 
results countermeasures development time summarized tables 
vulnerability categories table contains list vulnerabilities countermeasures document deal 
reflect scope vulnerabilities author wished address 
cases especially true integer overflows countermeasure implicitly offers protection certain kind vulnerability explicitly wanting protect 
cases listed vulnerabilities scope countermeasure 
example bounds checking solutions offer protection integer overflows integer overflows usually misused cause buffer overflows 
listed integer overflows part protection offered bounds checking solutions offer explicit protection 
code category stack buffer overflow heap buffer overflow dangling pointer format string vulnerabilities integer errors table vulnerability categories applicability limitations categories table lists codes specific requirements limitations application countermeasures may 
example countermeasures require source code program implement protection 
limitation countermeasure applied protect programs source code available 
protection limitations categories tables contains list codes known limitations protection countermeasure may 
countermeasures may limitations ones table limitations give indication code applicability limitation categories source code required explicit manual changes intervention required compatible non instrumented code compile analyze code needs hardware modifications operating system modifications required architecture specific linux specific dynamically linked executable required protects libc string manipulation functions breaks applications requiring executable memory systems executable linking format elf unix systems specific inadequate support threading program needs implemented special language requires annotations operates integers scale larger applications examine string operations table applicability limitation categories options attacker may attacking application protected specific countermeasure 
type categories type protection countermeasure provides contained table 
countermeasures offer detection detect attack occurs take action defend application prevent vulnerability occurring 
prevention countermeasures attempt prevent vulnerability existing place generally able detect attacker attempting exploit program vulnerability eliminated 
type countermeasures ones try detect prevent attack vulnerability try mitigate damage attacker trying exploit vulnerability 
countermeasures harder attacker exploit vulnerability randomization techniques type mitigation 
response categories section contains table categories table describe countermeasure problem detected 
countermeasure able restore program original state continue execution decide continuing operation unsafe log message describing problem terminate application 
countermeasure response report problem means just log problem cases take action problem reported 
code protection limitation categories check dangling pointer stack heap check arrays structs arrays passing bounds pointers non instrumented code may cause unexpected behavior cases size buffers determined stack allocated buffers allocated alloca arrays variable length protects libc functions strcpy 
strings bounds checked bypassed indirect pointer overwriting attacker able view memory protection bypassed attacker able executed code return libc technique protection bypassed overwriting exception handlers causing exception overwriting memory marked appropriate possible memory allocated malloc protected current implementation sufficient injected code executed heap randomized code injected mimicry attacks execute injected code applications need privileges execute benefit false negatives possible protects string copies explicitly impossible sequences system calls accepted valid possible changes programs tracked definite changes table protection limitation categories code type category detection exploitation attempts detected prevention vulnerability prevented mitigation operations attacker perform limited exploitation harder table type categories code response category application terminated application crashes application state restored execution continues exception generated unsafe operation denied problem reported table response categories deployment tools tables contain list countermeasures deployment time protect application vulnerabilities described section 
due space limitations author name countermeasure mentioned column 
coverage field indicates types vulnerability countermeasure offers protection 
meaning codes indicate vulnerabilities covered countermeasure table 
computational memory cost give estimate run time cost specific countermeasure incur deployed 
values listed provided cases extremely hard determine cost descriptions authors values columns entirely accurate 
applicability limitation column lists important limitations applying countermeasures places applied countermeasure meaning codes 
protection limitations column contains list known limitations protection offered specific countermeasure 
meaning codes column 
type column lists type countermeasure offered 
currently identified major types countermeasures preventing countermeasures detecting countermeasures mitigating countermeasures mapping codes column actual types table 
final column contains response countermeasure trying prevent vulnerability detecting mitigating exploitation attempt 
codes column table 
countermeasure coverage comp 
mem 
app 
cost cost lim 
bounds checking kendall bcc steffen austin safe jones fail safe cred prot 
lim 
high high high high high high high high high low medium high high high high high high table deployment tools type response countermeasure coverage comp 
mem 
app 
cost cost lim 
protection cowan stack guard stack shield ret stack stack shield ret range low low chiueh rad chiueh readonly rad bray net stack prot 
xu split stack low low xu low low glu low low lee stack ghost low low lib low low safe low low check lib low low protection pointers cowan point guard yong sec 

tool prot 
lim 
type response low low low low low medium medium medium low low low low low low medium low medium low medium high table deployment tools continued high countermeasure coverage comp 
cost mem 
cost app 
lim 
prot 
lim 
type response protection dynamically allocated memory robertson low low fetzer wahbe sfi small misfit sasi evans goldberg janus systrace low low high high forrest sekar wagner wagner nd pda fault isolation low low high low policy enforcement high low high low low low medium low high high anomaly detection high high high medium high high table deployment tools continued medium medium countermeasure coverage comp 
mem 
app 
cost cost lim 
non executable memory solar designer non exec 
stack pax team high randomization rise kc pax team xu prot 
lim 
type response high high low high low low low medium chew low low cowan format guard robbins low medium format string countermeasures low low table deployment tools continued development tools tables contain list development tools examined document 
columns containing computational memory costs dynamic analysis countermeasures general development tools measures comparison running non instrumented programs 
costs countermeasures compared costs static analysis 
costs countermeasures static analysis measured running time analysis 
columns ones tables section 
countermeasure coverage comp 
mem 
app 
cost cost lim 
static countermeasures low low splint dor cssv high high shankar low low bush prefix pincus xie archer unknown high simon un wagner boon unknown prot 
lim 
type response high low low high known unknown medium un un known un wheeler secure software rats known low low low low low low table development tools countermeasure coverage comp 
mem 
app 
cost cost lim 
dynamic countermeasures hastings purify high larson muse high ghosh fist fink prop 
test electric fence prot 
lim 
type response high medium high high general development tools miller un low jim cyclone necula ccured deline vault control known medium medium high high high unknown unknown unknown unknown table development tools continued orr orr orr related lot done categorizing vulnerabilities different taxonomies relative strengths weaknesses little done categorizing available countermeasures important vulnerabilities 
cowan examined countermeasures buffer overflows examine set defenses including bounds checking modifications compaq compiler jones kelly compiler safe languages java ml debugging tools purify library patches freebsd patch compiler modifications stack guard early idea 
countermeasures mentioned briefly stackguard examined depth 
published documents area relating static countermeasures describing dynamic ones 
documents limited publicly available tools focus comparing existing production tools 
examines rats splint boon comparison compares stackguard stack shield 
documents examines effective countermeasures respectively finding vulnerabilities source code preventing wide range attacks 
chapin performed extensive survey techniques exploiting buffer overflows format string vulnerabilities 
focus mainly exploitation techniques provide overview countermeasures designed buffer overflows format string vulnerabilities 
main goals provide comprehensive survey countermeasures vulnerabilities allow code injection vulnerability section contains vulnerabilities dangling pointer integer errors considered chapin 
difference focus describe countermeasures provide synthesis allows reader weigh advantages disadvantages specific countermeasure opposed easily 
important properties countermeasures described document identified countermeasure try prevent vulnerability entirely detect attack take subsequent action try mitigate abuse attack 
combination properties 
important properties countermeasure requires changes original program impact countermeasure performance compatibility existing code need access source code program protecting intrusiveness programs working applying specific countermeasure limitations bypassed 
coverage stack overflows heap overflows format string vulnerabilities 
properties table countermeasures described document 
useful determining kind countermeasure suited particular application 
observation countermeasures take ad hoc approach prevent mitigate impact specific vulnerabilities 
propose designing model describes key abstractions compiler relies generate program 
key abstractions function call virtual function table stack 
ones generally abused attacker gain control program execution flow 
conventions exist describe abstractions 
designed system implementation focus issue security 
modeling abstractions machine model modeling vulnerabilities attacks countermeasures model reason level 
provides higher level platform compare specific countermeasures 
tracks devise machine model model existing new countermeasures 
linux programmer manual section printf 
cited page 
jtc sc wg 
iso iec programming languages technical report international organization standards 
cited pages 
robert abbott janet chin james 
william shigeru douglas webb 
security analysis enhancements computer operating systems 
technical report 
cited page 
anonymous 
free 
phrack 
cited page 
ken dawson engler 
programmer written compiler extensions catch security holes 
proceedings ieee symposium security privacy pages berkeley california usa may 
ieee computer society ieee press 
cited pages 
aslam 
taxonomy security faults unix operating system 
master thesis purdue university 
cited page 
todd austin scott breach sohi 
efficient detection pointer array access errors 
proceedings acm sigplan conference programming language design implementation pages orlando florida june 
acm 
cited pages 
singh timothy tsai 
transparent run time defense stack smashing attacks 
usenix annual technical conference proceedings pages san diego california june 
usenix association 
cited pages 
elena david ackley stephanie forrest trek palmer darko dino dai 
randomized instruction set emulation disrupt binary code injection attacks 
proceedings th acm conference computer communications security ccs pages washington district columbia october 
acm 
cited pages 
bbp 
bsd heap smashing 
bbp net bsd heap smashing txt may 
cited page 
sandeep daniel sekar 
address obfuscation efficient approach combat broad range memory error exploits 
proceedings th usenix security symposium pages washington district columbia august 
usenix association 
cited pages 
richard ii dennis hollingsworth 
protection analysis project final report 
technical report information sciences institute university southern california 
cited page 
matt bishop 
taxonomy unix system network vulnerabilities 
technical report cse department computer science university california davis may 
cited page 
matt bishop 
vulnerability analysis 
proceedings advances intrusion detection pages west lafayette indiana september 
cited page 
matt bishop dave bailey 
critical analysis vulnerability taxonomies 
technical report department computer science university california davis 
cited page 

basic integer overflows 
phrack december 
cited page 
brandon bray 
compiler security checks depth 
msdn microsoft com library en dv html asp february 
cited pages 
kil 
bypassing stackguard 
phrack 
cited pages 
william bush jonathan pincus david 
static analyzer finding dynamic programming errors 
software practice experience june 
issn 
cited pages 
monica chew dawn song 
mitigating buffer overflows operating system randomization 
technical report cmu cs carnegie mellon university december 
cited pages 
tzi cker chiueh fu hau hsu 
rad compile time solution buffer overflow attacks 
proceedings st international conference distributed computing systems pages phoenix arizona usa april 
ieee computer society ieee press 
cited pages 
jeremy condit matthew harren scott george necula weimer 
ccured real world 
proceedings acm sigplan conference programming language design implementation pages san diego california 
acm 
cited pages 
matt conover 
heap overflows 
www org files articles txt 
cited page 
patrick nicolas halbwachs 
automatic discovery linear restraints variables program 
conference record fifth annual acm symposium principles programming languages pages tucson arizona january 
acm 
cited page 
crispin cowan 
stackguard mechanism vulnerability 
www org stackguard html november 
cited pages 
crispin cowan matt barringer steve beattie greg hartman mike jamie 
automatic protection printf format string vulnerabilities 
proceedings th usenix security symposium pages washington district columbia august 
usenix association 
cited pages 
crispin cowan steve beattie ryan day calton pu perry wagle eric 
protecting systems stack smashing attacks stackguard 
proceedings linux expo raleigh north carolina may 
cited pages 
crispin cowan steve beattie john johansen perry wagle 
point guard protecting pointers buffer overflow vulnerabilities 
proceedings th usenix security symposium pages washington district columbia august 
usenix association 
cited pages 
crispin cowan calton pu dave maier heather hinton jonathan walpole peat steve beattie aaron perry wagle qian zhang 
stackguard automatic adaptive detection prevention buffer overflow attacks 
proceedings th usenix security symposium pages san antonio texas january 
usenix association 
cited pages 
crispin cowan perry wagle calton pu steve beattie jonathan walpole 
buffer overflows attacks defenses vulnerability decade 
proceedings darpa information survivability conference exposition volume pages hilton head south carolina january 
cited page 
deline manuel hndrich 
enforcing high level protocols low level software 
proceedings acm sigplan conference programming language design implementation pages snowbird utah may 
acm 
cited page 
vikram adve chris lattner 
memory safety runtime checks garbage collection 
proceedings acm sigplan conference language compiler tool support embedded systems pages san diego california june 
acm 
cited pages 
igor 
exploit cvs double free linux 
org lists bugtraq feb html february 
cited page 
dor michael rodeh mooly sagiv 
checking string manipulation programs integer analysis 
proceedings international static analysis symposium volume lecture notes computer science pages paris france july 
springer verlag 
cited pages 
dor michael rodeh mooly sagiv 
cssv realistic tool statically detecting buffer overflows proceedings acm sigplan conference programming language design implementation pages san diego california 
acm 
cited pages 
richard earnshaw 
procedure call standard arm architecture 
technical report arm october 
cited page 
margaret ellis bjarne stroustrup 
annotated manual 
addison wesley 
cited page 
fred schneider 
sasi enforcement security policies retrospective 
proceedings new security paradigm workshop pages hills ontario canada september 
acm 
cited pages 
hiroaki 
protecting stack smashing attacks 
technical report ibm research tokyo research laboratory june 
cited pages 
david evans david 
improving security extensible lightweight static analysis 
ieee software january february 
cited pages 
david evans andrew 
flexible policy directed code safety 
proceedings ieee symposium security privacy pages oakland california may 
ieee computer society ieee press 
cited pages 
christof fetzer zhen xiao 
detecting heap smashing attacks fault containment wrappers 
proceedings th ieee symposium reliable distributed systems srds pages new orleans october 
ieee computer society ieee press 
cited pages 
christof fetzer zhen xiao 
flexible generator architecture improving software dependability 
proceedings th international symposium software reliability engineering pages annapolis maryland november 
ieee computer society ieee press 
cited pages 
christof fetzer zhen xiao 
automated approach increasing robustness libraries 
proceedings international conference dependable systems networks dsn pages washington district columbia july 
ieee computer society ieee press 
cited pages 
christof fetzer zhen xiao 
toolkit enhancing robustness security existing applications 
proceedings international conference dependable systems networks dsn pages san francisco california june 
ieee computer society ieee press 
cited pages 
george fink matt bishop 
property testing new approach testing assurance 
acm sigsoft software engineering notes july 
cited pages 
stephanie forrest steven hofmeyr anil somayaji thomas longstaff 
sense self unix processes 
proceedings ieee symposium security privacy pages oakland california may 
ieee computer society ieee press 
cited pages 
jeffrey foster manuel hndrich alexander aiken 
theory type qualifiers 
proceedings acm sigplan conference programming language design implementation atlanta georgia may 
acm 
cited page 
mike mike 
stackghost hardware facilitated stack protection 
proceedings th usenix security symposium pages washington district columbia august 
usenix association 
cited pages 
vinod jha david chandler david david vitek 
buffer overrun detection linear programming static analysis 
proceedings th acm conference computer communication security pages washington district columbia october 
acm press 
cited pages 
ghosh tom connor 
analyzing programs vulnerability buffer overrun attacks 
proceedings st nist ncsc national information systems security conference pages october 
cited pages 
ghosh tom connor mcgraw 
automated approach identifying potential vulnerabilities software 
proceedings ieee symposium security privacy pages oakland california may 
ieee computer society ieee press 
cited pages 
ian goldberg david wagner randi thomas eric brewer 
secure environment untrusted helper applications 
proceedings th usenix security symposium pages san jose california july 
usenix association 
cited pages 
richard grimes 
preventing buffer overflows 
dr dobb journal software tools professional programmer january 
cited pages 
dan grossman greg morrisett trevor jim michael hicks wang james cheney :10.1.1.10.8871
region memory management cyclone 
proceedings acm sigplan conference programming language design implementation pages berlin germany june 
cited pages 
reed hastings bob joyce 
purify fast detection memory leaks access errors 
proceedings winter usenix conference pages san francisco california january 
usenix association 
cited pages 
eric matt bishop 
testing programs buffer overflow vulnerabilities 
proceedings th network distributed system security symposium ndss san diego california february 
internet society 
cited pages 
john howard 
analysis security incidents internet 
phd thesis carnegie mellon university 
cited page 
michael howard david leblanc 
writing secure code 
microsoft press 
cited page 
intel 
ia intel architecture software developer manual volume basic architecture 
order nr 
cited page 
trevor jim greg morrisett dan grossman michael hicks james cheney wang :10.1.1.127.7825
cyclone safe dialect usenix annual technical conference pages monterey california june 
usenix association 
cited pages 
richard jones paul kelly 
backwards compatible bounds checking arrays pointers programs 
proceedings rd international workshop automatic debugging number link ping electronic articles computer information science pages link ping sweden 
link ping university electronic press 
cited pages 
michel 
object believed embody magical powers 
phrack 
cited page 
gaurav kc angelos keromytis vassilis 
countering code injection attacks instruction set randomization 
proceedings th acm conference computer communications security ccs pages washington district columbia october 
acm 
cited pages 
samuel kendall 
bcc runtime checking programs 
proceedings usenix summer conference pages toronto ontario canada july 
usenix association 
cited pages 
brian kernighan dennis ritchie 
programming language 
prentice hall software series second edition edition 
cited page 
vladimir derek saman amarasinghe 
secure execution program shepherding 
proceedings th usenix security symposium san francisco california august 
usenix association 
cited pages 

frame pointer overwrite 
phrack 
cited pages 
vikram adve 
ensuring code safety runtime checks real time control systems 
cited pages 
andreas 
libc extension protecting applications heap smashing attacks 
www november 
cited pages 
carl landwehr alan bull john mcdermott william choi 
taxonomy computer program security flaws examples 
technical report 
cited page 
david david evans 
statically detecting buffer overflow vulnerabilities 
proceedings th usenix security symposium pages washington district columbia august 
usenix association 
cited pages 
eric larson todd austin 
high coverage detection input related security faults 
proceedings th usenix security symposium pages washington district columbia august 
usenix association 
cited pages 
james larus thomas ball das robert deline manuel hndrich jon pincus sriram rajamani ramanathan 
software 
ieee software may june 
cited pages 
doug lea wolfram 
glibc malloc malloc comments source code 
cited page 
ruby lee david john mcgregor shi 
hardware architecture thwart malicious code injection 
proceedings international conference security pervasive computing volume lecture notes computer science pages 
springer verlag 
cited pages 
john levine 
linkers loaders 
morgan kauffman october 
cited page 
steve chapin 
type assisted dynamic buffer overflow detection 
proceedings th usenix security symposium pages san francisco california august 
usenix association 
cited pages 
steve chapin 
buffer overflow format string overflow vulnerabilities 
software practice experience april 
cited page 
david 
defeating stack buffer overflow prevention mechanism microsoft windows server 
www 
com papers defeating stack protection pdf september 
cited page 
matt john 
safe string library 
www 
org november 
cited pages 
microsoft 
vault programming language reliable systems 
research microsoft com vault 
cited pages 
microsoft 
buffer overrun rpc interface allow code execution 
www microsoft com security bulletin ms asp july 
cited page 
todd miller theo de 
consistent safe string copy concatenation 
proceedings usenix annual technical conference freenix track pages monterey california june 
usenix association 
cited pages 
george necula scott weimer :10.1.1.152.1345
ccured type safe retrofitting legacy code 
conference record popl th sigplan sigact symposium principles programming languages pages portland oregon january 
acm 
cited pages 
akinori yonezawa 
fail safe ansi compiler approach making programs secure progress report 
proceedings international symposium software security pages tokyo japan november 
cited pages 
aleph 
smashing stack fun profit 
phrack 
cited page 
santa cruz operation system application binary interface 
technical report march 
cited page 
santa cruz operation system application binary interface sparc processor supplement 
technical report 
cited page 
glu carla brodley benjamin 
hardware solution prevent security attacks function return address 
technical report tr ece purdue university february 
cited pages 
bruce 
electric fence 
com 
cited pages 
frank 
taxonomy causes software vulnerabilities internet software 
supplementary proceedings th international symposium software reliability engineering pages annapolis maryland november 
ieee computer society ieee press 
cited page 
frank 
secure software engineering 
draft november 
cited page 
vassilis 
sandboxing applications 
proceedings usenix annual technical conference freenix track boston massachusetts june 
usenix association 
cited pages 
niels 
improving host security system call policies 
proceedings th usenix security symposium pages washington district columbia august 
usenix association 
cited pages 

different tricks bypass stackguard protection 
www com files files pdf april june 
cited pages 

smashing 
phrack 
cited page 
tim robbins 

www securityfocus com tools october 
cited pages 
william robertson christopher darren frederik 
run time detection heap overflows 
proceedings th large installation systems administrators conference pages san diego california october 
usenix association 
cited pages 
radu martin rinard 
symbolic bounds analysis pointers array indices accessed memory regions 
proceedings acm sigplan conference programming language design implementation pages vancouver british columbia canada june 
acm 
cited pages 
monica lam 
practical dynamic buffer overflow detector 
proceedings th annual network distributed system security symposium san diego california february 
internet society 
cited pages 
jerome saltzer michael schroeder 
protection information computer systems 
proceedings ieee september 
cited page 
fred schneider 
enforceable security policies 
acm transactions information system security february 
cited page 
fred schneider 
privilege 
ieee security privacy september october 
cited page 
scut 
exploiting format string vulnerabilities 
www team 
net articles 
cited page 
secure software 
rats website 
www com download rats htm 
cited pages 
sekar pradeep 
fast automaton method detecting anomalous program behaviors 
proceedings ieee symposium security privacy pages oakland california may 
ieee computer society ieee press 
cited pages 
umesh shankar talwar jeffrey foster david wagner 
detecting format string vulnerabilities type qualifiers 
proceedings th usenix security symposium pages washington district columbia august 
usenix association 
cited pages 
axel simon andy king 
analyzing string buffers kirchner ringeissen editors international conference algebraic methodology software technology volume lecture notes computer science pages 
springer september 
cited pages 
kevin ahuja margaret martonosi douglas clark 
improving prediction procedure returns return address stack repair mechanisms 
proceedings st annual acm ieee international symposium microarchitecture pages dallas texas november 
cited page 
christopher small 
tool constructing safe extensible systems 
proceedings third usenix conference object oriented technologies pages portland oregon june 
usenix association 
cited pages 
nathan smith 
stack smashing vulnerabilities unix operating system 
reality sgi com nate machines security nate buffer ps 
cited page 
alexander 

www lexa ru 
cited pages 
alexander 
freebsd libc stack integrity patch 
ftp ftp lucky net pub unix local libc letter february 
cited pages 
brian snow 
assured 
proceedings ieee symposium security privacy pages oakland california may 
ieee computer society ieee press 
cited page 
solar designer 
non executable stack patch 
www com 
cited pages 
solar designer 
jpeg com marker processing vulnerability netscape browsers 
www com advisories ow netscape jpeg txt july 
cited page 
eugene spafford 
crisis 
communications acm june 
cited page 
joseph steffen 
adding run time checking portable compiler 
software practice experience april 
issn 
cited pages 
bjarne stroustrup 
programming language 
addison wesley third edition edition 
cited page 
andrew 
bounds checking 
technical report imperial college 
cited pages 
pax team 
documentation pax project 

net docs 
cited pages 

documentation stack shield 
www 
com sk 
cited pages 
john bloch gary mcgraw 
static vulnerability scanner code 
th annual computer security applications conference new orleans louisiana december 
cited pages 
john gary mcgraw 
building secure software 
addison wesley 
cited page 
david wagner drew dean 
intrusion detection static analysis 
proceedings ieee symposium security privacy pages oakland california may 
ieee computer society ieee press 
cited pages 
david wagner jeffrey foster eric brewer alexander aiken 
step automated detection buffer overrun vulnerabilities 
proceedings th networking distributed system security symposium pages san diego california february 
cited pages 
robert wahbe steven lucco thomas anderson susan graham 
efficient software fault isolation 
proceedings th acm symposium operating system principles pages asheville north carolina december 
acm 
cited pages 
charles webb 
subroutine call return stack 
ibm technical disclosure bulletin april 
cited page 
david wheeler 
website 
www com 
cited pages 
david wheeler 
secure programming linux unix howto edition march 
cited page 
john kamkar 
comparison publicly available tools static intrusion prevention 
proceedings th nordic workshop secure systems sweden november 
cited page 
john kamkar 
comparison publicly available tools dynamic buffer overflow prevention 
proceedings th network distributed system security symposium san diego california february 
internet society 
cited page 

defeating solar designer non executable stack patch 
www insecure org non executable stack 
problems html 
cited page 
xie andy chou dawson engler 
archer symbolic path sensitive analysis detect memory access errors 
proceedings th european software engineering conference held jointly th acm sigsoft international symposium foundations software engineering pages helsinki finland 
acm press 
cited pages 
jun xu ravishankar iyer 
transparent runtime randomization security 
nd international symposium reliable distributed systems srds pages florence italy october 
ieee computer society ieee press 
cited pages 
jun xu sanjay patel iyer ravishankar 
architecture support defending buffer overflow attacks 
second workshop evaluating architecting system dependability pages san jose california october 
cited pages 
hsi yong susan horwitz 
protecting programs attacks invalid pointer dereferences 
proceedings th european software engineering conference held jointly th acm sigsoft international symposium foundations software engineering pages pages 
acm acm press september 
cited pages 
dor 
design 
technical report tel aviv university april 
cited page 
yves 
overview common programming security vulnerabilities possible solutions 
master thesis vrije universiteit brussel 
cited pages 
cliff zou gong don towsley 
code red worm propagation modeling analysis 
proceedings th acm conference computer communications security pages washington district columbia november 
acm 
cited page 

