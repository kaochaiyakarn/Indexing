linearity pi calculus naoki kobayashi university tokyo tokyo ac jp benjamin pierce university cambridge bcp cl cam ac uk david turner university glasgow dcs gla ac uk economy flexibility pi calculus attractive object theoretical study basis concurrent language design implementation 
generality cost encoding higher level features functional computation pi calculus throws away potentially useful information 
show linear type system recover important static information process behaviour 
particular guarantee processes communicating linear channel interfere communicating processes 
enables aggressive optimisation communications linear channels allows useful refinements usual notions process equivalence pi calculus 
developing standard results soundness typing focus equivalences adapting standard notion barbed bisimulation linear setting showing reductions linear channels induce useful partial confluence process behaviors 
long line formal systems hewitt actors agh modern process calculi milner parrow walker pi calculus mpw mil popularized idea range concurrent programming idioms modeled simple processes exchanging messages channels 
immediate applications specification verification concurrent systems calculi basis concurrency features numerous programming languages car gmp rep foundations theoretical study language features concurrent objects jon wal ht vas ky ky core programming languages right pt pt fg 
small set message passing primitives pi calculus attractive object theoretical study basis language design implementation 
generality cost pi calculus extremely low level notation encoding higher level features functional computation pi calculus permission digital hard copies part material personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copyright permission acm copy republish post servers redistribute lists requires specific permission fee 
popl st petersburg fla usa flc acm throw away potentially useful information 
common response observation consider larger calculi example functions primitives 
ensures cost parsimony functions compiled efficiently expected high level rules reasoning formally informally apply 
radical approach exploring avoid adding new primitives recover information special modes usage static type information 
encoding functional computation example illustrates encode functions function application cf 
mil san pure message passing calculus highlights pitfalls encodings 
suppose plusone communication channel running process repeatedly reads pairs plusone number channel responds case sending value 
numbers implemented processes channels need concern 
may speak channel plusone location incrementing process plusone means processes refer 
build function suppose channel serve location new process 
create process repeatedly reads pairs uses plusone twice returning final result channel 
plusone plusone replicated input expression 
describes process time receives pair channel starts fresh copy body running parallel processes system 
copy body invocation function creates fresh channels channel creation operator sends message channel plusone written plusone parallel waits receive response continuation channel written 
arrives sends message plusone waits response sends back continuation channel original caller 
example convention function process reading messages channel callers function processes send messages unfortunately pi calculus notation prevents process disrupting protocol maliciously accidentally reading writing 
asymmetry roles function caller lost 
lack structure lead errors complex programs blocks useful optimizations program transformations 
arities polarities simplest type systems pi calculus mil just track arities channels order prevent situations tuple arguments provided sender width tuple bound variables receiver channel assigned type form tn read channel carrying tn describing number values message sent types 
example channel type num num communicate pairs element number second channel send single number 
type system extended ways instance adding polymorphism gay vh tur lw 
interest possibility refining types channels carry information 
example straightforwardly capture polarity directionality communications channels introducing new channel types tn channels context send tuples type tn tn channels receive tn tuples ps ode 
point view process implementing increment function type plusone num num read messages message consist number channel send response 
point view users function plusone type num num send messages message consist number channel sending numbers 
refinement useful preventing programming mistakes yields powerful techniques reasoning programs 
example early draft mil milner proposed encodings call value lambda calculus pi calculus 
unfortunately simpler encodings turned preserve beta equivalence possibility external environment channels generated encoding wrong direction san 
pierce sangiorgi ps showed validity beta reduction established typing encoding output channels 
essence refining type system reduces number contexts process correctly placed making easier processes equivalent 
useful information captured simple polarized channel types 
example express fact result channel passed plusone just 
information justified replacing example efficient tail call optimized form 
plusone plusone see version behavior original contexts imagine increment process signals twice result channel 
tail call optimized implementation fact visible caller generating messages result channel original implementation sends just message linear types propose refined pi calculus type system channel types polarities determine directions multiplicities control times 
example type num describes channel exactly send message containing number num describes channel number times 
pi calculus linear channel types take type plusone point view callers num num capturing fact invoked number times result channel invocation 
accurate typing original tail call optimized versions example provably equivalent sense behave typed contexts show section 
refined typings plusone instances general observation techniques similar tur ps easy show result channel pi calculus encoding lambda term assigned linear type 
useful equivalences gained presence linear types mechanics reasoning processes augmented absence nonlocal operators choice processes communicating linear channel interfere affected communicating processes 
stands sharp contrast usual situation pi calculus possibility senders competition receiver vice versa introduces essential element non determinism 
expression reduce reduced reach common point 
hand senders receivers linear channel race conditions arise 
linear communications exhibit partial confluence property reminiscent church rosser property lambda calculus show section 
linear typing potentially enables variety compiler optimizations 
impact optimizations practice clear underway evaluating compiler linear variant pict programming language pi calculus pt pt 
example implementation communication linear channel simplified current pict implementation linear channel states communication occurs may zero processes opposite polarity waiting communicate polarity 
addition heap space allocated linear channel immediately re receiver communication reclaimed garbage collection 
linear channel types help detect common programming mistakes 
example case process signal channel indicate leaving critical section 
suppose channel supposed signal completion 
critical section complex easy forget signal completion signal twice linear type typing rules ensure exactly 
note slightly careful exactly means typing preserved reduction cf 
section process containing exactly communicate evolve process step process contains 
guarantees twice eventually subprocess occurs diverge deadlock communicates example process creates fresh channel reads sends fresh sender send reached 
possibility partial deadlock divergence pi calculus gives linear typing slightly different force lambda calculus linear value program fails yield result 
overview goals precise definition linear types formal justifications claims sketched typing program equivalences 
novel aspects development technical treatment linear channel types input output ends comprise linear capabilities importantly study behavioral equivalences presence linear types 
introducing notational conventions section define typing relation section show preserved reduction section way properties confluence 
section adapt standard notion barbed congruence setting 
section extends results strong barbed congruence useful weak case prove versions equivalent 
section discusses related section sketches variations system studied 
proofs omitted summary accompanying technical report kpt 
notational preliminaries operators introduced examples constitute fragment polyadic pi calculus mil omitting choice matching operators milner mini pi calculus mil asynchronous communication honda tokoro calculus ht 
argued pragmatic virtues calculus pt techniques develop applicable similar system 
course behavioral properties studied sections sensitive exact choice calculus particular partial confluence linear communications fails presence general choice operator 
provide booleans conditional expressions primitives typing behavior interacts linearity slightly special way 
syntax metavariable ranges multiplicities 
metavariable ranges polarities 
formally subsets set capabilities fi og readability abbreviations fi og fog fig fg 
set types channel types bool booleans example type bool fog bool describes channel exactly send message containing boolean bool describes channel input output 
brevity sequences types written tn type form called limited 
types unlimited 
example unlimited type bool bool describes channel send number messages components message boolean linear output channel 
set process expressions parallel composition output atom input prefix 
replicated input channel creation conditional avoid writing parentheses give higher precedence bodies inputs extend far right possible 
means 

inert process defined 
free bound variables process expression defined usual way having scope having scope 
type environments type environment set bindings distinct variables types containing bindings true bool false bool 
convention write type environments xn tn just omitting bindings booleans 
domain type environment written dom set variables binds 
type environments extended bindings new variables writing write mean type environment unlimited bindings consider process relative particular type environment domain contain free variables process 
regard names bound variables inessential perform silent alpha conversion necessary ensure name bound variable different names free variables bound variables 
operations types combination types written defined follows cases mentioned undefined bool bool bool similarly difference types written bool bool bool note necessarily type polarity remove single instance capability capability unlimited number times type bool unlimited channel type unchanged operation 
operator extended pointwise type environments equal domains add remove capabilities single existing binding environment 
write mean mean 
account effect value type write set type environment written comprises type environments obtained replacing subset xn tn bindings xn tn tn typing linear channel types inspired girard linear logic gir glt resource conscious refinement classical logic numerous proposals functional languages linear logic abr wad bak mac 
crucial element systems careful treatment typing environments expressions judged typed 
example form pair values type environment linear lambda calculus simply check typed hv wi split type environment parts representing resources consumed separately hv wi similarly linear type system pi calculus split type environment rule parallel composition par typing consumes sum resources proofs typed 
consider instances rule scheme defined 
typing judgement acquires additional force typed typing assumptions uses linear capability just 
linear type systems omit rule dereliction linear logic allows unlimited channel coerced linear 
type system subtyping relation similarly ban coercion 
worlds linear unlimited values allowed mix 
typing rules differ technical detail usual formulations linear logics type systems 
normally type environment split variable bindings right left subderivations included respective halves 
example check check 
find clearer split type environments removing just capabilities leaving variable bindings place combination operator applied environments equal domains 
type environment check 
ensure linear bindings environment get check leaves typing derivation instances typing rule output expressions remaining bindings current environment multiplicity polarity unlimited bindings unlimited typed augmented case linear capabilities consumed output 
note capabilities expressed types consumed output arguments passed receiver communication 
conversely input expression typed body typed environment capability input removed linear capabilities associated values read added 
rule replicated input nearly type unlimited body may instantiated times ensure common part type environment contain linear bindings 
unlimited 
rin rule expressions adds type type environment 
side condition verifies supplied type reasonable channel declaration bool type allow input output silly 
new rule checking conditional expressions little different corresponds additive operators linear logic rest operators belong multiplicative part 
know parts clause executed linear bindings environment parts allocated part 
bool typing relation relation closed foregoing rules 
process typed called process 
concerned algorithmic issues worth noting rules give rise typechecking algorithm fairly straightforward way 
guessing split capabilities environment rules par pass environment lefthand premise crossing capabilities passing left righthand premise 
cost associated checking unlimited side conditions simple tricks keep small practice 
operational semantics mil operational semantics processes steps 
define structural congruence relation capturing fact example order branches parallel composition effect behavior 
define reduction relation 
specifying processes evolve communications subprocesses 
structural congruence structural congruence plays important technical role simplifying definition reduction relation 
example intend process process reduce structurally congruent suffices write reduction rule case stipulate general contains possibility communication expression structurally congruent experts structural congruence relation identical usual drop garbage collection rules 
structural congruence rules state commutative associative 
assoc third rule called scope extrusion pi calculus literature free extr informally says scope channel starts private process extended include side condition ensures free channel named 
condition satisfied renaming necessary applying scope extrusion rule 
example process may transformed technical convenience allow adjacent channel bindings switched switch formally relation congruence closed rules meaning obtained applying rules number times direction arbitrary subexpressions lemma iff definition process pn normal form pn guarded processes process guarded input output replicated input conditional 
lemma process normal form proof associativity commutativity fact guarded input moved outside expression extr 
lemma processes pn qm normal forms structurally congruent permutation permutation qn proof structural congruence introduces eliminates guarded subexpressions bindings move subexpressions input prefixes 
reduction pi calculus reduction relation usually written 
meaning evolve making single atomic step communication 
basic relation annotate extra information need stating properties semantics 
write ff 
type environment remind interested reduction typed processes see way communication uses capabilities linear channels multiplicity tag recording communication leads occurs linear unlimited channel ff name channel indicating communication occurs special tag indicating channel communication occurs bound scope point 
important reduction rule communication 
environment channel type multiplicity parallel composition output input evolve body input process arguments output substituted formal parameters 
record arrow 

com similarly output parallel replicated input reduce appropriate instance body input plus fresh copy replicated input ready consume outputs 


reduce isolation placed parallel process ff 
ff 
par similarly reduces placed extra annotations divide rule cases 
channel bound channel communication occurred change label arrow change polarity type binding remainder effect changing polarity multiplicity linear effect multiplicity unlimited 


new hand communication occurs channel simply pass labels unaltered 
ff 
ff ff 
new expression reduces branch depending guard 
true 
ift false 
iff rearranged structural congruence laws communication possible communication possible ff 
ff 
cong want explicit typing environment force reduction occurred write ff 
ae ff ff label arrow binder channel communication occurred hand label remove instance type capabilities 
usual write 

show reduces zero steps 
type soundness sine qua non operational semantics typed language typedness preserved reduction 
theorem subject reduction ff 
operational semantics careful cross linear capabilities uses subject reduction theorem theorem implies linear channels addition standard observation arity mismatch execution typed program 
shorthand qg stand parallel composition process theorem run time safety typed process contains immediate possibilities communication failure misuse capabilities 
formally qf rg 
input ym zn replicated input ym 
zn binding polarity 
binding polarity including 

binding polarity including 

binding multiplicity 

binding multiplicity 


binding multiplicity 
worth mentioning type annotations labels semantics just bookkeeping play role determining possible behaviors typed process expressions 
theorem typed processes operational semantics allows reductions standard untyped semantics obtained erasing types type environments labels arrows 
partial confluence come results show linearity affects reasoning program behavior 
theorem says communication linear channel deterministic 
second says process contains possible communications linear channel may performed order reach result 
word linear reduction confluent respect reductions 
theorem 

theorem partial confluence ff 
fi fi 
ff 
fi 
proofs occupy rest section may safely skipped reading 
technical lemma 
lemma ff 
holds 
rg rg 

rg 
rg 
true rg rg 
false rg rg 
derivable cong 
proof fact cong new permuted rules successive applications cong combined cong 
proof theorem reduction rules 

lemma 
lemma assume loss generality normal forms obtain normal forms move outside 
lemma permutation rn guarded processes rn case happen form contradicts fact 
obtain similarly implies required 
proof theorem suppose ff 
fi 
come communications unreplicated inputs 
cases replicated input conditional similar 
assumption lemma binding 
assume loss generality normal forms 
assumption lemma linearity obtain lemma rn permutation rn ff 
fi 
strong bisimilarity final task formalize process equivalence presence linear types check equivalences claimed really hold 
adapt milner sangiorgi notion barbed ms san suited job reasons 
naturally relation typed processes crucial 
second fairly modular definition sense barbed different calculi formulated identically facilitates comparison helps give confidence definition natural 
varieties bisimilarity comes coinductive proof technique 
establishing basic theory strong bisimilarity section section extends results developed useful case weak bisimilarity 
basic definitions defining tests process external observer relative certain type environment 
definition say exhibits barb type environment written immediate possibility performing input output action channel type observer supply side communication case linear input output capabilities formally iff holds 
qg 
qg 
qg 
case assumption bound variables distinct names ensures channel experts note definition barbs agrees standard full pi calculus 
working asynchronous fragment output atoms output prefixes need allow observation inputs drop clauses definition obtain notion observation closer processes see 
conjecture theory developed rest affected change 
say processes bisimilar sets observable actions step step reach state bisimilar 
slight complication require processes typed exactly type environment linear communication removes capabilities type environment want allow possibility processes bisimilar may linear resources different orders 
deal allowing typed different environments provided environments obtained removing capabilities common environment 
formally define means arbitrary relation pairs processes associated type environments bisimulation 
processes said bisimilar related bisimulation 
recall set environments obtained changing bindings form 
definition strong barbed bisimulation relation bisimulation 
iff 

implies 


implies 
processes bisimilar written ffl bisimulation barbed bisimulation weak relation 
order interesting need close substitution parallel composition 
resulting relation called barbed congruence seen full congruence process constructors 
definition type environments substitution oe function dom dom dom type written dom oe unlimited intuitively substitution maps channels xn dom channel dom ensures combination capabilities congruence definition written substitution oe defined ffl oeq 
largest bisimulation closed typed substitutions parallel composition 
processes congruent written processes congruent typed type environment 
simple example easy check processes congruent environment 
congruent environment 
fortunately closing parallel composition substitution processes congruent placing process context yields congruent processes 
theorem congruence relation preserved process constructors 
weak bisimilarity usual definitions strong barbed bisimulation congruence useful somewhat complex counterpart called weak bisimulation drop requirement processes compared proceed lock step allow take zero steps match single step 
main result section example formalizes claim versions process behaviorally equivalent 
definitions definitions weak barbs weak bisimulation weak congruence obtained strong ones standard way 
weak barbs process strong barbs derivatives 
weak bisimulation ffl obtained replacing second 
clauses definition reflexive transitive closure 
weak precongruence congruence formed closing substitution parallel composition 
refined definitions read follows definition weak barbed bisimulation relation weak bisimulation 

iff 


implies 


implies 
processes weakly bisimilar written ffl pair weak bisimulation definition processes weakly written substitution oe defined ffl oeq 
processes weakly congruent written arguments follow convenient weak bisimulation prove processes bisimilar ffl directly 
definition weak bisimulation relation weak bisimulation 

iff 


implies 


implies 
processes weak bisimilar weak bisimulation lemma weakly bisimilar iff weakly bisimilar prove processes weakly barbed bisimilar hard compare weak barbs need consider possible reduction sequences 
theorem allows compare strong barbs weak barbs substantially simplifies proofs weak barbed bisimilarity 
barbs set strong barbs set weak barbs theorem relation weak bisimulation 
barbs barbs 

implies 


implies 
proof suffices show 
suppose 

barbs 
condition matching reduction sequence 
condition 
know 
similarly 
theorem congruence 
partial confluence linear reduction theorem expressed useful way theorem ff 
theorem essentially says linear reduction change weak precongruence class process show suffices show typed linear reduct 
case linear reduction just need show congruent 
lemma prove theorem 
lemma ff 
proof theorem suppose oe substitution defined 
oe ff 
oeq 
show ff 
ffl 

ff 
show weak bisimulation 
set definition weak bisimulation suffices check case 
ff 

show barbs barbs 
suppose ff 
conversely lemma ff 

consider reduction fi 
matched 
theorem ff 
fi 
reduction matched fi 


ff 

appears application apply foregoing theory show versions plus process weakly congruent 
processes nontrivial proof equivalence requires care introducing technical lemmas help structure argument 
lemma ffl ffl write mean dom dom 
lemma defined ffl example num num plusone num num versions plus process weakly congruent 
proof plusone num num num num theorem suffices show num plusone plusone side processes typed suffices show num plusone plusone substitution rename variables note bindings incompatible suffices show defined num plusone ffl plusone show num plusone plusone 
ffl weak bisimulation desired result follows num plusone plusone take pair num plusone plusone part check conditions theorem 
barbs num plusone barbs barbs plusone 
consider reduction num plusone possibilities reduction occurs inside interaction occurs num plusone 
case num plusone 
reduction matched plusone 
plusone case reduction occurs channel plusone plusone num reduction matched plusone 
num ffl plusone lemma implies num ffl lemma 
consider reduction plusone 
cases reduction occurs inside interaction occurs plusone 
case plusone 
matched num plusone 
num plusone argument case similar part 
conditions imply weak bisimulation related spur came takeuchi honda kubo describing modified pi calculus syntax guarantees certain channels shared just processes 
motivating intuitions calculus flavor type system suggesting achieve effect standard pi calculus introducing refined type system altering syntax 
fact earlier honda hon adopt type theoretic perspective related 
type system shares deal linear type systems lambda calculi related programming languages abr wad hod bak mac 
particular linear typing proposed framework syntactic control interference sequential programming languages cf 

world process calculi papers analyzing channel usage effect systems 
nielson nielson nn proposed method inferring maximum usages channels applying effect system cml nn kobayashi yonezawa proposed method approximating number receivers try read channel simultaneously particular detect channels maximum queue length 
type analysis effect analyses advantages disadvantages 
effect methods infer usage information currently type system checks consistency usage information 
hand approaches effect analysis channel usage analyzed respect regions may aliased infinite number channels degrading accuracy analysis 
kobayashi tried overcome defect degree resulting analysis difficult algorithmic aspects especially time complexity left open 
abramsky gay nagarajan agn gn describe typed calculus synchronous processes 
calculus ensures deadlock freedom expressive power limited sense exactly sender receiver channel mobility passing channels data channels expressed 
type system reminiscent explicitly incorporating notion linearity developed steffen nestmann sn purpose analyzing confluence pi calculus processes arising semantics concurrent object oriented programs 
problem tackled liu walker purely semantic techniques lw 
analysis related nie guarantee uniform confluence pi calculus fragment replicated inputs 
variants extensions focused fragment original polyadic calculus mil omitting output guards processes form choice operator 
type system reduction semantics easily extended full calculus results developed treated carefully 
example presence output guards example valid 
allow output guards nonlinear channels example remain valid 
similarly add choice calculus theorems hold recover allowing choice processes guarded nonlinear communications 
great variety resource aware type systems tracking different kinds usage information formulated similar techniques 
systems encoded simple system linear types 
trivial variant system obtained replacing linear affine channels exactly 
seen possible throw away linear channels placing deadlocked subprocess linear affine variants system nearly identical properties 
advantage affine variant allows garbage collection process typed context typed context 
interesting variant introduces type replicated channels arbitrarily output allow single replicated input 
communication replicated channels enjoys partial confluence property linear communication 
conjecture property show example fi reduction preserves weak congruence encoding call value calculus 
handle replicated channels formally introduce new multiplicity replacing augmenting linear multiplicity 
define operator new multiplicity modify side conditions rules rin follows unlimited 
rin variation linear channels linearized channels multiple times sequential manner output reuse output input reuse input linearized channels encoded linear channels recursive types 
write type linearized channels repeatedly carrying tuples type type encoded follows terms linear types linearized channel encoded linear channel carrying tuples types plus extra parameters channel trigger continuation output needed translating language output guards channel nearly type original linearized channel precisely type input original linearized channel replaces original continuation sender receiver 
input output expressions linearized channel encoded follows linearized channel types viewed variant fragment honda types dyadic interaction hon 
combining intuitions replicated linearized channel types yields important usage analysis milner calls unique handling mil channel uniquely handled single replicated receiver moment sender 
capability send explicitly passed client contention clients access service provided receiver 
course reason principle analyses distinguish zero arbitrarily uses channel just introduce additional multiplicities experimental testbed pict language benefits gained refinement profiling pict programs indicates great majority channels unboundedly linearly 
largely due fact functions literally compiled processes pict large number channels locations functions result channels 
applying type systems full scale programming language raises number pragmatic issues 
typechecking help programmer annotations partial type inference relatively unproblematic quite difficult add linear type information cluttering language extra distinctions programmer explicitly bear mind 
underway exploring issues linear variant pict 
kobayashi partially supported aid scientific research japan 
pierce supported epsrc gr 
turner supported epsrc gr save space linear types 
profited lively discussions robin milner phil wadler monday interruption club cambridge 
fournet gave useful comments earlier draft 
abr samson abramsky 
computational interpretations linear logic 
theoretical computer science april 
agh gul agha 
actors model concurrent computation distributed systems 
mit press cambridge ma 
agn samson abramsky simon gay nagarajan 
interaction categories foundations typed concurrent programming 
deductive program design proceedings marktoberdorf summer school nato asi series springer verlag 
bak henry baker 
lively linear lisp look ma garbage 
acm sigplan notices 
car luca cardelli 
amber 
guy cousineau pierre louis curien bernard robinet editors combinators functional programming languages pages 
springer verlag 
lecture notes computer science 
fg fournet georges gonthier 
reflexive chemical machine 
principles programming languages january 
gay simon gay 
sort inference algorithm polyadic calculus 
proceedings twentieth acm symposium principles programming languages january 
gir jean yves girard 
linear logic 
theoretical computer science 
glt jean yves girard yves lafont paul taylor 
proofs types volume cambridge tracts theoretical computer science 
cambridge university press cambridge 
gmp alessandro mishra prasad 
facile symmetric integration concurrent functional programming 
international journal parallel programming 
gn simon gay nagarajan 
typed calculus synchronous processes 
proceedings ieee symposium logic computer science 
hewitt 
viewing control structures patterns passing messages 
artificial intelligence 
hod hodas 
lolli extension prolog linear context management 
miller editor workshop prolog programming language pages philadelphia pennsylvania august 
hon kohei honda 
types interaction 
concur volume lecture notes computer science pages 
ht kohei honda mario tokoro 
object calculus asynchronous communication 
pierre america editor proceedings european conference object oriented programming ecoop volume lecture notes computer science geneva ch 
springerverlag berlin heidelberg new york tokyo 
jon cliff jones 
pi calculus semantics object design notation 
best editor proceedings concur lncs pages 
springer verlag 
naoki kobayashi akinori yonezawa 
static analysis communication asynchronous concurrent programming languages 
second international static analysis symposium sas volume lecture notes computer science pages 
springer verlag 
kpt naoki kobayashi benjamin pierce david turner 
linearity pi calculus 
technical report department information science university tokyo computer laboratory university cambridge 
ky naoki kobayashi akinori yonezawa 
foundations concurrent objectoriented programming 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla pages 
ky naoki kobayashi akinori yonezawa 
foundations concurrent object oriented programming types language design 
theory practice object systems john wiley sons 
appear 
lw liu david walker 
confluence processes systems objects 
proceedings caap pages 
springer 
lw liu david walker 
polymorphic type system polyadic calculus 
concur concurrency theory pages 
springer 
mac ian mackie 
functional programming language linear logic 
journal functional programming october 
mil robin milner 
functions processes 
research report inria sofia antipolis 
final version journal mathematical structures computer science 
mil robin milner 
polyadic calculus tutorial 
technical report ecs lfcs laboratory foundations computer science department computer science university edinburgh uk october 
proceedings international summer school logic algebra specification marktoberdorf august 
reprinted logic algebra specification ed 
bauer brauer schwichtenberg springer verlag 
mpw milner parrow walker 
calculus mobile processes parts ii 
information computation 
ms milner sangiorgi 
barbed bisimulation 
kuich editor th icalp volume lecture notes computer science pages 
springer verlag 
nie joachim 
functional computation concurrent computation 
principles programming languages january 
nn hanne riis nielson flemming nielson 
higher order concurrent programs finite communication topology 
proceedings popl st acm sigplan sigact symposium principles programming languages portland oregon pages january 
nn hanne riis nielson flemming nielson 
static dynamic processor allocation higher order concurrent languages 
tapsoft theory practice software development volume lecture notes computer science pages 
springer verlag 
ode martin odersky 
polarized name passing 
proc 
fst tcs lncs 
springer verlag december 
hearn power tennent 
syntactic control interference revisited 
mfps xi conference mathematical foundations program semantics volume electronic notes theoretical computer science 
elsevier march 
ps benjamin pierce davide sangiorgi 
typing subtyping mobile processes 
logic computer science 
full version appear mathematical structures computer science 
pt benjamin pierce david turner 
concurrent objects process calculus 
ito akinori yonezawa editors theory practice parallel programming sendai japan nov number lecture notes computer science pages 
springer verlag april 
pt benjamin pierce david turner 
pict programming language 
appear 
rep john reppy 
cml higher order concurrent language 
programming language design implementation pages 
sigplan acm june 
san davide sangiorgi 
expressing mobility process algebras order higher order paradigms 
phd thesis department computer science university edinburgh 
san davide sangiorgi 
investigation functions processes 
proc 
ninth international conference mathematical foundations programming semantics mfps volume lecture notes computer science pages 
springer verlag 
sn martin steffen uwe nestmann 
typing confluence 
bericht xx informatik vii universitat erlangen 
takeuchi kohei honda makoto kubo 
interaction language typing system 
proceedings parle pages 
springer verlag 
lecture notes computer science number 
tur david turner 
types polymorphism implementation 
forthcoming ph thesis lfcs university edinburgh 
david turner philip wadler christian mossin 
type 
functional programming languages computer architecture san diego california 
vas vasco vasconcelos 
typed concurrent objects 
proceedings eighth european conference object oriented programming ecoop volume lecture notes computer science pages 
springerverlag july 
vh vasco vasconcelos kohei honda 
principal typing schemes polyadic pi calculus 
proceedings concur july 
available keio university report cs 
wad philip wadler 
linear logic 
proceedings acm symposium partial evaluation semantics program manipulation pages 
wal david walker 
objects calculus 
information computation 
