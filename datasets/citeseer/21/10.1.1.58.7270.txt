dynamic tree cross products preprint marcus university passau passau germany marcus uni passau de 
range searching tree cross products variant classic range searching introduced buchsbaum 
proc 
th esa vol 
lncs pp 

tree cross product consist hyperedges connecting nodes trees 
td 
context range searching means determine hyperedges connecting set tree nodes 
buchsbaum describe data structure supports queries adding removing edges tree nodes remain fixed 
new data structure additionally provides insertion deletion leaves 
td combines approach novel technique search trees superimposed ordered list maintenance structures 
extra cost roughly factor log log log 
trees dynamic especially important maintaining hierarchical graph views problem modeled tree cross product 
views evolve large base graph contraction subgraphs defined recursively associated hierarchy 
graph view maintenance problem provide methods refining coarsening view 
previous solutions edges underlying graph dynamic application data structure node set dynamic 
motivation graphs network traffic graphs web graph biochemical pathways large display edit effectively 
established technique solve problem partition graph recursively hierarchy subgraphs 
complete road map europe instance large graph hierarchy defined grouping places roads city cities state 
city state needed full detail subgraphs contracted single meta node representing city state 
edges contracted subgraph nodes outside retained edges meta node outside place 
leads representation graph graph view convenient overview graph necessary details displayed simultaneously 
interactive scenario user choose subgraphs contract meta node expand replace subordinate subgraphs facilitates exploring editing large graph 
depending marcus admissible modifications hierarchy graph buchsbaum differentiate variants graph view maintenance problem static case graph hierarchy fixed dynamic graph variant graph edges inserted deleted dynamic graph tree variant graph additionally subject node insertions deletions hierarchy may change splitting merging clusters 
maintaining hierarchical graph views formulated terms general problem range searching tree cross products introduced 
tree cross product consists trees 
td set dimensional hyperedges 
ud ui ti 
context range searching means decide efficiently hyperedge subtrees tree nodes report hyperedges 
set hyperedges dynamic trees static generalize approach allow insertion deletion leaves 
tn 
formal definition problem data structure dimensional tree cross product described sect 
serves basis recursive description higher dimensional case sect 

sect 
introduce new dynamic leaves variant graph view maintenance problem compound graphs general model hierarchically structured graphs clustered graphs previous approaches 
formulated tree cross product problem solved efficiently data structure 
new dynamic leaves variant extends dynamic graph variant insertion deletion graph nodes leaves hierarchy 
contrast dynamic graph tree variant lacks splitting merging clusters 
adequate dynamic graphs fixed hierarchical structure network traffic graphs computers identified ip addresses edges represent traffic hierarchy structure ip addresses 
hierarchy fixed structure ip address change 
examples road maps biochemical reaction networks consist reactions organism hierarchy defined grouping reactions belong biochemical pathway acid cycle 
unable handle graphs dynamic node set previous solutions appropriate models applications 
range searching tree cross products rooted tree vertex set edge set 
node children denote set children parent parent descendants desc nodes subtree rooted rooted trees 
td consider partite hypergraph ti ti td 
define maxd depth ti 
tuple 
ud ti 
xd xi desc ui dynamic tree cross products set hyperedges descendants components see fig 
example dimensional tree cross product 
call tuple induced hyperedge induced hypergraph consists vertex set induced hyperedges ti 
example fig 
instance set contains edges empty yields induced edge 
defined tree cross product problem perform operations tuples ti determines induced determines set determines induced hyperedges 
uj uj 
ud children uj 
inserting deleting hyperedges data structure supports new operations adding removing leaves tj adds new leaf tj child node leaf tj removes hyperedges incident tj 
dimensional case share idea order nodes tree linearly tree node set desc fully determined min max smallest largest node subtree rooted clearly traversing tree post order yields order 
defined insert new leaf child insertions occur point linear order 
simply assigning consecutive integers nodes inefficient nodes new 
efficient data structures problem performing order queries ordered list subject insert delete operations 
assign numerical label integers elements making order query simple comparison labels 
efficient solution allows operations performed worst case time sect 

technique insertions deletions dense sequential files top level level data structure complicated simpler slightly efficient data structure suitable implementation 
example sect 
describe solutions amortized time insert delete worst case time order 
approach treat order maintenance component black box worst case solution time bounds theorems worst case 
addition need access successor predecessor node order 
part order maintenance structures separately maintain marcus doubly linked list nodes tree 
compare nodes corresponding order query 
keep list children tree node sorted respective order tree 
addition values min max store tree node symmetrically nodes desc nodes tree connected node subtree see fig 

defined set remove multiple entries node entry corresponds edge needs find 
node desc indicates edge desc node exists edge connects desc desc 
implemented checking desc 
fig 

example dimensional tree cross product 
dashed edges belong trees solid ones hyperedges 
need store set data structure insert delete efficiently supports successor operation succ succ returns smallest null element exists 
observe desc succ min max returns true succ min max 
maintain set balanced search tree respect order provided corresponding order maintenance data structure 
insert delete succ done log worst case time provided order operation worst case time 
additionally link leaves search trees facilitate operation 

balanced search trees contracted stratified trees cst sets 
improve time bounds insert delete succ log log log increase required space factor log log effects seen table 
cst stores subset fixed integer universe impractical sets subsets set tree nodes contrast dynamic tree cross products dynamic 
apart universe fixed integer labels order maintenance structures cst complicated insert operation nodes inserted possibly shifted get new number 
sets containing shifted node need updated 
table 
summary results comparison dimensional data structure bounds worst case 
max depth ti 
denotes size output 
bounds stated include additive terms unavoidable description 
approach data structure space log log log log log log log log log log log log log log log log log order efficiently perform operation see algorithm need determine ancestor node depth tree 
level ancestor problem studied static dynamic variant 
need add remove leaves dynamic data structure described 
preprocesses tree linear time space level ancestor queries adding leaves performed worst case time theorem 
deleting leaves explicitly mentioned obviously possible constant time simply deleting leaf 
space bound longer linear number tree nodes 
similar maintaining dynamic arrays rebuild data structure instance half nodes deleted 
takes amortized cost delete standard doubling technique distribute sequence operations operation worst case 
altogether approach combines idea novel technique search trees superimposed order maintenance structures 
previous data structure dynamic regard insertion deletion leaves slow operations roughly factor log log log tolerable see table 
marcus lemma 
data structure described takes md log worstcase preprocessing time uses md additional space 
proof 
edge contribute entry sets predecessor 
space needed sets md 
built follows edge inserted sets predecessor symmetrically predecessor 
md insert operations balanced search trees takes log 
additional space order maintenance data structures linear number elements contain preprocessing takes worst case time 
level ancestor structure preprocessed linear time space theorem 
lemma 
take log log worstcase time respectively number edges reported 
proof 
done checking succ min max 
set stored balanced search tree succ operation takes log worst case time 
finding edge reported essentially 
leaves search trees sets linked remaining edges discovered constant time 
implement appropriate collection operations general efficient algorithm similar 
simplifies description algorithm treats expansion component edge expanding second component works analogously 
algorithm input induced edge output children 
vk ordered list children repeat succ min max vk max set ancestor level children vk advance child vk max vk return lemma 
takes log worst case time number edges reported 
dynamic tree cross products proof 
loss generality assume case symmetric 

vk denote children ascending order linear order tree vk 
note children stored order need sorted 
start determine connected calculating succ min 
max reported max max vk ancestor children reported 
determine efficiently level ancestor data structure 
iterate procedure max vk see algorithm 
succ operation yields new result 
determining level ancestor takes constant time get log worst case time 
adding new edge insert predecessors predecessors conversely deleting edge remove 
predecessors yields lemma lemma 
take log time 
deleting leaf delete incident edges implicitly updates affected sets 
update order maintenance level ancestor data structures remove leaf tree 
predecessor possibly update values min max predecessor successor ordered list tree nodes 
inserting new leaf child node insert just max order maintenance structure 
add level ancestor data structure insert tree child inner node operation values min max remain correct 
leaf means max min equal set min may entail changes min values predecessors insertion deletion order maintenance level ancestor data structure take constant time yields lemma lemma 
deleting leaf incident edges inserting leaf performed time 
higher dimensions data structure described far maintains dynamic set pairs trees dynamic regard insertion deletion leaves 
provides retrieval operations 
give recursive description higher dimensional data structure dimensional case basis 
suppose data structure case maintaining hyperedges nodes trees 
dimensional data structure stores node set sd 
desc marcus hyperedges incident descendants 
disregarding component hyperedge separate dimensional data structure set sd 
words store dimensional hyperedges dimensional data structure projections components 
implement 
ud 
ud dimensional data structure stored 
query forwarded similarly edges returns correct dimensional result dimensional data structure contains original hyperedges 
operation 
ud implemented 
ud dimensional data structure node 
expanding hyperedge component build data structure designating tree instance 
theorem 
additional space data structure solves dimensional dynamic tree cross product problem worst case time bounds shown table 
proof 
case bounds table follow directly lemmas 
edge 
ud contributes entry lower dimensional data structure predecessor predecessor assuming tree designated second data structure 
entries induction entry uses space lower dimensional data structure gives total space 
inserting deleting edge implemented insert delete operation lower dimensional data structure predecessor dimensions takes log induction 
retrieval operations forwarded appropriate lower dimensional data structure recursion ends dimensional data structure operation implemented described sect 

get additional steps recursion 
inserting deleting leaf differ dimensional case 

compressed trees improve space bound 
tree edge parent light desc desc parent heavy 
compressed tree evolves contracting heavy paths respective topmost node 
technique employed maintaining subject insertion deletion leaves original tree straightforward 
problem modifications change status tree edges predecessors affected node light heavy vice versa 
compressed tree results adding removing inner node 
especially new inner node expensive equip new node appropriate data structures set 
reducing space bound compressed trees increases time bounds operations factor log log log 
trees stratified recursively improve time bounds 
unfortunately stratification dynamic tree cross products arguments faulty results stratification listed table 
maintaining hierarchical graph views compound graph ei ea consists nodes inclusion edges ei adjacency edges ea 
required inclusion digraph ei tree adjacency edge connects node descendants predecessors see figs 

view graph nodes desc desc nodes view related terms inclusion tree 
nodes connected induced edge nodes desc desc connected adjacency edge ea see fig 

fig 

example compound graph directed edges form inclusion digraph undirected ones adjacency edges ea fig 

compound graph fig 
depicted inclusion dashed rectangles fig 

view consisting darker shaded nodes compound graph figs 
compound graph view graph view maintenance problem efficiently perform operations expand replaces node children result view nodes children contract children contracts children result view nodes children 
new dynamic leaves variant problem compound graph subject modifications desc desc adds new adjacency edge ea removes adjacency edge marcus adds new node new inclusion edge child inclusion tree leaf inclusion tree removes compound graphs concepts extending graphs hierarchical structure clustered graphs popular consist base graph tree leaves exactly nodes base graph :10.1.1.58.6416:10.1.1.20.6336
consequently clustered graphs adjacency edges leaves inclusion tree compound graphs allow pair tree nodes descendant 
data structures maintaining views clustered graphs expand contract operations described static allow insertion deletion adjacency edges 
efficient data structures additionally support modifications node set left open problem 
providing insertion deletion leaves solve problem partially see detailed description directly applying ideas sect :10.1.1.2.3540
problem 
table summarizes results compares approaches 
graph view maintenance problem compound graphs reduced dimensional tree cross product see sect 

set interpret adjacency edge ea edge connecting 
clearly determining induced edge nodes directly map corresponding operations tree cross products 
inserting deleting leaves inclusion tree engenders operation 
expanding view node edge incident view determines children inheriting edge 
contracting view node straightforward children removed connected neighbors children theorem 
depth md additional space data structure solves dynamic leaves variant graph view maintenance problem worst case time bounds shown table 
proof 
opt children edges incident view number items added removed expand bounded opt view expanding similarly number items affected contract bounded opt 
traversing edges incident children find neighbors view resulting contracting children contract takes opt time 
expand bounded opt log expand edge incident see algorithm 
note yield edges children maintain edges separately list node tree 
edge stored exactly dynamic tree cross products table 
results comparison graph view maintenance problem 
depth min log opt children 
expand denotes view expanding bounds labeled exp expected worst case 
approach approach data structure space ms md log log md expand opt opt log log opt log contract opt opt opt exp log log log log exp log log log log list nearest common ancestor nodes uses additional space violate md space bound 
clearly takes additional time updating lists possible log bound inserting deleting edges 
bounds follow immediately theorem 
efficient data structure range searching tree cross products trees dynamic regard insertion deletion leaves 
summarized table approach compete extends 
far data structure tree cross products node set dynamic 
applying graph view maintenance partially solved dynamic graph tree variant open problem 
comparison summarized table shows solution matches static ones additionally provides insertion deletion graph nodes 
data structure dynamic graph hierarchy variant splitting merging clusters remains open problem 
acknowledgments adam buchsbaum enlightening discussions details valuable comments 
furthermore am grateful franz brandenburg christian falk schreiber suggestions 
marcus holm 
improved algorithms finding level ancestors dynamic trees 
proc 
th icalp vol 
lncs pp 

springer 
bender farach colton 
level ancestor problem simplified 
proc 
th latin vol 
lncs pp 

springer 
bender richard demaine farach colton 
simplified algorithms maintaining order list 
proc 
th esa vol 
lncs pp 

berkman vishkin 
finding level ancestors trees 
journal computer system sciences 
brandenburg forster pick schreiber 
exploration visualization biochemical pathways 
nger eds graph drawing software mathematics visualization pp 

springer 
buchsbaum 
personal communication 
buchsbaum goodrich westbrook 
range searching tree cross products 
proc 
th esa vol 
lncs pp 

springer 
buchsbaum westbrook 
maintaining hierarchical graph views 
proc 
th soda pp 

dietz 
finding level ancestors dynamic trees 
proc 
nd wads vol 
lncs pp 

springer 
dietz sleator 
algorithms maintaining order list 
proc 
th acm stoc pp 


feng cohen eades 
draw planar clustered graph 
proc 
st cocoon vol 
lncs pp 

springer 
harel 
visual formalisms 
comm 
acm 
harel tarjan 
fast algorithms finding nearest common ancestors 
siam journal computing 
lai eades 
graph model supports flexible layout functions 
technical report university newcastle 

library hierarchies graphs views 
proc 
th graph drawing vol 
lncs pp 

:10.1.1.2.3540
maintaining hierarchical graph views dynamic graphs 
technical report mip universit passau 
sugiyama misue 
visualization structural information automatic drawing compound digraphs 
ieee trans 
systems man cybernetics 
van emde boas 
design implementation efficient priority queue 
mathematical systems theory 
willard 
worst case algorithms inserting deleting records dense sequential files 
proc 
acm sigmod pp 

