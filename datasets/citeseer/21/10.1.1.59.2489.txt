research shown boilerplate code repetitive code traversing datatypes eliminated generic programming techniques available implementations haskell 
particularly intractable kind boilerplate code having names name binding fresh name generation 
reason difficulty operations data structures involving names usually implemented regular instances standard map fold zip operations 
nominal syntax alternative treatment names binding swapping operations equivalence capture avoiding substitution free variable set functions better behaved 
show nominal syntax techniques similar freshml provided haskell library called freshlib 
addition show existing generic programming techniques reduce amount code needs written new datatypes involving names binding short scrap 
categories subject descriptors programming languages language constructs features general terms languages keywords generic programming names binding substitution 
programming tasks statically typed programming language haskell complicated ought need write boilerplate code traversing user defined datatypes 
generic programming ability write programs datatype thought require significant language extensions external tools example generic haskell 
years shown authors great deal generic programming performed safely understood existing extensions haskell hinze peyton jones derivable permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp september estonia 
copyright acm 

scrap functional pearl james cheney university edinburgh edinburgh united kingdom inf ed ac uk type classes mmel peyton jones scrap boilerplate approach entirely haskell hinze generics masses :10.1.1.1.3176:10.1.1.6.3741
techniques possible eliminate forms boilerplate code 
form boilerplate especially annoying shall call code deals names fresh name generation equality safe renaming free variables substitution 
code accomplish tasks usually straightforward trivial apparently written datatype basis 
main reason capture avoiding substitution equivalence usually written uniform instances map fold zip 
cases straightforward cases involving variables name binding require special treatment 
despite fact involves writing lot repetitive classical order approach programming syntax names binding popular practice 
class alternatives name free techniques de bruijn indices bound names encoded pointers numerical indices 
effective practical implementation compilation technique approaches tricky implement hard non experts understand provide special assistance open terms fresh name generation exotic forms binding pattern matching constructs functional languages 
tasks inlining name free approaches require implementation effort efficient name approaches 
alternative higher order syntax technique encoding object language variables binding forms variables binding forms metalanguage 
advantages efficient implementations equivalence capture avoiding substitution inherited metalanguage low level name management details including sideeffects hidden freeing programmer focus high level problems 
powerful approach interesting programming tasks involving higher order syntax require higher order unification common higher order logic programming languages prolog functional languages haskell particular 
higherorder syntax haskell require significant language extensions 
name free approaches higher order syntax provide special support programming open terms fresh name generation exotic forms binding 
third alternative advocate nominal syntax swapping approach syntax bound names introduced gabbay pitts employed freshml prolog languages 
approach retains advantages order syntax providing systematic support equivalence fresh name generation 
shall show nominal syntax implemented directly haskell type classes definitions functions substitution free variables generated automatically user defined types 
nominal syntax generic programming techniques fruitfully combined provide convenience higher order syntax sacrificing expressiveness order syntax language extensions needed generic programming haskell 
purpose show scrap combining nominal syntax existing generic programming techniques available haskell implementations ghc 
illustration develop small library called freshlib freshml style programming nominal syntax haskell 
main technical contribution previous freshml showing generic programming techniques available ghc eliminate implementing capture avoiding substitution free variables computations 
implementation uses advanced features currently ghc believe technique applicable situations 
remainder structured follows 
section provides high level overview examples freshlib user point view emphasizing fact library just works user needing understand nominal syntax generic programming priori obliged write boilerplate code 
section introduces key concepts nominal syntax describes initial type class implementation freshlib 
section shows freshlib completely generic hinze peyton jones derivable type classes mmel peyton jones scrap boilerplate class section technical relies heavily familiarity mmel peyton jones casual readers may prefer skip reading 
section discusses extensions handling user defined name types alternative binding forms 
section section discuss related conclude 

freshlib overview examples freshlib basics nominal syntax assumed special data types names 
freshlib provides data type name string valued names optional integer tags data name name string int instances eq show standard classes 
convention user provided names written tag names generated freshlib written tagged 
ingredient nominal syntax assumption types involved syntax trees possess equivalence relation addition functions casual user doesn need know class nom bool members discussed section datatype involving names name binding needs instance nom freshlib provides instances name abstraction constructor see haskell built types constructors 
generic instances user defined datatypes derived automatically 
result library user needs provide instances nom default behavior desired implementing datatype exotic binding structure section 
addition freshlib provides type constructor name abstractions data binding structure data syntactically just pairing 
name instance nom name special meaning represents elements bound name 
provided instance declarations nom name define equivalence equivalence safe renaming bound names 
example true false false true types name treated binders stick name bindings discuss section 
name types meant incorporated user defined datatypes syntax trees involving names binding 
give examples section section 
important component nominal syntax ability generate fresh names 
haskell way accomplishing monad 
fixing probably specific monad forcing users freshlib freshlib provides type class freshness monads rename existing names fresh ones class monad name name application freshness monad provide monadic destructor name bound name name name freshml pattern matching abstraction constructor automatically name bound abstraction need destructor explicitly names 
addition providing equivalence freshlib provides type classes subst freevars perform substitution calculate sets free names class subst name class freevars fv name intuitively subst provides substitution function replaces variables type similarly freevars provides function calculates list free variables type note subst may need generate fresh names substituting abstraction need freshness monad freevars fresh name generation needed need specify type free variables seek 
appropriate instances subst freevars name built datatypes provided 
hide constructor haskell module system export constructor abs destructor abstractions unpacked 
force require computation take place monad unnecessary 
reason current version freshml provides ways pattern matching abstractions 
explicit type passing allowed haskell simulated passing dummy argument type example undefined module lam import freshlib data lam var name app lam lam lam name lam deriving nom eq show instance lam var var just var 
free implementation lam cbn eval lam lam cbn eval app cbn eval case lam cbn eval return app cbn eval return 
call name evaluation note substitution free variable sets completely type directed calculations need know structure case 
specifically need know extract name variable type freshlib provides class providing function var tests value variable extracts name class var name instantiated instances subst freevars derived automatically 
freshlib provides instance name name considered variable replaced name 
example fv name function evaluates monadic expression particular fm 
recall names form names freshly generated lambda calculus consider worn example implementing syntax equivalence capture avoiding substitution free variables functions untyped lambda calculus 
idealized haskell code shown needed freshlib 
consider equivalence lam terms lam var lam var true lam lam var lam lam var false lam lam var lam lam var true examples substitution var lam var lam var var lam lam var white lies discuss section 
module import freshlib data type varty name type type name type deriving nom show eq data term var name app term term lam type name term name term term type deriving nom show eq instance type var varty just var instance term var var just var 
free polymorphic lambda calculus freshlib lam lam var note example capture avoided renaming second substitution effect equivalence free term 
examples fv fv lam lam app var var fv lam app var var show call name evaluation implemented freshlib built substitution operation 
small example cbn eval app lam lam app var var var lam app var var polymorphic lambda calculus example illustrates correct handling simplest possible example involving type kind names real languages involve multiple types different kinds names 
consider involved example polymorphic lambda calculus system names may term variables type variables 
freshlib code shown 
examples varty varty varty varty varty varty false true addition indicated instances type variable constructor varty term variable constructor var appropriate implementations fv provided 
tm lam varty app var var fv term tm fv type tm class name name type name bool name type string type varty return unbound variable abs ty abs ty type type ty ty ty ty return type expressions differ type type type ty ty return ty ty expected function type type name type abs return abs expected forall type 
type formedness utility functions term type var ty case ty just ty return ty unbound variable app ty ty ty ty return lam ty abs abs ty ty return ty ty tm ty ty tm ty abs ty ty abs ty ty abs tm abs ty tm return ty 
type checking polymorphic lambda calculus fv name tm varty tm lam var app var var var tm lam varty app var var give complete implementation type checking 
terms type annotated type checking wholly syntax directed 
shows monadic interface typechecker type formedness utility functions shows type checker proper 
thing missing instance details implementation say tcm particularly enlightening omitted 
quick example inferring type lam varty varty lam varty app var var varty varty varty varty stress code complete freshlib program 
boilerplate code whatsoever needs written program count instantiating 
hand just type name names implementation allows nonsensical expressions formed blur distinction type variables term variables 
fixed allowing multiple name types 
return issue section 
record calculus final example sketch syntax simple record calculus untyped fragment part challenge implemented freshlib 
calculus provides record constructors 
ln en field lookups pattern matching patterns consist pattern variables record patterns 
ln pn 
record expressions record patterns labels distinct patterns variables distinct 
pattern variables considered bound represent syntax augment lam type follows data lam 
rec label lam deref lam label lam pat lam data pat pvar name prec label pat constructor encodes syntax 
far special meaning name 
fact freshlib provides type class btype types bound left hand size abstraction 
provide desired behavior pattern binding need instantiate btype pat 
internal workings btype class implementation instance btype pat deferred section 
technique automatically equate expressions patterns reordering labels record expressions behavior provided suitable specializations nom btype eq 

implementation type classes section show approximation freshlib implemented type classes haskell 
implementation section requires liberal amounts boilerplate userdefined datatype boilerplate eliminated advanced generic programming techniques shall shown section 
names nominal types described earlier name consists strings optional integer tags data name name string int aforementioned convention user provided names untagged helps avoid collisions names generated freshlib 
enforced making name 
key ingredient nominal syntax glossed earlier assumption types interest possess name swapping operation exchanges names value freshness operation tests name appear free value 
operations building blocks formalize equivalence particularly convenient way particular necessary define equivalence terms capture avoiding renaming fresh name generation 
nom type class includes functions class nom trans perm foldr name bool bool types data trans name name type perm trans indicate pairs lists pairs names considered transpositions permutations respectively 
notation indicates transposition swapping names note permutation application function just applies transpositions list right left convenient btype class section 
obviously instance nom name needs spell name swapping freshness equivalence behave names instance nom name provide number instance declarations built datatypes type constructors 
base types functions trivial built type constructors lists pairs just proceed recursively instance nom int true instance nom nom map map zip instance nom nom nom 
abstraction types far types discussed binds names 
consider type constructor name abstractions values bound name 
recall abstraction type defined data structurally just pair provide instance declaration nom name gives special meaning instance nom nom name swapping purely structural freshness equivalence 
particular name fresh abstraction bound immediately fresh body abstraction 
similarly abstractions equivalent literally equal name bound side fresh body side bodies equal modulo swapping bound names 
definition equivalence studied gabbay pitts shown equivalent classical definition earlier swapping definition mckinna pollack formal verification properties calculus 
key advantage point view haskell programming classical definition definition require performing fresh name generation capture avoiding renaming tandem equivalence testing 
result type equality function nominal syntax trees 
freshness monads ability swap names test freshness equivalence applications 
example define substitution need able choose fresh names substitutions safely pushed inside abstractions 
haskell name generation usually performed monad 
fact different applications parsing typechecking code generation typically employ different monads 
example unusual single monad maintaining typechecking evaluation environment generating fresh names 
purposes need know generate fresh names 
define type class freshness monads cf 
section computation involving choice fresh names take place 
class monad name name functions capture avoiding substitution parameterized freshness monads needing specialized particular 
define monadic destructor unpacking abstraction bound name name name return provide default freshness monad fm simply maintains integer counter data fm fm int int instance monad fm omitted instance fm fm name just fm fm capture avoiding substitution free variables show implement type classes substitution calculating sets free variables 
subst recall class definition class subst name provide instances built types 
cases substitution commutes existing structure 
note renaming needs performed cases 
instance subst int return instance subst subst mapm instance subst subst subst return 
provide instance subst name name name substituted name 
instance subst name name provide instance abstractions know substitute substitute name bound name 
instance subst subst name abs abs return class freevars defined follows class freevars fv name explained section type parameter realized dummy argument undefined needed typechecking hint 
implement basic cases built types instance freevars int fv instance freevars freevars fv foldl union map fv instance freevars freevars freevars fv fv fv provide instance freevars name name instance freevars name name fv name abstractions compute free variables body filter bound name instance nom freevars freevars name fv fv note approach class 
result instances subst freevars user defined datatypes provided 
instances special behavior cases involving variables type cases straightforward recursion steps see 
instance nom lam var var app app lam abs lam abs var app lam abs abs var var app app lam abs lam abs abs abs instance subst lam lam var return return var app return app lam abs abs abs return lam abs instance freevars lam lam fv lam var fv lam app fv lam fv lam fv lam lam abs fv lam abs 
code lam limitations approach described working type class implementation freshlib culminating definitions capture avoiding substitution free variable sets cases automatically provided 
far approach simply reorganized written new user defined datatype involving names binding 
reorganization code reuse convenience benefits example override reuse fv notations don write trivial cases pushing substitutions inside lists pairs datatypes remaining cases need written uniform tricky case provided freshlib 
code simpler write just boilerplate new datatype 
fact may write code nom needs instantiated user defined datatypes 
example shows additional code write implement equivalence substitution free variables lam type type class version freshlib 
fortunately existing techniques applied nom turns perfect example derivable type class fv examples generic monadic traversals generic queries approach 
section describe freshlib completely generic suitable instances nom subst freevars derived automatically datatypes built standard types constructors name 

implementation generic programming employ different approaches scrap remaining freshlib 
derivable type classes provide generic default definitions methods nom class nom trans unit unit unit inl inl inr inr name bool unit unit true inl inr bool unit unit unit true inl inl inr inr false 
nom derivable type class suitable user defined datatypes 
unfortunately approach subst freevars employ latest version mmel peyton jones scrap boilerplate library 
particular essential innovation supports modular generic traversals traversals special cases provided type class instances 
possible previous versions 
warning 
section especially section depends heavily derivable type classes new version library 
papers probably prerequisite understanding section 
details mastered casual users freshlib 
nom derivable type class derivable type class called generic class ghc documentation may specify default behavior class method induction structure type expressed terms generic unit types unit sum types product types instantiate derivable type class particular type constructor write structural description type existing type constructors unit units sums products type level abstraction recursion 
example structure lam type name name structure list type constructor unit 
derivable type class declaration specialized type structural type description 
provided cases unit declaration corresponding cases type type level recursion translated term level recursion type level abstraction translated class dependences instance declarations 
generic functions purely structure driven specialized behavior provided usual providing appropriate type class instances 
instances take precedence default instance provided derivable type class declaration 
empty instance provided default behavior inherited 
nom turns prime example derivable type class 
shows define nom derivable type class methods derived automatically user defined datatypes simply providing empty instance nom 
example lam declaration specializes exactly instance nom lam 
list type constructor default instance declaration nom nom essentially shown section 
behavior nom built types int char special freshlib types name provided instances section changes needed 
subst freevars modular generic traversals derivable type classes nom help scrap remaining boilerplate involved subst freevars 
reason classes take multiple parameters multiple parameter derivable type classes supported ghc 
classes provide behavior constructor dependent just type dependent 
derivable type classes function behavior dependent structure argument type suitable writing functions different behavior different constructors type 
possible solution powerful generic programming system generic haskell allow generic functions display constructor dependent behavior 
users freshlib need familiar generic haskell 
approach supports constructor dependent generic functions mmel peyton jones library :10.1.1.6.3741
approach provides powerful facilities generic functions traverse data structure generically special cases 
assume familiarity approach rest section 
capture avoiding substitution example generic traversal original library 
na approach implement lam specific substitution function generic monadic traversal lifting function works datatype name lam lam lam var return return var return name lam mkt course implements capturing substitution want 
natural thing try monadic define function gives behavior substitution abstractions performing extension function ext scrap boilerplate extend bound names appropriately 
unfortunately approach quite 
reason function needs know type body nom just data polymorphic generic traversal 
way solve nom superclass data unsatisfactory data part library 
approach disadvantages example repeat tricky admittedly shorter definition substitution user defined type worse definitions modified added new binding types 
fact examples general limitations library 
observed mmel peyton jones original approach related disadvantages relative type classes 
generic functions closed extended defined type classes open extended interesting behavior new datatypes providing instances 
second generalize completely polymorphic functions form data type specific behavior possible cast behavior particular generalize functions rely knowing instance class data 
result style generics powerful lack modularity advantages type classes integrated existing type class libraries easily 
mmel peyton jones developed new version addresses problems essence parameterizing data type class type class elements data assumed belong form parameterization allowed haskell proper may simulated ghc extensions technique due hughes 
refer current library 
implement fv datatype basis 
case definition fv essentially variable constructor 
ideally able parameterize definitions fv constructor 
haskell course allow kind parameterization simulate type class class var name implement subst freevars shown 
mmel peyton jones code contains white lies class parameters data explicit type arguments gfoldl hide details actual encoding haskell 
real version available online code change match modifications library evolves 
instance declaration subst specifies default behavior 
types substitution just proceeds structurally monadic traversal combinator 
white lies mentioned earlier picture painted freshlib section little unrealistic 
underlying generic programming techniques freshlib progress 
describe cosmetic differences idealized code section current implementation freshlib user defined datatype freshlib depends extensions haskell ghc 
declarations need added ghc source file making freshlib options exts options undecidable instances options overlapping instances options options fth need import parts library import import basics import derive nom derivable type class haskell built derivable type classes builtin classes eq ord permitted deriving clause 
write homepages inf ed ac uk freshlib html available www cwi nl ralf instance data subst subst subst instance data subst subst var just return subst 
substitution modular generics instance data freevars freevars fv gfoldl freevars fvs fvs fv instance data freevars freevars fv case var just gfoldl freevars fvs fvs fv 
free names modular generics data deriving nom 
automatically derive nom need write empty instance instance nom generic order instantiate derivable type class nom cosmetic difference noted earlier haskell support explicit type parameters writing 
type parameter passing coded haskell dummy arguments ascription writing undefined 
latest version library relies template haskell derive instances library data typeable classes need write template haskell directive derive changes introduce fixed overhead file user defined datatype 
changes minor expected disappear versions ghc support added modular version library 

extensions integrating type classes subtle problem arises wishes define directly equivalence having write additional boilerplate code 
early version freshlib nom contained 
defined equivalence nature take course instances defining instance eq nom eq name unsatisfactory discussed earlier nom mentioned deriving clause eq mentioned dependent nom type containing 
explicit boilerplate instance eq lam provided nom lam instantiated instance nom lam generic instance eq lam var var boilerplate cases get rid boilerplate put nom specific version equality nom provide line instantiation eq desired 
integrate nom existing type classes example provide instance ord compatible equivalence put additional nom specific versions members nom 
prefer able original modular approach possible derivable type classes deriving clauses 
user defined name types freshlib provides size fits type string valued names name types 
wish names carry information string example symbol table location information namespace information pointer variable value 
addition single name type names lead subtle bugs due names kind shadowing capturing names kind 
example haskell ordinary variables type variables separate confusion resulting type term variable 
doing freshlib leads disaster lam var varty lam var varty false term level binding lam captures type variable desired behavior avoid take care ensure term type variable names distinct 
different name types type term variables rule kind bug 
way support names arbitrary types parameterize name types type data carried names data name name int type trans name name type perm trans class nom trans name bool 
immediate difficulty doing old instance nom name instance name string type reason need provide functions trans name name name name bool case behavior want non parametric type swap names test inequality swapping effect freshness holds 
adequate probably inefficient solution require typeable test type dynamically cast class nom typeable trans typeable name bool bool instance typeable eq nom name case cast just case cast just true instances nom basic datatypes unchanged 
necessary cast testing freshness instance typeable eq nom nom name case cast just false subst freevars classes need modified slightly essentially unchanged 
possibility type name parameterize nom classes problems 
ghc support multi parameter generic type classes second avoid variable capture important knows kinds names just particular kind 
approach suggested problem name name parametric user defined binding forms name abstraction type name wide variety binding situations situations awkward 
example bindings typed quantifiers binding transitions calculus represented name representation requires rearranging natural syntax example forall 
provide better support forms binding provide instances allow binding types name 
code permits binding name value pair data instance nom nom nom name encode binding typed quantifiers forall 
addition custom instances subst freevars needed difficult derive 
exotic binding forms calculus binding transitions handled similar fashion defining customized instances nom subst freevars 
common forms binding handled name examples include binding list names list parameters function binding names domain typing context considered equal renaming variables bound binding names pattern matching case considered equal renaming bound variables binding mutually recursive names recursive 
case wish simultaneously bind unknown number names appearing value 
sketch general mechanism making type allowing left side 
type need able tell names bound value values equal permutation names 
introduce type class types class nom btype bv name perm member bv computes set names bound btype second tests values equal permutation returns permutation exists 
provide general instance nom instance btype nom nom bv case just bv bv false equivalence test checks bound data structures equal permutation checks names bound left hand side right hand side fresh body right hand side checks permutation synchronizes bound names synchronizes bodies 
natural complicated generalization equivalence single bound name 
class instance substitution calculate names bound left hand side generate fresh names rename bound names fresh names 
class instance free variables subtracting singleton list subtract bv 
details omitted 
example contexts newtype ctx ctx name type implementing bv map fst function constructs simplest permutation ctx ctx exists 
similarly pattern binding implemented providing corresponding functions patterns 
note replace earlier instances nom name nom name providing instance declarations instance btype name bv just instance btype nom btype bv bv promised show implement syntax pattern matching sketched section follows instance btype pat bv pvar bv prec bv prec xs bv bv xs pvar pvar just prec prec just prec prec prec prec return note implementation assumes enforce labels pattern variables distinct expressions patterns need excluded manually 
unfortunately combining user defined name types userdefined binding forms appears nontrivial 
currently working combining extensions 
nominal generic functions capture avoiding substitution free variables sets just possible interesting generic operations syntax names 
examples include linear subterm orderings conversion name free encodings de bruijn indices binary formats syntactic unification randomized test generation quickcheck 
library appears possible define nominal versions gfoldl gmap gzip combinators data names default passing name abstraction 
approach interesting generic functions ones considered expressible nominal generic traversals queries 
leave exploration possibility 
optimizations substitution free variable computations basic operations need efficient 
currently freshlib written clarity efficiency particular follows hammer approach bound names renamed subterms visited capture avoiding substitution 
haskell builtin sharing laziness optimizations offer assistance faster techniques dealing substitution known plan investigate supported freshlib 
minor optimizations easy incorporate 
example implementation substitution traverses term easily modify instance declaration subst name substitution early detect name substituting bound 
similarly improve efficiency simultaneous substitution fv efficient set data structures 
possible optimization rapier approach capture avoiding substitution ghc inliner described peyton jones marlow section 
approach set variables scope computed simultaneously capture avoiding substitution fresh names generated monad hashing set names guess name high probability scope 
approach substitution pure function monads name generation avoided 
hand hashing step may need repeated fresh name 
parallelization order fresh names generated usually effect results computation theoretically substitution operations reordered performed parallel 
mind fine grained approach parallel programming gph 
classical approach sideeffects hides optimization opportunities fresh names generated sequentially 
approach substitution performed parallel long separate threads generate distinct fresh names 
way replace single threaded freshness monad split source fresh names disjoint parts 
example fresh names generated technique augustsson fresh name source infinite lazy tree split disjoint fresh name sources needed 

related freshml important source inspiration 
source logic programming languages prolog qu prolog provide capture avoiding substitution built operation defined structure terms 
aware implementations functionality haskell library essentially idea type classes provide swapping freshness equivalence 
alternative attempts aware include roughly functionality discussed half section generic programming consider substitution free variable set computations 
sheard library particular inspired treatment freshness monads user defined binding forms 
urban isabelle hol axiomatic type classes develop formalization lambda calculus 
techniques generic programming nominal syntax may relevant setting 
pottier developed ml source source translation tool ocaml converts high level type specification including generalization freshml name abstraction types 
interestingly approach provides advanced declarative support exotic binding forms including letrec 
ml capture avoiding substitution built easy implement overriding visitor operation syntax trees provided automatically 
evidence nominal syntax compatible variety generic programming techniques just provided ghc 
advantage implementing nominal syntax language extension freshml prolog library built equality equivalence name generation treated side effects nondeterminism languages capture avoiding substitution pure function observable side effects equivalence 
language extensions advantage providing userdefined name types straightforward lack support probably biggest gap freshlib 
freshlib provides fewer static guarantees flexible important respects example possible users define binding forms section 
advantage freshlib underlying representations names accessible example names ordered keys efficient data structures freshml prolog allowed swapping invariant ordering names 
large literature efficient representations terms implementations capture avoiding substitution variety settings example explicit substitutions optimal reduction dags 
plan attempt integrate techniques freshlib 
mmel proposed generic programming particular generic traversals basis refactoring tools tools automatic user controlled program transformation 
technique refactorings described high level generality instantiated particular languages describing syntax binding structure 
approach common btype classes interested exploring connection 
important difference refactoring renaming fresh name generation expected performed user 
refactorings simply fail name clash detected freshlib needs able generate fresh names automatically situations 
freshlib approach lightweight powerful way incorporate novel features freshml inside haskell 
particularly suitable prototyping rapid development educational purposes 
suitable real haskell programs 
optimistic way reconciling efficiency modularity transparency important direction 
development may help respect chakravarty extension haskell type classes support associated types 
speculate associated types may useful providing better support user defined name binding types freshlib 

shows developments active research areas generic programming nominal syntax fruitfully combined provide advanced capabilities programming syntax names binding haskell 
nominal syntax functions comparing terms renaming calculating set free variables term safely substituting term variable regular definitions regular fact expressed generic programming techniques supported extensions haskell derivable type classes library 
definitions provided library developed proof concept library called freshlib 
code chores equivalence substitution free variables provided freshlib having learn nominal syntax generic programming master external generic programming tool 
ability provide capture avoiding substitution built operation cited main advantages higherorder syntax approaches 
shown presence generic programming techniques advantage shared nominal syntax 
addition approach provides exotic forms user defined binding including pattern matching binding forms 
contrast name free higherorder syntax techniques provide special assistance kind binding 
hand focused clarity efficiency 
optimization techniques hope incorporated freshlib 
fact freshlib works encouraging suggests nominal syntax higher order syntax sensible highlevel programming interface names binding 
remains determined interface higher order syntax implemented efficiently 
believe freshlib promising step efficient generic library 
acknowledgments wish ralf mmel simon peyton jones answering questions new scrap boilerplate library associated 
wish tim sheard sharing freshml haskell library ideas incorporated freshlib 
supported epsrc 
glasgow parallel haskell june 
www macs hw ac uk dsg gph 
abadi cardelli 
curien 
vy 
explicit substitutions 
journal functional programming 
andrea asperti stefano 
optimal implementation functional programming languages 
cambridge university press 
lennart augustsson mikael dan 
generating unique names 
funct 
program 
brian aaron bohannon matthew fairbairn nathan foster benjamin pierce peter sewell dimitrios geoffrey stephanie weirich steve zdancewic 
mechanized metatheory masses challenge 
proceedings eighteenth international conference theorem proving higher order logics tphols 
appear 
manuel chakravarty gabriele keller simon peyton jones simon marlow 
associated types class 
popl proceedings nd acm sigplan sigact symposium principles programming languages pages new york ny usa 
acm press 
cheney urban 
alpha prolog logic programming language names binding alpha equivalence 
proc 
th int 
conf 
logic programming iclp number lncs pages 
koen claessen john hughes 
quickcheck lightweight tool random testing haskell programs 
proceedings acm sigplan international conference functional programming icfp pages 
acm 
de bruijn 
lambda calculus notation nameless dummies tool automatic formula manipulation 
mathematicae 
gabbay pitts 
new approach syntax involving binders 
giuseppe longo editor proceedings th annual ieee symposium logic computer science pages washington dc 
ieee ieee press 
gabbay pitts 
new approach syntax variable binding 
formal aspects computing 
ralf hinze 
generics masses 
icfp proceedings ninth acm sigplan international conference functional programming pages new york ny usa 
acm press 
ralf hinze simon peyton jones 
derivable type classes 
graham hutton editor proceedings acm sigplan haskell workshop volume electronic notes theoretical computer science 
elsevier 
hughes 
restricted data types haskell 
meijer editor proceedings haskell workshop number uu cs technical report utrecht university department computer science 
simon peyton jones simon marlow 
secrets glasgow haskell compiler inliner 
journal functional programming july 
ralf mmel 
generic refactoring 
proc 
third acm sigplan workshop rule programming rule pittsburgh usa 
acm press 
pages 
ralf mmel simon peyton jones 
scrap boilerplate practical design pattern generic programming 
proceedings acm sigplan international workshop types language design implementation pages new york ny usa 
acm press 
ralf mmel simon peyton jones 
scrap boilerplate reflection zips generalised casts 
icfp proceedings ninth acm sigplan international conference functional programming pages new york ny usa 
acm press 
ralf mmel simon peyton jones 
scrap boilerplate class 
benjamin pierce editor proceedings th international conference functional programming icfp estonia 
andres johan jeuring editors 
generic haskell user guide version coral release 
technical report uu cs utrecht university 
conor mcbride 
order unification structural recursion 
journal functional programming 
james mckinna robert pollack 
lambda calculus type theory formalized 
autom 
reason 
nadathur miller 
higher order logic programming 
gabbay hogger robinson editors handbook logic artificial intelligence logic programming volume chapter pages 
oxford university press 
frank pfenning conal elliott 
higher order syntax 
proc 
acm sigplan conf 
programming language design implementation pldi pages 
acm press 
pitts 
nominal logic order theory names binding 
information computation 
pitts gabbay 
metalanguage programming bound names modulo renaming 
backhouse oliveira editors proc 
th int 
conf 
mathematics programme construction mpc number lecture notes computer science pages ponte de lima portugal july 
springer verlag 
fran ois pottier 
overview ml june 
available inria fr pdf 
tim sheard march 
personal communication 
tim sheard simon peyton jones 
template meta programming haskell 
haskell proceedings acm sigplan workshop haskell pages new york ny usa 
acm press 
pitts gabbay 
freshml binders simple 
proc 
th acm sigplan int 
conf 
functional programming icfp pages uppsala sweden 
acm press 
olin shivers mitchell wand 
bottom reduction dags 
sagiv editor proceedings th european symposium programming esop number lncs pages 
staples robinson paterson hagen wallis 
qu prolog extended prolog meta level programming 
harvey abramson rogers editors meta programming logic programming chapter 
mit press 
urban pitts gabbay 
nominal unification 
theoretical computer science 
urban 
nominal techniques isabelle hol 
proceedings th international conference automated deduction cade 
appear 
phil wadler andrew pitts koen claessen september 
personal communication 
