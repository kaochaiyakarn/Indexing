test input generation java pathfinder willem visser riacs nasa ames research center moffett field ca usa email arc nasa gov show model checking symbolic execution generate test inputs achieve structural coverage code manipulates complex data structures 
focus obtaining branch coverage unit testing core methods red black tree implementation java treemap library java pathfinder model checker 
different test generation techniques introduced compared straight model checking code model checking black box fashion generate inputs fixed size lastly model checking white box test input generation 
main contribution show efficient white box test input generation done code manipulating complex data account complex method preconditions 
categories subject descriptors software engineering testing debugging symbolic execution general terms algorithms verification keywords testing object oriented programs model checking symbolic execution coverage red black trees 
software testing commonly technique validating quality software labor intensive process typically accounts half total cost software development maintenance 
automating testing reduce cost producing software increase reliability modern software 
report national institute standards technology estimates software failures currently cost economy year improvements software testing infrastructure save third cost 
automated test case generation studied literature see section focused generation test inputs containing simple permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
issta july boston massachusetts usa 
copyright acm 
corina kestrel technology nasa ames research center moffett field ca usa email arc nasa gov khurshid ut arise university texas austin austin texas usa khurshid ece utexas edu unstructured data 
ll address problem doing test input generation code manipulates complex data structures 
main research challenge area efficient test input generation obtain high code coverage show symbolic execution complex data address problem 
model checking popular decades 
application model checking analysis software programs come fore 
model checking programs hard due complexity code completely analyze program state space runs memory 
reason popular program model checkers rely predicate abstractions reduce size state space techniques suited handling code manipulates complex data introduce predicates making abstraction process inefficient 
show program model checker relying abstraction achieve code coverage dealing programs manipulating complex data augmenting symbolic execution seen form abstraction result generation tests achieve high code coverage 
active research community investigating generation test inputs model checking focus specification test input generation black box testing coverage specification goal 
model checking lends test input generation simply specifies set temporal properties specific coverage achieved model checker find counterexamples exist easily transformed test inputs achieve stated coverage goal 
symbolic execution long advocated means doing efficient test input generation ensuing research focused generating tests simple data types integers part 
previous developed verification framework symbolic execution model checking handles dynamically allocated structures lists trees simple primitive data integers strings concurrency :10.1.1.12.7968
framework uses method preconditions initialize fields valid values method postconditions test oracles test method correctness 
show extended symbolic execution framework perform automated test input generation unit testing java programs :10.1.1.12.7968:10.1.1.12.7968
gen erate inputs meet testing criterion particular method test model check method 
testing criterion encoded set properties model checker check 
counterexamples properties represent paths satisfy coverage criterion 
symbolic execution performed model checking computes representation set constraints inputs execute paths 
actual testing requires solving input constraints order instantiate test inputs executed 
framework uses lazy initialization initializes components method inputs needed basis requiring priori bound input sizes 
describes detail symbolic execution lazy initialization model checking highlight complex preconditions lazy initialization initialize inputs valid values :10.1.1.12.7968
particular highlight key feature framework preconditions conservative may evaluated partially initialized structures return false initialized fields input structure violate constraint precondition 
important feature mentioned briefly elaborate :10.1.1.12.7968
show lazy initialization combination conservative preconditions initialization eliminate incorrect structures results powerful efficient way performing symbolic execution code manipulates complex structured data 
show solve input constraints order get test inputs necessary actual testing 
illustrate flexibility framework contrast white box technique black box technique method preconditions systematically generate non isomorphic test inputs size done symbolically executing code precondition 
approach similarities techniques employed korat tool executes code precondition symbolic execution primitive data lazy initialization :10.1.1.122.9788
evaluate approaches generating tests red black tree implementation java treemap library 
contributions powerful flexible test input generation framework unit testing 
framework uses efficient approach symbolic execution code manipulating complex data structures takes account preconditions analysis infeasible paths soon possible 
framework uniformly white box black box testing 
show framework generating tests code manipulating complex data structures specifically red black trees 
illustrate flexibility model checking tool test input creation comparing straight model checking code test black box approach white box approach 

background describe java pathfinder jpf model checker extended symbolic execution ca int assert false pc true pc pc pc pc pc pc pc false 
code swaps integers corresponding symbolic execution tree transitions labelled program control points 
show section extension jpf white box black box test input generation 
java pathfinder jpf explicit state model checker java programs built top custom java virtual machine jvm 
jpf handle language features java treats nondeterministic choice expressed annotations program analyzed annotations added programs method calls special class verify 
methods verify class returns boolean value nondeterministically 
random returns values nondeterministically 
cond forces model checker backtrack cond evaluates true 
jpf previously find errors number complex systems including real time operating system deos honeywell prototype mars rover developed nasa ames called 
means generating input plans current rover takes input plans generated black box fashion similar technique described section 
symbolic execution java pathfinder section give background symbolic execution symbolic execution framework reasoning java programs 
background symbolic execution main idea symbolic execution symbolic values actual data input values represent values program variables symbolic expressions 
result outputs computed program expressed function symbolic inputs 
state symbolically executed program includes symbolic values program variables path condition pc program counter 
path condition quantifier free boolean formula symbolic inputs accumulates constraints inputs satisfy order execution follow particular associated path 
program counter defines statement executed 
symbolic execution tree characterizes execution paths followed symbolic execution program 
nodes represent program states arcs represent transitions states 
consider code fragment swaps values integer variables greater shows corresponding symbolic execution tree 
initially pc true symbolic values respectively 
branch point pc updated assumptions inputs order choose alternative paths 
example execution statement alternatives statement possible pc updated accordingly 
path condition false set inputs satisfy means symbolic state reachable symbolic execution continue path 
example statement unreachable 
generalized symbolic execution describe algorithm generalizing traditional symbolic execution support advanced constructs modern programming languages java :10.1.1.12.7968
algorithm handles dynamically allocated structures primitive data concurrency 
extended adding support symbolic execution arrays :10.1.1.12.7968
algorithm starts execution method inputs uninitialized fields uses lazy initialization assign values fields initializes fields accessed method symbolic execution 
allows symbolic execution methods requiring priori bound number input objects 
execution accesses uninitialized field algorithm nondeterministically initializes field null new object uninitialized fields object created prior field initialization systematically treats aliasing 
execution accesses uninitialized primitive string field algorithm initializes field new symbolic value appropriate type execution proceeds 
branching condition primitive fields evaluated algorithm nondeterministically adds condition negation corresponding path condition checks path condition satisfiability decision procedure 
path condition infeasible current execution terminates algorithm backtracks 
framework symbolic execution framework built top jpf model checker 
enable jpf perform symbolic execution lazy initialization original program instrumented doing source source translation adds nondeterminism support manipulating formulas represent path conditions interested reader referred detailed description code instrumentation class node int elem node precondition acyclic void foo :10.1.1.12.7968
elem elem simple example illustrate generalized symbolic execution model checker checks instrumented program usual state space exploration techniques essentially model checker explores symbolic execution tree program 
state includes heap configuration path condition primitive fields thread scheduling 
path condition updated checked satisfiability appropriate decision procedure omega library linear integer constraints 
path condition unsatisfiable model checker backtracks 
framework test input generation finding counterexamples safety properties 
test input generation model checker generates paths witnesses testing criterion encoded set properties 
reported path model checker reports input heap configuration encoding constraints fields path condition primitive input fields thread scheduling reproduce error 
note performing forward symbolic execution programs loops explore infinite execution trees 
systematic state space exploration framework uses depth search iterative deepening breadth search 
concentrate analysis sequential code worth mentioning symbolic execution framework handles concurrency uses model checker systematically analyze thread interleavings 
model checker search engine framework allows exploit built capabilities model checker backtracking different search capabilities heuristic search techniques combat state explosion partial order symmetry reductions 
note consider branch coverage metric testing framework handle testing criteria encoded properties model checker check data flow coverage 
illustration illustrate generalized symbolic execution simple example see 
class node implements lists fields elem represent respectively node integer value node 
gives part corresponding code instrumented symbolic execution concrete types replaced symbolic types library classes provide concrete operations method calls implement equivalent operations symbolic types 
class expression supports manipulation symbolic integers 
class node expression elem node boolean initialized false boolean elem initialized false static vector new vector static add null node new node int verify random size size return node elementat node new node add return node get initialized initialized true node new node verify precondition acyclic return void foo 
get elem gt get elem set get instrumented code input structure pc true 
pc symbolic execution tree excerpts pc 
field reads updates replaced get set methods get methods implement lazy initialization 
field original class declaration boolean fields initialized elem initialized added 
fields set true get set methods 
vector stores input objects created result lazy initialization 
helper method new node called get node uses elements vector systematically initialize input fields different aliasing possibilities 
illustrates paths generated symbolic execution code method foo input structure 
node execution tree denotes symbolic state 
branching tree corresponds nondeterministic choice introduced build path condition handle aliasing 
edges labelled numbers refer program statements numbers lazy initialization steps 
value elem field indicates field initialized cloud indicates field initialized null nodes represented 
structures represent constraints fields input structure represents cyclic acyclic lists nodes points second node 
explain section method preconditions lazy initialization input structure violates precondition model checker backtracks call method verify 
example consider precondition input list acyclic algorithm explore transitions marked 
case study red black trees input generation techniques testing variety programs including methods classes java util package 
programs manipulate complex data structures 
particular illustrate techniques java implementation red black trees java util treemap standard java libraries version 
red black trees binary search trees extra bit information node color red black 
restricting way nodes colored path root leaf red black trees ensure tree balanced guarantee basic dynamic set operations red black tree take log time worst case 
binary search tree red black tree 
node red black 

root black 

node red children black 

simple path root node descendant leaf contains number black nodes 
red black properties expressible java 
properties basic properties binary search trees define repok method java predicate checks representation invariant class invariant corresponding data structure 
case repok checks input red black tree 
gives part java util treemap declaration gives fragment code repok representing third red black tree property red nodes black children 
generation red black trees particularly interesting framework due complex structure primitive fields back pointers 
section different techniques generate test inputs implementation red black trees java util treemap 
illustrate test input generation helper methods put remove methods class java util treemap responsible adding deleting node corresponding public class treemap entry root static final boolean red false static final boolean black true static class entry implements map entry object key object value entry left entry right entry parent boolean color 
precondition repok root public object remove object key 
public object add object key 
declaration java util treemap boolean repok entry 
worklist new linkedlist worklist add worklist isempty entry current entry worklist entry cl current left entry cr current right current color red cl null cl color red return false cr null cr color red return false cl null worklist add cl cr null worklist add cr return true method repok excerpts 
key tree 
note deletion complex operation standard operations red black trees involves rotations 
auxiliary methods addition deletion java util treemap lines java code 
implicit precondition put remove methods requires input satisfy class invariant repok input red black tree 

test input generation section illustrate applications model checking test input generation software manipulating complex data structure 
focus implementation put remove methods red black trees java treemap library 
testing criterion source code level branch coverage want compare black box white box approaches test input generation 
mentioned section framework handle kinds testing criteria 
aim generate set non isomorphic tests meets desired coverage criteria 
isomorphism tests defined isomorphism graphs heap java program viewed edge labeled graph node identities permutable primitive values :10.1.1.122.9788
note java semantics allow object allocation dictate exact object identities implies initializing test input concrete representation level setting field values level sequence method invocations say regression testing generate identical structures generates isomorphic structures 
show model checker testing executing sequences method calls data structure interface 
secondly show symbolic execution framework build non isomorphic input trees small size black box testing method 
done symbolically executing java code method precondition case code repok 
lastly show framework test input generation conservative preconditions lazy initialization analysis infeasible paths 
show input constraints computed symbolic execution solved provide inputs actual testing 
model checking testing doing model checking clear distinction system analyzed environment system inputs system takes 
environment approximated behaviors considered actual environment model checking model checking form testing 
note case model checking software environment usually large 
considering connection model checker generate inputs analyze code inputs 
illustrate idea show test java treemap library analyzing sequences put remove calls set maximally elements jpf model checker 
note example interested coverage code correctness model checker default properties uncaught exceptions important oracle general approach allows general oracles including method postconditions expressed java predicates 
input generation black box testing framework automatically generate java data structures description method public static int public static treemap new treemap public static integer elems static elems new integer int elems new integer public static void main string args true verify put elems verify random null remove elems verify random model checking testing ditions 
note sequential code generalized symbolic execution explores paths non isomorphic inputs 
generate non isomorphic input structures satisfy precondition applying generalized symbolic execution code precondition 
input structure shelf constraint solvers solving constraints path condition obtaining test input 
test inputs black box testing method test 
drawback approach relationship inputs code coverage 
hand interested covering input specification code test black box method achieves full coverage input structures bound 
order test put remove methods automatically generated non isomorphic input trees small size java description method precondition structural invariant eliminating need construct inputs sequence method calls 
framework symbolically executes repok generates input structures repok returns true 
put limit number generated objects size vector stores objects created lazy initialization see section reaches limit model checker backtracks 
result input structures satisfying repok size specified limit created 
approach contrasted brute force approach generate possible trees size class definition apply repok select valid red black trees 
approach scales better generate trees demand lazy initialization backtrack soon tree property violated pruning large portions search space 
important note actual structure repok crucial efficiency method 
repok evaluate tree determine tree valid approach equivalent generating trees pruning 
input generation white box testing symbolic execution framework input generation white box testing 
generate inputs meet testing criterion framework symbolically execute method test model check properties encode testing criterion 
counterexamples properties represent paths satisfy criterion 
path framework reports input structure path condition primitive input values define set constraints inputs satisfy order execute path particular characteristic framework uses method preconditions phases input generation eliminate infeasible structures conservative precondition deal partially initialized structures lazy initialization see section counterexample structural constraint path input concrete precondition section solve constraints valid inputs see section conservative preconditions preconditions initializing fields see 
particular field initialized value violates precondition 
notice evaluate precondition structure may uninitialized fields require precondition conservative return false initialized fields structure violate constraint precondition 
consider analysis remove method tree implementations 
method precondition class invariant red black tree data structure repok java predicate 
conservative version precondition lazy initialization illustrated 
boolean flags left initialized right initialized added code instrumentation keep track uninitialized input fields see section 
code conservative repok identical repok exception constraints encoded repok evaluated initialized fields 
example assume input trees illustrated created analysis remove method lazy initialization step 
round filled nodes represent entries colored black empty nodes represent entries colored red null nodes represented 
cloud denotes uninitialized field intuitively representing set nodes lazily initialized different nodes 
simplicity presentation omit represent key value fields 
shows results evaluating conservative repok tree structures 
tree violates repok matter concrete value cloud red nodes red children 
case model checker backtrack consider structure 
second tree concrete structure satisfies repok 
third tree represents concrete trees may may satisfy repok conservative repok returns true don know analysis continues 
note lazy initialization input fields framework related materialization summary nodes shape analysis conservative preconditions formulated context interpretation 
explore connections 
framework reports thread scheduling information case multi threaded code boolean conservative repok entry 
worklist new linkedlist worklist add worklist isempty entry current entry worklist entry cl current left entry cr current right current color red current left initialized cl null cl color red return false current right initialized cr null cr color red return false current left initialized cl null worklist add cl current right initialized cr null worklist add cr return true predicate conservative repok false true true don know evaluation conservative repok structures handling destructive updates lazy initialization algorithm builds input structures needed basis accessed symbolic execution 
code analysis performs destructive updates structure inputs lost 
create test inputs need reconstruct input structures 
example consider structures leaves symbolic execution tree depicted result destructive update structures longer contain information input structure link nodes 
order recover original input structures keep mappings objects uninitialized fields objects symbolic input structure satisfying conservative repok solution satisfies repok solution 
constraint violated 
concretization symbolic structures created fields initialized mappings reconstruct input structures 
note precondition needs evaluated lazy initialization reconstruct input structures evaluate precondition reconstructed input structures 
solving constraints result symbolically executing particular program path heap structure encodes constraints fields path condition encodes constraints primitive data 
constraints define inputs allow execution path 
order obtain actual test inputs solve constraints build actual java data structures testing 
framework solve constraints separately structures primitive data 
convert symbolic structures concrete structures uninitialized fields satisfy method precondition 
method preconditions amounts simply setting uninitialized fields null 
symbolic input structure satisfies conservative precondition input code concrete precondition symbolically executed obtain concrete structure way similar test input generation method described section 
constraints path condition solved shelf constraint solver 
note symbolic structure satisfies conservative precondition valid solutions 
example 

experiments mentioned measured branch coverage methods treemap class simplicity consider helper methods del 
optimal branch coverage achieved methods 
note statement coverage obtained methods uncovered branches missing branches option taken 
rest branches shown infeasible 
resources coverage time mem states del memory table model checking testing results obtained jpf model checker version ghz dual processor pentium gb memory running windows java 
model checking testing results table show coverage achieved methods model checking code different values number entries added treemap 
coverage numbers gathered jpf facility calculate branch coverage bytecode level execution simple transformation done obtain branch coverage source code level 
note technique branch coverage calculations rest section 
table contains time taken seconds memory consumed mb number states generated model checking 
results indicate approach scale 
size results give appearance fast low memory reasonable coverage exponential explosion apparent size size handled entirety 
branch coverage achieved called surprising large jump coverage size 
advantage model checking approach obtains path behavioral coverage small input domains systems testing fundamentally hard concurrent systems 
domain considered sequential programs manipulating complex data technique testing appropriate pass finding errors obtain structural coverage needs sophisticated approach 
black box table shows results black box structural coverage fixed size 
input trees generated doing symbolic execution repok method jpf 
input trees possible node deletions new insertion executed tests code coverage measured 
report total number trees created structs specific size parenthesis number trees size structures considered candidates lazy initialization code repok 
memory consumption minimal mb cases shown report time taken generate trees time running tests negligible 
note structures generated size results include smaller structures 
statistics coverage structs candidates time tests del table black box structural tests statistics coverage time mem tests del table white box tests minute trees required achieve optimal coverage code generated size 
note trees size created analyzing sequences put remove operations section subset trees size allowed repok believe due class invariant repok permissive property maintained sequences put remove operations 
say performance concerns methods may maintain properties stronger stated class invariant disallowing certain structures valid generated executions method sequences 
white box results doing white box analysis methods treemap obtain set test inputs achieve optimal branch coverage methods table 
report time taken seconds memory usage mb number tests run number tests generated removing duplicates parenthesis coverage obtained 
mention input trees considering test input consists input tree node put remove 
note don parameterize results size trees table goal cover branches achieved different size trees 
limit size trees looking size smaller 
expected coverage obtained optimal 
duplicates input trees generated cover branches code unique input trees required 
trees trees size trees size possible trees 
discussion lazy initialization repok black box test input generation compared approach taken korat :10.1.1.122.9788
korat generates inputs constraints java predicates uses backtracking monitors executions repok fully initialized inputs priori input size 
example number candidate structures techniques consider similar 
introduces integer values structures approach considers lot fewer structures uses symbolic execution integer constraint solving korat enumerate integer fields 
fact white box approach test inputs required versus obtain optimal coverage black box approach illustrates power goal directed white box approach blind blackbox approach test input generation obtaining high coverage 
believe complicated structural invariants difference test input size black white box approach pronounced 
drawback current approach determine code unreachable code contains cycles case red black tree examples considered 
considering techniques automatic invariant generation shape predicates abstraction address problem 
inherent drawback symbolic execution strength decision procedures check infeasible path conditions 
currently deal linear integer constraints hope add powerful decision procedures near 
note experimented different approaches representing data structures completely symbolic represented partially initialized java structures context 
approach facilitates evaluation preconditions written java predicates 

related specification testing idea constraints represent inputs dates back decades idea implemented various tools including 
prior solve constraints primitive data integers booleans solve constraints complex structures requires different constraint solving techniques 
frameworks notably testera korat support non isomorphic generation complex structures red black trees 
testera generates inputs constraints alloy order declarative language relations 
testera uses shelf sat solvers solve constraints 
discussed korat section 
korat algorithm included test generator enable generation structures 
testera korat focus solving structural constraints 
directly solve constraints primitive data systematically try primitive values bounds may inefficient 
testera korat black box testing white box setting 
early goodenough gerhart emphasizes importance specification testing 
various projects automate test case generation specifications specifications uml statecharts adl specifications specifications 
specifications typically involve structurally complex inputs address object oriented programs 
frankl algebraic specifications generate tests including oracles object oriented programs 
astoot tool generates sequences interface events checks resulting objects observationally equivalent specified algebraic specification 
interested generating tests covering input structures black box code algebraic specification create additional tests check functional requirements code straight forward extension 
heitmeyer model checker generate tests violate known properties specification scr notation 
black combine model checking mutation analysis generate test cases specification 
structural coverage approach generate test cases specifications rsml model checker 
lee define framework temporal logic specify data flow test coverage 
static analysis valued logic analyzer tvla static analysis system verify preservation list structure programs perform list reversals destructive updates input list 
tvla analyze small programs manipulate doubly linked lists circular lists sorting programs 
tvla system extended deal preconditions shape graphs 
pointer assertion logic engine pale verify large class data structures represented spanning tree backbone possibly additional pointers 
data structures include doubly linked lists trees parent pointers threaded trees 
static analysis program properties promising approach ensuring program correctness long run current static analysis techniques verify limited program properties 
example techniques verify correctness implementations balanced trees red black trees 
testing hand general verify decidable program property realistically large implementations bounded inputs 
software model checking lot interest applying model checking software 
focused checking event sequences specified temporal logic api usage rules form finite state machines 
approaches offer strong guarantees program successfully checked input execution lead error 
typically consider linked data structures considered reduce state space explored check data structures 
shows enable shelf model checker check properties complex structures account complex preconditions 
algorithms implemented straightforward fashion enable model checkers support dynamic structures check structural properties 
popular software model checkers blast slam predicate abstraction white box test input generation 
cases goal generate tests cover specific predicate combination predicates 
techniques focus generating complex test inputs handle complex preconditions 

main contribution show complex preconditions allow efficient symbolic execution code manipulating complex data generate test inputs obtaining high code coverage 
particular illustrated conservative precondition evaluates symbolic structures structures fully initialized eliminate structures lead valid concrete inputs achieve stated coverage 
conservative precondition seen version concrete precondition disallow invalid structures accept structures instantiated concrete structures fail concrete precondition 
created conservative precondition hand investigate generate directly concrete precondition techniques interpretation 
experiments precondition class invariant approach handle precondition expressed java predicate 
showed approaches model checking symbolic execution testing 
firstly traditional approach model checking perspective simply applies model checking system test 
approach obtain high levels behavioral coverage small configurations data structures 
secondly showed symbolically executing code precondition efficiently obtain tests suitable black box testing 
second approach shows flexibility lazy initialization approach symbolic execution resembles algorithm employed korat tool highly successful generating test inputs :10.1.1.122.9788
believe flexible approach testing complex software important 
think techniques covered seen continuum fashion 
code analyzed doesn full specification black box approach considers structure inputs generate tests 
note structure inputs known case java predicate 
specification exist example algebraic specification specification centered approach test input generation augment 
note requires specification notation acceptable model checker java case 
point black box approach exhausted needs consider code white box generate additional tests 
considered simple coverage criteria drive symbolic execution test input generation specify criteria expressed properties model checker example predicate coverage 
lastly testing sufficient cases example testing concurrent program notoriously incomplete powerful technique program model checking 
acknowledgments darko marinov insightful discussions sharing java implementation class invariant red black trees 
reviewers detailed comments allowed greatly improve 

economic impacts inadequate infrastructure software testing 
national institute standards technology planning report may 
adam thomas henzinger majumdar 
generating tests counterexamples 
proceedings th international conference software engineering icse edinburgh scotland may 
black 
specification coverage metric evaluate test sets 
proceedings th ieee international symposium high assurance systems engineering 
black 
model checking generate tests specifications 
proceedings nd ieee international conference formal engineering methods 
goldberg havelund lowry pasareanu rosu visser 
experiments test case generation runtime analysis 
proceedings th international workshop state machines italy march 
ball 
abstraction guided test generation case study 
microsoft research technical report msr tr 
ball rajamani 
automatically validating temporal safety properties interfaces 
proc 
th international spin workshop model checking software pages 
ball rajamani 
slam project debugging system software static analysis 
proc 
th annual acm symposium principles programming languages popl pages 
beizer 
software testing techniques 
international thomson computer press 
boyapati khurshid marinov :10.1.1.122.9788
korat automated testing java predicates 
proc 
international symposium software testing analysis issta pages july 
brat giannakopoulou goldberg havelund lowry pasareanu visser washington 
experimental evaluation verification validation tools martian rover software 
proceedings sei cm software model checking workshop pittsburgh march 
appear formal methods system design journal 
chang richardson 
structural specification testing automated support experimental evaluation 
proc 
th acm sigsoft symposium foundations software engineering fse pages sept 
clarke grumberg peled 
model checking 
mit press cambridge ma 
clarke 
system generate test data symbolically execute programs 
ieee transactions software engineering sept 
corbett dwyer hatcliff pasareanu robby laubach zheng 
bandera extracting finite state models java source code 
proc 
nd international conference software engineering icse june 
cormen leiserson rivest 
algorithms 
mit press cambridge ma 
iosif 
deadlock detection tool concurrent java programs 
software practice experience july 

automating formal specification testing 
proc 
conference theory practice software development volume pages lille france 

frankl 
astoot approach testing object oriented programs 
acm transactions software engineering methodology 
foundations software engineering microsoft research 
test generator tool 
research microsoft com fse doc html 
heitmeyer 
model checking generate tests requirements specifications 
proceedings th european engineering conference held jointly th acm sigsoft international symposium foundations software engineering fse 
springer verlag 
godefroid 
model checking programming languages verisoft 
proceedings th annual acm symposium principles programming languages popl pages paris france jan 
goodenough gerhart 
theory test data selection 
ieee transactions software engineering june 
botella 
automatic test data generation constraint solving techniques 
proc 
international symposium software testing analysis issta clearwater beach fl 
gurevich schulte 
generating finite state machines state machines 
proc 
international symposium software testing analysis issta pages july 
heimdahl visser george gao 
auto generating test sequences model checkers case study 
proc 
rd international workshop formal approaches testing software fates montreal canada oct 
henzinger majumdar 
software verification blast 
proceedings tenth international spin workshop model checking software volume lncs 
hong lee ural 
temporal logic theory test coverage generation 
proc 
th international conference tools algorithms construction analysis systems tacas grenoble france april 
huang 
approach program testing 
acm computing surveys 
khurshid pasareanu visser :10.1.1.12.7968
generalized symbolic execution model checking testing 
proc 
th international conference tools algorithms construction analysis systems tacas warsaw poland april 
king 
symbolic execution program testing 
commun 
acm 
korel 
automated test data generation programs procedures 
san diego ca 
lev ami sagiv 
tvla system implementing static analyses 
proc 
static analysis symposium santa barbara ca june 
marinov 
testing solver imperative constraints 
phd thesis computer science artificial intelligence laboratory massachusetts institute technology 
appear 
marinov khurshid 
testera novel framework automated testing java programs 
proc 
th ieee international conference automated software engineering ase san diego ca nov 
moeller schwartzbach 
pointer assertion logic engine 
proc 
sigplan conference programming languages design implementation snowbird ut june 
offutt 
generating tests uml specifications 
proc 
second international conference unified modeling language oct 
pasareanu visser 
verification java programs symbolic execution invariant generation 
proceedings th international spin workshop model checking software volume lncs 
springer verlag 
penix visser larson 
verification time partitioning deos scheduler kernel 
proceedings nd international conference software engineering icse ireland june 
acm press 
pugh 
omega test fast practical integer programming algorithm dependence analysis 
communications acm aug 
ramamoorthy 
ho chen 
automated generation program test data 
ieee transactions software engineering 
sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
acm trans 
prog 
lang 
syst jan 
visser havelund brat 
park 
model checking programs automated software engineering journal april 
reps sagiv 
symbolically computing precise operations shape analysis 
proceedings th international conference tools algorithms construction analysis systems tacas barcelona spain april 
