ray tool automatic measurement hardware parameters keshav pingali paul pingali cs cornell edu department computer science cornell university ithaca ny growing interest self optimizing computing systems optimize behavior different platforms manual intervention 
examples successful self optimizing systems las generates basic linear algebra subroutine blas libraries fftw generates fft libraries 
self optimizing systems need values hardware parameters number registers various types capacities caches various levels 
example atlas uses capacity cache number registers determining size cache tiles register tiles 
describe ray system implementing micro benchmarks measure hardware parameters 
novel algorithms measuring parameters 
experimental evaluations ray traditional workstations servers embedded systems show ray produces accurate complete results existing tools 

growing interest self optimizing systems optimize behavior different platforms manual intervention 
systems generate test paradigm writing program implements program generator produces large number program variants determines empirically variant performs best 
prevent combinatorial explosion supported ibm faculty partnership award darpa nsf aci aci aci aci aci 
number program variants considered self optimizing systems bound search space hardware parameters values number registers capacity cache 
software truly self optimizing values hardware parameters relevant software optimization determined automatically 
important note values necessarily values find hardware manual 
example loop unrolling take account number registers available hold values computed loop body 
compilers set aside certain registers holding special values stack frame pointer number registers available register allocator usually total number architected registers 
practice hard find documentation hardware parameter values values relevant software optimization 
describe ray framework implementing micro benchmarks measure relevant values hardware parameters automatically 
portability ray entirely implemented ansi 
interesting challenges approach ensure compiler perform highlevel restructuring optimizations benchmarks pollute timing results performance critical optimizations register allocation enabled 

ray framework hardware parameters measured ray microbenchmarks 
presents general structure micro benchmark ray framework 
example consider measurement number available registers particular data type way determine value perform number experiments perform computa micro benchmark parameters control engine hardware parameter value nano benchmark specification generator execution time nano benchmark code compile execute time 
micro benchmark ray tions different number variables type exceeds number available registers type variables register allocated execution time increase substantially 
number available registers inferred cross point 
general drawn example 
micro benchmark determine value parameter may need time number different related programs call nano benchmarks 
may priori bound number required nano benchmarks need nano benchmark generator produce nano benchmark code high level nano benchmark specification 
generation happen fly results nano benchmark may determine nano benchmark executed 
ray execution micro benchmark orchestrated control engine chooses nano benchmarks execute order executed appropriate parameters 
control engine determines value hardware parameter timing results 
micro benchmarks may need results obtained running micro benchmarks 
example determine latency instruction cycles nanoseconds control engine needs know cycle time processor 
specified user measured micro benchmark discussed section 

nano benchmarks access high resolution timer hard accurately time operations take cpu cycles execute 
suppose want measure time required execute statement time small compared granularity timer measure time required execute statement number times rs dependent divide time rs 
rs small time execution measured accurately rs big experiment take longer needs 
rs measures rs tmin rs rs return measures rs rs 
nano benchmark timing shows timing strategy ray nano benchmarks 
code measures rs measures time required execute rs repetitions statement determine reasonable value rs code starts setting rs doubles experiment runs tmin seconds 
value tmin specified user defaults seconds current implementation 
simplistic implementation shown 
code incurs considerable loop overhead unroll loop times 
problem restructuring compiler optimizations may corrupt experiment 
example consider case want measure latency single addition 
framework measure time taken execute statement 
important allocate registers crucial compiler replace statements loop body statement prevent code timing original statement correctly 
solve problems need generate programs compiler aggressively optimize disrupting sequence operations execution time want measure 
solve problem switch statement volatile variable shown 
semantics require read memory compiler assume switch selected 
potential control flow blocks impossible compiler combine reorder way 
final problem compiler able deduce result computations performed rest code perform dead code elimination remove instances altogether 
prevent unwanted optimization variables appear assigned values read appropriately typed volatile variables initialize statement similarly final values copied back volatile variables statement 
see section cases wish measure performance sequence different statements sn 
prevent compiler optimizing sequence code generator measures ts loop goto loop te return te ts measures ts loop repeat times 
goto loop te return te ts give si different case label generating code form shown 
number case labels smallest multiple greater equal 
nano benchmark generator ray nano benchmark generator accepts input nano benchmark specification produces nano benchmark code structured shown figures 
nano benchmark specification tuple contains statement timed type information variables example measure latency double precision floating point add operation nano benchmark specification means time statement variables type double defined asf ray 
specification nano benchmark generator produce code shown 
generating code form shown complex requires element tuple function integer string computes code statement si case label 
implementing new micro benchmark see section implementing new micro benchmark ray requires measures initialize volatile int switch case ts loop case case case goto loop te return te ts 
implementation measures initialize volatile int switch case ts loop case case case si case sn case case sn goto loop te return te ts 
implementing nano benchmarks timing experiments 
code fits template nano benchmark specifications 
implementing micro benchmark control engine describe nano benchmarks run parameters order produce final result external parameters timings 

cpu micro benchmarks 
cpu frequency cpu frequency important hardware parameter parameters measured relative clock cycles 
ray assumes dependent integer additions executed rate cycle valid current processors 
assumption dependence important modern architectures issue independent integer addition operations cycle timing independent addition operations misleading 
micro benchmark nano benchmark specification int time time required execute statement compute cpu frequency mhz time 
see section assumption dependent integer additions executed rate cycle may correct processors 
case timing measurements reported ray scaled appropriate constant obtain actual values 
serious problem software uses timing measurements choose different code sequences relative absolute times needed 

instruction latency latency lo operation instruction operands type number cycles instruction dispatched result available subsequent dependent instructions 
nano benchmark specification compute instruction latency clock cycles lo time 

instruction throughput throughput operation instruction operands types rate cycles cpu issue independent instructions type 
modern processors throughput instruction usually smaller latency pipelining super scalar execution 
measure nano benchmark specification follows 
pn pn 
pn 
pn note specification generates code form shown 
parameterized control number independent instructions generate 
example sequence statements generated 
case case case case 
general generate simple statement case label measure ilp statically scheduled vliw cores 
measure instruction throughput clock cycles follows 
time time time time time cpu nano benchmark code exhibits instruction level parallelism ilp order control engine times nano benchmark successively growing values performance continues increase due additional ilp 
performance levels control engine starts growing check increasing ilp case labels improves performance 

instruction existence existence certain instructions influence code produced self optimizing systems example atlas exploits existence fused multiply add fma 
determine fused multiply add instruction exists comparing throughput simple multiply fused multiply add 
similarly embedded processors dedicated floating point hardware emulation library 
ray measure latency floating point add assert hardware floating point unit exists latency cycles 

number registers measure number registers nrt type nano benchmark specification st pi 
pn example sequence statements generated follows 
case case case case case 
pi allocated registers time operation smaller allocated memory 
goal determine maximum variables allocated memory 
control engine doubles observes drop performance 
performs binary search interval 
actual control engine algorithm follows 

smp smt time st time st time st time st nrt measure number processors smp architecture ray uses throughput nano benchmark section specification values maximum throughput achieved 
number threads running concurrent instances configuration exhibit slowdown compared running single thread characterizes number physical processors smp 
reading number cpus os call returns number virtual smt processors 
smt cpu system computed find virtual processors share physical processor ray executes instances configuration concurrently 
slowdown virtual processors share physical processor 

cache micro benchmarks section summarize approach measuring memory hierarchy parameters 
full description detailed proofs 
known benchmark measuring memory hierarchy parameters saavedra benchmark timing results usually inspected manually determine memory hierarchy parameters 
approaches hardware counters portable 
approach produces hardware parameter values directly results accurate arbitrary cache associativity cache exclusion hardware stride prefetching 
focus measuring associativity block size capacity hit latency caches 
parameters referred caches parameter referred 
description algorithms parameter call stride cache 

sequences compact sequences ray determines memory hierarchy parameters measuring average time repeatedly access elements different address sequences 
access cache hit relatively small say sequence compact 
access cache relatively large say sequence non compact 
sequences compact non compact call semi compact 
measure capacity associativity data cache ray uses sequences addresses successive addresses separated stride sequences completely characterized starting address stride number elements notation represent 
theorem describes necessary sufficient conditions compactness non compactness sequence type cache 
informally theorem says stride gets bigger maximum length compact sequence stride decreases bottoms minimum length non compact sequence stride decreases bottoms 
theorem 
consider cache parameters sequence 
compact iff nc non compact iff nnc proof 
omitted 

measuring cache parameters cache latency determine cache hit latency measuring average time repeatedly access elements obviously compact 
capacity associativity theorem suggests method determining capacity associativity find determining asymptotic limit length compact sequence stride increased 
smallest value stride limit reached stride cache know find pseudo code measuring data cache shown 
compact empirically determine compact comparing average time repeatedly access elements cache hit latency 
compact repeat min compact algorithm described follows 
start sequence compact keep doubling sequence compact 
happens 
start doubling stride compute smallest compact 
value binary search interval 
recompute repeat step 
point declare block size cache stride associativity sequence non compact addresses map cache set 
sequence expressed offset second half sequence constant shown get set addresses 

sequence measuring addresses subsequences map single cache set 
cache set non compact cache sets different compact 
pseudo code algorithm shown 
compact return 
measuring parameters lower levels algorithms section measure parameters lower level cache provided ensure memory accesses higher level caches accomplish sequences sequences 
lack space omit details refer interested reader companion 

implementation compact represent sequences memory addresses arrays pointers void arrays integers int saavedra benchmark 
initialize array way element contains address element accessed immediately 
local variable initialized address element accessed 
correct implementation important repeatedly access elements sequence order access irrelevant 
prevent hardware constant stride prefetchers interfering timings initialize array elements chaining pointers visit elements pseudo random order 
perform timings nano benchmark specification void void fact nano benchmark generator measuring cpu parameter values cache parameter values demonstrates flexibility ray architecture 

experimental results section experimental results obtained ray measure hardware parameters number desktop embedded platforms 
embedded processors particularly challenging variations single processor family fact companies customizable embedded processors 
compare results actual values hardware parameters values obtained lmbench 
unable build run lmbench architectures 
tables show summary experimental results cpu features memory hierarchy respectively 
tables special keywords exist micro benchmark measuring hardware parameter exist lmbench os lower level caches physically addressed modern machines necessary super pages obtain consistent measurements lower level cache parameters 
support super pages os specific targeted linux proof concept 
currently working implementation solaris irix aix 
similarly lmbench relies various os features available platforms 
feature tool ultrasparc iiii power actual frequency ray mhz lmbench os os actual latency add ray cycles lmbench os os actual latency multiply ray cycles lmbench os os actual throughput add ray cycles lmbench os os actual throughput multiply ray cycles lmbench os os actual nr ray count lmbench exist exist exist exist exist exist exist exist exist exist exist actual false false false false true false false true true false false fma ray true true true true true false true true true false true boolean lmbench exist exist exist exist exist exist exist exist exist exist exist actual true true true true true true true false false true true fpu ray true true true true true true true false false true true boolean lmbench exist exist exist exist exist exist exist exist exist exist exist actual latency add ray cycles lmbench os actual latency multiply ray cycles lmbench os actual throughput add ray cycles lmbench os actual throughput multiply ray cycles lmbench os actual nr ray count lmbench exist exist exist exist exist exist exist exist exist actual false true true false true false false true false fma ray false true true false true false false true false boolean lmbench exist exist exist exist exist exist exist exist exist actual true true true true true true true false false false true fpu ray true true true true true true true false false false true boolean lmbench exist exist exist exist exist exist exist exist exist exist exist actual latency add ray cycles lmbench actual latency multiply ray cycles lmbench actual throughput add ray cycles lmbench actual throughput multiply ray cycles lmbench actual nr ray cycles lmbench exist exist exist exist exist exist exist exist actual false true true false true false false false fma ray false true true false true false false false cycles lmbench exist exist exist exist exist exist exist exist table 
summary experimental results cpu features pentium itanium athlon mp opteron arm sa xscale lx feature tool ultrasparc iiii power actual cache capacity ray kb lmbench os os actual cache associativity ray count lmbench exist exist exist exist exist exist exist exist os os exist actual cache block size ray bytes lmbench os os actual cache latency ray cycles lmbench os os actual cache capacity ray os os os kb lmbench actual 
cache associativity ray os os os count lmbench exist exist exist exist exist exist exist actual cache block size ray os os os bytes lmbench actual 

cache latency ray os os os cycles lmbench actual 
main memory latency ray os os cycles lmbench os os table 
summary experimental results memory hierarchy obtain official information actual value hardware parameter 
ray lmbench measure hardware parameters different units 
allow direct comparison normalized lmbench results follows 
lmbench measures processor clock cycle various latencies nanoseconds 
compute processor frequency mhz latency cycles 
measuring instruction throughput lmbench measures available instruction parallelism 
compute instruction throughput cycles latency cycles corresponding instruction computed shown 
discuss interesting results 

ultrasparc iiii ray measured parameters accurately architectures 
lmbench measured parameters supports accurately gave accurate pentium itanium athlon mp opteron arm sa results ultrasparc iiii especially instruction latency throughput 

power ray detected integer fused multiply add instruction isa 
verified measurement sequence translated separate dependent multiply add instructions hardware achieve throughput add 
multiply add sequence generate high performance code architecture 
ray measured data cache way set associative way set associative 
resulted capacity kb compared documented kb 
lmbench gave accurate results parameters able measure 

pentium xeon processors feature double pumped integer alus led ray believe frequency twice higher actual 
problem long timings measured relative xscale lx frequency 
table shows timing values measured ray twice larger actual values throughput add 
throughput add quite interesting 
integer alus integer add latency cycles expect effective throughput cycles translates cycles relative frequency 
ray measured greater integer adds cycle 
problem occurs instruction cache pentium deliver instructions cycle instruction dispatch engine preventing integer pipes achieving maximum throughput 
results ray able measure accurately number vector registers mmx sse sse latencies throughputs corresponding simd instructions 
results close ray noticeably accurate 
lmbench advertised frequency double value ray 

itanium ray produced accurate results parameters 
lmbench results slightly accurate major problem throughput add 
processor able execute independent add operations cycle lmbench measured throughput 
ray measured correct throughput 
measuring number registers illustrates different point 
processor floating point registers hardwired 
spite ray concluded itanium available registers average access time increase significantly variables spilled 
reducing significance threshold ray may permit accurate measurement increases sensitivity noise 

athlon mp opteron ray measured cpu feature parameters accurately 
lmbench gave accurate results especially instruction throughput 
memory hierarchy numbers machine interesting expose fact caches implement cache exclusion 
platforms support cache inclusion means information cached particular level memory hierarchy cached lower levels 
amd machines hand exclusion data resides caches simultaneously 
ray classified kb way associative cache way set associative cache capacity kb exactly 
similarly opteron mb classified way set associative cache effective capacity kb exactly 
actual capacity cache needed obtained subtracting capacity cache combined capacity relevant self optimizing code wants perform optimization cache tiling 

lx lx configurable extensible processor core designed 
hardware parameters different lx cores different 
feature lx processor challenging target ray 
frequency processor frequency measured ray mhz different actual value mhz 
inaccuracy explained loop overhead incurred code shown 
case statements latency cycle total cycles loop back code total latency cycles 
measurement error 
partially compensate feel necessary frequency measure parameters relative clock cycles 
number registers ray measured integer registers floatingpoint registers architecturally available types 
verified register spills occurred integer variables floating point variables 
cost spilling floating point registers sufficient ray declare phase transition happened 
course lower threshold ray declares phase transition happened negative impact platforms measurement noise relatively high 
practice performance penalty statistically significant number variables number available registers 
looking robust phase transition detection algorithms 
configurations introduced integer add integer multiply functional units 
ray correctly measured new throughput add throughput multiply cycles respectively 
changed data cache configuration kb way set associative byte blocks 
ray correctly measured new cache parameters 
replaced data cache bit single precision fixed point simd unit 
appropriate descriptions added ray correctly measured latency throughput add multiply number vector registers respectively 

mips ray measured parameters accurately 
lmbench accurately measured parameters supports 
details worth noting 
latency multiply measured ray cycles actual latency cycles 
reason mismatch special hold result integer multiply 
code sequence translated assembly sequence hi lo lo noop noop 
noop instructions necessary access lo asynchronous compiler needs sure value copied destroyed 
latency integer multiply cycles sustained code 
ray measured significantly fewer registers architecturally available 
examined generated assembly files confirmed policy native compiler reserve rest registers 

actively developing new micro benchmarks inside ray framework 
current focus includes measuring parameters memory hierarchy parameters instruction caches replacement policy bandwidth different cache levels determining bundles instructions issued single cpu cycle sustained rate 
ray downloaded iss cs 
cornell edu software ray 
performing measurements carl staelin assistance lmbench numerous constructive suggestions improving ray 
coleman davidson 
automatic memory hierarchy characterization 
ieee international symposium performance analysis systems software pass pages 
dongarra moore seymour 
accurate cache tlb characterization hardware counters 
proceedings international conference computational science iccs poland 
johnson 
design implementation fftw 
proceedings ieee 
special issue program generation optimization adaptation 
hennessy patterson 
computer architecture quantitative approach 
morgan kaufmann publishers 
mcvoy staelin 
lmbench portable tools performance analysis 
usenix annual technical conference january 
san diego ca pages berkeley ca usa jan 
moura johnson padua veloso singer xiong ga chen johnson 
spiral code generation dsp transforms 
proceedings ieee 
special issue program generation optimization adaptation 
saavedra smith 
measuring cache tlb performance effect benchmark run 
technical report csd feb 
staelin mcvoy 
mhz anatomy microbenchmark 
usenix annual technical conference january 
new orleans louisiana pages berkeley ca usa june 
whaley dongarra 
automated empirical optimization software atlas project 
parallel computing 
available university tennessee lapack working note ut cs www netlib 
org lapack lawn ps 
li ren padua pingali 
search really necessary generate high performance blas 
proceedings ieee 
special issue program generation optimization adaptation 
pingali 
automatic measurement memory hierarchy parameters 
rics june 
