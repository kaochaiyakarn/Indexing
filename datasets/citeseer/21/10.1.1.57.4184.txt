compiling standard ml java bytecodes nick benton andrew kennedy george russell proceedings rd acm sigplan conference functional programming september baltimore 
copyright notice required acm see www acm org pubs html 
copyright fl association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
compiling standard ml java bytecodes nick benton andrew kennedy george russell cambridge andrew uk mlj compiles sml verifier compliant java bytecodes 
features include type checked interlanguage working extensions allow ml java code call automatic recompilation management compact compiled code runtime performance just time compiling java virtual machine usually exceeds existing specialised bytecode interpreters ml 
notable features compiler include program optimisation rewriting compilation polymorphism specialisation novel monadic intermediate language expresses effect information type system interesting data representation choices 
success sun microsystem java language means virtual machines executing java secure multithreaded garbage collected bytecode supported capable collection standard library classes just available wide range architectures operating systems installed modern machines 
idea compiling functional language ml java bytecodes appealing obvious attraction able run compiled code machine jvm potential benefits interlanguage working java ml considerable 
existing compilers functional languages ability call external functions written language usually 
unfortunately differences memory models type systems foreign function interfaces awkward limited functionality type unsafe 
consequently example functional graphics libraries call typical functional programmer probably doesn bother language interface call everyday library functions say calculate md checksum manipulate gif file access database 
necessary gives uses language 
surely major factor holding back wider appear rd acm sigplan conference functional programming september baltimore adoption functional languages real world applications situation getting worse software operate complex environment interacting components written variety languages possibly wrapped distributed component architecture corba dcom javabeans 
semantic gap java ml smaller ml java uses simple scheme dynamic linking mlj able interlanguage working safe straightforward 
mlj code call external java methods manipulate java objects declare java classes methods implemented ml called java 
mlj programmer write applets ml instant access standard libraries graphics guis database access sockets networking concurrency corba connectivity security servlets sound large rapidly growing collection third party code 
interesting question ml compiled java bytecodes efficient useful 
java criticised slow especially running code significant amounts allocation bytecodes certainly designed compilation languages mind 
little opportunity low level backend control garbage collector heap layout requirement compiled classes pass java verifier places strict type constraints code generate 
furthermore current java virtual machines store activation records fixed size stack fail optimise tail calls 
initial prospects generating acceptably efficient java bytecodes functional language look simple minded lambda calculus java translator plus early jvm ran benchmark times slower moscow ml clear practical ml java bytecode compiler fairly extensive optimisations 
mlj progress scope significant improvement compilation speed generated code particular current version optimises simple tail calls quite usable source programs lines produces code modern jvm usually outperforms popular moscow ml bytecode interpreter 
overview compiler phases mlj intended writing compact self contained applications applets software components usual sml interactive read eval print top level 
operates traditional batch compiler 
structures project separately parsed typechecked translated typed monadic intermediate language mil see section simplified 
separately compiled mil terms linked large mil term extensively transformed translated low level basic block code bbc see section 
backend turns bbc collection compiled java class files default placed single zip archive 
program approach compilation unusual unique 
increases recompilation times considerably allow easily produce faster just importantly applets smaller code 
program perform transformations inlining dead code elimination known function call optimisation regard module boundaries runtime cost associated module system 
appendix contains example jvm code generated mlj 
compilation environment mlj run entirely batch mode interactive recompilation environment 
top level structures signatures stored file moscow ml mlj doesn implement functors 
compilation driven need produce named java class files application usually just class containing main method whilst applet usually subclass java awt applet 
root classes exported names specified command compiles links optimises required structures automatic dependency analysis 
smart recompilation manager similar sml nj cm ensures necessary structures recompiled file changed post link optimisation phase performed program 
typically recompile time relinking translated mil structures memory optimising generating code thirds total initial compile time includes parsing typechecking translation mil 
compilation compiler typechecks ml code external java classes mentioned compiled representations read typically standard classes zip file typecheck resolve 
language mlj compiles functor free subset sml including substructures new construct plus non standard extensions interlanguage working program compiler sounds bit naive prefer think post link optimiser sophisticated ring java 
large subset new standard basis library implemented 
interlanguage features bring java types values ml whilst enforcing separation java type ml type may compiled code 
external java types may referred ml simply java names quotation marks 
java awt graphics int type pairs component java object representing graphics context second component ml integer 
important subtlety whilst java pointer types implicitly include special value null chose quoted java type names ml refer non null values 
value java type may passed java ml code result external field access method call parameter method implemented ml value ml type option value corresponding java null values form corresponding non null values 
similarly guarantee ml value type option represented element underlying java class 
complication allows type system catch statically dynamic gives compiler freedom choosing sharing data representations see section 
builtin structure java includes ml synonyms common java types coercions equivalent ml java types example java tostring converts java string ml string 
exception generate actual bytecodes included just separate type systems securely source 
mlj code perform basic java operations field access method invocation object creation collection new keywords start underscore fits existing lexical structure sml quotation marks java field method names 
example type colour java awt color val grey valof getfield colour gray java toint invoke grey colour ml synonym java class color gets static field called gray class 
mlj reads compiled java class file states field holds instance class color infers type java awt color option getfield construct external value null 
invoke virtual method returned colour value get java int value red component convert ml int 
valof required remove option type returned value raises exception argument mlj allow method invocation possibly null java values 
new constructs getfield invoke essentially static semantics equivalents version departs definition places 
significant arithmetic operations raise overflow exception 
datatype behave unit 
behave extends java awt button private field behaviour behave public method action java awt event option java object option java boolean val getfield behaviour putfield behaviour java true constructor name string behave super java name behaviour generating java class mlj java language 
virtual method invocation example compiler searches class hierarchy method matching name argument types applying rules finding specific method possible coercions arguments java 
ml polymorphism isn allowed confuse things uses new constructs implicitly explicitly monomorphic 
easy convert existing java programs code fragments mlj intended mlj fully fledged object oriented extension sml particular inheritance induce subtyping relation ml types 
mlj structures declare new java classes fields methods having mixture ml java types methods implemented ml 
fact programs contain class java runtime system call ml code get called 
extensions declaring classes express expressed java language including access modifiers public private natural restrictions static fields ml type non option java type initialisers default values types overloading ml types forbidden ml types may represented java type 
class definitions structures anonymous ml type names bound java class names class referenced purely ml code internal name compiled program directly accessible external java code 
mentioned top level class exported java name 
exported classes accessed java entirely trivial restrictions concerning types access modifiers fields methods necessary ensure visible directly inheritance external java world java primitive java class type 
just give flavour java classes may generated mlj shows definition ml button class similar form part functional gui toolkit 
subclasses standard java button class instance variable higher order ml datatype behave 
button pressed action method called causes behaviour function called presumably side uses java introspection capabilities consider cheating effects returning new behaviour stored instance variable ready click 
constructor syntax particularly baroque called ml string initial behaviour 
starts calling superclass java string initialises instance variable supplied behaviour 
mil monadic intermediate language mil heart compiler 
mil typed language inspired moggi computational lambda calculus distinction computations values type system 
impredicative system style polymorphism refines computation type constructor include effect information 
mil includes slightly lower level features optimisations representation choices wish expressed mil mil transformations 
include quite class sequence types multiple argument multiple result functions flat datatype constructors java types just interlanguage working express representations ml types kinds function local global closure 
typed intermediate languages widely accepted thing 
types aid analysis optimisation provide secure basis correct transformations required type directed transformations compilation polymorphic equality 
help catch compiler bugs 
case especially natural java bytecode eventually produce typed 
computational types intermediate language unusual similar systems proposed monadic intermediate language express strictness optimisations proposed 
separation computations values gives mil pleasant equational theory full fi rules plus commuting conversions correct rewriting simpler 
order evaluation explicit cps intermediate representations refinement computation types different monads gives unified framework effect analysis associated transformations 
value variables constant base type vn tuple injection sum injection exception type abstraction type application fold recursive type unfold recursive type elimination projection val trivial computation evaluation function application ref creation dereferencing assignment raise throw exception try handle evaluate catch case inn xn mn case sum case mn case exception case cn mn case base type fl fn mn fl recursive function declaration terms mil int char base types theta delta delta delta theta product delta delta delta sum fl function type ref type exn exception polymorphic type recursive type ni vector types fl computation type throws reads writes effects types mil types terms types mil divided value types ranged computation types ranged fl shown 
value types include base types int char products function types multiple arguments results sum types multiple argument summands types polymorphic types recursive types 
computation types form indicating computation result types effect 
subset relation effects induces subtyping relation types unsurprising way 
note interested compiling call value language restricted function types values computations 
terms divided values ranged simplifications presentation 
particular implementation mutual recursion multiple types lower level features capture java representations omitted 
computations ranged shown 
evaluation happens try 
moggi construct evaluates computation term binds result scope computation term construct try handle generalises providing handler exception raised bound variable continuation evaluated 
interesting note construct defined conventional handle recourse value sum type 
construct val allows value multiple values treated trivial computation 
translation sml initial translation typed sml mil essentially moggi call value translation 
example source application exp exp translates translations exp exp translation expands certain features source language target patterns compiled flat case constructs records translated ordinary tuples fields sorted label structure constructs sml module language compiled ordinary tuples values 
relies impredicative polymorphism mil 
alternative see stratify intermediate language similar way stratification sml code module levels 
uses polymorphic equality compiled away simple dictionary passing style 
expect equality ideal candidate exploiting java virtual methods overriding equals method classes representing ml types 
prevent sharing representations ml types different equality functions doesn worth doing 
transformations compiler time spent applying set mil transformations term representing program 
considered general purpose simplification steps applied stages compilation whilst perform specific transformations arity raising functions 
transformations obviously rewrites tricky part deciding applied 
moment decisions taken basis simple rules result sophisticated analysis 
rules type directed involve simple properties terms size subterm number occurrences variable 
effect inference currently naive particularly regard recursive functions datatypes small number places basis annotated computations pure may dead coded programs referenced 
simplification basic transformations essentially just pure fi reductions commuting conversions obtains proof theory computational lambda calculus adapted large allocating terms duplicated see 
reductions genuine simplifications whilst commuting conversions tend expose reductions 
mlj applies commuting conversions exhaustively obtain cc normal form code generation particularly straightforward 
doing sort heavy rewriting large term expensive particularly done functionally heap turnover high 
current simplifier uses quasi pass algorithm similar described appel jim maintains environment variable bindings census count variable occurrences stack evaluation contexts perform commuting conversions efficiently 
algorithm times faster version ends expensive phase repeated stages compilation total time spent simplifier typically half recompile time 
validity certain rewrites depends effect information types 
shown 
polymorphism implementations sml compile parametric polymorphism boxing ensuring values type re claiming justified formally respect semantics full language 
case beta case delta delta delta inn xn mn val eta val cc case cc case delta delta delta inn xn mn case delta delta delta inn xn mn proof theoretic rewrites dead free dead try try handle throws hoist case delta delta delta inn xn mn case delta delta delta delta delta delta inn xn mn free rewrites dependent effect information inside value type represented uniformly pointer boxed 
java natural way box objects free cast object natural way box primitive types create heap allocated wrapper object cast object 
unboxing involves java checkcast bytecode cast back case primitive types extracting field 
done naively kind boxing extremely inefficient number papers address question place coercions reduce cost boxing 
early version compiler implemented moderately sophisticated graph algorithm coercion placement 
whilst graph algorithm worked fairly taken radical straightforward approach removing polymorphism entirely 
possible firstly program secondly property standard ml finite number types polymorphic function determined statically 
languages polymorphic recursion versions haskell property hold types function may known run time 
polymorphic function specialised produce separate version type instance 
worst case produce exponential blowup code size experience happen practice 
reasons cited 
specialise respect source types respect final java representations sharing types occurs 
example suppose filter function lists containing elements different datatypes represented universal sum class discussed section 
version filter required 
second boxing unboxing coercions introduce certain amount code blowup avoided 
third polymorphic functions tend small cost duplicating great 
polymorphic functions inlined away prior case particular instance function consequently inlined subject simplification 
arity raising heap allocation expensive 
try avoid creating tuples closures replacing curried functions functions accepting tuples functions multiple arguments flatten sums products datatypes multiple argument constructors 
remove type unit nullary product entirely 
transformations ideally driven information values find fairly simple minded application type isomorphisms theta fl fl fl fl theta theta theta unit unit fl hi fl hi regarded kind boxing re uniform shared representations certain ml types note box primitive types 
object delta delta delta pn exception delta delta delta fm delta delta delta sr delta delta delta es java classes representing mil types combined rewrites produces significant improvement programs 
example benchmark runs seconds optimisation enabled takes seconds tuple argument arity raising turned 
worse crashes stack overflow de currying disabled mlj unable goto instruction place tail call 
observe de currying depends effect information types including termination unsound 
data representation ml base types ml base types close java equivalents ml ints represented java ints ml strings represented java strings 
couple small differences semantics types operations led diverge ml definition integer arithmetic raise overflow char string structures java unicode 
products distinct product type theta delta delta delta theta represented different class fields types see class hierarchy 
representations shared sorting fields type example class type int theta string string current version compiler doesn 
sums natural object oriented view sum type delta delta delta represent summands subclasses single class method lookup place case 
example represent lists class list subclasses nil fields cons field head field tail 
length function compile method implementation nil simply returns zero implementation cons returns successor result invoking method tail 
whilst technique elegant necessarily efficient 
typical functional code generate large num ber small methods necessary pass free variables bodies case constructs arguments methods 
jvm bytecode possible method invocation 
unfortunately check classes time instanceof cast checkcast 
variation idea store integer tag superclass implement case constructs switch tag followed cast appropriate subclass 
take stage single superclass sum types subclass type summand 
reduces number classes required summands single class represent sum types occurring source program sharing representations obtained types constructed sum types 
universal sum scheme general special cases efficient representations described 
ffl enumeration types datatypes constructors nullary primitive integer type 
ffl types java variables type contain valid object array value null 
types form hi represented nonnull class array type 
example sml type int int option implemented class int int represented null 
type int list implemented single product class fields head integer tail class nil represented null 
primitive product class wrap primitive value 
form hi create additional dummy value appropriate class type represent extra value type 
example value sml type int list option represented way type int list extra value created stored global variable class initialised 
types general type ref simply represented unary product class 
created top level inside functions class way assigned dereferenced compared equality passed static fields distinguished class words global variables 
hope perform escape analysis order local variables types possible 
exceptions sml type exn special status extensible 
exception declarations create fresh distinguishable exception constructors operational semantics formalised creation fresh names 
exceptions declared outside functions fixed finite set names determined compile time 
exploit representing exception constructor separate class subclasses class ml exceptions 
contrast sums class exception constructors argument types 
ml handle construct fits better jvm try catch construct class exception determine block code execute 
generative exception declarations appear inside functions generate fresh integer count global variable store field exception constructor object 
field tested exception handlers case constructs 
exceptions give nice anecdotal example sort low level java specific tweaking necessary addition high level optimisations 
early version compiler noticed certain programs exceptions control flow mechanism ran hundreds times slowly expected 
problem tracked feature java exception created complete stack trace computed stored object 
solution simply override method ml exception class stack trace stored 
functions mentioned earlier functions mil divided locals globals closures 
follows ffl functions appear tail application positions sharing single continuation compiled inline basic blocks 
function application compiled goto bytecode 
incidentally reason compiling jvm bytecodes java source goto instruction available java 
example val fn 
body simply compiled block code calls compiled jumps 
possible transform non tail function application tail 
consider fragment ml val fn 
val assuming appear expression continuation moved definition calls implemented jumps 
ffl functions appearing application positions compiled static java methods distinguished class function application implemented invokestatic bytecode recursive tail call case goto 
ffl remaining functions higher order way compiled closures 
number ways achieved 
obvious generate function type class app method subclass closure type storing free variables instance variables object 
wasteful classes function type closure appearing program 
currently different sight alarming scheme 
single app method different method names different function types 
single superclass functions dummy methods possible app method 
closures types free variables different function types share subclasses possible actual closure objects shared free variables app methods different 
example fun string val fn int 
val fn string 
closures required share closure class free variable types function types different 
values free variables object saving allocation 
simple flow analysis decide function compiled 
sophisticated flow analysis allow identify known functions refine type partitioning application methods allowing sharing classes closures 
bbc basic block code bbc static single assignment representation operations available java virtual machine abstracts away certain instruction selection details including distinction stack local variables 
normal form mil commuting conversions applied translated bbc includes information effects object fields mutable backend orders selects instructions turn real bytecode 
currently backend constructs dependency dag bbc works top stack possible storing intermediate results local variables ordering constraints immediate stack impossible 
pass local variable numbers reassigned number copies basic blocks minimised combined standard register colouring phase try minimise total number local variables 
scheme produces code respectable far optimal 
data passed basic blocks left stack passed local variables 
basic blocks jvm stack fairly simple minded way 
causes local variables leads code somewhat larger 
heavy optimisation backend benchmark mlj moscow sml nj quicksort life knuth bendix mandelbrot boyer moore fft table compile times seconds probably justified point view execution speed bytecodes usually recompiled jit compiling virtual machine independent mapping stack locations local variables registers memory keen reduce size bytecodes 
currently developing improved backend intelligent stack 
current status performance mlj currently comprises lines sml written sml nj version plus basis library code 
freely available web research uk mlj sml nj heap image solaris win linux digital unix basis code compiled 
scope improvement mlj useful real applications 
internal projects mlj include ffl writing functional sgml xml stylesheets downloaded web browsers run servers 
involves lot interlanguage working including javascript netscape microsoft browser specific java classes third party java xml parsers 
ffl implementing graphical functional language filtering classifying events web servers 
involves interworking third party graph editor written java 
number nice demonstrations including paulson hal theorem prover order logic compiled third party java terminal code produce applet functional programs graphical user interfaces access oracle database java jdbc api 
largest program successfully compiled lines compiler asn producing 
compile times compile times range standard sml benchmark programs shown table 
timings taken mhz pentium pro mb ram running windows nt 
compared july internal version mlj moscow ml sml nj 
benchmark mlj moscow sml nj quicksort life knuth bendix mandelbrot boyer moore fft table code size comparisons kilobytes code size table lists sizes compiled code produced compilers 
obtain roughly fair comparison excludes run time system 
mlj total size class files excludes java interpreter required run 
moscow ml size bytecode file excludes interpreter required run 
sml nj size windows heap image produced excludes run win run time system required run 
run times preliminary benchmark times shown table 
timings performed machine compilation benchmarks compare mlj moscow ml sml nj 
run times include start time run time system 
different java implementations run code compiled mlj ffl java nt latest version beta sun java development kit running windows nt symantec jit enabled ffl nt latest version microsoft jit compiler build running windows nt ffl kaffe linux latest version tim wilkinson kaffe jvm jit enabled running redhat linux ffl java linux steve byrne port sun interpreting jvm running redhat linux 
illustrate effect initial heap size performance sun jvms tested twice firstly default initial heap mb secondly heap starting mb 
interpretation results usual details small program benchmark figures treated scepticism possible broad generalisations 
thing note mlj compile times high times slower moscow ml times slower sml nj worth recompile times important numbers software development typically third total compile times 
hardly surprising extensive functional rewriting program turns costly compilation technique sml nj program single file compile times higher mlj 
intermediate language certainly uses space traditional untyped lambda calculus firstly carrying types secondly computational lambda calculus translations inherently verbose 
slows compilation increasing heap turnover 
current parser contributes long compile times uses parser combinators table driven 
secondly java virtual machines vary widely performance 
jit compiler produces significant speedups current state art fastest jits bugs 
microsoft win jit generally quite fast fundamental bug causes operations reordered 
luckily able identify problem sufficiently precisely add compiler option produce slightly efficient code avoids bug 
current version symantec jit number serious bugs prevent running code 
problems indicate pragmatic hope temporary 
drawback clever compilation languages java bytecodes java compilers produce fairly naive stylised bytecodes mlj produces bytecodes whilst perfectly legal jvm specification produced java compiler 
tends uncover bugs jvm implementers tested output existing java compilers 
general mlj code run jit compiler tends particularly performance better sml nj heavily numeric benchmarks mandelbrot fft 
unsurprising allow code easily translated jit code generated naive compiler 
typical functional code lot heap allocation quicksort boyer moore life tends run slowly showing storage management jvms fairly poor suspect fact increasing initial heap size significant difference quicksort knuth bendix boyer moore life running sun symantec jvms indicates inefficient heap expansion just slow garbage collection se 
comparison sml nj life benchmark particularly interesting benchmark originally written program optimisation allows specialise representations including uses polymorphic equality run times faster sml nj 
program constrained minimal signature sml nj specialise runs nearly times faster best mlj manage 
particularly poor performance microsoft jit performance knuth bendix benchmark due fact doing deal allocation heavy exceptions 
code produced mlj impressively compact quite small produced moscow ml 
moscow advantage bytecode specifically designed ml expect able narrow gap 
mentioned ongoing improvements backend just significant non trivial space overhead associated fairly large number distinct java classes produced mlj 
example knuthbendix benchmark produces total classes benchmark mlj moscow sml nj nt java nt java nt mb kaffe linux java linux java linux mb quicksort life knuth bendix mandelbrot boyer moore fft requires compilation mlj switch set avoid bug microsoft jit program crashed due bug symantec jit timing jit disabled sml nj gave incorrect results timing improves seconds top level structure constrained minimal signature table run times seconds total size taken product sum exception classes contains essentially real code 
certainly scope improving representation choices decrease code size 
mlj useful tool compiler popular functional language produces compact highly portable code reasonable performance unusually powerful straightforward access large collection foreign libraries components 
reasonable performance achieved price high compile times limitation size programs may reasonably compiled 
decision program optimisation certainly controversial worth trying give explicit justification ffl importantly relative inefficiency current jvms difficulty mapping ml java bytecodes simply way achieve considered adequate performance 
ffl limitation program size just problem real applications 
number sml programs say lines long small awful lot sml 
suggested compiler compile useless clearly nonsense 
ffl trends component architectures interlanguage development dynamic linking distributed systems mean large monolithic application common 
course component boundaries reintroduce problems separate compilation worse form reason compile component possible 
ffl completely separate compilation granularity modules introduced software engineering purposes high level languages pay earlier discussion sml nj performance life benchmark indicates realistically doubled speed parts mlj simply manually code 
range approaches completely naive program compilation separate compilation whilst optimum lies middle extremes easiest compiler writer 
mlj develops caching information module sacrificing rewrites able handle larger programs compilers add complex intermodule optimisations expect come closer 
interesting compare mlj wadler odersky pizza 
started standard functional language added extensions support interlanguage working java pizza starts java adds functional features pattern matching parameterised types 
aware attempts compile sml java bertelsen moscow ml walton edinburgh 
uniform representations perform level optimisation mlj 
wakeling compiled haskell java bytecode disappointing results large code performance considerably slower hugs interpreter 
main attempt compile mainly functional language java bytecode kawa compiler scheme 
kawa interactive top level loop compiles bytecodes dynamically uniform representations 
informal tests indicate kawa typically runs order magnitude slowly mlj tends run memory stack space earlier mlj 
currently developing concurrency extensions mlj built top java built threads looking thinking possibility advantage java remote method invocation infrastructure develop distributed mobile applications ml 
reason believe jvms tail call elimination may appear soon remove significant limitations mlj compile simple loops jumps lack general tail call optimisation programs run stack space reasonable sized inputs 
tail call optimisation done consider selective techniques placing functions method tiny interpreter technique glasgow haskell compiler 
naive techniques cause significant worsening code size speed base decisions sophisticated flow analysis allow improve transformations 
appear point longer compilation times hope avoided improving representation intermediate language 
compiler currently spends vast amount time memory performing trivial rewrites mil term 
rewrites commuting conversions simply disappear suitable graph representation 
rewrite destructively able obtain compiler speedups 
minor improvement need ensure mlj generates methods exceed jvm byte limit 
far happened unusual program anticipate great difficulty modifying code generator prevent happening 
monadic intermediate language particularly novel 
whilst claim allows perform optimisations achieved ad hoc methods powerful elegant framework structuring compiler 
general strongly advocate principled type theoretic semantic ideas compiler implementation 
things compiling java bytecodes large ongoing effort develop better faster jvms take advantage free 
early information sun generation jvms indicates allocation collection improved significantly possibly factor 
mlj runtime performance competitive native compilers improvements 
appel 
compiling continuations 
cambridge university press 
appel jim 
shrinking lambda expressions linear time 
journal functional programming september 
arnold gosling 
java programming language 
addison wesley second edition 
benton 
strictness analysis lazy functional programs 
phd thesis university cambridge computer laboratory august 
technical report 
benton bierman de paiva 
computational types logical perspective 
journal functional programming 
appear 
bertelsen 
compiling sml java bytecode 
master thesis dept information technology technical univ denmark january 
blume 
cm compilation manager sml nj 
technical report 
part sml nj documentation 

kawa compiling dynamic languages java vm 
usenix conference june 
compiler available www cygnus com kawa html 
henglein rgensen 
formally optimal boxing 
acm symposium principles programming languages pages 
peyton jones 
implementing lazy functional languages stock hardware spineless tagless 
journal functional programming pages april 
peyton jones launchbury shields tolmach 
bridging gulf common intermediate language ml haskell 
acm symposium principles programming languages january 
rgensen 
calculus boxing analysis polymorphically typed languages 
technical report diku university copenhagen may 
leroy 
unboxed objects polymorphic typing 
th annual acm symposium principles programming languages pages 
milner tofte harper macqueen 
definition standard ml revised 
mit press cambridge mass 
moggi 
notions computation monads 
information computation 
mossin 
flow analysis typed higher order programs 
technical report diku university copenhagen 
martin odersky philip wadler 
pizza java translating theory practice 
acm symposium principles programming languages january 
paulson 
ml working programmer 
cambridge university press second edition 
shao 
overview flint ml compiler 
acm sigplan international conference functional programming pages june 
shao 
typed cross module compilation 
technical report yaleu dcs tr department computer science yale university july 
shivers 
control flow analysis higher order languages 
phd thesis carnegie mellon university may 
cmu cs 
tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
acm sigplan conference programming language design implementation pages philadelphia pa may 
tolmach 
optimizing ml hierarchy monadic types 
workshop types compilation march 
wadler 
marriage effects monads 
rd acm sigplan conference functional programming september 
volume 
wakeling 
vsd haskell java virtual machine code compiler 
th international workshop implementation functional languages september 
weeks 
program optimizing compiler standard ml 
technical report nec research institute november 
available www neci nj nec com homepages 
sample output code implements quicksort algorithm integer lists 
fun quick xs fun quicker xs ys case xs 
ys 
ys bs 
fun partition left right quicker left quicker right ys partition left right xs partition left right xs partition left right xs partition bs quicker xs internal function quicker compiles static method method ra ra ra goto new class ra 
dup iload aload invokespecial method ra int ra 
astore goto new class ra 
dup iload aload aload invokestatic method ra ra ra 
invokespecial method ra int ra 
astore aload ifnull aload getfield field ra 
dup astore ifnull aload getfield field int 
istore astore astore aload ifnull aload getfield field int 
dup istore iload aload getfield field ra 
astore new class ra 
dup iload aload invokespecial method ra int ra 
astore goto new class ra 
dup aload getfield field int 
aload invokespecial method ra int ra 
areturn aload areturn program illustrates code transformations performed mlj 
integer lists represented class ra nil represented null xs represented instance ra stored field xs field notice calls partition call quicker implemented goto bytecodes 
tuples removed triple passed partition vanished function quicker expecting pair transformed method arguments 
