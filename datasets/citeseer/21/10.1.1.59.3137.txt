search software test data generation survey phil department computer science university sheffield regent court portobello street sheffield dp uk dcs shef ac uk preprint article published software testing verification reliability pp 
june 
copyright wiley 
metaheuristic search techniques automatic generation test data burgeoning interest researchers years 
previous attempts automate test generation process limited having constrained size complexity software basic fact general test data generation undecidable problem 
metaheuristic search techniques offer promise regard problems 
metaheuristic search techniques highlevel frameworks utilise heuristics seek solutions combinatorial problems reasonable computational cost 
date metaheuristic search techniques applied automate test data generation structural functional testing testing grey box properties example safety constraints non functional properties worst case execution time 
surveys undertaken field discussing possible new directions research different individual areas 
keywords search software engineering automated software test data generation evolutionary testing metaheuristic search evolutionary algorithms simulated annealing metaheuristic search techniques automatic generation test data burgeoning interest researchers years 
industry test data selection generally manual process responsibility usually falls tester 
practice extremely costly difficult laborious 
automation area limited 
exhaustive enumeration program input infeasible reasonably sized program random methods unreliable exercise deeper features software exercised mere chance 
previous efforts limited size complexity software involved basic fact general test data generation undecidable problem 
application metaheuristic search techniques test data generation possibility offers promise problems 
metaheuristic search techniques high level frameworks utilise heuristics order find solutions combinatorial problems reasonable computational cost 
problem may classified np complete np hard problem polynomial time algorithm known exist practical 
standalone algorithms strategies ready adaption specific problems 
test data generation involves transformation test criteria objective functions 
objective functions compare contrast solutions search respect search goal 
information search directed potentially promising areas search space 
search software test data generation just example software engineering :10.1.1.143.9716
date metaheuristic search techniques applied automate test data generation areas coverage specific program structures part structural white box testing strategy exercising specific program feature described specification attempting automatically disprove certain grey box properties regarding operation piece software example trying stimulate error conditions falsify assertions relating software safety verify non functional properties example worst case execution time segment code 
surveys undertaken areas results achieved 
section begins reviewing search techniques 
section discusses application structural testing date received greatest share attention search testing researchers 
section presents area functional testing followed grey box testing section non functional testing section 
section outlines possible directions research appropriate area 
metaheuristic search techniques order adapt metaheuristic search technique specific problem number different decisions example way solutions encoded manipulated search 
choice encoding ensure similar solutions unencoded space neighbours representational space 
way search allowed move easily solution shares similar set properties 
movements dependent evaluation candidate solutions performed problem specific objective function 
feedback objective function search seeks better solutions knowledge experience previous candidates 
objective function critical success search 
solutions better respect rewarded better objective values poorer solutions punished poorer objective values 
better objective value practice higher value lower value dependent search seeking minimise maximise objective function 
objective function maximised reflects relative goodness candidate solutions objective function minimised usually referred context cost function reflects relative solutions 
section outlines metaheuristic techniques software test data generation hill climbing simulated annealing evolutionary algorithms 
treatment search techniques 
decade seen emergence new techniques exploited test data generation techniques 
gives treatment 
hill climbing hill climbing known local search algorithm 
hill climbing works improve solution initial solution randomly chosen search space starting point 
neighbourhood solution investigated 
better solution replaces current solution 
neighbourhood new solution investigated 
better solution current solution replaced improved neighbours current solution 
improvement likened climbing hills landscape maximising objective function 
landscape peaks characterise solutions locally optimal objective values troughs signify solutions locally poorest objective values 
steepest ascent climbing strategy neighbours evaluated neighbour offering greatest improvement chosen replace current solution 
random ascent strategy referred ascent neighbours examined random neighbour offer improvement chosen 
high level description algorithm seen 
hill climbing simple gives fast results 
easy search yield sub optimal results hill climbed leads solution locally optimal globally optimal 
cases search trapped peak hill unable explore areas search space 
search stuck landscape 
circumstances neighbouring solution deemed offer improvement current solution objective value 
non trivial landscapes results obtained hill climbing highly dependent starting solution 
common extension algorithm incorporate series restarts involving different initial solutions sample search space minimise problem possible 
select starting solution repeat select obj obj ascent strategy obj obj high level description hill climbing algorithm problem solution space neighbourhood structure obj objective function maximised simulated annealing desirable search framework dependent starting solution 
simulated annealing similar principle hill climbing 
probabilistically accepting poorer solutions simulated annealing allows restricted movement search space 
probability acceptance inferior solution changes search progresses calculated difference objective value current solution neighbouring inferior solution considered control parameter known temperature 
temperature cooled cooling schedule 
initially temperature high order allow free movement search space dependency starting solution lost 
search progresses temperature decreases 
cooling rapid search space explored chances search stuck local optima increased 
basic algorithm minimising objective function seen 
name simulated annealing originates analogy technique chemical process annealing cooling material heat bath 
solid material heated past melting point cooled back solid state structural properties cooled solid depend rate cooling 
algorithm proposed metropolis simulates change energy system subjected cooling process converges steady state 
algorithm proposed basis search mechanism kirkpatrick 
evolutionary algorithms evolutionary algorithms simulated evolution search strategy evolve candidate solutions operators inspired genetics natural selection 
genetic algorithms probably known form evolutionary algorithm having conceived john holland united states late sixties 
genetic algorithms closely related evolution strategies developed independently time germany ingo hans paul schwefel 
genetic algorithms search primarily driven recombination mechanism exchange information solutions breed new ones evolution strategies principally mutation process randomly modifying solutions 
select starting solution select initial temperature repeat repeat select random obj obj generate random number num decrease cooling schedule stopping condition reached high level description simulated annealing algorithm problem solution space neighbourhood structure num number solutions consider temperature level obj objective function minimised different approaches developed independently different directions mind incorporated ideas traditions narrowing differences 
discussion focuses genetic algorithms 
information evolution strategies see 
genetic algorithms name genetic algorithm comes analogy encoding candidate solutions sequence simple components genetic structure chromosome 
continuing analogy solutions referred individuals chromosomes 
components solution referred genes possible values component called alleles position sequence locus 
furthermore actual encoded structure solution manipulation genetic algorithm called genotype decoded structure known phenotype 
applications genotype simply string binary digits issue revisited context test data generation 
example vector integers range represented 
real values decision precision mapping binary strings 
possibility example scale real values integer values required precision integer encoding 
genetic algorithms maintain population solutions just current solution 
search afforded starting points chance sample search space local searches 
population iteratively recombined mutated evolve successive populations known generations 
recombination operator takes parent solutions produce new offspring 
point recombination single crossover point chosen random 
recombination individuals encoded form single point crossover chosen take place locus take place follows produces offspring 
various selection mechanisms decide individuals create offspring generation 
key concept fitness individuals 
fitness individual value obtained directly objective function value scaled way 
idea selection favour fitter individuals hope breeding fitter offspring 
strong bias best individuals result dominance generations reducing diversity increasing chance premature convergence area search space 
conversely weak strategy result exploration evolution search substantial progress 
holland original genetic algorithm fitness proportionate selection 
selection mechanism expected number times individual selected reproduction proportionate individual fitness comparison rest population 
process analogous roulette wheel 
individual allocated slice wheel proportion fitness 
wheel times order pick parents 
spin position wheel marker denotes individual selected parent generation 
fitness proportionate selection difficulties maintaining constant selective pressure search 
selective pressure probability best individual selected compared average probability selection individuals 
generations search fitness variance usually high 
fitness proportionate selection selective pressure high highly fit individuals granted greatest opportunities parents 
lead premature convergence 
generations fitness values individuals similar fitness variance population correspondingly low selective pressure low 
lead stagnation search 
linear ranking individuals technique proposes circumvent problem 
individuals sorted fitness selection performed rank direct fitness values 
linear ranking mechanism bias allocates selective bias top individual bias median individual bottom individual 
constant bias applied search selective pressure constant controlled 
tournament selection noisy fast rank selection algorithm 
population need sorted fitness order 
individuals chosen random population 
random number chosen 
probability better individual selected fitter individuals wins chosen parent fit individual chosen 
competing individuals returned population possible selection 
repeated times required number parents selected 
probability individual sampled twice best individual selected reproduction twice median individual worst individual remaining unselected 
resulting selective bias dependent probability ranking bias best individual produced 
bias 
set parents selected recombination take place form generation 
crossover applied individuals selected random probability pc referred crossover rate crossover probability 
crossover takes place offspring inserted new population 
crossover take place parents simply copied new population 
recombination stage mutation employed responsible introducing genetic material search interests maintaining diversification 
usually achieved flipping bits binary strings low probability rate pm usually 
high level description genetic algorithm seen 
initial population generated random seeded pre set individuals 
search terminated stopping criterion met example number generations reached pre imposed limit 
advanced encodings operators traditionally chromosomes represented string binary digits 
problem standard binary encoding disparity occur solutions close unencoded solution space far apart encoded binary representation 
example standard binary encoding integer represented represented 
crossover mutation operators change bits move integer value neighbouring 
alternative gray code 
gray code binary representation adjacent integers hamming distance neighbours hamming space 
example standard binary reflected gray code represented 
empirical evidence shown gray codes generally superior standard binary encodings 
goldberg argues binary representation decomposes chromosome largest number smallest possible building blocks order recombination mutation operators effectively 
disputed advocates expressive alphabets 
davis supports view 
real world applications genetic algorithms variety problem domains davis real valued representations outperformed binary encodings real valued encodings representational choice evolution strategies 
course real valued encoding raises question crossover mutation 
crossover operator requires underlying randomly generate seed initial population repeat evaluate fitness individual select parents selection mechanism recombine parents form new offspring construct new population parents offspring mutate stopping condition reached high level description genetic algorithm sequence representation operate binary encodings 
possibilities mutation operator include replacement real number chromosome new randomly generated number 
advanced mutation operators real number creep 
operators sweep chromosome pushing values small amount 
way element local search incorporated 
genetic algorithms successfully applied wide range problems 
introductory texts see 
shorter overviews tutorials see 
structural white box testing structural white box testing process deriving tests internal structure software test 
section summarises achievements automating structural test data generation metaheuristic techniques 
compared earlier related approaches 
basic concepts reviewed 
basic concepts forms structural testing control flow graph cfg program question 
control flow graph program directed graph set nodes set edges respective unique entry exit nodes graph 
node statement program edge ni nj representing transfer control node ni node nj 
example control flow graph seen version triangle classification program 
triangle classification program benchmark testing papers 
assuming non zero non negative integer lengths sides triangle program decides triangle isosceles scalene equilateral invalid 
nodes corresponding decision statements example statement referred branching nodes 
triangle example branching nodes nodes 
outgoing edges nodes referred branches 
condition determining branch taken referred branch predicate 
true branch node branch predicate input vector vector 
xk input variables program domain input variable xi set values xi take 
domain program cross product dx dx 
dxk dxi domain input variable xi 
program input single point dimensional input space path control flow graph sequence 
nm ni ni path said feasible exists program input path traversed path said infeasible 
definition variable node modifies value example assignment statement input statement 
variable type defined triangle program node 
variable node referenced example assignment statement output statement branch predicate expression 
triangle classification example variables node 
definition clear path respect variable path modified 
triangle example paths node respect variables path node definition clear respect type 
term control dependency describe reliance node execution outcome previous branching nodes 
node node path exit node contains node post dominates branch path exit node contains node control dependent post dominates branches post dominate triangle example node control dependent node turn control dependent node 
node control dependencies external condition entry causes procedure executed 
information captured control dependence graph 
shows control dependence graph triangle program 
techniques described implemented experimentation variety programming languages 
consistency examples static structural test data generation static structural test data generation analysis internal structure program requiring program executed 
symbolic execution symbolic execution execution program true sense process assigning expressions program variables path followed code structure 
technique derive cfg node int tri type int int int int type int int int type triangle type scalene type equilateral type isosceles return type triangle classification program corresponding control flow graph entry control dependence graph triangle classification program constraint system terms input variables describes conditions necessary traversal path 
forward traversal forward substitution path demonstrated triangle classification program 
say path executed 
input variables assigned constant variables respectively 
nodes respective false branches taken 
second constraints constraint system path path requires true branch taken node 
requires addition third constraint expressions assigned nodes respectively fourth final constraint node needs added 
equal backward path traversal possible starting final node path reverse manner start node 
resulting constraint system forward traversal storage required intermediate symbolic expressions variables 
forward traversal allows early detection infeasible paths constraints generated inconsistent 
consider path requires true branches taken nodes false branch node taken 
constraints derived branching predicates initial section path node clearly constraints contradictory indicating path infeasible 
backward traversal meant symbolic execution path backwards backwards nodes node possible determine fact 
solutions constraint system input data execute path 
constraint satisfaction problems general np complete 
constraints linear linear programming techniques applied 
heuristic methods attempt finding solution case 
example boyer employ hill climbing 
ramamoorthy trial error procedure monitoring effects random value assignments variables constraint system 
procedure efficient non trivial programs 
test goal execution particular statement paths leading statement explored 
problem presence loops due potential number paths may need examined 
clarke test data generator system path manually selected tester 
generators symbolically simply execute loop times specified tester chosen system 
large number constraints generated method satisfiable 
symbolic execution problems example resolving computed storage locations array subscripts 
perform action code fragment known general refer element variables bound specific values 
information important equal value condition branch predicate evaluates true 
value predicate evaluates false 
boyer ramamoorthy suggest possible solutions problem 
methods significantly increasing complexity memory requirements symbolic execution system 
similar problem occurs pointers 
example known refer location 
knowledge expression assign determined 
difficulties include handling procedure calls 
common solution simply inline called procedure calling routine 
number paths grow rapidly approach 
computable function written arrays pointers procedure calls normal practice programmers avoid constructs simply flexibility offer role play reducing complexity program code 
domain reduction domain reduction test data generation technique originally employed part constraint testing developed demillo offutt 
constraint testing builds constraint systems describe test goal 
solution constraint system brings satisfaction goal 
original purpose constraint testing generate test data mutation testing 
reachability constraints constraint system describe conditions particular statement reached 
necessity constraints describe conditions mutant killed 
symbolic execution develop constraints terms input variables 
domain reduction attempt solution constraints 
procedure begins domains input variable 
derived type specification information supplied tester 
domains reduced information constraints involving relation operator variable constant constraints involving relation operator variables 
remaining constraints simplified back substituting values 
simplification possible input variable smallest remaining domain chosen random value assigned 
value variable back substituted constraint system order allow reduction domains remaining variables 
variables assigned values manner constraint system satisfied variable assignment stage repeated hope time successfully selecting appropriate random numbers variables 
constraint testing constraints computed analysed 
constraints derived symbolic execution method suffers similar problems involving loops procedure calls computed storage locations 
dynamic domain reduction introduced offutt intent addressing issues 
called dynamic domain reduction technique characteristic program executed real input values 
standard domain reduction dynamic domain reduction starts domains input variables 
contrast standard domain reduction domains reduced dynamically symbolic execution stage constraints composed branch predicates encountered path followed 
branch predicate involves variable comparison domains input variables responsible outcome decision split arbitrary split point assigning random input values 
example initial domains input variables branch predicate encountered needs executed true domains split leaving domain 
back tracking procedure correct spurious split points execution proceed far specified path unable continue due bad decision earlier reduction process 
despite setting deal problems traditionally encountered techniques symbolic execution dynamic domain reduction suffers difficulties due computed storage locations loops 
furthermore clear domain reduction techniques handle non ordinal variable types enumerations 
dynamic structural test data generation discussed relationship input data internal variables structural test data generation difficult analyse statically presence loops computed storage locations 
dynamic methods execute program question input simply observe results form program instrumentation 
array subscripts pointer values known run time problems associated symbolic execution circumvented 
random testing random testing simply executes program random inputs observes program structures executed 
technique works simple programs 
structures executed low probability covered 
consider triangle classification example 
true branch node requires input values equal 
branch executed chance 
domain integer values variable limited values probability variables selected value 
cases directed search technique required locate test data 
applying local search miller combine results actual executions program search technique 
method originally designed generation floating point test data principles widely applicable 
tester selects path program produces straight line version containing path 
branching statements replaced path constraint form ci ci ci ci estimate close constraint satisfied 
example branch predicate form rearranged path constraint abs 
take triangle example execution path 
straight line program respective path constraints re arranged follows int tri type int int int int type int type triangle note value dependent computations 
information required derivation path constraints process test data generation symbolic execution 
constraints function constructed 
value provides real valued estimate close constraints satisfied negative constraints remains unsatisfied positive constraints satisfied 
input values sought numerical maximisation techniques attempt push value closer closer zero hope eventually making positive 
normal conditions execution complete path possible branch predicates encountered path evaluated required manner 
straight line version program possible run time errors occur possible original program 
segment code execution allowed proceed true branch values zero greater size error induced array index assignment statement bounds size ideas miller extended korel pascal programs 
test data generation procedure worked instrumented version original program need straight line version produced 
search targeted satisfaction branch predicate path turn circumventing issues encountered miller 
execute desired path program initially executed arbitrary input 
execution undesired branch taken deviates desired path local search program inputs invoked objective function derived predicate desired alternative branch 
objective function describes close predicate true 
value obtained referred branch distance 
take triangle example execution path 
function executed program input control flow successfully follows false branches relational predicate rel abs abs table korel objective functions relational predicates nodes 
control flow diverges away intended path false branch node 
point local search invoked change program inputs alternative true branch taken 
general branch predicate assumed form op arithmetic expressions op relational operator objective function form rel derived rel table 
function minimised positive zero rel current branch predicate required branch false negative zero rel true 
predicate true branch node objective function 
value function program input 
program instrumented objective values computed 
performed branching expression example follows eval obj 
program function eval obj reports branch distances node local values function return boolean value corresponding evaluation original branching expression order program execution resume normal 
local search deriving input values accordance objective function known alternating variable method 
input variable taken turn value adjusted keeping variable values constant 
stage manipulating input variable called exploratory phase 
probes neighbourhood variable increasing decreasing original value 
move leads improved objective value pattern phase entered 
pattern phase larger move direction improvement 
series similar moves minimum objective function variable 
input variable selected exploratory phase 
return triangle example execution diverged intended path node 
decreases increases effect objective value 
chosen 
decrease leads worse objective value increase leads improvement 
pattern phase entered increased suppose value reached 
new input vector 
control flow proceeds branching node desired execution diverges away void nested example int int int target example nested structures node value node greater value local search invoked time adjust input values true branch taken node whilst maintaining correct subpath node 
new objective function derived true branch predicate 
decrease input value leads violation sub path node improved value objective function increase internal values swapped nodes 
eventually input vector 
input vector evaluates branching node true complete path executed 
local searches final result dependent starting solution 
consider example 
input initially selected control flow proceeds directly final branching node 
variable changed value successful sub path final branching node violated 
case search fail 
heuristic search methods potential moves variable values lead improvement value current cost function 
lead wasteful costly executions program 
triangle example changing value input variable effect branching node 
order search efficient korel extra information derived program form influences graph 
influences graph detect input variables able influence outcome current branching node determined dynamic data flow analysis 
risk analysis input variables undertaken order decide potentially violate successful sub path 
example node attractive manipulate changing may change current successful sub path node 
gallagher narasimhan built korel programs written ada 
particular record support logical connectives branch predicates 
predicates form objective value formed summation individual objective values expressions predicates form objective value minimum value individual objective values expressions 
goal oriented approach published korel developed known goal oriented approach 
techniques concentrate execution path 
fulfilling structural coverage criterion statement coverage means path selected individual uncovered statement 
goal oriented approach removes requirement 
achieved classification branches control flow graph program respect target node critical semi critical non essential 
performed automatically basis program control flow graph 
branches leaving node target control dependent critical branch edge leads execution path away target node 
control flow driven critical branch prospect target reached 
objective function form outlined previous section associated branch predicate alternative branch 
alternating variable search method employed seek inputs alternative branch taken 
required inputs process terminates target remaining 
semi critical branch leads target node backward edge loop 
alternative branch branching node leads directly target node 
case execution driven semi critical branch alternating variable method invoked seek inputs execution alternative branch 
suitable input values process terminate 
execution allowed flow semi critical branch hope alternative branch iteration loop 
non essential branch critical semi critical 
nonessential branches determine target reached regardless position control flow graph 
execution allowed proceed branches 
take example target execution node 
classification branch seen control flow graph 
false branches nodes critical node reached executed 
false branch condition semi critical control flow diverges away target point target may reached iteration loop 
input vector false branch condition taken search procedure invoked change value control flow proceeds true branch node node false branch taken 
search change outcome branch flow control allowed continue loop times true branch node taken target reached 
goal oriented method employs alternating variable local search suffers similar problems korel original approach 
removal requirement select path relieving effort behalf tester introduces new ways test data search fail 
take example execution true branch node 
true branch taken objective values equal zero 
consider happens initial input vector selected zero approximately half input domain 
cfg node void goal oriented example int int target return example goal oriented approach starting point critical false branch node taken 
search fail small exploratory moves effect objective function associated condition concerned value landscape objective function region search space flat 
example attribute failure local search technique 
global search technique genetic algorithm sample input domain thoroughly find required value local search incorporate series restarts 
may required path target node low probability 
genetic algorithms trouble search spaces see section 
korel noted situation avoided data dependencies test goal taken account search attempted address issue chaining approach 
chaining approach chaining approach uses concept event sequence intermediate means deciding type path required execution target node 
event sequence basically succession program nodes executed 
initial event sequence consists just start node target node 
extra nodes inserted event sequence test data search encounters difficulties 
event sequence formally described sequence events ek event tuple ei ni ci ni program node ci set variables referred constraint set 
control flow graph branch classification program 
node target 
represents critical branch semi critical branch non essential branch objective function value cfg node void chaining approach example int int target 
example chaining approach objective function landscape execution node true adjacent events ei ni ci ei ni ci variables constraint set modified 
say definition clear path taken ni ni respect variable ci 
example target execution node 
initial event sequence adjacent events ei ni ci ei ni ci event sequence branches program classed critical semi critical non essential 
exist definition clear path respect variables ci ni ni branch program nodes path exist alternate branch branch declared critical 
branch semi critical critical ni control dependent exist acyclic definition clear path ni respect ci 
branches declared non essential 
goal oriented approach flow control take critical branch 
taken alternating variable method try change execution branching node 
semi critical branches preferably avoided non essential branches ignored 
recall section search inputs execute branching node true program program fail value negative 
executing initial event sequence false branch node critical 
local search unable find input value alternative true branch taken exploratory moves yield change values objective function associated branch 
inputs change flow control critical branch avoided declared problem node new event sequences generated 
instances chaining approach looks definition statements variables problem node 
example variable node variable variable defined nodes 
different event sequences generated inserting event node executed node executed constraint set events includes variable reassignment node destroy effect inserted event node 
event sequence executes exactly path inputs 
outcome different second sequence 
assume input vector 
control flow driven critical false branch node 
alternating variable method try amend 
increments positive effect objective function associated true branch 
eventually input 
flow control driven critical false branch node 
exploratory moves effect objective function associated branch 
increment leads improvement cost function eventually vector 
chaining approach organises generated event sequences tree 
root tree initial event sequence 
level contains event sequences generated result problem node 
complicated examples problem nodes encountered route executing definition node inserted sequence 
instances chaining approach backtracks looks definition statements variables new problem nodes 
additional event sequences added tree 
tree explored depth fashion specified depth limit 
chaining approach generate test data larger class programs goal oriented approach 
search times increase local search employed trapped difficult search spaces 
applying simulated annealing tracey authors applies simulated annealing structural test data generation hope overcoming problems associated application local search 
test data generated specific paths specific statements branches 
order apply simulated annealing neighbourhood structure defined various different input variable types 
integer real variables neighbourhood simply defined range values individual value 
ordering values significant boolean enumerated types values variables considered neighbours 
objective function simply branch distance required branch control flow diverges away intended path away target structure critical branch 
objective functions table principle identical employed korel nonzero positive failure constant added branch predicate evaluates false removes need relation rel function 
way objective function returns value zero predicate false zero true 
order reduce chances search stuck local optima tracey drops constraint employed korel newly generated solution conform successful sub path 
means doing results search losing information progress 
solutions diverge away target earlier critical branches assigned similar objective values diverging away stage 
demonstrated example 
target statement node false branches nodes critical 
korel scheme current solution diverging critical branch node vector consideration successful sub path node violated 
due fact input vector takes earlier critical branch node 
tracey method move take place solutions furthermore solutions rewarded identical objective values distance values taken different branching nodes 
relational predicate objective function obj boolean rue abs abs abs negation moved inwards propagated table tracey objective functions relational predicates 
value refers constant added term true cfg node void landscape example int int target statement 
example comparing objective functions coverage oriented watkins roper evolutionary structural test data generation control oriented structure oriented branch distance oriented jones mcgraw combined control branch distance approaches tracey wegener classification dynamic structural test data generation techniques evolutionary algorithms applying evolutionary algorithms application evolutionary algorithms test data generation referred literature evolutionary testing example 
applying evolutionary algorithms generate structural test data 
point structural test data generation largely focused finding input data specific paths individual structures programs branches statements 
initially techniques genetic algorithms took slightly different directions 
classification techniques different techniques applying evolutionary algorithms structural test data generation categorised basis objective function construction 
coverage oriented approaches reward individuals basis covered program structures 
roper individual rewarded basis number structures executed accordance coverage criterion 
scheme search tends reward individuals execute longest paths test object guidance structures covered chance example deeply nested structures branch predicates true input variable specific value large domain 
watkins attempts obtain full path coverage programs 
objective function penalises individuals follow covered paths assigning value inverse number times path executed search 
direction search constant adaptation 
covered paths provides little guidance discovery new previously paths 
results show comparison random testing genetic algorithm approach required order magnitude fewer tests achieve path coverage experimental programs 
programs simple nature containing loops 
furthermore input domains artificially restricted search 
general problem coverage oriented approaches lack guidance provided structures executed values small portion input domain 
difficult expect full coverage techniques non trivial program 
structure oriented approaches follow similar lines earlier korel take divide conquer approach obtaining full coverage 
separate search undertaken uncovered structure required coverage criterion 
structure oriented techniques differ type information objective function 
categorised branch distance oriented control oriented combined approaches 
branch distance oriented approaches exploit information branch predicates similar style earlier miller korel 
genetic algorithms employed generate test data structures covered random search 
path chosen relevant branch predicates extracted program 
genetic algorithm find input data satisfies branch predicates objective function summing branch distance values 
scheme suffers similar problems suffered miller 
furthermore need select path burden tester 
jones obtaining branch coverage path need selected 
objective function simply formed branch distance required branch 
guidance provided branch reached program structure place 
mcgraw alleviate problem condition coverage delaying attempt satisfy condition branching expression previous individuals reach branching node question 
initial generation target condition seeded individuals 
scheme inefficient test data required coverage specific condition 
earlier korel removed need tester select path 
new test data considered search conform successful sub path explicit control oriented information regarding target need included objective function 
rigid constraints increase chances search stuck local optima better feedback provided objective function 
problem addressed control oriented approaches 
control oriented approaches objective function considers branching nodes need executed desired way order bring execution desired structure 
approach jones loop testing falls category 
objective function simply difference actual desired number iterations 
statement branch coverage control dependence graph test object 
sequence control dependent nodes identified structure 
branching nodes executed specific outcome order structure reached 
objective value objective function value objective function landscape example individual simply assigned number control dependent nodes executed intended 
recall branch leading away target control dependent node identified critical branch korel 
measure equivalent number critical branches successfully avoided individual 
problem control information purposes objective function form objective function landscape 
objective function gives guidance change flow execution control dependent nodes distance information exploited branch predicates 
take simple example 
target node control dependent node turn control dependent node 
dependent number control dependent nodes current target executed number control dependent nodes successfully executed required manner 
minimising version objective function computed dependent executed 
scheme individual diverging away target node receives objective value individual diverging node receiving value 
landscape minimising version objective function example seen 
landscape 
individuals satisfying branch predicates guidance descend landscape solutions closer executing target 
horizontal planes search random 
combined approaches branch distance control infor objective function value objective function landscape tracey example objective function value objective function landscape wegener example mation objective function 
tracey builds previous simulated annealing 
strategy combining techniques follows 
control dependent nodes target structure identified 
individual takes critical branch nodes distance calculation performed branch predicate required alternative branch 
computed functions table table logical connectives 
tracey uses number successfully executed control dependent nodes scale branch distance values 
branch dist branch distance calculation performed branching node critical branch taken 
formula tracey computing objective function executed branch dist dependent unfortunately scheme lead unnecessary local optima objective function landscape 
example evident valleys objective function landscape seen 
wegener map branch distance values branch dist logarithmically range call branch dist 
minimising objective function zero target structure executed objective value computed dependent executed branch dist dependent executed sub calculation referred approximation level appropriately approach level attained individual 
resulting objective function landscape similar form 

extra information provided branch distance calculation prevents formation approach level 
example result sweeping landscape level level downwards 
objective functions different structural coverage criteria detailed far structural test data generation mainly addressed statement branch condition coverage 
wegener new structure oriented objective functions introduced previously unexplored coverage types 
purpose structural criteria divided categories node oriented path oriented node path oriented node node oriented basic form minimising objective function approach level branch dist strategy approach level branch dist computed varies coverage type question 
node oriented criteria aim cover specific nodes control flow graph example statement coverage 
strategy node oriented methods discussed section 
approach level calculated basis number control dependent nodes target lying nodes covered individual target node 
point control flow diverges critical branch branch distance calculated predicate alternative branch 
path oriented criteria require execution specific paths control flow graph 
possible ways calculate objective function 
method calculate approach level basis length identical initial path section branch distance calculation performed predicate diverging branch 
alternative strategy considers identical path sections approach level branch distance calculation accumulation distance calculations point divergence intended path 
wegener report superior results method 
node path oriented criteria include branch coverage linear code sequence jump coverage node specific subsequent path executed 
objective function combined node oriented calculation 
calculations individuals reaching initial node treated node oriented criteria 
individuals reaching initial node path oriented calculation additionally applied 
node node oriented criteria aim execute certain sequence nodes control flow graph specification concrete path node 
includes data flow oriented coverage types defs criteria 
case objective function cumulative node oriented strategy 
calculations individuals failing reach node carried node oriented methods individuals reaching subsequent node having additional calculations carried nodes 
control related problems objective functions provision guidance structures nested loops presents problem demonstrated 
target execution node 
node control dependent node paths false branch node execute node subsequent iterations loop 
consequently search receive guidance regarding fact true branch node needs taken target statement reached 
results poor search performance 
approach taken baresel treat branches target iterations loop critical branches recall branches classed semi critical korel 
node treated control dependent node 
appears approach taken tracey 
leads individuals iteration loop 
example input variable objective value taken iteration 
individual closest executing target statement iteration loop 
furthermore input value individual deemed missed cfg node void loop example int int target statement loop example control flow graph target target executed iteration loop 
order circumvent problem tracey examines branch distance iteration loop uses minimum branch distance obtained purposes computing final objective value 
problem assignment approach levels classes program unstructured control flow 
baresel example 
target search node 
different control dependent paths node node control dependent paths node 
consequently approach level possibilities node paths length possibilities node 
plausible solutions problem include optimistic pessimistic approach level allocation strategies 
optimistic strategy control dependent branching node allocated approach level basis shortest control dependent path target node 
way node assigned approach level basis direct path receiving level node 
pessimistic strategy branching node allocated approach level basis longest control dependent path target node 
scheme node assigned approach level basis path nodes 
optimistic pessimistic schemes put test initial experiments baresel 
whilst show different schemes different effects progress search unable conclude experiments strategy works best general 
problem open question 
branch distance related problems objective functions global search techniques robust local searches objective function landscapes containing local optima struggle hostile search landscapes containing large local optima 
particular induced search space flag variables branch predicates 
flag simply boolean variable 
flag variables involved branch predicates resulting objective cfg node switch case cond return cond break case cond break return target statement example demonstrate problems unstructured control flow entry control flow graph control dependence graph control graphs example objective function value flag flag result result flag example objective function landscape flag example function landscape consists true value false value 
situations evolutionary search performs better random search 
demonstrates example 
true branch executed flag true 
objective function gives guidance true value brought 
plateau induced objective function landscape seen 
proposes solution special case flag problems similar form example value flag determined predicate 
suggested predicate distance calculation substituted predicate assigning flag value 
essentially objective function landscape provides guidance required test data 
flags commonly assigned constant true false values seen 
objective function value objective function landscape predicate case expression leading true assignment control assignment 
note true branch node executed test data execute preceding true branch node 
simplicity possibility ignored purposes example section 
harman suggest program transformation remove flag variables branch predicates replacing expression led determination 
transformed version program branch predicate flag free consequently induced flag removed 
shows possible transformation program 
note flag removed branch predicate remains program case purpose statement 
objective function new branch predicate useful landscape 
transformed program merely means discarded required test data 
disadvantage approach transform programs flags involved loops 
approach baresel identify sequence nodes executed prior branch predicate containing flag 
example true branch node required clear node needs executed node reached 
sequence nodes executed performed data flow analysis flags involved 
flag node defined nodes node assigning false value node assigned required true value 
required sequence cfg node flag false flag true flag result result alternative version flag example flag false flag true result result flag removed branch predicates program transformation 
guidance provided search form predicate true branch node required execution node 
approach handles nodes executed example flag reassigned false nested statement nodes 
solution dissimilar static version chaining approach 
objective functions executing node sequences dissimilar node node oriented functions discussed section 
approach problems avoiding assignments flags loop bodies 
aside problems local optima appearing objective function landscape entirely possible branch distance calculation deceive search 
consider example 
goal execute true branch final branching node branch predicate 
zero zero 
objective function works guide search away equal zero increasing values decrease values deceiving search believing getting closer closer zero depicted objective function landscape 
problem occur nested branch predicates seen example 
example input data satisfying solution attempted 
input data conditions chances finding input objective function value target branch deceptive objective function example landscape deceptive objective function data fits subsequent conditions decreases 
solution subsequent conditions violating earlier conditions 
leads poor search performance 
ideally conditions evaluated 
values modified branching statements predicates evaluated branching statement 
situation established data dependency analysis 
similar problem occurs short circuit evaluation atomic conditions branch predicates operators situations evaluation predicate breaks early result determined 
process searching test data individual conditions attempted 
example 
preferable evaluate conditions 
situation care needs taken side effects appear conditions 
solution apply side effect removal program transformation 
alternatively variables values saved temporary variables inserted immediately branching statement restored side effect condition normally evaluated 
applying variable dependence analysis harman apply variable dependence analysis determine subset input variables affect outcome branch predicate 
way search space reduced increasing chances finding solution potentially finding faster 
take triangle example 
branching node input variables relevant 
variable affect outcome node need included search 
branching node input variables relevant may determined outcome prior nodes 
ideas similar korel influences graph see section information statically computed structural target 
variable dependence analysis information compute slice program respect structural target 
program slice smaller version original program contains statements interest slicing criterion 
case criterion involves removal statements affect attainment desired structure 
slices potentially useful cut time required execute program evaluate individuals search 
generating input sequences problem structural test data generation test objects internal states 
situations input sequence required cover certain structures 
take example 
variable counter declared static 
means value counter retained function call time executed 
branching node requires executions function true branch feasible 
baresel aim circumvent branch coverage encoding individuals sequences input vectors 
sequence length order calls function performed 
function called times individual chances execute desired branch 
objective value individual calculated approach level branch distance closest point executing branch 
input sequence individual closest executing true branch branching node call branch distance required individual execute target structure call function 
drawback scheme tester idea long sequence going 
maximum sequence length short target structure unreachable 
long search take longer fail find test data 
variable length encoding solve problem 
problem scheme works states individual functions 
general case state behaviour exhibited modules data types objects 
example demonstrates 
true branch function test executed part tick function dependent module executed number times 
extension scheme baresel incorporate function identification number extension deal different type functions order generate test script execution target structure 
problem state systems tendency flag enumeration variables control current state 
suggest approach combining evolutionary search test data construction event sequences similar style chaining approach 
construction event sequence infer function call sequence required solving flag problems 
incur performance penalties evolutionary search take place step construction event sequences 
problem potentially occur chaining tree event sequences large search exhaustively 
cases suggest heuristics pursue exploration promising sequences 
evolutionary algorithms encodings operators early applying genetic algorithms structural test data generation binary encodings 
jones improvement gray code 
common variables valid values subset possible bit patterns binary level 
addition range imposed ordinal type compiler input variables restricted certain range context application 
problem occur binary encodings corruption occur restricted types actions crossover mutation operators 
problem raised tracey 
shows chromosomes const int threshold int sequence example int int int static int counter branching node counter counter threshold branching node return return test sequence generation example void check time static time get time void tick target branch time int get time return time function test dependent module test sequence generation example multiple functions representing integer variables restricted 
crossover locus yields offspring 
final variable chromosome range 
solution restrict crossover points boundaries variable making impossible variable value go range 
chromosome damaged mutation operator 
possible solution repair penalise invalid individuals 
alternative real valued encoding 
decision taken tracey wegener 
real valued encodings crossover naturally restricted boundaries variable 
example mutation operator number creep introduced section care ensure value shifted required range 
real valued encoding removes need encode decode input vector binary format 
directions search structural testing search structural testing problems involving flag enumeration variables unstructured control flow state behaviour described 
furthermore may variety reasons test data ease program structures search techniques 
insights metrics research area tune existing techniques 
furthermore search structural testing limited programs numerical nature 
programs involving strings dynamic data structures lists trees problematic necessary determine required size shape execution program structure 
shape tree example determined branches number nodes level 
initial korel area utilises local search adapt dynamic data structure matches requirements path executed 
may necessary find special values special orders data structures example string specifying date 
initial area includes baresel 
problems dynamic types include comparison pointer locations 
traditional distance approach compare memory locations information real guiding search appropriate test data 
extensions search structural test data generation object oriented systems complicated problems internal states objects inherently state 
issues include polymorphic types 
method called object different types test data generation system needs decide version interface needs instantiated 
possible areas research include programs information files sockets 
initial structural testing distributed systems includes ferguson korel 
functional black box testing section discusses application metaheuristic search techniques testing logical behaviour system described form specification 
generating test data specification jones generate test data triangle classification program specification 
state space system described schema named declares input integer variables represent sides triangle 

schema describes invariants inputs check lengths specified range side lengths represent valid triangle 
checks included operations declared 
operations decide triangle scalene ri equilateral ri isosceles ri right angled ri 
schema system declared ri ri ri ri purposes test data generation disjunct considered route system 
genetic algorithms search test data satisfies route 
fitness function rewards individuals come close satisfying conjuncts route 
case equilateral triangle predicates satisfied include invariants state space schema ri schema 
conjunct evaluated distance approach similar fashion branch distance calculations structural testing 
fitness route summation distances conjuncts 
results report successful test data generation genetic algorithm routes examination ri ri ri ri 
example small general establish usefulness 
furthermore small subset limited relational operators 
testing specification conformance section showed test data generated formal specification 
tracey extends idea 
technique conformance implementation specification checked executing test object generated test data validating output specification 
int wrapping counter int int return wrapping counter example specification implementation represented pre condition defines valid inputs post condition defines output 
failure input situation discovered satisfies precondition function outputs violate post condition 
objective function derived describes closeness test data uncovering situation metaheuristic search techniques employed seek failures implementation 
simple example take wrapping counter function 
function implements counter takes integer value returns increment 
input counter wraps round 
pre condition function simply post condition input value return value 
constraint system derived describe conditions implementation non conformance pre condition conjunction negated post condition objective function derived indicate close failure constructed constraint system rules tables obj obj min obj obj obj obj landscapes objective functions derived constraint systems contained areas 
shows objective function landscape faulty version program branch predicate replaced 
objective function zero indicating fault 
plateau forms values 
results min operator objective function 
connective objective function obj obj obj min obj obj obj min obj obj obj obj min obj obj obj obj xor obj min obj obj obj obj table tracey cost functions logical connectives obj individual cost connective objective value operand obj obj smaller objective value second operand obj obj 
guidance search improved converting constraint system disjunctive normal form disjunct basis separate search 
conversion original constraint system equation disjunctive normal form gives disjuncts disjunct disjunct objective functions disjunct respectively disjunct obj obj obj obj disjunct obj obj obj obj shows landscape faulty branch predicate objective functions disjuncts respectively 
seen landscape second disjunct range gives guidance failure point objective value zero 
tracey applied technique testing safety critical nuclear primary protection system written pascal 
sub systems available evaluation 
consisted pages formal vdm sl specification second pages approximately lines executable code 
pre post conditions function sub system manually derived specification different disjuncts obtained 
mutation testing tool generate mutant implementations code 
simulated annealing genetic algorithms metaheuristic searches technique 
searches killed approximately non equivalent mutants outperforming hill climbing random searches achieved scores 
wegener evolutionary algorithms test specification conformance early version automated vehicle parking system 
system aims automate parking vehicle parking space objective function value objective function landscape wrapping counter example information environmental sensors register surrounding objects 
individuals search simply parking scenarios describe dimensions parking space including collision areas starting position car 
parking control unit called data parking manoeuvre simulated 
successful test causes collision objective function simply value smallest distance car collision area recorded simulation 
experiment undertaken approximately scenarios simulated scenarios leading collisions 
analysis scenarios discovered controller difficulties scenarios parking space distance away starting position near collision area side 
fault detected simulation environment calculations involving position car imprecise 
lead simulated impacts collision area 
baresel test simulink stateflow models require input signal sequences generated 
problem domain generation realistic signals potential length result large search space 
baresel propose novel solution building signal series simple signal types example sine spline linear curves 
search space set parameters construct signal section built base signal example ampli objective function value objective function value disjunct disjunct objective function landscapes individual disjuncts wrapping counter example tude length 
guarantees generation realistic input signals keeping size search space relatively compact 
cruise control system tested technique 
system senses approach slower vehicles automatically slows car maintain safe distance 
objective function checks violations requirements checking dependencies output signals checking output signal boundary violations checking signal maximal overshoot settlement time 
tests revealed system broke maximal speed violation certain input conditions 
directions search functional testing activity area search functional testing compared structural testing 
functional tests derived different forms specification 
tests derived way barrier complete automation fact mapping needs provided model specification concrete form implementation 
system tests potential problem size search space 
possible solution innovative encodings afore mentioned scheme baresel generating input signals base signal types 
potential problems include existence internal states 
test sequences may need generated put system valid state order property interest tested 
search may need additional information regarding state structure system 
grey box testing grey box testing combines structural functional information purposes testing 
assertion testing korel attempts find test cases violate assertion conditions embedded programmer program code 
assertions specify constraints apply state computation 
assertion evaluates false error program 
assertions embedded comment regions boolean conditions example assertion program statement executable code 
assertions embedded blocks executable code special variable assert 
assigned true false values denote correct incorrect state assertion 
example assertion checks elements array sorted ascending order assert true len assert false normal program code 
korel showed search test data falsify assertion reduced problem executing specific statement program 
assertions stripped code 
boolean conditions code generated placed assertion original position 
assertion condition negated 
new condition condition represents violation finding fault 
converted disjunctive normal form 
series nested statements generated condition individual disjunct 
statement evaluated true violation reported 
example take assertion condition 
negated form assertion 
code generated negated condition disjunctive normal form report violation report violation goal search execute report violation statements 
assertions appearing code assertion code formed function original assertion comment region replaced call function 
goal execute false assignment assert variable statement function avoiding true assignments variable 
process test data generation performed chaining approach section 
addition programmer embedded assertions korel tool automatically generates assertions run time errors division zero errors array boundary violations overflow errors 
tool tries find input data stimulate error conditions variables program statement 
initial experiments original pascal programs embedded assertions 
faulty versions produced 
experiments inputs violate assertion reveal fault time 
exception condition testing tracey built ideas korel genetic algorithms simulated annealing generate input data test handling run time error conditions code 
languages java ada run time errors known exceptions 
languages provide explicit exception handling constructs exception related code separated main logic program 
tracey generate test data raising exception structural coverage exception handler 
korel problems reduce problem execution certain statement statement triggers exception throw raise statement sequence statements code raising exception followed coverage structural element exception handler 
experiments undertaken simple programs lines code 
metaheuristic techniques generate test data raise exception conditions contained code full branch coverage exception handlers existed 
industrial experiment undertaken engine controller 
test data generated raised variety exception conditions 
exceptions raised practice input situations generated possible actual operation system 
directions search grey box testing ability embed arbitrary assertions programs able search test data order check violation powerful concept 
applications assertion testing suggested tracey 
idea includes component reuse testing 
amounts searching test data causes component called usage assumptions described assertions broken 
application checking outputs structural tests 
presently checked manually 
black box assertions oracle tests offering automation process 
non functional testing date search testing effort area non functional testing concentrated checking best case worst case execution times realtime systems 
execution time testing correct operation real time system depends logical behaviour timing behaviour 
general incorrect timing behaviour real time system occurs outputs produced early late 
execution time testing involves attempting find worst case execution time wcet best case execution time bcet system order determine compliant timing constraints 
task extremely difficult achieve timing behaviour piece software dependent internal structure characteristics target hardware 
software level timing dependent instructions corresponding data items 
compiler introduce effects apparent source code level 
hardware level accounting actions target processor extremely difficult caching pipelining operations need considered 
consequence longest shortest path program necessarily yield longest shortest execution time 
static analysis static analysis derive upper lower bounds wcet bcet respectively order try ensure timing schedules met 
performed examining possible execution paths modelling timing behaviour hardware level 
primary step needs assistance programmer information required regarding infeasible paths maximum number iterations loop appearing code 
unfortunately possibility simulation errors need human involvement error prone process 
result produced extremely pessimistic case wcet optimistic case bcet 
estimates vary observed practice magnitude times consequently calculations produced need tested 
course tests derived expose flaws logical behaviour generally little benefit domain 
search execution time testing search execution time testing seeks input situations invoke extreme execution times 
objective function simply execution time system executed input 
search attempts maximise objective function case wcet minimise case bcet 
test case violates timing constraints search terminated 
wegener apply genetic algorithms temporal testing 
experiments shown genetic algorithms yield better results random testing 
number experiments industrial test objects carried 
experiment investigated time critical tasks engine control system 
genetic algorithms outperform random search tests constructed developers 
developer tests longest execution times cases developer tests worse random tests 
developers internal knowledge system results met surprise 
wegener suggest may system calls linkage compiler optimisation effects temporal behaviour guessed difficulty developers 
additional sullivan applies cluster analysis determine search terminated 
technique decides search converging basis distribution individuals search space 
apply genetic algorithms find wcet programs differing execution time behaviour 
results compared obtained random search upper wcet bounds static analysis best effort times researcher efforts wegener private communication 
find input data yield wcet 
genetic algorithm match find longer times random search 
superiority genetic algorithm particularly evident large input domains 
genetic algorithm similar times best effort analysis case finding longer time 
whilst upper bound times static analysis broken matched occasions 
practice unusual times provided static analysis generally pessimistic optimistic wcet bcet respectively 
tracey employs simulated annealing genetic algorithms finding wcet handful small understood programs written ada known wcet behaviour 
experiment deemed success technique executed path program yielded known wcet 
genetic algorithms successful simulated annealing outperformed hill climbing random search 
genetic algorithm achieved success fewer trials simulated annealing 
particular study varying parameters optimisation techniques little effect result apart initial temperature set low simulated annealing dependency starting position lost 
unfortunately branch program executed low probability chance search technique executing low 
branch involved path leading extreme execution time extreme execution time 
gross identifies number properties programs lead low probability branches example high levels nesting branches executed input variable specific value 
just features exist source code necessarily mean extreme execution time 
gross conducted empirical study handful test objects establish system predict testability test objects source code 
empirical study small consisting fifteen test objects 
type test objects characterised particular way effects underlying hardware accounted 
furthermore dependence prediction system setting genetic algorithm parameters established 
wegener investigated objective function landscape timing behaviour 
due fact execution times input vectors executing program path identical common landscape 
discontinuities formed significant differences execution time slightly different input vectors leading execution different paths 
findings help explain little improvement obtained local search improve times genetic algorithms wegener tracey 
experiments performed show superiority search approaches random testing 
whilst search techniques guarantee actual wcet bcet best result obtained form interval time obtained static analysis actual extreme execution time probably lies 
directions search execution time testing search techniques shown bind execution times opposite ends static analysis interesting published attempts combine relative benefits order yield tighter bounds 
example potential incorporate domain knowledge static analysis 
surprising cues source code machine code details regarding hardware included benefit search 
gross suggests input human knowledge 
conversely search techniques verify path feasibility static analysis 
strategies guaranteeing survival path number generations suggested literature 
author knowledge published reporting effectiveness ideas 
particular search strategies adapted give low probability paths special treatment directing search untried areas example branch distance calculations ensuring genetic algorithm maintains certain level diversity proportion population utilising paths instantly killed 
possibility combine objective function structural test data generation ensure timing behaviour involving branches explored 
instances care needs taken avoid probe effects deviations actual runtime behaviour due effects instrumentation 
search execution time testing far largely restricted programs procedural nature 
extending techniques object oriented software appear 
directions search non functional testing non functional testing largely restricted execution time testing 
possibilities automating non functional tests search approaches 
example resource usage software tested searching input situations cause constraints memory storage requirements broken 
similar fashion search approach automatic detection memory leaks may possible 
possibilities search automation include stress testing security testing 
surveyed application metaheuristic search techniques software test data generation 
search software test data generation just example search software engineering 
structural test data generation metaheuristic dynamic approaches compared static techniques symbolic execution 
techniques symbolic execution evaluate program code order build system constraints describing test goal 
problematic presence loops cases computed storage locations need determined 
trying formulate constraint system dynamic approaches merely execute program input examine effects form program instrumentation 
helps circumvent problems associated static techniques dynamic information example pointer locations known run time 
metaheuristic techniques search test data 
metaheuristic technique requires definition objective function rewards test data solutions basis close fulfilling required test goal 
coverage oriented objective functions reward input data basis number program structures executed 
argued structure oriented approaches represent successful strategy 
individual uncovered structure receives specific attention form individual search 
individual search provided explicit guidance coverage structure question automatically tailored objective function 
guidance nested structures executed special circumstances exercised 
search test data generation approaches functional testing largely focused seeking input situations demonstrate implementation conform specification 
executions test object monitored input data solutions rewarded basis close discovering failure decided specification 
grey box test data generation approaches combine methods generating structural functional testing 
showed korel violation program embedded assertion reduces problem executing program statement 
structure oriented white box testing techniques attempt induce violations assertions 
discussed results obtained testing areas successful experiments undertaken real world examples drawn industry 
problems need solved area directions research outlined section 
sponsored daimlerchrysler research technology 
author mike holcombe joachim wegener andr baresel various anonymous referees comments earlier drafts sections 
deceptive function example section due mark harman search software engineering workshop windsor september 
harman jones 
search software engineering 
information software technology 
clark harman hierons jones mitchell rees roper shepperd 
reformulating software engineering search problem 
iee proceedings software 
reeves editor 
modern heuristic techniques combinatorial problems 
mcgraw hill 
corne dorigo glover editors 
new ideas optimization 
mcgraw hill 
metropolis rosenbluth rosenbluth teller teller 
equation state calculations fast computing machines 
journal chemical physics 
kirkpatrick vecchi 
optimization simulated annealing 
science 
ck schwefel 
survey evolution strategies 
booker belew editors proceedings th international conference genetic algorithms pages san diego california usa 
morgan kaufmann 
ck 
evolutionary algorithms theory practice 
oxford university press new york 
whitley 
overview evolutionary algorithms practical issues common pitfalls 
information software technology 
holland 
adaptation natural artificial systems 
university michigan press ann arbor 
whitley 
genitor algorithm selection pressure allocation reproductive trials best 
schaffer editor proceedings rd international conference genetic algorithms pages san mateo california usa 
morgan kaufmann 
deb goldberg 
comparative analysis selection schemes genetic algorithms 
rawlins editor foundations genetic algorithms pages 
morgan kaufmann san mateo california usa 
whitley 
free lunch proof gray versus binary encodings 
proceedings genetic evolutionary computation conference pages orlando florida usa 
morgan kaufmann 
whitley rana mathias 
evaluating evolutionary algorithms 
artificial intelligence 
goldberg 
genetic algorithms search optimization machine learning 
addison wesley 

new interpretation schema notation binary encoding constraint 
proceedings rd international conference genetic algorithms applications pages san mateo california usa 
morgan kaufmann 
davis 
handbook genetic algorithms 
international thomson computer press 
mitchell 
genetic algorithms 
mit press cambridge ma 
srinivas 
genetic algorithms survey 
ieee computer 
whitley 
genetic algorithm tutorial 
statistics computing 
ferrante ottenstein warren 
program dependence graph optimization 
acm transactions programming languages systems 
king 
new approach program testing 
proceedings international conference reliable software pages 
acm press 
king 
symbolic execution program testing 
communications acm 
clarke 
system generate test data symbolically execute programs 
ieee transactions software engineering 
boyer levitt 
select formal system testing debugging programs symbolic execution 
proceedings international conference reliable software pages 
acm press 
ramamoorthy ho chen 
automated generation program test data 
ieee transactions software engineering 
garey johnson 
computers intractability guide theory np completeness 
freeman new york 
demillo offutt 
constraint automatic test data generation 
ieee transactions software engineering 
offutt jin pan 
dynamic domain reduction procedure test data generation 
software practice experience 
miller 
automatic generation floating point test data 
ieee transactions software engineering 
korel 
automated software test data generation 
ieee transactions software engineering 
gallagher narasimhan 
test data generation suite ada software systems 
ieee transactions software engineering 
korel 
dynamic method software test data generation 
software testing verification reliability 
korel 
automated test generation programs procedures 
international symposium software testing analysis issta pages san diego california usa 
ferguson korel 
chaining approach software test data generation 
acm transactions software engineering methodology 
tracey clark mander mcdermid 
automated framework structural test data generation 
proceedings international conference automated software engineering pages hawaii usa 
ieee computer society press 
tracey clark mander 
way forward unifying dynamic test case generation optimisation approach 
international workshop dependable computing applications pages 
dept computer science university south africa 
wegener buhr 
automatic test data generation structural testing embedded software systems evolutionary testing 
proceedings genetic evolutionary computation conference gecco pages new york usa 
morgan kaufmann 
harman hu hierons baresel sthamer 
improving evolutionary testing flag removal 
proceedings genetic evolutionary computation conference gecco pages new york usa 
morgan kaufmann 
wegener 
evolutionary functional testing automated parking system 
international conference computer communication control technologies th 
international conference information systems analysis synthesis orlando florida usa 
ellis le gall 
application genetic algorithms software testing application des algorithmes au test des 
th international conference software engineering applications pages toulouse france 
roper 
computer aided software testing genetic algorithms 
th international software quality week san francisco usa 
watkins 
automatic generation test data genetic algorithms 
proceedings fourth software quality conference pages 
jones sthamer 
automatic structural testing genetic algorithms 
software engineering journal 
mcgraw michael schatz 
generating software test data evolution 
ieee transactions software engineering 
harrold peck 
test data generation genetic algorithms 
software testing verification reliability 
tracey 
search automated test data generation framework safety critical software 
phd thesis university york 
wegener baresel sthamer 
evolutionary test environment automatic structural testing 
information software technology 
baresel sthamer schmidt 
fitness function design improve evolutionary structural testing 
proceedings genetic evolutionary computation conference gecco pages new york usa 
morgan kaufmann 

instrumenting programs flag variables test data search genetic algorithm 
proceedings genetic evolutionary computation conference gecco pages new york usa 
morgan kaufmann 
baresel sthamer 
evolutionary testing flag conditions 
proceedings genetic evolutionary computation conference gecco lecture notes computer science vol 
pages chicago usa 
springer verlag 
harman hu zhang munro 
side effect removal transformation 
proceedings th ieee international workshop program comprehension iwpc pages toronto canada 
ieee computer society press 
harman hu zhang munro wegener 
post placement side effect removal algorithm 
proceedings th ieee international conference software maintenance icsm pages montreal canada 
harman fox hierons hu danicic wegener 
transformation system variable dependence analysis 
nd ieee international workshop source code analysis manipulation scam pages montreal canada 
weiser 
program slicing 
ieee transactions software engineering 
baresel 
structural functional sequence test dynamic state software evolutionary algorithms 
proceedings genetic evolutionary computation conference gecco lecture notes computer science vol 
pages chicago usa 
springer verlag 
holcombe 
state problem evolutionary testing 
proceedings genetic evolutionary computation conference gecco lecture notes computer science vol 
pages chicago usa 
springer verlag 
ferguson korel 
generating test data distributed software chaining approach 
information software technology 
jones sthamer yang 
automatic generation software test data sets adaptive search techniques 
proceedings rd international conference software quality management pages spain 
spivey 
notation manual 
international series computer science 
prentice hall nd edition 
tracey clark mander 
automated program flaw finding simulated annealing 
software engineering notes issue proceedings international symposium software testing analysis issta pages 
korel 
assertion oriented automated test data generation 
proceedings th international conference software engineering icse pages 
tracey clark mander mcdermid 
automated test data generation exception conditions 
software practice experience 

testing results static worst case execution time analysis 
proceedings th ieee real time systems symposium pages madrid spain 
ieee computer society press 
wegener sthamer 
testing temporal behavior real time tasks extended evolutionary algorithms 
proceedings th european conference software testing analysis review barcelona spain 
wegener grimm sthamer jones 
systematic testing real time systems 
proceedings th european conference software testing analysis review amsterdam netherlands 
wegener sthamer jones 
testing real time systems genetic algorithms 
software quality journal 
wegener 
verifying timing constraints real time systems means evolutionary testing 
real time systems 
wegener sthamer 
automated testing real time tasks 
proceedings international workshop automated program analysis testing verification limerick ireland 
sullivan wegener 
testing temporal correctness real time systems new approach genetic algorithms cluster analysis 
proceedings th european conference software testing analysis review munich germany 

gross 
prediction system evolutionary testability applied dynamic execution time analysis 
information software technology 

gross 
evaluation dynamic optimisation worst case execution time analysis 
proceedings international conference information technology prospects challenges st century 

gross 
evolutionary testing component real time system construction 
proceedings genetic evolutionary computation conference gecco late breaking papers pages new york usa 

