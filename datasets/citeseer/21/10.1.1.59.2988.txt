anomaly detection self nonself discrimination lars olsson june thesis show computers protect different forms attacks mis configurations program errors 
inspired immune system similar vein immune system system learns distinguish self nonself 
learning done system call level profiles constructed analysed programs 
scheduler decides processing time process normal program behaves 
system seen homeostatic feedback loop analysis system calls sensor scheduler actuator tries maintain stable environment 
system implemented couple modules linux kernel analyses system call programs added system 
learn analyse profiles system calls tried different methods table lookup method feedforward neural network elman recurrent neural network 
experiments show system detect methods intrusion including buffer flow attacks format string attacks trojan code 
contents 
aim 
background related 
overview 
biological inspiration homeostasis immune system homeostasis 
immune systems 
artificial immune system algorithms 
homeostasis immune systems attractive metaphors computer science 
normal abnormal program behaviour kernel mode user mode system calls 
system calls program behaviour 
analysing system call sequences 
lookahead pairs 
neural networks 
design implementation requirements 
kernel implementation 
design 
system call hijacking 
profiles training 
scheduling abnormal processes 
user interface 
implementation 
user view system 
experiments results detected 
buffer overflow attacks 
format string exploits 
trojan code 
summary detection experiments 
line experiments 
analysis discussion slowing system calls 
performance different learning algorithms 
different abnormal sequences normal sequences 
determinism sequences system calls 
problems approach system 
source code development testing 
installation usage 
sandbox module 
makefile 
pl 
proc interface 
homeos defs 
homeos profile 
proc io 
sensor 

feed forward 
elman 
profile io 
sandbox 
homeos utils 
main 
proc interface 
proc io 
sensor module 

profile io 
homeos profile 
lookahead profile 
homeos prof 
sandbox 
homeos utils 
start homeos 
homeos 
tcl 
timer tcl 
chapter computer systems interconnected vulnerable various forms deliberate attacks configuration mistakes program errors 
growing need autonomous self controlling systems abundance computers impossible computers close supervision humans 
computers left extended periods time human intervention need know protect 
major question computer science performance anymore survival 
system designed order survive 
looks animals experts survival share common design ideas 
important ideas homeostasis 
homeostasis basically way maintaining stability example keeping constant body temperature sensors actuators coupled feedback loops 
system existing mammals immune system distinguish cells belonging animal self cells belonging animal nonself 
foreign cell immune system eliminated 
thesis investigates ideas taken biology create computer systems protect little human help possible 
specifically look operating system protect processes start behave differently normal behaviour 
process start behave differently potentially dangerous computer number reasons 
reason error program causing execute normal potentially dangerous sequence system calls 
reason mis configurations example web server potentially opens security loop holes causes web server properly 
computer attacked foreign computer hacker 
typical attack called buffer overflow attack basically exploits kind weakness design programming attacked process causes process execute commands code inserted attacker 
detect abnormal behaviour focus system calls processes operating system modern operating systems way user space process interact operating system hardware 
aim aim investigate operating system protect abnormal behaviour implement real system linux kernel 
difference done area implemented complete line system just proof concept line learning algorithm 
important reasons 
developing software operating system put constraints software example speed programming constructs 
line system built impossible slow real operating system 
running system part operating system easier test number different programs collection data needed 
background related wants build secure system different approaches follow build system way dangerous unauthorized activities take place 
best way extremely difficult may impossible system isolated environment interactions computers 
detect illegal dangerous activities happen 
ideal system activities compromise system 
detect illegal activities occurred try determine damage done 
systems including tripwire third way maintaining set cryptographically secure checksums files system 
possible detect possible attacks comparing saved checksums actual checksums files find possible damage 
virus detection system similar method scan local network storage signatures known viruses 
computer security intrusion detection area focus detect respond attacks outside 
basic approaches intrusion detection misuse intrusion detection anomaly detection 
misuse intrusion detection known patterns signatures known intrusion methods identify attacks happen 
anomaly detection systems hand assumed patterns intrusion unknown intrusion classified different normal behaviour system 
misuse detection assumes pattern intrusion known new kinds attacks 
dorothy denning generic intrusion detection model shown 
thesis denning generic model build anomaly detection system interested detecting novel attacks 
current commercial academic systems tries implement second method described detecting stopping attacks happen 
study popular intrusion systems effectiveness stability tested systems bad winner test 
major problem high rate false positives means false warnings intrusions 
major problem denning generic intrusion detection model 
system generates false positives turned possibly neglected warns real intrusion 
severe error false negatives system detect real attack 
seminal forrest established analogy human immune system intrusion detection :10.1.1.47.6145
showing correlations fixed length sequences system calls executed process signature profile determining self program 
analysed traces system calls quite complex unix programs including sendmail lpr possible build profiles programs short sequences system calls 
profiles see process behaving normal different kinds common intrusions changed sequences system calls 
system developed line previously collected data quite simple table lookup algorithm learn profiles programs 
forrest analyses alternatives table lookup algorithm including methods frequencies different system calls data mining technique hidden markov models hmms :10.1.1.47.6145:10.1.1.46.2976
show hmms exceptional accuracy high computational cost 
simpler table methods performs cheaper execute 
research groups tried complex machine learning algorithms 
ghost tried different machine learning algorithms including table lookup algorithm back propagation feed forward neural network 
early algorithms fixed sequence lengths analyse sequences 
authors describe variable length sequence matching algorithm known teiresias algorithm identify anomalies sequences system calls 
sekar show language designed called ree regular expressions events conjunction extended finite state machine generate intrusion detection system 
system user needs create specification legal behaviour ree process manually 
similar approach show possible add code operating system user programs detect attacks 
course assumes source code programs operating system available user 
assumes user knowledgeable program identify security holes normal behaviour programs 
far tell examples discussed implemented proof concept line systems real time intrusion detection systems embedded operating system 
real anomaly detection system ideas developed implemented anil somayaji writing phd thesis :10.1.1.47.6145
system ph process homeostasis implemented linux kernel great inspiration thesis 
thesis somayaji shows operating system try maintain stable environment slowing processes behave learned profile 
user decide anomalies part normal behaviour process 
system developed thesis quite similar borrowed lines code somayaji system see comments source code 
major difference design difference changes somayaji profile training algorithm system different training algorithms 
described inspired network intrusion detection see example :10.1.1.47.6145:10.1.1.31.7474
focus traffic different machines 
analysing system calls self defined normal pattern ip addresses ports 
nonself traffic ip addresses ports set normal traffic patterns 
combining system call trace analysis network methods 
example authors describe architecture complete agentbased system different agents monitor different parts networks including system call analysis network traffic authentication processes 
earlier forrest inspired general pattern recognition algorithms see example nice overview common algorithms :10.1.1.47.6145
overview rest thesis structured follows 
chapter describe discuss biological inspiration homeostasis immune systems 
chapter describe behaviour programs seen sequences system calls 
shortly describe system calls relate operating systems user space processes 
describe design implementation system chapter 
chapter describe experiments done results 
chapter contains analysis results chapter contains 
appendix contains source code instructions build system 
chapter biological inspiration homeostasis immune system chapter discusses biological inspiration thesis 
describe organising principle homeostasis describe fundamental properties homeostatic system animals immune system 
discuss relates computer science homeostasis immune systems metaphors inspiration building secure stable computer systems 
homeostasis biological systems maintain stable internal state monitoring responding internal external changes 
self monitoring seen defining properties life generally known homeostasis 
homeostatic systems studied extensively completely understood 
general feature sensors monitor property body example body temperature 
sensors coupled effectors example blood vessels extremities contract body cold 
reserves greater proportion body heat inner core body individual warmer 
homeostatic systems generally properties state need maintained closed system state maintained sensor detect current state effector change state monitored state 
table summarizes properties shows relate homeostatic system temperature regulation 
abstraction temperature regulation closed system body individual state temperature sensor specialized nerve cells effector muscles table defining properties homeostatic system 
biological metaphors computing right level abstraction needs 
think abstractions artificial system correspond abstraction biology 
table shows biological abstractions table find abstractions build intrusion detection system 
abstraction anomaly detection closed system individual computer state normal program execution sensor sequences system calls effector delayed canceled system calls table defining properties homeostatic intrusion detection system analysing sequences system calls 
reasons analysing sequences system calls sensor 
system calls way program interact operating system hardware see chapter 
reason fairly easy detect detection done overhead 
abnormal behaviour detected dealt 
system inspired slow processes start behave abnormal 
option killing executing processes letting abnormal system calls return error code 
immune systems immune system complex homeostatic system responsible defending body misbehaving foreign cells 
overview immune system computer scientists biological overview 
immune system consists large number cells molecules interact number different ways detect eliminate dangerous agents pathogens 
interactions depend chemical bonding localised 
surfaces immune system cells covered receptors bind immune system cells molecules achieve communication signaling mediate immune response 
cells bind chemically pathogens 
cells travel body blood lymph systems centralised control little hierarchical organisation :10.1.1.31.7474
detection elimination pathogens result cells interacting simple local rules 
classic view see immune system system distinguish self nonself self body nonself pathogens 
pathogens dangerous eliminating harm body 
better definition say immune system distinguishes harmful nonself self :10.1.1.31.7474
harmful pathogen detected deleted 
different pathogens eliminated different ways immune system needs choose right kind effector eliminate particular pathogen 
known works signaling form cytokines probably plays part regulating cells common cells immune system 
artificial immune system algorithms years researchers computer science started develop algorithms especially pattern recognition inspired biological immune systems 
overview known algorithms 
describe algorithms negative selection algorithm 
ways immune system achieves self tolerance correct discrimination self nonself allowing detector cells mature isolated settings 
cells example mature thymus undergo stages maturation including genetic rearrangements positive selection negative selection 
special interest negative selection cells bind strongly self proteins destroyed 
principle design change detection algorithm follows suppose collection data 
collection defined self goal monitor self changes 
data sequences system calls executable file file containing kind data 
generate set detectors fail match self 
detectors monitor protected data 
detector finds match change occurred monitored data know know pattern matched detector 
observe algorithm uses closed world assumption 
detector match self matches part nonself 
homeostasis immune systems attractive metaphors computer science discussed immune systems properties attractive computer science point view 
distributed body central controller single point failure 
especially attractive feature called carrier class systems usually systems demanding environments telecom systems defense single point failure allowed high reliability necessary 
immune systems diverse enhances robustness individual population level different people may vulnerable different pathogens 
components immune systems constantly created destroyed moved body leading dynamic system increases temporal spatial diversity 
interesting aspect immune system self protecting immune system protects mechanisms protects rest body 
important feature immune system distributed nature adapt learn recognize respond new foreign pathogens 
features added sounds ideal design distributed computer system 
needed way design structure computer systems homeostatic systems immune systems forms feedback loops control 
thesis investigate systems security system analysing sequences system calls designed 
sense seen low level reflex system similar movements carried consultation brain moving hand hot stove 
build really stable secure system built principles feedback systems designed example log analyzers network usage system properties designed 
chapter normal abnormal program behaviour chapter describes user programs interact operating system hardware solely set system calls 
interface described different ways representing program behaviour sequences system calls discussed 
kernel mode user mode system calls modern cpus run different modes usually called kernel mode user mode 
process executing instance program called process executed user mode directly access kernel data structures kernel programs 
program runs kernel mode restrictions longer apply 
primitive operating systems example ms dos user mode programs allowed direct access hardware 
linux operating system modern operating systems windows nt user program issues request operating system wishes access hardware resource 
request granted operating system interacts hardware device behalf user program 
user space programs requests operating system kernel set system calls 
system call called user program arguments system call example file name mode open call placed specific registers processor 
user program executes special hardware dependent instruction int cpus cpu changes user mode kernel mode 
usually done standard library libc possible user programs system calls directly kernel 
system call dispatcher kernel checks system call parameters formed allowed 
wrong error code returned cpu changes back user mode 
kernel executes system call returns status executed call cpu changes back user mode 
shows relation kernel user programs 
system calls fact way user space programs interact kernel examples system calls write read chmod chdir execve way execute new process 
kernel mode gray colour user mode system call interface 
different classes computer program behaviour 
system calls program behaviour program user expects perform certain task 
program perform task faulty input broken network card user expects program halt execution inform user 
defined legal program behaviour 
hand program intended programmer error mis configuration deliberate attack user seen illegal abnormal behaviour 
way program normally behaves particular computer particular configuration seen normal behaviour 
especially true programs execute long time web ftp servers 
displays relation normal legal abnormal program behaviour 
user space program interacts kernel hardware devices network interfaces hard drives system calls behaviour process seen kernel point view sequence system calls arguments system calls 
far regarding anomaly intrusion detection systems sequences system calls arguments calls studied :10.1.1.25.7298
probably due complexity analysing arguments 
define sequences system calls program executes normal execution self problem detecting abnormal behaviour problem finding sequences system calls profile normal behaviour nonself 
build profiles number different machine learning algorithms 
described section 
analysing system call sequences useful programs execute thousands millions system calls lifetime necessary focus sub sequences windows system calls 
system analyses system calls able detect abnormal behaviour occurring needs execute fast probably part kernel 
problem build profile sequences system calls define self program 
formally problem build alphabet possible system calls linux 
ti trace calls length window size profile set patterns associated detect sequence exists algorithm able say abnormal hamming distance way measuring difference sequences 
lookahead pairs anil somayaji uses algorithm called lookahead pairs build profiles 
window sequence system calls recording system call call came current window 
formally definitions section define profile consisting number pairs system calls si sj si sj tp si tp sj concrete consider sequence system calls brk open read fstat old mmap open mprotect brk system call mprotect sequence 
suppose window size profile look table 
note open follows current position position brk open brk old mmap fstat read open brk fstat read open old mmap fstat read mprotect open old mmap table sequence represented 
brk old mmap open entry position 
determine sequence profile check new traces profile method 
profile consider happen sequence brk open mprotect profile mprotect follow open entry brk position mprotect sequence classified abnormal 
method possible measure abnormal sequence counting number entries sequence profile 
example sequence abnormal count sequence mprotect read open abnormal count 
know training profile finished 
author describes step heuristic depends total number calls seen far calls seen profile edited 
total count total number seen calls mod count number calls seen profile edited 
profile frozen total count total count mod count changes changes profile normal wait seconds profile said normal ready 
profile changed frozen frozen flag set 
note names encoded numbers linux kernel 
mapping asm header file 
architecture feed forward neural network elman recurrent neural network 
nodes labeled input nodes nodes labeled hidden neurons nodes labeled output nodes 
elman recurrent net nodes labeled context memory nodes 
neural networks way build profiles traces system calls neural networks 
thesis different types neural networks classic back propagation feed forward elman recurrent neural networks :10.1.1.117.1928
architecture type network shown 
types networks input neuron represents call window system calls window size network input neurons 
feed forward network output neuron value depends input sequence abnormal 
elman networks memory neurons predict sequences 
usually output neurons input neurons values output neurons sequence 
sequence example window size starting left input 
output sequence 
formally input sequence corresponding output neurons values 
sum absolute differences input values values output neurons calculate error training 
training done back propagation algorithm feed forward network elman network 
space possible sequences bigger space normal sequences training starts training networks random data 
random data classified abnormal behaviour 
network trained detect training normal data normal 
get performance number networks trained data methods described varying number hidden nodes optimal number hidden nodes known training 
able train neural network profiles line 
line system described chapter 
compute abnormal sequence leaky bucket algorithm described 
leaky bucket algorithm keeps memory events accumulating networks output 
value slowly leaking 
abnormal system calls abnormal count quickly accumulate large value 
hand calls normal anomaly counter leak away anomaly value eventually reach zero 
chapter design implementation chapter describes design implementation system 
discuss requirements different possible ways implement system reasons decided design 
design described chapter ends description interesting parts data structures actual implementation 
source code appendix description files instructions build system 
requirements major goal building system design reactive system protect computer processes executing unwanted system calls 
goal divided requirements system monitor processes system call level 
profiles created monitored programs kind machine learning algorithm 
implemented algorithms far algorithm similar algorithm described regular feed forward neural network elman recurrent neural network :10.1.1.117.1928
moment possible train neural network profiles line trained profiles line system 
profile program stabilized processes executing program monitored abnormal behaviour 
preferably algorithm able say abnormal process behaving 
computer protect slowing abnormal process 
user notified process behaving abnormal opportunity accept abnormal behaviour normal incorporate profile kill process 
system stable fast run production servers 
fairly easy install require user patch recompile kernel 
kernel implementation 
requirements listed decided implement system part linux kernel 
necessary reasons 
reason wanted monitor processes system call level 
possible user space programs ptrace system call apparently working perfectly slows computer significantly 
option patch standard libc library 
possible programs bypass library direct calls kernel option able catch system calls 
second reason system able change scheduling abnormally behaving processes needed put part code kernel 
context switches kernel user mode expensive performance point view realised complete kernel implementation way go 
putting system kernel system secure extremely hard hacker change insert new code running security module important note system implemented part linux kernel possible build install run recompiling actual kernel 
reason system implemented kernel modules 
kernel modules basically code example device drivers loaded linked kernel needed removed longer needed 
design advantages disadvantages discussed 
design conceptually system consists different parts 
need access system calls executed 
executable wish monitor represented profile 
need train profiles monitored programs 
profiles see process behaving abnormal 
abnormally behaving slowed depending abnormal behave 
programs processes monitor administration system done user interface 
interface shows information processes executing processes 
data 
shows relation parts rest operating system 
reality system divided different modules 
module responsible accessing system calls executed 
system call hijacking problem faced monitor system call 
system implemented modules impossible add code actual system call dispatcher 
system call module implements version system call 
module initialised function pointer global sys call table array replaced corresponding function implemented original pointers saved pointers call original system calls 
probably impossible 
see example hacker phrack anonymous author describes possible patch linux kernel inserting new module 
problem method hacker needs root system usually goal attack 
system design 
system consists changed train process syscall delay process module profiles interface subsystems 
reason separate system call module rest system twofold 
firstly separating functionality separate module modules need monitor system calls example sandbox module described appendix secondly important possibility race conditions system unloaded longer needed 
suppose system built module 
module unloaded original system call function pointers need put back sys call table 
problem possible turn interrupts changes array atomic 
problem system calls take seconds days execute waiting special event occur 
calls return return address corresponding function hijacking code 
code unloaded address contain total system crash occur 
solution separate hijacking code separate module unloaded 
user requests unload module changes back original system calls remove reality refuses removed memory 
module occupies memory high price pay stable system 
profiles training module responsible functionality relating program profiles interface user 
program monitored profile 
program executed independent processes time process individual state structure shares actual profile processes executing program 
processes train update single process time 
speeds training assume instances executing program behaves similarly 
profiles saved file time process exits cached memory faster recollection 
user adds program monitor user interface added list monitored programs 
time execve way start new program system call executed list monitored programs traversed 
program new process added monitoring system 
profile profile program process executing cache disk new empty profile created 
scheduling abnormal processes process behaving abnormal slowed letting process sleep executing system calls 
length sleep depends abnormal process behaved 
current implementation process anomaly window consisting latest executed system calls 
window originally filled abnormal call value changed 
possible keep track abnormal call process done calls normal call change value back 
value calculate number milliseconds sleep 
ab number abnormal calls calls 
process sleep delay factor ab 
internal time measurement linux generally ms platform means operating system switches processes times second 
observe amount time abnormal processes sleep increases exponentially depending value ab 
user interface user communicates system module writing reading files proc homeos directory resides proc filesystem 
proc filesystem virtual filesystem vfs means represent physical device 
designed allow easy access information processes name nowadays part linux kernel interesting report 
implemented graphical user interface language tcl tk gives commands read data system writing reading files proc homeos 
shows gui 
implementation actual implementation system consists lines including lines generated automatically list available system calls 
lines code copied anil somayaji system ph described data structures quite similar 
copied functions commented code note function copied ph 
development kernel probably possible compile system kernels 
quite big complex program describe certain parts implementation overview 
central code struct homeos task state represents monitored process see 
central data structure homeos profile structure represents profile executable file 
structure dependent learning algorithm graphical user interface 
typedef struct int max lfc unsigned char window locality window len typedef struct homeos sequence int unsigned char seq max sequence len homeos sequence struct homeos sequence seq int delay int unsigned long count int pid char program homeos max file name struct entry kernel struct semaphore endif structs represent executing process 
typedef struct unsigned long mod count unsigned long unsigned long sequences unsigned char entry num num struct int normal char homeos max file name char program homeos max file name long normal time int unsigned long count int anomalies kernel struct semaphore endif structs represent lookahead profile 
shows data structure lookahead pairs algorithm 
algorithm described detail section 
observe central data structures contain semaphores 
necessary need protected different problems occur single multiprocessor systems due concurrency 
system call executed user process executes version system call located system call module 
located look apart execve fork deal execution new programs processes 
calls looks similar unsigned int fd const char buf count nr write return fd buf count return sensor hook system saved sys write function pointer original system call 
function sensor calls homeos system call anomaly detection system potentially systems interested system calls sandbox described appendix homeos system call train function called profile locked process added list monitored processes 
profile process normal considered stable checked executed system call normal 
profile unlocked function returns 
call abnormal process put sleep function homeos task delay schedule timeout kernel function 
function invokes schedule function selects process execution 
number process put sleep depends abnormal call described section 
process executed returns sensor 
real system call executed 
observe call analysed called possible disallow call executed 
option just putting process sleep behaving abnormally 
user view system user influence running system ways 
user add delete programs monitor 
possible see properties currently monitored processes 
properties include profile process frozen normal number anomalies currently delayed see 
user influence running processes different ways monitored process killed 
monitored process stopped monitored 
profile process reset 
process profile set normal normal monitoring starts 
process 
process 
commands meaning inspired similar processes real immune systems 
means user regards program behaviour normal system classified abnormal 
hand tells system learned behaviour process forgotten profile 
chapter experiments results chapter describes experiments performed results 
method follows 
showing types behaviour detected looking sequences system calls 
important shows kind anomalous behaviour system theoretically able detect 
done designing program vulnerable certain kind attack 
program analysed program find sequence system calls executed program 
tried exploit see results sequence system calls 
tried system detect exploit 
done training system normal behaviour program profile considered normal executed exploit 
behaviour looked just change source code simple program 
done show small changes source code program change sequence calls 
shows programs executed linux experiments 
describe classic hacker attacks buffer overflows trojan horses format string exploits detected analysing sequences system calls 
describe experiments done line different machine learning algorithms implemented represent profiles programs 
data number different programs sendmail ps wu ftp downloaded www cs unm edu 
show different algorithms lookup tables feed forward neural network elman recurrent network learn profiles detect anomalies 
detected 
program executed linux things happen actual program code programmer wrote executed 
executable file needs executable format determined 
file copied working memory memory areas mapped 
main function program called 
concrete consider classic hello world program listed prints hello world terminal exits 
view behaviour program system call level program 
program outputs system calls program arguments standard include include int main int argc char argv char msg world msg msg return hello minimal hello world program system call write directly printf minimal amount libc code 

shows output hello see program executes system calls write called system call programmer called source code 
hello program changed example start program command line argument sequence system calls changes 
consider program hello 
command line argument give exactly series system calls hello started argument sequence look 
notice small change code program lead major change sequence system calls executed program 
result shows possible detect different behaviours programs analysing sequence system calls execute 
trained system learn behaviour hello detected changed hello code hello started argument 
buffer overflow attacks buffer overflows involve program uses fixed amount storage save kind external data 
program programmer ensure external data fits storage possible overwrite neighbouring memory locations example return addresses functions 
concrete consider small program 
program input longer bytes data th byte written data stack 
intel processors turns return address program start executing returns parse char arg stored array param stack 
stack grows lower addresses string longer bytes case overwrite return address 
usually results segmentation fault illegal instruction return address overwritten usually points random position memory 
specially designed string constructed return address points address executable code code executed 
consider example program 
program designed output sequence bytes standard output generate buffer overflow executed ordinary input bytes size execute system calls system calls programs execute described 
hand output overflow executing overflow execute program calling execve code calling execve compiled homeostasis hello execve hello hello vars uname sys linux node 
brk open ld preload file directory open ld cache fstat st mode st size 
old mmap null prot read map private close open lib libc read elf fstat st mode st size 
old mmap null prot read prot write map private map anonymous old mmap null prot read prot exec map private mprotect prot old mmap prot read prot write map private map fixed old mmap prot read prot write map private map fixed map anonymous close write hello world hello world 
exit homeostasis include include system calls hello world program 
int main int argc char argv char msg world argc system date msg msg return hello program executes program date command line argument prints hello world terminal 
homeostasis hello 
close rt sigaction sig ign sig dfl call due system date rt sigaction sig ign sig dfl rt sig block fork wait sat aug bst null rt sigaction sig dfl null rt sigaction sig dfl null rt sig null call system date child exited exit homeostasis system calls 
notice small change code program give difference sequence system calls execute 
include include void parse char arg char param int param arg return main int argc char argv parse argv program attacked buffer overflow 
note char array characters long 
strcpy check length buffer copies 
arg longer buffer stack overwritten 
include assembly code code code system execve program ebx 
movl esp ecx move esp ecx xor eax eax put eax push eax push eax esp ebx put tmp sh ebx add xc esp add esp push eax push eax push ebx push ebx movl ecx edx move ecx edx movb xb move execve low ax want execute system binary machine code assembly code char code xe xc xf xc xb movl esp eax int main int argc char argv int long unsigned esp int argv putchar putchar code tmp sh memory code address address esp esp stdout overflow program create buffer overflow program output program input program 
program creates string bytes containing machine code representation executing execve system call tmp sh executed program 
tmp sh symbolic link program 
program executed suid root superuser privileges tmp sh executed root privileges 
string bytes contain number nop instructions 
length depends buffer size param buffer 
code output 
thing note argument string seen execve system call 
nop instructions needed fill buffer 
see actual code executes system call psa 
follows program executed tmp sh followed address overwrites return address stack 
thing note second execve call 
see tmp sh executed buffer overflow succeeded executing program 
course bad news possible execute arbitrary programs overflowing buffers 
news buffer overflow probably execute sequence system calls normal behaviour program 
system detects changes normal behaviour analysing sequences system calls detect buffer overflow correctly trained 
consequently tried train system managed detect buffer overflow started input overflow format string exploits kind commonly intrusion technique format string exploits 
idea exploit fact printf family functions example fprintf format strings control output 
programmer forgets add format string prints string user typed functions user supply format string input 
cleverly crafting format string example possible read change value variable program see example 
detected system changed value variable causes program execute piece code executed 
program typical program exploited format string exploit 
important thing notice call done format string 
prototype int char str size size char format 
program vulnerable format string argument user 
works fine long actual format strings string 
data taken stack 
format string exploits gain root access system 
fashion somewhat similar buffer overflow described possible design input string contains machine code starting shell 
test program called downloaded generate string 
trained system vulnerable profile normal string generated input vulnerable expected system succeeded detecting exploit gives root shell vulnerable started suid root 
trojan code aim experiment see system detect changes way program behaves executable file replaced recompiled configuration 
example case trojan horse attack commonly buffer overflow execve psa tmp sh vars uname sys linux node 
brk old mmap prot read prot write map private map fixed map anonymous close execve tmp sh tmp sh var overflow uname sys linux node 
brk open ld preload file directory open ld cache fstat st mode st size 
old mmap null prot read map private close open lib libc read elf fstat st mode st size 
old mmap null prot read prot write map private map anonymous old mmap null prot read prot exec map private mprotect prot old mmap prot read prot write map private map fixed old mmap prot read prot write map private map fixed map anonymous close brk brk ec ec brk sequence system calls executed special overflow string written overflow note trace edited places space reasons 
firstly reality nop instructions argument string execve call starts deleted standard system calls processes execute see section 
note second execve system call executed buffer overflow string 
include include int main int argc char argv char argc exit failure argv exit success vulnerable program attacked format string exploit 
note function called supplied format string 
argument program argv format string 
program taken 
program example su replaced recompiled new code 
code usually leaves backdoor hacker longer knows root password 
test form attack backdoor source code patch secure shell allows users connect foreign machine encrypted communication channel 
patch applied possible user login machine patched version installed typing special password compiled compromised program 
password gives user root shell normal authentication logging procedures 
normal version get normal profile analyse sequences system calls manually 
tried patched version profiles similar 
tried login special password execve call execve call 
system able detect intrusion 
summary detection experiments experiments showed classical ways hacker gain access system causes attacked program execute different trace system calls 
table summarises results 
observe attacks detected attack changed trace detected system buffer overflow format string new shell format string change read variable trojan code backdoor table results exploit experiments 
attacks changing reading value variable change sequence system calls 
line experiments test lookahead pair feedforward elman network profile algorithms tested data downloaded www cs unm edu 
different traces described table information data sets captured website 
normal data sets divided equally program intrusion traces normal traces normal system calls sendmail ps wu ftp table data line experiments 
note intrusion traces synthetic attacks designed unm researchers sendmail real captured attacks wu ftp ps 
sized sets data training evaluation 
intrusion traces see trained networks detect intrusions 
neural networks cross validation training described section tried neural networks number different internal nodes program 
program lookahead table feed forward elman recurrent network sendmail ps wu ftp table percent false 
results neural networks denotes best trained network program 
percentage percentage system calls classified abnormal taken tha normal evaluation data 
table shows results best trained neural networks program lookahead pair algorithm 
see elman recurrent neural network slightly better lookahead pair algorithm basic feed forward network performs worse methods 
expected feed forward contains memory problems classifying sequences 
final experiment performed see different training algorithms detect intrusions 
lookup table algorithm elman neural network detect intrusions data described table 
feed forward network detect sendmail intrusions wu ftp intrusions ps intrusions 
chapter analysis discussion chapter discusses results experiments discusses general points regarding intrusion detection nature system call traces 
slowing system calls defense mechanism system slow abort processes behave abnormally 
idea slowing process system administrator time analyse behaviour process process run slow attacker unable finish attack 
seen experiments attacks discovered slow process little sleeping time depends abnormal process behaving 
attack changes normal sequence calls hardly notice slowed process 
course depends process put sleep 
problem slowing processes behave abnormally possibility denial service dos attacks provoking abnormal behaviour process cause execute slower 
solved killing restarting abnormally behaving processes 
performance different learning algorithms elman neural network performed couple problems neural networks real line systems 
problem execution speed 
neural networks considered fast machine learning algorithms slower simpler table lookup methods 
done experiments say certain neural network algorithms slows computer table lookup methods slows computer system call intensive applications executed 
observe elman recurrent neural net performs better feed forward neural net slower contains nodes uses extra set hidden nodes context nodes 
problem fact neural networks usually floating point representations cause problems execute kernel mode 
reason linux kernel save floating point registers switches user mode kernel mode back due performance reasons 
solved ways 
implementing integer neural network saving floating point registers time neural network executed restoring 
quite costly system probably execute hundreds thousands times second considered feasible option 
thing consider neural networks ability generalise 
reason decided try considered generalisation solution false positives 
thinking attractive generalisation context 
question neural network trained generalise new normal behaviour considered normal 
attack may consist new system call neural network say normal behaviour way trained 
philosophy false positives bad better false negatives warning real intrusions simpler table lookup method secure neural network approach 
different abnormal sequences normal sequences 
started look data generated experiments done chapter concerning different exploits soon realised usually small difference abnormal behaviour normal behaviour regarding system calls 
usually system calls difference exploited program issues execve call 
sequences quite regular sub sequences fairly deterministic 
data downloaded www cs unm edu reinforced view 
compared different types system calls ps program issued normal data exploit data exactly system calls albeit somewhat different sequences 
certainly hold possible types attacks probably majority 
reasons goal attacker usually gain superuser access commonly done executing execve new shell superuser access 
point program probably behaving completely normal hard detect 
simple quite effective intrusion system intended defend computer intrusions intension gain superuser privileges need monitor programs abnormal execve calls 
confirm idea analysis live wu ftp data source 
bigger differences normal abnormal data 
system calls unlink exploit data calls normal data 
reason calls normal data program exit execute program attacked 
unique calls abnormal data calls perform exploit 
determinism sequences system calls information theory entropy measure uncertainty impurity collections data 
formally entropy data source defined pi log pi finite number states data pi probability variable state xi 
entropy value smaller data pure variables belong state class 
way seeing entropy see number bits needed represent state program unique calls log entropy sendmail wu ftp mp player emacs table entropy traces number different programs 
unique calls denotes number uniquely system calls log number bits needed represent system call trace calls probability entropy entropy trace 
table shows entropy system call traces number programs 
thing note average program uses different system calls 
interesting note server programs sendmail wu ftp programs lowest entropy 
means traces regular easier predict example emacs 
results surprising emacs program interacts user sendmail wu ftp server programs basically executes loop waits clients connect server 
done measure determinism regularity trace system calls computing conditional entropy trace :10.1.1.25.7298
collection sequences system calls length window size 
sequence denoted 
cn cn ci system call 
collection subsequences subsequences defined 
cn 
collection subsequences window call shorter conditional entropy measures uncertainty remains sequence seen formally conditional entropy defined xi yj log yj pi seen measure hard data model 
investigate idea sequences system calls quite regular deterministic computed conditional entropy number traces including data sendmail wu ftp ps downloaded www cs unm edu emacs run system 
conditional entropy case measures conditional entropy normal traces exploit traces 
system calls sequence determines nth system call result zero means completely deterministic 
traces sendmail wu ftp contained different system calls ps trace consisted different calls 
shows results window size sendmail wu ftp ps emacs 
see conditional entropy wu ftp program ps highly similar 
window bigger conditional entropy suggesting value nth call highly deterministic system calls seen 
sendmail conditional entropy starts high gets values ps wu ftp window bigger calls 
window bigger calls value indicating highly predictive behaviour 
conditional entropy abnormal traces exploits quite similar normal traces difference slightly predictive small window sizes 
general results surprising sendmail complex program harder predict 
system window size reasonable size considering results 
problems approach system noticed number potential weaknesses problems approach anomaly detection attacker knows system system call anomaly detection system 
possible hacker design special attacks example buffer overflow strings alter trace system calls 
attacks detected system 
denial service attacks 
protection method system delay abnormally behaving processes denial service attacks 
solution problem restart important processes behave abnormally 
conditional entropy normal traces exploit traces 
profile normal 
wait week changes profile regarded normal sure 
lead problems false positives 
generalisation thing anomaly detection system 
risk generalisation classify dangerous attack normal 
stability performance problems 
implemented system stable days computer 
user program causes problems 
system started music player playing music graphical user interface program freezes 
idea 
chapter thesis studied operating systems designed detect respond various forms anomalous behaviour built system studied principles 
detect anomalies analyse sequences system calls user space applications call operating system kernel 
argue best level place intrusion detection system way programs access files hardware modern computers 
detect abnormal behaviour profiles built application models normal sequences system calls application calls 
problem detecting abnormal behaviour distinguish normal behaviour self abnormal behaviour nonself 
number ways build profiles thesis tried different methods lookup table feed forward neural networks elman recurrent neural networks 
results experiments show elman network feed forward network slow line system need execute executed system call part linux kernel 
speed extremely important tested methods lookup table method fast 
experiments shown commonly attack methods including buffer overflows format string exploits trojan code usually change sequence system calls attacked program executes 
theoretically possible detect forms attacks monitoring sequences system calls applications execute 
number problems suggested approach anomaly detection 
important denial service attacks exploit fact abnormally behaving programs slowed 
possible attacker deny application deliberately slowing 
problem build models normal behaviour 
model alarm program behaving normal alarm program behaving abnormal 
researchers claim answer problem generalisation know generalising profile identify abnormal behaviour normal know abnormal behaviour look 
problems system call intrusion detection advantages methods misuse detection 
major advantages intrusions detected real time possible detect novel attacks 
major advantage user need specialised knowledge system learns monitored programs normally behaves 
need analyse source code change code monitoring logging done operating system 
conclude definitely believe system call anomaly detection 
computers abundant autonomous need method survive 
discrimination self nonself probably 
bibliography aleph smashing stack fun profit phrack issue www phrack org ross ashby cybernetics chapman hill london internet pcp vub ac books pdf daniel marco understanding linux kernel reilly neil campbell biology th edition benjamin cummings publishing de castro artificial immune systems novel paradigm pattern recognition alonso fyfe editors artificial neural networks pattern recognition university paisley dorothy denning intrusion detection model proceedings symposium security privacy patrik stephanie forrest paul helman immunological approach change detection analysis implications proceedings ieee symposium security privacy jeffrey elman finding structure time cognitive science terry intrusion detection john wiley sons stephanie forrest stephen hofmeyr information processing immune system lee cohen editors design principles immune system distributed autonomous systems oxford university press stephanie forrest perelson allen self nonself discrimination computer proceedings ieee symposium research security privacy stephanie forrest steven hofmeyr anil somayaji thomas longstaff sense self unix processes proceedings ieee symposium computer security privacy ieee computer society press ibrahim haddad charles dsi secure carrier class linux linux journal issue august simon haykin neural networks second edition prentice hall guy johnny wong honavar les miller intelligent agents intrusion detection proceedings ieee information technology conference ghosh aaron michael schatz learning program behaviour intrusion detection usenix proceedings workshop intrusion detection network monitoring stephen hofmeyr stephanie forrest architecture artificial immune system journal computation florian eugene spafford diego zamboni embedded sensors detecting network attacks proceedings acm workshop intrusion detection systems brian dennis ritchie programming language second edition prentice hall gene kim eugene spafford experiences tripwire integrity checkers detection technical report csd tr department computer sciences purdue university kim peter bentley human immune system network intrusion detection proceedings th european congress intelligent techniques soft computing wenke lee dong xiang information theoretic measures anomaly detection proceedings ieee symposium security privacy may mcgraw gary felten edward understanding keys java security sandbox authentication javaworld may david newman joel snyder rodney thayer crying wolf false alarms hide attacks network world www com june lars olsson sandbox processes programs users implemented linux kernel module www shell linux se lars sandbox ps december sd sf cz anonymous linux fly kernel patching phrack issue www phrack org alexander writing linux device drivers reilly scut exploiting format string vulnerability www team net articles march sekar synthesizing fast intrusion prevention detection systems high level proceedings th usenix security symposium august claude shannon warren weaver mathematical theory communication university illinois press lee cohen editors design principles immune system distributed autonomous systems oxford university press anil somayaji operating system stability security process homeostasis phd :10.1.1.47.6145:10.1.1.31.7474:10.1.1.25.7298:10.1.1.117.1928
thesis university new mexico july andrew tanenbaum albert operating systems design implementation prentice hall international root kit ssh www ne jp linux january christina stephanie forrest barak pearlmutter detecting intrusions system calls alternative data models proceedings ieee symposium security privacy andreas wespi marc dacier debar intrusion detection system teiresias pattern discovery algorithm proceedings appendix source code chapter contains source code programs described thesis :10.1.1.46.2976
describing development method installation usage described 
source code listings short description sandbox module developed part project 
development testing development kernel modules quite different regular applications see excellent overview kernel debugging development 
problem mistakes accessing null pointer crashes computer just single application 
debugging complex impossible write terminal infinite loops causes computer freeze 
tricky test code needs inserted kernel executed 
reasons started developing testing possible modules regular programs test harnesses 
designed code possible regular applications conditional compilation 
symbol kernel decide code included kernel 
important functionality tested function level module level 
manage source code cvs important functions regression tests detect errors caused new code changes old code 
installation usage build system simply needs type 
compiles files file created pl compilation modules sensor homeos sandbox see directory 
directory contains number utility programs including homeos prof program modules save profiles profile reader program examine saved profiles 
start system script start homeos 
starts sensor module homeos module inserting kernel 
starts user space program homeos prof save profiles file 
interact system user program writing reading directly files proc filesystem 
system script homeos 
script sends save exit command homeos module saves profiles homeos prof terminated 
homeos module removed kernel 
sandbox module source code listing contains code sandbox module configure system calls specific program process user allowed execute 
example simple security system described section disallowing execve system call 
module compiled modules compiled inserted typing root sandbox module new implementation uses interface described 
id cc gcc change una learning warn wall copt malign defines ke dde includes copt learning defines learning defines learning defines dlo defines dke main san homeos homeos sensor sandbox sandbox de cc echo 
rm 
bin needs see id open file stderr fi stderr st num name names num name stdi chop num stdi chop stdi stderr head see id include include sandbox endif running return head map map map stderr map map map arguments function int long long running tup cha init change stderr define add progr define remove pr define remove pr define config fil void void endif home see id homeos define homeos define homeos pr undef debug define debug lev define light define average define strong de define proc define main define profile de define syscall de debug define deb define define endif info err kernel define info define err define info define err endif endif typedef struct int normal long int unsigned long int unsigned long unsigned long unsigned long unsigned long unsigned long unsigned long unsigned char unsigned char char char program typedef struct som struct int normal char char program long int unsigned long int kernel struct endif typedef struct int unsigned char typedef struct ho int unsigned char homeos sequence typedef struct proc see id proc io define proc io include include void int str int st int int uns int uns int uns read int int int int int int int int int feed see id feed forw define feed forw define num input define num hidde define num struct double double double double double double struct void str void str endif elm elman see id elman elman define elman define num input define num hidde define num struct elman netw double double double double double double double double int struct node ab typedef struct char program int struct node program node ab typedef struct int pid int struct endif hom see id char mai homeos im copyright program free program gnu general ha foundation contact lars olsson proc returns void cleanup home info info cl macros proc see id include include include include include asm include include include include include name define root dir names define processes define add progr define remove pr define remove pr define save prof define load prof name define info file define config fil struct struct struct void char name int name nam void create create proc see id include include include include asm include include include asm sem include include include include include define message le define mod read doe returns nu const int char message return add program returns nu const char unsigned int memset strcmp add remove pr pid strcmp err return read doe returns nu const char unsigned int memset return count re returns nu char char message int int return depend change tr num te num doing returns int unsigned char header debug switch case header header break case train memcpy pa returns nu char message int int return pid message sens see id kernel define kernel endif include include con include include include include include include asm include include include include include include include include macros com module module author define save void pr homeos pro atoi parse temp program prev program temp temp tem prev pr temp prev nex return prev program returns null homeos pro homeos program temp pr return null prog pro adds void homeos program prog nu return programs programs tem temp temp nex program returns void remove homeos program info remove prog prog nu info void int pid info remove pid atoi void info programs nu info ok info info void info info info include asm include asm sem include asm ato include asm include asm include asm include include include include include include include include include include include include include struct mmap arg unsigned long unsigned long unsigned long unsigned long unsigned long unsigned long struct unsigned long inp struct struct semaphore declare mutex int int usage int void void int sandbox return endif running unsign unsign nr mount unsign nr unsign unsign unsign nr stime unsign unsign nr alarm unsign unsign nr pause unsign nr utime unsign unsign unsign nr sync unsign unsign nr rename unsign nr mkdir unsign nr rmdir unsign nr dup unsign unsign nr unsign nr unsign unsign unsign unsign unsign nr unsign unsign unsign unsign unsign unsign unsign unsign unsign nr symlink unsign unsign unsign unsign nr unsign unsign nr unsign nr vm old unsign nr wait unsign unsign unsign unsign unsign unsign nr unsign nr uname unsign unsign unsign nr mprotect unsign unsign unsign unsign unsign unsign unsign unsign unsign nr sched ge unsign unsign unsign unsign unsign unsign unsign unsign nr unsign unsign unsign nr vm unsign nr query mo unsign unsign unsign unsign unsign unsign unsign unsign nr unsign unsign unsign unsign unsign unsign unsign unsign unsign nr unsign unsign unsign unsign unsign nr chown unsign unsign unsign unsign unsign unsign nr return return long return return long return return long return return long return return long return return int int char ge ptr err goto return return long return return long return return long return return long return return long return return int return return unsign return return long return return long return return long return return int return return long return return unsign return return long return return long return return return int ho return return long return return long return return long return return long return return long return return long return return long return return long return return long return return long return return long return return long return return long return return long return return return int ho nr return old return long nr return sa return long return return long return return long return return long return return long return return long return return long return return long return return int ho return return int return return long return return int ho return return long return return return long return return long return return long return return unsign return return long return return long return return long return return long return return long return return long return return long return return long return return return return return return long return return return long return return long return return long return return long return return long return return long return return long return return long return return long return return int return return long return return long return return long return return long return return long return return return return return int return return long return return long nr return sa return long return return long return return long return return long return return long return return long return return long return return long return return long return return long return return long return return return long return return long return return long return return return return void voi info int extern long unsigned long running info usage return info usage running old mmap saved sys saved sys change return int extern long unsigned long usage info usage return usage return info running return see id kernel include include include include include asm include include asm ato include asm sem include include return program filename new returns ne int kernel endif memset memset return copies void int norm coun kernel err un return adds int info info sav char info new new nul new count new new normal new new new new new new memset ne memset ne info new return new endif hom see id kernel include endif void void void voi void void voi void void int voi void voi voi int voi voi void lookahead include endif include endif elman include elman endif add handler observe void observe void void err return kernel endif kernel endif pid normalize void err return err data voi temp temp nex pid pid returns null return nu temp return temp moment void info programs nu running void running programs nu void temp prev temp temp tem prev pr temp nu prev nex return prev pid pid saves void err return prog void info progr temp void info pid pid program new adds void kernel endif pid run void running run seq value note voi seq void homeos add ano val numb note voi int returns return program kernel delay number loops th void endif kernel homeos unsigned kernel endif info void mon void int won kernel endif return look see id include data voi int memset da data hom see id include include include include include int char tmp char memset tmp memcpy tmp return tm int char tmp char memset tmp memcpy tmp return tm void char char tmp int main void file unsigned char int int char nul module module author define root dir define add define remove pro define add proce define remove pr define add user define remove define info file struct struct struct struct struct struct struct struct int ato int int mul char mul return int char tmp char int nu return memset tmp memcpy tmp atoi return program tem temp temp nex void err return return temp prev temp temp tem prev pr temp prev nex return prev void tem nu return tem temp temp nex void tem returns int tmp tmp tm return int strcmp tes info return return void program node progr temp void int break void add program node char char tmp memcpy tmp tmp add node node nu node memcpy node nex program void program node prog prog nu err return prog void char char tmp int pid void int uid pr uid atoi proc proc nu err return proc en const char unsigned int memset return count int unsigned program node utm int tmp tm strcmp add remove pr err return count int op return return unload int module mod return decrements int mod dec return info info info return put back see id kernel include include include include include include asm include include include include include include endif include kernel char struct struct struct mm str struct int struct mm mm mm read mm mm mnt break mm buf return buf char return buf command return proc normalize puts proc puts proc show menu popup tk popup add com popup add com proc frame width pack bind sho return proc write hom puts proc pid append expr program puts append expr proc program add program prog write home proc program program prog write home wm homeos frame top pack top append forma program append forma append forma normal append forma append forma count append forma append forma append forma append forma 
