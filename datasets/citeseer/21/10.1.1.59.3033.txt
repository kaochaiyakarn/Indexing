models computation languages embedded system design review models computation moc organize respect time abstraction 
distinguish continuous time discrete time synchronous untimed mocs 
system level models serve variety objectives partially contradicting requirements 
consequently argue different mocs necessary various tasks phases design embedded system 
different mocs integrated provide coherent system modeling analysis environment 
discuss relation popular languages reviewed mocs find moc offered languages single language support multiple mocs 
contend importance quality tools design productivity abstraction levels primitive operators provided language 
observe various flexible ways way heterogeneous frameworks coordination languages embedding different mocs language 
contents hardware software 
computation communication 
function architecture 
time 
validation 
abstraction 
refinement 
models computation continuous time models 
axel jantsch ingo sander january discrete time models 
synchronous models 
feedback loops timed synchronous models 
untimed models 
data flow process networks rendezvous models 
heterogeneous models computation purpose models continuous time models 
discrete timed models 
synchronous models 
untimed models 
discussion 
relation design languages mocs general purpose design languages synchronous languages 
dataflow languages 
rendezvous communication 
heterogeneous frameworks 
languages successful 
support analysis synthesis infrastructure education tools libraries 
system chip soc integrate microcontrollers digital signal processors dsps memories custom hardware reconfigurable hardware form field programmable gate arrays fpgas communication structure analog digital analog converters single chip 
total may dozens fpga memory micro controller communication structure dsp custom hardware possible system chip architecture hundreds components single soc 
architectures offer enormous potential 
tremendously complex heterogeneous 
apply hardware software 
system complexity grows faster system size due component interaction 
fact intra system communication dominant factor design validation performance analysis 
consequently issues communication synchronization parallelism play prominent role system design languages 
hardware software order manage complexity heterogeneity soc applications edwards believe design approach formal methods describe behavior system high level abstraction decision decomposition hardware software taken 
final implementation system automatic synthesis high level abstraction ensure implementations correct construction 
validation simulation verification done higher levels abstraction 
contrast current design practice typically leads early definition interfaces hardware software 
interfaces specified fixed system designers hardware software developed separate different teams 
validates design specified interfaces little opportunity reevaluate interfaces hardware software partitioning 
unfortunate details different parts explicitly modeled analyzed understood certain requirements constraints needs apparent 
example mixed hardware software design project task scheduler shall implemented software 
system specification determined hardware timer sets flag basic time unit scheduler 
timer higher resolution system design hardware software interface specification decided information passed hardware timer software scheduler flag set timer reset scheduler 
apparent reason interface complicated previous product generations successfully mechanism 
simplicity major design goal experience shown dimensioned designs caused increased hardware cost delayed development resulted performance bottlenecks 
apparent new product requires sophisticated scheduler 
due challenging real time requirements hap pens scheduler invoked interrupt hardware timer 
turns possible scheduler properly schedule tasks timing violations situation happens times row specific task delayed case 
properly scheduler know elapsed timer tick 
timer information readily available hardware software interface means convey 
difficult impossible change interface specification 
design teams specification hardware software changed 
possible local solution kind problem sought 
instance case software engineers tempted infer elapsed time counting executed instructions 
kind ad hoc solutions cause set problems undocumented dependency particular processor type clock frequency nightmare potential validation problems 
avoid ad hoc problem fixes local optimizations edwards argue system specification detailed identify kind problems early commit specific implementations detailed interface definitions 
essentially want delay commitment phase problem design better understood informed better decisions 
consequence mapping implementation specification automatic faster error prone 
advocate design process representations precise mathematical meaning validation mapping initial description various intermediate steps carried tools guaranteed performance 
formal model design consist components 
functional specification set explicit implicit relations involve inputs outputs possibly internal state information 
set properties design satisfy 
set performance indexes evaluate design different aspects speed size reliability 
set constraints performance indexes 
computation communication similar view system design formulated point orthogonalization concerns particular separation computation communication function architecture crucial importance 
orthogonalization concerns aims breaking complex problem smaller simpler pieces 
communication mechanisms tasks design blocks specified designed implemented independently design computation system 
computations tasks designed optimized defined communication services designed 
communication services defined respect functionality performance 
instance message passing mechanism synchronization buffering policy defined latency bandwidth constraints 
specified contradiction high abstraction mean detailed implementation 
instance delay minimum maximum latency range specified leaves sufficient freedom various implementation options 
example case scheduler timer better specify design implement validate communication mechanism hardware software independent design implementation scheduler 
communication defines data transfered timer scheduler data 
provided specified communication mechanism system designers elaborate system functionality postpone details hardware software interface stage implementation interface straight forward automatic 
provided guaranteed design implement specify communication mechanism 
example shows replace type problem partitioning 
old way partitioning hardware software outdated implementation oriented subject continuous change implementation options increase 
replaced partitioning computation communication problem oriented conceptually cleaner stable face rapidly developing implementation technology 
function architecture similar line argument separation functionality architecture 
architectural templates platforms shall developed validated independently development functionality particular product 
platform offers services defined 
platform implementers spend great effort optimizing validating implementation services 
application developers postpone implementation decisions stage know platform fulfills specified functional performance requirements 
platform services implemented mixture hardware software see shift traditional hardware software partitioning service provider service user partitioning problem oriented conceptually cleaner arbitrary 
time embedded systems fulfill non functional requirements 
usually reactive systems respond continuously environment sufficiently fast meet timing requirements 
embedded systems battery driven need power efficient 
embedded systems exhibit minimum level reliability predictability 
design languages support non functional properties 
exception time non functional features hardly part syntax semantics design languages 
time languages vhdl verilog concurrent processes relative timing activities influences system behavior 
timing integral part functionality 
fact concurrency major dominant source system complexity way time represented handled design language considerable impact complexity design validation process 
expect significance grow coming years 
important theme article ordering factor discuss models computation section 
validation design process embedded systems ensure final system implementation complies requirements imposed system 
share validation costs compared total design costs continuously increasing 
current estimates suggest typical design project employs validation engineer design engineer 
decades heated discussions language properties effectively support validation 
proponents derived languages systemc claimed increase simulation speed compared vhdl verilog simulations facilitates validation 
argued simulation general technique suffices complemented formal verification 
formal semantics considered precondition language amenable formal verification 
return important issue section 
term validation system simulation formal verification 
abstraction system design starts development specification model 
phase designer formulates model requirements requirement specification usually written natural language english 
specification model expressed formal language analyzed processed transformed tools significant advantage 
formal design language requires details filled decided may available early stage project 
order gain obvious benefits trend introduce formal design languages earlier project 
important point language offers right abstractions designer wants capture neatly expressed unnecessary details unavailable information ignored 
example designer specify break sub system left front wheel car sends status information central controller communication mechanism sending data 
send data destination primitive requires provide concerned data destination communication action 
appropriate engineer focus data sent sent 
tool verify right data sent right place 
alternatively designer low level primitives declaring shared memory location protecting shared memory semaphores checking status shared memory writing reading acknowledging data received 
disadvantages 
details necessary express system functionality specification engineer wastes precious time 
second verification tool harder task verify correct data sent dealing statement process verify statements 
shared memory mechanism may efficient mechanism implement transaction 
project may turn message passing mechanism cost power efficient 
case formal language mean language formally defined syntax defined semantics 
simplicity include languages vhdl languages mathematically defined semantics abstraction level abstraction gap high level specification model lower level specification model implementation number possible refined models high abstraction level leaves wider design space specification engineer effort wasted may obstacle efficient implementation 
suppose primitive non blocking transaction provide information sender data received 
assume important action sender initiated data delivered 
blocking send primitive synchronizes sender receiver specification engineer express desired behavior complex ways resulting similar disadvantages described 
important provide high abstraction level crucial offer right primitives natural fit problem 
primitives find efficient implementations 
arduous establish new abstraction level meets requirements march higher abstraction levels slow 
higher abstraction level model fewer implementation details inherent model larger design space 
design space defined amount possible implementations fulfill specification model illustrated 
refinement system specification model serves distinct purposes elaborate section 
specification purpose aims capturing system functionality unambiguous analyzable way allow designers managers provider supplier discuss asses product 
implementation purpose aims providing base contract implementation validation teams 
sufficiently developed efficiently avoid constraining implementation 
sufficient details convince everybody product realized suggested respect requirements 
high level abstraction imperative specification purpose models suitable implementation purpose relevant implementation details missing 
specification implementation purpose impose incompatible constraints model single model fits specification implementation purposes 
design process models different levels shown 
starting abstraction level intermediate models specification model design space refinement steps implementation design process stepwise refinement high level specification model final implementation specification model includes implementation details allows application formal verification techniques design process shall provide stepwise refinement technique results efficient implementation complex heterogeneous architecture 
easy task huge abstraction gap bridged 
system design methodology offer possibility model system high level abstraction allowing efficient validation refinement methodology allows bridging abstraction gap order yield efficient abstraction gap implementation 
objectives summarized challenge successful system design methodology 
clearly see models levels abstraction 
specification implementation purpose require different models kind model purposes 
design process provide refinement particular model computation mapping rules different models computation 
rest article organized follows 
section discuss models computation moc 
view moc convenient concept abstracts slightly languages allows focus essential issues concurrency time communication synchronization 
section discuss detail purpose specification model determines requirements specification language 
discussion allows appreciate strengths weaknesses different mocs respect requirements design process 
section move discuss languages 
give complete list design languages focus features concerning time communication 
models computation term model computation moc focus issues concurrency time 
consequently defined different ways different authors see instance define time representation semantics communication synchronization processes process network 
moc defines computation takes place structure concurrent processes giving semantics structure 
semantics formulate machine able execute model 
languages computational models underlying computational models 
instance languages vhdl verilog systemc share discrete time event driven computational model 
hand languages support computational model 
forsyde functional language haskell express models computation 
libraries created synchronous data flow discrete event models computation 
similarly standard ml implement timed synchronous untimed computational models 
systemc extended support sdf synchronous dataflow csp communicating sequential processes models computation addition native discrete event moc 
choose right model computation utmost importance moc certain properties 
example consider process network modeled discrete event system systemc 
general case automatic tools able compute static schedule single processor implementation process network easily allow 
reason patel shukla extended systemc support sdf moc 
process network expressed sdf easily statically scheduled tool 
skillicorn talia discuss models computation parallel architectures 
community faces similar problems design embedded systems 
fact typical parallel computer structures simd mimd implemented soc architecture 
recognizing programming large number communicating processors extremely complex task try define properties suitable model parallel computation 
emphasize model hide details decomposition mapping communication synchronization programmers shall able manage intellectually creation software 
exact structure program inserted translation process programmer 
models possible means parallelism explicit program text 
point ad hoc compilation techniques expected problems complexity advocate building software correct construction verifying program properties construction 
programs architecture independent allow reuse 
model support cost measures guide design process guaranteed performance useful variety architectures 
depending information explicit model distinguish levels flynn classified typical parallel data structures simd abbreviation single instruction multiple data mimd multiple instruction multiple data 

explicit 
parallelism explicit 
parallelism decomposition explicit 
parallelism decomposition mapping explicit 
parallelism decomposition mapping communication explicit 
parallelism decomposition mapping communication synchronization explicit number important models computations give key properties 
organize timing abstraction 
distinguish discrete time models synchronous models cycle denotes notion time untimed models 
consistent tagged signal model proposed lee sangiovanni vincentelli 
event time tag different time tag structures result different mocs 
time tags correspond real numbers continuous time model integer time tags result discrete time models time tags drawn partially ordered set result untimed moc 
mocs organized criteria kinds elements manipulated moc leads paul thomas grouping mocs hardware artifacts mocs software artifacts mocs design artifacts 
organization properties inherent properties mocs limited changes mocs different ways 
drawback organization time abstraction strictly sequential models finite state machines sequential algorithms fall class mocs representation time irrelevant 
minor concern focus parallel mocs 
continuous time models time represented continuous set usually real numbers talk continuous time moc 
prominent examples continuous time moc instances simulink vhdl ams modelica 
behavior typically expressed equations real numbers 
simulators continuous time mocs differential equation solver compute behavior model including arbitrary internal feedback loops 
due need solve differential equations simulations continuous time models slow 
small parts system usually modeled continuous time analog mixed signal components 
able model analyze complete system contains analog components mixed signal languages simulators vhdl ams developed 
allow model pure digital parts discrete time moc analog parts continuous time moc 
allows complete system simulations acceptable simulation performance 
typical example heterogeneous models multiple mocs clear benefit 
discrete time models models events associated time instant time represented discrete set integer natural numbers called discrete time models 
discrete time models simulation hardware 
vhdl verilog discrete time model simulation semantics simulator discrete time mocs usually implemented global event queue automatically sorts occurring events 
discrete time models may causality problems due zero delay feedback loops discussed section 
synchronous models synchronous mocs time represented discrete set integers elementary time unit physical unit due abstraction mechanisms group mocs denoted discrete event moc 
strictly speaking discrete event discrete time independent orthogonal concepts 
discrete event models values events drawn discrete set 
combinations occur practice continuous time continuous event models continuous time discrete event models discrete time continuous event models discrete time discrete event models 
see instance coverage discrete event models 
languages different model computation synthesis similar perfect synchronous model due synchronous registers difference computation zero delay 

timing activities events precisely defined constraint elementary time slot 

timing intermediate events visible elementary time slot irrelevant ignored 
time unit processes evaluate events occurring process considered occur simultaneously 
synchronous assumption formulated 
synchronous approach considers ideal reactive systems produce outputs synchronously inputs reaction observable time 
implies computation output event instantaneous 
synchronous assumption leads clean separation computation communication 
global clock triggers computations conceptually simultaneous instantaneous 
assumption frees designer modeling complex communication mechanisms provides solid base formal methods 
synchronous design technique hardware design clocked synchronous circuits 
circuit behavior described deterministically independent detailed timing gates separating combinational blocks clocked registers 
implementation behavior circuit assumption combinational blocks fast circuit include zero delay feedback loops 
synchronous assumption implies simple formal communication model 
concurrent processes easily composed 
feedback loops zero delay may cause causality problems discussed 
feedback loops timed synchronous models timed models allow zero delay computation synchronous models basic assumption 
consequence feedback loops may introduce inconsistent behavior 
fact feedback loops illustrated may consistent solution may consistent unambiguous solution may solutions 
shows system zero delay feedback loop stable solution 
output boolean function output nand function means output function contradiction starting point analysis 
starting value output lead stable solution 
clearly solution problem 
shows system feedback loop multiple solutions 
system stable functions functions output value 
system possible solutions 
shows system feedback loop solution 
solution outputs crucial design safety critical systems feedback loops solution detected eliminated result oscillator 
feedback loops multiple solutions imply risk safety critical systems lead nondeterminism 
non determinism may acceptable detected designer aware implications may serious consequences stays undetected 
feedback loops timed synchronous models importance approaches address problem 
microstep order introduce order events produced consumed event cycle concept microsteps introduced languages vhdl 
order solve zero delay feedback problem vhdl distinguishes dimensions time 
time unit second number 
delta delay infinitesimal small amount time 
operation takes zero time units delta delay 
delta delays order operations time unit 
approach partly solves zero delay feedback problem introduces problem delta delays cause advance time measured time units 
event cycle may infinite amount delta delays 
result implemented vhdl operation causes time advance true true nand true true true true feedback loop synchronous system 
system solutions multiple solutions single solution 
delta delay 
advantage delta delay simulation reveal composite function oscillates 
vhdl simulation detect solutions simulation semantics vhdl assign initial value output gates give stable solu tion concealing non determinism designer 
serious drawback microstep concept leads complicated semantics aggravates task formal reasoning 
forbid zero delays easiest way cope zero delay feedback problem forbid 
case mean insertion extra delay function upper function 
delay function initial value systems stabilize 
assuming initial value stabilize current event cycle values output nand function value function 
stabilize output value functions 
possible problem approach stable system rejected contains zero delay feedback loop 
approach adopted synchronous language lustre 
unique fixed point idea approach system seen set equations solution form fixed point exists 
vhdl defines data type boolean means type boolean false true 
program start variables signals take leftmost value data type definitions case boolean data type 
special value bottom allows give systems solution solutions fixed point solution 
advantage method system regarded functional program formal analysis show system unique solution 
systems stable feedback loop accepted systems rejected result value solution feedback loops 
naturally fixed point approach demands sophisticated semantics theory understood 
esterel adopted approach constructive semantics esterel described 
relation approach allows specification systems relations 
system specification may zero solutions solution multiple solutions 
implementation system usually demands unique solution solutions may interesting high level specifications 
relation approach employed synchronous language signal 
untimed models data flow process networks data flow process networks special variant kahn process networks 
kahn process network processes communicate unbounded fifo channels 
writing channels non blocking succeed stall process reading channels blocking process reads empty channel stall continue channel contains sufficient data items tokens 
processes kahn data flow process network process network monotonic means need partial information input stream produce partial information output stream 
monotonicity allows parallelism process need input signal start computation output events 
processes allowed test input channel existence tokens consuming 
kahn process network total order events inside signal 
order relation events different signals 
kahn process networks partially ordered classifies untimed model 
data flow program directed graph consisting nodes actors represent communication arcs represent ordered sequences streams events tokens illustrated 
empty circles represent nodes arrows represent streams filled circle represents token 
data flow networks hierarchical node represent data flow graph 
execution data flow process sequence firings evaluations 
firing tokens consumed tokens produced 
number tokens consumed produced may vary firing defined firing rules data flow actor 
data flow process networks shown valuable digital signal processing applications 
implementing data flow process network single processor sequence firings called schedule 
general data flow models undecidable schedule exists depends input data 
synchronous data flow sdf puts restrictions data flow model requires process consumes produces fixed number tokens firing 
restriction tested efficiently finite static schedule exists 
exists synchronous data flow process network effectively computed 
shows sdf process network 
numbers arcs show tokens produced consumed firing 
possible schedule sdf network exists variety different data flow models excellent overview see 
rendezvous models rendezvous model consists concurrent sequential processes 
processes communicate synchronization points 
order exchange information processes reached synchronization point wait 
tagged signal model sequential process set tags 
synchronization points processes share tag 
partial order events model 
process algebra community uses rendezvous models 
csp communicating sequential processes model hoare ccs calculus communicating systems model milner prominent examples 
language ada communication mechanism rendezvous 
heterogeneous models computation lot effort spent mix different models computation 
approach advantage suitable model computation part system 
hand system model computational models semantics interaction fundamentally different models defined simple task 
amplifies validation problem system model single semantics 
little hope formal verification techniques help simulation remains means validation 
addition heterogeneous system model specified difficult optimize systems different models computation 
summary heterogeneous mocs provide general flexible useful simulation modeling environment cross domain validation optimization remain elusive years heterogeneous modeling approach 
overview related mixed models computation 
charts hierarchical finite state machines embedded variety concurrent models computations 
idea decouple concurrency model hierarchical fsm semantics 
advantage modular components basic fsms designed separately composed system model computation best fits application domain 
possible express state fsm process network specific model computation 
charts describe hierarchical fsms composed data flow discrete event synchronous models computations 
composite dataflow integrates data control flow 
vectors conversion scalar values vectors vice versa integral parts model 
allows capture timing effects conversions resorting synchronous timed moc 
timing processes represented level determine sufficient data available start computation 
way effects control timing dataflow processing considered highest possible abstraction level appear data dependency problems 
model implemented combine matlab sdl integrated system specification environment 
internal representations system property intervals spi model developed integrate heterogeneous system model internal representation 
idea spi model allow global system analysis system optimization language boundaries order allow reliable optimized implementations specified embedded real time systems 
synthesis relevant information resource utilization communication timing behavior extracted input languages trans formed semantics spi model 
spi model set parameterized communicating processes parameters adaptation different models computation 
spi allows model non determinism behavioral intervals 
exists software environment spi called spi workbench developed analysis synthesis heterogeneous systems 
representation refines spi model adding capability explicitly modeling state information allows separation data flow control flow 
goal provide unifying specification focuses specific design methods particular scheduling validation 
internal model shall reduce design complexity representing properties system model relevant design methods 
know heterogeneous modeling framework ptolemy 
allows integrate wide range different mocs defining interaction rules different moc domains 
come back ptolemy sections 
purpose models previous sections evident different models fundamentally different strength weaknesses 
single model satisfy purposes models computation chosen care 
consider design flow distinguish purposes system model specification purpose model develop system functionality study solution imposed problem requirements fulfilled model 
specification model shall implementation details shall allow large design space parts hardware software architecture determined 
implementation purpose model shall efficiently mapped architecture 
implementation details play important role underlying architecture reflected model 
hand specification unnecessarily restrict implementation prescribing details efficiently implemented 
fine balance specification model synthesis tools inefficient infeasible 
detailed model constrain design process lead abandoning specification model inefficient overly costly implementation 
worse balance hard strike changes advances implementation technology design technology different different application areas 
revisit discussed mocs light observation respect design flow 
sake simplicity identify main design tasks illustrated 
early requirements definition phase moc need able efficiently capture main functional features bothering details 
addition feasibility analysis requires detailed studies critical issues may concern performance cost power functional non functional property 
functional specification determines entire system functionality high abstraction level constitutes model implementation 
independent functional specification architecture specification 
task graph breaks functionality concurrent activities tasks mapped architecture resources 
resource binding scheduling performed detailed implementation resources created 
essential difference main computational models introduced previous section representation time 
feature weighs heavily respect suitability design tasks development phases 
continuous time models continuous time mocs accurately model analyze existing prospective devices 
usually specify constrain behavior may serve models implementation 
frequently feasibility studies analyze critical issues architectural models represent analog mixed signal components architecture 
analog synthesis infancy continuous time models rarely input synthesis tools 
functional requirements functional specification task graph feasibility analysis architecture definition code generation suitability mocs different design phases 
stands continuous time moc discrete time moc synchronous moc untimed moc 
discrete timed models discrete timed model drawback precise delay information synthesized 
provide precise delay model piece computation may useful simulation may appropriate existing component hopelessly specifies computation synthesis 
assume multiplication defined take ns 
shall synthesis tool try get close possible 
deviation acceptable 
interpreted max ns 
different tools give different answers questions synthesis different target technologies yield different results match simulation discrete time model 
situation worse delta delay model 
discussed section delta delay model elegantly solves problem non determinism simulation requires mechanism globally ordering events 
essentially synthesis system synthesize similar mechanism target design unacceptable overhead 
problems notwithstanding synthesis systems hardware software developed languages timed models 
vhdl verilog tools popular successful exam ples 
avoided problems ignoring discrete time model interpreting specification clocked synchronous model 
specific coding rules assumptions allow tool identify clock signal infer latches registers separating combinatorial blocks 
drawbacks approach follow special coding guidelines synthesis specification implementation may behave differently general semantics language complicated distinguishing simulation synthesis semantics 
success approach illustrates mixing different mocs language practical 
demonstrates suitability clocked synchronous model synthesis underscores discrete time model synthesizable 
synchronous models synchronous models represent sensible compromise untimed fully timed models 
timing details ignored time unit evaluation clock cycle reason timing behavior 
natural place intermediate model design process 
lower level synthesis may start synchronous model 
logic rtl synthesis hardware design compilation synchronous languages embedded software prominent examples 
result certain synthesis steps may represented synchronous description scheduling behavioral synthesis 
debatable synchronous model appropriate starting point higher level synthesis design activities 
fairly strictly defines activities occurring evaluation cycle independent processes simultaneous 
imposes strong coupling unrelated processes may restrict early design synthesis activities 
hand systems timing properties integral part system functionality important part system specification model 
complex control structures typically require fine control relative timing events activities 
single chip systems complex feature common 
today hardly soc design exhibit fairly complex control algorithms 
synchronous models constitute compromise dealing time level 
avoid nasty details low level timing problems allow represent analyze timing relations 
essence clock evaluation cycle defines time budgets block 
time budgets turn timing constraints implementation blocks 
time budgets constrain timing behavior constraining 
potentially high degree flexibility approach evaluation cycles synchronous moc considered fixed duration clock cycles time budgets identical duration different parts design 
duration change cycle cycle required 
re timing techniques exploit flexibility 

feature offering intermediate flexible abstraction level time synchronous mocs suitable wide range tasks indicated 
untimed models untimed models variants nice mathematical features facilitate certain synthesis tasks 
tedious scheduling problem software implementations understood efficiently solvable synchronous data flow graphs 
said determining right buffer sizes processes necessary critical task hardware software mixed implementations 
individual processes compiled hardware software depends language describe 
data flow process model restrict choice languages responsible support 
responsible communication processes relative timing provides excellent support due carefully devised mathematical model 
discussion summarizes discussion indicates design phases different mocs suitable 
note mocs placed design phase bubble means general single moc suffice phase may required 
single moc serves purposes equally 
emphasis equally sufficiently expressive versatile variety contexts 
different focus suitable specific tasks 
instance fully timed discrete event model model simulate 
extremely inefficient simulate analyze complex systems detailed timing behavior irrelevant 
inefficiency concerns tools human designers 
simulation timed moc model takes orders magnitude longer simulation untimed moc model 
formal verification orders magnitude efficient perfectly synchronous moc models timed moc models 
human designers significantly productive modeling analyzing signal processing algorithm untimed moc model synchronous timed moc model 
productive model complex distributed system appropriate high level communication primitives available express communication unprotected shared variables semaphores 
hardware engineers working rt level synchronous moc design gates day counterparts synchronous design style 
analog designers productive deal full range details physical electrical level 
unfortunately abstractions higher level analog design consequence analog design automated efficient digital design 
mocs impose different restrictions selected carefully lead significant improvements design productivity quality 
strict finite state machine model unbounded memory requirements 
property inherent fsm model proved specific design 
amount memory required calculated static analysis simulation required 
contrast models dynamic memory allocation general impossible prove upper bound memory requirement long simulations obtain high level confidence memory requirements feasible 
fsm models restrictive problem suits restrictions gain design productivity product quality tremendous 
similar example synchronous dataflow 
system naturally expressed sdf graph efficiently analyzed scheduled designed system modeled general dataflow graph 
general guideline state produc tivity tools designers highest expressive moc naturally applied problem 
different computational models place design flow 
different mocs design model different sub systems different requirements characteristics 
leads naturally heterogeneous mocs delayed language languages coordination framework discussed 
relation design languages mocs revisit models computation see appear different popular design languages 
general purpose design languages call design languages vhdl verilog systemc general purpose design languages constitute backbone asic fpga soc hw sw design flows 
general discrete time moc allows model simulate parts typical soc 
wider range powerful features allow advanced data structuring modeling building advanced functional hierarchies functions procedures processes managing large complex design projects 
discrete time moc severe restrictions discussed languages extended main directions 
vhdl case point 
facing need model simulate entire systems including digital analog parts vhdl extended vhdl ams 
idea combine distinct mocs different simulation engines unifying syntax 
vhdl ams fact implements heterogeneous moc consisting continuous time discrete time moc 
originally vhdl devised general purpose simulation modeling language digital hardware 
soon apparent highly desirable language input synthesis tools 
reasons discussed discrete time model suitable input hardware synthesis tool 
solution define synchronous moc expressed vhdl syntax 
called synthesizable subset vhdl essentially defines clocked synchronous moc suited input synthesis 
similar reasons formal verification tools operating synchronous moc expressed vhdl discrete time moc vhdl simulation semantics 
systemc similar evolutionary route 
general discrete time moc synthesizable subset established essentially defines clocked synchronous moc 
attempts extend systemc analog modeling 
systemc takes idea support mocs explicitly defining transaction level abstraction 
time perspective transaction level abstraction untimed moc strictly timing constructs interfering imposes partial order timing events solely determined sequence interaction processes 
strictly enforced freely mixed mocs synthesis analysis verification tools hardly 
instance processes process network consume produce constant number data items evaluation process network fact constitute synchronous data flow sdf process network tool able derive static schedule prove network sdf graph 
patel shukla proposed alternative way equip systemc mocs 
provide different simulation kernels mocs sdf communication sequential processes addition discrete event simulation kernel 
consequence designer explicitly flags moc tool safely assumptions specific properties moc 
summary trend general purpose design languages define subsets modeling rules realize different mocs various purposes 
call technique embedding moc expect main roads advance design technology 
proved successful past applied ad hoc 
synchronous languages synchronous languages successfully area reactive safety critical embedded control systems 
languages perfectly synchronous computational model section 
model gives solid mathematical foundation formal reasoning application formal program manipulation techniques 
synchronous languages key properties 
support concurrency 
simple elegant formal semantics allows express parallel composition clean way 
support concept synchrony divides time discrete instants 
part focuses largely presentation imperative synchronous language esterel 
follows short discussion synchronous languages 
esterel esterel imperative language suitable description control 
program consists collection nested concurrently running threads described imperative syntax 
threads communicate means signals 
addition common control structures esterel large number preemption statements allow termination statements 
formal framework developed esterel includes causality analysis ensuring causality constraints contradictory reachable state 
consider programm 
outputs module input output loop await await emit module simple esterel module inputs output 
soon input received 
addition input event received module reset 
lines define input output events module 
loop lines loops forever exit condition 
line module waits parallel 
operator parallel operator sequence operator 
brackets structure text 
line module waits events parallel synchronizes soon events received 
emitted 
sequence operator take time fact emitted time instant received 
emitted iteration loop started module waits inputs 
received module immediately aborted restarted 
works reset signal interrupting loop activity module 
esterel designed synchronous reactive systems program typically waits inputs computes emits outputs 
modules communicate events 
event emitted module module instantaneously seen modules 
called instantaneous broadcast 
module need know name address receiving module communicate 
esterel follows perfect synchrony assumption computation communication takes observable time 
activities module system synchronized incoming events 
module waits inputs reacts instantaneously 
consequence zero delay feedback loops possible 
consider esterel module 
line module checks module output emit emit module illegal esterel module due zero delay feedback 
event occurring 

parallel line checks presence emit 
program nondeterministic describes possible consistent behaviors 
absent 
legal esterel program 
dependency cycles broken prohibiting zero delay loops 
instance shows corrected 
refers pre module output pre emit emit module dependency cycle broken correct 
vious value signal 
line checked occurred previous evaluation cycle 
follows occurred previous cycle emitted current cycle 
consequence emitted current cycle due lines check presence current cycle 
feedback loop legal esterel program 
exist legal esterel programs zero delay feedback loops 
consider 
cyclic dependency module input output emit emit module legal esterel module zero delay feedback loop 
vice versa halves cycle occur simultaneously 
depends depends 
defined behavior correct legal esterel program 
constructive semantics esterel defines set legal programs provides constructive way efficiently distinguish legal illegal programs 
synchronous languages esterel developed control dominated synchronous reactive systems 
synchronous languages control dominated systems statecharts argos 
graphical syntax describing state machines 
synchronous languages dataflow dominated systems lustre signal 
lustre declarative data flow language systems composed sets equations 
variable function time denotes flow 
operators operate single values flows 
discuss detail ideas dataflow languages context untimed mocs section introduce language lucid 
similarly signal declarative dataflow language relations functions 
signal program set constraints relations involved signals 
signal compiler performs formal calculations synchronization logic data dependencies check program correctness produce executable code 
lustre signal support multiple clocks clock domains 
synchronous languages successfully industry exist industrial tools esterel esterel technology lustre signal 
esterel technology acquired environment order able combine control oriented esterel data flow oriented lustre synchronous approach 
synchronous language programs usually translated finite state automata order implement sequential reactive program single processor 
esterel lustre translated hardware implementations 
clean mathematical formalism led development verification tools synchronous languages 
halbwachs raymond give overview techniques tools developed validation reactive systems described lustre 
techniques adapted synchronous language 
dataflow languages dataflow languages traced back dennis kahn ashcroft pioneered field 
kahn ex targeted dataflow machines programming language laid foundation dataflow process networks derivations synchronous dataflow cyclo static dataflow boolean controlled dataflow 
kahn process networks coincide strongly untimed moc section 
introduce lucid illustrate principles dataflow languages 
mention briefly languages graphical notations 
lucid dataflow languages operators called nodes operate streams input values generate streams output values 
assuming denotes stream values denotes denote pointwise addition streams result stream illustrated 
dataflow node adding pointwise values input streams 
lucid data object variable constant stream potentially infinite sequence values 
valid lucid expression operating stream variables constant denote infinite sequence element number denotes sequence addition pointwise operators lucid special non pointwise operators 
instance results constant stream element drops element consider lucid program 
expression 
input output soon variables streams equations define streams 
line defines constant stream determined input value 
lines define stream represent natural numbers starting 
lines core program define stream depends recur 
begins represents squares natural numbers 
line defines output constant stream taken value program computes alternative interpretation lucid program loop iterator line constitutes exit condition 
lucid developed multidimensional dataflow language granular lucid glu coordination language course grain parallelism sequential parts described aspects typical dataflow languages 
dataflow languages functional declarative semantics 
originally regular computation intensive applications matrix manipulations graphics manipulations scientific applications 
programming parallel computers functional paradigm facilitates parallelization problems scientific computing demanding researchers sought exploit parallel architectures 
dataflow languages rise signal processing telecommunication domain companies commercialized tools principles dataflow computation 
tools graphic block languages spw cadence labview national instruments 
example graphical block language untimed dataflow moc consider sdf graph ptolemy ii 
processes 
attach ports channels arrows ports determine direction dataflow channels 
numbers close ports denote number data tokens consumed produced invocation process 
shows valid sdf graph static schedule valid sdf graph execution sequence processes block channel buffers grow bound 
ptolemy sdf example important note graphical block languages considered coordination languages define processes modeled 
principle processes described language long obey rules governing moc interacting environment 
rendezvous communication languages partially influenced hoare communicating sequential processes csp milner calculus communication systems ccs defined communication mechanism tight synchronization partners called rendezvous 
rendezvous sender receiver block partner ready act communication completed 
means communication leads synchronization point leading tighter coupling processes necessary due data dependencies 
furthermore means channel buffers required 
dataflow models discussed receiver blocks input data available sender just sends data concern readiness receiver 
means data item buffered channel time sent consumed 
determine necessary buffer size avoid buffer overflow main design challenges implementing dataflow models 
problem rendezvous communication channels need buffer datum 
process primary clock domain set clock external unsigned result channel defined file extern chan unsigned channel void main void delay channel result process wait data received process secondary clock domain set clock external divide unsigned chan unsigned channel void main void channel process wait data received process sends bit data process handel 
handel handel variant targeting complex fpga design 
differs ansi number ways importantly offering fine control parallelism timing 
arguing fpga design discrete time model superfluous ineffective offers higher level mocs 
module defined main function governed clock clock synchronous moc 
module par seq statements allow tight control parallelism 
main functions declared governed different clock 
essentially constitute process network rendezvous untimed moc 
untimed handel model determine relation different clock signals left synthesis implementation 
communication main processes strongly coupled sender receiver block communication completed 
consider example 
processes defined separate files different main functions 
set clock lines define clocks processes 
case process clock derived process clock running half speed 
necessary processes entirely independent clocks 
note information relative frequencies clocks determining behavior system truly untimed moc 
keyword defines communication channel directional 
direction determined usage 
token denotes writing channel denotes reading channel 
processes blocked communication completed loops progressing lock step manner process runs clock twice fast process heterogeneous frameworks due complexity heterogeneity embedded systems socs framework languages support multiple mocs popular 
ad hoc solutions proposed coupling particular languages 
exist systematic approaches problem 
ptolemy ii take ptolemy ii example 
consider hierarchical system 
process actor actor director sdf director de hierarchical heterogeneous system ptolemy ii 
actor ptolemy ii language consists actors 
sdf model constituent actors modeled different moc dis crete event de moc 
de moc ptolemy ii corresponds called discrete time moc 
ptolemy process network governed particular moc called domain 
domain realized entities director receiver 
director determines execution order processes domain receiver handles communication ports domain 
actors communicate communication controlled receivers follows sdf semantics 
sdf director controls invoked 
invoked controlled de semantics 
communication ports handled receivers invocation actors occurs semantics de moc 
way heterogeneous systems modeled hierarchically moc hierarchically contained moc 
mocs integrated ptolemy ii include communicating sequential processes csp continuous time ct discrete event de distributed discrete event dde discrete time dt finite state machine fsm process networks pn synchronous data flow sdf synchronous reactive sr 
due separation computation process communication environment actors reused different mocs called domain polymorphism 
frameworks example heterogeneous framework embedded systemc language described 
systemc simulation semantics extended adding simulation kernels realize mocs 
addition discrete time moc standard systemc framework contains sdf csp fsm moc 
problem simulating heterogeneous models addressed ptolemy ii patel systemc libraries cross moc domain analysis verification open problem 
particularly urgent severe system failures occur due mismatch basic assumptions sub systems 
ptolemy team started address problem developing type system communication protocols allow static verification certain protocol properties 
formal framework study heterogeneous mocs simulation developed par tially implemented haskell ml 
discussed section spi aiming integrate heterogeneous models cross domain analysis optimization 
summary theoretical practical problems integration heterogeneous mocs open 
history guide progress steady slow expect tools address cross domain performance analysis verification optimization gradually integrated standard industrial design flows 
languages successful 
research programming design languages rarely immediate effect particular language adopted large industrial community 
addition technical merits language factors influencing success acceptance 
fate language tied certain companies applications user communities success failure important inherent properties language 
having said review important technical factors necessary direct consequence semantics language mocs supports 
support analysis synthesis year year international technology roadmap semiconductors listed functional validation main challenges design 
edition reads verification dominant cost design process 
current projects verification engineers outnumber designers ratio reaching complex designs 
design conception implementation mere main activity verification page validation dominating design language help 
main lines arguments issue 
proponents suggest validation technology hardly dependent design language 
validation methodologies simulation engines authoring tools formal verification techniques applied design language roughly effect 
today market validation technology supporting traditional design languages vhdl verilog 
number formal verification tools operating vhdl verilog researchers claimed years languages suitable formal verification 
survey industrial usage formal verification tools see 
contend formalism semantics language huge difference effective analysis verification algorithms 
instance side effects allowed language information exploited tools establish equivalence different design representations 
tool prove single case side effect may impossible cases side effect 
effective synthesis verification techniques vhdl verilog possible proper subset defined appropriate interpretation syntactic structure ease synthesis verification adopted inconsistent simulation semantics essentially different moc defined embedded vhdl verilog 
process taken years argued choice vhdl verilog delayed efficient synthesis verification tools years widening design productivity gap 
accept languages selected narrow technical merits observe exposing important properties designers tools choosing right level detail abstraction impact efficiency tools design methodologies 
evolution mocs related concepts essentially consequence search right abstraction levels primitive operations exposed designers tools 
examples may illustrate point 
times mentioned sdf restricted untimed moc 
restrictions chosen guarantee nice formal properties allow efficiently tackle static scheduling buffer optimization problem 
applications price restricted moc worth paying 
example function procedure block side effect performs action explicitly visible output 
function plus adds numbers returns result writes file updates global variables said side effects apparent return value 
side effects obstacle formal verification analysis deduce possible side effects daunting task variable aliasing pointers 
type systems 
type systems enforce properties design components variables functions processes statically checked 
tremendously facilitates static analysis definition efficient dynamic analysis simulation 
fact sdf moc viewed type system processes 
type process determined number data items consumes produces invocation 
dynamic variations process type allowed sdf moc 
experience shows defining language subsets extensions enforcing modeling rules combining integrating different languages right level detail abstraction right set properties approximated basis established languages vhdl verilog fact popularity concept computational models draws hope able formulate essential properties independent language syntax semantics project embed different computational models existing design languages 
agenda successful able formulate mocs particular purposes synthesis formal verification system level performance analysis integrate language systemc multi language framework ptolemy 
net result terms technical merits significant 
infrastructure education tools libraries substantial investment education training current languages libraries conventions tools methodologies companies government organizations universities schools radical changes impossible 
argue new languages learned weeks consequently new languages introduced quickly 
languages syntax semantics constitute tiny fraction education effort shown bottom reversed investment pyramid rests 
change improvement incremental disrupt heavy legacy previous investments 
drastic change take longer time prepared establishing education infrastructure tools libraries compete market place 
support upper part legacy pyramid appropriate point primary tools compiler linker semantics syntax legacy code secondary tools libraries investment pyramid 
try replace entire pyramid 
importance semantics properties design languages hardly underestimated ultimately constrain analysis optimization synthesis tools efficient productive designers 
huge impact cost performance designed system 
demands requirements design language versatile contradicting single language small set languages satisfy 
due huge investment tools libraries legacy code new language technology introduced gradually slowly 
upside observed novel language technology accompanying tools methodologies deployed flexible ways 
moc concept shown interesting model features properties separated syntax semantics language 
allows new moc defined independent language embedded various existing design languages 
new tools operate new moc existing tools operating design language see change 
way insert new language design technology established design flows offered heterogeneous frameworks integrate different semantic domains 
heterogeneous frameworks allow integrate new languages models easily govern domains interact constrain domain internal semantics behavior 
consequence expect new language technology accompanying design tools gradually integrated main stream design flows embedding appropriate mocs popular languages systemc java enhancing heterogeneous frameworks useful specialized domains 
ashcroft wadge 
lucid language iteration 
communications acm july 
peterson 
designers guide vhdl ams 
morgan kaufman september 
benveniste berry 
synchronous approach reactive real time systems 
proceedings ieee september 
benveniste caspi edwards halbwachs le guernic simone 
synchronous languages years 
proceedings ieee january 
berry 
hardware implementation pure esterel 
proc 
international workshop formal methods vlsi design january 
berry 
foundations esterel 
plotkin stirling tofte editors proof language interaction essays honour robin milner 
mit press 
berry 
constructive semantics pure esterel draft version 
technical report ria sophia antipolis france july 
berry 
esterel language primer 
ecole des mines inria sophia antipolis france version edition july 
berry gonthier 
esterel synchronous programming language design semantics implementation 
science computer programming 
engels 
cyclo static data flow 
proceedings ieee international conference acoustics speech signal processing pages 
jantsch 
modeling mixed control dataflow systems 
ieee transactions large scale integration vlsi systems october 
booch bryan 
software engineering ada 
benjamin cummings publishing 
de simone 
esterel language 
proceedings ieee september 
buck 
scheduling dynamic dataflow graphs bounded memory token flow model 
phd thesis department electrical engineering computer science university california berkeley 

discrete event systems modeling performance analysis 
associates 
limited 
handel language manual dk edition 
rm 
clarke wing 
formal methods state art directions 
acm computing surveys december 
harman 
mastering simulink 
prentice hall 
dennis 
version data flow procedure language 
goos hartmanis editors programming symposium volume lecture notes computer science pages 
springer verlag 
edwards lavagno lee sangiovanni vincentelli 
design embedded systems formal models validation synthesis 
proceedings ieee march 
eker lee liu liu sachs xiong 
taming heterogeneity ptolemy approach 
proceedings ieee january 
elmqvist otter 
modelica new object oriented modeling language 
proceedings th european simulation multiconference june 
ashcroft wadge 
multidimensional programming 
oxford university press may 
flynn 
computer organisations effectiveness 
ieee transactions computers september 
girault lee lee 
hierarchical finite state machines multiple concurrency models 
ieee transactions computer aided design integrated circuits systems june 
gr liao martin swan 
system design systemc 
kluwer academic publishers 
gr liao martin swan 
system design systemc 
kluwer academic publishers 

survey system ona chip design verification 
technical report electrical computer engineering department concordia university montreal canada 
halbwachs 
synchronous programming reactive systems 
kluwer academic publishers 
halbwachs caspi raymond pilaud 
synchronous data flow programming language lustre 
proceedings ieee september 
halbwachs raymond 
validation synchronous reactive systems formal verification automatic testing 
asian asian computing science conference pages thailand december 
lncs springer verlag 
harel 
statecharts visual formalism complex systems 
science computer programming 
hoare 
communicating sequential processes 
communications acm august 
lee liu liu xiong zheng editors 
ptolemy ii heterogeneous concurrent modeling design java volume 
department electrical engineering computer sciences university california berkeley 
memorandum ucb erl version 
ieee 
ieee standard verilog hardware description language 
ieee 
ieee 
ieee standard vhdl language manual 
ieee 
technology working group 
international technology roadmap semiconductors design edition 
jagannathan 
coarse grain dataflow programming conventional parallel computers 
bic 
gao editors advanced dataflow computing multithreading pages 
ieee computer society press 
ger 
technical economical barriers drivers formal methods verification digital systems 
master thesis darmstadt university technology department electrical engineering information technology january 
jantsch 
modeling embedded systems socs concurrency time models computation 
systems silicon 
morgan kaufmann publishers june 
jantsch 
models embedded computation 
embedded systems 
crc press 
invited contribution appear 
jantsch 
composite signal flow computational model combining events sampled streams vectors 
proceedings design test europe conference date pages paris france march 
jantsch sander 
roles functions objects system specification 
proceedings international workshop hardware software codesign 
jones 
haskell language libraries 
cambridge university press 
kahn 
semantics simple language parallel programming 
proceedings ifip congress stockholm sweden 
north holland 
kahn macqueen 
coroutines networks parallel processes 
ifip 
north holland 
kern 
formal verification hardware design survey 
acm transactions design automation electronic systems april 
malik newton rabaey sangiovanni vincentelli 
system level design concerns design 
ieee transaction computer aided design integrated circuits systems december 
le guernic gautier le le marie 
programming real time applications signal 
proceedings ieee september 
lee 
overview ptolemy project 
technical report ucb erl university california berkeley ca july 
lee messerschmitt 
static scheduling synchronous data flow programs digital signal processing 
ieee transactions computers january 
lee messerschmitt 
synchronous data flow 
proceedings ieee september 
lee parks 
dataflow process networks 
ieee proceedings may 
lee sangiovanni vincentelli 
framework comparing models computation 
ieee transactions computer aided design integrated circuits systems december 
lee xiong 
behavioral type system application ptolemy ii 
formal aspects computing 

bois 
survey current functional verification practice 
technical report cole de montr universit de montr 

argos language graphical representation automata description reactive systems 
ieee workshop visual languages october 
patel shukla 
functional programming framework heterogeneous model computations system design 
proceedings forum specification design languages lille france september 
mcfarland 
formal verification sequential hardware tutorial 
ieee transactions computer aided design integrated circuits systems may 
milner 
calculus communicating systems 
lncs 
milner 
calculus communicating systems volume lecture notes computer science 
springer verlag 
milner 
communication concurrency 
prentice hall 
patel shukla 
systemc kernel extensions heterogeneous system modeling 
kluwer academic publishers boston dordrecht london june 
paul thomas 
models computation systems chip 
wolf editors multiprocessor systems chip chapter 
morgan kaufman publishers 
halbwachs 
implementing reactive programs circuits hardware implementation lustre 
rex workshop proceedings june 
rose leiserson saxe 
optimizing synthesis circuitry retiming 
proc 
caltech conference vlsi pages 
roy ramesh chakraborty nakata rajan 
functional verification system chips practices issues challenges 
proceedings th international conference vlsi design 
sander jantsch 
system modeling transformational design refinement forsyde 
ieee transactions computer aided design integrated circuits systems january 
savage 
models computation exploring power computing 
addison wesley 
engels 
programming environment design complex high speed asics 
proceedings design automation conference anaheim ca june 
skillicorn talia 
models languages parallel computation 
acm computing surveys june 
strehl thiele gries ernst teich 
internal design representation codesign 
ieee transactions large scale integration vlsi systems august 
synopsys systemc compiler behavioral modeling guide 
synopsys systemc compiler rtl user modeling guide 
taylor 
models computation formal language 
oxford university press new york 
grimm 
systemc ams requirements design objectives rationale 
proceedings design automation test europe conference 
wadge ashcroft 
lucid dataflow programming language 
academic press 

scheduling behavioural vhdl retiming techniques 
proceedings pages september 
winskel 
formal semantics programming languages 
mit press 
richter ernst thiele teich 
spi system model specified embedded systems 
ieee transactions large scale integration vlsi systems august 

