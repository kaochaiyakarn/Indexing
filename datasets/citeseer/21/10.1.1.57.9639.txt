machine learning kluwer academic publishers boston 
manufactured netherlands 
naive bayesian classification structured data peter flach peter flach bristol ac uk department computer science university bristol united kingdom nicolas lachiche lachiche fr universit louis strasbourg france 
bc bc systems perform naive bayesian classification structured individuals 
approach bc project individuals order features 
features built individual structural predicates referring related objects atoms molecules properties applying individual related objects bond atoms 
describe individual terms elementary features consisting zero structural predicates property features treated conditionally independent spirit naive bayes assumption 
bc represents alternative order upgrade naive bayesian classifier considering probability distributions structured objects molecule set atoms estimating distributions probabilities elements assumed independent 
unifying view systems bc works language space bc works individual space 
new efficient recursive algorithm improving original approach bc 
systems implemented context order descriptive learner investigate differences systems computational terms artificially generated data 
describe range experiments ilp benchmark data sets demonstrating viability approach 

probabilistic approaches classification typically involve modelling conditional probability distribution ranges classes descriptions language objects classified 
description particular object assign class 
bayesian approach splits posterior distribution prior distribution likelihood denominator normalising factor ignored determining maximum posteriori class depend class 
key term equation likelihood description class abbreviated 
bayesian classifier estimates likelihoods training data typically requires additional simplifying assumptions 
instance attribute value representation called propositional single table representation individual described vector values fixed set attributes 
determining requires estimate joint probability abbreviated 
joint probability distribution problematic reasons size exponential number attributes requires complete training set examples possible description 
problems vanish assume attributes peter flach nicolas lachiche independent class ai ai assumption usually called naive bayes assumption bayesian classifier assumption called naive bayesian classifier abbreviated naive bayes 
effectively means ignoring interactions attributes individuals class 
cases assumption clearly false naive bayesian classifier give results domingos pazzani 
explained considering interested se merely calculating class 
values attributes naive bayes assumption result loss predictive accuracy result interaction actual probabilities different 
roughly speaking requires combined attribute correlates class similar way individual attributes 
instance case naive bayesian classifier clearly fails separately correlate positively class conjunction correlates negatively xor parity problems 
way saying naive bayes ranker poor probability estimator 
inductive logic programming ilp called multi relational data mining studies upgrade machine learning methods richer representation formalism order logic general logic programming languages prolog particular muggleton muggleton de raedt zeroski lavra :10.1.1.35.951
originally perceived form logic program synthesis examples pure classification task ilp appeared different attribute value learning 
years view ilp emerged stresses similarities differences propositional learning 
central view notion individual centred representation flach lavra flach data describes collection objects molecules customers sales transactions distinguish individuals molecules classified target predicate class related objects atoms bonds induced rules generalise individuals mapping class 
clearly notion structured individual arises domains including molecular biology bio informatics information retrieval structured documents web pages image processing 
probabilistic viewpoint pursued main question model influence related objects likelihood classify individual 
chief complication individual may arbitrary number related objects 
result logical representation space simple cartesian product attributes assumed attribute value probability space employed naive bayes 
order resolve mismatch downgrade representation space upgrade probability space 
approach employs aggregated properties related objects attributes individual 
closely follows language possible descriptions object call language space approach 
second approach involves defining estimating probability distributions structured objects 
naive bayesian classification structured data approach follows structure actual individuals classified call individual space approach 
study approaches upgrading propositional naive bayesian classifier structured data 
approach leading bc system select restricted set order conditions attributes classical propositional naive bayesian classifier 
second system bc generalises propositional naive bayes introducing ways estimate probability distributions structured objects described essentially annotated entity relationship model 
geometric distribution modelling probabilities collections order see far simple approach takes 
systems unifying perspective focusing representation 
outline follows 
start defining representation structured objects section 
clearly representation data hypotheses crucial importance machine learning spend time discuss links isp representation relational representations term representations 
discuss ways upgrading attribute value classifier structured data considering language space considering individual space 
sections devoted respectively language approach individual approach 
section compare approaches regarding algorithmic properties investigate differences behaviour artificial data sets 
section describes experimental results ilp data sets 
section discuss range related 
section concludes summary main contributions outlook 

representing structured data section different representations structured data compared 
representation isp declarations individuals structural predicates properties 
sections compare isp representations flattened relational representations respectively 
term representation relevant forms conceptual basis bc probability distributions 
section take closer look individual language spaces 

isp representation follow flattened prolog datalog notation 
literal consists predicate number arguments brackets 
arguments predicates variables starting upper case character constants starting lower case character 
instance element carbon literal consisting binary 
rules clauses written backwards implications replacing implication connective 
rule states atom class mutagenic molecule atom element carbon peter flach nicolas lachiche variables implicitly universally quantified 
distinction variables occurring antecedent consequent rule variables occurring antecedent 
called existential variables universal quantifier variables pushed antecedent existential quantifier 
roughly speaking variables occur antecedent consequent refer individual classified existential variables refer parts individuals 
order features consider interpreted antecedents rules rely data model inform variables feature denotes individual 
data modelling approach inspired strongly typed term representation proposed flach translated flattened prolog setting flach lachiche flach lachiche 
approaches rule learning lavra flach relational subgroup discovery lavra 
data model consists isp declarations parts part declaring individuals part declaring structural predicates part declaring properties 
part starts appropriate keyword 
illustrate isp declarations mutagenesis data set srinivasan 
concerned predicting molecules cause mutations cells 
molecule described structure atoms bonds atoms measurements certain chemical properties 
individual molecule mol structural mol atom mol atom fr atom bond atom bond atom bond atom bond properties class mol class lumo mol lumo logp mol logp element atom element atom charge atom charge bond mode declarations progol muggleton domain assigned argument declared predicates 
avoid word type reserved term representations section 
instance class mol class declaration arity argument ranging domain mol second argument ranging domain class 
hash denotes parameter argument predicate instantiated hypotheses constants data parameters occur properties 
non parameter domains indicate object identifiers 
isp declaration identifies domain individual mol 
unary predicate molecule dummy predicate sole purpose give individual naive bayesian classification structured data declarations syntax declarations 
structural predicates express relationships objects 
instance atom mol atom states relationship molecule atoms atom belongs exactly molecule molecule related atoms 
keep representation compatible previous representations mutagenesis literature bonds oriented atom bond distinguished second fr atom bond atom bond 
remaining declarations denote properties individual related objects 
properties assign value object 
instance element atom element declares predicate specifying element atom element states carbon atom 
parameter instantiated constant examples hypotheses features 
predicate stands attribute object parameter stands value remaining argument identifies object 
property similar propositional attribute necessarily refer individual 
parameter represents value attribute 
definition structural predicate property 
structural predicate binary predicate representing relation domain 
object domain functional structural predicate structural function refers unique object domain non determinate structural predicate non functional 
property binary predicate characterising object domains parameter 
parameter argument property instantiated 
non determinate structural predicates form collections objects 
term collection generic term flexible size aggregates lists sets multisets term non determinacy refer existence flexible sized collections noted properties assumed discrete bc bc instructed continuous properties training model discrete random variables 
part description molecule isp declarations 
class mutagenic 
lumo 
logp 
atom second atom mol atom 
mol atom 
element 
element 


charge 
charge 
fr atom bond 
atom bond 
fr atom bond 
atom bond 
bonds 


peter flach nicolas lachiche usual flattened representation structure individual encoded predicates 
individual described ground facts referring ground facts referring related objects linked tod structural predicates 
concludes description isp data model 
section show data model define order features subset elementary features bc 
remainder section discuss relation isp declarations closely related data models entity relationship models type signatures 

relational representation relational representations known databases include relational database model entity relationship model 
model essentially formalism representing meta data relational model closely associated operations data 
practice model process transforming relational model understood date 
show close link isp declarations restricted model 
model consists entities objects relationships entities 
gives entity relationship model mutagenesis data set 
molecule class lumo logp mol atom atom bond element charge 
entity relationship model mutagenesis data set 
restrictions imposed isp declarations identifiers keys composite binary relationships allowed relationships carry property 
restriction merely technical identifiers easily restricted single variable introducing new identifier necessary 
second restriction roughly means ary relationship new entity 
restriction implies properties normally carried relationships properties entities existing entities relationships corresponding functional dependencies new entity relationships 
link isp declarations restricted model straightforward 
individual section isp declarations corresponds entities 
properties isp declarations correspond attributes entities model 
structural predicates correspond relationships 
naive bayesian classification structured data 
term representation full non flattened prolog ability represent structured data means functors non evaluated function symbols arguments terms 
nonrecursive functors called data constructors represent tuples recursive functors represent flexible size ordered datatypes lists trees 
non typed language prolog functors introduced typed language need declared 
typed language ilp advocated flach type declarations establish strong declarative bias similar entity relationship data model 
example type definition mutagenesis written escher language higher order logic functional programming language haskell functional programming language lloyd lloyd type molecule atoms lumo logp type atoms atom type lumo float type logp float type atom element charge data element br cl type int type charge float type bond type bond type bond type int molecule tuple consisting set atoms attributes lumo logp 
atom tuple consisting attributes element enumerated datatype integer charge floating point number 
remainder type structure deals bonds atoms 
presence bonds means molecules graphs trees 
pure term representations object identifiers graph structures molecules pose representational problems 
simplified example obtain tree representation molecule cutting bond middle 
order maintain consistency benchmark data set bonds directed 
consequently atom associated sets bonds ones depart atom ones arrive atom 
bonds attributes simplicity represented tuple single 
gives graphical representation type structure 
relation term representation isp representation defined slightly immediate entity relationship case 
generally speaking translating term representation isp flattening rouveirol involves naming non atomic subterms introducing object identifiers 
structural predicates correspond going composite term subterm 
simplified tuples involved go molecule atom step sets atoms peter flach nicolas lachiche element atom element charge charge 
type structure mutagenesis data set 
atoms atom molecule atoms lumo logp bond bond lumo bond bond interesting right collapse relation molecules sets atoms relation sets atoms atoms single oneto relation molecules atoms 
isp property corresponds atomic component tuple 
comparing representations see bias imposed isp representations predominantly concerned distinguishing oneto relationships 
bias imposed term representations finer grained able represent different kinds non determinacy arising different datatypes list sets multisets 
advantage term representation term self contained 
hand terms easily handle graphs trees leads loss information example need resort naming related objects order deal occurrences atoms occurring bonds 
isp representations closer representations useful keep term representation mind conceptual basis probability decompositions bc 
order facilitate isp declarations practice inherit characteristics term representation particularly ability annotate structural predicates datatype list set multiset 
logp naive bayesian classification structured data 
individual space language space starting point upgrade propositional naive bayesian classifier right hand side equation need obtain likelihood observing individual description class naive bayesian approach need decide decompose likelihood independent components easily reliably estimated 
propose ways upgrading propositional naive bayesian classifier structured data 
approach consists upgrading propositional attributes order features see section 
involves generating equivalent propositional attributes called order features take account relevant properties individual related objects 
words structured representation projected tuple feature values 
approach usually referred kramer 
straightforward approach generate data set applying propositional learner 
section shows approach efficiently implemented recursive algorithm 
feature space generated explicitly handled implicitly classification phase 
similar kernels support vector machines kernel methods see rtner kernel defined structured objects 
second approach upgrading propositional naive bayes involves modifying probabilistic engine 
representation transformation involved directly structured representation 
suppose individual classified collection objects description enumeration objects included collection 
modified naive bayes assumption states know probabilities objects assumed independent determine probability collection 
covered section 
mentioned approaches common core captured algorithm follows structure data 
common perspective difference approaches bc works language space bc works individual space 
order build order features approach considers language 
features built recursively domain object property order feature domain related structural predicate 
second approach works individual space 
estimated probability individual product estimated probabilities properties estimated probability collection objects related structural predicate turn obtained recursively estimated probabilities 
common principle approaches consider properties current object recursively consider related objects 
practical difference approaches actual structures language space individual space differ 
figures show entity relationship term representations individual molecule mutagenesis data set 
individual structures contrasted language structure expressed data model cf 
figures 
peter flach nicolas lachiche mutagenic mol atom mol atom mol atom 
individual relational representation mutagenesis data set 

individual term representation mutagenesis data set 
naive bayesian classification structured data 
upgrading naive bayes language space section language space approach upgrading propositional naive bayesian classifier 
introduce order features generalisation propositional attributes section 
section discusses implementation bc system 

order features order features defined appeared flach lachiche approaches including lavra flach lavra 
built isp declarations introduced section attributing individual property related objects linked individual structural predicates 
order feature defined syntax 
definition order feature 
global variable denoting individual firstorder feature abbreviated feature individual conjunction literals involving structural predicates properties 
structural predicate uses global variable local variables introduced structural predicates introduces new local variable 
properties introduce new variables 
variables structural predicate property 
kinds order features depending structural predicates involved non determinate 
fairly common case structural predicates non determinate case feature existential called nondeterminate 
instance mol atom fr atom bond order feature relates property appropriate structural predicates intermediate objects atom variables existentially quantified variable corresponding individual free quantified 
proper order predicate language feature written mol atom atom bond 
existential quantifier acts aggregation operator disjunction possible instantiations variable 
additionally different aggregation operators minimum maximum average cardinality increase expressiveness wrobel 
existential operator appropriate data sets including multi instance problems dietterich aggregation operators may sense data sets pkdd challenge involving analysis financial data 
existential aggregation currently implemented bc 
structural predicates involved functional new variables introduce require quantification uniquely determined variables 
peter flach nicolas lachiche feature contains non determinate structural predicate feature existential domain feature boolean feature true false 
features involving structural functions inherit domains properties involved 
feature functional structural predicates involved feature functional individual related objects 
domain functional feature cartesian product domains parameters properties 
functional features treated separately algorithms 
special case functional features structural predicates refer properties individual called propositional attributes 
instance lumo functional feature declared property 
reader noticed minimality requirement definition 
instance conjunction satisfies definition mol atom element mol atom logically equivalent conjunction simpler order features share global variable literals literals respectively 
easy define order features minimal sense done 
lavra flach 
notice subsumption relation features mol atom element subsumes mol atom element 
naive bayes assumption features conditionally independent clearly invalid subsumption relation features 
reason stronger constraint order features guarantees absence subsumption relations 
definition elementary features 
order feature elementary contains single property 
context elementary feature conjunction structural predicates occurring 
individual value elementary feature parameter value property feature functional true false depending feature satisfied individual feature non determinate 
easily seen exclude structural predicates propositional features properties individual elementary 
restriction elementary features assuming independence said generalise propositional naive bayes assumption 
noted order case restriction leads loss statistical logical knowledge features involving property referring non determinate local variable written conjunctions elementary features 

bc order naive bayesian classifier bc upgrade propositional naive bayesian classifier relying elementary order features 
bc implemented context order rule discovery flach lachiche 
uses isp declarations explained section argument predicate belongs named type set constants belonging type defines naive bayesian classification structured data domain 
domain continuous intervals standard deviation centered mean specified number equal size bins 
constructs order features top search starting empty feature iteratively refining adding structural predicates properties 
order prevent redundancy refinement steps adding literal unifying variables instantiating variable applied fixed order 
particular refinement step applied predecessors applicable anymore 
infinite number refinements search restricted maximum number literals variables specified command line 
addition maximum number occurrences particular predicate specified part isp declarations 
elementary order features generated generate hypotheses containing exactly property unnecessary structural predicates 
features optionally read file 
bc system flach lachiche proceeds follows 
training phase generates order features counts individuals class satisfy value feature 
specifically feature fi feature value fi class obtain counts fi 
calculates probability estimates counts laplace correction fi fi number values fi number parameter values functional feature non determinate feature 
classification phase involves calculating class likelihoods test instance multiplying class prior determining class maximises posterior 
algorithm details calculation class likelihoods 
algorithm bc classification algorithm non recursive version obtain likelihoods individual class classes initialise likelihoods class cl iterate features feature value class cl cl return cl re iterate point value feature referred algorithm boolean case non determinate feature 
means presence absence property values molecule contains carbon atom taken account 
contrast functional feature property value occurring individual influences likelihood 
distinction relevant case missing values functional features assumption missing property value non determinate features apply closed world assumption peter flach nicolas lachiche sense assume non determinate feature true evidence false 
section show recursive implementation similar individual space significantly decrease runtime compared non recursive implementation 

upgrading naive bayes individual space previous section derived order upgrade naive bayesian classifier language space 
essentially approach map order representation propositional feature space probability distribution defined usual way 
propositional probability space defined terms summary statistics original data particular example related object certain property 
advantage approach simplicity particular modify naive bayes engine 
hand loss logical information disadvantage 
section consider alternative way upgrading naive bayes considering individual space structured objects directly data model 
requires definition probability distributions structured objects considered section 
bc system implements section 

probability distributions structured objects bc directly models probability space ranging structured individuals 
requires definition probability distributions structured datatypes isp representation structural predicates 
probability individual defined joint probability properties hand related objects linked structural predicate 
extending propositional naive bayes assumption properties individual conditionally independent class related objects likewise assumed conditionally independent naturally arrive recursive approach probability object composed marginal probabilities properties probabilities related objects 
recursive composition considerably simplifies analysis consider case object consisting collection related objects probability distribution possible related objects known 
related objects considered atomic xn denotes domain related objects atoms pd probability distribution domain 
question define probability distributions collections elements flach appear analysed question detail summarise results 
considered possibilities loosely referred aggregation mechanisms lists multisets sets 
list distribution corresponds simple stochastic logic program muggleton cussens extends type checking logic program lists probability distributions clauses naive bayesian classification structured data element 
element 
element 
list 
list element list 
probability list obtained multiplying probabilities clauses involved refutation query list 
instance probability list probability list 
put differently geometrically decaying distribution list lengths probability empty list combined pd follows 
definition geometric distribution lists 
pli defined follows pli xj pd ji parameter determining probability empty list 
readily seen defines proper probability distribution 
clearly terms product result 
fix list length pd ji adds possible lists length distribution essentially tuple distribution independent components cumulative probability lists length 
equivalent definition obtained extended domain xn symbol distribution pd pd xi pd xi 
follows pli xj pd ji 
pd represents sided die generates list elements symbol appears 
notice ordering list elements disregarded sense permutations particular list obtain probability 
want include ordering list elements distribution assume distribution pa pairs elements domain probability pa ab pa bc lists length 
distribution take aspects ordering account note obtain probability consist pairs aa ab ba start obviously continue process triples quadruples note increasingly computationally expensive unreliable probabilities estimated data 
geometric distribution defined probability multiset flach appear total probability mass permutations 
multiset ki stand number occurrences th element domain ki denote cardinality multiset 
probability obtained pd xi ki ki 
ki independent class treating lists multisets affect classification performance bc 
peter flach nicolas lachiche similar vein set seen equivalence class lists multisets containing element set elements 
instance set interpreted stand lists length contain ii element domain cumulative probability lists satisfying condition ii easily calculated condition computationally expensive requires iterating subsets set 
non empty subset elements domain defined probability set pss pd pd pd pd 
subset distribution takes elements occurring set account ignores remaining elements domain 
instance set probability regardless element domain probability elements cumulative probability contrast usual approach sets representing tuple distribution defined disadvantage probability set depends elements extension complement 
advantage subset distribution applicable finite subsets infinite domains 
obvious disadvantage subset distribution exponential cardinality set expensive compute large sets 
turns list distribution approximate subset distribution set pd case large domains sets ranging structured objects 
case pss pli ls ls list constructed choosing arbitrary order elements proof flach appear 
experiments bc system computationally feasible subset distribution yielded virtually identical classification results list distribution 
experiments reported section exclusively list distribution 
goal see improvement get simple probabilistic model collections 
bc seen starting point aim refine considering sophisticated probability distributions collections 
general format different distributions domain distribution pd parameter probability distribution collections objects defined pd higher order function probability distribution argument returning probability distribution 
instance case list distribution pd pd assume behaved sense pd probability distribution probability distribution case list multiset subset distributions described 
nest distributions recursively passing result level order define distribution collections level aggregation 
explains recursive nature algorithm section 
illustrate type structure depicted compute probability distribution molecules bottom fashion 
know distri naive bayesian classification structured data bution domain bond types calculate subset distribution approximation list distribution 
combine distributions tuple distribution yielding 
subset distribution combining tuple distribution obtain 
notice class conditional version col required naive bayesian classifier obtained plugging class conditional domain distribution pd class conditional value 
estimated data described section 

bc order naive bayesian classifier section implementation ideas bc probabilistic classifier 
explained predecessor bc fundamentally recursive distributions collections elements take probability elements account 
element composite type probability estimated probabilities components 
recursion stops properties 
instance probability element mutagenic carbon atom mutagenic molecule estimated proportions atoms mutagenic molecules carbon atoms 
difference bc case counting number mutagenic molecules carbon atoms number carbon atoms occurring mutagenic molecules 
counting property values feature values 
probability bond mutagenic bond atoms type estimated way 
need take account bonds ordered representation paths molecule bond atom bond second atom bond 
context property occurs path individual property taken account object occurs different contexts occurrences treated distinct objects 
similarly structural predicates properties indexed context occur essentially preceding structural predicates order feature 
mutagenesis data set notion context slightly artificial arises arbitrary orientation bonds 
data sets finite element mesh design data set dol sak muggleton crucial :10.1.1.35.951
data set concerns predicting number finite elements needed model edge properties properties topologically related edges 
sense take account property related differently class depending property individual mesh classified edge left hand side individual 
detail classification training phases 
training phase estimate probabilities property value class context 
involves counting objects satisfy value property account target predicate context property connected individual example 
maintain dimensional matrix peter flach nicolas lachiche indexed property value context class fill matrix iterating training individuals 
classification algorithm uses laplace estimate convert counts class conditional probability estimates 
done differs bc estimates probability property values feature values 
algorithm bc training algorithm take account contribution object counts class context ctxt ctxt handle properties object properties prop corresponding parameter value prop ctxt handle related objects structural predicates struc involving ctxt add struc ctxt struc functional related object ctxt non determinate structural predicate set related objects struc ctxt struc ctxt object ctxt top level initialise counts null training stands empty context 
collect counts needed class conditional estimates 
training set processed obtain structural predicate context class average number lc objects associated collections 
probability empty collections estimated lc maximum likelihood estimate cardinalities distributed lc lc flach appear 
implemented 
classification main function object context ctxt 
returns table estimate class class conditional likelihoods object individual related objects 
notice context passed argument relevant calculations 
new context new parameter value occurs test set training set ignored estimation likelihood 
naive bayesian classification structured data algorithm bc classification algorithm obtain likelihoods object class classes context ctxt ctxt initialise likelihoods class cl handle properties object properties prop corresponding parameter value class cl cl prop ctxt handle related objects structural predicates struc involving ctxt add struc ctxt struc functional related object cl ctxt class cl cl cl non determinate structural predicate set related objects object cl ctxt class tau struc ctxt cl cl cl tau return cl cl tau calculates class conditional probability collection objects class conditional list distribution defined definition possibly multiset subset distributions discussed section 
top level null test 
illustrate classification algorithm means worked example 
example classification molecule order classify molecule see bc estimates likelihood class properties object probabilities objects linked 
molecules retrieve probabilities lumo value logp value estimated training phase 
consider structural atom 
molecule atoms order apply pli bc requires probability atom conditional class 
obtained applying algorithm recursively 
probability atom estimated properties element charge probabilities objects linked fr atom bond atom bond peter flach nicolas lachiche fr atom bond class look estimates probability carbon atom probability atom number probability charge class 
need estimate probabilities bond applying algorithm 
probability bond estimated property context atom bond 
done appropriate contexts bonds occurs 
probabilities pli formula get probability sets bonds 
information calculate probability atom class multiplying bond set probabilities 
done atoms 
pli formula calculate probability set atoms probabilities atom combined probabilities lumo logp yield probability molecule 
example assumed lumo logp charge discretised 
discretised actual value replaced identifier appropriate bin 
flattened language bc allows representational flexibility pure term language subterms named 
means graph structures molecules modelled need take care avoid cyclic computations 
isp declarations limit number times structural predicate set example 
addition global limit number structural predicates set 
practice means individual represented set paths related objects satisfying length constraints 

comparison bc bc section compare systems order understand differences operation performance 
section alternative recursive implementation bc runtime performance similar bc 
section explains main differences computations performed systems small example 
section investigates behaviour differences bc bc artificially generated data sets 

algorithmic comparison table presents runtimes bc bc data sets described section 
experiments run normal workstation pc mhz mb ram 
table obvious non recursive implementation bc algorithm originally proposed flach lachiche runs considerably slower recursive implementation bc particular relational data sets 
turns calculations performed bc bc sufficiently similar allow efficient recursive implementation bc 
detailed remainder section 
recursive bc training algorithm initialises counts iterates null defined algorithm training naive bayesian classification structured data table 
runtimes seconds nonrecursive implementation bc compared recursive implementation bc performing fold cross validation data sets 
data set bc bc target mutagenesis propositional mutagenesis relational propositional relational class null initially empty context 
main issue existential aggregation counting individuals property counted individual ignored current individual passed additional argument 
algorithm bc training algorithm recursive version add contribution individual class counts properties object context ctxt ctxt handle properties properties prop encountered ctxt corresponding parameter value prop ctxt handle related objects structural predicates struc involving ctxt add struc ctxt set related objects object ctxt bc convert counts probability estimates 
ctxt prop stands elementary feature built structural predicates deals counts appropriate way depending non determinate functional 
classification phase proceeds stages 
calculate likelihood individual collect contribution properties related objects occurring making sure prop processed 
take remaining non determinate features satisfied account apply closed world assumption non determinate features 
peter flach nicolas lachiche algorithm bc classification algorithm recursive version obtain likelihoods individual class classes cl null non determinate contexts ctxt properties prop parameter values prop encountered ctxt class cl cl ctxt prop return cl obtain contribution object context ctxt class conditional likelihood individual ctxt initialise likelihoods class cl handle properties properties prop corresponding parameter value prop encountered ctxt class cl cl ctxt prop handle related objects structural predicates struc involving ctxt add struc ctxt set related objects object cl ctxt class cl cl cl return cl recursive implementation bc produces exactly probabilities non recursive implementation runtime similar runtime recursive implementation bc second column table 

comparison worked example assuming bc uses geometric list distribution estimate probabilities nondeterminate structural predicates main differences bc bc 
small training set test individual illustrate differences 
notational brevity term representation cf 
section 
individual pseudo molecule consisting collection atoms atom pair element type arbitrarily chosen 
training set contains positive examples naive bayesian classification structured data table 
conditional probabilities learned bc bc small example 
bc bc positive negative positive negative mol atom element mol atom element mol atom element mol atom element mol atom type mol atom type mol atom type mol atom type mol atom type mol atom type negative examples test individual table lists conditional likelihood estimates obtained bc bc training phase 
difference counts individuals bc related objects appearing context bc 
instance consider feature mol atom element stating molecule contains oxygen atom 
bc counts positive examples contain oxygen atom laplace estimate feature boolean bc counts atoms belonging molecule required context oxygen atoms element property take different values laplace estimate second difference number atoms molecule taken account bc 
bc likelihood estimates table directly bc pli pd distributions 
probability associated atom multiplied obtain pd 
estimated average cardinality positives negatives 
third difference property taken account individual bc occurrence taken account bc 
classifying test individual bc uses probabilities associated hydrogen element bc uses 
peter flach nicolas lachiche fourth difference bc probabilities associated properties occur test individual bc takes account nondeterminate features satisfied 
classifying test individual bc uses probabilities associated nitrogen element bc 
putting bc calculates likelihood test individual positive class similarly likelihood negative class bc classifies test individual structure 
set atoms estimates likelihood atom positive class pd pd pd 
account obtain likelihood positive class similarly likelihood negative class calculated prior distribution uniform bc predicts test individual negative bc predicts positive 
explained fact number atoms test individual occurrences suggest positive class factors ignored bc 

experimental comparison artificial data sets section describe experiments artificially generated data 
section performance assessed accuracy estimates obtained crossvalidation 
addition analysed performance underlying probabilistic model means roc curves 
roc curves provide information accuracy estimates poor accuracy result poorly chosen decision threshold roc curve see lachiche flach method determine thresholds class multi class naive bayesian classifiers 
probabilistic classifiers roc curves evaluate predicted probabilities separating positives negatives committing particular decision threshold concern ranking performance classification performance 
area roc curve auc indicates aggregated quality classifiers constructed setting different thresholds interpreted probability randomly drawn positive example ranked higher model randomly drawn negative example hand till 
experiments roc curves constructed cross validation merging rankings obtained test fold 
simple way averaging roc curves doesn give error bars fawcett 
generated artificial data sets examples collections pairs constants 
collections generated sampling geometric list distribution parameter 
components pairs generated independently sampling fixed distribution values 
data set card generated test hypothesis bc better able distinguish collections different cardinality 
generated examples average cardinality approximately collections contained pairs uniformly distributed constants 
examples naive bayesian classification structured data card auc bc bc bc bc auc bc bc dist auc bc bc 
roc curves artificial data sets 
denote point chosen default probability threshold diagonal lines indicate iso accuracy lines points higher lines better 
ex bc bc bc bc peter flach nicolas lachiche table 
accuracy results artificial data sets obtained fold cross validation fold case 
data set bc bc card dist ex elements designated positive rest negative resulted roughly positives negatives 
accuracy auc results table roc curves clearly show bc achieves near perfect performance task 
bc performs nearly positives achieves random performance remainder data 
second data set dist generated test hypothesis bc model distributions domains elements atoms bc models existential aggregation 
generated collections average length consisting pairs component value probability values probability chose different majority values positive negative class examples 
results show superior performance bc bc bc roc curve shows performs roughly positives negatives random performance remainder 
third data set ex designed demonstrate bc needs data learn distributions performance may degrade smaller data sets 
generated small collections uniformly distributed constants possible values 
collection positive contained particular constant negative existential concept 
data set contains positive negative examples way examples generated small difference average cardinality positives negatives bc able take advantage 
bc performs clearly worse bc simple task bc accuracy suffers fact default probability threshold clearly sub optimal case 
conclude experiments bc generally preferable bc small data sets 
bc structural probabilities tend dominate probabilities propositional attributes demonstrated section mutagenesis dataset 

experimental evaluation evaluated classification performance bc bc ilp data sets identifying mutagenic compounds drugs alzheimer disease structure elucidation 
naive bayesian classification structured data table 
accuracy mutagenesis regression friendly data set 
majority class settings 
bc bc accuracies reported indicates accuracy achieved default threshold indicates accuracy achieved optimised threshold described lachiche flach 
settings bc bc progol regression lumo logp lumo logp ind atoms bonds plus lumo logp plus ind 
mutagenesis problem concerns distinguishing mutagenic non mutagenic compounds srinivasan muggleton 
considered regression friendly regression unfriendly data sets 
experiments atom bond structure molecule setting adding lumo logp properties get second setting adding boolean indicators ia 
experiments involving lumo logp propositional attributes 
regression friendly data set 
continuous properties lumo logp charge discretised respectively intervals equal size interval contains number individuals 
numbers chosen order get intervals possible containing representative number individuals 
fold cross validation performed 
accuracy results listed table 
progol regression results quoted muggleton 
thing note propositional data bc bc achieve identical performance construction naive bayes outperforms regression 
accuracy drops considerably atoms bonds considered 
addition propositional attributes improves accuracies weight generally compensate negative influence atoms bonds 
notice bc benefits bc propositional features probabilities order features bc order propositional features bc probabilities collections smaller differences likelihoods collections tend dominate 
roc curves auc results 
default thresholds indicated 
settings propositional clearly seen bc bc produce identical probabilistic models 
relational settings roc curves produced worse propositional indicator attributes 
regression unfriendly data set 
data set contains molecules 
accuracy estimates roc curves obtained leave customary dataset 
continuous properties data set small get reasonable peter flach nicolas lachiche lumo logp auc bc bc atoms bonds auc bc bc bc bc bc bc lumo logp ind auc bc bc plus ind auc bc bc plus lumo logp auc bc bc 
roc curves mutagenesis regression friendly data set 
performance best propositional representation attributes 
relational data sets bc slightly better bc default thresholds optimal near optimal bc advantage 
bc bc bc bc bc bc naive bayesian classification structured data number examples interval 
accuracy results table roc curves 
table 
accuracy mutagenesis regression unfriendly data set 
majority class settings 
settings bc bc progol regression lumo logp lumo logp ind atoms bonds plus lumo logp plus ind roc curves seen performance propositional settings poor 
data set addition indicator attributes lumo logp decreases performance worse majority class lumo logp performance slightly better majority class notice regression achieves worse majority class performance cases 
relational settings performance increases considerably choice default threshold poor 
settings bc optimised decision threshold achieves performance 
notice addition propositional attributes atoms bonds representation little effect bc terms roc curve influence location default optimal thresholds 

alzheimer disease 
data set drugs alzheimer disease asker 
aims comparing desirable properties drugs inhibit low toxicity high inhibition reversal memory deficiency 
properties leads distinct classification task 
table compares accuracies bc bc properties 
rac reconsider conquer rule learning algorithm proposed asker 
shows roc curves obtained data sets 
bc bc curves similar 
fourth targets default decision threshold clearly sub optimal 
fact seen optimal point fourth target majority class classifier 
notice performs considerably worse majority class targets outperforms naive bayes 
table 
accuracy alzheimer disease data set 
target bc bc rac majority class inhibit low toxicity high inhibition reversal memory deficiency peter flach nicolas lachiche lumo logp auc bc bc atoms bonds auc bc bc bc bc bc bc lumo logp ind auc bc bc plus ind auc bc bc plus lumo logp auc bc bc 
roc curves mutagenesis regression unfriendly data set 
top curves propositional data poor default threshold second data set results worse majority class performance 
curves relational data sets better default threshold sub optimal cases 
notice bc curves virtually identical relational representations atoms bonds dominate 
bc bc bc bc bc bc naive bayesian classification structured data inhibit auc bc bc high inhibition auc bc bc bc bc bc bc low toxicity auc bc bc reversal induced memory deficiency auc bc bc 
roc curves alzheimer disease data set 
fourth curve default threshold results worse majority class performance 
notice fourth curve class distribution performance improve majority class classification dataset improve majority class 
confirmed optimised accuracy results table 
bc bc bc bc peter flach nicolas lachiche table 
accuracy results data set 
majority class settings 
settings bc bc foil propositional relational propositional relational 
structure elucidation 
fundamental classes natural products members known zeroski 
structure elucidation nmr spectra nuclear magnetic resonance separated main stages identification residues ester identification skeleton arrangement residues skeleton 
data set concerned second stage identification skeleton 
skeleton unique connection carbon atoms specific atom number normalized pure skeleton molecule residues certain multiplicity measuring number directly connected particular carbon atom stands means proton hydrogen connected carbon stands proton connected carbon stands triplet quartet bound carbon atom 
data contains information known structure 
representations available propositional atom numbers known relational information 
order compare results zeroski accuracy evaluated fold cross validation settings considered representation separately 
multi class classification problem show roc graphs 
apply method finding improved decision thresholds 
propositional data set bc bc perform comparable toc relational instance learner better 
relational representation perform considerably better considerably worse 
combination propositional relational features improves bc performance relative settings case reasonable trade achieved 
naive bayes compete instance methods dataset relational settings 

related section discuss closely related literature 
basically fall groups approaches inductive logic programming incorporate upgrade naive bayesian classifier probabilistic models structured data order logic 
address groups turn 
naive bayesian classification structured data earliest considers naive bayesian classification ilp context kononenko 
approach consists learning set order rules step new attributes classical attribute value naive bayesian classifier 
closely related bc approach replacing bc exhaustive feature generation selective feature construction rule learner 
hand data modelling facilities limiting possibility adapt representation domain 
slattery craven goes direction uses naive bayes invent new predicates 
invented predicates boolean features individual 
demonstrate increased performance constituent learners various text classification data sets 
principle bc bc similar way invent complex predicates 
sbc multi relational simple bayesian classifier fairly similar bc 
knowledge representation involving binary structural predicates properties consider features consisting path structural predicates followed single property 
main difference sbc estimates probabilities structural path property separately 
allows storing path probabilities computing probability longer path probability prefix 
sbc interfaces directly relational database 
extensive body probabilistic models structured data discuss selection 
best known koller probabilistic relational models prms getoor 
upgrade bayesian networks define probabilistic dependencies top entity relationship model 
oneto relationship entities probabilistic dependency modelled means aggregation linked objects 
prms closely related bc regards knowledge representation aggregation deal non determinacy 
difference prms individual centred model learned data regardless molecules atoms individuals 
developments aggregate links include taskar lu getoor 
approaches combine logic programs probabilities include stochastic logic programs slps muggleton cussens bayesian logic programs kersting de raedt kersting raedt prism programming statistical modelling sato kameya sato kameya 
treat ground atoms herbrand base program random variables probability distributions defined 
contrast slps define probability distributions terms 
approach closely related bc 
showed section geometric list distribution generated slp 
distribution non determinate links isp data model transformed equivalent slp training phase bc correspond estimating probabilistic parameters slp 
close relationships exist bc probabilistic relational models hand bc stochastic logic programs clear advantages employing simple probabilistic model naive bayes 
instance general parameter estimation procedures exist slps cussens bound peter flach nicolas lachiche computationally expensive slow converge 
contrast maximum likelihood estimate parameter geometric distribution simply derived average cardinality 
mention ongoing hierarchical higher order bayesian networks flach flach appear 
idea lift naive bayesian independence assumptions defining probabilistic models higherorder type structure 
probabilistic decomposition employed bc special case higher order bayesian network similar way propositional naive bayesian classifier special case propositional bayesian network 

approaches upgrade propositional naive bayesian classifier deal structured data 
approach upgrading attributes order features works language space 
approach implemented bc system 
second approach generalises naive bayes estimate probability tuple elements probabilities components collections elements 
works individual space led bc system 
systems available line 
provides unified view bc bc approaches 
particular approach way upgrading propositional naive bayesian classifier 
compared lachiche flach context dependency added takes account explicitly structure object enables bc deal objects involving similar components different locations structure 
context key recursive implementation bc compared previous non recursive implementation flach lachiche 
bc inherits efficiency bc better typical approach 
mapping different feature space performed implicitly spirit kernel methods 
compared systems respect probabilities compute regarding performance artificially constructed data sets 
experiments confirm bc outperforms bc problems modelling cardinality collections distributions elements collections important 
hand demonstrate bc requires data estimate probabilities reliably 
experimental results obtained range benchmark ilp data sets 
confirm systems perform comparably ilp systems 
probabilistic classifiers criticised induce declarative interpretable models 
overlooked advantage probabilistic model ranker classifier calibrated improve classification performance 
roc analysis shown default decision threshold turn ranker classifier sub optimal 
lachiche flach suggest algorithm improve accuracy cost probabilistic classifier class multi class problems 
includes bc bc systems works structured data attribute value data 
naive bayesian classification structured data propositional case naive bayesian decomposition leads loss probabilistic information logical information 
relational case logical information lost 
means relational naive bayesian classifiers ones proposed expected sensitive representation 
experiments far paid particular attention worked simplest obvious representation 
plan analyse effect independence assumptions bc bc effect representation detail 
issue concerns continuous properties electric charge atom 
currently dealt nominal values discretisation pre processing 
option directly estimate probability continuous property john langley :10.1.1.8.3257
option various aggregation operators 
aim naive bayesian classifier efficient structured data complexity 
important feature ilp systems incorporation logical background knowledge 
currently systems allow plan alleviate restriction 
starting point dehaspe combines maximum entropy approach logical constraints 
plan look effect different probability distributions collections 
apart bitvector distribution corresponds geometric list distribution simplest ways modelling probabilities collections 
main aim far bc investigate improvement get simple means 
step see improvements achieved sophisticated distributions collections 
acknowledgments part supported eu framework project data mining decision support business competitiveness solomon virtual enterprise ist 
due henrik sa zeroski providing alzheimer data sets respectively 
anonymous reviewers extensive insightful comments helped considerably improve 
notes 
integers reals enumerated types atomic terms types tuples lists trees sets non atomic compound composed subterms types lower type structure 

independently conceived similar refinement operator showed weakly perfect 

holds exactly refutation instantiation case 

optimised threshold obtained method lachiche flach indicated general different threshold obtained fold cross validation 

www cs bris ac uk research machinelearning bc peter flach nicolas lachiche 

refinement operators weakly perfect 
proceedings th international workshop inductive logic programming pp 

springer verlag 
asker 

combining divide conquer separate conquer efficient effective rule induction 
proceedings th international workshop inductive logic programming pp 

springer verlag 
malerba 

sbc multi relational nave bayes classifier 
proceedings seventh european conference principles practice knowledge discovery databases pkdd pp 

springer verlag 
cussens 

parameter estimation stochastic logic programs 
machine learning 
date 

database systems 
addison wesley 
dehaspe 

maximum entropy modeling clausal constraints 
proceedings th international workshop inductive logic programming pp 

springer verlag 
dietterich lathrop lozano perez 

solving multiple instance problem rectangles 
artificial intelligence 
dol sak muggleton 

application inductive logic programming finite element mesh design 
muggleton ed inductive logic programming 
academic press 
domingos pazzani 

optimality simple bayesian classifier zero loss 
machine learning 
zeroski schulze kremer wettschereck blockeel 

structure elucidation nmr spectra inductive logic programming 
applied artificial intelligence 
special issue order knowledge discovery databases 
zeroski lavra 
eds 

relational data mining 
berlin springer verlag 
fawcett 

roc graphs notes practical considerations data mining researchers 
tech report hpl 
hp laboratories palo alto ca usa 
available www hpl hp com techreports hpl pdf 
flach giraud carrier lloyd 

strongly typed inductive concept learning 
proceedings th international conference inductive logic programming pp 

springer verlag 
flach lachiche 

bc order bayesian classifier 
proceedings th international workshop inductive logic programming pp 

springer verlag 
flach 

knowledge representation inductive learning 
symbolic quantitative approaches reasoning uncertainty ecsqaru pp 

springer verlag 
flach lachiche 
appear 
probabilistic reasoning terms 
linkoping electronic articles computer information science 
available www ida liu se ext epa cis html 
flach lachiche 

confirmation guided discovery order rules 
machine learning 
rtner lloyd flach 

kernels structured data 
proceedings th international conference inductive logic programming pp 

springer verlag 
getoor friedman koller pfeffer 

learning probabilistic relational models 
zeroski lavra eds relational data mining 
springer verlag 
flach 

hierarchical bayesian networks approach classification learning structured data 
proceedings progress track th international conference inductive logic programming pp 

department informatics university 
hand till 

simple generalisation area roc curve multiple class classification problems 
machine learning 
john langley 

estimating continuous distributions bayesian classifiers 
proceedings eleventh conference uncertainty artificial intelligence pp 

san mateo 
kersting de raedt 

bayesian logic programs 
proceedings progress track th international conference inductive logic programming pp 

kersting de raedt 

combining inductive logic programming bayesian networks 
proceedings th international conference inductive logic programming pp 

springer verlag 
de haas siebes 

aggregates 
proceedings th european conference principles data mining knowledge discovery pp 

springer verlag 
naive bayesian classification structured data kramer lavrac flach 

approaches relational data mining 
zeroski lavra eds relational data mining 
springer verlag 
wrobel 

transformation learning multirelational aggregation 
proceedings th international conference inductive logic programming pp 

springer verlag 
lachiche flach 

improving accuracy cost class multi class probabilistic classifiers roc curves 
proc 
th international conference machine learning icml pp 

aaai press 
lachiche flach 

bc true order bayesian classifier 
proceedings th international conference inductive logic programming pp 

springer verlag 
lavra flach 

extended transformation approach inductive logic programming 
acm transactions computational logic 
lavra flach 

rsd relational subgroup discovery order feature construction 
proceedings th international conference inductive logic programming pp 

springer verlag 
lloyd 

programming integrated functional logic language 
journal functional logic programming 
lloyd 

logic learning learning comprehensible theories structured data 
springer verlag 
lu getoor 

link classification 
proceedings twentieth international conference machine learning icml pp 

aaai press 
muggleton 
ed 

inductive logic programming 
academic press 
muggleton 

inverse entailment progol 
new generation computing special issue inductive logic programming 
muggleton 

stochastic logic programs 
de raedt ed advances inductive logic programming 
ios press 
muggleton de raedt 

inductive logic programming theory methods 
journal logic programming 
muggleton srinivasan king sternberg 

biochemical knowledge discovery inductive logic programming 
proceedings conference discovery science 
berlin springer verlag 
kononenko 

naive bayesian classifier ilp 
proceedings th international workshop inductive logic programming pp 

department computer science katholieke universiteit leuven 
rouveirol 

flattening saturation representation changes generalization 
machine learning 
sato kameya 

prism symbolic statistical modeling language 
proceedings fifteenth international joint conference artificial intelligence ijcai 
nagoya japan morgan kaufmann 
sato kameya 

parameter learning logic programs symbolic statistical modeling 
journal artificial intelligence research 
slattery craven 

combining statistical relational methods learning hypertext domains 
proceedings th international conference inductive logic programming pp 

springer verlag 
srinivasan muggleton king sternberg 

mutagenesis ilp experiments non determinate biological domain 
proceedings th international workshop inductive logic programming pp 

gesellschaft mathematik und mbh 
taskar segal koller 

probabilistic clustering relational data 
proceedings seventeenth international joint conference artificial intelligence ijcai pp 

