fundamenta informaticae ios press learning recursive theories normal ilp setting donato malerba dipartimento di informatica universit degli studi di bari malerba di 
induction recursive theories normal ilp setting difficult learning task complexity equivalent multiple predicate learning 
propose computational solutions relevant issues raised multiple predicate learning problem 
separate conquer search strategy adopted interleave learning clauses supplying predicates mutually recursive definitions 
novel generality order imposed search space clauses investigated order cope recursion suitable way 
consistency recovery performed reformulating current theory applying layering technique collapsed dependency graph 
proposed approach implemented ilp system atre tested laboratory sized real world data sets 
experimental results demonstrate atre able learn correct theories autonomously discover concept dependencies 
related works main differences approach discussed 
keywords machine learning inductive logic programming ilp learning recursive theories multiple predicate learning 

recursion fundamental concept computation models expressive power turing machines 
control flow mechanism available pure logic programming interesting functions implemented 
despite computational relevance recursion rarely handled inductive learning systems 
considerable debate actual usefulness learning recursive programs knowledge acquisition discovery applications 
common opinion real life concepts recursive definitions rare examples address correspondence dipartimento di informatica bari italy malerba learning recursive theories normal ilp setting ancestor natural language 
recursion considered useful programming examples main task synthesizing programs compute results generating programs classify observations instances concept 
literature possible find applications recursion proved helpful finite mesh design dynamical systems planning automated telephony 
cases pattern occurs repetitively training observation best way capture occurrence means recursive programs 
fact generally know advance recursion beneficial application domain justify general purpose learning techniques induce recursive non recursive programs 
usually explanations recursion idea definition concept formally expressed function procedure predicate formulated terms concept 
true explanations skip cases mutual recursion concepts mutually defined 
instance logic program odd succ succ odd zero provides mutually recursive definition odd numbers clause taken recursive 
example shows problem learning recursive programs related problem learning multiple concept definitions final analysis problems equivalent 
framed area inductive logic programming ilp uses computational logic representation formalism training observations induced hypotheses 
assume concepts learned represented means predicate symbols result learning process logical theory 
research ilp focused learning called normal strong explanatory ilp setting 
background theory bk set positive examples set negative examples normal ilp setting hypothesis sought bk bk words theory complete consistent respect set training examples bk 
framework inductive learning recursive logical theories equivalent learning multiple predicate definitions set examples 
renewed interest learning multiple predicate definitions justified employment ilp systems complex tasks induced investigate learning recursive theories 
important issues characterize multiple predicate learning problems 
de raedt shown learning multiple predicates difficult learning single predicate 
due fact having predicate definitions learn main difficulty multiple target predicates involved learning task related crucial discover dependencies learning predicate definitions 
wrong hypothesis predicate dependencies may affect learning results 
ii difficulty lies generality order multiple predicate learning 
ordering typically ilp subsumption sufficient guarantee completeness consistency learned definitions respect logical entailment 
malerba learning recursive theories normal ilp setting necessary consider stronger generality order consistent logical entailment class logical theories take account 
iii main problems multiple predicate learning explained terms important property normal ilp setting individual clauses consistent data conjunction need consistent data 
called non monotonicity property normal ilp setting states consistency preserved adding new clauses theory adding definite clauses definite program enlarges herbrand model lhm may cover negative examples 
instance clauses happy loves woman woman hag individually consistent respect bk loves daisy donald loves amelia hag amelia hag happy donald woman daisy woman happy logical theory bk happy 
consequence non monotonicity property clauses supplying predicates multiple definitions learned individually principle generated 
order overcome problems de raedt lavra proposed working nonmonotonic setting ilp clauses investigated independently interactions longer important 
setting produces properties examples rules generating examples 
instance clause loves happy expresses necessary sufficient condition happy generated nonmonotonic setting 
kind hypotheses predicting truth values facts 
interested predictions normal ilp setting appropriate 
studies problem learning restricted forms recursive theories normal ilp setting literature 
cohen proves positive negative results classes logic theories allowed include recursive clause 
cameron jones quinlan investigate heuristic method preventing infinite recursion single predicate definitions system foil 
de raedt propose algorithm named mpl performs greedy hill climbing search learning multiple predicate definitions 
giordana define bottom learning algorithm called rtl learns hierarchical non recursive theory complete consistent tries synthesize simple recursive theory aha developed system called derived matwin able learn recursive definitions consisting unit clause literals recursive clause 
progol guides top generalization process known bottom clause learn recursive clauses inverting implication function free definite clauses :10.1.1.31.1630
martin property confused properties alternative non monotonic ilp setting name due relation non monotonic reasoning 
malerba learning recursive theories normal ilp setting deal problem inducing mutually recursive predicate definitions clause learned theory extensionally covers positive examples rejects negative ones 
proposes algorithm assumptions correctly specializes recursive theory respect positive negative examples 
almquist suggests technique efficiently learning recursive definitions including base clause tail recursive clause random sample examples 
iterative bootstrap induction method learning recursive predicate definitions studied jorge brazdil 
adopt top approach learning recursive programs recursive clause 
extension mpl normal programs proposed fogel 
interactive multiple predicate learning system called logan literature 
thorough overview achievements inductive synthesis recursive logic programs 
new approach problem learning multiple dependent concepts proposed 
differs approaches aspects learning strategy generalization model strategy recover consistency property learned theory new clause added 
ideas implemented new version learning system atre full description reported 
organized follows 
section introduces issues related induction recursive logical theories 
section illustrates learning strategy adopted atre 
section devoted generalization model implementation sketched 
solution problem recovering non monotonic theories proposed section 
section proposed approach illustrated system atre characterized object centered representation training examples seed objects adoption classical negation 
experimental results application real world problem understanding multi page printed documents described section 
section concludes touches related discusses ideas 

problem specification henceforth term logical theory denote set definite clauses 
logical theory associated directed graph called dependency graph predicate node ii arc directed node node iff exists clause predicates literal occurring head body respectively 
dependency graph allows representing predicate dependencies predicate dependency defined follows definition 
predicate dependency predicate depends predicate theory iff exists clause occurs body ii exists clause predicate body depends 
easy notice direct indirect ii predicate dependencies represented arcs paths respectively 
correspondence may highlighted reformulating problem algebraic point view 
set predicates occurring logical theory direct predicate dependencies may mathematically depicted instances binary malerba learning recursive theories normal ilp setting relation 
binary relation rpd predicate dependencies transitive closure 
binary relation associated directed graph graph corresponding just dependency graph definition 
recursive theory logical theory recursive dependency graph contains cycle 
simple recursive theories cycles dependency graph go predicate simple recursive theories may contain recursive clauses express mutual recursion 
example dependency graph recursive theory 

recursive theory corresponding dependency graph predicates odd 
definition 
predicate definition logical theory predicate symbol 
definition set clauses head 
henceforth denote set predicates defined worthwhile notice 
instance theory odd odd zero succ 
quite general formulation learning task normal ilp setting defined follows set predicates 
pr learned set positive negative examples predicate pi background theory bk language hypotheses lh defines space hypotheses sh find possibly recursive logical theory sh defining predicates 
pr 
pr bk completeness property bk consistency property 
studies problem induction recursive theories concentrated learning simple recursive predicate definition single predicate definition including recursive clause 
case main issue guarantee learned definitions intensionally complete consistent 
learning simple recursive theories complicated necessary discover malerba learning recursive theories normal ilp setting right order predicates learned dependency graph theory 
order determined possibly statistical techniques problem learning single predicate definitions 
learning problem harder mutually recursive theories learning possibly recursive predicate definition interleaved learning ones 
way build interleaving parallel learning clauses different predicates 
fact strategy adopted atre 

learning strategy high level learning algorithm atre belongs family sequential covering conquer algorithms strategy learning clause time procedure learn rule removing covered examples iterating process remaining examples 
recursive theory built step step starting empty theory adding new clause step 
way obtain sequence theories 
ti ti 
tn ti ti theories sequence consistent respect training set 
denote lhm ti herbrand model theory ti stepwise construction theories requires lhm ti lhm ti 

addition clause theory augment herbrand model theory 
henceforth assume positive negative examples predicates learned represented ground atoms label 
examples ground atoms herbrand models sets ground atoms definition possible check example belongs lhm ti 

pos lhm ti neg lhm ti number positive negative examples lhm ti respectively 
guarantee pos lhm ti pos lhm ti 
neg lhm ti 
finite number steps theory complete consistent built 
theory correct classifies correctly examples training set established information generalization accuracy drawn training data 
fact selection best theory basis inductive bias embedded heuristic function explicitly expressed user learning system preference criterion 
order guarantee condition pos lhm ti pos lhm ti follow procedure adopted induce progol :10.1.1.31.1630
positive example predicate learned selected lhm ti 
example called seed 
space definite clauses general explored looking clause neg lhm ti 
way guarantee second condition holds 
added ti giving ti 
positive examples included lhm ti new seed selected process repeated 
relevant novelties learning strategy sketched embedded design procedure learn rule proposed 
implements parallel general specific general mutual recursion removed reformulating theory introducing additional new predicates 
explains additional degree complexity learning recursive theories respect inducing simple recursive theories 
malerba learning recursive theories normal ilp setting example driven search strategy space definite clauses ordering called generalized implication explained section 
search space forest search trees called specialization hierarchies number chosen seeds seed incomplete predicate definition kept 
search tree rooted unit clause directed arc node node exists obtained single refinement step 
downward refinement operator considered adds new literal clause 
forest processed parallel concurrent tasks number search trees 
task traverses specialization hierarchies top general specific synchronizes traversal tasks level 
initially clauses depth forest examined concurrently 
task free adopt search strategy decide clauses worth testing 
tested clauses consistent clauses depth considered 
search proceeds deeper deeper levels specialization hierarchies consistent clause 
task synchronization performed relevant clauses depth examined 
supervisor task decides search carry basis results returned concurrent tasks 
search stopped supervisor selects best consistent clause user preference criterion 
advantage strategy simplest consistent clauses independently predicates learned 
synchronization allows tasks save computational effort distribution consistent clauses levels different search trees uneven 
parallel exploration specialization hierarchies predicates odd shown 
suppose seeds odd selected 
partial view corresponding specialization hierarchies shown consistent clauses reported italics 
levels refer specialization step 
exploring hierarchies level level atre finds candidate clauses add initial empty theory 
simplest clause zero added base case recursion defined 
generate second clause new seeds considered say odd 
case consistent clauses generated system odd succ zero odd succ 
particular generation second clause possible partial definition numbers generated previous step 
clauses selected added theory zero 
noteworthy clauses entail positive example odd selection promising clause exclusively form search bias user preference criterion 
instance second clause preferred general partially learned theory see definitions generality order section 
critical choice concerning seeds 
system started odd clause added discussion properties operator scope 
thorough description upward downward refinement operators 
note recursive definitions recursive clause syntactically simpler base clause 
appear cause problems strategy 
proposed strategy allow discovery recursive clause base clause complexity malerba learning recursive theories normal ilp setting theory odd succ zero resulting compact correct theory odd numbers 
important explore specialization hierarchies seeds predicate 
training examples background knowledge represented sets ground atoms flattened representation ground clauses number candidate seeds high choice stochastic 
object centered representation adopted atre advantage reducing number candidate seeds partitioning set training examples objects 
object contains seeds generation base clauses recursive theory 
learning problems size object high parallel exploration candidate seeds feasible computational issue reported solved 
details atre object centered representation section 
comparison proposed search strategy respect systems attack problem multiple predicate learning see section 

parallel search predicates odd 
generalized implication model precise definition search space learn rule stage necessary 
follow usual practice established ilp defining generality order generalization model provides basis organizing search space 
clarifying generality order step reasoned design learning system 
generality orders reported literature known subsumption 
subsumption objects comparison clauses say additional malerba learning recursive theories normal ilp setting source knowledge theory considered 
true generality order implication implication 
comparing definite clauses generality order may lead incorrect results case recursive theories 
example 
instance previous example odd predicates clause odd succ logically entails correctly considered general odd succ succ succ take account theory succ odd zero interested generality order compare clauses relatively theory buntine generalized subsumption 
definition 
generalized subsumption definite clauses disjoint variables 
cn 
dm general generalized subsumption respect theory denoted substitution exists substitution grounds variables new constants occur happens 
dm 
cn 
test performed proving 
dm sld 
cn informally generalized subsumption requires heads refer predicate body background theory entail body example 
consider clauses succ succ succ succ zero theory zero substitution matches head substitution grounds variables new constants occur happens succ succ derived definite program 
zero 
succ 
succ 
zero 
malerba learning recursive theories normal ilp setting derivation reported 

sld resolution proving step number resolving clause general unifiers reported 
unfortunately generalized subsumption weak recursive theories 
example 
consider clauses odd succ odd succ succ succ zero theory succ odd zero substitution matches head consider grounding substitution goal clause succ derived definite program 
succ odd 
zero 
succ 
succ 
succ 
zero 
conclude informally order strong class theories organize theories strictly wider class logical entailment 
organization theories consistent logical entailment order weak 
malerba learning recursive theories normal ilp setting alternative generality order known relative generalization proposed plotkin 
base better known plotkin definition relative general generalization 
definition 
relative generalization set clauses set unit clauses conjunction atoms definite clause 
general derive definite clause resolution subsumes resolutions derivation involve clause buntine reports extension plotkin relative generalization case theory composed definite clauses necessarily unit clauses 
definition 
relative generalization definite clauses 
general relative generalization respect theory substitution exists 
theorem holds extended notion relative generalization theorem 
definite clauses logical theory 
general relative generalization respect occurs refutation demonstrating 
extended notion relative generalization inadequate 
side weak 
consider clauses theory reported example clear refutation demonstrating involves twice clause prove odd odd 
side notion strong goals 
taken literally lead consider unintuitive solutions conquer stage illustrated example 
example 
consider training set background knowledge bk incomplete theory built step 
selected seed 
desirable search space clauses general bk set clauses head aim induce predicate definition space contains instance clause 
space clauses relatively general bk includes solutions 
clause correct relatively general 
intuitive related target predicate solution coherent formulation learning problem defined background knowledge appear predicates definition induced 
consider solutions multiple predicate learning problems harder solve 
bk proven equivalent proving 
malerba learning recursive theories normal ilp setting restriction reflected new ordering named generalized implication 
definition 
generalized implication definite clauses 
general generalized implication respect theory denoted substitution exists head head 
generality order proved strictly stronger generalized subsumption condition definition entails condition 
dm 
cn definition 
view theorem generalized implication reduces generalized subsumption compares root refutation demonstrating 
properties hold 
proposition 
definite clauses theory 
generalized implication order satisfies properties reflexivity ii transitivity proof trivial empty substitution chosen 
ii definition substitution exists head head substitution exists head head 
substitution obtained composition 
head head head head 
follows 
proved semi decidability generalized implication termination generalized implication test guaranteed negative result overcome datalog clauses considered 
fact restriction function free clauses common ilp systems remove function symbols clauses put background knowledge techniques flattening 
transformation cause problems handling numeric data show section 

implementing generalized implication test naive implementation generalized implication test obtained testing head head computing herbrand models lhm lhm 
herbrand model substitution unifies heads implication monotone respect application substitution entails 
sufficient consider logical equivalence theorem stating proving equivalent proving 
malerba learning recursive theories normal ilp setting theory coincides fixed point immediate consequence operator compute herbrand models 
definition 
immediate consequence operator ground set ground instances clauses herbrand interpretation set ground atoms built alphabet immediate consequence operator computes interpretation 
bm ground 
bm shown sets definite clause infinite sequence interpretations computed iterative application immediate consequence operator 

converges lhm fixpoint 
notationally lhm 
convergence fixpoint finite number iterations guaranteed finiteness herbrand base datalog theories 
cause inefficiency naive evaluation ground facts lhm may computed times iterative application semi na evaluation partially overcomes redundancy partitioning layers 

lhm lhm lhm 
efficient methods proposed section reported literature 
developed context bottom evaluation queries deductive databases 
main objective proposal introducing important properties layered theories useful section recovering consistency theory 
worthwhile noticing computation lhm lhm equivalent iterative application immediate consequence operator starting interpretation lhm lhm 
way clauses 
longer considered computing logical consequences example 
theory bk 
suppose theory bk may partitioned follows 
lhm standard notation logic programming deductive databases immediate consequence operator tp logic program datalog program 
henceforth operator denoted order avoid confusion symbol logical theories 
malerba learning recursive theories normal ilp setting lhm lhm lhm lhm lhm lhm lhm lhm lhm lhm lhm notice classical iterative application immediate consequence operator ground atoms computed bk bk bk 
issues related problem finding layers recursive theory lhm lhm lhm lhm dealt 
difficulties arise dependency graph directed cyclic graph 
order remove cycles resort notion strongly connected component directed graph 
definition 
strongly connected component vertices directed graph said strongly connected directed path directed path 
proven directed graph decomposed acyclic graph strongly connected components time 
result decomposition called collapsed dependency graph 
definition 
collapsed dependency graph dependency graph logical theory collapsed dependency graph denoted directed acyclic graph dag obtained collapsing maximal strongly connected component single node 
nodes equivalence classes respect strong connectivity relation 
properties dag easy compute level predicate maximum distance terminal node terminal nodes nodes coming edges 
definition 
predicate level collapsed dependency graph logical theory level predicate level terminal node max level child logical theory layered basis level predicates 
definition 
layered theory collapsed dependency graph logical theory partitioned disjoint sets clauses 

called layers 
level 
malerba learning recursive theories normal ilp setting worthwhile observing technique layering logical theory induces total order layers 

example 
theory obtained union background knowledge bk theory consisting bk equivalence classes respect strong connectivity graph level level level level 
layers bk extracted 
proposition proved 
proposition 
logical theory partitioned layers ground atom predicate symbol 

lhm lhm lhm 
proof lhm 
fix point theorem definition immediate consequence operator ground clause exists 
am ground aj 

am ground 
proof induction layer want prove aj lhm lhm follows 
proof continues induction iteration step ground fact theory specifically lhm 
aj aj lhm 
construction layers follows aj ground atom predicate symbol aj 
induction hypothesis aj lhm 
malerba learning recursive theories normal ilp setting want prove aj lhm lhm lhm lhm follows 
proof continues induction step ground fact theory specifically lhm generally lhm lhm addition set clauses ground clauses lhm theory augment herbrand model theory 
construction layers follows aj ground atom predicate symbol aj aj aj lhm 
inductive hypotheses may say aj lhm lhm 
conclude lhm lhm 
lhm lhm 
particular lhm lhm obtained applying iteratively immediate consequence operator starting interpretation lhm lhm lhm 
monotone lhm lhm lhm 
lhm 
proposition states necessary sufficient condition ground atom predicate symbol lhm computed iteratively applying immediate consequence operator starting interpretation lhm 
proposition prove theorem herbrand model layered theory 
theorem 
theory partitioned layers criterion definition 
lhm lhm lhm 
proof 
partition lhm 
contains ground atoms predicate symbol 
proposition follows lhm lhm lhm 
lhm lhm lhm 
lhm lhm lhm lhm lhm lhm lhm 
lhm lhm 
lhm lhm obtained applying iteratively immediate consequence operator starting interpretation lhm lhm lhm 
monotone malerba learning recursive theories normal ilp setting lhm lhm lhm lhm 
lhm 
sum procedure layering theory provides semi naive way computing generalized implication test 
importance layering evident problem recovering consistency dealt see section 

consistency recovery strategy learning issue considered multiple predicate learning non monotonicity normal ilp setting individual clauses consistent data conjunction need consistent data 
algorithmic implications property may effectively illustrated means example 
example 
sets positive examples negative examples background knowledge respectively bk suppose consistent complete recursive theory learned conquer stages note bk bk explains positive examples bk 
incomplete learner generate new clause say consistent entails bk added recursive theory clause inconsistent bk 
ways remove inconsistency revising learned theory 
cheng de wolf describe complete method specializing logic theory respect sets positive negative examples 
method unfolding clause deletion subsumption 
operations applied clause added theory may involve clause inconsistent theory 
result clauses learned inductive steps totally changed removed 
theory revision approach coherent stepwise construction theory section re opens question validity clauses added previous steps 
alternative approach consists simple syntactic changes theory eventually creates new layers logical theory just stratification normal program creates new strata 
recovery strategy proposal follows approach layering technique illustrated section see definition 
example 
previous example possible define layers bk see malerba learning recursive theories normal ilp setting bk 
reformulating follows adding clauses new theory different layers 
bk 


easy see theory consistent 

collapsed dependency graph 
due theory restructuring number layers may increase proved proposition 
proposition 
consistent theory partitioned layers 

definite clause addition theory clause inconsistent 

pr predicate head 
theory obtained substituting occurrences predicate new predicate symbol theory 
tn 
tn number layers greater equal proof obviously addition inconsistent represented collapsed dependency graph 
level 
replaces level theory restructuring level 
level level 
equals maximum level node new theory predicate greater level number layers increases 
conversely level predicates depending increase breaking equivalence classes remain stable 
malerba learning recursive theories normal ilp setting pre conditions consistent respect consistent respect 
pr procedure verify global consistency partition theory 

partition contains instances 
negative example exists addition clause inconsistent predicate head new predicate symbol renaming return 
tn 
tn return post condition verify global consistency consistent respect lhm lhm 
procedure theory layering 
input induced theory new induced clause background knowledge bk set examples procedure returns new theory consistent explains examples explained example showing increase number layers breaking equivalence classes reported 
noteworthy assumption partially defining predicates 
pr learn addition clause inconsistent clause added words inconsistency may occur conditions hold contains dependence definition needs clauses explain positive examples 
procedure theory layering reported 
computational complexity partitioning step linear number vertices arcs collapsed dependency graph real computational burden procedure verify global consistency test negative example obviously supposed induced theory datalog program logical entailment computed terminating semi na procedure computation generalized implication see section 
procedure returns new theory consistent explains examples explained proved propositions 
proposition 
consistent theory partitioned layers 

definite clause consistent clause inconsistent added malerba learning recursive theories normal ilp setting 
pr predicate head 
theory obtained substituting occurrences new predicate symbol theory 
tn 
tn consistent 
proof definition lhm lhm 
tn 
tn 
affect 
tn 
tn layering effect lhm 
tn 
tn lhm lhm 
tn 
tn lhm lhm 
tn 
tn lhm 
tn 
tn simply renames adds clause 
tn 
tn 
equivalence holds lhm lhm 
tn 
tn lhm lhm lhm 
tn 
tn lhm new ground atoms 
tn generated basis lhm 
chaining equivalences lhm lhm lhm 
tn 
tn lhm 
suppose inconsistent ground atom lhm exists negative example training set 
obviously 
tn 
tn lhm negative examples instances predicates 
pr 
lhm lhm clause consistent lhm lhm contain negative examples 
contradiction follows 
corollary 
consistent theory partitioned layers 

definite clause addition theory clause inconsistent 

pr predicate head 
theory obtained substituting occurrences new predicate symbol 
tn 
tn 
lhm lhm 
tn 
tn 
proof follows immediately proof proposition lhm lhm lhm 
tn 
tn lhm lhm 
tn 
tn lhm lhm lhm 
set inclusion strict explains example previously explained short new theory obtained layering consistent consistent keeps original coverage noteworthy proposed approach consistency recovery new predicates invented aim accommodate previously acquired knowledge theory currently generated hypothesis clause 

atre system malerba learning recursive theories normal ilp setting atre multiple concept learning system solves problem set concepts 
kr learned set objects described language lo background knowledge bk described language language hypotheses lh defines space hypotheses sh user preference criterion pc find possibly recursive logical theory sh defining concepts 
cr complete consistent respect set observations satisfies preference criterion pc 
differences respect learning problem formulated section concept preference criterion replacement terms predicates examples words concepts objects respectively 
preference criterion required describe logical foundations learning procedure necessary deal problem selecting best theory satisfying completeness consistency properties 
second difference due atre representation formalism explained subsection 

representation issues atre basic component representation languages lo lh literal takes distinct forms 
tn alue simple literal 
tn set literal function symbols called descriptors ti si terms closed interval 
descriptors nominal linear ordering relation defined domain values 
particular ordering relation defined domain nominal descriptors appear simple literals 
contrary total ordering relation defined linear domains linear descriptors appear set literals 
examples literals color blue distance extension 
close true 
example shows lack predicate symbols representation languages adopted atre 
order literals represented fp true fp false respectively fp function symbol associated predicate means atre deal classical negation negation failure 
henceforth sake simplicity adopt usual notation fp true fp false respectively 
concept ki learned represented simple literal 
concepts sharing descriptor arity having different values define multi class problem imposes membership malerba learning recursive theories normal ilp setting training example exactly class positive examples class negative examples mutually exclusive classes 
instance application domain document image understanding reported section concepts logic type title logic type logic type author define class problem 
training examples logic type instances title author logic type instances logic types simultaneously 
training examples logic type title considered negative concepts logic type logic type author viceversa 
training examples logic type concept interested learning considered negative examples title author 
noteworthy multi class problems possible concept dependencies expressed recursive theories 
instance document image understanding domain clause learned logic type author top logic type title expresses dependence position block title position block author page layout 
concepts learned different descriptors typical multiple predicate learning problem concerning family domain mother true father true ancestor true flexibility formulation learning problem distinguishing characteristic system 
atre language observations lo object centered sense observations represented ground multiple head clauses called objects conjunction simple literals head 
instance object taken blocks world type blk type blk column pos blk hor pos blk ver top blk blk note multiple head clause semantically equivalent definite program type blk pos blk hor pos blk ver top blk blk type blk column pos blk hor pos blk ver top blk blk equivalent disjunctive clause type blk type blk column pos blk hor pos blk ver top blk blk comma head interpreted disjunction conjunction 
notion multiple head clauses atre adapts notion interpretation common relational data mining systems 
presents main advantages respect definite clauses better comprehensibility efficiency 
basically due fact clauses provide system compact description multiple properties predicted malerba learning recursive theories normal ilp setting complex objects 
second advantage possibility having unique representation known properties shared subset observations 
fact atre distinguishes objects examples 
said objects ground multiple head clauses interpretations uniquely identified object identifier oid 
examples described pairs oid literal head object indicated object identifier oid 
examples considered positive negative concept learned 
instance type blk positive example concept type negative example concept type column positive negative example concept stable true 
body example oid body oid body multiple head clause identified oid 
object identifiers define partitioning set training examples 
choice seeds separate parallel conquer search strategy efficient 
basic assumption atre object contains examples explained base clauses underlying recursive theory 
choosing seeds examples different concepts represented training object possible induce correct base clauses 
mutually recursive concept definitions generated base clauses added theory 
problems caused incomplete object descriptions violating assumption investigated require application abductive operators available current version system 
language hypotheses lh linked range restricted definite clauses simple set literals body simple literal head 
noteworthy atre deals numeric descriptors 
precisely ary function symbol xn values numerical domain atre produce hypotheses set literals xn numerical interval computed information theoretic criterion csl 
related contexts qualitative relational regression inductive logic programming learning numerical constraints inductive constraint logic programming 
updated review 
background knowledge defines relevant domain knowledge 
expressed language constraints language hypotheses 
example spatial background knowledge close distance states objects distance close 
representation languages atre fit ilp framework easy transform atre definite clauses datalog clauses extended built predicates 
transformation literals top true top false straightforward 
general simple literal 
tn alue transformed ary predicate 
tn alue set literal 
tn range range interval transformed 
tn relational operators built predicates 
transformation possible apply atre concepts properties developed standard order logic languages 
particular clause considered set literals definitions resolution subsumption clauses simple literals remain unchanged 
extension due presence set literals transformation introduces built negation removed replacing classical negation predicate new predicate 
malerba learning recursive theories normal ilp setting predicates 
case clause partitioned subsets literals ordinary predicates built predicates cb 
clause subsumes clause substitution exists set solutions constraints cb non empty set including set solutions constraints db 
instance clause cb subsumes clause db ground clause subsume clause set cb solutions empty 
observe resolution definite clauses expressed atre hypothesis language lh corresponds classical resolution principle heads simple literals 
consequently generalized implication definition section easily applied atre 

algorithmic issues main procedure atre shown 
system input set objects background knowledge set concepts learned preference criterion guide heuristic search space possible hypotheses 
illustrate algorithm consider input data table 
step generation inductive hypotheses saturation objects respect bk information implicit example background knowledge explicit procedure saturate objects 
example saturation involves addition literals logically entailed bk close zone zone close zone zone close zone zone close zone zone close zone zone close zone zone close zone zone close zone zone close zone zone 
initially positive negative examples pairs oid generated concept learned learned theory empty set concepts learned contains ki 
input data system generates positive examples downtown zone downtown zone positive examples residential zone residential zone negative examples equally distributed downtown zone downtown zone downtown zone downtown zone residential zone residential zone residential zone residential zone 
conquer stage performs general specific beam search generate set consistent linked range restricted clauses concepts learned 
seed associated specialization hierarchy 
seeds chosen textual order objects system 
ok object example uncovered concept ki ok taken generate seeds ki 
particular examples ki ok uncovered selected seeds possible specialization hierarchies concept 
ground literals body seed objects generalized 
particular generalization ground literal 
tn alue obtained turning distinct constants distinct variables malerba learning recursive theories normal ilp setting procedure learn recursive theories bk 
kn pc saturated saturate objects bk saturated generate positive negative examples 
kn learned kn repeat consistent clauses parallel conquer beam search learned pc find best clause consistent clauses pc consistent verify global consistent saturate objects saturated update examples learned pos example ki learned learned ki endif learned return 
atre main procedure 
table 
example input data main procedure objects downtown zone residential zone residential zone downtown zone downtown zone residential zone downtown zone downtown zone residential zone residential zone downtown zone residential zone zone high business activity zone close zone zone low business activity zone close zone zone adjacent zone zone zone low business activity zone low business activity zone close zone zone high business activity zone adjacent zone zone low business activity zone close zone zone low business activity zone close zone zone zone high business activity zone bk close adjacent close close concepts downtown true residential zone true pc minimize maximize number negative positive examples explained 
malerba learning recursive theories normal ilp setting replacing occurrences constant ti variable xi simple inverse substitution 
clause specialization performed adding new generalized seed literal preserves property clause restricting interval set literal body 
consistent range restricted clause put aside search stops consistent range restricted clauses determined 
example seeds generated unique object 
procedure parallel conquer beam search generates set consistent clauses minimum number defined user 
requiring generation consistent clause respect examples procedure returns set clauses downtown high business activity 
downtown adjacent 
downtown adjacent 
fact hypothesis space concept residential simultaneously explored consistent clauses concept downtown consistent clause residential discovered 
parallel conquer procedure stops number consistent clauses greater 
point best selected user preference criterion procedure find best clause 
default criterion maximization number positive examples covered minimization complexity clause represented number literals body 
example clauses selected 
addition consistent clause may lead augmented inconsistent theory atre applies layering technique explained section recover consistency procedure verify global 
difference procedure reported invoked atre main procedure set objects passed order reconstruct body examples selected clause re saturate object recursive clauses generated call procedure parallel conquer beam search 
continuing previous example literals added downtown zone downtown zone 
operation enables atre generate definition concept residential depends concept downtown 
procedure update examples tags positive examples explained current learned theory longer considered generation new clauses 
loop terminates positive examples tagged means learned theory complete consistent 
example downtown zone downtown zone tagged complete definition downtown true learned 
positive examples tagged procedure parallel conquer beam search re invoked returns clause residential close downtown low business activity 
re saturating object learned clauses possible generate recursive clause third iteration residential close residential low business activity 
sets clauses learned downtown high business activity residential close downtown low business activity residential close residential low business activity simple recursive theory 

computational complexity malerba learning recursive theories normal ilp setting generation consistent clauses requires exploration search space size finite increases exponentially number literals bodies selected seeds 
clauses specialization hierarchy seed example oid obtained adding set literals clause 
xn alue obtained turning constants variables 
literals specialization process generalizations literals body obtained turning constants variables possibly determining interval case linear descriptors number clauses body atre explores polynomially bounded portion space 
precisely step body clauses considered 
soon selected specialization step beam search 
second step selected hypothesis specialized body different ways 
general th step selected hypothesis specialized body different ways 
sum number generated clauses body body body body body analysis confirms efficiency system searching consistent clause number tested hypotheses linear beam search quadratic maximum number literals training object 
arity function symbols number variables learned clause affect cost search happens systems 
number specialization hierarchies equals number training examples worst conclude computational complexity procedure parallel conquer beam search polynomial number training examples beam search maximum number literals training object 
unfortunately analysis take account fact saturation objects may increase number literals training object 
worst case number exponential number constants body objects making upper bound computational complexity search exponential 

experimental results atre implemented prolog 
section show results multiple concept learning problems 
experiments refer domain family relations test mpl 
real world application document image understanding interrelated definitions logic components possible 
results concerning induction mutual recursive theory odd numbers application cognitive modeling reported available web site system 
atre applied geographical knowledge discovery main feature system tested application handling numerical attributes relations order context 
malerba learning recursive theories normal ilp setting 
domain family relations de raedt lavra defined class experiments domain family relations 
experiment aims learning definitions ancestor father mother complete set positive negative examples 
mpl negative examples generated close world assumption knowledge base contained ground atoms concerning predicates male female parent 
convenient representation atre single object positive negative examples ancestor father mother explicitly reported head instances male female parent reported body 
simple recursive theory learned mpl elegant ancestor parent father parent male mother parent female ancestor parent ancestor 
clauses reported order learned 
problem atre learns correct theory pc ghz different intuitive ancestor parent father ancestor male mother ancestor female ancestor ancestor ancestor father ancestor ancestor mother ancestor 
theory new predicate ancestor invented due consistency recovery 
account ancestor parent semantically equivalent interpretation theory clearer 
explanation result straightforward 
clauses generated atre ancestor parent father ancestor male mother ancestor female 
fact atre definitions father mother point learning process system know complete definition ancestor considers clauses father parent male mother parent female equivalent respectively 
atre discovers overgeneralization error new clause ancestor father ancestor added theory 
point system applies consistency recovering strategy invents new predicate ancestor 
noteworthy results obtained beam equal 
enlarging beam atre takes learn theory analogous induced mpl ancestor parent ancestor parent ancestor father parent male mother parent female 
malerba learning recursive theories normal ilp setting example suggests improvement system 
currently atre checks bk example concept father 
examples ancestor considered test inferred partial definition 
augmenting bk set oh positive examples ancestor available head object testing bk oh atre experiment positive negative examples ancestor input system 
reason modified test sooner atre generate clauses cover examples oh 
anticipate drawn generated clauses 
trick adopted lamma 
set positive negative examples incomplete explains consistency recovery strategy theory layering necessary 
second experiment family domain aims learning male ancestor female ancestor father mother 
training set complete 
mpl learned theory female ancestor mother male ancestor father female ancestor mother female ancestor male ancestor father female ancestor male ancestor father male ancestor female ancestor female ancestor male ancestor 
atre learned slightly different equally correct reformulation mpl theory male ancestor father female ancestor mother male ancestor male ancestor female ancestor male ancestor male ancestor male ancestor female ancestor female ancestor female ancestor female ancestor male ancestor female ancestor 
beam experiment learning time 
third experiment family domain aims learning father grandfather incomplete example set 
example set contains positive examples father grandfather 
negative examples complete grandfather incomplete father generated means rule father false parent false 
results reported mpl father parent grandfather male parent parent theory learned atre father parent grandfather male father father 
noteworthy atre generates general theory 
means atre prone error soon mother seen definition father wrong 
atre generated considered indistinguishable respect covered examples 
result simply influenced order equivalent clauses added set solutions 
malerba learning recursive theories normal ilp setting 
application document image understanding problem atre applied problem processing printed documents induced logical theories intelligent document processing system named wisdom see web site www di malerba wisdom 
henceforth specific problem learning rules document image understanding dealt 
main innovation respect previous automated discovery possible concept dependencies consideration documents 
document characterized different structures representing internal organization content layout geometrical structure logical structure 
associates content document hierarchy layout objects text lines vertical horizontal lines graphic photographic elements pages 
associates content document hierarchy logical objects sender receiver business letter title authors article 
term document image understanding denotes process mapping layout structure document corresponding logical structure 
document image understanding process assumption document images understood basis layout structures 
mapping layout structure logical structure represented set rules 
traditionally rules hand coded particular kinds document requiring human tuning effort 
propose application inductive learning techniques generate rules automatically set training examples 
user trainer asked label layout components set training documents logical meaning 
layout components clear logical meaning labeled 
document generates training examples number layout components 
application multi class learning problem 
concepts correspond distinct logical components recognized document 
defined different values taken descriptor logic type 
unlabelled layout objects act counterexamples concepts learned instances concept logic type undefined 
training document represented object atre different constants represent distinct layout components page 
description document page reported table lists descriptors represent page layout multi page document 
rules background knowledge order automatically associate information page order layout blocks 
page part page page intermediate part page intermediate page part page page part page long papers appeared january issue ieee transactions pattern analysis machine intelligence pami considered 
papers contain pages variable number layout components average 
total number layout components associated eleven logical labels affiliation author biography index term page number running head title 
remaining blocks considered instances logical component body interested learning recognition rules 
malerba learning recursive theories normal ilp setting table 
descriptors wisdom represent page layout multi page document descriptor domain page page nominal domain intermediate width block integer domain height block integer domain pos centre block integer domain pos centre block integer domain type block nominal domain text hor line image ver line graphic mixed part page block boolean domain true page contains block top block block boolean domain true block block right block block boolean domain true block right block alignment block block nominal domain left col right col middle col columns upper row lower row middle row rows 
layout page multi page document left partial description order logic language right malerba learning recursive theories normal ilp setting learning rules recognition semantically relevant layout components document raises issues concerning induction recursive theories 
simple mutual concept dependencies handled logical components refer part document document may related 
instance case papers published journals dependent clauses running head top left text page number running head top right text odd page number paragraph running head text express fact textual layout component top left right hand corner odd page running head textual layout component running head paragraph 
recursive clause paragraph paragraph text useful classify textual layout components upper paragraph 
document understanding kind application may benefit learning strategies multiple predicate learning 
running atre training set described theory table returned 
beam experiment learning time 
clauses reported order learned 
filtered candidate clauses evaluation step performed composite preference criterion minimizes number negative examples covered maximizes number positive examples covered minimizes cost clause 
theory contains concept dependencies see clauses plausible 
significance clauses evident looking number positive examples covered see fourth column 
particular atre discovers concept dependencies page number running head 
learned theory distinct layers affiliation author biography index term page number title layer running head 
order test predictive accuracy learned theory considered fourth long article published issue transactions training 
wisdom segmented fourteen pages article layout components instances concepts training set remaining instances concept body rule generated 
learned theory may commit omission commission errors 
particular performed sixteen omission errors blocks labeled correctly recognized theory fourteen commission errors possible commission errors worst case association block concepts correct 
omission errors due near misses 
instance title page recognized simply height range width values determined atre training phase see clause 
significant recovery omission errors obtained relaxing definition subsumption definite clauses 

discussion discussed proposed computational solutions relevant issues raised induction recursive theories normal ilp setting 
separate parallel conquer search malerba learning recursive theories normal ilp setting logic type running head height pos centre width logic type height width page intermediate logic type page number pos centre width logic type page number width 
pos centre logic type type image page intermediate logic type type graphic logic type page width logic type affiliation page pos centre logic type author page pos centre logic type biography page height logic type alignment middle col logic type type text height 
logic type index term height 
pos centre logic type title page height 
logic type width height logic type running head alignment upper row logic type page number logic type height logic type height top logic type width logic type height pos centre logic type top alignment lower row logic type logic type width top logic type total table 
theory learned document image understanding problem 
third column reports number additional training examples explained clause added theory 
fourth column reports number training examples explained clause 
malerba learning recursive theories normal ilp setting strategy adopted synchronize interleave learning clauses supplying predicates mutually recursive definitions 
novel generality order called generalized implication imposed search space clauses order cope recursion suitable way 
layering technique collapsed dependency graph investigated recover consistency partially learned theory 
ideas implemented ilp system atre characterized object centered representation training examples 
experimental results reported laboratory sized data data obtained processing multi page document images 
continue discussing related researches ideas developments 

related atre presents innovations respect previous works multiple predicate learning mpl extension normal logic programs mult icn rtl 
separate parallel conquer search strategy provides atre solution problem interleaving induction process distinct predicate definitions 
strategy generation clauses introduce mutual dependence predicate predicate possible recursion base clause 
atre operates shot way additional synthesis step rtl iterative bootstrap induction method jorge brazdil 
mpl solves interleaving problem performing greedy hill climbing search theories beam search single clause 
clauses generated means types refinement operators body head 
particular possible generate body clause specifying head 
subsequent refinement heads introduces possibly different predicates system chooses promising clause interestingness measure 
generation clauses forbidden possible generate recursive clause predicate base clause 
strategy adopted slightly different mpl 
high level follows classical separate conquer search strategy 
innovation conquer strategy refinement literal addition applied clauses different heads 
heuristics evaluating best refinement greedy conquer strategy laplace estimate 
unfortunately aspects unclear 
specialize literal say clauses heads different arity ordered 
second generation infinite recursive definitions prevented dealt 
completely different approach adopted mult icn 
high level conquer search strategy 
conquer stage system chooses predicate learned 
preference target predicates definition incomplete positive examples covered appear body previously learned clauses 
instance generated clause odd succ second step system tries learn definition 
words base clauses learned 
generalization model represents difference atre multiple predicate learning systems 
mpl adopts different generalization models search subsumption malerba learning recursive theories normal ilp setting learning single clause logical entailment learning theory 
distinct checks performed system learned clause local consistency completeness check subsumption extensional coverage global check logical entailment intensional coverage 
similar approach adopted mult icn 
pointed martin extensional coverage test lead generation non terminating extensionally valid theories zero odd succ succ odd defines odd numbers basis successors predecessors 
avoid problem mult icn introduces acceptability criterion clause lets user choose right rate acceptability 
mpl solves problem differently deleting globally incorrect irrelevant clauses added theory 
clause odd succ generated best clause added theory soon removed globally irrelevant positive examples odd numbers covered 
approach clear select clause remove globally irrelevant inconsistent 
care taken get infinite loops deleting clauses adding 
similarly progol mpl uses depth bounded interpreter check induced theory logically entails example 
depth bound allows system check consistency completeness properties case infinite recursive definitions 
explicitly stated similar depth bounded approach adopted logical entailment check properties completeness consistency clause 
systems adopt extensional subsumption coverage tests additional problem learning recursive clauses examples sparse 
problem evident atre learn correct definition odd numbers example set incomplete 
problems caused non monotonicity property normal ilp setting considered multiple predicate learning systems mult icn 
explained section crucial aspect multiple predicate learning problem 
progol instance properly considered multiple predicate learning system induce theories globally inconsistent 
mpl solves problem means clause deletion technique undoing previous may considerably increase learning time 
atre adopts layering technique invents new predicate addition clause theory interferes clause added theory 
shown section application layering technique prevent atre discovering equally correct theories simplified keeping minimum herbrand model theory restructuring 

current implementation atre optimal 
reasons time clause added theory specialization hierarchies reconstructed new set seeds may intersect set seeds explored previous step 
words possible system explores specialization hierarchies times memory done previous steps 
currently optimizing separate parallel conquer search strategy malerba learning recursive theories normal ilp setting exploring specialization hierarchies repeatedly learning process 
approach complex caching techniques effectiveness clear concepts learn recursively definable mutually dependent 
important aspect abundance candidate consistent clauses atre parallel conquer beam search procedure generate 
currently best clause respect user preference criterion selected case observed equivalent clauses exist preference criterion 
means atre blind choice equally clauses 
better selection strategies exist sets equivalent clauses recursive theory learning open question 
known issues sparse noisy training sets problem learning recursive theories harder 
integration abductive mechanisms inductive learning algorithms solution problems data sparseness class noise presence noise background knowledge requires probabilistic tests similar extension subsumption test proposed 

web site stand release atre system data sets experiments downloaded www di malerba software atre 

acknowledgments author grateful esposito david lorenzo interesting discussions suggestions concerning 
margherita berardi francesca assistance experiments 
author wishes michelangelo lynn devoted time reading manuscript 
aha ling matwin learning recursive relations randomly selected small training sets proc 
eleventh international conference machine learning 
apt logic programming handbook theoretical computer science van leeuwen ed vol 
elsevier amsterdam 
bergadano learning clauses tracing derivations proc 
fourth international workshop inductive logic programming wrobel ed vol 
gmd studien 
bergadano inductive logic programming machine learning software engineering mit press cambridge ma 
specialization recursive predicates machine learning ecml lavra wrobel eds vol 
lnai springer verlag berlin 
induction recursive transfer rules learning language logic cussens zeroski eds vol 
lnai springer verlag berlin 
malerba learning recursive theories normal ilp setting bratko applications machine learning knowledge synthesis new generation computing 
buntine generalised subsumption applications induction redundancy artificial intelligence 
cameron jones quinlan avoiding pitfalls learning recursive theories proc 
twelfth international joint conference artificial intelligence 
ceri gottlob tanca wanted know datalog ask ieee transactions knowledge data engineering 
cohen learnability restricted logic programs proc 
rd international workshop inductive logic programming muggleton ed 
de raedt interactive theory revision academic press london 
de raedt dehaspe clausal discovery machine learning journal 
de raedt lavra faces inductive logic programming methodologies intelligent systems komorowski ra eds vol 
lnai springer verlag 
de raedt lavra multiple predicate learning inductive logic programming settings journal pure applied logic 
de raedt lavra zeroski multiple predicate learning proc 
th international joint conference artificial intelligence 
zeroski bratko handling noise inductive logic programming proc 
second international workshop inductive logic programming institute new generation computing technology 
zeroski lavra relational data mining springer verlag berlin 
esposito malerba induction recursive theories normal ilp setting issues solutions inductive logic programming cussens frisch eds vol 
lnai springer verlag berlin 
esposito malerba machine learning intelligent processing printed documents journal intelligent information systems 
esposito malerba inductive learning numerical symbolic data integrated framework intelligent data analysis 
esposito semeraro multistrategy theory revision induction abduction inthelex machine learning journal 
inductive synthesis recursive logic programs achievements prospects journal logic programming special issue synthesis transformation analysis 
fogel normal programs multiple predicate learning inductive logic programming page ed vol 
lnai springer verlag 
gelfond lifschitz logic programs classical negation proc 
seventh international logic programming conference mit press cambridge 
giordana saitta learning simple recursive theories methodologies intelligent systems komorowski ra eds vol 
lnai springer verlag 
gottlob subsumption implication information processing letters 
malerba learning recursive theories normal ilp setting almquist generalization clauses ph thesis department computer systems sciences stockholm university royal institute technology stockholm sweden 
almquist efficient induction recursive definitions structural analysis advances inductive logic programming de raedt ed ios press amsterdam 
jorge brazdil architecture iterative learning recursive definitions advances inductive logic programming de raedt ed ios press amsterdam 
khardon learning take actions machine learning journal 
khardon learning horn expressions logan proc 
seventeenth international conference machine learning 
lamma mello milano integrating extensional intensional ilp systems abduction proc 
seventh international workshop logic program synthesis transformation 
matwin sub unification tool efficient induction recursive programs proc 
ninth international conference machine learning morgan kaufmann 
lavra zeroski inductive logic programming techniques applications ellis horwood chichester 
lavra zeroski bratko handling imperfect data inductive logic programming advances inductive logic programming de raedt ed ios press amsterdam 
van leeuwen graph algorithms vol 
handbook theoretical computer science elsevier amsterdam 
levi sirovich generalized graphs artificial intelligence 
lloyd foundations logic programming second edition springer verlag berlin 
lorenzo learning reason actions proc 
fourteenth european conference artificial intelligence horn ed ios press amsterdam 
malerba esposito lanza machine learning information extraction topographic maps geographic data mining knowledge discovery miller han eds taylor francis london 
malerba esposito learning recursive theories atre proc 
thirteenth european conference artificial intelligence prade ed john wiley sons chichester 
malerba esposito semeraro learning simple recursive theories ai ia advances artificial intelligence lenzerini ed vol 
lnai springer verlag 
malerba semeraro esposito multistrategy approach learning multiple dependent concepts machine learning statistics interface taylor eds john wiley sons new york 
martin valued framework induction general logic programs advances inductive logic programming de raedt ed ios press amsterdam 
michalski theory methodology inductive learning machine learning artificial intelligence approach michalski carbonell mitchell eds tioga publishing palo alto ca 
mitchell machine learning mcgraw hill 
malerba learning recursive theories normal ilp setting top induction recursive programs small number sparse examples advances inductive logic programming de raedt ed ios press amsterdam 
muggleton inductive logic programming academic press london 
muggleton inverting implication proceedings nd international workshop inductive logic programming muggleton furukawa eds 
muggleton inverse entailment progol new generation computing :10.1.1.31.1630
muggleton bryant theory completion inverse entailment inductive logic programming cussens frisch eds vol 
lnai springer verlag 
nagy seth prototype document image analysis system technical journals ieee computer 
cheng de wolf complete method program specialization unfolding proc 
twelfth european conference artificial intelligence 
cheng de wolf subsumption theorem inductive logic programming facts advances inductive logic programming de raedt ed ios press amsterdam 
cheng de wolf foundations inductive logic programming springer heidelberg 
pazzani kibler utility knowledge inductive learning machine learning journal 
plotkin note inductive generalization vol 
machine intelligence edinburgh university press edinburgh 
plotkin note inductive generalization vol 
machine intelligence edinburgh university press edinburgh 
ramakrishnan srivastava sudarshan rule ordering bottom fixpoint evaluation logic programs ieee transactions knowledge data engineering 
rouveirol flattening saturation representation changes generalization machine learning journal 
sommer approach theory restructuring extended machine learning ecml lavra wrobel eds vol 
lnai springer verlag 
sommer approach quantifying quality induced theories proc 
ijcai workshop machine learning comprehensibility nedellec ed 
toussaint schmid wysotzki recursive control rules planning proc 
session learning adapting ai planning las vegas 
van laer de raedt zeroski multi class problems discretization inductive logic programming proceedings th international symposium methodologies intelligent systems ismis ra eds vol 
lnai springer verlag 
ilp automated telephony inductive logic programming progress cussens frisch eds 
