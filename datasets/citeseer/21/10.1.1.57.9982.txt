feature construction game playing paul utgoff utgoff cs umass edu department computer science university massachusetts amherst ma build evaluation function game playing needs construct informative features enable accurate relative assessment game state 
chapter describes feature construction problem suggests directions dealing shortcomings state art 
essential ingredient game playing program ability approximate relative utility game states may encounter actual play look ahead search 
approximate program requires features measure strengths weaknesses position method combining feature values single number indicates rating state relative 
features needed difficult define evaluation input variables typical 
features needed search reach terminal positions back true payoffs 
state variables know input variables form base level representation state 
feature function state variables features 
particular state confronted choice successor states evaluates successor selects best value possible exception electing explore apparently suboptimal state 
addition may look ahead immediate successors presumably producing better estimate value node obtain looking ahead 
simplicity assume model domain modeling successor states possible 
strictly necessary represent successor state implicitly current state conjoined name action produce successor learning watkins dayan 
evaluation functions major aspects designing evaluation function 
processes interact necessarily occur fixed order 
needs 
create set features measure presence absence intrinsic properties state 
choose functional form model class maps various feature values scalar value 
provide game payoffs purpose inferring target values states encountered correct citation article copyright nova science publishers utgoff 

feature construction game playing pp 

kubat eds machines learn play games 
nova science publishers 
feature construction game playing 
select method adjusting parameters part functional form 
focus design aspects problem creating useful features 
large degree possible simplifying assumptions rely existing methods 
due interactions needs consider interest primarily feature construction 
example functional form linear combination particular set features 
training signal temporal difference learning sutton infer expected utility state 
adjust parameters functional form descend gradient error function respect adjustable parameters press flannery teukolsky vetterling freeman 
choices items may preferable settings determined context particular scheme feature construction 
purpose selecting best move accuracy important extent affects move selection 
may acceptable absolute assessment state flawed relative comparison values gives best value best move berliner utgoff clouse 
problem finding useful set features may somewhat simplified relative assessment account fundamental problem remains 
feature overlap critical design choice construct features overlap disjoint 
suppose boolean feature true set inputs similarly boolean feature true set inputs 
sets covered features intersect features overlap disjoint 
suppose corresponds color red corresponds shape square 
case natural assume features take values independently 
presence contributes evaluation presence contributes evaluation overlapping model joint presence contributes evaluation 
alternative model disjoint features combinations separate feature individual contribution 
example say disjoint features true time contribution evaluation sole contribution evaluation 
true evaluation common representation evaluation function disjoint features cellular lookup table tree structured lookup table breiman friedman olshen stone 
interest overlapping features 
compensate dependencies including higher order terms needed 
example evaluate include feature weight detect presence absence intrinsic property state evaluating boolean feature 
target functions true relative utility game playing typically highly irregular state variables 
hope turn combinatorics overlapping features advantage 
essential aspect feature applies set states share intrinsic property 
may case feature defined amount error coverage 
ultimate test feature game playing program achieve higher expected payoff feature berliner 
putting aside disjoint features worth noting othello produced practical hybrid approach 
othello common tables subsets feature construction game playing input variables output variable 
single layer features input space combine individual values linearly 
example rosenbloom edge tables represent possible edge configurations individually 
edge configuration indexes table associated weight stored 
equivalent treating edge boolean features exactly true time 
table stores associated weight contribute evaluation position 
table edges effect 
boolean variables 
boolean edge features included set features table 
bill lee mahajan extends edge table include neighboring squares 
logistello buro extends idea informative subsets instance space 
nonoverlapping features effective discriminating useful subsets instances 
suspect longer run useful able identify overlapping features afford discriminations 
save space importantly provide insight particular instance value 
constructing overlapping features devising understanding methods automatic feature construction longstanding research quest 
constructing features major developmental bottleneck building system high quality decisions 
continue study enhance ability automate process 
section briefly reviews state art 
broad categories methods constructing features discussed 
parameter tuning second higher order term expansion third quasi random methods fourth knowledge derivation 
parameter tuning popular method constructing features automatically layered feedforward artificial neural network layer hidden units suggested 
unit element computes simple nonlinear function sigmoid inputs 
treating output unit input units obtains network computing elements principle compute arbitrarily complicated function inputs 
power approach hidden units defined parametrically parameter values learned descending error surface respect adjustable parameters werbos rumelhart mcclelland 
error evaluation function feature construction game playing distributed hidden units updated reduce hidden unit feature error 
kind approach quite useful problems suffers drawbacks 
algorithm trapped local minimum descending error gradient applications local minimum may useful 
second algorithm slow requiring weeks months longer reach best performance level 
speed issue sure algorithm trapped local minimum 
main problem algorithm fail find features need achieve sufficient accuracy 
trapped local minimum feature definition settle local decision boundary useful boundary 
algorithm revise feature definition attempt introduce error temporarily algorithm designed minimize 
overcome repeatedly re engineer input variables carefully program learn adequately 
parameter adjustment hidden unit input weights fundamental aspect approach feature construction 
associated task determine network architecture 
hidden units shall shall units connected 
methods devised modifying network architecture learning 
adding deleting hidden units explicit part procedure having system builder implement static architecture 
despite appeal automating construction network topology problem local minimum gradient descent eliminated 
ash dynamic node creation algorithm dnc inserts new hidden unit network error asymptotes unacceptably high level 
hanson network tracks variance input weight splits unit highest variance input weight moving away moment 
similarly node splitting method jones detects weights hidden unit oscillating splits oscillatory unit 
fahlman lebiere cascade correlation method learns weights just single output unit 
stabilizes error high weights frozen new output unit created inputs existing frozen units 
frean algorithm finds class convex boundaries repeatedly adding new linear threshold units ltu way correct classification errors frozen 
reinforcement learning common set problem program agent learns single reward punishment 
suddarth caruana shown richer training signal greatly facilitates learning task 
example game provides just game value state information provides locations legal moves 
knowledge legal moves typically implicit problem making explicit part training signal agent learn 
powerful example assortment legal moves bears game value 
indicates generally learning features task may aid learning discussed 
higher order expansion construct feature conjunction subset boolean input variables 
empty conjunction true covers true input examples 
conjunction just input variable true input variable true example 
create feature distinct pair input variables 
generally produce terms increasingly higher order defining feature 
includes possible conjunctive feature construction game playing features represent evaluation function 
kind completeness appealing accurate function may require exponentially features making intractable general 
connective 
example exclusive produces walsh expansion duda hart 
expand selectively constructing just features terms predicts add accuracy evaluation function 
example consider elf algorithm utgoff precup 
input variables boolean means discrete valued variables continuous variables mapped boolean 
approximator starts general feature true inputs tries learn weight amounts approximating target evaluation function constant 
algorithm responds stream example value pairs adjusting weights reduce error pair encountered 
series corrections accumulates individual feature association errors input values 
weights stabilize reach locally optimal neighborhood utgoff elf constructs new feature specialization strongest error input association 
old feature new specialized feature able discriminate instances differ input variable interest enabling refinement evaluation function 
elf approximator problems tends bog training proceeds 
problems 
elf removes largest errors 
smaller error residuals occur difficult differentiate causes 
second new features constructed dimensionality problem rises requiring longer training periods weights stabilize 
second example algorithm expands selectively vu value unification algorithm utgoff 
series best searches algorithm repeatedly identifies feature covers largest subset training examples include correctly evaluated example 
conjunctive term defines subset adopted new feature 
useful weight associated new feature eliminate error example 
weight computed directly manner eliminates apparent error large subset examples covered new feature 
algorithm halts examples evaluate correctly 
unusual algorithm combining mechanics covering algorithms manipulation additive values needed produce evaluation 
reduces error concentrated manner guided global error measure 
find large feature sets quite quickly 
brittle relies searching space conjunctively defined features 
important lesson vu content sufficient number layers conjunctively defined features 
possible prove representational adequacy mean achieved best possible compression 
example vu variant compressed possible positions tic tac toe single layer conjunctive features 
discussed better 
series expansions generally unwieldy producing explosion features may useless 
attempt produce terms expansion selectively approaches eventually bog 
quasi random methods study genetic algorithms goldberg expect method feature recombination crossover mutation 
earlier attempts apply kind feature construction game playing approach ga non ga variants nearly elf algorithm 
error indicate new feature needed direct approach 
hoping identify intrinsic properties shared large number domain elements appears needs specialize methodically 
knowledge derivation adopts view knowledge important state evaluation entailed task definition start formal statement task domain attempt decompose useful measurable elements fawcett callan 
fawcett zenith system uses declarative theory defines problem solving state space move operators goal learner endeavors achieve 
system applies transformation operators synthesize features declarative knowledge 
zenith maps logical term clause numeric value computing number bindings logical expression match state 
zenith reconstructed accepted features othello constructed useful original feature humanly dubbed frontier directions 
levinson snyder morph system learned evaluation function game chess 
set features represented set patterns associated weight 
pattern abstraction portion state represented high level hand engineered pattern language attacking guarding relationships chess pieces pattern 
system produces pattern state move state move form explanation learning account differences 
directions constructing overlapping features primary goal develop methods enable automatic construction features evaluation function drive move selection 
stated outset system obtains feedback environment regarding utility various outcomes 
feedback system adjusts parameters functional form minimize evaluation error 
features constructed automatically manner avoids traps weaknesses described 
able decompose state space subsets share intrinsic properties 
subset concept needs circumscribed feature definition true elements subset false outside 
subsets overlap state may possess multiple properties simultaneously 
set features compact discriminating extent possible 
feature definitions quickly minimum human effort 
feature evaluate efficiently search expensive matching costs applied inputs 
ideally features intelligible humans strictly necessary 
sections discuss layered learning compression afforded individual computing elements systems supervised problem decomposition training feature compilation 
layered learning accepted concepts learned human existing concepts learned earlier 
humans ability create new knowledge old knowledge new experiences thinking 
efficient layer knowledge way 
feature construction game playing person need learn new concept principles 
disastrous approach respect efficiency learning survivability storage efficiency respect understanding particular elements knowledge relate 
remarkably approaches evaluation function learning attempt learn just layers features knowledge 
may motivated fact hidden layers features units features layer sufficient represent evaluation function 
sufficiency imply efficiency terms learning time space consumption 
implies efficiency terms layers 
consider simple analogous example propositional logic 
sentence requires binary operators layers evaluate logically equivalent sentence requires fifteen binary operators layers evaluate 
possible motivation minimizing number layers facilitate parameter adjustment scheme 
layers features model problem decomposition gradient descent layers 
back propagation error layered network model process learning layered knowledge time 
easy expect see humans case 
teach quantum mechanics 
humans build new concept old new concept different old 
curricula teachers parents help learn quickly arranging new knowledge palatable order accounting various dependencies known teacher student 
important lesson people learn exactly just described take new requires learning small amount go back fill background new require learning 
consider simple example game othello 
play able recognize available legal move players state advantageous minimize number legal moves opponent 
legal move exists square board bracketed span exists lines emanating compass directions square 
bracketed span exists starting square empty followed opponent discs followed player discs 
able recognize available bracketed span players state 
set possible bracketed spans forms feature layer set legal move squares forms second feature layer number moves available player forms third feature layer 
attempt capture knowledge fewer layers avail 
programs back propagation error learn just win loss disc differential evaluation function find feature decomposition 
programs find features somewhat correlated mobility find features legal moves bracketed spans 
programs expected learning layers features scratch 
people poor 
rules othello explain bracketed span order explain legal move 
feature define efficient 
day practice tesauro dating back decades samuel engineer set input variables enables layer learning algorithm learn evaluation function 
quite reasonable limited capabilities parameter adjustment learning algorithms 
amounts hand coding layers features need feature construction game playing table 
ltu spans direction empty black white learned ready learn task set program designer 
need move layer learning approaches 
hand coding required prior features input variables need learn extent possible 
setting learning program need set agent learn assortment related concepts features extended period 
suspect formulating algorithm construct sufficient set features automatically elusive decades fundamental reasons 
aiming feature layers counterproductive 
second expect program infer required knowledge represented various layers just outcomes task interest program designer 
simply unrealistic expect programs learn needed scratch 
vein learning task learning play game formulated impoverished manner outset 
example entire notion move availability hidden game mechanics implicit play 
quite different human play human illegal move opponent referee identifies 
expect learning program uncover facts related available legal moves list available moves 
able add appropriate inference rules kinds fixes merely change built mechanics game 
better treat concept move legality subconcept program learn 
discussed rules game state concept explicitly suggesting mastered independently tactics strategy game 
compression important question represent feature 
computing elements better set inputs need covered grouped feature definition 
consider problem representing possible bracketed spans emanate particular square othello board 
happens possible represent bracketed spans emanate direction just linear threshold unit ltu 
impossible represent ltu spans emanate different directions 
understand apparent curiosity consider ltu depicted numerically table 
example threshold assumed sum weights indicates presence span sum indicates absence span 
table square square bracketed span may emanate 
square see column empty see row contributing weight linear combination see cell entry meaning bracketed span possible determined rest pattern 
notice square contains black disc white disc contribution indicating bracketed span impossible 
square white black span sees weight white weights empty black 
square contains black disc span feature construction game playing weight causes sum positive regardless remaining values 
square empty span absent square holds white disc span possible 
considers various combinations sees sum positive just patterns span 
spans direction span exist time spans differing directions exist independently 
negative sum indicate lack span direction unfortunately indicate lack span direction 
large set possible spans noteworthy cluster groups 
ltu direction needs groups ninth represent disjunction 
hints teacher offer decomposition learner 
course learner rely solely teacher attempt cluster inputs possible 
teacher facilitates learning need know integrate supervised unsupervised compression useful sets inputs feature definitions 
linear threshold unit sigmoid threshold unit necessarily represent spans emanating square single direction 
need tune shape sigmoid explicitly 
known fitting data points threshold shaped function sigmoid fail find separating plan exist duda hart freeman 
poorly suited computing element feature definition complicate structure feature network slow learning 
systems need methodology constructing systems learn multitude layered features individually collectively 
notion training single output unit output layer needs give way idea train features means limited back propagation error 
needs able train element feature time 
returning othello example expert play depends move presence depends bracketed span presence 
system needs able accept supervised training various bracketed spans various move time 
capabilities complement displace methods developed layer learning 
notion layered learning may suggest layers learned time 
need case layered knowledge may advanced knowledge remains relatively 
furthermore inputs feature come existing feature layers may tidy 
define new state variables build new features various levels long development features 
need know layers features constructed modified incrementally 
decision making program agent able interact human expert teacher invent features correspond useful decompositions views task domain 
evaluation function learner automatically draw pool features learned time 
issues arise 
set surrounds data structures mechanisms making easy trainer offer features lessons comfortably high level 
structures need accessible evaluation function learner 
second set issues surrounds problem specifying generalized statements feature definitions 
stated way trainer want provide training examples particular feature times trainer wish provide definition feature 
definition high level need converted discussed feature construction game playing table 
application interface functions double probe char unit name create load char file name int save char file name save unit unit file fp save wire wire file fp set value char unit name double train value char unit name double unit lookup unit char name void create template char template name char input unit char input unit create unit function ft char name create wire char input unit name char output unit name double weight eval eval unit unit insert unit unit load units file fp load wires file fp sort units update layer nums unit set template values char template name double value double value section 
persistent network layered features begun data type training maintaining persistent layered feature memory 
developed described illustrates path longer term learning layered features 
input variable named symbolically 
new feature created giving symbolic name specifying type computing element uses specifying symbolic names inputs 
symbolic names underlying structures need known expert teacher external entity 
assume discussion feature accepts boolean input values produces boolean output value 
may desirable accept real valued input variables emphasis features intrinsic properties absent 
feature construction game playing table sketches incomplete set functions build manage train growing library interconnected features 
inputs feature state variables features set features input variables form network features maintained data type 
data structures loaded saved necessary feature definitions persist develop time variety applications 
example application teacher undertaken educate agent properties pair sided dice features associated trained dice available applications 
approach effecting longer term learning transfer 
evaluate feature specifies values input variables depends output value desired feature computed applying function feature computing element inputs recursively necessary 
train feature provides additionally target output value feature produce inputs 
update rule appropriate function computing element applied 
different program network different ways common particular program repeated interactions particular form 
example training program may provide sequence training instances refining definition particular feature 
expensive necessary symbolic associations lookups training event 
circumvent expense defines template series interactions 
associations just sequence 
values training instance loaded relevant elements network template pointers elements stored template defined 
needs forbid handle carefully recurrent structures 
shall avoid recurrent structures near term 
evaluation function learner input variable feature input 
values inputs single linear combination unit layer units customary approaches layer learning 
learning evaluation function connections existing features feature modeling evaluation created implicitly 
feature compilation little point training computing element empirically definition understood teacher communicated 
providing stream example value pairs able provide definition high level specification language 
needs procedure compiling specification data structures features represented internally 
feature compiler constructed purpose utgoff 
consider game tic tac toe 
learn data recognize ways forming marks line specify features relatively easily 
compiler accepts statements somewhat extended order logic converts specific features modeled simple computing elements 
computing element feature ltu 
main compilation mechanism presumption quantified statements enumerated domain quantified logic variable state variable finite small 
logic specification shows specify possible lines xs individually represent presence simplest winning configurations 
specification abstracts essence row 
compiler told domain quantified logic variable told quantified feature construction game playing constants define define define variables define define define constraints set set feature feature horizontal lines mod vertical lines diagonal lines feature feature exists 
specification row 
executable row feature construction game playing definitions lines 
compiler enumerates possibilities produces low level executable feature definitions evaluate quickly state 
shows features created automatically feature compiler specification row 
left hand boxes indicate input state variables corresponding presence absence empty square board 
top boxes indicate feature definitions 
label box formed copying text logic statement removing commas 
shaded box indicates feature computing element function non shaded box indicates function 
solid dot indicates positive connection input variable feature feature 
ltu features 
tic tac toe specify high level features needed play perfectly simple ply search 
decision making program enumerate choices select best 
specification includes needed high level features shown compiler creates features layers just seconds 
features verified database tic tac toe positions 
recall vu features single layer features 
compared possible positions layers achieve compression better 
strong evidence favor minimum number layers features 
particular approach took application form dynamic programming dijkstra form goal regression waldinger kind static analysis domain etzioni 
having features immediate wins generate features states immediate produced move 
kind feature bootstrapping leads features recognize positions won perfect play 
applications may construct features enable perfect step decision making 
goal provide practical means specifying useful features 
example chess specify feature true opponent piece pinned bishop rook queen 
feature enables learning accurate evaluation function just aspect position evaluation 
discussed begun look quantify logic variables atomic objects domain 
extended notion object composites objects 
example consider tic tac toe 
lines cells 
highly inefficient quantify logic variables cells test combinations form lines test condition holds line 
efficient define lines composite objects quantify finite domain lines 
decomposition compression intrinsic properties features sense expert teacher may efficient means decomposing state space purpose learning accurate evaluation function 
example described othello spans emanating particular square particular direction covered just linear threshold unit 
necessary separate element span 
important teacher know 
asking knowledge highly useful understand sets patterns compressible single computing element linear threshold unit 
need study 
feature construction game playing able experiment lines developed algorithm called plm finds piecewise linear fit examples class 
older algorithm duda augmented add new linear threshold units dynamically needed learning utgoff 
algorithm attractive properties investigating separately context classification algorithms 
plm algorithm applied database states tic tac toe 
state labeled member class win class draw class lose 
database labeled positions produced second brute force searcher assumed perfect play times 
states representation means represents player just moved 
fact just moved state representation changed changed removes need record player move 
approximately cpu hours dec alpha plm produced perfect class piecewise linear fit data 
class class class total features 
guarantee minimum number 
significant improvement features produced feature compiler described 
compared positions compression 
mean compiling bad idea better target set computing elements linear threshold units 
compiler ran seconds plm ran eighteen hours 
compiling directly ltu features produce stronger compression boolean features low cost 
consider example tic tac toe 
useful feature particular square empty remaining squares particular line hold empty 
single linear threshold element represent cases need recognize case individually boolean logic 
inspection class set examples covered informative 
instances covered ltu 
instance member class class evaluates value small margin 
finds ltu lines row 
cluster instances covered ltu certain commonalities 
ltu represents boundary boolean hypercube clustered instances represent hamming neighborhoods 
need know sets instances covered single ltu set cover set instances piecewise manner 
need identify implications teacher features decompose space 
plm finds single layer circumscribe convex region 
may target 
building useful layers features non convex regions describable 
important think decompositions comprehensively respect layers useful features 
discussion appears important investigate methods enable construction layers features 
follows observation useful features defined terms desire move layer learning systems 
humans able learn features 
learning provides small incremental advances knows 
learning layered features occur extended period time variety interactions agents important develop facilitating data type 
need feature construction game playing interface human separate program define features specifying symbolic name computing element symbolic names inputs 
features trained independently time leaving connected features network features 
features serve inputs element layer elements compute evaluation state 
addition facilitating supervised construction training features layered network useful study feature compilation methods convert high level feature specifications low level features feature sets represented underlying data structures 
preliminary version exploration done regarding powerful specification languages succinct target representations 
issues regarding task decomposition information compression need addressed 
consider proposing build long lived network feature definitions just pushing hand coding features programming process application program constructing training features 
surface may 
layers features offer significant representational advantages 
furthermore agent able benefit organized curriculum instruction interleaved learning experience 
quite common employ artificial neural networks problems layer features learned adequately 
artificial neural networks highly useful role perform inputs properly engineered 
trapped local minima fail find features provide improved evaluation accuracy 
need broader scope addressing problem constructing useful features evaluation function learning 
ideas proposed 
fruitful consider layers features supervised teaching features feature compilation problem decomposition unsupervised reorganization compression existing features 
acknowledgments supported national science foundation iri 
discussion icml workshop learning game playing helpful particularly donald michie remarks learning stages 
david built feature compiler 
margaret connell gang ding richard cochran provided helpful comments 
ash 

dynamic node creation backpropagation networks 
connection science 
berliner 

tree search algorithm best proof procedure 
artificial intelligence 
berliner 

search vs knowledge analysis domain games pp 

banerji eds artificial human intelligence 
new york elsevier science publishers 
breiman friedman olshen stone 

classification regression trees 
belmont ca wadsworth international group 
feature construction game playing buro 

simple features sophisticated evaluation functions 
international conference computers games 
tsukuba japan 
callan 

knowledge feature generation inductive learning 
doctoral dissertation department computer science university massachusetts amherst ma 
caruana 

multitask learning 
machine learning 
dijkstra 

discipline programming 
prentice hall 
duda 

pattern classification iteratively determined linear piecewise linear discriminant functions 
ieee transactions electronic computers ec 
duda hart 

pattern classification scene analysis 
new york wiley sons 
etzioni 

acquiring search control knowledge static analysis 
artificial intelligence 
fahlman lebiere 

cascade correlation architecture 
advances neural information processing systems 
fawcett tom 

feature discovery problem solving systems 
doctoral dissertation department computer science university massachusetts amherst ma 
frean 

algorithm method constructing training feedforward neural networks 
neural computation 
freeman 

neural networks algorithms applications programming techniques 
addison wesley 
goldberg 

genetic algorithms search optimization machine learning 
addison wesley 
hanson 

networks 
advances neural information processing systems 
lee mahajan 

pattern classification approach evaluation function learning 
artificial intelligence 
levinson snyder 

adaptive pattern oriented chess 
proceedings ninth national conference artificial intelligence pp 

anaheim ca mit press 
press flannery teukolsky vetterling 

numerical art scientific computing 
new york cambridge university press 
rosenbloom 

world championship level othello program 
artificial intelligence 
rumelhart mcclelland 

parallel distributed processing 
cambridge ma mit press 
feature construction game playing samuel 

studies machine learning game checkers pp 

feigenbaum feldman eds computers thought 
new york mcgraw hill 
suddarth holden 

symbolic neural systems hints developing complex systems 
international journal man machine studies 
utgoff 

feature compilation tr amherst ma university massachusetts computer science department 
sutton 

learning predict method temporal differences 
machine learning 
tesauro 

practical issues temporal difference learning 
machine learning 
utgoff 

perceptron trees case study hybrid concept representations 
connection science 
utgoff clouse 

kinds training information evaluation function learning 
proceedings ninth national conference artificial intelligence pp 
anaheim ca mit press 
utgoff precup 

constructive function approximation pp 

liu motoda eds feature extraction construction selection data mining perspective 
kluwer 
utgoff 

approximation value unification 
proceedings sixteenth international conference machine learning pp 

ljubljana morgan kaufmann 
waldinger 

achieving goals simultaneously pp 

michie eds machine intelligence 
new york wiley sons 
watkins dayan 

learning 
machine learning 
werbos 

advanced forecasting methods global crisis warning models intelligence 
general systems yearbook 
jones 

node splitting constructive algorithm feed forward neural networks 
advances neural information processing systems pp 

