object oriented concurrent programming yonezawa tokoro eds mit press 
concurrent object oriented programming act henry lieberman move forward generation artificial intelligence programs new languages developed meet demanding requirements applications 
artificial intelligence software require unprecedented flexibility including ability support multiple representations objects ability incrementally transparently replace objects new upward compatible versions 
advances computer architecture changing economics feasible machines large scale parallelism artificial intelligence require new ways thinking computation exploit parallelism effectively 
realize propose model computation notion actors active objects communicate message passing 
actors blur conventional distinction data procedures 
parallel computation actors called futures create concurrency dynamically allocating processing resources 
restrict concurrency constraining order events take place changeable local state 
actor philosophy illustrated description prototype actor interpreter act 
actors meet requirements organizing programs societies capabilities needed computational model construct models intelligent processes society cooperating individuals 
knowledge distributed members society centralized global data base 
member society knowledge appropriate functioning 
shall show act distributes knowledge entirely individual actors 
actor knowledge expertise required respond messages actors 
notion global state actor system 
society model member able communicate members society ask help inform progress 
act communication interaction actors uses message passing 
actor operated looked taken apart modified sending request actor perform operation 
members society able pursue different tasks parallel 
putting members society different approaches problem different pieces problem may speed solution enormously 
individuals able independently tasks society generated initiative 
show act allows high degree parallelism 
act uses object oriented message passing philosophy provide exceptionally clean mechanisms exploiting parallelism avoiding pitfalls timing errors 
ideas especially suited implementation large integrated network parallel processors lieberman 
different subgroups society able share common knowledge resources avoid duplicating common resources individual needs 
act uses technique delegating messages allows concentrating shared knowledge actors general behavior creating extensions actors idiosyncratic behavior suited specific situations 

actors active objects communicate message passing object oriented concurrent programming yonezawa tokoro eds mit press 
basic ideas actor model simple 
kind object actor 
including procedures data uniformly represented actors 
kind thing happens actor system event 
event happens target actor receives message 
messages actors 
think actor person communicates people society sending messages 
actors referring 
say 
actor know able fulfill role society 
actor system represented data structure components actor behavior receives message 
script actor program determines actor receives message 
message received script target message control 
script recognizes message decide accept message 
script doesn recognize message rejects 
actor knows actor delegate message script decides reject message 
proxy actor capable responding message basis general knowledge original recipient 
alternatively code script may decide explicitly delegate message actor 
actor know names actors communicate 
acquaintances actor local data variables associated actor 
think acquaintances telephone numbers people 
actor call send message actors providing knows telephone number 
actor starts set known telephone numbers acquire new ones lifetime 
say actor knows acquaintances 
simple framework general encompass kind computation imaginable 
shall discuss traditional concepts programming expressed actor model advantages doing 
shall model concrete describing act implemented lisp show fool lisp regarding ordinary data procedures active objects 

insist actor 
actor theory requires system functions coroutines processes numbers lists databases devices represented actors capable receiving messages 
may little dogmatic important practical benefits arise having totally actor oriented system 
radical systems simula birtwistle clu liskov lisp machine lisp moon weinreb generally provide special data type means constructing data types represent active objects defined user special message passing procedure operates special data type 
predefined components system numbers arrays procedures considered active objects 
non uniform system program know actor data type order message send operation 
program expecting system data type newly defined actor 
limits extensibility systems 
smalltalk goldberg robson language shares philosophy uniform representation objects 
actor system communication happens message passing thing important actor actor behaves receives message 
actor user just know messages actor responds actor responds message details specific storage formats may irrelevant user application 
relying actors message passing systems extensible 
extensibility ability add new behavior system modifying old system providing new behavior object oriented concurrent programming yonezawa tokoro eds mit press 
compatible 
actor system user may add new actor message passing behavior different internal implementation new actor appear identical old far users concerned 
extend system introducing new actor behavior superset behavior old actor 
respond new messages old didn long new actor behavior compatible old previous user tell difference 
conventional languages lisp tend weak introducing new data types 
conceptually new object introduced pre defined data objects lists 
user aware format list rewrite program format changes 
suppose wanted implement actor representing matrix numbers 
matrices accept messages access individual element indices invert multiply matrices print 
traditionally matrix represented dimensional array elements accessed indexing 
multiplication inversion functions worked array representation 
implement actor stores matrix form 
descriptions programs english avoid introducing details act syntax point 
important identifiers capitalized text indented correspond structure program 
create actor called array matrix 
acquaintance named element array dimensional array size matrix 
array matrix receive access message asking element look element element array 
suppose identity matrix efficiently representable procedure storing elements zeros ones 
create actor called 
identity matrix get access message indices equal return 
return 
alternatively suppose matrix database resides remote site 
message matrix actor result communication computer network retrieve 
user wouldn worry actual physical location data network protocols long elements appear needs 
plausible different data representation sparse matrix compact encode elements matrix list indices non zero elements contents elements zero 
matrix needs data structure procedure accessing elements representation 
different representations matrices may system implementing actors means users insensitive implementation decisions affect behavior 
users matrices access sending messages kinds matrices respond access messages identity matrix interchangeably array matrix 
calling program doesn know matrix represented data structure procedure 
conventional language introducing new representation usually means code users representation changed 
object oriented concurrent programming yonezawa tokoro eds mit press 
able define multiple representations new data types introduced user sense allow multiple representations built system data types 
possible user defined data type masquerade system data object number 
user designs new object obeys message passing protocol numbers programs designed operate system numbers new object 
ability extend built objects area radical languages clu scheme deficient 
matrix example desired treat certain matrices scalars done mathematics 
identity matrix represented matrix element diagonal entries zero represented constant act allow definition matrices respond messages scalars passing messages sent matrix diagonal element 

inventory messages eval match monolithic centralized interpreter act lisp 
act distributed interpreter consisting set predefined actors respond messages correspond actions conventional interpreter 
interpreter driven messages ask actors evaluate 
send eval messages eval function lisp code responding messages distributed system 
user define new kinds actors respond eval messages differently 
list defined respond eval considering element list target rest elements list message sending message target 
symbols respond eval looking values variables 
apply messages bear relationship eval messages eval function apply lisp 
actors defined handle eval apply message specially control evaluation arguments message replacing mechanisms macros maclisp 
decide evaluate arguments return actor receive eval message macros 
place lisp argument lists actor receiving message pattern incoming message matched 
pattern actors receive match messages ask object included match message satisfy description pattern 
match message includes environment matching result binding variables message parts 
pattern matching name messages matching object identifier pattern binds variable message test objects equality data type 
objects patterns match objects equal 
patterns match objects belonging certain class 
pattern matching break composite data structures extract pieces data separately 
list patterns pattern match objects lists recursively match element pattern element object 
new patterns defined creating new actors respond match messages 
pattern matching match messages constitutes kind distributed interpreter complementary eval 

equality eye fact actors defined behavior response messages important allows different implementations concept exist single system 
allowing multiple representations requires flexibility definition equality 
testing objects equality done sending actors equal messages asking willing consider equal objects 
matching relies equality tests 
different kind equality relation appears systems 
actors code handling object oriented concurrent programming yonezawa tokoro eds mit press 
equal messages actors equal mutual consent bitwise comparison storage formats 
suppose actors cartesian complex acquaintances real imaginary parts complex number 
polar complex numbers represented acquaintances angle magnitude number 
cartesian complex number able consider equal equivalent number 
define actor called cartesian complex number acquaintances real part imaginary part 
cartesian complex asked equal number ask actor equal message complex number 
says answer 
says ask real part call real part 
ask real part equal real part 
ask imaginary part equal imaginary part parts equal answer 
part different answer 
assume code polar complex number real imaginary parts angle magnitude 
cartesian complex number able furnish angle magnitude benefit actors polar complex number 
slightly unusual characteristic equality relation asymmetrical 
actor gets chance field message asking question order may different results practice happens 
symmetric way set example cartesian complex polar complex delegate messages general complex actor knowledge convert various representations reside 
equivalent type checking performed act messages 
data types act sense conventional typed languages pascal 
variables name objects type just lisp 
useful able ask actor kind actor help predict behavior compare actors 
cartesian complex number delegate messages proxy holds information common complex numbers turn delegate number actor 
cartesian complex answer asked complex number number 

continuations implement control structure functions message sending primitive act unidirectional 
target receives message script target complete control happens subsequently 
needs way sending request target actor receiving reply answer question asked 
bidirectional control structure functions subroutines conventional languages 
act mechanism implementing function call return control structure uses continuation actors 
continuation actor receives answer question encodes object oriented concurrent programming yonezawa tokoro eds mit press 
behavior necessary continue computation question answered 
continuation actor analogue return address subroutines abelson actor sends request message corresponding function call message includes component called reply continuation tells target send answer 
target decides furnish answer sends reply message corresponding returning function reply continuation received part request message 
answer included reply message 
lest reader worry writing requests replies explicitly burden user rest assured seldom necessary 
request reply messages automatically supplied act interpreter user writes code function call syntax lisp 
continuation actors usually freshly created request message sent 
replies usually sent directly actor request new actor sender creates receive answer 
important optimization argument function evaluated caller continuation passed creating new continuation 
allows called tail recursive calls action function definition call function efficient iteration 
nested function calls produce chain continuations knows continuation control stack lisp 
lifetime continuation may extend time reply message returned answer continuations stored conventional stack 
continuations arises communication parallel systems activity running concurrently may need wait condition true 
program store away continuation waiting activity wait condition true issue reply stored continuation resuming activity 
complaint continuations kind continuation represent behavior taken error condition encountered 
explicitly managing complaint continuation user set error handlers look error message decide take action delegate message general error handlers 

knowledge shared delegating messages actor receives message answer immediately basis local knowledge expertise delegates message actor called proxy 
delegating message passing buck 
actor originally receiving message call client tells proxy don know respond message respond 
client actors may share proxy actor proxies script 
general knowledge common actors may reside proxy specific knowledge client actor shares proxy 
avoids need duplicating common knowledge client actor 
delegation provides way incrementally extending behavior actor 
actors existing large system correct new application 
extension accomplished creating new client actor specifically mentions desired differences falls back behavior old actor proxy 
client actor gets crack responding messages catch new messages override old ones 
delegation replaces class subclass instance systems simula smalltalk lisp machine lisp 
provides similar capabilities sharing common knowledge objects delegation uses message passing low level built communications mechanism delegation allows flexibility 
delegation allows patterns communication objects sharing knowledge object oriented concurrent programming yonezawa tokoro eds mit press 
determined time message received object object created definition compiled 

existence actors lisp actor system keep getting caught infinite loop sending messages actors causing messages sent actors computation performed 
recursion actors messages primitive data types procedures needed 
implementation remain faithful theory says components system treated actors obey message passing protocol 
ideally actor machine deals actors right lowest level hardware 
create illusion actors machine doesn believe 
answer cheat cheating allowed long get caught 
ground rules implementation allowed violate actor model guaranteed invisible programmer 
simulation actors conventional hardware incurs certain cost overhead kept reasonable level prohibitive simplest operations 
cheating done improve efficiency 
long actor behaves message passing rules implementor free efficient procedures scenes accomplish behavior 
important provide smooth interface host language lisp 
lisp functions callable actor programs lisp data usable requiring explicit conversion different representation 
means build existing facilities lisp having duplicate actor language 
actor interpreter perform computation adding numbers 
numbers added primitive addition operation implementation language works machine representation numbers 
actors acquaintances actors turn know actors actor data structure terminate primitive data implementation language 
actors ability reply messages receive sending messages 
set actors called rock bottom actors allowed cheat actor model primitive data procedures implementation language 
representing number actor stored number script value number acquaintance represent number actor just machine representation number 
fixed number types implementation language known advance interpreter find script corresponding particular rock bottom actor looking table indexed type object 
actors explicitly stored scripts proxies call scripted actors 
implemented vector record structure dimensional array containing script proxy acquaintances 
implementation fast way able tell actor rock bottom actor scripted actor just looking 
position describe fundamental loop act interpreter works happens event occurs event consists target receiving message 
check see target actor rock bottom actor 
find script actor looking type actor table rock bottom scripts 
object oriented concurrent programming yonezawa tokoro eds mit press 
invoke script 
script may access target actor 
actor scripted actor extract script invoke 
script access acquaintances proxy stored actor 
script rejects message message delegated target proxy 
script causes new event new target new message 
new target message may come acquaintances target message actor newly created script special set scripts rock bottom scripts allowed directly operate actor sending messages 
code rock bottom scripts written implementation language scripts supplied initial system 
compiler may convert user written scripts rock bottom scripts efficiency 
illustrate relationship rock bottom actors scripted actors showing numbers act 
numbers rock bottom actors represented lisp numbers 
user may defined kinds number actors complex numbers infinite numbers may code receive equal messages 
number sent message recognized actor interpreter 
interpreter finds script corresponding lisp numbers invokes 
script numbers checks script number message sees answer definitely 
turns sends message number giving chance respond 
care taken avoid situation actors unfamiliar getting loop trying pass buck 
final problem concerns calling functions written implementation language act 
lisp functions require standard lisp objects arguments actors 
rock bottom message asks actor supply lisp object take place actor applying lisp functions 

actors accept messages asking identify conventional languages fixed set data types establish conventions data types input output communication human users 
act allows user introduce new data types time defining new actors need conventions typed printed 
course actor message handlers print special way helpful establish conventions printed representations actors fall back 
solution extension printing philosophy lisp 
lisp print function expected produce printed representation printed representation read back read function result object equal original object 
unread message asks actor return printed representation suitable reading back creating actor equal original 
printed representation form printed user screen printing primitives implementation language case lisp print function 
able read print arbitrary actors devise way interpose eval read print 
eval capable constructing actor whatsoever 
reader recognizes special escape character causes invoke eval expression return result read 
actor typed typing escape character followed expression evaluates desired actor 
object oriented concurrent programming yonezawa tokoro eds mit press 
convention print actor print starting read time eval character followed expression evaluates equivalent actor 
actors called plausible way print printing call function creates say create turtle arguments create turtle appropriate state components position heading pen 
ditch heuristic printing actors just show user sit proxy acquaintances usually information identify actor 

making decisions special care needed treatment conditionals 
conventional languages lisp conditional just compare result test true false objects language decide branch conditional execute 
want adhere policy allowing user defined actors appear system provided actor appear provide case result predicate conditional user defined actor 
act interpreter prepared send message value predicate decide proceed conditional 
message asks target considers true purposes making choice branches conditional 

thinking lots things getting confused part try accomplish goals parallel argue actor model appropriate way think parallel computation 
actors may actively sending receiving messages time actors inherently suited modelling parallel systems 
specific actors feel included programmer tool kit writing parallel programs 
show examples illustrating primitives 
futures actors represent values computed parallel processes 
created dynamically disappear longer needed 
actors may value concern feet computed parallel 
synchronization provided protect actors internal state timing errors caused interacting processes 
show primitives implemented act 
act implemented serial machine simulates kind parallelism occur real multiprocessor machine 
discussion implementation give concrete picture mechanisms involved show needed implementation real network parallel processors 

traditional techniques parallelism inadequate language allows parallelism provide way creating destroying parallel activities means communicating 
traditional techniques parallelism grown operating systems simulation share characteristics usually fixed number parallel processes created processes created programs running 
processes usually explicitly destroyed longer needed 
communication processes takes form assignment memory cells shared processes 
propose parallel processes represented actors celled futures baker hewitt 
futures created dynamically disappear garbage collection explicit deletion re longer needed 
communication processes takes place shared actors called protect internal state timing errors 
object oriented concurrent programming yonezawa tokoro eds mit press 

dynamic allocation processes parallels dynamic allocation storage act solves problem allocating processes extending lisp solution problem allocating storage 
languages fortran machine languages take position storage allocated statically advance time program runs 
inflexibility static storage allocation led lisp different view 
lisp cons storage magically appears need garbage collector magically recovers storage longer accessible 
computer finite number storage locations reality user pretend memory practically infinite 
futures actors represent parallel computations 
created needed inaccessible gets garbage collected lisp object 
number processes need bounded advance processes number real physical processors computer system automatically time shared 
user pretend processor resources practically infinite 
fortran procedures communicate assignment shared variables 
causes problems memory location shared users inadvertently user violating assumptions users memory contents 
lisp uses control structure function calls returns procedures communicating passing arguments resuming values 
process creating actor communicates process passing arguments process communicates creator resuming value 
discourage explicit deletion processes reason discourage explicit deletion storage 
users expecting results computed single process user allowed destroy process unexpectedly havoc user 

futures actors representing results parallel computations promise deliver value needed 
act primitive hurry returns actor immediately regardless long computation take 
hurry creates parallel process compute value may running resumed 
user may pass perform computations actions win overlapped computation value 
viewpoint user program actor indistinguishable value 
difference parallel machine computed quickly 
behavior actor arranged computation value completed act identically value 
running delay sender long computation run completion 
futures especially useful problem broken independent subgoals 
main problem requires subgoals solution goal pursued waiting finish solution problem faster allocating futures compute subgoal 
computation subgoal presumably take long time computation subgoals overlap procedure combining results 
know value returns really needed 
actor model easy way actor may value send message 
actor sends message require finish computing reply sent 
value requested ready caller wait finish getting answer 
finish answer away inside behaves identically answer passing incoming messages answer 
object oriented concurrent programming yonezawa tokoro eds mit press 
nice aspect futures construct automatically matches creation parallel processes synchronization results computed processes 
promotes structured parallel programs formalisms describe creation parallel processes synchronization independently 
property able transparently substitute actor whatsoever computing actor crucially dependent fact act object communication happens message passing 
done radical languages clu simula provision objects message passing don treat way 
value built data type numbers vectors place ordinary number vector appear 
futures act conjunction lisp list structure represent generator processes 
suppose procedure produces sequence possibilities procedure consumes overlap production new possibilities testing ones 
represent having producer come list possibilities consumer may pick test 
fine finite number possibilities consumer willing wait possibilities trying 
futures simply change producer create futures list possibilities creating list growing time possibilities consumed 
define producer possibilities 
return empty list 
possibilities remain create list computing possibility rest computing rest possibilities calling producer define consumer consuming list possibilities test possibility possibilities list call consumer rest possibilities list 
consumer list possibilities ordinary list producer produced entire list possibilities advance 
get parallelism having consumer create futures testing possibilities parallel 
machine sufficiently processors radical way introduce parallelism change interpreter evaluate arguments parallel 
making eager beaver evaluator require just simple change create evaluation argument function 
current implementation act require explicit specification futures processes bit expensive serial machine default create frequently 
futures powerful alternative data flow model proposed dennis dennis 
dataflow model arguments function computed parallel function applied arguments finished returning values 
say re trying compute sum factorial factorial factorial time consuming 
dataflow computations factorial function done parallel sum start computing factorial computations finish 
object oriented concurrent programming yonezawa tokoro eds mit press 
futures created arguments function done act evaluation arguments returns immediately actors 
function applied actors arguments waiting run completion 
value particular argument needed computation wait finish 
sum factorials example imagine factorials finished third returned 
act allows sum adding results factorial factorial soon return parallel computation factorial 

explicit deletion processes considered harmful notice operations futures don provide appear parallel formalisms 
way ask finished 
message violate property futures incoming message forces finish wrapping futures values completely transparent 
encourage writing time speed dependent programs 
way returned value 
continuing analogy list storage believe explicitly stopping destroying processes bad reason deleting pointers lists bad lisp 
deleting process somebody pointer just harmful deleting list pointer shared somebody 
safer deletion happen garbage collection system automatically delete object verified longer needed anybody 
don exclude possibility providing lower level operations examining destroying processes purposes debugging implementation routinely user programs 
safer way able decision processes finished act serializer primitives assure proper synchronization 

act implement futures 
receives message intended value cases depending computation running 
needs flag distinguish cases 
running sender wait computation finishes 
finishes sets flag remembers answer computation memory cell 
messages sent relayed stored answer 
define hurry creating evaluating form create cell initially says running 
create cell answer form eventually evaluate 
create process start computing value form send value form continuation finish 
get request check running cell 
true sender waits false 
pass message answer cell 
define finish receiving value form receive answer computation started hurry 
update running cell false object oriented concurrent programming yonezawa tokoro eds mit press 
indicating finished 
put value answer cell 
cause process commit suicide longer needed 

aren futures going terribly inefficient 
advocates conservative approaches parallelism criticize proposals grounds futures inefficient implement practice 
allocating processes dynamically garbage collecting cost simpler schemes machines presently designed 
analogy list structure experience shown benefits dynamic storage allocation worth cost garbage collection 
trends hardware design moving designs computers small processors single large 
think challenge designing languages machines near come trying effective massive parallelism excessively clever conserve processor resources 
source wasted processor time comes processes running processor time longer needed reclaimed garbage collector 
analogous fact lisp storage unavailable time inaccessible time reclaimed garbage collector 
cost minimized smart incremental real time garbage collector processes henry baker proposed lieberman hewitt 
intend processes cheap easy create basic operation system just message passing 
taken care see process doesn tremendous amount state information machinery associated 
state process completely described target actor message actor continuation actors 
information saved process safely interrupted may wait condition happen processes running resumed 
processes mobile 
easy move process processor time processes single processor 
multiple processor systems may need dynamic load balancing time sharing conceptual processes physical processors 

needed protect state changeable actors class errors arise parallel programming don show sequential programming timing errors 
timing errors occur process looks state actor takes action implicit assumption state remains unchanged process modifies state invalidating data 
timing errors possible parallel programs changeable actors incorrectly 
actor changeable message sent different occasions result different answers 
protect misuse actors changeable state actors modify directly 
actors changeable state sent messages requesting state change 
actor receives state change requests insure state change operation completes outside interference request handled 
facility provided actor called time 
time kind serializes actor restricts parallelism forcing certain events happen serially 
time creates new actors protected process may actor time 
time actor holds state set state variables defined locally inaccessible outside 
script receiving messages result receiving message may decide change state 
message received object oriented concurrent programming yonezawa tokoro eds mit press 
locked message handled possibly state changed unlocked receive message 
time actor embodies basic concept hoare monitor idea hoare 
time advantage allows creating protected actors dynamically protecting lexically scoped block procedures variables 
actors created time class citizens 
may created interactively time program passed arguments returned values manner identical actor 

guardians complex synchronization time kinds synchronization possible achieve simply time 
time property reply incoming message possession released message different process accepted 
bit control reply sent useful 
reply delayed message process gives go ahead signal 
response message desired cause state change release possession await messages replying time 
imagine computer dating service receives requests parallel customers 
customer sends message dating service indicating kind person looking get reply dating service name ideal mate 
dating service maintains file people matches people interests 
dating service win able fill request immediately matching new request file 
request win join file filled subsequent customer 
dating service represented actor file people part state 
incoming request filled right away file people updated 
possession dating service actor released receive new customers reply original customer don know ideal mate going 
actor guardian provides dimension control synchronization processes takes place 
message replied immediately target actor save away means necessary reply continue receiving messages perform reply conditions right 
guardian actor notion continuations 
continuation encodes necessary continue computation reply guardian remember continuation reply 
guardian time continuation messages sent explicit give guardian control reply continuation may occur 
time easily implemented terms guardian 
code computer dating service 
define computer dating service create guardian actor internal state variable file people 
computer dating service get message lonely heart questionnaire help find ideal mate check see file people matches questionnaire 
reply lonely heart name ideal mate reply ideal mate name lonely heart 
enter lonely heart file people object oriented concurrent programming yonezawa tokoro eds mit press 
wait request lonely heart 
really happens implementation process attempts guardian actor 
actor waiting line associated 
messages coming line wait turn come served order 
guardian immediately available process sent message wait going sleep turn line comes guardian unlocked 
message sent sender way knowing message delayed 
message may change internal state actor guardian 
define guardian protecting resource internal state guardian waiting line memory cell saying resource locked initially false 
guardian get message locked sender wait waiting line locked sender front waiting line 
set locked flag true 
send resource incoming message reply continuation message resource send reply message 
resource update internal state result message 
set locked flag false letting process waiting line 

waiting rooms advantages busy waiting situations implementing parallel facilities act require process wait condition true 
message received finishes computing sender wait computation finish 
message received guardian locked sender wait guardian unlocked sender turn queue arrives 
message received actor provides input device terminal disk input requested may available requesting process wait time input appears 
way implement behavior busy waiting repeatedly testing condition true 
busy waiting bad idea subject needless deadlock 
condition true false possible condition won checked time true 
process waiting depend action release failing detect release condition process cause system containing processes grind halt 
disadvantage busy waiting repeated checking conditions wastes time 
preferable technique implementing wait operations waiting rooms 
people try visit time sitting waiting room listening reading magazines ready see proceed 
time delay caused waiting room interaction unaffected fact busy 
waiting rooms lists processes waiting condition happen 
message sent actor wants cause sender wait places sending process object oriented concurrent programming yonezawa tokoro eds mit press 
waiting room including sender continuation contains information necessary reply sender 
condition true everybody waiting condition waiting room receives reply 
waiting rooms introduce problem garbage collection 
order actor waiting room wake waiting process know pointer process 
reason process held requested isn immediately available process really longer relevant 
room pointer protects process garbage collection 
waiting rooms implemented weak pointers special kind pointer doesn protect contents garbage collection lieberman hewitt 

race parallel generalization lisp list structure creating ordered sequence objects lisp uses elegant concept list structure created primitive cons 
creating sequences objects computed parallel ordered time completion introduce actor called race 
race convenient way collecting results parallel computations result available soon possible 
cons produces lists containing elements order cons 
race starts futures computing elements parallel 
returns list contains values elements order finished computing 
lists constructed race respond messages produced cons indistinguishable ordinary serial lists far program uses concerned 
ask rest car cdr list determined won race process sent message waits outcome race known gets answer 
just happens send message finished computing value 
race idea similar ferns friedman wise friedman wise 
race easily implement parallel version helpful want start heuristics solving problem accept result heuristic succeed solving problem 
parallel starts evaluating set expressions parallel returns evaluates true returns false expressions true 
just create race list elements evaluated disjunct expressions 
searches disjuncts concurrently returns list results 
simple serial procedure runs list resuming true result false get list finding true result 
evaluations going true result appears inaccessible processes garbage collected 
don need explicitly rest disjuncts 
define parallel set disjuncts start race list evaluating parallel evaluate disjuncts 
examine results come back examine disjuncts 
define evaluate disjuncts set disjuncts set empty return empty list 
break disjuncts disjuncts rest disjuncts 
start race testing disjunct evaluates true doing evaluate disjuncts rest disjuncts list 
object oriented concurrent programming yonezawa tokoro eds mit press 
define examine disjuncts list clauses list empty return false 
split result rest results 
rest result true return value parallel 
examine disjuncts rest results illustration race consider problem merging sequence results computed parallel processes 
lists constructed race appear parallel merge form list containing elements lists order completion 
element merged list appears race elements list 
define merge lists list list return race element list result merge lists list rest list 
implementation race bit tricky motivated trying keep race analogous cons 
race immediately starts futures computing rest 
outcome race depends finishes 
serializer receive results futures deliver crosses finish line 
look easy part element finishes rest finishes 
time race actor reply rest messages sent 
gets message reply value argument race actor won race 
gets rest message reply computing second argument ho race may running 
difficult case rest finishes 
trivial case occurs rest returns empty list 
race rest empty produce list element just cons rest empty 
value rest isn empty assume list trick get case list produced race 
ask list element 
list produced race delivers fastest element contains 
element element race list node constructed 
running race remaining elements list produce rest final race list 
computation element appears farther list appears closer front list front changing places elements computed 
define race form rest form create futures evaluating form rest form 
return whichever finishes wins rest wins 
define wins finishes return list value rest rest object oriented concurrent programming yonezawa tokoro eds mit press 
may running 
rest wins helping race rest finishes look value rest 
empty wait returns return list 
empty return list list returned rest rest race value returned rest list returned rest 

previous acknowledgments carl hewitt originally developed notion actor guided development actor theory implementation inception 
owe special group worked previous projects implement actors including marilyn shrobe todd richard steiger russell atkinson brian smith peter bishop roger hale 
act distant ancestors languages simula lisp 
simula language tried explicitly support object oriented programming birtwistle 
traditional lisp provide direct support objects messages lisp flexibility extensibility allowed ai community experiment programming styles capture actor philosophy moon moon 
alan kay smalltalk replaced simula algol base foundation completely built notion objects messages goldberg robson smalltalk closest system sharing radical approach building totally object oriented language 
smalltalk follows simula coroutines simulate parallelism 
smalltalk retains class mechanism simula sharing knowledge delegating messages 
kenneth kahn developed actor language called director extension lisp kahn kahn 
director treat actor quasi parallel developed extensive dynamic graphics facilities means compiling actors lisp 
mechanism delegation strongly influenced director 
guy steele gerald sussman implemented dialect lisp called scheme compromises traditional lisp actors abelson 
active objects implemented lisp functions message passing performed function call scheme built data types numbers symbols lists active objects sense functions 
sussman steele contributed understanding issues continuation control structure compilation 
daniel friedman david wise modified lisp interpreter uses delayed control structure lisp cons primitive implements list structure parallel evaluation elements synchronization race 
wise friedman wise 
extend jon white richard greenblatt helpful discussion critical systems programming issues 
giuseppe attardi maria simi luc steels kenneth kahn carl hewitt william daniel friedman david wise dave robson gerald barber dan david akinori yonezawa helpful comments suggestion earlier drafts 
object oriented concurrent programming yonezawa tokoro eds mit press 
abelson abelson revised revised report scheme technical report mit artificial intelligence laboratory 
abelson abelson computer medium exploring mathematics mit press cambridge ma 
baker baker actor systems real time computation technical report mit laboratory computer science 
baker baker list processing real time serial computer communications acm april 
baker hewitt baker hewitt incremental garbage collection processes proc 
conference ai programming languages rochester ny 
birtwistle birtwistle dahl simula van nostrand reinhold new york 
borning borning object oriented system building simulations constraints proc 

dennis dennis varieties data flow computers proc 
st international conference distributed computing huntsville alabama 
friedman wise friedman wise cons eval arguments technical report indiana university 
friedman wise friedman wise nondeterministic constructor applicative programming proc 
conference principles programming languages acm sigplan 
goldberg robson goldberg robson smalltalk language implementation addison wesley reading ma 
hewitt hewitt universal modular actor formalism artificial intelligence proc 

hewitt hewitt viewing control structures patterns passing messages artificial intelligence mit perspective winston brown eds mit press cambridge ma 
hewitt hewitt attardi lieberman security modularity message passing proc st conference distributed computing huntsville alabama 
hoare hoare monitors operating system structuring concept communications acm october 
kahn kahn dynamic graphics quasi parallelism proc 
acm siggraph conference atlanta 
kahn kahn creation computer animation story descriptions 
kahn kahn program society 
proc aisb conference 
krasner krasner 
ed smalltalk bits history words advice addison wesley reading ma 
object oriented concurrent programming yonezawa tokoro eds mit press 
lesser erman lesser erman retrospective view hearsay ii architecture proc 

lieberman lieberman tv turtle logo graphics system raster displays proc 
acm siggraph sigplan symposium graphics languages miami 
lieberman lieberman object oriented simulator proc 
aaai washington august 
lieberman hewitt lieberman hewitt real time garbage collector life times objects communications acm vol 
june 
liskov liskov snyder atkinson js 
schaffert abstraction mechanism clu communications acm vol 
august 
minsky minsky society mind basic books new york moon moon maclisp manual mit laboratory computer science 
moon moon weinreb lisp machine manual symbolics mit 
papers papert basic books new york 
steels steels reasoning modeled society communicating experts technical report mit artificial intelligence laboratory june 
