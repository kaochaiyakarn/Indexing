ucpop sound complete partial order planner adl scott penberthy ibm watson research center box yorktown heights ny jsp watson ibm com daniel weld department computer science engineering university washington seattle wa weld cs washington edu describe ucpop partial order planning algorithm handles subset pednault adl action representation 
particular ucpop operates actions conditional effects universally quantified preconditions effects universally quantified goals 
prove ucpop sound complete representation describe practical implementation succeeds pednault mcdermott examples including infamous yale stacking problem mcdermott 
investigation techniques reasoning actions plans split camps 
camp looked formal characterizations languages describing change attempted build actual planners losing precise understanding programs forest pragmatic choices 
researchers described complete algorithms rigorously approaches suffer liabilities 
ffl planners handle restrictive strips representation tweak chapman snlp mcallester rosenblitt ffl planners represent plans totally ordered sequences actions rosenschein kautz planners mcdermott 
consensus suggests partial order planning preferable total order approaches minton barrett barrett weld void space rigorous planners 
mcdermott clearly believed quest doomed want completeness theorem planner better build linear planner 
show mcdermott overly pessimistic 
describe ucpop partial order planner step descriptions include conditional effects universal quantification 
universal existential quantification permitted step preconditions effect preconditions effect postconditions goals 
ucpop assumes closed world actions add delete fixed universe objects allow domain axioms disjunctive preconditions considerably expressive rigorous partial order planners 
ucpop algorithm starts initial dummy plan consists solely start step effects encode initial conditions goal step preconditions encode goals 
ucpop attempts complete initial plan adding new steps constraints preconditions guaranteed satisfied 
main loop types choices supporting open preconditions resolving threats ffl ucpop satisfied precondition open step effects possibly constrained unify desired proposition considered 
ucpop chooses effect nondeterministically adds causal link mcallester rosenblitt plan record choice 
ffl third step called threat possibly interfere precondition supported causal link ucpop nondeterministically chooses method resolve threat reordering steps plan posting additional subgoals adding new equality constraints 
name pronounce yoo see pop anagram capitalized letters 
fact domain dependent information guide choice 
backtracking ensures choices eventually considered 
ucpop successfully created protected causal link goal plan halts returns solution 
money home wisdom adopting example pednault suppose single briefcase wanted move objects 
pednault formalizes simple domain operators movb moving briefcase contents putting item briefcase removing items briefcase 
version operators seen precond effects precond effects movb precond effects demonstrate ucpop generates plans actions 
algorithm nondeterministic assume convenient order practice backtracking required find correct plan 
example begins items briefcase dictionary start home briefcase containing 
goal home dictionary office 
initial plan depicted follows home goal start office office diagram italics represent open preconditions treated subgoals 
preconditions open satisfied display step requires 
steps instances operators written typeface 
arrows steps denote causal links showing subgoals step satisfied 
ucpop selects goal office satisfying creating new movb office step making causal link goal step 
office movb office goal office home start creates subgoal omitted links simplicity 
ucpop selects subgoal office creating link step previous goal 
adds subgoal movb office step start goal movb office office office home goal selected home 
home ucpop fact satisfy final goal ucpop records decision adding link start shown start goal movb office office office home dashed link denotes threat movb step left briefcase moving briefcase negate initial condition home jeopardize supported goal 
ucpop eliminates threat posting subgoal turn satisfied adding plan start home office office movb office goal ucpop selects subgoal creates causal link new step ensuring dictionary briefcase briefcase moved 
new step generates subgoals ensure briefcase dictionary spatially coincident goal movb office office office home start home home home ucpop generates links initial start step satisfy preconditions step 
causes free variable bound home 
unsatisfied subgoals threats detected ucpop halts partially ordered plan home home home start home office office movb office goal run time unifies plans briefcase briefcase sussman sussman ysp data taken implementation ucpop ibm rs model 
times milliseconds 
pragmatics implementation ucpop algorithm implemented common lisp runs variety platforms 
maintain completeness ida search implement exploration nondeterministic choices 
shows actual run times briefcase example literature mcdermott pednault pednault sussman 
number unifications total number partial plans ucpop considered solving particular planning problem shown 
problems summarized follows ffl briefcase 
pednault briefcase domain 
problem indicates universal quantification postconditions described 
ffl 
bought home turn water water holes wall 
paste holes fix plumbing 
pasting holes fixing plumbing useless pednault 
ffl sussman 
tested versions sussman anomaly 
sussman problem clear axiom uses introducing numerous subgoals 
ffl ysp 
mcdermott yale stacking problem variation sussman anomaly uses predicate 
observe ucpop yale stacking problem quite easy mcdermott belief impossible nonlinear planner 
combinatorics handling universal preconditions multiple interacting steps exemplified increasing time 
overview contributions send mail weld cs washington edu information acquiring code 
ffl clear simple description ucpop planning algorithm 
ffl proof ucpop soundness 
ffl proof ucpop completeness 
section review pednault adl language ucpop uses represent actions detail simplifying assumptions 
sections describe representation partially ordered plans ucpop algorithm 
section presents core results proofs soundness completeness 
concludes brief discussion related 
representing actions frustrated restrictive strips representation frightened prospect implementing planner full situation calculus naturally pednault action description language adl 
adl essentially reformulation situation calculus action schemata akin add delete lists strips fikes nilsson 
adl expressive strips expressive full order logic 
action schemata semantics adl algebraic structures models characterize states world 
action adl set state pairs oes action executed state produce state association state state description oe indicated models symbol written oe 
action schema adl closely resembles add delete lists strips characterizes set possible actions 
schemata described optional groups clauses 
precond preconditions 
add delete set formulae describing set tuples added deleted interpretation relations resulting state 
update set relations describing functions change pednault version movb schema movb add delete merge add delete categories single effects category 
notion adding tuple encoded 
deleting tuple encoded asserting 
note technique merely syntactic variant pednault action representation 
forbid update category disjunction preconditions 
insist necessary preconditions explicitly stated 
diverges pednault approach assumed preconditions inferred world state 
free variables schemata implicitly existentially quantified serving placeholders interpretations 
equality constraints involve variables variables constants 
constants assumed unique value changed actions 
secondary preconditions pednault represents action schemata internally sets causation preservation preconditions collectively known secondary preconditions 
intuitively causation precondition action relation sigma specifies conditions cause added world state 
preservation preconditions action relation pi completely specify conditions deleted world state conditions preserve truth value example preservation condition respect action movb pi movb bv bv min disjunct corresponds moving briefcase location affecting 
second disjunct corresponds moving item briefcase affecting 
ensuring disjunct holds true preserves value movb executed 
mcdermott represented action schema secondary preconditions create provably complete total order planner adl 
generating secondary preconditions straightforward techniques pednault thesis resulting expressions unwieldy containing multiple disjunctions equality constraints functionals 
mcdermott simplified formulae heuristic rules efficiency purposes 
resulting algorithm sacrificed completeness produced anomalous behavior simple tasks 
chose different approach 
key insight separate logical connectives relations implementation successfully handles disjunctive preconditions finished implementing class metric updates extended proofs cases 
metric functions equality constraints 
realized generating complete disjunctive secondary precondition unnecessary circumstances 
example disjuncts required particular planning task 
devised algorithm constructed secondary preconditions dynamically introducing constraints logical connectives absolutely necessary 
steps effects representing action schemata complex set secondary preconditions convert action schemata canonical tuples called steps effects 
tuples permit ucpop quickly identify relevant parts add delete condition generating extending secondary precondition 
believe results considerably efficient regression process see comparison section 
definition step triple oeae fi ae step preconditions set quantified literals step effects set effects fi step constraints set equality constraints free variables ae 
notations ae fi refer sets ae fi step ae common preconditions effects 
equality constraints fi apply formulae effects preconditions ae 
binding constraints fi represented set possibly negated pairs 
indicates free variables constants unify formed formula 
indicate non codesignation unify formed formula 
set bindings fi specify equivalence relation written fi plan variables constants 
say pair consistent set bindings fi holds true relation fi similarly consistent hold true fi effect represented follows 
notations ae fi refer sets ae fi effect definition effect triple oeae fi ae effect preconditions set quantified literals effect postconditions set quantified literals fi effect binding constraints set equality constraints free variables ae 
step effect tuples clearly distinguish logical connectives equality constraints required secondary preconditions 
ucpop algorithm wants generate part causation precondition relation looks effect tuple oeae fi recall precondition sigma dictates conditions action cause true 
effect captures possible way action generate true ae fi sigma ucpop post conjuncts ae new subgoals fi new constraints met plan 
action newly instantiated action schema step ucpop post subgoals ae fi new goals represent nondeterministic choice choice disjunct sigma corresponding decision sure effect true cause proves impossible ucpop backtracks 
example consider step oeae fi describing action movb 
precondition ae fat specifies briefcase location binding constraints fi require origin destination distinct 
effects specify briefcase contents move execution movb 
set written internal representation effects tuples form oeae fi ae oe oe note quantifier indicate free variable effect tuple universally existentially quantified 
representing plans problems totally ordered sequence steps fairly easy identify step causes proposition true world 
call step source true initial world state refer dummy step source 
partially ordered steps things complex useful explicitly record intended source proposition planning 
elaborating tate mcallester define definition causal link quadruple oe denoted possibly negated precondition precondition effects effect unifies aid decision making ucpop maintains list causal links effects steps goals subgoals 
links represent assumptions plan relies crucial aspect partially ordered plans 
definition plan quadruple oes set steps set binding constraints free variables set ordering constraints fs sg set causal links 
pednault plans included steps ordering constraints 
representation denotes importance separating equality constraints logical connectives 
equality constraints secondary preconditions gathered kept single set goals posted satisfying equality constraints 
immediately checked consistency 
time planning process set inconsistent plan eliminated consideration ucpop backtracks 
plan tuples represent problem solved explain 
definition planning problem ff quadruple oe gamma set action schemata set literals indicating initial conditions gamma set quantified clauses indicating goals universe discourse variables gamma 
assure systematic establishment goals subgoals universal quantified clauses map clauses set corresponding ground clauses 
definition universal base upsilon order clause defined recursively follows ffl upsilon delta delta delta contains quantifiers 
ffl upsilon 
xn delta 
xn upsilon delta ffl upsilon 
xn 
yn delta 
upsilon delta delta conjunction formulae identical delta possible interpretation universe renamed unique names example suppose delta won universe discourse delta pair blocks fa bg 
universal base upsilon delta set elements clause upsilon delta said universally ground 
reformation universally quantified clauses similar skolem functions existentials universals recall skolem functions eliminate universals replacing existentials dummy functions produce corresponding values instance universal 
skolem functions applied inside universal base applied outside 
universal base set clauses isomorphic image skolem functions set clauses delta 
enumerate set ff 
xn range generate appropriate set clauses delta substitution corresponding universal rename renaming prevents name conflicts alternating quantifiers 
assume universe universal base finite 
definition ff oe gamma denote planning problem 
goal plan ff written plan ff plan oes fs fs initial step introduces ff initial conditions preconditions constraints goal step ff goals preconditions effects binding constraints 
section describe algorithm ucpop takes goal plan problem input systematically adds steps constraints finds solves planning problem 
section prove ucpop sound complete 
ucpop planning algorithm heart ucpop theorem prover resolves step preconditions effect postconditions 
reduces quantified formulae universally ground propositions manipulates create extend secondary preconditions 
preconditions satisfied creating causal links protecting effects steps 
common subroutine ucpop algorithm definition mgu function returns general unifier literals returned unifier exists 
delta set clauses notation represents set clauses delta resulting applying substitution ffi clause ffi delta 
form general unifier taken set pairs indicating ensure unify 
allow treat binding constraints fi conjunction general unifiers 
example mgu mgu mgu algorithm overview ucpop algorithm takes inputs plan oes agenda outstanding goals set action schemata entry goal agenda pair oec denotes plan step denotes precondition step pednault 
equality constraint variables rename variables add algorithm ucpop oes 
termination empty report success return 
goal selection choose goal oec link exists fail impossible plan 
note universally ground 

operator selection nondeterministically choose existing new instantiated step effect universally ground clause upsilon mgu 
choice exists fail 
fs sg mgu fi fi ss fs sg gamma oec fs 
subgoal generation effect establish link bindings mgu oe upsilon ae add oeoe oe upsilon ae add oeoe 
causal link protection causal link step effect postcondition ek step threatens link clause ae upsilon possibly mgu ae 
consistent ae threatens ae nondeterministically choice exists fail promotion possibly fs 
demotion possibly fs 
separation fs nondeterministically choose constraints fi existentially quantified variables mgu ae fi ii 
choose precondition upsilon ae ek mgu ae foe 
recursive invocation inconsistent fail call ucpop oes 
ucpop partial order planning algorithm handles actions universally quantified preconditions effects conditional effects sound complete 
constraint constants remain unchanged 
variable renaming done action schema instantiated step plan line ucpop fresh variables mcallester rosenblitt 
top level solve planning problem ff oe gamma algorithm called ff goal plan universally ground goals schemata ucpop plan ff upsilon gamma 
note goal agenda set tuples oec achieved step abbreviation top level goals 
example write upsilon gamma cumbersome upsilon gamma algorithm depends assumptions ffl initial world state complete 
ffl universe discourse fixed finite 
ffl changes world state dictated actions explicitly stated 
ffl actions deterministic 
ffl actions consistent action add oe oe consistent world state condition 
ffl relations pednault truth value relation step determined solely actions initial state 
ucpop algorithm continually refines incomplete plan goals subsequent subgoals satisfied 
refinements include addition new steps constraining free variables additional codesignation bindings ordering steps constraints lines dynamically introduce portions causation preconditions 
line chooses create disjuncts preservation conditions relation rely heavily structure effects steps 
efficiency concerns ucpop algorithm clearly exponential 
improve efficiency ucpop implementation distinguishes static dynamic propositions avoids copying static world description partial plan 
universe discourse implemented static typed hierarchy lisp objects 
universal quantification handled lazily iteration abstraction dynamically expands universal clauses cover cases similar plan transformation rule pednault 
closed world assumption adopted prevent large normally effects 
codesignation constraints fi implemented monotonically converging equivalence classes similar union find algorithm 
partial orderings steps simple lists pairs departure current trend complex temporal databases 
ucpop uses search evaluation function space partial plans 
numerous hooks domain dependent heuristics haven systematically explored believe avenue offers greatest opportunity performance improvement 
formal properties section prove ucpop sound complete 
adopt model theoretic semantics adl refer reader pednault complete description 
formalizing solutions soundness implies plan produced ucpop solution original problem 
completeness implies solution problem ff ucpop find 
concepts rely definition solution 
construct definition starting notions world states defining means execute actions execute plans converging formal concept solution 
recall states world algebraic structures models logic 
steps instances adl action schemata modeled set state pairs oes step executed state produce state set types describes collections objects type fixed set objects fo 
types may overlap example block type representing known blocks set physical objects 
types play important role determining scope universal quantifiers 
primitive state model time actions atomic overlap 
temporal history world represented linear sequence states separated single actions 
concepts define means execute step 
slightly changed definition pednault correspond notation assumptions 
deterministic actions insist state exists pair oes action pednault assumed set initial states assume complete initial state 
definition fs sequence steps state world 
result executing fs written result fs defined recursively follows ffl result fs ffl result fs fs gamma state pair action sn previous definition says feasible execute action state 
details happens state action applied produce state define notion executability partially ordered plans 
define mapping partially ordered totally ordered plans definition ff oe gamma denote planning problem 
totally ordered sequence steps fs ground topological sort plan oes bijection steps fs homomorphism respect ordering constraints exists global substitution theta binds unbound variables consistent step plan sn theta 
map partially ordered plans sets totally ordered plans define means execute definition step oeae fi representing set possible actions executable state ae fi consistent plan oes executable initial state ground topological sort fs step executable state result fs gamma 
recall planning problem collection action schemata initial conditions universe goals 
definition plan oes enhancement plan oes planning problem ff oe gamma definition solution planning problem ff oe gamma plan oes enhancement plan ff executable instances action schemata note solution follows result fs gamma ae gamma executable 
soundness proof soundness relies heavily pednault causality theorem akin version chapman modal truth criterion chapman plans conditional actions 
restate causality theorem convenience theorem pednault causality theorem 
condition true point execution plan holds 
action executed prior point sigma true immediately executing 
pi true immediately execution action point 
true initial state pi true immediately execution action prior point proving soundness means demonstrating ucpop algorithm correct answer ucpop plan ff upsilon gamma correct solution planning problem 
standard technique recursive algorithms proving loop invariant holds recursion 
show invariant holds ucpop halts 
invariant defined follows 
definition ucpop loop invariant subgoals goal agenda satisfied solution ff 
lemma ucpop loop invariant holds initial call ucpop plan ff upsilon gamma 
proof 
trivially goals upsilon gamma satisfied step gamma satisfied solution 
lemma loop invariant holds iteration ucpop hold 
proof 
corollary pednault thesis replace goals subset agenda causation preconditions steps effects achieve goals preservation preconditions steps threaten goals 
pednault causality theorem pednault preconditions satisfied original goals satisfied 
argue ucpop correctly performs goal transformations 
condition point causality theorem match variable step line ucpop 
action refers new existing step line ucpop 
note new steps instantiated place new steps introduced 
note case causality theorem handled choosing step line ucpop 
ucpop diverges direct procedural encoding causality theorem result observation 
requiring entire causation preconditions sigma generated posted subgoal sufficient post condition ae subsumes complex formulae ae sigma ae constraints exactly formulae stored step effect tuples mentioned earlier syntactic transformations action schemata 
assumptions ucpop translate causation preconditions pednault thesis rewrite follows sigma ae fi sigma false unique constants true sigma false constant true operator selection line ucpop chooses effect mgu 
upsilon 
mgu returns general unifier upsilon returns set formulae mgu 
substituting ucpop correctly chooses disjunct effect secondary precondition sigma ucpop works action schema dynamically adjusts set actions represented schema introducing constraints mgu 
corollary ucpop replaces original goal ae line records decision causal link equality constraints step derived disjunction fi handled follows 
ucpop renames variables adds line mgu fi fi ss 
inconsistent equality goals met 
mimics secondary precondition sigma false 
grounding free variables consistent set constraints satisfy equality goals subsuming sigma true 
syntactic translation goals form step ucpop correctly posts subset causation preconditions step effect depends assumption free variables existential constants unique 
conclude ucpop correctly handles case subcase causality theorem 
case subcase case causality theorem require preservation preconditions steps possibly come step plan requires true rewrite preconditions terms assumptions tuples follows pi ae fi pi false constant true pi false unique constants true ucpop handles subcase follows 
introduces additional step ordering subcase longer applies follows previous intuition posts goals pi actions lines ucpop handle approach 
line conjunction conditions line handle previous argument causation preconditions 
pednault corollary satisfying newly revised goal agenda equivalent satisfying ucpop recurses consistent introduces new steps loop invariant holds execution ucpop ground topological sort original plan executable satisfied 
corollary fact action preconditions introduced line executable new satisfied 
ucpop monotonically increases set binding constraints causal links steps iteration returns enhancement plan ff 
solution true 
lemma loop invariant holds iteration ucpop ucpop halts invariant holds 
proof 
ucpop halts line goal agenda empty performing modifications 
structures modified loop invariant hold ucpop halts 
theorem soundness ff oe gamma planning problem 
ucpop plan ff upsilon gamma returns plan solution ff 
proof 
previous lemmas combine form simple inductive argument ucpop loop invariant holds ucpop halts provided invoked ucpop plan ff upsilon gamma 
goal agenda empty ucpop halts additional conditions required solution 
plan returned ucpop plan ff upsilon gamma solution ff 
completeness stating completeness theorem useful corollaries soundness theorem 
corollary ff oe gamma planning problem 
fs solution ff fs solution oe result fs gamma gamma 
words step plan solution planning problem initial conditions gamma steps solution modified planning problem starts initial conditions derived executing step proof 
follows directly definition result fs 
definition plan oes fully supported step fully supported 
step fully supported preconditions ae fully supported 
precondition step fully supported causal link effect fully supported 
effect step fully supported fully supported precondition ae fully supported 
corollary ff oe gamma planning problem 
ucpop plan ff upsilon gamma returns plan fully supported 
proof 
follows soundness theorem 
note link line records decisions ucpop steps effects satisfy preconditions 
theorem completeness ff oe gamma planning problem fs solution ff extra steps 
appropriate search strategy ucpop applied plan ff return solution fs ground topological sort proof 
induction number steps totally ordered solution 
finesse issues search control fs oracle guide construction partially ordered plan mcdermott refers algorithm 
ida search korf maintain completeness implementation 
base case fs 
means plan steps dummy initial goal steps necessary achieve goal gamma 
call ucpop plan ff upsilon gamma result operator selection step consistently choosing establishing step making causal links solely initial step 
new steps added links threatened 
ucpop terminate solution additional steps satisfying need sequence ground topological sort inductive step fs 
solution fs gamma steps assume inductively ucpop correctly generates solution fs ground topological sort enhancement consider solution fs planning problem oe gamma show ucpop finds corresponding solution 
ff planning problem oe result gamma 
inductive assumption corollary ucpop plan ff upsilon gamma return solution oes gamma step sequence fs guidance 
close plan seeking initial step doing double duty acting source propositions provide original totally ordered solution 
distinguish define subsets causal links denote set links source propositions remain unchanged original initial conditions step executed 
delete propositions may add duplicates absorbed result ffl fs result distinct subset links add contains links source propositions added execution step proposition initial conditions result step executed situations caused effect ffl add fs result cg third set del contains links source propositions deleted execution step proposition contained initial conditions absent result deleted effects step executed situations ffl del fs result cg consider execution trace choices ucpop constructing trace conjunction sets links carefully guide ucpop solving original problem ff producing plan steps 
difference ff ff initial state intervene guiding ucpop wants create link initial state 
goals threat elimination proceed execution trace link chosen ucpop guided create link original initial conditions captured effect link chosen add del create ucpop guided create corresponding link new step identical step sequence fs links proceed 
execution trace exhausted ucpop additional goals form oec 
executable result satisfied links initial state posing new threats 
ucpop guided create links 
final result enhancement plan ff executable initial state nearly identical step know executable 
constructed solution ff contains ground topological sort fs ucpop complete 
related directly motivated chapman mcallester rosenblitt foundations partial order strips planning 
basic snlp algorithm barrett mcallester derived chapman tweak tate nonlin 
partial order planners action representations strips formalism 
chien chien dejong introduced conditionals tweak proved incremental convergence soundness 
parallel efforts proving ucpop sound 
pednault provides elegant theoretical foundation total order planning adl pednault pednault 
extended handle partial order plans pednault 
ucpop developed independently pednault pages document provide informal description lines algorithm 
pednault theory planning action transcend implementation encompasses incomplete initial states nondeterministic actions functional updates disjunctive preconditions 
pednault pose rule plan enhancement algorithm complete implementation theory attempted 
selected large subset language far total coverage 
mcdermott implementation planner adl total order plan representation 
mcdermott proved simple version algorithm complete frustration performance issues led pursue heuristic variations sacrificed completeness 
believe fundamental problem brute force generation entire preservation causation preconditions runtime 
formulae tend fraught redundant formulae constraints heuristic simplification recourse 
generating entire secondary preconditions suggested pednault pednault implemented mcdermott ucpop divides preconditions separate logical equality current extensions metric functional aspects allows specialized solvers deal constraints optimized fashion 
follows collins pryor extended snlp handle conditional effects 
consider universal quantification preconditions effects prove soundness completeness 
plans enhanced algorithm handle disjunctive preconditions completed extension allows updates monotonic metric functions 
high priority extend formal results augmented algorithm 
wish allow actions create destroy objects universe discourse surprised ucpop performance simple problems tested plan investigate performance issues thoroughly 
ucpop speed largely function simplicity classic test problems 
described algorithm nondeterministically actual implementation search 
manifest search techniques key efficient planning 
result believe ucpop affords excellent platform experimentation search control heuristics barrett knoblock speed learning techniques minton etzioni etzioni 
developed model language supporting search control heuristics ucpop similar prodigy minton 
fully implemented model search control tested plan report findings near 
presents clean elegant algorithm partial order planning expressive action representation 
ucpop handles large subset adl including actions conditional effects universally quantified preconditions effects universally quantified goals 
prove ucpop sound complete briefly describe full implementation 
believe ucpop simplicity efficient implementation excellent vehicle research planning learning 
acknowledgments research funded part national science foundation iri office naval research xerox 
ed pednault detailed helpful suggestions acknowledge useful discussions tony barrett benjamin grosof steve hanks 
barrett weld barrett weld 
partial order planning evaluating possible efficiency gains 
technical report university washington department computer science engineering july 
barrett barrett soderland weld 
effect step order representations planning 
technical report university washington department computer science engineering june 
barrett barrett 
search control heuristics abstraction commitment planning 
proceedings workshop problem reformulation representation change 
nasa technical report fia may 
chapman chapman 
planning conjunctive goals 
artificial intelligence july 
chien dejong chien dejong 
incremental reasoning explanation learning plans method evaluation 
proceedings aaai august 
collins pryor collins pryor 
achieving functionality filter conditions partial order planner 
proceedings aaai august 
etzioni oren etzioni 
structural theory explanation learning 
phd thesis carnegie mellon university 
available technical report cmu cs 
etzioni oren etzioni 
prodigy ebl works 
proceedings eighth national conference artificial intelligence 
fikes nilsson fikes nilsson 
strips new approach application theorem proving problem solving 
artificial intelligence 
kautz kautz 
order dynamic logic planning 
tech rept csrg department computer science university toronto 
knoblock knoblock 
automatically generating abstractions problem solving 
phd thesis carnegie mellon university 
available technical report cmu cs 
korf korf 
depth iterative deepening optimal admissible tree search 
artificial intelligence 
mcallester rosenblitt mcallester rosenblitt 
systematic nonlinear planning 
proceedings aaai pages july 
mcdermott mcdermott 
regression planning 
international journal intelligent systems 
minton steven minton jaime carbonell craig knoblock daniel kuokka oren etzioni yolanda gil 
explanation learning problem solving perspective 
artificial intelligence 
available technical report cmu cs 
minton minton bresina drummond 
commitment strategies planning comparative analysis 
proceedings ijcai august 
minton minton 
quantitative results concerning utility explanation learning 
proceedings aaai pages august 
pednault pednault 
mathematical theory plan synthesis 
phd thesis stanford university december 
pednault pednault 
synthesizing plans contain actions context dependent effects 
computational intelligence 
pednault pednault 
adl exploring middle ground strips situation calculus 
proceedings knowledge representation conf 
pednault pednault 
generalizing nonlinear planning handle complex goals actions context dependent effects 
proceedings ijcai july 
rosenschein rosenschein 
plan synthesis logical perspective 
proceedings ijcai august 
sussman sussman 
computer model skill acquisition 
american elsevier new york 
tate tate 
generating project networks 
proceedings ijcai pages 
weld de kleer weld de kleer editors 
readings qualitative reasoning physical systems 
morgan kaufmann san mateo ca august 
