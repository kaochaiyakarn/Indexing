formal analysis distributed object oriented language runtime alexander ahern nobuko yoshida department computing imperial college london 
distributed language features form important part modern objectoriented programming 
spite prominence today computing environments formal semantics distributed primitives object oriented languages understood contrast sequential part 
difficult perform rigorous analysis behaviour develop formally founded safety methodologies 
step rectify situation operational semantics typing system java core language primitives distribution 
language captures crucial hidden concerns involved distributed objects including object serialisation dynamic class downloading remote method invocation 
propose invariant properties describe important correctness conditions distributed runtime behaviour 
invariants play fundamental le establishing type safety help bound design space extensions language 
semantics language constructed modularly allowing straightforward extension exploited adding primitives direct code distribution language thunk passing 
typing rules new primitives developed invariants analysis tool type soundness ensuring inclusion violate safety guarantees 
language features distributed computing form important part modern objectoriented programming 
common different portions application geographically separated relying communication network interface coordination 
distributing application way confers advantages programmer resource sharing load balancing fault tolerance 
remote procedure call helps simplify engineering practice attempting offer seamless integration network resource access local procedure calls 
java programming language popular choice developing systems highly dynamic customisable class loading mechanism heart 
applets widespread example code mobility derived custom class loaders user visits page containing java applet virtual machine running inside web browser automatically download link required classes user intervention 
obtaining classes automatically fundamental java remote method invocation rmi 
widely adopted java platform offers programmer straightforward mechanism accessing shared remote resources 
fully exploits customisable class loading system underlying language alexander ahern nobuko yoshida allow code propagate network 
objects passed parameters remote methods provider method corresponding class file may attempt obtain sender 
semantics rmi different normal local method invocation 
passing parameter remote method accepting return value involve operations hidden user reason maintaining seamless integration original language 
example objects rmi passed local invocation classes implementing marker interface 
objects passed value invokes serialisation mechanism language 
similarly object class finds way particular location byte code class uses customised class loading mechanism attempt obtain class network 
verifying received class safe may require downloading direct superclass classes mentioned method bodies 
typically programmer aware actions fails 
presence hidden features runtime behaviour program idioms distributed computation complex understandable sequential 
due complexity need identify precise semantics distributed primitives arguably greater 
having semantic account distribution may benefit useful outcomes similar formal studies context sequential language features 
example build basis reasoning verification mobile code applets agents resulting theoretical framework analysis new language constructs engineering methodologies discuss optimisations clear semantic understanding 
importantly semantic account features life systems designer implementor easier providing framework implementation 
aims give formal semantics core java language basic programming primitives distribution extending existing core languages 
central challenge modelling distributed features give representation runtime behaviour reflects hidden elements discussed 
includes class downloading serialisation features contribute observable behaviour program 
key activity matching return points remote method call non trivial unavoidable interleaving operations system multiple locations underlying programmer level language explicitly mention 
show succinct representation runtime behaviours possible partly techniques higher order calculi 
highlights linear type discipline ensure correct intermediate state rmi returns 
semantics avoids tied particular implementation rmi abstracting away concerns methods resource binding stubs skeletons sensible implementation strategies change time example need skeletons removed homogeneous java systems jdk version moved version 
semantics flexible modular distill key features class downloading serialisation separately important design choices example eager lazy formal analysis distributed object oriented language runtime class downloading easily reflected semantics 
hope formal semantics offer clear high level understanding behaviour distributed extensions java languages contributing starting point development application formal semantics languages 
applying proposed formal semantics establish basic safety property typed formalism type soundness 
establishing type safety highly non trivial making invariant properties runtime configurations satisfy time 
instance simple example invariant says expression contains instance local class object stored physical location code question 
invariants capture basic safety criteria distributed states believe sensible implementations conform 
sanity check design typing rules invariant guaranteed reduction tends point concrete issue typing rules possible remedy 
invariants proving safety guarantees goes type safety simple example show progress properties derived combinations invariants 
proposed formal machinery show framework incorporate new primitive distributed object oriented programming thunk passing passes fragments code value communication execution 
known languages scheme lisp metaml having significant usability distributed object oriented programming know consistent type safe language level incorporation primitive distributed java languages 
typing rule primitive strong ensure type safety far obvious interaction existing distributed primitives 
find sound typing rule invariants tool analysis example thunk passing leaks local objects network simple minded typing rule violation directly suggests rule strengthened 
resulting typing rule guarantees preservation fundamental properties type safety progress extended language 
experiment incorporation distributed failure demonstrate extensibility framework 
summarise major technical contributions 
core calculus class java typed object oriented programming language basic primitives distribution including dynamic class downloading serialisation 
formal semantics centres representation runtime distributed configurations uses techniques process calculi treats different design choices modularly eager lazy class downloading 
new technique systematically prove type safety distributed formalisms network invariants 
invariants represent conditions distributed states 
essential proving type safety useful analytical tool developing consistent typing rules 
integration thunk passing primitives distributed object oriented programming establishment integration rmi class downloading mechanisms preserve type safety progress 
typing rules primitives developed analysis interplay invariants 
alexander ahern nobuko yoshida remainder section informally introduces language study 
section introduces syntax 
section lists auxiliary definitions 
sections defines operational semantics 
section lists examples operational semantics give detailed analysis behaviour programs listed section 
section defines typing system 
section proves basic properties typing system 
section develops invariants progress properties 
section proves subject reduction invariants 
section discusses related 
section concludes topics 
appendix lists rules operational semantics typing system 
program examples section illustrates basic ideas small distributed java language study concrete programming examples 
consider class definition class server int task return compute server created 
idea simple site powerful computing resources accept rmi calls tasks specify compute server perform behalf supplier 
code follows class task int compute return simple setting assume tasks return integers easily say special class created purpose 
receipt instance class subclass server calls method 
client server look class client server client server int gcd int int return new class extends task int int int int compute int true return formal analysis distributed object oriented language runtime client wishes server compute greatest common divisor integers iterative version euclid algorithm 
programmer creates correct body overriding method class task 
client requests done server making remote method calls awaiting result 
behaviour program conceptually simple contains significant elements captured purely sequential non distributed formalisms 
firstly server site may copy class case standard practice rmi site request copy class binary byte code client invoking remote communication 
contrast formalisms assume classes available locally 
second observation sending instance server class implement interface sender site invokes serialisation mechanism 
non distributed formalism consider passing objects value ignore aspect 
semantically distinction remote local essential rmi java similar languages distinction associated behaviour modelled 
example natural expect clients handled single server formalism support concurrency 
formal semantics distributed objects inevitably include runtime behaviour remote invocation transit return message transit request class downloaded class delivered 
sequential formalisms representation intermediate states runtime fundamental part formal semantics 
shall simple way represent borrowing ideas typed ho calculus 
class downloading mechanisms rmi realise natural method transferring code network 
design space code passing limited 
construct complements class downloading may realise code mobility explicitly form known thunk passing 
sections examine primitive formal viewpoint 
illustrate primitive significance previous example task server 
mentioned server download 
add extra burden making sure class server need perform job available directory accessible network leads low efficiency high rate failures 
suppose deep inheritance hierarchy server obtaining class fetch superclasses needed 
require trips network increasing risk failure adding latency 
compute server tightly coupled notion task client wishes cast framework 
issues arise class downloading allow direct fine grained control code passing programming 
primitives creation execution thunk write freeze solve issue 
give code server class int compute thunk int return defrost alexander ahern nobuko yoshida see mention class stipulation thunk question read evaluated returns 
say body thunk classes server developer tied particular representation done 
show code modified client class int gcd int int thunk int freeze int int int true return return compute client freeze expression language 
sending class embodying code euclid algorithm client creates frozen representation algorithm sending 
minor difference body compute method thunk lines 
lines simply copy formal method body thunk executing site computes correct result 
client supplies server server defrost run 
primitive code passing fully controllable user level server longer tied particular convention shape tasks client need create new class individual task 
importantly offers natural mechanism client explicitly specify piece code passed server distinct tag shall explain section 
cost expressiveness subtlety typing shall explore section 
formal semantics precisely concisely capture semantic differences significant design choices 
choice arises way class downloading executed 
eager class downloading code associated classes sent immediately 
lazy class downloading current standard implementation employs associated class fetched necessary remote site 
distinction significant consequences failure semantics efficiency 
desirable formal semantics cleanly capture ideas just formal semantics sequential languages cleanly represent call name call value calling conventions 
language formal analysis distributed object oriented language runtime section presents formal syntax language call dj 
consider configuration consisting multiple hosts virtual machines single high level class language 
inter host communication remote method invocation 
parameters remote methods may include base values remote objects interestingly objects local caller 
remote invocation parameters implicitly marshaled sending receiving sites 
brief marshaling process transforming parameters memory representation suitable transmission network 
unmarshaling dual 
allow explicit marshaling data arbitrary programs carrying local code classes 
related features provision automatic dynamic class downloading remote site 
language demonstrates key aspects rmi code distribution java clr making operational semantics non trivial 
spite simple syntax extension distribution operational semantics largely governed runtime behaviour hidden programmer 
language dj formalised kinds syntax writing programs local site call user syntax occurs runtime intermediate forms call runtime syntax 
user syntax introduce user syntax fig 

syntax extension fj mj augmented basic primitives distribution including thunks discussed section 
metavariables range expression statement types language 
represents expression types booleans base values considered class names ranged expressions type serialised objects type metavariable ranges types augmented special usual empty meaning 
class declarations ranged constructors method declarations ranges field names ranges method names denote local variables formal parameters 
denotes vector fields short hand sequence typed field declarations 
tn fn 
apply similar abbreviations sequences 
assume sequences contain duplicate names 
introduces class named direct superclass fields types constructor methods written java language fields may subclass new definition shadowing superclass 
simplify assume fields declared different names fields declared superclasses approach adopted fj 
allow overriding methods names subclass addition new methods 
constructors written form super 
initialises new instance class initialising fields superclasses call super 
fields declared initialised sequence alexander ahern nobuko yoshida bool thunk ser types void class extends classes super constructors um methods expressions pe return return serialize deserialize freeze defrost pe new true false null values eager lazy tags csig csig extends remote mi ti ui class signatures fig 

user syntax precisely correct number parameters constructor declaration fields class superclasses 
ensures correct initialisation 
methods declared um 
denotes method returns value type takes parameters types body method represented expression values ranged standard meaning expressions important new primitives 
expressions language denoted syntax expressions standard pairs distributed primitives 
consists values variables ranged branchings field accesses sequencing local variable declarations 
special class expressions denoted pe computation expression results value allow expressions return value needed sequences expressions 
introduce pairs distributed primitives 
pair serialisation 
serialize takes value computed expression 
produces new value suitable transfer network java serialisation writes byte stream original form chosen syntax leads simpler presentation typing rules 
deserialize takes serialised value computed expression converts back structured form 
pair primitives distribution creating thunks 
freeze takes expression evaluating produces frozen representation code 
expression evaluated stored value 
tag flag control amount class information sent user 
code automatically frozen classes may 
lazy specified responsibility receiving virtual machine formal analysis distributed object oriented language runtime obtain missing classes 
dual freezing action defrost expects evaluation expression produce piece frozen code executed 
ranges values consists boolean constants 
class signature csig mapping class names interface types signatures 
assume csig globally lose generality uniqueness class maintained digital signature standard implementations class tables maintained location basis 
attached signature name direct superclass declaration remote class remote 
class predicate remote holds iff remote appears csig local holds formal definition appears definition 
class signatures contain types fields expected method signatures implementation 
provides lightweight mechanism determining type remote methods 
simplicity omit casting exceptions synchronisation multiple inheritance adaptations features straightforward 
runtime syntax runtime syntax fig 
extends user syntax represents distributed state multiple sites communicating including remote operations transit 
new download resolve expressions await error values identifiers names threads go return go eto error ct configurations networks stores ct ct class tables fig 

runtime syntax syntax uses location names thought ip addresses network 
tagged class names written indicate body class obtained location typically code shipped network class names decorated labels consumers expressions safely alexander ahern nobuko yoshida request resources need execution 
write treatment class name independent tagged 
extended expressions define machinery class downloading 
tagged class creation new going download class executing new operator 
download downloads classes location executing resolve checks superclasses location facilitate automatic class downloading intuitively adopt task class 
await rmi explained threads 
distinguished result computation de null pointer 
fourth line extends values 
object identifiers denote instances classes destination rmi call 
shall frequently write id brevity 
channels fundamental mechanism method invocation determine return destination remote local method calls illustrated operational semantics 
call names ranged identifiers range names variables second extended value expression thunk brevity frozen piece code passed methods value 
point executed compute value 
ct denotes expression frozen class table ct ct ships class bodies may execution empty party evaluating lacks required class attempt download copy third extended value serialised array blob brevity flattened data representation suitable transfer network 
contains values transfer 
vi treated differently nature 
vi base value identifier remote object included special treatment 
oi oi identifier local object object flattened transfer 
creates object graph containing local objects transitively referenced oi 
final component blob location name indicating created 
fourth extended value empty value placeholder return value methods declared 
threads ranged comprise expressions evaluated parallel new name operator restricting identifier confused new object creation 
denotes empty thread 
notation comes calculus 
includes error denotes result communication failure 
primitives essential represent rmi mechanism 
channel created runtime spawn thread rmi 
await placeholder waiting result rmi go messages access remote methods carrying return result method invocation go message going back await remote location 
detailed explanation primitives operational semantics 
represent instance virtual machine configuration ranged metavariable configuration written ct consists threads store containing local variables objects class table written ct formal analysis distributed object oriented language runtime surround configuration possibly empty vector restricted names limits scope local names variables 
networks written comprise zero configurations executing parallel 
denotes empty network 
denotes configuration executing location understood threads 
scope restricted identifiers opened different located configurations structural equivalence rules explained permit remote method invocation 
stores ranged consist mapping variable names values written object identifiers store objects written indicating identifier maps object class vector fields values class tables ct mapping class names class definitions metavariable fig 

auxiliary definitions operational semantics typing rules structural equivalences dj depend auxiliary definitions 
explained section 
important definitions object graph definition class graph definition formulate operational semantics serialisation code mobility respectively 
reader skip section come back necessary 
definition domains 
functions domv domo compute domain variable mappings object mappings term respectively 
inductively defined networks configurations stores fig 

adopt convention dom domv domo 
similarly store location split parts cells containing values variables cells containing objects 
domains store denoted domv domo variable object parts respectively 
domains configuration defined domains store part configuration minus names restricted network defined sum domains configurations making network minus names restricted network level 
definition lookup functions 
fig 
provide functions determining types fields methods particular class retrieving code forms body methods 
distinguished class ob ject contains fields methods forms base recursive definitions 
fields 
fields class written fields yields sequence fi name field ti type field class signature write represent empty sequence fields 
method interface 
type particular method class class signature function mtype denoted indicate method takes sequence parameters type returns value type corresponds interface method 
alexander ahern nobuko yoshida configurations domv domo ct domv fv domo fn networks domv domo domv domv domo domo domv fv domo fn stores domv domo domv domo fig 

domains method body 
lookup fields method types rely lightweight csig code supplying body method obtained local class table ct function call mbody ct returns pair denotes formal parameters method body method 
valid method overriding 
java language overriding method subclass exact signature declared method superclass 
override defined means thats new signature class correct overriding 
definition free class names 
class name defined free subject instantiation operation written new 
set free class names term function fcl defined expressions threads class table entries 
free class names value defined fcl 
free class names expression defined recursively union free class names sub expressions exception fcl new fcl ei importantly fcl new fcl ei threads definition equally obvious fcl fcl fcl pi fcl fcl class table entries retrieve free class names appearing bodies methods fcl class extends fcl ei mi ti xi ei formal analysis distributed object oriented language runtime fields ob ject csig extends remote mi ti ui mtype mi ti ct class extends um mbody ct field lookup csig extends mi ti ui fields method type lookup fields csig extends remote mi ti ui method body lookup valid method overriding mtype mtype ct class extends um mbody ct mbody ct mtype implies override fig 

lookup functions definition free variables names 
functions determining free variables fv free names fn defined fig 

function defined fv fn 
variables represented range local variables threads variables mentioned domain domain store mappings 
names complex name object identifier usually written channel name written 
object identifiers appear threads stores domain domain channels permitted thread level 
definition define rule creating thunks 
definition free assigned variables 
function fav returns free assigned variables expression definition identical fv exception fav fav example fav fv 
cases omitted brevity easily constructed fig 

definition location names 
location names function loc defined inductively structure network returns set names loca alexander ahern nobuko yoshida fv fn values true false null error fv fv ct fn fn ct expressions fv fv fv vi fn fn fn vi fv fv fv fn fn fn fv fn fv fv fn fn fv fv fn fn fv fn fv fv fn fn new fv ei fv ei fv fn ei fn ei fn return fv fn return serialize fv fn deserialize fv fn freeze fv fn defrost fv fn return fv fn await go fv fn go eto fv fn download fv fn resolve configurations fv fn fv fn fv fn ct threads fv fv fv ct fn fn fn ct fv fv fn fn fv fn networks fv fn fv fn fv fv fn fn stores fv fv fn fn fv fv fn fn class tables fv fv fn fn um class extends fv fv mi fn fn mi ct fv fv ct fn fn ct fig 

free variables names formal analysis distributed object oriented language runtime tions comprising network defined follows loc loc loc loc loc loc loc definition local remote classes 
formal definition remote local classes follows type said local class local predicate true 
local true csig extends mi ti ui false remote predicate true type said remote class 
remote true csig extends mi ti ui false predicate true type class 
definition formulating serialised object identifier 
definition object graph 
function og computes object graph value store 
defined set mappings object identifier store object local object transitively referenced local object identifier value refers remote object base value boolean object graph empty 
algorithm defined follows og domo remote og oi fn domo og oi 
easy show algorithm terminates 
example object graph computation 
suppose dom 
assume remote alexander ahern nobuko yoshida local 
compute og follows og og domo og og og domo og og remote og og og og domo og domo og og og domo obtain og shows calculation example arrow denotes pointer store contains local class dotted arrow shows store contains remote class 
region denoted dashed lines represents stores collected step 
introduce preliminary notion reachability 
definition object graph reachability 
predicate reachable holds exists path store object identifier object identifier immediate link stored field fields intermediaries 
defined reachable fn fn reachable predicate may construct relation rch containing reachable pairs objects store rch domo reachable definition important 
object graph algorithm correct preserve tree structure store copying objects 
words preserve reachability relation 
determine correctness algorithm definition introduce notion complete object graph definition 
formal analysis distributed object oriented language runtime initial store collected collected fig 

object graph example collected collected completed object graph definition complete object graph 
store object graph computed store predicate og comp holds computed graph preserves reachability relation object identifiers object domain 
rch rch definition og comp domo domo rch rch alexander ahern nobuko yoshida property ensures links correctly copied graph new links created 
interesting point algorithm compute class graph safely add extra objects violating property iff objects unreachable graph 
intuitively safety preserved recipient object graph merely add unreachable element store immediately garbage collected 
course behaviour may inefficient garbage data may transmitted network 
definition calculate class table frozen create expression 
definition class graph 
function cg ct computes class graph type class table ct defined set classes referenced transitively type ct class name referenced appears method bodies defined class defined direct superclass 
algorithm defined follows cg ct bool cg ct void cg ct cg ct mi cg ct um cg ct cg ct cg ct ct dom ct dom fct cg ct cg ct cg ct ci cg ct cg ct fcl cg ct class extends cg ct cg ct class extends definition complete class table 
say class table ct complete respect class predicate holds comp ct def dom ct say class complete predicate holds ct comp ct def dom ct 
comp ct intuitively class said complete class dom ct superclass available 
completeness essential proper instantiation 
note cg ct generates transitive closure superclasses lemma shall show ct typable cg ct returns subset ct complete 
formal analysis distributed object oriented language runtime definition substitutions 
calculus different kinds substitution pertaining update store assignments applied method call mechanism substituting actual receiver distinguished related class labelling 
show turn 
store object substitution defined follows iff substitution objects store defined follows non object store entries substitutions defined follows consider substitutions method invocation 
receiver substitution defined recursively sub expressions interesting base case follows similarly return substitution return return defined recursively subexpressions example return return return return return return return return return return def return return class labelling substitutions defined follows class extends class extends um substitutions defined recursively sub expressions interesting case new new ei alexander ahern nobuko yoshida configurations ct ct fn fn ct ct ct fv ct ct fn fn threads networks fn return return return return operational semantics fig 

structural equivalence section presents operational semantics dj 
follows standard small step call value semantics 
large step semantics suitable due consideration concurrent execution possible interference reductions 
structure section follows 
introduce structure rules define reduction rules standard expressions serialisation local remote method invocation freezing class downloading errors 
rules categories mutually related 
appendix lists reduction rules 
structural equivalences subsection defines structural equivalences dj 
defined threads networks configurations fig 

equivalence relation comes calculus handles scope identifiers parallel composition threads networks naturally regarding programs identical 
formally equivalence relation includes conversion generated equations fig 

rules configurations define garbage collection useless store entries rules threads erase runtime value void type 
rules including scope opening inherited calculus standard 
reduction formal analysis distributed object oriented language runtime reduction dj expressed relations 
defined configurations executing individual location binary relation name location containing second relation global defined networks written relation includes key distributed rules dj remote method invocation class downloading locations 
define multi step reduction union structural equivalence relation transitive closure relation def def evaluation contexts reduce number computation rules evaluation contexts fig 

contexts contain single hole written inside 
represents expression obtained replacing hole context ordinary expression evaluation order terms language determined construction contexts 
new defrost return go go standard expressions fig 

evaluation contexts fig 
outline basic reduction rules language 
rules form sequential part language mention concurrency channel communication 
rules standard points fresh identifier creation allocating new space store rc dec rc new explicitly restrict identifiers 
operation represents freshness uniqueness address new entries 
facility important natural formulation distributed reduction relations invariants related locality identifiers cf 
section 
tagged class creation special allocation rule rc newr applied execution attempts instantiate object tagged class 
immediately allocating new object rule attempts download actual body class labelled location reduction rules class downloading discussed 

alexander ahern nobuko yoshida reduction context expressions evaluated contexts may create new identifiers rc dec rc new example 
scope new identifiers opened context shown new ct ct allows newly created identifiers successfully propagated 
example case automatic scope opening method call evaluated 
restriction rc seq similarly explained 
rc var ct ct rc fld fi ct vi ct rc cond iftrue ct ct iffalse ct ct rc seq ct ct ct ct rc dec ct ct domv rc ass ct ct rc new fields new ct ct rc ct ct dom ct domo rc newr new ct download ct dom ct rc cong ct ct ct ct serialisation fig 

rules local expressions contributions dj precise formalisation semantics serialisation 
subsection outlines interpretation java serialisation api formal analysis distributed object oriented language runtime serialize og vi domo serialize ct ct deserialize oi dom deserialize ct download min ct fig 

rules serialisation form operational semantics 
serialisation occurs situations 
situation allow explicit flattening re inflation objects programmer 
second instance occurs automatically values transported network 
instances local classes incapable remote method invocation pass parameters return values remote method invocations 
occur remote party receive identifier unreachable object 
avoiding problem involves sending local objects remote methods value serialised form 
serialize deserialize appear automatically runtime expressions parameters return values remote method invocations 
reduction rules de serialisation appear fig 

primitive values integers producing serialised representation straightforward significant internal structure 
objects may refer store care taken 
serialisation apply serialize 
remote primitives assume values suitable form serialisation change 
local object passed remote method part parameters sent dependent objects 
means copy local object referenced directly transitively 
purpose apply object graph computation algorithm definition obtain og vi 
graph constructed able build blob form 
parameters serialised time referential integrity maintained 
instance code cf 
remote method called local object parameters parameter individually relationship values field lost 
situation copies created remote site violating referential integrity 
operation dual serialisation 
blob applying deserialize 
remote object identifiers base values invariant operation local objects contained blob treated care 
create new local identifier renaming occurrences object graph new identifier preserving graph structure 
completing alexander ahern nobuko yoshida go serialize deserialize return deserialize network boundary serialize fig 

remote method invocation return go process append resulting data local store 
complication arises contains instances classes class table location 
retrieved location making call download vector accurately mimics mechanism employed class java rmi 
sending marshaled objects rmi implementations annotate data stream classes codebase url 
pointer remote directory refer download classes available current location 
method invocation key omission fig 
rules method invocation 
sequential formalisms dj describes remote method invocation 
accommodate rmi rules method call take novel form employing concepts calculus representing context call local linear channel 
technique known calculus dj may faithfully capture semantics rmi java language 
benefits allows define semantics local remote method calls concisely uniformly method call local receiver located caller remote receiver located 
remote calls differ local ones need parameter serialisation reflected extra reduction steps 
general picture remote method invocation summarised fig 
starts dispatch remote method ends delivery return value 
corresponding formal rules fig 

start local method calls 
method call domo local heap rule rc applied 
indicates local method invocation 
operations defined rule 
new channel created carry return value method 
return point method call replaced thought receiver waiting value supplied channel 
method call spawned new thread rewritten read method call return value channel 
formal analysis distributed object oriented language runtime rc ct await ct fresh domo rc ct await go serialize ct fresh domo rc 
mbody ct ct return return ct rc await await return ct ct rn return ct ct fn rn leave go ct ct ct deserialize ct rn return go ct ct ct return deserialize ct fig 

rules method invocation domo fn stage execution application rc recognisable style traditional method invocation rule 
remote local method invocations ultimately apply rule contains common parts required method invocation assigning store space formal parameters setting receiver gathering return value 
operations defined rule 
receiver parameter substituted invocation time 
new store entries formal parameters created initialised supplied parameters similar rc dec rc new 

value returned method sent channel realised substitution return return 
interesting aspect method call dj channels described final step 
leads definition method return rule rc await common remote local calls 
communicates return value caller 
call shown case domo remote method invocation 
case rule rc applied 
rule shares similarities rc creates new channel return point spawns new thread carry method code 
differs alexander ahern nobuko yoshida longer assume object identifiers parameter vector passed 
example object identifier refer instance remote class essentially meaningless remote server 
cope java rmi serialisation api dj employ similar mechanism 
nutshell name local object passed remote method parameter entire object graph represents copied 
means local objects referred fields taken original object ensure remote method access information needs 
discussed 
note values transferred remote location modification base values 
serialisation taken place left thread form go serialised representation original parameters point network level rule rn leave triggers migration method calling thread location holds receiving object local store 
transfer network parameters previously serialised rc applied 
return value remote method serialised rn crosses network application rn return 
returning calling site mechanism 
fig 
summarises values returned methods channel communication 
direct code mobility moving class downloading illustrate semantics thunk creation resolution 
thunks offer direct way manipulate code classes 
noted operations associated thunks creation thunks called freezing 
rules fig 

notable point invariants design reduction rule freezing illustrate 
rc freeze fv vi xi ct cg ct fcl eager lazy freeze ct ct ct rc defrost fcl dom ct defrost ct ct ct fig 

rules creating executing expressions formal analysis distributed object oriented language runtime freezing defined rc freeze takes modes lazy operation divided steps 

instantiate values stored local memory free local variables fv occurring creating 

mode calculate class table class graph function cg ct fcl defined definition attach initial step modes 
take special care local variable example dangerous freeze expression eventual point variable longer accessible 
avoid allowing local variables frozen expressions freeze operation takes step 
example suppose point evaluation freeze variable mapped value true store freezing operation safely replace actual value yielding true contain obvious error 
assuming invariant states values stored closed stated inv definition ensure newly created thunk closed 
concerning mode freezing merely determines amount information sent class table fragment accompanies expression thunk 
lazy mode empty class table lazy means client responsibility download classes needs 
eager mode freeze operation calculates class dependency graph required expression evaluate class graph function defined definition 
eager approach conservative computing classes may including superclasses necessarily 
example expression needs class superclass execute safely class graph function includes 
rule rc defrost defrost thunk 
step augment class table current location provided thunk 
classes mentioned tagged originating location new new 
execution newly thunk expression new encountered rc newr applied explained earlier 
possible may downloaded execution location party thunk contents ct 
alternative rule new object creation downloads class table entries necessary giving lazy semantics 
note eager case required classes attached ct substitution unnecessary 
hand lazy case ct 
note thunk shipped remote location argument rmi defrost location 
alexander ahern nobuko yoshida rc resolve ct ci class ci extends di dom fct resolve ct download ct rn download dom ct fcl ct ct ct download ct ct resolve ct ct ct rc ci dom ct download ct ct fig 

rules class downloading 
having modes generalise freeze operator ship user defined classes follows 
rc fv vi xi ct cg ct freeze ct ct requires change rule 
uniformly prove correctness choices invariant properties introduced section 
specifically invariant guarantee completeness class 
class downloading formalisation class downloading key contributions dj 
class mobility important java rmi systems reduces unnecessary coupling communicating parties 
interface agreed class implements interface passed remote consumer type safety preserved 
works sites able dynamically acquire class files 
hidden behaviour omitted known sequential formalisms required single location setting 
rules class downloading dj fig 

download expression responsible transfer class table entries remote site 
semantics operation rn download informally download attempts download vector classes location expression resolution defined rc resolve process examining classes dependencies scheduling download missing classes 
rules iteratively resolve class dependencies object 
dependencies met normal execution continues rc 
formal analysis distributed object oriented language runtime request download classes download actions 
calculated 
comprises classes available local class table preventing duplicate downloads 
compute vector comprises free class names contained method bodies classes 
class table ct copied local class table 
ct comprises bodies corresponding class names occurrence member tagged name remote site case 
rules represent lazy downloading mechanism standard java approximately model strategy jdk verification 

eager class downloading effective high bandwidth environment easily defined changing ct premise rn download cg ct 
correctness easily proved completeness class particular case special case chain download resolve reductions exist cf 
lemma 
threads networks fig 
give standard reduction rules executing threads networks parallel closed restricted names execution configurations locations 
rn conf promotes local reduction network level 
contextual rules standard see 
rc par ct ct ct ct rc res ct ct ct ct rn conf rn par rn res fig 

rules network thread rc str rn str alexander ahern nobuko yoshida errors final subsection defines distinct classes error arising programmer mistake arising unforeseen system failure 
rules error represents state execution reached program goes way 
key programming error may arise attempting dereference null pointer 
gives rise nullpointerexception java 
reduction rules concerning errors fig 

err err characterise error field access attempted null err method invocation attempted null 
important note situation parameters method invocation fully computed possible determine null receiver 
formulations consistent current java specification 
err null ct error ct err null ct error ct fig 

programmer errors err null ct error ct err download dom ct ct ct fcl ct download ct ct error resolve ct ct ct err go ct ct error ct ct domo err go ct ct error ct ct fn fig 

network failure errors second class error natural consequence distributed system network failure 
fig 
outlines situations failure exhibit effect formal analysis distributed object oriented language runtime network 
rule err download characterises corruption class table data transmitted network 
case err network partitioned remote method call attempting reach location 
results calling code reducing error 
likewise case err return value remote method call return original caller located 
reduces 
examples operational semantics section shows examples operational semantics focussing rmi code mobility serialisation 
subsection presents eager lazy code mobility third demonstrates code mobility remote sites final shows serialisation 
example corresponds second program section example section 
slightly modify programs section demonstrate non trivial interplay rmi code mobility class downloading serialisation 
code mobility eager code mobility write cl mobile phone client site sv server 
site maintains class table known classes specialist classes listing listing respectively 
simplicity assume library available universally 
computation question simple calculation greatest common divisor numbers 
client code class task contains body euclid algorithm 
seen listing client thunk task gcd depending choice tag may enclose copy task class execution immediately 
case operation remote location sv append definition class task class table sv 
instantiates task calls method gcd 
parameters replaced actual values cl time freezing 
assume sv server client code location cl remote object write network follows cl return new client gcd cl sv sv ctsv consider location cl initially isolation remote method call cpu 
return new client gcd cl cl return gcd cl cl cl client cl od return await gcd cl cl cl new task gcd 
line reduces return await thunk int freeze 
cl alexander ahern nobuko yoshida local class class client extends object server client server int gcd int int thunk int freeze new task gcd return cpu local class class task extends object int gcd int int return return gcd mod listing 
class eager ct task 
new task gcd 
reduces cl 
reduces return await thunk int cl 
cl return await thunk int cl 
cl cl cl cl 
reduces dg return await return cpu cl cl dg return await return cpu cl cl dg return await return cpu cl return await return cpu cl remote class class server int cpu thunk int return defrost listing 
class formal analysis distributed object oriented language runtime domo cl remote method call 
return await return await go cpu serialize cl cl return await return await go cpu cl method ready move location sv rule rn leave 
happen scope restricted names opened network 
simplifying network written csd cl return await return await go cpu cl sv sv ctsv movement csd cl return await return await cl sv cpu deserialize sv ctsv consideration turns location sv isolation 
previous line cpu sv ctsv sv return defrost sv ctsv sv sv sv return defrost sv ctsv return defrost sv ctsv sv return new task gcd sv ctsv ct sv return gcd sv ctsv ct sv sv task sv oh return await gcd sv ctsv ct assuming calculation goes greatest common divisor 
recursive call generates new pair entries stack parameters denote vector interesting note stack frame recursive call corresponds thread await channels resume execution point final stack frame removed result returned 
write sv represent store execution 
oh return await return sv ctsv ct return await return sv ctsv ct sv return sv ctsv ct return sv ctsv ct sv sv ctsv ct sv go sv ctsv ct alexander ahern nobuko yoshida opening scope restricted names applying garbage collection rule rn return give network written normal form csd cl return await return await cl sv go sv ctsv ct movement csd cl return await return await return deserialize cl sv sv ctsv ct concentrating location cl return await return await return deserialize cl cl return await return await return cl cl return await return cl cl return cl assume channel process waiting input 
model return value entire program 
lazy code mobility chose assume tag set eager mode 
mode class potentially required evaluate thunk remote site bundled 
case class needed task 
suppose chosen lazy 
illustrate lazy downloading shall assume task dom ctsv 
execute code location sv obtain classes needs 
defrost step return defrost sv ctsv sv return new task cl gcd sv ctsv task dom ctsv class name task tagged location created thunk specified rc defrost 
normal instantiation rc new download task cl rc newr 
previous line reduces return download task cl task gcd sv ctsv apply rn download retrieve definition task return resolve task cl task gcd sv ctsv task 
sv return download ob ject cl task gcd sv ctsv task 
ob ject dom ctsv foundation class rc applied return new task gcd sv ctsv task 
necessary classes downloaded execution resume 
formal analysis distributed object oriented language runtime nested code mobility example shows process compute value incrementally stages moving different sites 
consider class table listing 
suppose remote object identifiers instances class scope program new compute execution method return value 
actual computation approach ability arbitrarily nest freeze expressions perform calculation steps different locations 
class int compute int int return execute freeze eager int int return execute freeze eager class int execute thunk int return defrost listing 
partial computation class table initial freeze eager operation obtain thunk denotes int int return execute freeze 
remote procedure call execute triggers defrost location object identifier means location begins executing code performing simple calculations declarations variables create new thunk sent thunk write location important 
defrost performs trivial computation result returned turn returns original caller 
remote method invocation object serialisation class downloading subsection gives outline reduction steps example section 
demonstrate operational semantics precisely model rmi object serialisation associated class downloading 
recall remote classes server side 
avoid confusion append trad class names section trad means traditional 
alexander ahern nobuko yoshida server class int task return compute class shared server client 
server client class task int compute return show effect inheritance class downloading slightly modify programs section follows 
server class class int gcd int int task new return client classes class extends int int int int int compute example section class extends task int compute return new mod compute class mod extends object int compute return client side exists inheritance task class mod 
assume task shared server client classes local client initially exist server class table 
summary sv dom ctsv task cl dom mod task formal analysis distributed object oriented language runtime previous example consider initial network cl return new gcd sv sv ctsv intermediate reduction steps essentially similar reductions 
restart configuration client side focussing serialisation local object identifier go serialize cl 
local method serialised network transfer 
procedure outlined definition illustrated example serialisation takes copy store 
go cl cl go moves server blob invoking class download 
sv deserialize cl sv ctsv sv sv download cl sv ctsv note name restriction operator guarantees freshness id 
similarly downloading calls series iteration resolve follows 
resolve cl sv ctsv 
sv download cl sv ctsv 
sv sv ctsv 
mod cl mod body class 
note superclasses downloaded executing mod downloaded replaced mod cl allow lazy downloading cl example new compute performed server side lazily download class mod rc newr cl rest reduction similar local method invocation 
typing system section presents typing system dj 
technical key points typing 
linearity channels linear channel types guarantee determinacy destination rmi return point 
class signature offers lightweight type checking rmi preserves consistency serialisation code freezing 
freezing thunks special care required freezing expressions contain free variables object ids 
alexander ahern nobuko yoshida bool thunk ser types void types ret return types chan chano channel types expression environment channel environment syntax types environments fig 

syntax types environments introduce syntax types environments fig 

represents expression types booleans class names expressions type serialised objects type metavariable ranges types augmented special type void usual empty meaning 
write class subtype class notion subtyping standard assume causes cycle judged class signature 
runtime types appear programs newly introduced 
return types ranged denote type value returned method invocation um typed type ret 
metavariable ranges types channels method calls explained subsection 
different kinds environment 
environment typing expressions written finite map variables ids types ranged finite map channel names channel types appears judgements method calls involving multiple threads locations 
linear channel types key tasks typing rules ensure linear channels 
means channel exactly process waiting input output terms dj ensures method receiver returns value correct caller returned value finds initial caller waiting 
fig 
linear input value type chano opponent called linear output 
channels matched input output types 
assigned await chano threads go 
note channels appear runtime channels carry channels 
see linear types consider network return expression determine original location awaits channel violating linearity await ct await ct go ct formal analysis distributed object oriented language runtime uniqueness returned answer lost return channel appears twice 
return ct return ct aim introducing linear channels avoid situations executions runtime method invocations 
binary operation controlling composition threads networks 
definition channel environment composition 
commutative partial binary composition operator channel types defined chano def chan 
define composition channel environments def dom dom dom dom channel types composable iff composition defined defined 
similarly 
note partial operators 
composition combinations allowed 
compose linear input output types typed chan chan 
intuitively typed environment compose safely preserving channel linearity 
untypable 
chano subtyping notion subtyping dj standard 
judgements shown fig 

st refl st vec ui st trans st ser ser ser fig 

subtyping st expr thunk thunk ret ret st class csig extends 
rule st refl reflexive subtyping judgement type trivial subtype 
st trans ensures subtyping relation transitive respect classes class subtype class class subtype class said subtype assume atomic subtyping 
st expr expression subtyping introduced 
example thunk thunk ensures thunk alexander ahern nobuko yoshida computes precise value safely place thunk coarser type 
likewise judgement ret ret essential assigning types method bodies reason 
similar argument st ser 
importantly rule st class judge subtypes classes 
entirely class signature csig particular class table entries 
allows judgements type system lightweight 
example opted judge subtypes knowledge held class tables required typing judgements form ct current class table ct augmented time new classes downloaded discovered 
formedness formedness defined types environments stores class tables 
kinds judgement interrelated 
assume ranges remote mi ti ui 
env formed environments tp formed type ok formed store environment csig ok csig formed signature ct ok ct formed class table judgement ensures environments respect rules 
consider expression environment environment completely separate notion channels language stores kinds information mappings object identifiers classes mappings local variables types mapping special expression class current receiver channel environment may contain mappings channel names channel types ranged 
construct formed environments formed types class types may 
judgement tp provides defined fig 
note csig contains formed types formed csig entry 
nil env var tp dom env tp dom env env env oid tp dom env fig 

formed environments chan tp env dom env wf base env void tp bool tp chan tp wf sig formal analysis distributed object oriented language runtime wf sc tp csig tp chano tp thunk tp ret tp override mi di ti ui tp ti tp dom csig extends remote mi ti ui tp value expression typing wf vec ui tp tp fig 

formed types wf ser tp ser tp wf csig dom csig tp csig ok wf ctp csig tp tp types assigned values expressions expression environment judgements form type expression environment ranges typing rules values fig 

rule tv null allows assignment formed class type value null 
tv thunk states expression class packaged formed expression type serialised object typed rule tv blob values contains typed store typed types object identifiers contains 
case bound object identifier oi type local class 
rules assigning types expressions fig 

rely expression environment similar form typing rules java languages 
note subsumption rule type nil ok var ok domv ok fig 

formed stores oid ok vi domo ti fields ok alexander ahern nobuko yoshida ok ret mtype um ct nil ok ok fields fields super class extends ok ct class extends ok ct ok ct class extends ok fig 

formed class tables system 
explicitly annotate place subtypes place supertype 
explain rules differ 
te fld restricts field accesses local classes hand allow remote class instantiated id store exists location see rc 
constraint initial condition defined section guarantees field access local 
te return te ensure return statement return type 
rule serialisation te serialize assigns types term serialize 
rule te defrost dual 
typing rules complicated rule te freeze 
expression freeze typed conditions hold firstly expression type environment written secondly free name variable mentioned expression primitive type object identifier remote class guaranteed local ti ui ti 
requirement simplifies tv bool env true bool false bool tv null tp null tv thunk ct ok thunk tv oid env fig 

rules values tv empty env void tv blob local ci ok domo ser te var env formal analysis distributed object oriented language runtime te fld tp local fields fi ti te ass te meth mtype te serialize serialize ser te freeze fav local ti ui ti freeze thunk te pe pe pe void te env te seq void te te return return ret te deserialize ser deserialize te defrost thunk defrost te tp download resolve fig 

rules expressions te cond bool te dec te new fields ei ti tp new te env return ret void te hole tp burden freezing operation local object identifiers allowed passed part thunks heavy requirement object identifier similar fashion remote method invocation 
order prevent variable replacement strategy rc freeze na example freeze re written alexander ahern nobuko yoshida freeze straight substitutions require expression frozen contain free assigned variables 
condition written fav defined definition 
conditions designed ensure shipped thunk leak free local object identifiers variables satisfying variable id invariants defined definition 
te defrost dual 
te pe rule typing sequential composition 
typed context starts te hole explained subsection 
rules obvious 
freezing 
operational semantics typing system simplified assuming contain free variables shown rules 
ct cg ct fcl eager lazy freeze ct ct ct fv fn remote ci ui ci freeze thunk check rules satisfy invariants specified section 
simplification current typing rule te freeze allow creating code contains free local object ids 
combining serialisation primitives type code contains serialised object graph serialize freeze note serialize creates closed value 
combination kinds distributed primitives offers flexible high level programming style 
threads typing threads assigned type expression environment channel environment 
judgement takes form thread typed environment rules assigning types threads shown fig 

tt nil states inactive process typed formed environment 
key rule tt par type parallel compositions threads composition channel environments preserve linearity channels 
checked see 
tt res standard rule typing restricted channel names 
allow new channels assigned 
similarly restrict variable exists store 
related definition rule tt weak states safe add matched channels environment provided course names environment 
rule tt await types await expression corresponds return point method calls 
expects channel expecting input type safely plugged waiting context 
tt return types method bodies thought dual tt await expects channel output type carry supertype return value method 
remainder rules handle method call remote invocation 
tt nil env formal analysis distributed object oriented language runtime thread tt par pi thread thread tt weak thread dom chan thread tt return ret tt res chan thread thread tt await thread dom await thread chano return return thread tt remote mtype chano go serialize thread tt mtype chano thread tt ser remote mtype chano deserialize thread chano go thread tt local chano thread chano go thread networks typing fig 

rules threads tt goto ser chano go eto thread threads networks configurations typed expression channel environment 
judgements conf typed configuration environment 
net typed network environment 
typing rules fig 

restricted identifiers configurations networks typed rules tc resid tn resid respectively 
share side condition common form dom ensures create spurious new identifiers correspond element domain store likewise dom ensures similar condition network level 
alexander ahern nobuko yoshida tc chan conf conf tn nil env net tn chan net net tc resid conf dom conf tn conf conf net tn resid net dom net fig 

rules networks configurations tc conf thread ok ct ok fct ct ct conf tn par ni net dom dom loc loc net tn weak net dom chan net rule tc conf states configuration typed environment threads store typed environment 
class table formed contain copy foundation 
rule tn nil standard meaning inactive network typed formed environment 
rule tn par states parallel composition networks typed typing environments composable share identifiers stores disjoint sets location names 
condition understood tt par 
rest rules tn tn weak understood tc tt weak respectively 
basic properties section shall show key properties lemmas necessary proof network invariance conditions type soundness theorem 
write adopt convention written simply subsequent proofs length functions stores class tables defined length length length length length length ct class extends length ct lemma introduce lemma 
concerns canonical forms dj 
prove typable network written form 
intuitively formal analysis distributed object oriented language runtime canonical form restricted identifiers moved network level 
lemma canonical forms 
suppose net li pi cti denotes number locations proof 
induction number networks parallel suppose 
assumptions net 
trivially equivalent zero product li pi cti 
inductive step suppose statement holds networks show adding equivalent normal form structural rules fig 

suppose assumption un ln pn ctn net inductive hypothesis un li pi cti apply alpha equivalence restricted names un ensure clash names allows apply scope opening obtain un ln pn ctn apply alpha equivalence time ensure names bound un clash location ln 
apply structural equivalence obtain un un ln pn ctn li pi cti straightforwardly rewritten un un li pi cti completes case 
judgements lemma lists useful properties judgements 
write stand judgements env ok thread conf net lemma useful property ensuring channels appearing channel environment linear 
alexander ahern nobuko yoshida lemma judgements 
permutation environments 

similarly 
linearity channels 
fn chan 
weakening 
dom chan 
tp dom 
tp dom strengthening 
fn 
implied judgements 
env 
proof 
induction size 
cases straightforward 
list proof weakening case thread 
applying rule tt par cases apply inductive hypothesis left branch right branch parallel composition 
example choose left branch 
chan thread chan dom 
apply tt par yield chan thread 
chan thread definition 
case proceeds similarly 
stores lemma states properties type safety store access 
store access defined adding new variable object identifier mappings updating fields objects value held variable retrieving information variables object fields 
lemma allows concatenation disjoint stores useful typing operation 
lemma stores 

assume ok dom ok 
assume ok ok 
ok imply 
assume ok fields ti dom 
ok 
ok fields ti fi ok 
assume ok fi ti 
vi ti 

suppose ok ok dom dom ok proof 
induction length store written length 
prove 
similar 
formal analysis distributed object oriented language runtime case length trivially domo assumptions immediately conclude ok required 
case length suppose 
length length 
premises lemma state ok dom fields ti ok assumption derived oid premises ok domo fields ti applying lemma obtain env derived rule oid premise tp dom 
side condition apply lemma obtain ok dom complete case apply oid obtaining ok required 
case length base case 
length case empty means 
lemma take ok deduce env 
ok required 
case length inductive step 
assume store length statement holds prove length 

perform case analysis item appended store 
variable value mapping object identifier store object mapping 
shall consider case variables case similar 
suppose assumption ok dom dom assuming item appended variable mapping premises var ok domv alexander ahern nobuko yoshida apply weakening obtain apply lemma deduce env 
means dom 
fact apply lemma obtain ok required 
graphs dj kinds graph computed object graphs class graphs 
lemma proves correctness algorithms definition definition respectively 
properties key prove type soundness theorem 
note definition complete appears definition 
lemma graph computation 

assume ok og 
ok domo local 

og implies og comp 

suppose ct ok dom csig 
cg ct ok 
ct comp ct cg ct imply ct comp ct fct 
proof 
show induction length induction length 
shall assume og ok length prove length shall show objects instances local classes 
examining definition object graph calculation algorithm see distinct cases 
base case graph empty store straightforward ok 
case computation happens difficult 
examining definition og definition 
trivially re order ensure item 
infer assumption ok oid premise ok examining body algorithm see length length length og oi domo og oi 
inductive hypothesis immediately conclude ok 
singleton store trivially formed take ok ok order apply lemma obtaining ok required 
assume og 
base case length 
examining algorithm see 
trivially og comp 
inductive step assume og og comp length setting length sub cases 
trivially pairs reachability relation rch og comp vacuously 
formal analysis distributed object oriented language runtime og oi fn domo og oi 
clearly length initial removal 
write og oi 
examination algorithm shows computed elements collected domo domo inductive hypothesis og comp og oi 
recall 
adding side add number reachable states og comp 
induction length ct 
consider class graph length ct 
suppose ct cg definition class graph algorithm ct 
clearly ok ct nil 
inductive step assume cg ct ok length ctn show length ctn 
suppose ctn ok dom csig cg ctn ok assumption consider case dom ct dom fct trivial 
shall prove cg ctn ok expanding class graph algorithm steps cg ctn obtained cg ctn cg ctn class extends note class ok dom ctn ctn ok cg ctn proved inductive hypothesis 
second item union cg ctn check method mi compute cg ctn expanding algorithm step yields cg ctn inductive hypothesis cg ctn defined 
applying ct conclude proof 
suppose length ct definition ct complete 
take length ctn ct cg ctn complete assumption dom ctn ct dom ctn ct 
inductive step show length class table computed class graph remains complete 
extending class table achieved appending new entry ctn dom ctn 
assume superclass ctn new class table complete hold default 
cg ctn ct complete virtue empty 
assumption class contains direct superclass complete 
lemma method body 
suppose mbody ct mtype ct ok ret 
alexander ahern nobuko yoshida proof 
straightforward 
lemma context 
iff 
proof 
induction structure structural equivalence important property shown application structural equality rules fig 
preserves typing term 
proved lemma order equally important property shown lemma 
lemma yields natural properties composability environments proofs 
lemma commutativity composition composability 




proof 
proofs loss generality consider singleton environments chano chan 
case show left right direction opposite direction similar 
interesting case share channels 
definition know dom 
chano required 
easily check defined definition desired 
proceeds similar manner adopting singleton environments 
easily check defined equal chan 
dom chano 
definition chan required 
lemma structural equivalence preserves typability 

conf conf 

assume thread thread 

net net 
proof 
induction typing derivations paying attention rule applied 
cases straightforward 
show sub lemma 
formal analysis distributed object oriented language runtime show case ct ct 
suppose shall prove ct conf fn fn ct ct conf infer rule tc conf applied premises thread ok ct ok derived applying tt res premise chan thread applying tc conf obtain chan ct conf complete case apply tc obtain required 
interesting case 
associated proving case handled lemma follows 
suppose thread shall prove thread derive rule tt par applied premises thread thread side conditions apply lemma obtain derive tt par premises thread thread alexander ahern nobuko yoshida apply tt par yield thread take premises rule tt par obtain thread apply lemma obtain required 
interesting case 
prove right left direction 
direction similar 
suppose shall prove net net infer rule tn par applied premises net net lemma chan dom dom overlapping channels 
apply lemma obtain required 
lemma substitution 

assume fav 

imply 
proof 
induction structure expression lemma lemma 
show interesting cases 
case def freeze suppose freeze thunk 
derived te freeze premises fav ui ti local ti 
fav apply inductive hypothesis premise obtain apply rule te freeze fav local 
note fv implies fav 
premise local 
apply te freeze order obtain freeze thunk 
thunk thunk completes case 
formal analysis distributed object oriented language runtime case def await suppose await thread 
derived tt await premise thread dom 
assumption fav await definition fav fav 
apply inductive hypothesis obtaining thread 
unchanged side condition dom holds apply rule tt await yield await thread required 
cases trivially similar 
key difference base case def 
proof remains straightforward 
network invariants section studies network invariants 
show initial network satisfies initial conditions typed reduction preserve run time invariants 
important showing safety establishing subject reduction theorem 
network invariants initial networks start definition property networks definition 
definition properties 
denote property networks subset networks 
write satisfies write satisfy 
define error property err set networks subexpression err error ct 
say reduction closed err 
define network invariant initial property err reduction closed 
order ensure correct execution networks preservation safety require certain properties remain invariant 
key invariants presence distribution classes class called superclasses local class table 
requirement eliminates erroneous networks containing locations new class empty class table initial step execution cause crash 
note class table superclass unexpected state 
property formalised completeness class table comp ct defined definition 
definition formally states class invariant 
domv resp 
domo denotes variables resp 
ids domain 
say thread inputs await dually thread outputs return go definition network invariants 
network li fi fi pi cti assuming required define property inv set networks satisfy condition defined follows alexander ahern nobuko yoshida class invariants 
fct cti 
pi new qi comp cti 
dom cti dom ct cti ct cti ct li fcl cti value invariants 
pi fv 
fv 
fv vi state invariants 
fv pi domv 
fv pi fv pj 
domv domv object identifier invariants 
fn fi fn fj 
remote 
fn fi 
local 
fn fi domo 
domo domo method invocation invariants 
pi qi 
comp cti field invariants 
pi qi 
comp cti 

pi qi 
comp cti 
linearity invariants 
pi qi ri qi inputs ri pj inputs 
pi qi ri qi outputs ri pj outputs invariant clear operational arguably engineering meaning illustrate number corresponds invariant number 
class invariants 
availability foundation classes class table location contain copy foundation classes 

class availability class instantiated location superclasses available location class table 

class name coherence classes name distributed different locations exactly definition definition location tagging class name 
value invariants 
value closedness values contain unbound variables 

value closedness stores store entries may contain open variables 

field value closedness stores objects location store closed fields 
state invariants 
availability variable stores programs location mention variables variables accounted list restricted names entire network 
formal analysis distributed object oriented language runtime 
locality variables local variables shared threads different locations 

locality variable stores local variables store globally unique names 
object identifier invariants 
locality local object ids object referenced threads different locations case identifier remote class 

availability local object ids thread instance local class object necessarily located store 
availability object ids object located store remote local location 
unicity id stores object identifier system unique store 
ensures ambiguity determining location holds store entry particular remote object 
method invocation invariants 
availability store classes method calls thread attempting perform method call store code method body available 
field invariants 
field access availability locality field access succeeds objects local executing code 

field assignment availability locality field assignment succeeds objects local executing code 
linearity invariants 
unicity await network unique await name 
ensures ambiguity determining place remote method invocation happened 

unicity output network unique output thread name 
ensures unique return value method invocation 
proving network invariants define initial network configurations 
roughly speaking initial configuration contains runtime values expressions ids 
contain parallel threads distributed locations generated compiling multiple user defined main programs 
definition states conditions formally 
definition initial network 
call network li pi cti initial network satisfies conditions called initial properties 
contains runtime expressions values ids parallel compositions contain free ids fn 
satisfies properties inv inv replaced class invariants 
fcl pi dom cti fcl cti dom cti comp cti 
comp cti 
note fn pi form 
similarly inv inv prog prog 
alexander ahern nobuko yoshida strengthen field invariants inv inv replacing field invariants arbitrary context 
pi dom 
denote set networks satisfying conditions init 
note combining inv condition subsumes inv inv 
extra requirement states initial class tables complete classes program stores 
example suppose new ct ct class void new return defined ct ensured inv secondly defined ct ensured dom ct comp ct implies dom ct thirdly defined ct appears method invocation atm 
condition ensured fcl ct 
condition similarly understood 
note runs programs initial properties may satisfied classes downloaded lazily 
typical example new ct download ct appears free expression dom ct satisfy 
formalise situation lemma prove invariant inv 
initial condition inv similarly understood 
proof method invariants invariant properties required proofs subject reduction shown section 
means type preservation assumed prove invariant inv 
inductive step goes need divide proof routine steps step prove step invariant property typed network starting initial properties 
step sub cases assume net satisfies initial properties 
implies inv err 
ii assume nm net nm inv 
nm nm implies nm inv nm err 
step prove subject reduction theorem step net implies net 
step invariant inv corollary steps 
lemma lists key additional invariants related dynamic downloading classes main proofs class invariants 
shall notation pim denote threads location reduction steps 
formal analysis distributed object oriented language runtime lemma class invariants 
assume nk net satisfies initial condition nk inv 
assume nm nm um li pim im ctim nm um li pim im ctim 
assuming required 
monotonicity class tables ctim ctim 

eager thunks class tables pim qim ct ct jm 

remote downloading class tables pim download qim dom ct jm pim resolve qim dom ct jm 

class downloading availability class tables fcl pim dom ctim pim download qim 

availability local classes fn pim im 
dom ctim dom ctim pim download qim pim resolve qim 

availability superclass tables nk uk li pik ik pik download cz cz nm um li pim im ctim nk nm pim resolve qim dom ctim 
final statement requires slightly different conditions need track sequence download resolve reductions 
proof 
induction omit ct reduction step 
straightforward examining rn download rc defrost class tables changeable rule 
obvious investigating rc newr rn download rc defrost inductive hypothesis nk satisfies monotonicity class table 
base case inv fcl pi case dom cti 
fcl pi property holds trivially 
inductive step assume property holds reduction steps 
sub cases considers fcl pim dom ctim 
dom ctim required 
fcl pim pim download new qim 
dom ct jm 
rule rn download dom ctim 
assume dom ctim dom ct ct jm 
definition downloading ctim ctim ct dom ctim required 
alexander ahern nobuko yoshida assume fcl pim fcl pim 
examining definition free class names reduction rules see reduction generates new free class name rc newr 
deduce pim new qim li pim qim required 
suppose fn pim im 
situations 
created locally evaluation new original program text lemma inv dom ctim 
created object exists pik download contains classes objects defined rn download 
lemma dom required 
lemma multi step reduction nl nm removed class table entries dom ctim required 
case reduces resolve rc resolve 
reasoning lemma 
obvious repeating rn download rc resolve reach resolve note reductions terminates inheritance relations formed class table acyclic 
proofs network invariants ready prove step lemma 
necessary show subcase ii step invariant inv inv inv 
cases inv inv prove stronger initial condition inv hold 
inv inv derived corollary 
hand case inv assume particular invariant holds may case previous network inv holds 
show inv established reduction step 
case inv lemma 
case inv suppose pim new qim li pim new qim 
candidates reduction rule applied suppose rule applied rc cong 
pim new qim 
structure indicates expression part original program text lemma dom ctim dom cti 
inv dom cti super classes cti 
lemma dom ctim required 
suppose rule applied rc 
set pim download qim 
means sequence download resolve download steps 
considering pattern behaviour conclude chain started application rule rc newr 
lemma super classes downloaded ctim 
lemma classes ctim required 
formal analysis distributed object oriented language runtime case inv prove rule induction 
sub cases 
applied rule rn download 
assume dom ctim ct ct jm li download im ctim lj jm ct jm li resolve im ctim ct lj jm ct jm note reasoning proof lemma ct welldefined 
show dom ctim ct dom ct jm implies ctim ct ct jm 
ct jm inductive hypothesis ctim ct jm obvious ctim ct ct jm concluding case 
applied rule rc defrost 
similar lemma 
case inv interesting cases values newly created reduction 
investigate rc var rc fld rc ass serialize rc freeze rc defrost 
cases rc var rc fld proved induction nm inv nm inv 
interesting case applied rule rc freeze 
assume freeze ct li ct fv vi induction nm inv know side condition fv fv 
fv ct 
cases straightforward induction nm inv 
case inv consider rules store domain variable modified rc dec rc ass rc 
straightforward induction 
case inv consider rules store object id field variables modified rc fld rc rc deserialize 
interesting case applied rule deserialize 
assume deserialize im ctim li download min ctim loss generality consider 
domo 
store fragment generated network nk nk inv induction 
see adding closed fragment closed store im case im closed 
nm inv required 
case inv check applied rule changes store 
applied rule rc dec suppose um li qim im ctim net 
loss generality assume qim 
reduction alexander ahern nobuko yoshida um im ctim 
show fv domv im 
inv holds assumption definition fv fv 
fv clearly domv im definition variable domain fv domv im 
fv argument similar 
vector restricted names um extended domv im um required 
applied rule rc ass 
assumption um li qim im ctim net um li qim im ctim li um li qim im ctim 
loss generality qim 
show fv domv 
inv fv fv 
assumption domv im um 
reduction trivially fv domv im vector restricted names preserved domv im um 
applied rule deserialize 
case straightforward store changes know lemma graph computation lemma store appended contains variables 
domv im domv im fv download min domv im um required 
applied rule rc 
loss generality take qim 
um li im ctim def net um li return return im ctim show fv return return domv im um 
note fv return return fv definition substitution 
domv im domv im domv im domv im um 
assumption initial network typed conclude ctim ok mbody ct fv 
clearly domv im finishing case 
case inv nm inv investigate applied rules terms values classes transferred different locations 
sub cases 
applied rule rn leave 
suppose pim go qim 
chan remote 
ii vi oi oi ci vi 
note ii uses induction nm inv 
applying rn leave fv vi holds completing nm inv 
applied rule rn return 
similar sub case 
case inv inv inv inductive hypothesis 
case inv proof inv consider cases applied rule rn leave rn return 
derived ii proof inv 
formal analysis distributed object oriented language runtime case inv investigate case applied rule deserialize 
mechanical similar reasoning case inv 
case inv obvious apply garbage collection 
case inv inv inv 
case inv suppose pim qim 
rc im 
know fn pim lemma shape pim dom ctim dom ctim required 
case inv consider case field access 
case field assignment just 
cases case pim pim 
applied context networks 
case obvious assumption 
case pim qim pim qim 
interesting cases applied rule rc var rc fld rc new deserialize 
show cases rc var rc new 
suppose applied rule rc var 
qim im ctim li qim im ctim im typable te fld know local im ok im rc var local 
hypothesis pim satisfies inv inv 
inv exists km 
inv fn im implies means dom im desired 
suppose applied rule rc new 
new qim im ctim li qim im ctim obviously dom im 
case deserialize similar 
applied rule rc 
im ctim li return return im ctim im 
mbody ctim 
fn pim implies substituted means im required 
case inv inv straightforward definition analysis tt res tt await tt return tt 
derive progress properties immediately invariants 
note linear invariants guarantee determinacy remote method invocation return points strengthening usual progress properties prog 
alexander ahern nobuko yoshida definition progress invariants 
network li pi cti assuming define property prog set satisfy condition 
class 
pi new qi dom cti 
pi download lk qi ci dom cti dom 

pi resolve min qi ci dom cti 
field 
pi fi qi fields 
pi fi qi fields variable 
pi qi dom 
pi qi dom method invocation 
pi qi 
mbody cti defined 

pi go qi dom 
return 
pi go qi pk await qk 
explain properties briefly class 
class availability classes available instantiation 

download locates required classes download operations succeed retrieving required classes specified location 

resolution coherent attempt resolve classes available local class table 
field 
field access availability locality attempt invoke field access store class store provide field 

field assignment availability locality attempt invoke field access store class store provide field 
variable 
variable access availability locality expressions access variables local 

variable assignment availability locality expressions assign variables local 
method invocation 
objects understand messages attempt invoke method object class class provide method 

remote invocations destination remote method invocations refer unique live location network 
return 
linear return method return exists exactly location waiting channel 
formal analysis distributed object oriented language runtime proposition progress 
assume init nm nk net nm nm implies nm prog 
proof 
immediately prog derived inv 
prog monotonicity class tables 
prog obvious rn download 
prog prog proved inv inv respectively 
prog prog obvious inv 
prog derived inv 
prog combining inv inv 
prog straightforward combining inv inv 
type soundness section proves subject reduction theorem 
corollary derive network invariants progress properties 
key points proof theorem sequential languages directly network invariants definition section cases code mobility freeze defrost remote method invocations field access secondly linearity channels cases parallel compositions threads networks correctness class object graphs lemmas ensure typability thunks serialised objects 
proof method section assume step paragraph proof method invariants prove step subject reduction theorems 
start expression 
theorem subject reduction expressions 
assume ok ct ok suppose ct ct err 
ok ct ok proof 
induction derivation case analysis final typing rules 
proofs laid manner definition configuration reduction definition configuration reduction premises conditions held reduction take place 
omit prove ok ct ok stores class tables unchanged reduction 
case rc var def ct def ct shape expression typing rule applied te var 
states assumption ok immediately apply lemma conclude case rc cond def ct def ct consider case boolean test true case identical 
structure typing rule applied te cond premise required 
alexander ahern nobuko yoshida case rc fld def fi ct def vi ct assuming satisfies prog dom 
premise rc fld 
proof straightforward lemma assumptions fi ti ok side condition 
obtain judgement vi case rc seq def ct def ct ti completing case 
premise rc seq states ct ct 
structure typing rule applied te seq premises void side condition apply lemma obtain inductive hypothesis ok ct ok finishing case 
case rc dec def ct def ct premise rc dec domv 
shape typing rule applied te dec premises gives type preservation immediately 
assumption ok side condition domv apply lemma obtain ok case rc ass def ct def ct examining typing rule applied te ass premises type preservation immediate 
applying lemma premises assumption ok derive ok case rc def fi ct def fi ct shape typing rule applied expression te giving judgement fi premises fi ti ti 
immediately derives type preservation 
show new store formed 
order derive premise rule te fld premises fields tp 
note assuming satisfies prog dom 
assumptions ok rc apply lemma obtain fi ok finishing case 
case rc new formal analysis distributed object oriented language runtime def new ct def ct premise rc new states fields dom ct 
examining structure rule applied derivation new te new premises tp fields ti 
oid derives env 
possible apply tv oid derive shows type preservation 
remains show new store formed 
premises assumption ok apply lemma obtain ok required 
case rc newr def new cm ct def download ct premise rc newr dom ct 
case straightforward examining structure rule applied te new 
judgement form new premises application te derive download new concluding case 
case rc cong def ct def ct rc cong side conditions ct ct 
straightforward lemma 
case serialize def serialize ct def ct premises serialize og vi domo 
shape assumptions conclude typing rule applied te serialize 
gives judgement serialize ser condition assumptions ok og vi apply lemma soundness object graph computation obtain ok set ok note lemma object identifiers store instances local classes establishing local ci 
tv blob gives ser 
weakening lemma derive ser desired 
alexander ahern nobuko yoshida case deserialize def deserialize ct def download min ct oi dom 
structure shows expression typing rule applied te deserialize giving judgement deserialize derived premise ser 
infer tv blob employed premises local ci ok domo 
lemma implied judgement env derived oi ci tv oid 
check ok imply fi tp oid tv oid 
application te leads download min formedness store note ok domo imply domo domo 
lemma obtain ok completing case 
case rc resolve def resolve ct def download ct premise rc resolve ct ci class ci extends di dom ct 
examining typing rule applied te resolve conditions tp ct ok apply te show tp proved immediately premise wf sig 
case rc freeze def freeze eager ct def ct side conditions rule state fv vi xi cg ct fcl 
assume mode operation case similar 
proof network invariant property inv definition 
examining structure see typing judgement expressions freeze eager thunk result application te freeze 
rule premises fav ui ti local ti 
initial assumptions ok domv case form 
knowing apply lemma derive vi vi xi ti 
apply lemma substitution obtain fav note network invariant property inv closed allows conclude side condition 
complete case show ct ok assumptions know ct ok ct cg ct fcl 
fact classes fcl formed class signature csig apply lemma formal analysis distributed object oriented language runtime correctness class graph computation deduce ct ok apply tv thunk obtain ct thunk 
thunk thunk concludes case 
case rc defrost def defrost ct def ct ct premises rc defrost state fcl dom ct 
structure expression see typing rule applied te defrost giving judgement defrost ct derives premise ct thunk order infer thunk tv thunk conditions ct ok straightforwardly deduce order complete case show tp obtained side condition rc defrost 
ct ct ok follows directly network invariant inv definition 
case rc def download ct def ct premise rc ci dom ct 
proof straightforward 
examining see typing rule applied te premise immediately yields type preservation 
theorem subject reduction threads 
assume conf err 
conf 
proof 
induction derivation case analysis final typing rules 
case rc res def ct def ct consider case reduction occurs restricted channel name cases object identifiers variables similar 
chan 
premises rc res ct ct 
examining shape cases 
case applied rule tc 
chan ct conf inductive hypothesis chan ct conf 
apply tc obtain required result 
second case applied rule tt weak chan conf premise conf 
inductive hypothesis conf 
noting fn application tt weak gives chan conf 
case applied rule tt weak trivial omit case analysis 
alexander ahern nobuko yoshida case rc str suppose case follows straightforwardly proof lemma structural equivalence preserves typing 
case rc par def ct def ct premises rc par ct ct 
case similar rc cong treatment channel environments 
examining structure configuration see thread typing rule applied tt par 
gives judgement form thread premise pi thread 
premise rule know chan thread 
note ui 
apply weakening lemma order obtain thread 
apply tt par tt res derive ct 
case rc def ct def await ct rc fresh domo 
inspecting structure configuration rule applied contexts giving rise judgement thread 
lemma assume rule premises thread 
choosing fresh channel name apply tt await infer await thread dom 
see premise inferred rule te meth conditions mtype ti 
picking channel name apply tt order derive chano thread 
important note chano definition fact dom 
apply tt par obtain chan await thread 
case rc def ct def await go serialize ct premises rc fresh domo 
loss generality set 
initial parts case similar case rc 
network invariant property inv definition 
shape similarity case local method calls choose similarly fresh immediately conclude await thread dom see te meth applied derivation premises mtype ti 
formal analysis distributed object oriented language runtime assumption domo network invariant property inv case remote 
premises apply rule tt derive chano go serialize thread remote 
chano apply tt par derive chan await go serialize thread completing case 
case rc def ct def return return ct application rc 
mbody ct 
shape rule applied type thread component tt thread 
inferred premises mtype vi ti 
assumption ok apply lemma obtain env 
choosing dom assumption ok vi ti lemma extends store new variable bindings ok show preservation thread type 
assumption ct ok ret alpha conversion choose vector chosen prove formedness new store apply weakening obtain assume dom 
apply weakening ret derive ret 
premises apply lemma obtain ret apply tt return giving chano return return thread complete case 
case dom similar lemma obtain ret 
case rc await def await return ct def ct examining structure thread typing rule applied tt par 
supposing chan await return thread 
order derived premises hold await thread return thread chano 
environment trivially reordered reordering lemma 
derive premise tt await form conditions thread dom 
derive second premise tt return premise return ret likewise derived te return premise alexander ahern nobuko yoshida apply reordering environment obtain lemma weakening obtain thread finishing case 
theorem subject reduction networks 
assume net err 
net 
proof 
induction derivation case analysis final typing rule applied 
case rn conf def def premises rn conf structure see typing rule applied tn conf premise conf 
assumption apply theorem obtain conf 
re apply tn conf deduce net required 
case rn par def def structure see typing rule applied tn par 
inferred premises net net supposing 
apply inductive hypothesis obtain net 
apply tn par derive net completing case 
case rn res def def rn res consider case restricted name channel 
case identifiers similar 
suppose typing rule applied tn 
inferred premise chan net 
apply inductive hypothesis giving chan net 
apply tn obtain net required 
case rn str suppose follow straightforwardly proof lemma 
case rn download def download ct ct def resolve ct ct ct premises rn download dom ct ct ct 
loss generality assume 
case uses invariance inv definition 
formal analysis distributed object oriented language runtime examining structure typing rule applied tn par 
supposing premises hold download ct net ct net 
premise see derived eventually facts download thread ct ok structure judgements deduce rule te condition tp 
second premise ultimately derived ct ok condition ct ct infer ct ok renaming ci affect formedness 
invariant inv definition know dom ct dom ct non empty overlapping classes definition 
means immediately derive ct ct ok complete case rebuild network tc conf tn par 
case rn leave def go ct ct def ct deserialize ct premise rn leave states domo shall prove ct deserialize ct net derive net typing rule applied tn par premises go ct net ct net assumption 
order derive ultimately shown go thread thread thread straightforward construct rule tc conf ct net constructing second location difficult 
lemma obtain 
fact apply tt par obtain go thread 
apply tc conf followed tn par obtain required 
case rn return def go ct ct def ct return deserialize ct alexander ahern nobuko yoshida fn premise rn return 
case rn leave 
achieve corollary network invariants progress properties 
inv prog network invariants initial property init defined definition 
final corollary specifies form network threads terminate 
corollary normal forms 
assume init err 
li pi cti pi ji ni go ji ji proof 
induction initial condition init set chan ci chano ui 
proof direct progress properties 
investigate cases reduction happens different networks 
suppose example contradiction exists pi pi qi 
local object id prog 
assume remote id domo 
time rc contradiction 
suppose exists pi pi go qi chan 
prog exists pk await qk 
apply rn return contradiction 
unicity go ji ji derived inv 
cases mechanical 
related obliq distributed object lexically scoped language proposed cardelli 
key feature language methods stored objects hierarchy tables inspect class languages 
class loading mechanism consider forms important part dj 
hand obliq code passing primitives procedures agents passed value executed obliq treats local variable assignment passed code feature consistently added dj relaxing te freeze variable store invariants definition 
dj models important concerns distributed classbased missing obliq dynamic class loading serialisation term refers serialisation sense transaction theory 
important difference semantics obliq informal manner terms examples dj formal operational semantics precise examination new primitives 
result established typing system type soundness may done obliq far 
encode obliq untyped calculus 
encoding show flaw part original migration semantics propose repair 
orthogonal sense offers direct formal semantics typing system language level detailed analysis subtle interplay distributed features including inheritance possible 
formal analysis distributed object oriented language runtime interesting find appropriate typed ho calculi dynamics types dj encoded faithfully 
gordon hankin extend object calculus explicit concurrency primitives calculus 
focus synchronisation primitives fork join distribution single location 
reason calculus class treat dynamic class loading serialisation main interests 
jeffrey treats extension study locality static dynamic type checking 
aim quite different treat dynamic class loading object serialisation treats transactional serialisation 
zhao propose sj calculus study containment real time java 
provide primitives explicit memory management crucial context 
sj calculus proposes new typing discipline idea scoped types memory real time applications allocated strict hierarchy scopes 
existing java package structure divide scopes propose typing system statically prevent scope invariants broken 
formalism similarities dj models extension imperative java calculus fj 
study focuses real time concurrency single location dynamic distribution code multiple locations 
dj guarantees similar scoping properties invariants example inv definition ensures identifiers local objects leak locations 
ohori kato extend purely functional part ml primitives remote higher order code evaluation channels show type system language sound respect low level calculus 
low level calculus equipped runtime primitives closures functions creation names 
focus pure polymorphic functions treat side effects distributed object oriented features serialisation code passing associated inheritance class downloading subtle interplay main concern 
representation runtime formal semantics limited distributed programs analysis execution model net clr gordon syme yu 
project implementation seal calculus java 
realised api run time system inside jvm targeted programming framework building multi agent systems 
semantics apis depend distributed primitives implementation language precisely target formal analysis 
may offer suggestion implementation security treatment thunk passing proposed 
class loading downloading crucial useful java rmi applications offer convenient mechanism distributing code remote consumers preserving type safety 
orthogonal subject class verification maintenance type safety linking 
formulation class loading simple modular example modifying class graph definition definition follows verification framework consistently replaced class loading mechanism alexander ahern nobuko yoshida verification 
example rule rc resolve vector constructed direct superclasses classes resolved 
java verification checks subtypes method receivers method parameters approximation extend include class names method declaration formal parameters 
set class invariant inv definition simplicity easily relax allow situation programs take advantage example latest version library recompilation new version binary compatible old 
control different situations distributed binary compatibility invariants guidance consistent refinements operational semantics typing systems 
literature surrounding class loading practice takes lazy approach 
discussed earlier setting remote method invocation laziness expensive due delay involved retrieving large class hierarchy network 
propose class splitting pre fetching algorithm reduce latency 
specific example applet loading time spent interactive portion applet download classes may needed better download ahead time user encounter large delay sharing motivation eager thunk primitive 
partly eager class loading approach implicit requires control flow information program question order determine insert instructions trigger ahead time fetching 
framework may difficult apply general distributed setting clients may access code remote server 
approach merely mitigates effect network delay removing requires sequential request hierarchy superclasses 
believe explicit thunk primitive proposed may offer effective alternative situations 
introduced java core language constructs distribution including dynamic class loading serialisation formal semantics typing system established basic safety properties invariants 
new language primitive distribution thunk passing proposed consistently integrated language simple typing rule 
invariants prescription global local state language runtime system designer expects guaranteed satisfied implementation correct strengthen typing rules relax prescription 
example field access local modified ordinal field access typing rule adding constraint local te fld guided value object identifiers invariants section 
class language considered include language features casting exceptions synchronisation polymorphism 
features represented straightforward enrichment syntax types precise interplay distributed language constructs needs examination 
important topic enrichment invariants type formal analysis distributed object oriented language runtime structures strengthen safety properties security 
orthogonal directions 
concerns mobility 
seen second example section current type structure thunk thunk int tells consumer little behaviour code execute dangerous 
java appropriate policy file ensure code downloaded remote sites restricted capability 
extending dj principals examine originator piece code prior execution determine suitable privileges 
ensure integrity resources dynamically check invariant code arrives adding constraint rc defrost adding fine grained information accessibility methods class signatures line static checking 
second issue extend syntax operational semantics allow complex structured communications 
purpose studying session types ensuring correct pattern matching sequences socket communications incorporating new class channels user syntax level 
operational semantics rmi smoothly extensible model advanced communication protocols 
session types designed class signatures safety proved invariance properties developed 
study semantics failure recovery framework important topic 
far incorporated possibility failures remote invocation due network partition defined err rules fig 
consideration recover errors 
class network errors considered cover problems duplication method calls return values lost situation notion time generally determine re transmit fail different invocation semantics example investigated dj 
intend implement new primitives code mobility 
initial version probably take form source source translator compiling freeze defrost operations standard java source 
eager class loading rmi require modification class loading mechanism installing custom class loader conjunction translated source 
approach advantage ordinary java compiler existing tools jvm need modification 
direct approach example extending virtual machine may yield better performance 
examples section lead question expressiveness serialisation freezing constructs programs semantically equivalent sense executions involve error state derive result 
ongoing investigating behavioural equivalences language technique established calculus 
correctness source translation mentioned investigated developed theory 
study line worthwhile considering optimisations rmi interaction patterns articulations comparisons newly proposed language constructs basis formal semantic foundations 
alexander ahern nobuko yoshida dezani sophia drossopoulou going collaboration sessions types 
luca cardelli susan eisenbach kohei honda paul kelly members slurp group discussions 
author partially supported epsrc phd studentship second author partially supported epsrc advanced fellowship gr epsrc gr gr gr 

metaml home page 
www cse ogi edu projects metaml 

martn abadi luca cardelli 
theory objects 
springer verlag 

davide ancona giovanni elena zucca 
simplifying types calculus java exceptions 
technical report disi universit di genova 

gavin bierman matthew parkinson andrew pitts 
mj imperative core calculus java java effects 
technical report university cambridge computer laboratory april 

gilad bracha martin odersky david stoutamire philip wadler 
making safe past adding genericity java programming language 
proceedings oopsla october 

luca cardelli 
obliq language distributed scope 
technical report systems research center digital equipment 

microsoft 
net framework developer guide 
msdn microsoft com net 

george jean tim kindberg 
distributed systems concepts design 
addison wesley 

sophia drossopoulou 
advanced issues object oriented languages course notes 
www doc ic ac uk scd teaching html 

sophia drossopoulou susan eisenbach 
manifestations dynamic linking 
workshop unanticipated software evolution spain june 
joint org proceedings html 

sophia drossopoulou giovanni susan eisenbach 
flexible models dynamic linking 
degano editor th european symposium programming volume lecture notes computer science pages 
springer verlag april 

cormac flanagan qadeer 
type effect system atomicity 
pldi proceedings acm sigplan conference programming language design implementation pages 
acm press 

andrew gordon paul hankin 
concurrent object calculus reduction typing 
technical report university cambridge computer laboratory february 

andrew gordon don syme 
typing multi language intermediate code 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 

kohei honda 
composing processes 
proceedings popl pages 

kohei honda vasco vasconcelos makoto kubo 
language primitives type disciplines structured communication programming 
esop volume lecture notes computer science pages 

kohei honda nobuko yoshida 
reduction process semantics 
tcs 

atsushi igarashi benjamin pierce philip wadler 
featherweight java minimal core calculus java gj 
acm transactions programming languages systems 
formal analysis distributed object oriented language runtime 
ecma international 
ecma iso common language infrastructure standards 
msdn microsoft com net ecma 

alan jeffrey 
distributed object calculus 
fool 
acm press 

naoki kobayashi benjamin pierce david turner 
linear types calculus 
proceedings popl pages 

chandra brad calder urs lzle 
reducing transfer delay java class file splitting prefetching 
proceedings th acm sigplan conference objectoriented programming systems languages applications pages 
acm press 

sheng liang gilad bracha 
dynamic class loading java virtual machine 
proceedings th acm sigplan conference object oriented programming systems languages applications pages 
acm press 

massimo uwe nestmann 
mobile objects mobile processes 
information computation 

sun microsystems discover secrets java serialization api 
java sun com developer programming serialization 

sun microsystems java remote method invocation rmi specification 
java sun com se docs guide rmi spec html 

robin milner 
functions processes 
mscs 

robin milner joachim parrow david walker 
calculus mobile processes parts ii 
info 
comp 

atsushi ohori kato 
semantics communication primitives polymorphic language 
popl proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 

benjamin pierce 
types programming languages 
mit press 

qian allen goldberg alessandro coglio 
formal specification java class loading 
proceedings th acm sigplan conference object oriented programming systems languages applications pages 
acm press 

davide sangiorgi 
expressing mobility process algebras order higher order paradigms 
phd thesis university edinburgh 

vasco vasconcelos ant nio simon gay 
session types functional multithreading 
concur volume lecture notes computer science pages 

jan vitek bryce walter binder 
designing java safe agents 
electronic commerce objects 

dan wallach andrew appel edward felten 
security mechanism language systems 
acm transactions software engineering methodology 

dan wallach dirk balfanz drew dean edward felten 
extensible security architectures java 
proceedings sixteenth acm symposium operating systems principles pages 
acm press 

kwok yeung paul kelly 
optimizing java rmi programs communication restructuring 
middleware volume lecture notes computer science pages 

nobuko yoshida 
channel dependency types higher order mobile processes 
popl conference record st annual symposium principles programming languages pages 
acm press 
full version available www doc ic ac uk yoshida 

yu andrew kennedy don syme 
formalization generics net common language runtime 
popl proceedings st acm sigplan sigact symposium principles programming languages pages 
acm press 
alexander ahern nobuko yoshida 
tian zhao james noble jan vitek 
scoped types real time java 
proceedings th annual ieee symposium real time systems 
formal analysis distributed object oriented language runtime operational semantics appendix lists operational semantics section look functions defined section 
equivalences configurations ct ct fn fn ct ct ct fv ct ct fn fn threads networks fn return return return return lookup functions fields ob ject csig extends remote mi ti ui mtype mi ti ct class extends um mbody ct field lookup csig extends mi ti ui fields method type lookup fields csig extends remote mi ti ui method body lookup valid method overriding mtype mtype ct class extends um mbody ct mbody ct mtype implies override alexander ahern nobuko yoshida expression rc var ct ct rc fld fi ct vi ct rc cond iftrue ct ct iffalse ct ct rc seq ct ct ct ct rc dec ct ct domv rc ass ct ct rc new fields new ct ct rc ct ct dom ct domo rc newr new ct download ct dom ct rc cong ct ct ct ct method invocation rc ct await ct fresh domo rc ct await go serialize ct fresh domo rc 
mbody ct ct return return ct rc await await return ct ct rn return ct ct fn rn leave go ct ct ct deserialize ct rn return go ct ct ct return deserialize ct domo fn serialisation formal analysis distributed object oriented language runtime serialize og vi domo serialize ct ct deserialize oi dom deserialize ct download min ct code creation rc freeze fv vi xi ct cg ct fcl eager lazy freeze ct ct ct rc defrost fcl dom ct defrost ct ct ct ct class downloading rc resolve ct ci class ci extends di dom fct resolve ct download ct rn download dom ct fcl ct ct ct download ct ct resolve ct ct ct rc ci dom ct download ct ct threads rc par ct ct ct ct rc res ct ct ct ct rc str alexander ahern nobuko yoshida network rn conf errors rn par err null ct error ct err null ct error ct rn res rn str err null ct error ct err download dom ct ct ct fcl ct download ct ct error resolve ct ct ct err go ct ct error ct ct domo err go ct ct error ct ct fn typing system appendix presents typing systems 
types tp wf base void tp bool tp chan tp wf sig wf sc tp csig tp chano tp ret tp thunk tp override mi di ti ui tp ti 
tp dom csig extends remote mi ti ui tp wf vec ui tp tp wf ser tp ser tp wf ctp csig tp tp wf csig dom csig tp csig ok subtyping st refl st expr formal analysis distributed object oriented language runtime st trans thunk thunk ret ret environments env nil env env stores env ok values tv bool env true bool false bool tv thunk ct ok var tp dom env chan tp env dom env st vec ui st ser ser ser st class csig extends remote mi ti ui oid tp dom env var ok domv ok tv null tp null thunk tp dom env var ok domo fields vi ti tv oid env tv empty env void tv blob local ci ok domo ser alexander ahern nobuko yoshida expressions te var env te fld tp local fields fi ti te ass te meth mtype ti te serialize serialize ser te ser deserialize te tp download resolve te env te seq void te te return return ret te deserialize ser deserialize te freeze fav ui ti local ti freeze thunk te pe pe pe void te cond bool te hole tp te dec te new fields ti ei tp new te env return ret void te defrost thunk defrost formal analysis distributed object oriented language runtime threads chan thread tt nil env thread tt par pi thread thread tt await thread dom await thread tt return ret chano return return thread tt weak thread dom chan thread tt res chan thread thread tt remote mtype chano go serialize thread tt vi ti mtype chano thread tt ser remote mtype chano deserialize thread chano go thread tt local chano thread chano go thread configuration chan conf tc chan conf conf tc resid conf dom conf tt goto ser chano go eto thread tc conf thread ok ct ok fct ct ct conf alexander ahern nobuko yoshida network chan net tn nil env net tn weak net dom chan net tn conf conf net tn resid net dom net method ok class ok ok mtype ret um class table ct ok ct nil ok tn par ni net dom dom loc loc net tn chan net net ok fields fields super class extends ok ct class extends ok ct ok ct class extends ok 
