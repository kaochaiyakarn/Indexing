fundamenta informaticae special issue graph tree mining accepted ios press frequent subtree mining overview yun chi department computer science university california los angeles ca usa cs ucla edu richard muntz department computer science university california los angeles ca usa muntz cs ucla edu siegfried nijssen leiden institute advanced computer science leiden university niels ca leiden netherlands nl joost kok leiden institute advanced computer science leiden university niels ca leiden netherlands joost nl 
mining frequent subtrees databases labeled trees new research field practical applications areas computer networks web mining bioinformatics xml document mining applications share requirement expressive power labeled trees capture complex relations data entities 
frequent subtree mining difficult task frequent itemset mining existing frequent subtree mining algorithms borrow techniques relatively mature association rule mining area 
provides overview broad range tree mining algorithms 
focus common theoretical foundations current frequent subtree mining algorithms relationship counterparts frequent itemset mining 
comparing algorithms categorize problem definitions techniques employed solving various subtasks subtree mining problem 
addition thorough performance study representative family algorithms 
keywords frequent subtree mining canonical representation priori enumeration tree subtree isomorphism authors partly supported nsf nos 

correspondence author chi nijssen muntz kok frequent subtree mining overview 
data mining goal discover useful previously unknown knowledge massive data expanding rapidly theory applications 
trend data mining research consider complex cases representable normalized single table relational databases xml databases multi table relational databases molecular databases graph databases 
databases containing complex data types require practical theoretical problems solved due relationships entities introduced 
general formalisms modeling complex structured data graph 
graphs general undesirable theoretical properties regard algorithmic complexity 
terms complexity theory currently efficient algorithms known determine graph isomorphic subgraph 
furthermore efficient algorithm known perform systematic enumeration subgraphs graph common facet data mining algorithm 
expect general graphs pose serious efficiency problems 
fortunately practical databases consist graphs require exponential computations 
root complexity graph algorithms existence cycles graph 
cases number cycles graph instances database limited graphs may acyclic 
case especially interesting graphs trees efficient algorithms known class graphs 
study tree mining algorithms may reveal insights approaches taken deal databases containing graphs instances cycles practical point view yielding formal complexity bounds 
review data mining algorithms introduced years mining frequent subtrees databases labeled trees 
give overview theoretical properties algorithms provide results experiments tree miners compared set frequent graph miners 
results provide clearer picture important properties algorithms suggest directions research field frequent structure mining 
importance graph mining reflected large domain applications computer networking web mining bioinformatics multi relational data mining xml document mining frequent tree mining algorithms involved applications ways gaining general information data sources user faces new data set know characteristics data set 
presenting frequent substructures data set help user understand data set give user ideas specific queries learn details data set 
example wang applied frequent subtree mining algorithm database containing internet movie descriptions discovered common structures movie documentation 
directly discovered frequent substructures cui showed potential application discovering frequent subtrees network multicast routing 
concurrent multicast groups network storing routing tables groups independently requires considerable space router 
possible strategy partition multicast groups build separate routing table partition 
frequent subtrees multicast routing trees different multicast groups offer hints form partition 
chi nijssen muntz kok frequent subtree mining overview constraint mining showed additional constraints incorporated free tree miner biochemical databases 
extending free tree miner mine molecular databases tree shaped molecular fragments frequent active molecules infrequent inactive molecules 
frequently occurring fragments provide chemists insight quantitative structure activity relationships 
association rule mining commercial online book seller information user patterns navigation web site structure important 
example association rule online book seller may find interesting web logs visitors web page book visited customer evaluation section book description section table contents book subsection book description section association rule provide book seller insights help improve web site design 
classification clustering data points classification clustering algorithms labeled trees 
considering frequent trees features data points application standard classification clustering algorithms possible 
example web logs web site obtain access patterns access trees visitors 
access trees classify different types users casual vs serious customers normal visitors vs web crawlers 
example zaki algorithms classify xml documents subtree structures 
helping standard database indexing access methods design frequent substructures database labeled trees provide information efficiently build indexing structures databases design efficient access methods different types queries 
example yang algorithms mining frequent query patterns logs historic queries xml document 
answers discovered frequent queries stored indexed efficient query answering 
tree mining step efficient graph mining nijssen investigated tree mining principles deal general problem graph mining 
enhanced tree mining algorithm shown efficient known efficient frequent graph miner 
algorithms proposed discover frequent subtrees databases labeled trees 
algorithms vary specific problem formulations solution details 
similar aspects 
proposed frequent subtree mining algorithms borrow techniques area market basket association rule mining 
overview tree mining algorithms introduced 
focus algorithmic theoretical differences algorithms 
categorize algorithms problem definitions techniques solve various aspects subtree mining tasks expose common techniques distinct features 
rest organized follows 
section review necessary theoretical background terminology 
section survey current algorithms mining frequent subtrees 
section discuss related 
section give thorough performance study representative family algorithms 
section give research directions conclude 
chi nijssen muntz kok frequent subtree mining overview 
background section provide necessary background information 
give overview basic concepts graph theory discuss different types labeled trees different types subtrees 
frequent tree mining algorithms borrow ideas frequent itemset mining algorithms conclude section review types frequent itemset mining algorithms effectively frequent subtree mining 

graph concepts labeled graph consists vertex set edge set alphabet vertex edge labels labeling function assigns labels vertices edges 
graph directed edge ordered pair vertices undirected edge unordered pair vertices 
path list vertices graph pair neighboring vertices list edge graph 
length path defined number edges path 
cycle path vertices path 
graph acyclic graph contains cycle 
undirected graph connected exists path pair vertices disconnected 
types trees 
introduce unrooted unordered trees free trees rooted unordered trees rooted ordered trees 
order listed types trees increasing topological structure 
free tree free tree undirected graph connected acyclic 
free trees properties easily shown example single path pair vertices 
rooted unordered tree rooted unordered tree directed acyclic graph satisfying distinguished vertex called root entering edges vertex exactly entering edge unique path root vertex 
rooted unordered tree vertex path root vertex ancestor descendant addition parent child vertices share parent siblings 
vertex descendant called leaf 
depth level vertex defined length path root node 
rooted ordered tree rooted ordered tree rooted unordered tree predefined ordering set siblings 
order implied left right order figures illustrating ordered tree 
rooted ordered tree define left right siblings vertex leftmost rightmost child sibling size tree denoted defined number vertices tree 
call tree size tree 
forest set zero disjoint trees 
free trees rooted unordered trees define isomorphisms trees 
labeled free trees isomorphic mapping chi nijssen muntz kok frequent subtree mining overview vertices vertices preserves vertex labels edge labels adjacency 
isomorphisms rooted unordered trees defined similarly mapping preserve roots 
automorphism isomorphism maps tree 
different types trees different notions subtrees 
give types subtrees 
bottom subtree see 
rooted tree ordered unordered vertex set edge set say rooted tree ordered unordered depending vertex set edge set bottom subtree labeling preserved vertex descendants ordered left right ordering siblings preserved intuitively bottom subtree root obtained vertex descendants corresponding edges 
induced subtree tree types vertex set edge set say tree vertex set edge set induced subtree labeling preserved defined rooted ordered trees left right ordering siblings corresponding vertices intuitively induced subtree obtained repeatedly removing leaf nodes possibly root node child embedded subtree rooted unordered tree vertex set edge set labels edges say tree vertex set edge set labels edges embedded subtree labeling nodes preserved parent ancestor rooted ordered trees embedded subtree fourth condition hold preorder preorder preorder preorder preorder node index tree preorder traversal 
intuitively embedded subtree break relationship vertices 
different types subtrees gives examples types subtrees 
tree left tree bottom subtree tree induced subtree bottom subtree tree embedded subtree bottom subtree induced subtree 
relationship types subtrees follows definitions bottom subtree induced subtrees embedded subtrees 
subtree bottom subtree induced subtree embedded subtree say 
chi nijssen muntz kok frequent subtree mining overview 
canonical representations labeled trees canonical representations labeled trees closely related data structures store trees memory disk files 
standard data structures adjacency matrix adjacency list child sibling representation tree mining algorithms representations reasons 
canonical representations compact standard data structures save space 
second importantly types labeled trees labeled free trees labeled rooted unordered trees multiple ways represent tree standard data structures 
canonical representation unique way represent labeled tree 
especially unordered trees free trees choice canonical representation far reaching consequences efficiency total tree miner 
canonical representation facilitates functions comparing trees equality enumeration subtrees 
section briefly review various canonical representations rooted ordered trees rooted unordered trees free trees respectively 
detail refer reader original publications cited section 
simplicity remaining sections specified trees labeled 
addition edge labels subsumed loss generality labels corresponding nodes seen shortly true rooted trees free trees ignore edge labels discussion 
string encodings rooted ordered trees introduced recursive definition pre order string rooted ordered tree single vertex pre order string st lr lr label single vertex rooted ordered tree vertex assuming root label lr children rk left right pre order string st str str str pre order strings bottom subtrees tr trk rooted rk respectively 
pre order string rooted ordered tree st abd cg 
advantage pre order string easily compute pre order string bottom subtree total pre order string 
example scan st label get equal number vertex labels symbol resulting substring bd exactly pre order string bottom subtree rooted useful property bottom subtree matching problem reduced substring matching problem solved efficiently algorithms string matching suffix array data structure 
shown string encoding space efficient traditional data structures storing rooted ordered trees 
similar encodings zaki chi 
asai nijssen independently defined equivalent encoding rooted ordered trees depth sequences 
encoding depth vertex explicitly recorded string 
pre order traversal 
tree asai nijssen string encoding st pair represents vertex number pair depth vertex second symbol vertex label 
string encodings defined asai nijssen chi extended canonical representations rooted unordered trees subsection 
chi nijssen muntz kok frequent subtree mining overview canonical representations rooted unordered trees uses standard data structures adjacency matrix adjacency list sibling representation represent rooted unordered tree faces difficulty specified order children vertex multiple representations tree 
key problem rooted unordered tree derive multiple rooted ordered trees shown 

rooted ordered trees obtained rooted unordered tree rooted ordered trees want uniquely select canonical representation corresponding rooted unordered tree 
defined canonical representation rooted unordered tree sorted pre order string 
sorted pre order string rooted unordered tree defined lexicographically smallest pre order strings rooted ordered trees obtained rooted unordered tree 
determine lexicographical order string encodings total order alphabet vertex labels defined 
rooted unordered tree canonical representation pre order traversal obtained linear time assuming finite alphabet vertex labels adopting aho tree isomorphism algorithm shown 
asai nijssen chi independently defined similar canonical representations 
canonical representations free trees free trees roots uniquely define roots purpose constructing unique canonical representation procedure starting free tree repeatedly remove leaf vertices incident edges single vertex adjacent vertices remain 
case free tree called centered tree remaining vertex called center second case free tree called tree pair remaining vertices called 
free tree centered 
procedure takes linear time 
shows centered free tree free tree procedure obtain corresponding center 
nijssen chi shown free tree centered uniquely identify center designate root obtain rooted unordered tree canonical representation rooted unordered tree obtain canonical representation centered free tree done previous section 
free tree cut free tree pieces rooted canonical string obtained comparing encodings subtrees 
computation canonical string free tree consists steps linear time center chi nijssen muntz kok frequent subtree mining overview centered free tree free tree 
centered free tree free tree free tree determined second resulting rooted trees normalized 
total complexity linear 

mining frequent itemsets section briefly review essential parts frequent itemset mining algorithms 
purpose introduce concepts exploited tree mining algorithms discussing context simpler case itemset mining 
problem definition alphabet items database transactions say transaction supports itemset itemset subset transaction 
number transactions database support itemset called frequency itemset fraction transactions supports called support itemset 
threshold minsup frequent itemset mining problem find set itemsets support minsup 
known property itemsets basis frequent itemset mining algorithms support support 
property called priori property 
example consider minsup 
itemsets easily define canonical string 
canonical string consists simply lexicographically sorted list items canonical string example abd 
candidate enumeration set items itemsets put lattice illustrated 
consequence priori property itemsets frequent itemsets occupy connected portion lattice traversed alternatives breadth depth combination 
level level level chi nijssen muntz kok frequent subtree mining overview breadth traversal depth traversal combined depth breadth traversal 
breadth traversal depth traversal combined depth breadth traversal enumeration lattice breadth approach shown search performed level wise 
itemsets size generated counted frequent itemsets candidate itemsets constructed 
itemsets frequent itemset counting order ab ac ad bc bd cd abc abd acd bcd abcd 
depth approach shown lattice traversed depth 
case itemset generated counted frequent itemset ab generated counted resulting evaluation order itemsets frequent ab abc abcd abd ac acd ad bc bcd bd cd third approach combination depth breadth traversal shown 
itemsets size generated counted 
joined frequent itemsets obtained set itemsets ab ac ad recursively investigated 
itemsets containing item investigated itemsets contain considered 
itemsets frequent order itemset counting ab ac ad abc abd abcd acd ad bc bd bcd cd 
candidate generation set itemsets ways generate initial set candidates size 
approach extend frequent itemset adding items higher lexicographic ordering item itemset 
example frequent itemsets ab ac ad bc bd candidate itemsets formed extension abc abd ab acd ac bcd bc 
extension number candidates clearly large 
strategy depth traversal lattice case choice candidate generation 
candidate generation approach join itemsets 
candidate guaranteed contain frequent subsets 
itemset mining algorithms perform join joining pair itemsets common prefix 
approach itemset ancestors lattice candidates generated 
breadthfirst traversal combined depth breadth traversal usually adopt join candidate generation 
frequency counting frequency candidate itemset needs counted order determine itemset frequent 
frequency counting method direct checking transaction frequency candidate itemsets supported transaction increased 
advanced data structures hash tree expedite direct checking :10.1.1.40.6757
frequency counting method vertical mining algorithms associates occurrence chi nijssen muntz kok frequent subtree mining overview list tid list candidate itemset list tids transactions support 
algorithms frequency itemset simply size occurrence list 
closely related vertical mining approaches database re written compact memory data structure frequent itemsets frequencies extracted data structure knowing transactions itemsets occur 

algorithms mining frequent subtrees section systematically study current algorithms mining frequent subtrees 
formally define frequent subtree mining problem 
type structure study algorithms detail 

mining frequent subtrees problem definition threshold class trees transitive subtree relation trees finite data set trees frequent tree mining problem problem finding trees trees isomorphic freq anti monotone function denote pattern tree tree part output text tree member data set subtree relation defines tree occurs tree simplest choice function indicator function 
simple case frequency pattern tree defined number trees data set contains pattern tree 
call frequency definition closely matches itemset frequency transaction frequency 
indicator function anti monotone due transitivity subtree relation 
transaction frequency easily define transaction support sup freq 
situations pattern tree may multiple occurrences text tree definitions frequency tree possible 
dependent type tree delay discussion frequency definitions 
mentioned assume transaction frequency 
discussion notation summarized table 

mining frequent bottom subtrees study simplest subtree mining problems bottom subtree mining problem 
definition bottom subtree see number bottom subtrees rooted tree size number vertices 
course bottom subtrees distinct 
result solve frequent bottom subtree mining problem straightforward way 
encode database prefix string format chi nijssen muntz kok frequent subtree mining overview number trees data set number distinct labels data set number nodes largest tree data set number nodes largest frequent tree number frequent pattern trees number candidate pattern trees considered algorithm pl largest number trees grow single tree vt number nodes text tree vp number nodes pattern tree vd number nodes database table 
summary complexity notation 
initialize array pointers node database note pointer points root bottom subtree 
sort pointers comparing string encodings subtrees point 
scan array determine frequencies bottom subtrees 
key straightforward solution number bottom subtrees rooted tree bounded vd 
shown method applies rooted ordered trees rooted unordered trees long canonical representations bottom subtrees 
time complexity algorithm vd log vd size largest tree database reasons 
steps take time vd 
step size array pointers bounded vd 
comparison algorithm sorting takes vd log vd comparisons comparison takes time length prefix string 
rooted unordered trees add pre processing step puts transaction database canonical form 
shown time canonical ordering rooted unordered tree size general pre processing step takes vd log 
result vd log vd time complexity applies rooted unordered trees 
note complexity independent choice function defines support 

mining frequent induced embedded subtrees general approach mining frequent induced embedded subtrees brute force method intractable number induced embedded subtrees labeled tree grow exponentially size 
consider rooted tree children root distinct labels 
deal potentially exponential number frequent subtrees frequent subtree mining algorithms induced subtrees embedded subtrees usually follow generate test methods 
simple generate test method assume initially empty tree chi nijssen muntz kok frequent subtree mining overview compute freq determining succ goto 
succ function computes successor tree possible trees maximum size enumerated exactly repeatedly call succ 
course method efficient 
efficient algorithms priori property restrict size search space 
sections reveal details algorithms exactly 
theoretical standpoint simple algorithm interesting straightforward way incorporates problems studied extensively literature 
problem computing tree inclusion relation step 

problem enumerating trees certain class uniquely step ideally worst case complexity subtree mining algorithms higher naive algorithm 
sections naive algorithm set subtree miners perspective 

rooted ordered embedded subtrees treeminer treeminer algorithm developed zaki mining frequent ordered embedded subtrees follows combined depth breadth traversal idea discover frequent embedded subtrees database rooted ordered trees 
general downward closure property subtrees frequent tree frequent treeminer takes advantage useful property string encodings rooted ordered trees removing vertices string encoding rooted ordered tree correspondent adjustment number backtrack symbols result string encoding valid embedded subtree illustrated 
vertices removed results 
please note removal second vertex yields tree considering embedded subtrees 
tree induced subtree grow mining induced subtrees 
abc abc abc de abc ed abc 
join rooted trees consists 
abc discussion follows candidate subtree obtain subtrees 
obtained removing vertex string encoding obtained removing second vertex string encoding 
addition chi nijssen muntz kok frequent subtree mining overview see share prefix string encoding th vertex share prefix 
easier see relationship subtree generating candidate subtrees relationship exploited generate candidate subtree joining frequent subtrees 
properties treeminer able follow combined depth breadth traversal candidate subtrees obtained joining frequent embedded subtrees string encodings share prefix th vertices 

example database 
part enumeration lattice gives running example database consisting transactions transaction ids respectively 
simplicity assume minimum support 
shows part enumeration lattice contains frequent subtrees prefix frequent subtrees ab prefix 
see candidate generation treeminer similar combined depth breadth lattice traversal frequent itemset mining 
support counting treeminer uses method database rewritten vertical representation scope lists 
frequent subtree size corresponding scope list records occurrences occurrence scope information node pre order walk called rightmost vertex 
element scope list triplet represents transaction id occurrence list vertices database nodes pre order walk mapped represents scope rightmost vertex vertex text tree transaction scope interval determined pair numbers 
number represents index pre order traversal second number represents index rightmost child bottom subtree induced shows database scope vertex 
considering scope interval scopes sv sv vertices text tree disjoint intervals means ancestor descendant relationship interval subinterval means vertex smaller scope descendant vertex 
shows join step uses scope list data structure 
scope lists frequent subtrees joined get scope list resulting candidate subtrees 
elements scope list determine elements scope lists joinable determines shape resulting candidate subtrees 
size scope list treeminer may larger size text tree illustrated 
example text tree consists vertices connected root vertices abusing term lattice defining upper bound greatest lower bound subtrees 
chi nijssen muntz kok frequent subtree mining overview 
scopes vertices 
scope list join 
pattern tree text tree number occurrences exponential label clearly number subtrees text tree small total different subtrees 
size scope list exponential size consider right hand pattern tree consists nodes 
different subsets nodes nodes mapped 
bad case assume support tree size needs determined yielding list size needs constructed 
clearly list size exponential worst case 
hand number matchings tree lower min total size scope lists tpm additional factor comes size triplet 
assume list joined maximally times total construction scope lists 
factor exponent due quadratic nature joining embedding lists 
apart transaction frequencies rooted tree databases allow frequency definitions root occurrences 
isomorphic subtree root node called root occurrence defines total number root occurrences obtains function anti monotone frequency definition 
please notice uses frequency defined root occurrences may support greater 
treeminer root frequency easily transaction frequency considering element matching part scope list triplets 
complexity comparison naive algorithm enumeration algorithms embedded subtrees implemented amortized time 
shown rooted ordered embedded subtree inclusion computed vt vp time 
embedded rooted ordered tree mining complexity naive algorithm bounded pessimistically 
due potentially exponential size treeminer occurrence lists reflected pessimistic upperbound chi nijssen muntz kok frequent subtree mining overview possible treeminer performs worse naive algorithm 

rooted ordered induced subtrees freqt freqt algorithm developed asai uses extension approach find frequent induced subtrees database rooted ordered trees 
preprocessing phase frequent labels database determined 
enumeration tree built enumerate frequent subtrees 
build enumeration tree subtree pk identify unique parent pk size 
freqt problem solved removing rightmost node 
extends pk pk means new node connected rightmost path pk rightmost path path root pk node pk pre order 
freqt set candidates generated tree pk consists trees obtained connecting new node frequent label rightmost path 
shows part enumeration tree rooted subtrees consisting labels assumption possible trees frequent 

part enumeration tree ordered subtrees 
occurrence lists freqt determine support trees freqt uses occurrence list approach 
subtree list records nodes database rightmost node subtree mapped 
database part enumeration tree shown occurrence lists 
example occurrence list tree pa single vertex means occurs twice th vertex time th vertex 
extension frequent example database pab subtree vertices parent 
occurrence list pab denotes rightmost node pab mapped vertex 
see rooted ordered induced subtrees record occurrences rightmost vertex occurrences vertices rightmost path needed extension occurrences derived occurrence rightmost node 
example tree bottom needs record occurrences rightmost node occurrence list 
order get occurrence list node labeled suffices scan occurrence list rightmost node find parents vertices occurrence list example 
size occurrence list bounded vd independent size chi nijssen muntz kok frequent subtree mining overview frequent subtree occurrence list method scalable support counting rooted ordered trees 
derive pessimistic upper bound time complexity freqt 
frequent subtree node rightmost path extended adding new rightmost child size occurrence list bounded vd 
extension occurrence nodes corresponding text tree considered pessimistic upper bound freqt time complexity fm vd number frequent trees considered 
course real problems occurrence lists shorter vd 
freqt number root occurrences easily computed occurrence list rightmost node 
proposed walk database starting element occurrence list alternatively add root occurrence occurrence list avoid linear recomputation 
addition freqt developed mine databases rooted ordered trees special situations mine unordered induced trees 
assumes siblings database label preprocessing step sort siblings database label 
discovered trees naturally follow label order reflect restriction database siblings label 
complexity comparison naive algorithm enumeration algorithm freqt naive algorithm 
complexity enumeration strategy amortized enumerated tree optimal 
shown complexity finding root occurrences pattern tree forest vp vd 
total complexity cm vd naive algorithm fm vd freqt 

rooted unordered induced subtrees independently asai nijssen proposed ufreqt algorithms extend freqt mine unordered induced subtrees general case siblings may labels 
candidate generation conceptually difficult unordered trees seen example 
different ordered trees isomorphic unordered trees true 
ufreqt solve problem enumerating ordered trees canonical depth sequences 
canonical depth sequence equivalent pre order string described section rightmost path extensions subtree canonical form extensions result canonical form subtree allowed 
new node connected rightmost path corresponds concatenation new depth tuple depth sequence 
recall depth sequence rooted unordered tree string encoding tree contains label depth vertex 
shown prefix canonical depth sequence canonical depth sequence enumeration remains complete disregards extensions immediately yield non canonical sequence 
difficult determine extension canonical 
asai nijssen method allows constant time enumeration depth sequences 
illustrate method example 
rooted unordered tree canonical depth sequence node tree define depth sequence node segment canonical depth sequence tree corresponds chi nijssen muntz kok frequent subtree mining overview prefix node lowest prefix node prefix nodes rightmost path 
canonical extensions canonical depth sequence 
bottom tree rooted node 
node rightmost path left sibling tree depth sequence prefix depth sequence left sibling node rightmost path called prefix node 
prefix node lowest level lowest prefix node tree 
please note tree lowest prefix node 
shown depth tuple may concatenated canonical depth sequence lowest prefix node true prefix node obtained follows 
length depth sequence lowest prefix node 
th tuple depth sequence left sibling lowest prefix node 
example tuples may concatenated 
intuitively tuples added canonical sequence obtained swapping order children root 
rightmost path node depth label example tuple concatenated shown index prefix node depth sequence computed incrementally constant time index depth sequence 
ufreqt algorithms differ way support trees evaluated 
uses occurrence list approach similar zaki treeminer 
pattern tree occurrence list constructed consists match labels modifications introduced limit size occurrence list 
understand reconsider tree bottom 
case unordered induced subtrees text tree possible match labels labeled vertices mapped ways vertices text trees 
avoid permutations sets nodes stored occurrence list canonical match label defined uniquely pick possible permutations 
different set vertices text tree canonical match label stored 
doing worst case list size equal worst case list size treeminer exponential 
pessimistic upper bound total time complexity building occurrence lists see details 
chi nijssen muntz kok frequent subtree mining overview ufreqt different occurrence list approach ufreqt algorithm 
worst case node pattern tree separate list occurrences stored 
lists consist vertices data set pattern vertex mapped 
size occurrence list bounded product size database size pattern 
algorithm specified computes new occurrence lists occurrence lists parent tree 
algorithm shown polynomial size database 
comparison simpler matching approach treeminer amount element occurrence lists larger 
shown element occurrence list worst case maximum bipartite matching problem solved worst case time complexity vt vp 
determine extensions pattern vd occurrence list rightmost node scanned element path root pattern tree neighbors occurrences path text tree scanned time neighbor obtained worst case maximum bipartite matching problem solved nodes pattern tree add elements occurrence lists pattern nodes complexity solving bipartite matching problem 
total complexity vd 
noted situation size list exactly vd extension requires operations exist upper bound pessimistic 
hybridtreeminer chi proposed algorithm called hybridtreeminer uses combined depth breadth traversal approach generates candidates joins extensions 
guarantee candidate generated hybridtreeminer uses canonical form called breadth canonical form level order traversal 
consequence choice algorithm determine constant time extensions joins allowed 
consider rooted unordered tree breadth canonical form size 
vertices level order leafs shown breadth codes obtained removing vertices canonical share common prefix size 
case vertex subtree canonical form child second vertex trees removal second node disconnect tree 
tree obtained trees common prefix 
observations follows generate candidates 
set frequent canonical ordered trees size share common prefix size pair trees set joined trees created joins obtained performing extension 
consequence extension necessary keep original database main memory possible treeminer store database vertical format 
please notice trees grown adding leaf nodes left right lowest level tree 
breadth canonical forms additional problem tree automorphisms joining frequent subtrees obtain candidate subtree recall automorphisms tree isomorphisms tree 
joining core subtree shared non identity automorphisms join complicated 
example joining including self joining trees left results candidate subtrees 
chi nijssen muntz kok frequent subtree mining overview candidate subtrees valid potentially real frequent subtrees 
chi provided techniques store automorphisms join operation 
join 
automorphisms 
occurrence list chi show occurrence lists trees joined candidate generated join 
join operation occurrence lists hybridtreeminer record occurrences candidate subtree possible orders shown 
example occurrence list subtree bottom represent occurrence different orders 
worst case size occurrence lists hybridtreeminer computed example 
example possible mapping root nodes child mapped second total 
occurrences 
general worst case 
possible different occurrences text tree 
assume occurrence list scanned computation joins time find extensions occurrence total performance bounded bm 
additional factor caused quadratic nature joins occurrence list may joined multiple elements list 
assumption siblings identically labeled algorithms mine frequent subtrees joining root paths feasible 
root path path root tree leaf node tree 
approach taken wang xiao algorithm 
consider paths 
general join paths uniquely defined allows trees siblings distinct labels possible join 
conversely unordered tree defined uniquely join root paths 
approach follows 
preprocessing step paths database stored fst forest data structure 
root path fst forest corresponds frequent path database associated occurrence list 
element occurrence list tuple consisting tree id node id node id identifier node database root path starts 
introduce notation pt short hand tree fst forest contains paths start label 
illustrated ptb database 
assume set siblings fst forest label constant time complexity building fst forest tm follows easily observation paths trees added iteratively fst forest 
chi nijssen muntz kok frequent subtree mining overview 
joining rooted paths 
root path list 
support counting construction fst forest determination frequent paths search frequent trees starts 
define root subtree induced subtree pt keeps root pt 
beneficial property fst forest frequent subtrees roots labeled root subtrees tree pt fst forest 
running example find frequent subtrees root labeled find frequent root subtrees ptb 
find frequent root subtrees prefix tree pt uses variation combined depth breadth traversal 
search starts single node 
breadth fashion frequent sets children root determined 
set children corresponds tree levels tree recursively expanded possible sets nodes level 
levels scanned depth fashion possibilities level determined breadth 
pattern tree root subtree fst tree leaf lowest level pattern tree potential set children obtained fst tree 
combinations candidate children scanned traditional breadth algorithm sets nodes size combined obtain sets size candidates contain infrequent subset removed 
support candidate computed joining occurrence lists leafs 
example consider tree 
occurrence list path 
list joined occurrence list path obtain occurrence list tree 
list joined occurrence list path obtain occurrence list tree 
compute support trees cp vd computation required 
total complexity tm cp vd 
complexity comparison naive algorithm assumes siblings identically labeled tree siblings distinct labels mapped ordered tree problem applies solved ordered tree miner 
compared naive algorithm section 
tm cp vd chi nijssen muntz kok frequent subtree mining overview vd cm vd cm vd may conclude introduce high complexity search comparison naive algorithm 
unique sibling assumption different algorithms necessary 
algorithm introduced enumerating rooted unordered trees certain size 
proposed algorithm compute unordered subtree inclusion mp time 
algorithm relies algorithm solving maximal bipartite matching problems 
total complexity naive algorithm 
complexity bounds derived frequent tree miners pessimistic information learned comparison upper bounds 
ufreqt complexity vd run time bounded polynomially 
hybridtreeminer exponential worst case complexity size largest pattern tree complexity pbm factor comes binomial complexity hybridtreeminer bm factor comes factorial 
compare hybridtreeminer see number occurrences hybridtreeminer may exponentially worse hybridtreeminer canonical form match labels 
hand hybridtreeminer uses joins generate candidates general branching factor smaller hybridtreeminer ufreqt number scans data set reduced considering extensions rightmost node 

induced free subtrees freetreeminer freetreeminer algorithm developed chi adopts breadth traversal idea discover frequent induced subtrees database labeled free trees 
algorithm starts finding frequent subtrees frequent subtrees single vertex repeatedly candidate subtrees generated joining pairs frequent subtrees 
join operation downward closure checking freetreeminer uses set leaf vertices vertices labeled free tree 
gives example downward closure checking candidate tree top leaves removed time get subtrees shown bottom tree 
subtree canonical string computed efficiently search subtree set trees 
meet downward closure constraint subtrees frequent 
generating candidate subtrees avoid redundancy subtrees joined share subtree called core pair subtrees joining labels leaves core subtrees top labels lexicographic order resulting candidate subtree 
example pair subtrees bottom joined get candidate tree top join tree tree leaves core share labels respectively top leaves candidate tree 
method sort order leaf labels works fine trees distinct vertex labels 
vertex labels distinct method needs changed little efficient 
count support candidate subtree transaction checked see chung extended bipartite matching tree inclusion algorithm subtree isomorphism free trees changing time complexity 
main idea chung algorithm fix root call resulting rooted tree test vertex rooted tree root isomorphic subtree may cases checked case chung showed time complexity subtree isomorphisms chi nijssen muntz kok frequent subtree mining overview 
candidate generation free trees free trees vt vp vp rooted trees 
shamir improved time complexity vt vp vp log vp solving maximum bipartite matching problem efficiently 
advantage direct support checking additional information candidate subtrees needs stored memory 
important number candidate subtrees large impossible store information candidate subtrees occurrence lists memory 
time complexity freetreeminer subdivided parts candidate generation phase support counting phase 
candidate generation phase frequent trees combined pairwise generate new candidates 
assume maximum number trees generated tree bf bf trees generated 
trees leafs removed remaining trees normalized existence set frequent trees checked 
depending data structure chosen efficient data structure takes tree 
total phase complexity 
count frequency trees remain frequency pruning candidates checked transactions making worst case complexity ctp pm log 
hybridtreeminer chi extend hybridtreeminer breadth tree encoding mine free trees 
hybridtreeminer adapted subset rooted trees considered 
precisely trees disregarded second deepest subtree root level deep deepest subtree 
conceive special rooted trees free trees special property rooted trees root center free tree 
simple restriction hybridtreeminer able enumerate centered free tree exactly free trees twice 
efficient linear time check rooted trees represent non canonical free tree removed output 
respect candidate counting complexity algorithm similar hybridtreeminer rooted trees bm 
candidate generation slightly difficult determine candidate canonical determine automorphisms linear algorithm required 
chi nijssen muntz kok frequent subtree mining overview gaston approach taken nijssen gaston algorithm 
depthfirst breadth approach hybridtreeminer modified mine free trees depth sequences 
achieved extending constant time enumeration strategy unlabeled free trees labeled trees 
consequence different strategy necessary compute automorphisms pattern trees obtain possible joins 
combined depth breadth algorithm uses procedure consists phases 
phase frequent undirected paths constructed combined depth breadth approach 
phase special canonical form paths computed linear time 
paths taken starting point rooted tree refined subset rightmost path extensions joins 
approach allowable extensions joins free trees characterized constant time free trees path enumerated 
occurrence list approach hybridtreeminer frequency evaluation complexity frequency evaluation bm 
extend extend self join extend extend extend hybridtreeminer extend join gaston join join 
steps involved generating particular candidate free tree gaston hybridtreeminer difference gaston hybridtreeminer illustrated 
hybridtreeminer enumerate represent tree 
see hybridtreeminer trees grow level wise gaston paths grown trees constructed paths 
generation trees paths gaston introduces additional complexity 
freetreeminer proposed freetreeminer different chi freetreeminer 
important difference algorithms searches frequent free trees database graphs 
chi nijssen muntz kok frequent subtree mining overview similar chi freetreeminer freetreeminer uses breadth canonical form grows trees adding nodes lowest level tree 
procedure generate candidates similar 
tree levels algorithm evaluates frequency passing database determining occurrences tree time possible extensions level determined transactions support extensions 
set candidate extensions obtained 
breadth approach frequent subsets pseudo frequent subsets set candidates determined determined joining tid lists associated candidate extensions 
may higher real frequencies locations extensions transactions taken account 
level obtained procedure called recursively determine real frequency find extensions level 
analysis restrict case freetreeminer applied database trees 
free tree miner determine possible occurrences free tree number occurrences free tree checked may tm noted occurrences recomputed time scratch 
hand increase computation time matchings tried success finding ones 
hand reduce amount memory algorithm 
occurrence extensions determined 
tree really counted set supporting transactions obtained computing intersection tid lists size 
assume maximum number level trees obtained level tree maximum number trees turn frequent intersection tid lists pessimistic upperbound total complexity freetreeminer pt 
complexity comparison naive algorithm algorithm enumerating unlabeled free trees enumerated free tree 
defining bijective mapping labeled unlabeled free trees algorithm enumerate labeled free trees 
pm log free tree inclusion algorithm inclusion trees data set computed giving naive algorithm worst case complexity ctp pm log 
closely matches worst case complexity chi freetreeminer ctp pm log 
noted candidate generation chi freetreeminer higher complexity free tree 
algorithms exponential worst case complexity bm hybridtreeminer gaston pt freetreeminer 
respective advantages disadvantages algorithms data set dependent example comparison hybridtreeminer gaston saves double evaluation number free trees may require double evaluation number paths 
respect enumeration complexity differences algorithms 
gaston uses strategy real free trees scheme paths 
algorithms strategy structures chi freetreeminer hybridtreeminer require computation automorphisms chi freetreeminer requires normalization free trees downward closure test 
chi nijssen muntz kok frequent subtree mining overview 
related algorithms inexact matchings algorithm finds frequent subtrees collection tree structured xml data considered rooted unordered trees 
subtree relationship defined tree subsumption 
rooted tree induced tree subsumption rooted tree ancestor descendant relationship subset guarantee completeness frequent subtrees may missed special cases 
shasha defined called approximate nearest neighbor search ann problem algorithm searching query tree database rooted unordered trees 
distance approximate containment tree matching criteria distance query tree text tree defined total number root leaf paths authors pointed tree matching root leaf paths requiring distance postprocessing step algorithm exact tree matching 
maximal closed frequent subtrees algorithms described discover frequent subtrees database labeled trees 
number frequent induced subtrees embedded subtrees grow exponentially sizes tree structured transactions 
consequences follow exponential growth 
users overwhelmed output trouble gain insights huge number frequent subtrees 
second mining algorithms may intractable due exponential number frequent subtrees 
algorithms wang xiao attempt alleviate problem finding presenting users maximal frequent subtrees 
maximal frequent subtree frequent subtree proper frequent 
postprocessing pruning discovering frequent subtrees algorithms solve second problem 
chi algorithm discover closed frequent subtrees maximal frequent subtrees discovering frequent subtrees 
subtree closed proper support 
database support set frequent subtrees set closed frequent subtrees set maximal frequent subtrees relationship types patterns types subtree relationships bottom embedded induced types tree inclusions 
inen gave types tree inclusions context tree matching problems includes definition applications time complexity tree matching problem 
shasha algorithm discovers frequent cousin pairs single set rooted unordered trees 
nodes rooted unordered tree cousin pair ancestor descendant relationship common ancestor length difference path 
shasha showed mining frequent cousin pairs applications finding occurring patterns multiple evaluating quality consensus trees finding kernel trees groups 
chi nijssen muntz kok frequent subtree mining overview unlabeled trees focused databases labeled trees 
consider unlabeled trees special family labeled trees history research unlabeled trees longer theories richer labeled trees 
example asai directly extended pattern growth techniques developed unlabeled rooted trees nakano 
similarly gaston adopted tree enumeration techniques developed unlabeled free trees nakano 
comprehensive algorithms unlabeled trees 
subgraph mining studies mining frequent subgraphs databases labeled graphs 
inokuchi agm breadth algorithm mining frequent unconnected graphs graph database 
algorithm restricts agm find connected subgraphs 
breadth algorithm mining frequent subtrees fsg uses join operation generate candidate subgraphs frequent subgraphs previous level 
agm algorithm extends subgraphs adding vertex level fsg algorithm adding edge 
frequent connected subgraph problem tackled yan pure depth algorithm gspan huan combined depthfirst breadth algorithm 
check transaction supports graph instance subgraph isomorphism problem np complete check graphs isomorphic order avoid creating candidate multiple times instance graph isomorphism problem known np complete 

performance study section performance study algorithms mining frequent embedded subtrees induced rooted ordered subtrees frequent induced rooted unordered subtrees frequent induced free trees 
table shows characteristics data sets performance study table gives explanation parameter table 
explain data set detail discussion 

algorithms mining frequent embedded induced rooted ordered subtrees section study performance algorithms mining embedded induced rooted ordered trees 
best knowledge time writing treeminer published algorithm mining type subtrees freqt available second type 
study performance algorithms 
data set obtained generator zaki 
data set mimics web access trees web site 
parameters generator number labels number nodes master tree maximum depth maximum fanout total number subtrees 
performance study mainly metrics total running time memory usage 
experiments section section done ghz intel pentium iv pc gb main memory running redhat linux operating system 
algorithms implemented chi nijssen muntz kok frequent subtree mining overview name max cs log multicast table 
characteristics data sets number vertices database number trees database number vertices tree mean fan number adjacent vertices vertex tree max maximum fan tree diameter length longest path tree number nodes tree diameter tree path number labels database mean trees database standard deviation trees database table 
clarification database characteristics compiled compiler optimization level 
freqt kudo implementation 
minimum support number frequent embedded subtrees number frequent induced subtrees different compare average running time frequent subtree treeminer freqt 
average run time seconds treeminer freqt minimum support memory usage mb treeminer freqt minimum support 
comparing treeminer freqt number frequent trees treeminer freqt minimum support see minimum support high treeminer efficient 
minimum support decreases freqt efficient treeminer average running time increases 
possible reason may lower value minimum support size frequent trees increases 
freqt size pattern tree influence evaluation time occurrence longer patterns general lower support values fewer occurrences chi nijssen muntz kok frequent subtree mining overview freqt average computation time frequent tree decreases 
treeminer hand size pattern importance occurrence contains match labels pattern vertices 
combined possibly longer occurrence lists due exponential nature number occurrences amount computation time treeminer increases lower minimum support 
shows memory usage algorithms different minimum support minimum support treeminer exhausts available memory 
see freqt memory usage remains flat different minimum support treeminer increases sharply minimum support decreases 
results support previous observations 
minimum support total number frequent embedded subtrees larger induced subtrees shown 
see number frequent embedded subtrees number induced subtrees increase exponentially minimum decreases 
number frequent embedded subtrees larger grows faster frequent induced subtrees 

algorithms mining frequent induced rooted unordered subtrees section compare performance algorithms mining rooted unordered subtrees 
ufreqt hybridtreeminer ufreqt new algorithm combines enumeration ufreqt occurrence list evaluation hybridtreeminer 
allow siblings node labels experimental results limited data sets satisfying constraint 
cs log data set described contains web access trees cs department rensselaer polytechnic institute month 
total transactions unique vertex labels corresponding urls web pages 
average zaki string encoding length data set 
run time seconds cs log ufreqt new hybridtreeminer ufreqt minimum support memory usage mb cs log ufreqt new hybridtreeminer ufreqt minimum support number frequent trees cs log minimum support 
performance rooted unordered tree miners cs log data set see running time algorithms remains steady minimum support greater 
minimum support decreases running time rises sharply 
please notice logarithmic scale axis 
experiment results minimum support decreases number frequent subtrees grows 
possible reason unusual behavior minimum support falls certain threshold access trees generated web crawlers opposed regular web surfers frequent web access trees usually larger ones generated regular web surfers 
regard running time ufreqt hybridtreeminer similar performance 
chi nijssen muntz kok frequent subtree mining overview memory usage minimum support lower ufreqt new exhausts available memory 
inspection code ufreqt new hybridtreeminer reveals large amount memory algorithms partly due efficient ways dealing large numbers labels data set 
hybridtreeminer sharp rise memory usage minimum support 
ufreqt scalable memory usage memory efficient support counting method 
multicast second data set described data set ip multicast trees 
data set consists mbone multicast data measured nasa shuttle launch th st february 
distinct vertices vertex takes ip address label 
data sampled nasa data set minutes sampling interval transactions 
data set dense sense exist strong correlations transactions 
transactions multicast trees nasa event different times 
frequent subtrees large size occur high minimum support 
run time seconds multicast ufreqt new hybridtreeminer ufreqt minimum support memory usage mb multicast ufreqt new hybridtreeminer ufreqt minimum support number frequent trees multicast minimum support 
performance rooted unordered tree miners multicast data set see difficult algorithms deal minimum support values lower 
best running time performance 
minimum support decreases memory usage grows faster algorithms 
third data set generated generator 
data set want control size maximal frequent subtrees 
set subtrees sampled large base labeled graph 
call set subtrees seed trees 
seed tree starting point transactions number transactions database minimum support 
transactions obtained randomly permuting seed tree adding random vertices increase size transaction 
step random transactions size added database increase cardinality database 
number distinct edge vertex labels controlled parameter number distinct edge labels number distinct vertex labels 
size seed trees ranges 
total number frequent subtrees grows exponentially size maximal frequent subtrees running time algorithms increases exponentially shown 
contrast cs log data set memory usage algorithms change number frequent subtrees chi nijssen muntz kok frequent subtree mining overview run time seconds ufreqt new hybridtreeminer ufreqt maximal seed tree size number nodes memory usage mb ufreqt new hybridtreeminer ufreqt maximal seed tree size number nodes number frequent trees maximal seed tree size number nodes 
performance rooted unordered tree miners data set size maximal frequent subtrees 
result implies memory usage ufreqt hybridtreeminer ufreqt new depends number frequent subtrees characteristics frequent subtrees 
data set ufreqt new best time performance smallest memory usage 
interesting performance data set running time change size maximal frequent subtrees grows certain size memory usage grows exhausts available memory quickly 
result results data sets suggests memory data structure rewrite database proportional number frequent subtrees may scalable size maximal frequent subtrees 
data set consists databases generated generator 
parameters remained number transactions database grows 
data set designed test scalability algorithms respect database size 
run time seconds ufreqt new hybridtreeminer ufreqt database size memory usage mb ufreqt new hybridtreeminer ufreqt database size number frequent trees database size 
performance rooted unordered tree miners data set minsup shown fixed minimum support database size increases running time memory usage grow linearly 
running time ufreqt grows faster algorithms growth sublinear databases study 
study algorithms ufreqt hybridtreeminer ufreqt new scalability respect database size 
interesting notice database size increases minimum support total number frequent subtrees decreases exponentially 
mainly due way data set generator implemented 
chi nijssen muntz kok frequent subtree mining overview algorithms mining frequent rooted unordered subtrees data sets studied ufreqt new best time performance multicast smallest memory footprint cs log 
multicast data set best time performance cs log data set ufreqt smallest memory usage 
algorithms scalability database size 
study suggested memory usage directly affected total number frequent subtrees 
addition comparing cs log data set data set see memory usage algorithms depends total number frequent subtrees parameters size patterns 

algorithms mining frequent induced free trees section study performance free tree mining algorithms discussed hybridtreeminer freetreeminer gaston free tree databases graph databases include graph mining algorithms experimental results precisely consider breadth graph miners fsg depth graph miner gspan 
metrics total running time memory usage 
stated experiments done ghz intel pentium iv pc mb main memory running redhat linux operating system 
algorithms implemented 
free tree mining algorithms compiled compiler optimization level 
graph miners obtained binaries compiled similar circumstances compiled compiler 
report experiment amd athlon xp mb main memory running mandrake linux operating system 
cs log experiment cs log data set previous section mining rooted trees 
clearly interesting know browsing behavior point entry taken account 
gspan algorithm considered experiment binary module available allow labels 
experimental results reported page reveal similar characteristics experiments rooted trees certain threshold number frequent trees explodes 
hybridtreeminer gaston run memory threshold sizes embedding lists algorithms increase dramatically 
breadth miners suffer memory exhaustion problem computation time freetreeminer increases drastically 
breadth fsg graph miner requires memory manages scale better smaller thresholds 
consider possible explanations phenomenon discussing experimental results artificial data sets paragraph 
artificial data sets section artificial data sets generated modified generator described 
modification pose constraints minimum maximum size trees generated furthermore allowed stricter control fanout trees generated 
parameters data sets summarized table 
freetreeminer el mentioned experiments developers algorithm concentrated biochemical applications efficiency implementation 
small databases able perform experiments larger databases report experiments freetreeminer timed 
chi nijssen muntz kok frequent subtree mining overview run time seconds run time seconds cs log gaston hybridtreeminer freetreeminer fsg minimum support run time frequent tree seconds gaston hybridtreeminer freetreeminer fsg cs log minimum support number frequent trees cs log minimum support 
performance free tree miners graph miners cs log data set gaston hybridtreeminer freetreeminer fsg gspan minimum support memory usage mb gaston hybridtreeminer freetreeminer fsg gspan minimum support run time seconds scale gaston hybridtreeminer freetreeminer fsg gspan database size 
performance free tree miners graph miners data set data set small data set low fanout number labels high 
characteristics reflect properties application domains web browsing molecular mining 
experiment gives reasonable indication performance free tree miners practical large databases 
reflected depth mining algorithms perform better breadth miners 
sees amount memory relatively low support values increases breadth depth mining algorithms exception gspan 
breadth mining algorithms require large amount memory store candidates main memory occurrence list tree miners require memory storing occurrence lists 
gspan performs better memory wise stores identifiers trees pattern graph occurs occurrences 
shows effect increasing data set size 
due large differences run times show graph logarithmic scale 
algorithms scale linearly size database 
scale properties fsg suggest algorithm includes additional features deal similar graphs input 
data set specified large fanout combination relatively low number labels 
reflected table high mean value 
value indicate tree path 
resulting trees broad deep way obtain data sets exhibit bad case situation 
see depth miners longer advantageous comparison breadth miners 
low values minimum support runtime depth algorithms increases breadth tree miners 
reason behav run time seconds chi nijssen muntz kok frequent subtree mining overview gaston hybridtreeminer freetreeminer fsg gspan minimum support memory usage mb gaston hybridtreeminer freetreeminer fsg gspan minimum support run time seconds freetreeminer fsg gspan minimum support 
performance free tree miners graph miners data sets ior clear considers memory usage algorithms 
memory usage full occurrence tree miners rises exponentially low values support indicates number different occurrences lower frequent trees large 
behavior partly explained considers large fan data set combination low number labels 
siblings label frequent trees symmetries 
depth algorithms extension approach means order extend pattern tree consider occurrences pattern tree text tree order find possible extensions 
particular database amounts large number possibilities stored occurrence algorithms considered depth algorithms 
breadth algorithms prune search space better 
situation stressed data set see equal data set labels removed 
labels number occurrences rises rapidly occurrence list algorithms run memory immediately data set extremely large 
exception rule gspan gspan store occurrence lists recomputes occurrences applicability gspan limited amount main memory gspan clearly shows extremely large run times expected algorithms check occurrences 
interesting drawn comparison freetreeminer fsg data set 
experiments fsg performs better freetreeminer situation completely different labels left data set 
case appears polynomial tree inclusion algorithm freetreeminer performs better potentially exponential subgraph isomorphism algorithm fsg 
provides explanation performance graph miners long reasonable number labels subgraph isomorphism problem practice efficiently solved 

directions aim examine current algorithms mining frequent subtrees databases labeled trees 
started giving applications frequent tree mining algorithms 
introduced relevant theoretical background graph theory studied representative algorithms detail 
focused study main components algorithms chi nijssen muntz kok frequent subtree mining overview candidate generation step support counting step 
thorough performance studies representative family algorithms 
discussed related approximate algorithms algorithms mining closed maximal frequent subtrees 
regarding efficiency issues performance study revealed single best tree mining algorithm 
algorithms offer better time efficiency algorithms require memory 
respect free tree mining algorithms may conclude performance current free tree miners differ general graph mining algorithms 
may reasons general subgraph isomorphism np complete common cases required computations exponential 
example consider case labels pattern text graph see section different subgraph isomorphism checked efficiently checking edges equally labeled nodes graphs 
graph miners label oriented approaches suited situations 
practice graph miners compute subgraph isomorphism graph isomorphism efficiently different reasons frequent tree miners 
subtree inclusion computable polynomially current occurrence list free tree miners take advantage property potentially exponential occurrence lists shown occurrence lists tree miners straightforwardly expanded general graph mining case 
implementations graph miners older tree miners repeatedly optimized years 
indications better performance tree miners ufreqt new gaston due implementation issues 
study showed interesting research questions related frequent tree mining answered 
relation multi relational data mining tree mining 
simple kind multi relational database olap star shaped database 
essence database simplistic tree structure 
applying general multi relational data mining algorithm expect specialized algorithms obtain better performance 
question tree mining algorithms general special kinds databases 
question closely related problem defining search space trees constitutes lattice 
constraint mining algorithms lattice properties optimize search optimizations currently applied tree mining algorithms 
regarding constraint mining additional interesting questions dealt 
example consider case labels tree atomic constitute set elements 
situations occur web access logs files attributes file size time creation type file html jpg access url attributes domain edu com visitor duration stay straightforward way encode sets add vertex element set connect new vertex original vertex 
original vertex label removed 
result database frequent trees labels may interesting cases result intractable search 
wish restrict search trees certain properties vertex chi nijssen muntz kok frequent subtree mining overview label connected vertex label 
raises question efficiently mine frequent trees restrictions 
question defining association rules 
current publications considered frequent tree mining problems 
web mining interesting know certain web browsing behavior predicts browsing behavior xml databases interested know occurrence certain tag part document leads occurrence particular tag 
define association rules structures 
questions involved searches association rules sense define frequency terms number transactions tree occurs 
occurrence count necessary 
efficiently construct association rules 
questions involve extension frequent itemset mining sequential pattern mining episode mining 
databases labeled trees multicast trees time stamps transaction tree 
mining sequential patterns episode trees databases interesting research topics 
professor mohammed zaki providing treeminer source codes cs log data set artificial tree generator 
professor xiao providing source codes offering lot help 
taku kudo making freqt implementation available online 
professor jun hong cui providing nasa multicast event data 
furthermore yan professor jiawei han providing gspan akihiro inokuchi providing algorithm ulrich providing freetreeminer providing fsg 
agrawal srikant fast algorithms mining association rules proc :10.1.1.40.6757
th intl 
conf 
large databases vldb september 
aho hopcroft ullman design analysis computer algorithms addison wesley 
aldous wilson graphs applications introductory approach springer 
asai abe arikawa efficient substructure discovery large semi structured data nd siam int 
conf 
data mining april 
asai uno nakano discovering frequent substructures large unordered trees th international conference discovery science october 
beyer constant time generation rooted trees siam computing 
chalmers almeroth modeling branching characteristics efficiency gains global multicast trees proceedings ieee infocom april 
chalmers almeroth topology multicast trees technical report ucsb march 
chi nijssen muntz kok frequent subtree mining overview chi xia yang muntz mining closed maximal frequent subtrees databases labeled rooted trees ieee transactions knowledge data engineering appear 
chi yang muntz mining frequent rooted trees free trees canonical forms knowledge information systems appear 
chi yang muntz indexing mining free trees proceedings ieee international conference data mining icdm november 
chi yang muntz hybridtreeminer efficient algorithm mining frequent rooted trees free trees canonical forms th international conference scientific statistical database management ssdbm june 
chi yang xia muntz mining closed maximal frequent subtrees eighth pacific asia conference knowledge discovery data mining pakdd may 
chung time algorithm subgraph homeomorphism problem trees journal algorithms 
cui kim gerla aggregated multicast comparative study proceedings ifip networking may 
garey johnson computers intractability guide theory np completeness freeman new york 
gusfield algorithms strings trees sequences computer science computational biology cambridge university press 
han pei yin mining frequent patterns candidate generation acm sigmod intl 
conference management data may 
huan wang prins efficient mining frequent subgraph presence isomorphism proc 
int 
conf 
data mining icdm 
inokuchi washio motoda apriori algorithm mining frequent substructures graph data proc 
th european conference principles practice knowledge discovery databases pkdd september 
inokuchi washio nishimura motoda fast algorithm mining frequent connected subgraphs technical report ibm research tokyo research laboratory 
tree matching problems applications structured text databases department computer science university helsinki 
kudo freqt implementation freqt org taku software freqt 
karypis frequent subgraph discovery proceedings ieee international conference data mining icdm november 
karypis efficient algorithm discovering frequent subgraphs technical report university 
exact rooted subtree matching sublinear time technical report tr universita di pisa 
bottom subtree isomorphism unordered labeled trees technical report tr universita di pisa 
mannila toivonen verkamo discovery frequent episodes event sequences data mining knowledge discovery 
chi nijssen muntz kok frequent subtree mining overview subtree isomorphism ann 
discrete math 
nakano uno efficient generation rooted trees technical report nii national institute informatics 
nakano uno simple constant time enumeration algorithm free trees psj algorithms number 
nijssen kok efficient discovery frequent unordered trees international workshop mining graphs trees sequences 
nijssen kok frequent structure mining difference proc 
int 
conf 
knowledge discovery data mining sigkdd august 
analysis algorithm subtree problem siam computing 
kramer frequent free tree discovery graph data special track data mining acm symposium applied computing sac 
shamir tsur faster subtree isomorphism journal algorithms 
shasha wang shan zhang approximate searching unordered trees th international conference scientific statistical database management ssdbm july 
shasha wang zhang unordered tree mining applications phylogeny th international conference data engineering 
srikant agrawal mining sequential patterns generalizations performance improvements proc 
th int 
conf 
extending database technology edbt 
rousset sebag step xml data mining proceedings ieee international conference data mining icdm 
algorithms trees graphs springer 
wang liu discovering typical structures documents road map approach st annual international acm sigir conference research development information retrieval 
wright richmond mckay constant time generation free trees siam computing 
xiao yao li dunham efficient data mining maximal frequent subtrees proceedings ieee international conference data mining icdm november 
yan han gspan graph substructure pattern mining proc 
int 
conf 
data mining icdm 
yan han mining closed frequent graph patterns proc 
int 
conf 
knowledge discovery data mining sigkdd 
yang lee hsu mining frequent patterns xml queries eighth international conference database systems advanced applications dasfaa 
zaki efficiently mining frequent trees forest proc 
int 
conf 
knowledge discovery data mining sigkdd july 
zaki fast vertical mining diffsets proc 
int 
conf 
knowledge discovery data mining sigkdd 
zaki aggarwal xrules effective structural classifier xml data proc 
int 
conf 
knowledge discovery data mining sigkdd 
