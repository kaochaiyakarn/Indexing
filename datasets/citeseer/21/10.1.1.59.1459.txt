types potency idempotency nonlinearity amnesia type system peter ller computer science department brandeis university waltham ma usa turtle achilles linearity org useful type inference faster normalization 
check safety conditions running program 
analyze relationship bounds normalization type inference 
show success type inference fundamentally related amnesia type system nonlinearity instances variable constrained type 
intersection types advocated usefulness static analysis modular compilation 
analyze system instances descendant system intersection type system type inference algorithm 
system lacks idempotency occurrence variable requires distinct type 
consequently type inference equivalent normalization single case time bounds type inference normalization identical 
similar relationships hold intersection type systems idempotency 
analysis founded investigation relationship linear logic intersection types 
show lockstep correspondence normalization type inference 
shows promise intersection types facilitate static analyses varied granularity immense challenge add amnesia analysis losing benefits 
categories subject descriptors programming languages formal definitions theory logics meanings programs studies program constructs program recursion schemes compu supported danish research agency nsf ccr 
supported nsf ccr cda tyson foundation 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp september snowbird utah usa 
copyright acm harry mairson computer science department brandeis university waltham ma usa mairson cs brandeis edu tation devices mathematical logic computability theory computational logic lambda calculus related systems general terms languages theory performance keywords intersection types type inference normalization complexity idempotence forget past repeat 
george type inference true success story programming language theory pragmatics added languages ml haskell ocaml works programmer worrying 
type inference works easy forget ingenuity lead success 
forms static safety analysis type inference predicts compile time behavior program run time recall milner typed programs go wrong 
crucial requirement type inference substantially faster running program get result follows run program watch 
efficiency achieved simple types hindley milner ml type system intersection type systems 
systems exponential super exponential leap worst case bound type inference worst case bound normalization running time 
consequence programs small types run long interesting explains ml works 
explain super exponential gap investigation intersection types polymorphism explicitly type constructor term type type type 
intersection types gained interest varied purposes flow analysis strictness analysis dead code elimination totality analysis 
intersection types advocated modular compilation usually principal typings exists single typing typings term derived 
significant interesting representative example intersection type system prototype system system descendant system principal typings automatic type inference 
type systems serve foundation church compiler project 
analyze relationship system cost type inference cost normalization 
focus crucial fact system lacks type idempotency analysis establishes formal connection intersection types linear logic originally suggested regnier 
notably expansion variables system shown syntactic rendition boxes 
types sharing nodes normalization bounds mimic normalization techniques elementary linear logic 
exact complexity analysis type inference required system 
analysis formalizes relationship type inference normalization inference rules correspond reduction rules 
corollary analysis normalization type inference identical single case 
evidenced church project experimentation tool inference seemingly innocent ml program fn fn fn fn fn fn times 
system reminds computational 
idempotency need bigger type get longer runtime fact type potentially big runtime 
holds intersection type systems idempotency 
compelling evidence amnesia crucial type systems 
contrasting expressiveness results system results mentioned simply typed calculus ml fundamental difference simply typable terms systems 
simply typed calculus amnesia idempotence normalization bound elementary function simply typed calculus nonelementary power 
contrast simple free types system linear power normalization done linear time size term 
complex types example ml polymorphism versus types amplify distinction 
rest section introduce concepts mentioned fairly broad informal brush 
sec 
give required technical preliminaries 
sec 
prove amnesia idempotency intersection type systems identical bounds normalization type inference 
sec 
go step show system type inference normalization result hold intersection type systems idempotency 
intersection types intersection types provide alternative ml system paradigm parametric polymorphism 
implement finite confused weaker notion principal types hindley milner type system 
principal types type environment fixed 
recall elementary function function bounded stack exponentials polymorphism captured typing rules ai rule states type occurrence may type type 
second rule states term type type environments intersection type combined environment 
combining types environments seemingly technical question associative commutative idempotent aci 
words equations hold 
leaving aci simplifies matters type inference choice shall see substantial consequences normalization bounds 
interest intersection types motivated concerns typing terms full generality type inference universal types intersection types undecidable wells proves universal types intersection types observe types characterize exactly strongly normalizing terms see cor 

practical implementations employ restriction 
example ml allows outermost quantification rejects fn true monomorphic type type int unify type bool 
intersection types rank bounds bound depth type type constant rank 
rank way counting lowest non trivial rank ml programs typed program intersection type int bool studied damiani 
modular compilation different parts software system developed compiled independently increasingly important program size increases 
intersection types strong candidate supporting type inference modular compilation 
avoid code principal typing 
intersection type systems advantageous cases principal typing programs 
static analysis flow analysis typical kind static analysis fixed call site program call procedure 
variable occurrence unique non aci intersection type typed flow analysis call sites functions optimize specific procedure applications 
exploited instance mossin 
comparing expressiveness type inference observe idempotency linearity enforced types variable occurs twice type consequently term simple type variable free bound occurs 
terms normalize linear time vastly powerful nonelementary bounds simply typed calculus 
observation base case variant statman theorem 
linearity statement places literature incorrect proofs 
unpublished correct proof 
appears correct proof published literature footnote 
spills introduce prove normalization rank bounded fragments intersection type systems idempotency take elementary time 
lower bounds type inference fundamental technical question iterate linear function different domain range types 
shown henglein mairson turing machine transition function encoded linear term represent transition function simple system term 
turing machine state implicitly coded type domain range types different 
polymorphically iterating function prove rank add type system expressiveness increased exponential cost type inference 
relating type inference expressiveness case shared upper bound type inference normalization start languages think system type inference equal normalization single term 
relate type inference normalization recast terms sharing graphs calculus 
refer graphs interaction nets just nets untyped containing typing information 
sharing nodes nets indicating contraction linear logic represent intersections 
system uses technology expansion variables facilitate compositionality delaying application typing rule 
expansion variables system syntax boxes interaction nets identical exponentials linear logic 
boxes piece code may apply intersection typing rule box typing decide typing ai derived picking fresh names type variables 
furthermore simply ignoring expansion variables standard aci intersection type systems 
standard interaction net machinery associativity commutativity added system 
results speak system general intersection type systems idempotency 
delaying typing rules promising way avoid analyzing term 
lack idempotency forces exact number copies needed explicit box passed argument 
result set typings invariant reduction 
principal typings normal forms consequently isomorphic intuitive understanding functional programmers reading function type vice versa 
combining insights conclude type inference normalization normalize term terminates due normalization bounds read back principal typing find principal typing return normal form 
operational level correspondence realized observing unification rules original presentation system exactly rules global reduction interaction nets 
may interpret technical results yield practical insights 
worst case lower bounds ml example traditionally wished away type inference works practice words programs small types 

programmers usually keep type heads goes saying bounds normalization show tremendous expressive power small types 
keep system type head know advance exactly program computing 
result negative stresses intersection types facilitate exact program analysis get precise running program 
combined imprecise analysis suggested non linear system provides powerful tool allows programmer get precision needs analysis program 
relating flow analysis geometry interaction observe interpretation intersection typed programs nets flow analysis programs essentially reformulation girard geometry interaction mundane computer scientists guise context semantics 
context semantics term may recover intersection typing information 
method elaboration algorithm prove correctness optimal reduction want read back term location linear logic boxes representing expansion variables existence commutativity associativity sharing nodes 
space reasons provide details hope longer version 
related coppo dezani ronchi della rocca van bakel mauny established connection inferring principal intersection typing normalization essentially infer principal typing normalization 
fact share idea mauny establish connection normal forms show subject reduction expansion 
connection linear logic account expansion variables introduced system result significantly stronger previous results 
relationship intersection types linear logic observed regnier 
formalizes observations extends contribution relating normalization type inference complexity theoretic observational perspectives 
kfoury analyze computational difficulty type inference intersection types aci comparing expressive power language 
develop na type inference algorithm expansion 
elementary functions prove type inference term rank dtime expressiveness dtime 
show idempotency removed type system expressiveness bound reverts bound type inference 
carlier system system overcomes number technical deficiencies system 
introduces modality allow inexact analysis 
current type inference system uses linear fragment system corresponds type inference system 
working meeting intersection types summer carlier wells subsequently proved step wise correspondence type inference normalization setting system 
carlier show system analysis corresponding vy labels 
joe wells explaining intricate details system invitation visit heriot watt university summer carlier inspiring seminar unification done tremendous effort answer questions 
technical comments criticisms alan bawden vincent danos jakob joe kfoury laurent regnier ronchi della rocca sebastian turbak urzyczyn steffen van bakel 
anonymous referees particular detailed astute technical comments caught vastly improved technical presentation 
preliminaries starting real party proving relationship type inference intersection types normalization warmup waltz recalling central concepts 
self contained aims getting reader back rhythm main concepts 
denote positive integers non negative integers 
denote complete function denote partial function 
disjoint union described 
log logarithm base 
turn introduce major systems system rigid non aci intersection type system calculus interaction nets alternative precise syntax calculus 
consider typing problem basic calculus 
set terms grammar variables drawn countable 
adopt barendregt variable convention 
number free occurrences variable standard size measure terms 
xn denote applications church numeral sn capture free substitution written 
define usual notion reduction 
notion reduction compatible closure reflexive transitive closure define subterm indirectly unique path identifying subterm lp lp rp call subterm written subterm path sub undefined 
system types expansions rank motivate system considering intersection type system style van bakel 
types simple types grammar type variables 
idempotency associativity commutativity equivalences hold call operator rigid 
typing rules var rule types abstraction fv fv dom rule typing rules syntax directed 
note rigidity formulation rule implies variable occurrences term top level 
duplication term premises highlights verbose feature type system 
call typing term 
due rule derivations type subterm type derivation 
typ types derived subterm identified subterm path type derivation subterm clear context write typ 
system attempts restrain verbosity retaining principal typings 
avoids redundancy rule inferring principal typing deferring choice instances reasonable choice 
accomplished expansion variables 
expansion variables motivated fact intersection types substitution obtain instance principal typing 
instance term subterm principal type principal typing subterm type obtained substitution top level type constructors different 
expand duplicating parts principal type fresh names obtain 
apply simultaneous substitution 
formalized numerous ways unfortunately heavy notation 
kfoury wells significant simplification extending types expansion variables marks expansions take place 
concretely system introduces expansion variables ranging expansions extends definition types include expansion variables extend typing rules 
expansion variables come doing type inference 
type inference derives typing set constraints form finds substitution solves constraints inferred type obtained applying inference syntax directed straightforward application fresh 
add constraint modify constraint meaningfully talk solutions need specify means substitute expansion expansion variables 
idea substituted applications replaced hole filled fresh instance 
fresh instances chosen expansion applied different instances type variable gets fresh name 
formal definition constraints necessary technical reasons formal definition system 
intersection type systems system type exactly strongly normalizing terms type inference undecidable 
obtain tractable fragment limiting depth 
usually rank defined maximal depth left child 
tighter definition count alternation domain argument side types 
formally functions rank rank rank rank max rank rank rank rank rank max rank rank rank rank rank rank rank max rank rank term typing derived rank maximal rank abstracted variable explicitly environment rank max rank rank typ sub 
interaction nets interaction nets provide graphical representation calculus terms avoiding problems variable capture preserving subject reduction providing link concepts linear logic 
calculus represented nets call name encoding inductively fig 
represent system typings add typing information nets obtain 
external vertices net free ports representing free variables distinguished root port term 
weakening nodes mark unused function arguments application function nodes mark definition procedures sharing nodes code multiplicity variable occurrences nodes mark variable occurrences 
global construction box delineates sharable arguments application 
edges wires endpoints attached strictly speaking system algorithm extra step term decorated expansion variables form socalled skeleton 
principle done ways algorithm arguments applications shown 

inductive encoding term net 
port top root representing term ports bottom correspond free variables 
application case left group wires variables solely middle group variables occurring right group variables solely 
reduction rules interaction nets 
ports node entire graph 
node principal port marked black dot possibly auxiliary ports 
equivalent doing reduction net reduced rules fig 

interaction takes place node connected principal ports sharing node box connected principal ports boxes connected principal auxiliary port 
rules graphical equivalent unification constraint solving rules system 
omit discussion necessary weakening rules primary concern type inference erasing argument change typability 
system church rosser write nf normal forms simulates reduction trivial permutations sharing nodes proposition 
proposition 
terms net equivalent nodes reachable root left right orientation auxiliary ports sharing nodes location inside outside boxes 
restrict consideration nets arise encoding reducing terms 
point language corresponding untyped calculus 
recover equivalent type system annotating wires net types oriented fixed direction wire type system enforces constraints ports nodes boxes 
call annotated net 
example simple types wire principal port node incoming type right left auxiliary port 
constraints nodes order typed 
note renamed expansion variables substituted 
annotations consist substitution expansion type case box defined 
incoming outgoing type 
observe typing rules var correspond na directly inductive cases encoding 
rule little problematic options duplicate structure box contents way share 
option amounts typing boxed net output type explicitly representing subderivations distinct pairing input application 
sharing nodes nodes linear logic equivalent multiple paired 
resulting size normal form reductions linear 
take alternative option duplicate term 
expansions spirit system represent different typings 
considerations mind define intersection typing la system definition 
interaction net 
wire oriented annotated triple consisting type expansion variable substitution expansion type followed substitution gives different types wire write annotations 

exactly free port wire oriented port denoting root term interest 
port proof holding type term remaining ports assumptions corresponding types free variables 

triples wires incident node box satisfies constraints fig 


assumptions expansion 

switching graph derived replacing node wire principal port auxiliary ports 
switching results forest connected acyclic note type environment system contains exactly free variables term consequently subderivations variables type environment 
graphs containing root port port marking weakening abstraction 
essence correctness criterion danos regnier 
annotations orientations wires net call typing say typing xn type type free port corresponding variable xi 
theorem 
term 
system typing typing system typable term principal typing lemma implicit 
principal system typing type variable occurs twice occurs twice occurs positively negatively 
syntax tree type occurrence type variable expansion variables path root syntax tree occurrence 
expansion variable occurs positively 
lemma facilitates translation net formulation definition 
typing net principal typing exists substitution expansion substitution obtained replacing annotations 
expressiveness bounds engage main motif understanding type inference worthwhile intersection type systems 
section derive bounds expressiveness rigid intersection types 
consider decision problem hard tell typed programs equivalent 
decision problem avoids question irrelevant costs due choice output format 
prove terms typable rank dtime hard decide terms equal 
compared time lower bound deciding term typable rank derive section 
shall see function appears bounds lack idempotency simply typed terms linear 
worstcase bounds section show specifically system merely worst case case type inference normalization 
obtain upper bound normalization tracing typing term transformed typing contractum 
recall insight kfoury complete development reduces rank redexes term consequently term redexes rank turned term redexes rank complete developments term redexes rank term affine reduced linear time 
key insight comes observation redex form contracts occurrence types new redexes created abstraction substituted operator application redexes satisfy rank rank re positive negative occurrence standard way count number times choose left child argument arrow syntax tree going root occurrence 
number occurrence positive odd occurrence negative 
dex linear reduction fail reduce rank redex 
remove linear redexes round complete developments 
system subject reduction due rigidity non trivial relate system derivations term contractum 
introduce relaxed type system acw 
definition 
acw type system system changes 
types 

take 

variable rule var 
rank acw type rank rank max rank rank rank max rank rank rank rank rank max rank rank 
define mappings system types acw types extend trivially environments 

differences acw allows weakening strengthening associative commutative allow intersections argument type abstraction 
straightforward prove typability rank preserved 
introduce linear reductions necessary machinery expose implicit redexes 
definition 
define notions reduction lemma 
tl reduction strongly normalizing form computed dtime 
tl terms term trace rank redexes term decreased reduction define maximal rank redex 
definition 
derivation acw maximal rank redex 
formally take max rank typ pl sub nf 
clearly rank 
establish substitution lemma lemma 
derive derive acw derivation max rank rank 
show tl reductions subject reduction affects rank benign way lemma 
terms tl acw typing derived derivation 
acw derivation 

rank 
bound normalization follow fairly standard calculation pairs tl developments maximal sequences tl reductions complete developments tl development complete development reduce redex rank increasing term size exponential 
complete development term intuitively take term underline existing redex 
reduce redexes copied step called residuals remain underlined new redexes caused substituting abstraction application underlined 
formally define pn xd pn interesting case chosen maximally qn qn proposition 
term tl redexes acw derivation typing acw derivation 


proof 
part part proven induction height derivation 
interesting case complete developments term tl normal form 
typ form new redexes rank rank part proven induction interesting case see part lem 

corollary 
term complete computed dtime 
theorem 
term typable rank normal form length computed dtime 
proof 
follows lem 
prop 
tl normalization followed complete development term produces term term typable redex rank typable redex rank 
induction repetitions produce redex rank type tl normalization normal form church rosser property nf 
theorem shows construct untypable terms just violate normalization bounds 
recall church numeral application typable rank 
note observe rank typed terms untypable ml system anomalous peculiar untypable rank bounded system standard ones programming inductive datatypes absence fixpoint recursion see 
lower bounds type inference derive lower bound type inference simulate turing machine type system 
idea henglein mairson observe term linear principal typing isomorphic normal form 
consider instance linear terms representing boolean true false principal types easy see linear normal form types 
interesting consider application true principal type principal type 
incidentally type inference effectively simulated normalization technique elaborated section order derive lower bound type inference represent turing machine ids closed linear terms 
turing machine going ids sn simulated terms mn types represent state transition function closed linear term mi mi similar types mi 
tie knot proving lemma lemma polymorphic iteration 
church numeral term simple types arbitrary 
define jn term jn applications reduces simple type rank proof essentially kfoury tedious packing types due rigidity 
choose term length simulates turing machine computation steps types terms 
provides lower bound type inference normalization shows upper bounds tight 
conventions regarding turing machines clear reader represent favorite machine 
convention 
consider turing machines decide predicates coded right infinite tape alphabet 
program goes leftmost symbol writes blank symbol moves head exactly reads 
turing machine states ql 
program done loops designated failure state ql acceptance state ql 
build transition function states linear terms fig 
standard representation pairs build lists recall rank unbounded system irrelevant practice type inference undecidable 
pairs lists zz nil xk xk nil sequencing right associative vk vk state symbols head movement pci ql qi state transition function nil ll 
building blocks turing machine encoding 
types omitted terms linear isomorphic terms 
pairs contrast usual inductive representation implies uniform type list 
represent machine state tuple consisting program counter tape left head reverse tape right head 
transition function table lookup symbol head find new state new symbol head direction head represented conventions blank read right tape case tape explicitly extended blank third line 
polymorphic iteration lemma originally proved setting aci 
application lemma aci term linear normal form takes enormous leap 
aci base calculus linear calculus simply typed boost 
standard machinery may conclude theorem 
term length deciding typable rank complete dtime 
type inference cheaper normalization reached high tide prove due lack idempotency type inference normalization 
type inference faster running program types inferred nominally solving constraints read normal form 
suggests curry howard isomorphism system possible intersection types general interaction nets 
furthermore shows type inference bounds literally statman theorem type system 
result obtained isomorphism normal form net principal typing 
establish isomorphism restricted case normal nets 
case read net principal typing dually construct normal net principal typing obtain algorithms similar mauny 
general case show set typings unchanged reduction 
system strongly normalizing fixed rank follows net principal typing normal form 
principal typing normal form obtain principal typing normal form reading sharing nodes function application nodes boxes expansion variables 
collect principal typing recursive algorithm outlined fig 
called tp base case corresponds normal form xk typing xi free 
algorithm returns typing annotating root free ports type information second case root gets type free port gets type 
graph represents xk vn nl 
apply algorithm recursively subnet corresponding ni result type annotations root free ports assign fresh expansion variable fi boxes 
assign type fl head variable type fi wire type returned recursive call 
find intersection type shared variable bottom traversal sharing forest 
sharing node principal port type type white black auxiliary port 
normal form principal typing dually function net nf produces net normal form principal system typing 
algorithm net founded intuition functional programmers gazing structure function type immediately knows function type outermost abstractions argument appears function position application 
sets system apart functional languages rigidity idempotency type specification variable occurrence lack commutativity gives orientation sharing nodes non associativity tells boxes principal typing reveals sources arguments applications 
instance typed clear second occurrence argument applied second argument 
looking principal type clear second occurrence 
definition 
function net nf defined principal typing see lemma 
proceed follows net net mutual recursive functions fig 

produce forest graphs applying net net type 
example net constructs strictly speaking plethora principal typings 
differ choice names type expansion variables 
net net net net net net net net net net net net net net net 
mutual recursive definitions functions net net building skeleton net type 
ci 

typing constraints various interaction nodes 
right subfigure expansion variable box 
net net connecting node 
connect ports type variable mentioned twice 
connect remaining ports weakening node 
proposition 
nf net principal typing net tp typings preserved reduction going easier case normal forms arbitrary nets establish set typings invariant reduction 
analysis derive subject reduction subject expansion 
recast question typability constraint problem 
show interaction net set typing constraints exactly characterizes typings 
second show set solutions invariant reduction 
follows net normal form set typings 
principal typing typing typings obtained net normal form principal typing 
definition 
net 
wire labeled unique type variable box labelled unique expansion variable 

typing constraints ci set equations occurrences type variable labelled constraining types nodes induce typing recall subject expansion feature reduces implies 
fl 


inductive definition function tp derives principal typing net 
right subfigure hatched oval wiring sharing forest bottom wires coming free ports subnets cases left variables fresh 
case variables fl fresh 
algorithm applied recursively subnets obtain types ni result types built processing sharing trees bottom described text 
constraint left fig 

box labelled union typing constraints nodes boxes inside box typing constraints type variable root outside inside box type variable ith auxiliary port outside inside box 
ci union constraints outermost boxes nodes outside boxes 

solution set typing constraints pair consisting expansion substitution variable substitution restrict variables occurring respects labels labelled occurrence prove isomorphism typings fixed net solutions ci need relate solutions ci 
specify intersection type wire annotation wire 
solution inserts expansions substitution expansion variables gk annotate boxes surrounding wire listed outermost innermost substitution provides type expanded derivatives wire type variable created applying 
consider solution equivalent wire exactly 
proposition 
net typing constraints 
exists solution typing equivalent wires 
furthermore solution exists typing equivalent wires 
sufficient prove set solutions preserved reduction 
intuitive level preservation holds fl fl fl 
fl 
cause ci capture happens reduction 
example consider outermost box looking wire relevant type variables constraint set box inside box 
constraints 
solution type variables expansion substitution effect 
respect labellings substitute type 
consequently solutions 
accordance fact box single wire 
furthermore allows solution reduced net original net 
redex inside box expansion variables boxes essentially get list constraints similar outermost 
establishing preservation main technical difficulty redex contractum different number wires 
solve noting redundancy solutions example choosing substitution instances leaves choice instances 
sufficient relate typing constraints subset variables extended uniquely solution 
call set basis 
definition 

basis set typing constraints subset variables occurring type substitution expansion substitution specified variables solution domd 

basis solution set typing constraints write denote restriction solution variables 

set typing constraints basis pair substitutions exists write unique solution coinciding prove set solutions typing constraints invariant reduction reduction rule choose bases net reduced net immediate connection wires boxes bases 
solutions related restricting bases mapping extending uniquely 
proposition 
nets ci cj typing constraints 
exists bases bi ci bj cj ui bi cj exists solution cj ui solution ci uj bj ci exists solution ci solution uj cj 
strictly speaking sure variables ci cj overlap loss generality assumed unchanged wires type variables 
subject reduction expansion follow completeness strong normalization result sec 

corollary 
set typings invariant reduction 
corollary 
net principal typing nf net tp net reduction simulates reduction folklore theorem follows subject expansion fact normal forms typable 
corollary 
strongly normalizable term 
typable system 
idempotency crucial 
idempotency rank types form linear calculus expressiveness language collapses complexity type inference type inference synonymous normalization 
previously conjectured complexity type inference normalization related log function suitably simple reasonable type systems 
reasonable characteristic clearly type system built simply typed calculus 
idempotency conjecture fails 
idempotency church numeral different type generalizations observation similar data representations lists trees clear 
consequence typing functions datatypes sense 
conceivable rebuttal normal people don program church numerals program real numbers 
iteration functional programmer weapons mass construction example iter iter iter iter type int 
worse typing simple programming examples abelson sussman square root program iterative approximation compiler exercises numerical analysis 
interaction net underlines similarities intersection types linear logic 
sharing nodes capture havior non aci features 
boxes capture essence expansion variables renaming expansions similar copying box 
brackets capture essence absorption propagation expansion type formula 
obvious question preserve important aspects type analysis allowing expressiveness language increase substantially cost typing 
related problem design type systems expressiveness allow intermediate levels static analysis 
static analysis example learn limited forms polymorphism 
abelson sussman 
structure interpretation computer programs 
mit press 
amadio 
curien 
domains lambda calculi volume cambridge tracts theoretical computer science 
cambridge university press 
asperti 
optimal implementation functional programming languages 
cambridge university press 
banerjee 
modular polyvariant type closure analysis 
proc 
int conf 
functional programming 
acm press 
barendregt 
lambda calculus syntax semantics 
north holland revised edition 
carlier wells kfoury 
system expansion variables flexible typing linear non linear types intersection types 
programming languages systems th european symp 
programming volume lncs pages 
springer verlag 
carlier wells 
type inference expansion variables intersection types system exact correspondence reduction 
technical report hw macs tr heriot watt univ school math 
comput 
sci jan 
coppo damiani giannini 
strictness totality non standard type inference 
theoret 
comput 
sci feb 
coppo dezani ciancaglini 
functional characters solvable terms 
zeitschrift logik und grundlagen der mathematik 
damiani 
conjunctive type system useless code elimination 
math 
structures comput 
sci 
damiani 
rank intersection types local definitions conditional expressions 
acm trans 
prog 
langs 

damiani 
rank intersection types modules 
proc 
th int conf 
principles practice declarative programming pages 
damiani giannini 
automatic useless code detection elimination hot functional programs 
funct 
programming pages 
danos regnier 
structure multiplicatives 
arch 
math 
logic 
gonthier abadi 
vy 
geometry optimal lambda reduction 
conf 
rec 
th ann 
acm symp 
princ 
prog 
langs pages 
gonthier abadi 
vy 
linear logic boxes 
proc 
th ann 
ieee symp 
logic comput 
sci pages 
ieee comput 
soc 
press 
henglein mairson 
complexity type inference higher order typed lambda calculi 
funct 
programming oct 
hindley 
principal type scheme object combinatory logic 
trans 
american mathematical society dec 
hindley seldin editors 
curry essays combinatory logic lambda calculus formalism 
academic press 
jensen 
inference polymorphic conditional strictness properties 
conf 
rec 
popl th acm symp 
princ 
prog 
langs 
jim 
principal typings 
conf 
rec 
popl rd acm symp 
princ 
prog 
langs 
kanellakis mairson mitchell 
unification ml type reconstruction 

lassez plotkin editors computational logic essays honor alan robinson 
mit press 
kfoury 
linearization lambda calculus 
logic comput 
kfoury mairson turbak wells 
relating typability expressibility finite rank intersection type systems 
proc 
int conf 
functional programming pages 
acm press 
kfoury tiuryn urzyczyn 
ml typability dexptime complete 
th colloq 
trees algebra programming volume lncs pages 
springer verlag 
kfoury wells 
implementing compositional analysis intersection types expansion variables 
proceedings nd workshop intersection types related systems 
kfoury wells 
decidable type inference finite rank intersection types 
conf 
rec 
popl th acm symp 
princ 
prog 
langs pages 
kfoury wells 
type inference intersection types expansion variables 
theoret 
comput 
sci 
lafont 
proof nets interaction nets 

girard lafont regnier editors advances linear logic proceedings workshop linear logic london math 
soc 
lecture note series pages 
cambridge university press 
lamping 
algorithm optimal lambda calculus reductions 
popl pages 

vy 
optimal reductions lambda calculus 
hindley seldin pages 
mairson 
deciding ml typability complete deterministic exponential time 
popl pages 
mairson 
outline proof theory parametricity 
hughes editor fpca conf 
funct 
program 
lang 
comput 
arch volume lncs pages cambridge ma 
aug 
springer verlag 
mairson 
hilbert spaces dilbert spaces context semantics simple 
nd conference foundations software technology theoretical computer science 
milner 
theory type polymorphism programming 
comput 
system sci 
mitchell 
type systems programming languages 
van leeuwen editor handbook theoretical computer science pages 
north holland 
mossin 
exact flow analysis 
math 
structures comput 
sci 
conf 
rec 
th ann 
acm symp 
princ 
prog 
langs 
regnier 
lambda calcul 
phd thesis university paris 
ronchi della rocca 
principal type schemes unification intersection type discipline 
theoret 
comput 
sci mar 
ronchi della rocca 
principal type schemes extended type theory 
theoret 
comput 
sci jan 

mauny 
new presentation intersection type discipline principal typings normal forms 
technical report rr inria oct 
statman 
typed lambda calculus elementary recursive 
theoret 
comput 
sci july 
van bakel 
intersection type disciplines lambda calculus applicative term rewriting systems 
phd thesis catholic university nijmegen 
wadler 
theorems free 
proceedings th int 
conf 
funct 
program 
languages computer architecture pages 
acm 
kfoury wells alan yates schwartz carlier 
system experimentation tool 
types bu edu modular compositional experimentation tool 
wells 
typability type checking system equivalent undecidable 
ann 
pure appl 
logic 
wells muller turbak 
calculus polymorphic polyvariant flow types 
funct 
programming may 
