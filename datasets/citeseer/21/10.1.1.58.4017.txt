revisiting coroutines ana cia de moura roberto ierusalimschy computer science department puc rio rua vicente rio de janeiro rj brazil ana roberto inf puc rio br puc mcc june defends revival coroutines general control abstraction 
proposing new classification coroutines introduce concept full asymmetric coroutines provide precise definition operational semantics 
demonstrate full coroutines expressive power equivalent shot continuations partial continuations 
show full asymmetric coroutines shot partial continuations similarities comparable benefits 
coroutines easier implemented understood specially realm procedural languages 
provide collection programming examples illustrate full asymmetric coroutines support direct concise implementations useful control behaviors including cooperative multitasking 
keywords control structures coroutines continuations este de como uma de 
uma nova classifica para de de uma sem 
ent que tem ao de continua es continua es shot 
que continua es shot cios 
por mais num de 
uma cole de de que de para de forma de ncia 
de continua es concept coroutines introduced early constitutes oldest proposals general control abstraction 
attributed conway described coroutines subroutines act master program implemented construct simplify cooperation lexical syntactical analyzers cobol compiler conway 
coroutines express useful control behaviors widely explored years different contexts including simulation artificial intelligence concurrent programming text processing various kinds data structure manipulation knuth marlin pauli soffa 
designers general purpose languages disregarded convenience providing programmer powerful control construct rare exceptions simula birtwistle bcpl moody richards modula wirth icon griswold griswold 
absence coroutine facilities mainstream languages partly attributed lacking uniform view concept precisely defined 
marlin doctoral thesis marlin widely acknowledged mechanism resumes fundamental characteristics coroutine follows values data local coroutine persist successive calls execution coroutine suspended control leaves carry left control re enters coroutine stage 
description coroutines corresponds common perception concept leaves open relevant issues respect coroutine construct 
apart capability keeping state identify main issues distinguish coroutine facilities control transfer mechanism provide symmetric asymmetric coroutines coroutines provided language class objects freely manipulated programmer constrained constructs coroutine construct able suspend execution nested calls 
depending intended coroutine mechanism particular solutions preceding issues adopted 
consequence quite different implementations coroutines developed simula modula coroutine facilities icon generators expressions python generators 
constructs satisfy marlin general characterization coroutines provide significantly different degrees expressiveness absence precise definition class continuations greatly contributed virtual research interest coroutines general control abstraction 
coroutines class continuations defined semantics widely acknowledged expressive construct implement interesting features including generators exception handling backtracking felleisen haynes multitasking source level dybvig hieb wand coroutines haynes 
exception scheme kelsey implementations ml harper alternative implementation python class continuations usually provided programming languages 
relevant obstacle incorporation continuations language difficulty provide efficient implementation construct 
difficulty mainly due need supporting multiple invocations continuation usually involves copying captured continuation modified hieb 
observation contexts continuations invoked motivated bruggeman introduce shot continuations limited single invocation eliminate copying overhead associated multi shot continuations 
shot continuations replace multi shot continuations practically useful applications 
specially implementation multitasking shot continuations provide significant performance benefits compared multi shot continuations bruggeman 
apart efficiency issues concept continuation representation rest computation difficult manage understand specially context procedural languages 
nature continuation invocation complicates considerably structure programs experienced programmers may difficulties understand control flow continuation intensive applications 
convenience limiting extent continuations localizing effects control operators motivated partial continuations felleisen johnson duggan proposal series constructs concept queinnec 
traditional continuations partial continuations represent continuation slice queinnec continuation subcomputation hieb 
partial continuations composed current continuation behave regular functions 
danvy filinski queinnec sitaram demonstrated control constructs concept expressiveness defined felleisen 
partial continuations provide concise understandable implementations classical applications continuations generators backtracking multitasking 
applications restriction imposed shot continuations applied partial continuations allowing efficient implementations constructs 
despite advantages traditional continuations partial continuations provided common implementations programming languages realm scheme 
significant reason absence coroutines modern languages current adoption multithreading de facto standard concurrent programming 
years research efforts dedicated alternative concurrency models support efficient error prone applications event driven programming cooperative multitasking 
mainstream languages java provide threads primary concurrency construct 
purpose defend revival coroutines powerful control abstraction fits nicely procedural languages easily implemented understood 
argue demonstrate contrary common belief coroutines far expressive continuations 
provided class objects implemented constructs full coroutine mechanism implemented coroutines equivalent power shot continuations 
similar arguments proposals partial continuations mechanisms easiness manage understand support structured applications specifically defend full asymmetric coroutines convenient construct language extensibility 
remainder organized follows 
section proposes classification coroutine mechanisms issues mentioned earlier discusses influence usefulness coroutine facility 
section provides formal description concept full asymmetric coroutines illustrates example general purpose programming language implements mechanism 
section show full asymmetric coroutines provide symmetric coroutine facilities shot continuations shot partial continuations 
section contains collection programming examples full asymmetric coroutines provide direct implementations useful control behaviors including multitasking 
section summarizes presents 
classification coroutines capability keeping state successive calls constitutes general commonly adopted description coroutine construct 
observe various implementations coroutine mechanisms differ widely respect convenience expressive power 
section identify discuss issues notably distinguish coroutine mechanisms influence usefulness 
control transfer mechanism known classification coroutines concerns control transfer operations provided distinguishes concepts symmetric asymmetric coroutines 
symmetric coroutine facilities provide single control transfer operation allows coroutines explicitly pass control 
asymmetric coroutine mechanisms commonly denoted semi symmetric semi coroutines dahl provide control transfer operations invoking coroutine suspending returning control coroutine invoker 
symmetric coroutines operate hierarchical level asymmetric coroutine regarded subordinate caller relationship somewhat similar called calling routine 
coroutine mechanisms support concurrent programming usually provide symmetric coroutines represent independent units execution modula 
hand coroutine mechanisms intended implementing constructs produce sequences values typically provide asymmetric coroutines 
examples type construct iterators liskov generators griswold griswold 
general purpose coroutine mechanisms implemented simula bcpl provide types control transfer 
absence formal definition coroutines simula mechanism truly complex implementation coroutines practically adopted general purpose coroutine mechanism greatly contributed common misconception symmetric asymmetric coroutines equivalent power 
easy demonstrate express constructs terms generalpurpose coroutine mechanism provide symmetric asymmetric coroutines 
providing constructs complicates semantics mechanism increase expressive power 
equivalent terms expressiveness symmetric asymmetric coroutines equivalent respect ease 
handling understanding control flow program employs moderate number symmetric coroutines may require considerable effort programmer 
hand asymmetric coroutines behave routines sense control transfered back 
novice programmers familiar concept routine control sequencing simpler manage understand 
asym metric coroutines allow development structured programs 
class versus constrained coroutines issue considerably influences expressive power coroutine mechanism coroutines provided class objects 
implementations coroutines typically intended particular uses coroutine objects constrained textual bound directly manipulated programmer 
example restricted form coroutine iterator abstraction originally proposed implemented designers clu permit traversal data structures independently internal representation liskov 
clu iterator preserves state successive calls described coroutine iterator fits marlin general characterization coroutines 
clu iterators confined loop invoke exactly iterator 
restriction imposes considerable limitation construct parallel traversals data collections instance possible 
sather iterators inspired clu iterators confined single call point loop construct 
number iterators invoked loop restricted clu iterator terminates loop terminates 
traversing multiple collections single loop possible asynchronous traversals required merging data collections simple solution 
icon goal directed evaluation expressions griswold griswold interesting language paradigm backtracking supported constrained form coroutines named generators expressions may produce multiple values 
providing collection built generators icon supports user defined generators implemented procedures suspend returning 
despite limited specific construct icon generators confined expression invoked explicit iteration goal directed evaluation 
icon generators easier clu sather iterators powerful provide programmer defined control structures 
facility provided coroutines implemented class objects freely manipulated programmer invoked place 
class coroutines provided instance icon expressions coroutine facilities implemented simula bcpl modula 
coroutine mechanisms allow coroutines suspend execution nested functions time coroutine resumed execution continues exact point suspended 
coroutine mechanisms provided instance simula bcpl modula icon clu sather iterators 
currently observed resurgence coroutines context scripting languages notably python perl 
python function contains yield statement called generator function 
called function returns object resumed point program behaves asymmetric coroutine 
despite constituting class object python generator construct suspend execution control stack level creation time 
words main body generator suspend 
similar facility proposed perl conway addition new type return command called yield preserves execution state subroutine called 
python generators similar non constructs permit development simple iterators generators complicate structure elaborate implementations 
example items produced recursive auxiliary functions necessary create hierarchy auxiliary generators yield succession original invocation point reached 
type generator powerful implement user level multitasking 
full coroutines preceding discussion argue classification issues determine expressive power coroutine facility coroutines class objects constructs 
absence facilities coroutine mechanism support useful control behaviors notably multitasking provide general control abstraction 
introduce concept full coroutine class object demonstrate provide expressiveness obtained shot continuations 
full coroutines symmetric asymmetric selection particular control transfer mechanism influence expressive power 
asymmetric coroutines easily managed support succinct implementations user defined constructs 
believe full asymmetric coroutines mechanisms provide convenient control abstraction symmetric facilities 
full asymmetric coroutines purpose section provide precise definition concept full asymmetric coroutines 
introducing basic operators model coroutines 
formalize semantics operators developing operational semantics simple language incorporates 
provide example programming language implements full asymmetric coroutine mechanism closely follows proposed semantics 
language programming examples 
coroutine operators model full asymmetric coroutines basic operators create resume yield 
operator create creates new coroutine 
receives procedural argument corresponds coroutine main body returns created coroutine 
creating coroutine start execution new coroutine begins suspended state continuation point set statement main body 
operator resume re activates coroutine 
receives argument coroutine returned previous create operation 
resumed coroutine starts executing saved continuation point runs suspends main function terminates 
case control transfered back coroutine invocation point 
main function terminates coroutine said dead resumed 
operator yield suspends coroutine execution 
coroutine continuation point saved time coroutine resumed execution continue exact point suspended 
coroutine operators provide convenient facility allow coroutine invoker exchange data 
time coroutine activated second argument operator resume passed argument coroutine main function 
subsequent coroutine second argument result value operator yield 
hand coroutine suspends argument passed operator yield result value operator resume activated coroutine 
coroutine terminates value returned main function result value reactivation 
operational semantics order formalize concept full asymmetric coroutines develop operational semantics mechanism 
similarities asymmetric coroutines subcontinuations discuss section allow base semantics operational semantics subcontinuations described hieb 
start core language call value variant calculus extended assignments 
core language set expressions denoted includes constants variables function definitions function calls assignments expressions denote values constants functions store mapping variables values included definition core language allow side effects variables values evaluation core language defined set rewrite rules applied expression store pairs value obtained 
evaluation contexts felleisen friedman determine step subexpression evaluated 
evaluation contexts defined core language preceding definition specifies left right evaluation applications argument evaluation context term function position value 
rewrite rules evaluating core language dom dom rule states evaluation variable results stored value 
rule describes evaluation applications case substitution assumed order guarantee fresh variable inserted store 
rule describes semantics assignments assumed variable exists store previously introduced abstraction 
order incorporate asymmetric coroutines language extend set expressions labels labeled expressions coroutine operators create resume yield extended language labels coroutines labeled expressions represent currently active coroutine 
see labeling coroutine context allows identify coroutine suspended operator yield evaluated 
labels coroutines include set expressions denote values extend definition store allowing mappings labels values variables labels values definition evaluation contexts include new expressions 
new definition specified left right evaluation operator resume argument coroutine reduced label value extra argument examined create resume resume yield types evaluation contexts full contexts denoted subcontexts denoted 
subcontext evaluation context contain labeled contexts 
corresponds innermost active coroutine coroutine nested coroutine occurs 
rewrite rules describe semantics coroutine operators create dom resume yield rule describes action creating coroutine 
creates new label represent coroutine extends store mapping label coroutine main function 
rule shows resume operation produces labeled expression corresponds coroutine continuation obtained store 
continuation invoked extra argument passed resume 
order prevent coroutine reactivated label mapped invalid value represented 
rule describes action suspending coroutine 
evaluation yield expression occur labeled subcontext re evaluation resume expression invoked coroutine 
restriction guarantees coroutine returns control correspondent invocation point 
argument passed yield result value obtained resuming coroutine 
continuation suspended coroutine represented function body created corresponding subcontext 
continuation saved store replacing mapping coroutine label 
rule defines semantics coroutine termination shows value returned coroutine main function result value obtained activation coroutine 
mapping coroutine label established coroutine resumed prevents reactivation dead coroutine 
example full asymmetric coroutine facility lua ierusalimschy ierusalimschy scripting language widely game industry application domain cooperative multitasking typical control behavior 
version lua provides coroutine facility closely follows semantics just described 
overview lua lua light weight language supports general procedural programming data description facilities 
dynamically typed lexically scoped automatic memory management 
lua supports basic value types nil boolean number string thread function table 
types nil boolean number string usual meanings 
type allows arbitrary data stored lua variables 
type thread represents independent thread control implement coroutines 
functions lua class values stored variables passed arguments functions returned results 
lua functions anonymous syntax function foo merely syntactical sugar foo function tables lua associative arrays indexed value may represent ordinary arrays symbol tables sets records order support convenient representation records lua uses field name index provides name syntactic sugar name 
lua tables created means constructor expressions 
simplest constructor creates new empty table 
table constructors specify initial values selected fields 
variables lua global local 
global variables declared implicitly initial nil value 
local variables lexically scoped explicitly declared 
lua provides conventional set statements similar pascal including assignments function calls traditional control structures repeat 
lua supports conventional features multiple assignments multiple results 
lua coroutines lua coroutine facilities implement concept full asymmetric coroutines moura 
semantics mechanism basic operations provided create resume yield lua libraries functions packed global table table coroutine 
function coroutine create allocates separate lua stack new coroutine 
receives argument lua function represents main body coroutine returns coroutine value type thread 
quite argument coroutine create anonymous function coroutine create function functions lua coroutines class values stored variables passed arguments returned results 
explicit operation deleting lua coroutine value lua coroutines discarded garbage collection 
functions coroutine resume coroutine yield closely follow semantics operators resume yield described 
lua functions return multiple results facility provided lua coroutines 
means function coroutine resume receive variable number extra arguments returned corresponding call function coroutine yield 
likewise coroutine suspends corresponding call function coroutine resume returns arguments passed coroutine yield 
coroutine create auxiliary function coroutine wrap creates new coroutine returning coroutine returns function called resumes coroutine 
arguments passed function go extra arguments resume 
function returns values returned coroutine resume boolean error code 
usually function coroutine wrap simpler coroutine create provides exactly typically needed function resume coroutine 
programming examples provided coroutine wrap 
illustration lua coroutines consider classical example iterator traverses binary tree pre order shown 
example tree nodes represented lua tables containing fields key left right 
field key stores node value integer fields left right contain node respective children 
function preorder iterator receives argument binary tree root node returns iterator successively produces values stored tree 
possibility yielding inside nested calls allows concise implementation tree iterator traversal tree performed auxiliary recursive function preorder yields produced value function preorder node node preorder node left coroutine yield node key preorder node right create iterator function preorder iterator tree return coroutine wrap function preorder tree return nil binary tree iterator implemented lua coroutines directly iterator caller 
traversal signalled nil value returned iterator main function terminates 
shows example binary tree iterator merging binary trees 
function merge receives arguments trees root nodes 
begins creating iterators trees collecting smallest elements 
loop prints smallest value correspondent iterator obtaining element continuing elements trees exhausted 
function merge local preorder iterator local preorder iterator local local nil nil print print merging binary trees expressing alternative control structures common belief coroutines far expressive class continuations friedman asymmetric coroutines powerful symmetric coroutines 
section contradict misconceptions showing language incorporates full asymmetric coroutines easily provide symmetric coroutines shot continuations shot partial continuations 
sort control structure implemented constructs provided full asymmetric coroutines 
symmetric coroutines basic characteristic symmetric coroutine facilities provision single control transfer operation allows coroutines pass control explicitly 
marlin pauli soffa argued symmetric asymmetric coroutines equivalent power general coroutine facilities provide constructs 
easy demonstrate provide mechanisms expressive power lost asymmetric coroutines provided language 
implementation symmetric coroutines top asymmetric facilities straightforward 
symmetrical transfers control asymmetric coroutines easily simulated pairs yield resume operations auxiliary dispatching loop acts intermediary switch control coroutines 
coroutine wishes transfer control yields dispatching loop turn resumes coroutine reactivated 
code shown illustrates mechanism providing lua library supports creation symmetric coroutines control transfer discipline 
order allow coroutines transfer control main program table provides field main represent simulating coroutine 
auxiliary field current store currently active coroutine 
coroutine main program wishes transfer control calls function transfer passing coroutine re activated extra argument provided function allows coroutines exchange data 
main program currently active dispatching loop executed function coroutine yield called dispatcher 
control transfered main program function transfer returns 
implementation followed modula semantics coroutine termination specifies termination coroutine explicit transfer control constitutes run time error wirth 
main function current main function create new coroutine function create local function val val error coroutine ended return coroutine wrap function transfer control coroutine function transfer val current main return coroutine yield val dispatching loop true current main return val val val implementing symmetric coroutines facilities der implement semantics function create wraps coroutine body function issues error terminate main program coroutine terminates 
shot continuations continuation represents rest computation point computation 
provided class objects scheme kelsey implementations ml harper continuations implement wide variety control structures represent powerful tool language extensibility 
scheme procedure call cc causes current continuation packaged class object 
captured continuation passed argument call cc procedure argument 
procedure returns invoking continuation returned value value application call cc 
time captured continuation invoked value value immediately returned continuation original call cc application 
conventional class continuation mechanisms allow continuation invoked multiple times virtually useful applications continuations invoked 
motivated fact bruggeman introduced concept shot continuations control operator call cc 
shot continuations differ multi shot continuations error invoke shot continuation implicitly returning procedure passed call cc explicitly invoking continuation created call cc 
implementation shot continuations described bruggeman reveals similarities mechanism symmetric coroutines 
implementation control stack represented linked list stack segments structured stacks frames activation records 
shot continuation captured current stack segment encapsulated continuation fresh stack segment allocated replace current stack segment 
terms symmetric coroutines corresponds creating new coroutine transferring control 
shot continuation invoked current stack segment discarded control returned saved stack segment 
exactly happens new coroutine time transfers control back creator 
similarities shot continuations symmetric coroutines allow provide concise implementation call cc symmetric coroutine facility described section 
implementation shown 
shot subcontinuations despite expressive power traditional continuations multi shot shot difficult trivial examples complicate considerably structure programs felleisen danvy filinski queinnec 
complexity involved continuations arise fact represent rest computation 
need constrain extent continuations localize effects control operators motivated proposal control abstractions concept partial continuations queinnec 
essence abstractions invocation captured partial continuation abort current continuation partial continuations composed regular functions 
subcontinuations hieb example partial continuation mechanism 
subcontinuation represents rest independent partial computation subcomputation point function call cc save continuation creator local current invoking continuation transfers control back creator local cont function val nil error shot continuation called twice transfer val continuation captured new coroutine created dispatched local val val transfer create function local cont cont control transfered back continuation shot invalidated nil value passed continuation return value call cc return val implementing shot continuations symmetric coroutines putation 
operator spawn establishes base root subcomputation 
takes argument procedure subcomputation passes controller 
controller invoked result value spawn value returned procedure 
controller invoked captures aborts continuation point invocation back including root subcomputation 
procedure passed controller applied captured subcontinuation 
controller valid corresponding root continuation program 
controller applied valid subcontinuation invoked subcomputation 
shot continuations symmetric coroutines shot subcontinuations full asymmetric coroutines similarities 
full asymmetric coroutines regarded independent subcomputations 
invoking subcomputation controller similar suspending asymmetric coroutine 
invoking shot subcontinuation corresponds resuming asymmetric coroutine 
subcontinuations asymmetric coroutines composed behave regular functions returning control invoker 
main difference subcontinuations full asymmetric coroutines subcontinuations types partial continuations reified subcontinuation restricted innermost subcomputation 
subcontinuation extends controller invocation point root invoked controller may include nested subcomputations 
similarities shot subcontinuations full asymmetric coroutines allow express shot subcontinuations terms lua coroutines provide implementation operator spawn shown 
function spawn invoked lua coroutine created represent subcomputation 
coroutine main body invokes spawn functional argument passing locally defined function implements subcomputation controller 
variable valid controller indicates legal invoke controller value true correspondent coroutine active 
controller function creates subcontinuation suspending coroutine variable shot indicates subcontinuation invoked coroutine resumed 
coroutine resumed function controller returns caller subcomputation controller invocation point 
argument passed subcontinuation returned coroutine yield result value controller invocation 
function responsible spawning subcomputation resuming correspondent coroutine 
subcomputation ends invoking controller coroutine main body returns invocation point result value obtained calling nil value see line 
case function terminates line spawn returns caller value returned controller invoked coroutine invocation line gets argument passed controller function applied subcontinuation invoked controller 
controller passed second argument coroutine yield line allows simulate subcontinuation composed arbitrary number nested subcomputations coroutine suspends returned controller checked verify belongs current scope line 
function passed controller applied subcontinuation 
means invoked controller corresponds outer subcomputation current coroutine calls coroutine yield line behavior provided variants partial continuation mechanisms marks queinnec tags sitaram specify context partial continuation reified 
function spawn local controller valid controller shot coroutine represents subcomputation local coroutine wrap function return controller nil function implements subcomputation controller function controller fc valid controller error invalid controller shot false val coroutine yield fc controller shot true return val function spawns subcomputation function shot error subcontinuation called twice invoke subcontinuation valid controller true local ret valid controller false subcomputation terminated nil return ret local controller invoked apply function subcontinuation elseif controller return ret invoked controller corresponds outer subcomputation val coroutine yield ret return val spawn subcomputation shot false return implementing spawn 
process repeated controller root reached allowing include suspended subcomputations captured subcontinuation 
symmetrically invoking subcontinuation successively resume suspended coroutines original controller invocation point reached 
efficiency issues haynes demonstrated continuations implement coroutines 
sitaram showed coroutines expressed terms partial continuations 
just shown full asymmetric coroutines express shot continuations shot partial continuations allow argue full asymmetric coroutines equivalent expressive power abstractions 
expressing shot continuations subcontinuations coroutines reverse operations may equivalent terms efficiency 
simple implementation shot continuations described bruggeman creation continuation involves conversion current stack segment continuation object allocation new stack segment replace 
shot continuation invoked current segment discarded control returned saved stack segment 
creation coroutine involves allocation separate stack 
actions suspending resuming coroutine just little expensive regular function calls 
implementation shot continuations creation single coroutine single stack segment sufficient implement continuation 
language implements full coroutines provide shot continuation mechanisms perform efficiently simple direct implementation abstraction 
hand implementation coroutines continuations developed haynes typically requires capture new continuation time coroutine suspended 
implementation involves allocation new stack segment control transfer performs efficiently uses memory direct implementation coroutines 
hieb described possible implementation subcontinuations uses stack labeled stacks 
ensure efficiency stack represented stack label address pairs address pointing stack segment stored 
invoking spawn results addition new empty stack stack labeled stacks new stack label assigned order associate correspondent controller 
controller invoked stacks associated label removed stack labeled stacks packaged subcontinuation 
subcontinuation invoked saved stacks pushed current stack labeled stacks 
implementation shot subcontinuations cost spawning subcomputation creation activation coroutine equivalent proposed implementation spawn 
subcontinuation involves single subcomputation usual case capture invocation subcontinuation perform efficiently described direct implementation subcontinuations 
complicated case subcontinuation includes nested subcomputations successive resumptions involved subcomputations impose overhead cost higher succession function calls 
hand implementation coroutines subcontinuations requires capture subcontinuation control transfer arguably efficient simple direct implementation coroutines 
kumar described implementation shot subcontinuations terms threads 
basic idea somewhat similar subcomputation represented child thread created spawn invoked 
parent thread put sleep waiting done condition associated subcomputation controller 
controller invoked child thread wakes root thread signalling correspondent done condition suspends execution creating waiting continue condition 
subcontinuation invoked correspondent thread woken signalling continue condition invoker put sleep waiting controller done condition 
conditions allow suspension resumption threads differently coroutines explicitly transfer control additional synchronization mechanism implemented mutex required prevent spawned child thread signal done condition parent thread put sleep implementation subcontinuations threads involve successive suspensions resumptions nested subcomputations coroutines requires 
threads introduces considerable complexity overhead due need synchronization mechanisms 
capture subcontinuation requires creation new condition allocation associated structures 
efficient general case implementing subcontinuations coroutines simpler arguably error prone 
simplified description implementation shown kumar 
considered requirements implementation non concurrent subcontinuations 
programming full asymmetric coroutines previous section showed language full asymmetric coroutines easily provide shot continuations shot partial continuations control behaviors implemented abstractions 
section complement demonstration expressiveness full asymmetric coroutines providing succinct elegant implementations different control behaviors including representative examples continuations 
producer consumer problem producer consumer problem paradigmatic example coroutines constitutes recurrent pattern scenarios 
problem involves interaction independent computations produces sequence items consumes time 
classical illustrations type interaction pair symmetric coroutines control explicitly transfered back forth producer consumer 
asymmetric coroutines provide simpler structured solution implement consumer conventional function resumes producer asymmetric coroutine item required convenient extension producer consumer structure pipeline producer consumer chain consisting initial producer filters perform transformation transfered items final consumer 
asymmetric coroutines provide succinct implementation pipelines 
filter behaves consumer producer implemented coroutine resumes get new value yields transformed value invoker consumer chain 
implementation filter shown 
single statement create pipeline connecting desired components activating final consumer consumer filter producer generators generator control abstraction produces sequence values returning new value caller invocation 
generators particular instance producer consumer problem generator behaving producer 
example consumer driven design 
appropriate producer driven solution developed 
function filter ant return coroutine wrap function true resume obtain value local ant yield transformed value coroutine yield implementing filter asymmetric coroutines typical generators implement iterators related control abstraction allows traversing data structure independently internal implementation 
capability keeping state possibility exchanging data transferring control asymmetric coroutines convenient facility implementing iterators 
classical example iterator implemented lua coroutines shown section 
usefulness generators restricted implementing data structure iterators 
section provides example generators quite different scenario 
goal oriented programming goal oriented programming implemented pattern matching griswold griswold prolog queries clocksin mellish involves solving problem goal primitive goal disjunction alternative goals 
alternative goals may turn conjunctions subgoals satisfied succession contributing partial outcome final result 
pattern matching problems matching string literals primitive goals alternative patterns disjunctions goals sequences patterns conjunctions subgoals 
prolog unification process example primitive goal relation constitutes disjunction rules conjunctions 
context solving problem typically requires implementation backtracking mechanism successively tries alternative adequate result 
implementations prolog style backtracking terms continuations haynes multi shot success continuations produce values examples scenarios shot continuations bruggeman 
type control behavior easily implemented full asymmetric coroutines matching string literal primitive goal function prim str return function pos local len string len str string sub pos pos len str coroutine yield pos len alternative patterns disjunction function alt patt patt return function pos patt pos patt pos sequence sub patterns conjunction function seq patt patt return function pos local coroutine wrap function patt pos patt goal oriented programming pattern matching generators wrapping goal coroutine allows simple loop successively retry resume goal adequate result 
primitive goal defined function yields result invocation 
disjunction implemented function sequentially invokes alternative goals 
conjunction subgoals defined function iterates subgoal invoking second produced outcome 
example consider pattern matching problem 
goal match string pattern patt expressed combining subgoals represent alternative matchings sequences sub patterns 
example pattern abc de style backtracking implemented shot partial continuations shown sitaram restricted forms coroutines icon generators 
implementation pattern matching shown 
pattern function receives subject string starting position 
successful matching yields position checked 
find matchings returns nil 
primitive goal corresponds matching substring string literal 
function prim implements goal receives argument string value returns function tries match substring starting position 
goal succeeds position immediately follows match yielded 
function prim uses auxiliary functions lua string library string len returns length string string sub returns substring starting positions 
alternative patterns substring correspond disjunction goals 
implemented function alt receives arguments alternative goals returns function tries find match invoking goals 
successful match new position yielded invoked goal goes directly function caller 
matching substring sequence patterns corresponds conjunction subgoals implemented function seq 
resulting pattern function creates auxiliary coroutine iterate subgoal 
successful match obtained invoking subgoal results new position second subgoal satisfied 
successful match second subgoal new position yielded goes directly function caller 
functions just described pattern abc de defined follows patt seq alt prim abc prim de prim function match verifies string matches pattern function match patt local len string len local coroutine wrap function patt pos pos len return true return false cooperative multitasking obvious uses coroutines implement multitasking 
due mainly wide adoption multithreading modern mainstream languages suitable coroutines currently disregarded 
list live tasks tasks create task function create task local coroutine wrap function return ended table insert tasks task dispatcher function dispatcher true local table tasks break tasks run local status tasks status ended table remove tasks break implementing cooperative multitasking language coroutines require additional concurrency constructs just thread coroutine represents unit execution private local data sharing global data resources coroutines 
concept thread typically associated preemptive multitasking coroutines provide alternative concurrency model essentially cooperative coroutine explicitly request suspended allow coroutine run 
preemptive scheduling consequent need complex synchronization mechanisms developing correct multithreading application difficult task 
contexts operating systems real time applications timely responses essential preemption unavoidable 
timing requirements concurrent applications critical 
thread implementations provide real timing guarantees 
application developers usually little experience concurrent programming 
scenario cooperative multitasking environment eliminates conflicts due race conditions minimizes need synchronization appropriate 
implementation cooperative multitasking terms full asym metric coroutines straightforward illustrated 
concurrent tasks modeled coroutines new task created inserted list live tasks 
simple task dispatcher implemented loop iterates list resuming live tasks removing ones finished condition signalled predefined value returned coroutine main function 
occasional fairness problems easy identify solved adding suspension requests time consuming tasks 
drawback cooperative multitasking arises blocking operations instance coroutine calls operation blocks entire program blocks operation completes 
concurrent applications unacceptable behavior 
situation easily avoided providing auxiliary functions initiate operation suspend active coroutine operation immediately completed 
ierusalimschy shows example concurrent application uses lua coroutines includes non blocking facilities 
currently renewal interest cooperative multitasking alternative multithreading adya behren 
concurrent constructs support cooperative multitasking proposed environments usually provided libraries system resources window fibers richter 
interestingly description concurrency mechanisms employed environments description coroutines plus dispatcher term coroutine mentioned 
exception handling language provides exception handling mechanism typically implements basic primitives try raise friedman 
try primitive gets expressions body exception handler 
body returns normally returned value value try exception handler ignored 
body encounters exceptional condition raises exception immediately sent handler case unevaluated portion body ignored 
exception handler return value value associated try raise exception sent dynamically enclosing handler 
language full asymmetric coroutines easily support exception handling 
try primitive implemented function gets function values body handler executes body coroutine 
raise primitive merely function yields exception 
save original version coroutine wrap local wrap coroutine wrap redefine coroutine wrap function coroutine wrap tag create tagged coroutine local wrap function return tag return function local ret resume coroutine tag outer coroutine tags match coroutine yield ret reinstate inner coroutine tag ret tags match return ret avoiding interference control actions avoiding interference control actions asymmetric coroutines implement different control structures single program structures nested may necessary avoid interferences control actions 
undesirable interference may arise instance iterator try structure raises exception 
avoid simple interferences identify pairs control operations associating control structure different tag string instance implement new version function wrap supports tags shown 
addition function coroutine yield takes required argument tag order allow match yield resume pairs 
notice basic idea solution similar matching subcomputation correspondent controller implementation subcontinuations see section 
avoiding simple interferences trivial coroutines continuations presence concurrency interferences control actions error handling general hard tackle 
due compositional nature asymmetric coroutines handling errors difficulties concurrency implemented asymmetric coroutines 
period intense investment middle early research interest coroutines general control abstraction virtually stopped 
absence precise definition concept led considerably different implementations coroutine facilities factors greatly contributed discard interesting construct class continuations general belief far expressive coroutines adoption threads standard concurrent construct 
observe renewal interest coroutines notably different scenarios 
corresponds research efforts explore advantages cooperative task management alternative multithreading 
scenario forms coroutines provided libraries system resources solely concurrent constructs 
resurgence coroutines context scripting languages python perl 
case restricted forms coroutines support implementation simple iterators generators powerful constitute general control abstraction particular concurrent construct 
argued favor revival full asymmetric coroutines convenient general control construct replace continuations multithreading single simpler concept 
order support proposition provided contributions described 
fulfill need adequate definition concept coroutine proposed classification coroutines main issues coroutines symmetric asymmetric firstclass objects constructs 
discussed influence issues expressive power coroutine facility introduced concept full coroutines class objects 
discussed advantages full asymmetric coroutines versus full symmetric coroutines equivalent power ease 
provided precise definition full asymmetric coroutine construct supported development operational semantics mechanism 
demonstrated full asymmetric coroutines provide symmetric coroutines shot continuations shot partial continuations discussed similarities shot continuations full symmetric coroutines shot partial continuations full asymmetric coroutines 
showed constructs equivalent power may equivalent terms efficiency 
provided collection programming examples illustrate full asymmetric coroutines support concise elegant implementations useful control behaviors including relevant examples continuations 
adya howell theimer bolosky 
cooperative task management manual stack management 
proceedings usenix annual technical conference 
usenix monterey ca 
behren condit brewer 
events bad idea servers 
proceedings th workshop hot topics operating systems hotos ix 
hi 
birtwistle dahl nygaard 
simula 
sweden 
bruggeman waddell dybvig 
representing control presence shot continuations 
proceedings acm sigplan conf 
programming language design implementation pldi 
acm philadelphia pa 
sigplan notices 
clocksin mellish 
programming prolog 
springer verlag 
conway 
rfc subroutines routines 
dev perl org perl rfc html 
conway 
design separable transition diagram compiler 
communications acm july 
dahl dijkstra hoare 
hierarchical program structures 
structured programming second ed 
academic press london england 
danvy filinski 
abstracting control 
proceedings acm conference lisp functional programming 
acm nice france 
dybvig hieb 
engines continuations 
computer languages 
felleisen 
prolog scheme 
technical report indiana university 
felleisen 
theory practice class prompts 
proceedings th acm symposium principles programming languages popl 
acm san diego ca 
felleisen 
expressive power programming languages 
proceedings rd european symposium programming esop 
copenhagen denmark 
felleisen friedman 
control operators secd machine calculus 
formal description programming concepts iii wirsing ed 
north holland 
friedman haynes kohlbecker 
programming continuations 
program transformation programming environments pepper ed 
springer verlag 
friedman wand haynes 
essentials programming languages second ed 
mit press london england 
sperber 
add threads sequential language getting tangled 
proceedings th workshop scheme functional programming 
cambridge ma 
griswold griswold 
icon programming language 
prentice hall new jersey nj 
harper duba harper macqueen 
typing class continuations ml 
proceedings th acm symposium principles programming languages popl 
acm orlando fl 
haynes 
logic continuations 
logic programming 
haynes friedman wand 
obtaining coroutines continuations 
computer languages 
hieb dybvig anderson iii 
subcontinuations 
lisp symbolic computation 
hieb dybvig bruggeman 
representing control presence class continuations 
proceedings acm sigplan conf 
programming language design implementation pldi 
acm white plains ny 
sigplan notices 
ierusalimschy 
programming lua 
lua org isbn rio de janeiro brazil 
ierusalimschy figueiredo 
lua extensible extension language 
software practice experience june 
johnson duggan 
stores partial continuations class objects language environment 
proceedings th acm symposium principles programming languages popl 
acm san diego ca 
kelsey clinger rees 
revised report algorithmic language scheme 
acm sigplan notices sept 
knuth 
art computer programming volume fundamental algorithms 
addison wesley reading ma 
kumar bruggeman dybvig 
threads yield continuations 
lisp symbolic computation 
liskov snyder atkinson schaffert 
abstraction mechanisms clu 
communications acm aug 
marlin 
coroutines programming methodology language design implementation 
lncs springer verlag 
moody richards 
coroutine mechanism bcpl 
software practice experience oct 
moura rodriguez ierusalimschy 
coroutines lua 
th brazilian symposium progamming languages 
sbc rj brazil 
omohundro stoutamire szyperski 
iteration abstraction sather 
acm transactions progamming languages systems jan 
pauli soffa 
coroutine behaviour implementation 
software practice experience mar 
queinnec 
library level control operators 
acm sigplan lisp pointers oct 
queinnec 
dynamic extent control operator partial continuations 
proceedings th acm symposium principles programming languages popl 
acm orlando fl 
richter 
advanced windows third ed 
microsoft press redmond wa 
peters 
pep simple generators 
www python org pep html 
sitaram 
handling control 
proceedings acm sigplan conf 
programming language design implementation pldi 
acm albuquerque nm 
sigplan notices 
sitaram 
models control implications progamming language design 
ph thesis rice university 

continuations python 
proceedings th international python conference 
arlington va wand 
continuation multiprocessing 
proceedings lisp conference 
acm stanford ca 
wirth 
programming modula third corrected ed 
springer verlag 

