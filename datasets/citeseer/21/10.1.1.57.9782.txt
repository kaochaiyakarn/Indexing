basic components constraint solver cooperations eric universit de nantes nantes cedex france eric univ nantes fr propose predefined set basic components designing implementing constraint solver cooperations solver cooperation languages 
combining components patterns enables manage computation control coordination needed solver cooperations 
framework implemented chr language 
implement cooperation primitives constraint propagation cooperative components 

solver cooperation research topic widely investigated years 
nowadays efficient constraint solvers available 
challenge cooperate order solve hybrid problems treated single solver improve solving efficiency reuse parts solvers reduce implementation costs 
solver cooperation languages provide primitives manage cooperation 
implementing language tedious task instructions complex clear separation computation control 
primitive language controls interaction manages coordination functions computations 
languages tightly related constraint problem representation limits evolutions extensions languages cooperation features 
studying properties characteristics cooperation designed language difficult complexity primitives 
goal propose new solver cooperation language bali language propose framework simplifies design implementation solver cooperations solver cooperation languages permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
acm sac melbourne florida usa copyright acm 
carlos castro departamento de inform tica universidad cnica federico santa mar espa chile inf cl allows evolutionary cooperation languages extended improved adapted order better fulfil user needs enables obtain simple relation solvers cooperations constraints order study deduce constraint cooperation properties automatically generate cooperations 
focus items 
framework basic components connected channels executing concurrently aim defining computations behaviors interactions occurring solver cooperations 
connecting components enables manage coordination defined cooperation belong :10.1.1.105.5728
structure behavior component imposed type 
component type fixes skeleton component number input output ports connected channels components number function parameters 
standard functions compose computational part component 
type component determines behavior react external events 
event mechanism defined concurrent rules enables manage coordination component synchronize components waiting message 
depending types components compute control coordinate components control data flow 
framework notion pattern enables reuse incrementally build cooperations 
fact pattern parametrized ports functions patterns combination components 
pattern define complex computation coordination behavior single component 
main contribution simplify solver cooperations cooperation languages design implementation 
fact propose layer standard programming languages complex solver cooperation languages bali language framework allows design concurrent competitive concurrent cooperative sequential cooperations 
components clear simple behaviors easily composed create complex behaviors 
propose new coordination model language concepts field coordination fact concepts happen iwim model applies field cooperative constraint solving 
framework rely specific structure constraint problems freely consider new kinds cooperations easily reuse patterns components different cooperations 
main drawback freedom topology components determined computation component create components react constraint structure 
part problem solved patterns considering powerful function parameters 
difference predefined set agents components agents devoted specific distributed algorithm consistency maintenance components tools design solver cooperations example consistency maintenance 
dice software framework constructing distributed constraint solvers 
symbolic derivations supported constraint solving essentially domain reduction branching 
kernel framework type solvers concept root framework interaction solvers type communication solvers 
framework implemented constraint handling rules chr language manage concurrent rules implementing components :10.1.1.10.4679
framework implement common cooperation strategies static reacting constraints primitives cooperation language 
patterns enabled implement applications constraint propagation cooperative components 
organized follows 
section give basic concepts related constraints control functions solver cooperation 
define notion components types section combine create patterns section 
section briefly describe implementation framework presenting section applications 
conclude section 
basic notions constraints solver cooperation languages generally impose constraint representation map interpretation 
example constraint disjunction conjunctions atomic constraints represented list lists atomic constraints logical terms 
considering computational information representation extended new structures 
representation constraints logical terms sets lists constraints required represent different computational possibilities different candidates solver applied 
order standard representations allow integrate computational information consider constraint representation parameter framework 
call pool information constraint problem denote set constraint problems 
problem defines set solutions want find initial search space 
usual methods amount reducing search space corresponds set solutions 
introduce notions clarify operations perform cooperation 
refer choice points branches denote node search tree choices leads 
call computational choice points candidates parts candidates problem solver cooperation effectively applied 
example consider solver extract roots polynomial equation 
problem contains polynomial equations computational choice point equations candidate 
create adding adding choice point leading branches common technique perform enumeration 
control solver cooperation languages control part semantics primitives 
framework components consider fine grain complex possess control capabilities 
consider control data perform complex control components 
separate constraint problems controls problems data computation controls data manage interaction components data flow 
control represented boolean value set controls denoted order fully separate notions framework provides channels ports data problems channels ports controls booleans 
functions functions parameters components executed components 
consider different classes functions respect profiles 
refine classes respect semantics functions 
sub classes effect connections components standard classes defined semantics solver cooperations 
transformers class functions consider computable functions constraint problems constraint problems functions class major sub classes solvers filters selectors 
solver function reduces search space defined constraint problem 
functions different nature considered solvers domain reduction functions symbolic transformations deductions gr bner bases computation splitting mechanisms enumeration create branches search space 
filter computable function returns constraint problem containing computational candidates fulfil requirements 
filter generally preparing data solver 
selector returns problem containing part input constraint problem 
select branch choice point candidate computational choice point 
problem combiners constraint combiner combines constraint problems new 
standard combiners disjunction conjunction union constraints 
control generator property function problem returns control data 
usual examples type functions check problem composed linear equations isempty test problem empty 
comparator comparator function problems returns control 
standard comparators 
control combiner control combiner function combines controls 
standard control combiners binary logical operators xor 
control class functions composed function 
function reverses control standard logical operator 

components components entities connected channels exchange problems controls 
components different tasks devoted problem transformation control generation control coordination management data flow management 
locally component possesses input output ports openings outside world 
ports connected unidirectional channels carrying messages 
ports channels dedicated problems computational data controls control data 
channel declared connect port type port type means messages pass port port type determines type channel 
ports identifiers connect components port names unique 
messages stored input ports fifo buffer consumed component 
messages pass channels soon put output ports channels need buffer 
input port connected channels output port connected channel 
component may execute functions section parameters 
depending design system implementation component access function library piece code integrated code component external component connected component represented term follows component type port type 
port type port type 
om port type function class 
fl function class component type represents type component see section 
resp 

om input resp 
output ports respective types port problems controls 
fl functions described section respective classes transformer combiner control combiner 
components concurrent rules way messages read sent defines behaviors components interactions synchronizations coordination 
component described set concurrent rules form head body head sequence get input port data instructions body sequence put output port data instructions function calls 
match rule means data pending ports appearing head rule get instructions 
fire trigger rule signifies rule matches actions body achieved sequence 
data pending input ports consumed soon rule needs match effectively fired 
match rules fired 
rules concurrent component composed rules matches triggered 
rule triggered stopped executes instructions body finishing component returns state tries match rules 
get instruction blocking data input port get simply fails rule match 
instruction put drops output port delivered finite time extreme channel connected illustrate notion rules example 
consider component managed rule get get put assume message arrives 
rule match triggered 
remains port 
assume message arrives 
rule matches message triggered removed input ports function applied result put note matching rule strengthened requesting conditions messages rule get true put false specifies component waits message message control data true 
types components data types concentrate component interaction coordination synchronization 
create confusion type data ports easily deduced context generally type functions parameters 
group components types define skeletons components behavior 
skeleton component composed input ports output ports number functions parameters 
behavior component described way component consumes messages data applies functions ports puts data 
handle different types data different classes functions component managing problem combiner component managing control manager see function classes section skeleton behavior 
define different types components skeletons behaviors representations concurrent rules 
transformers components type input port output port parameter function receive message consume apply send result syntax transformer transformer component transformer solvers filters 
control generator properties control functions 
single rule implements manages transformer component get put synchronizers components synchronize components mediating messages 
input ports output port function parameter act follows wait messages soon messages apply data put result synchronizer component form managed rule synchronize get get put synchronizer component handle problem combiner functions problem ports comparator functions problem ports control port control manager functions control ports 
component input ports ii ii output port ports ii ii kind local memories component put store get recall messages 
ports ii ii accessible outside component connected channel 
appear syntax component couple messages arriving arrived immediately put destroyed arrive 
rules define behavior component get get ii true put ii false get get ii true put ii false get get ii false put ii true put get get ii false put ii true put message true put ii indicates component read message forwarded message ii false message read component reset 
reset performed rule respectively rule destroys message respectively reinitialize component putting false ii respectively ii 
mechanism cleans input ports component prepare 
implementing component ii ii initialized put ii false put ii false component interesting similar cooperations parallel result fastest kept forwarded soon arrives 
sieve sieve component input ports problems controls control port output port type sieve sieve component waits message control 
true put consumed action performed nop get get true put get get false nop component blocks message control arrives deletes control false 
avoids putting message component sure consume remains clean ready 
duplicate duplicate component gets message input port returns copy output ports 
constraint problem control type duplicate behavior described rule get put put 
solver cooperations section restricted set components design usual forms solver cooperations 
solver cooperation set connected interacting components exchange information 
distinguish types cooperations compositions patterns 
composition mean set components totally fixed 
coordination behavior topology function parameters fixed 
simple example consists applying solvers sequence similar sequence primitive bali 
cooperation defined set components transformer os connect os transformer os soon constraint problem put solved put os 
reached treated result put os 
coordination point view patterns interesting composition 
define complex parametrized components built basic components see section patterns 
composition patterns hide internal structure structure visible definition patterns similar body function similar declaration function 
advantage reuse cooperations knowledge internal structures components involve having possibility having ports functions patterns parameters 
declaration pattern pat form pat 

om 
fl 
pk parameters 
input ports 
om output ports 
fl functions 
pk patterns 
say 

om profile pattern 
note shorten notation omitted types ports classes functions profiles patterns 
ports profile pattern external ports pattern ports definition pattern said internal external ports visible outside pattern appear declaration internal ports visible definition 
note function pattern parameters pi appear internal pattern pat 
pattern parameter pattern 

function parameters instantiated parameters case formal name profile identical execution ports profile connected channels ports notion pattern parameters concept pattern similar component pattern fixed skeleton fixed behavior defined components patterns built called internal composition connections 
illustrate notion pattern simple examples 
figures normal lines represent problem channels lines control channels 
pattern data duplicated times 
composing duplicate components propose pattern 
pattern definition left declaration pattern right duplicates message arriving output ports 

pattern implemented definition duplicate connect duplicate connect duplicate duplicate connect pattern simple function pattern parameter writing complex 
number channels grows direct ratio number duplicate components 
consider implicit channels simplification 
implicit channels consider component component output port connected input port channel 
cause confusion writing connect rename implicitly exists channel ports explicitly looks components sharing port 
notion pattern simplifies duplicate duplicate 
switch pattern switch pattern receives constraint problem depending value application property problem puts result output ports 
declaration switch switch pattern defined implemented see switch pattern ip transformer ip op duplicate op sc ni transformer ni sc sieve sc sieve sc fixed point fixed point common primitive solver cooperations applies iteratively cooperation case pattern result change input output cooperation 
declaration fixed point pattern fp equal coop ic oc equal function parameter test equality constraint problems coop pattern having input output port possibly function pattern parameters see section example instantiation fixed point 
possible definition fixed point equal function parameter depending structure constraint problems testing equality different 
fixed point pattern duplicate ic oc synchronizer equal duplicate ne sieve sieve transformer ne coop ic oc equal parameter fixed point pattern parameter internal component synchronizer 
instantiated pattern coop replaced full declaration function pattern parameters added 

implementation implement framework languages candidates manifold coordination facilities appropriateness coordination needs elan rule programming implementation tuple space model linda pattern matching features :10.1.1.30.7822
choose chr language rule concurrency capacities offered opportunity directly implement rules :10.1.1.10.4679
instructions language prolog predicates generate set chr rules 
compiling chr rules generates topology components communication interactions 
definition components rules nearly straightforward implementation 
chr shared memory constraint store 
shared mean rule uses concurrently constraints memory match generated constraint stored memory 
tagging constraints port names unique component easily find store constraint 
consider chr constraints form get port 
depending type component constraint problem control port unique identifier corresponds name port 
component getting data input port corresponds getting get constraint shared memory 
instruction put port corresponds adding constraint get port store 
firing rule usual chr mechanism rule matches body rule executed con straints head removed store 
behavior components messages removed ports 
different functions solvers filters 
implemented prolog predicates 
note predicates call external solvers 
creating channel ports performed connect component implemented rule get put 
shortcut consists removing channels input output port kept implementation 
done sharing name port 
component allowed put problems port get problems 
illustrate implementation simple example 
transformer stated transformer 
call transformer creates rule get cc put cc 
cooperation built list components 
predicate enables automatically create corresponding components set rules 
rules just put message input port put input port problem 
cooperation executes result stored output port read connected print component 

applications section implementation primitives cooperation language 
executions components constraint propagation standard method constraint solving 
simple structure problems applications 
consider atomic constraints conjunction list denoted 
atomic constraints disjunction list conjunctions 
computational choice points represented lists candidates 
consider finite domain variables types atomic constraints la ua determining domain values take la ua leq meaning consider solver narrow leq problem leq la ua lb ub reduces domain order problem locally consistent single constraint leq value removed domain 
basic primitives implementation basic primitives straightforward components 
sequence consists connecting output cooperation input 
don care simple pattern dc component synchronizer component don care function randomly choose inputs dc dc 
fixedpoint primitive corresponds fixed point pattern see section 
best apply semantics primitive problem best criteria parameters possible application cooperation coop part defined criteria parameters effectively modified 
words framework computational choice point defining candidates coop applied coop applied candidate best criteria coop really modify 
operational semantics primitive complex 
divide problems sub problems corresponding pattern 
patterns grouped pattern operational semantics equivalent best apply primitive 
detail patterns 
pattern takes input problem applies pattern coop corresponding solver cooperation best apply output ports coop really modifies true put success port put old port result applying coop put new port 
false put success old new 
pattern creates computational choice point filter function 
long reads true input port sends candidates output port 
false read candidate empty stops 
pattern responsible replacing transformed constraints initial problem 
declaration fully generic pattern ilter selector isempty sublist equal coop input output ports pattern 
isempty sublist equal functions related constraint problem representation coop cooperation apply input output ports 
ilter selector parameters create candidates determine best represent criteria parameters best apply primitive 
example pattern filter isempty sublist equal transformer ii oo narrow leq filter filters leq constraint related domain constraints suitable input narrow leq solver strategy performs depth search list constraint problem representation functions related problem structure isempty true computational choice point sublist removes computational choice point removes adds constraints problem equal checks problems equal 
sending problem leq port filter finds candidate leq patterns simplified fixing problem structure 
best apply pattern fix functions related problem structure significantly reduce number parameters 
definition remain calling fixed functions function parameters 
obviously chosen selector solved narrow leq 
final result pattern leq 
problem leq leq filter finds candidates 
selector sends candidate leq solver 
candidate modified solver 
selector sends candidate leq effectively reduced narrow leq solver 
answer leq leq 
best apply primitive change strategy applying cooperation changing filter selector parameters 
note main difficulties defining pattern remain message component applying 
fixed point shown 
primitives implementing dc apply primitive simple just reuse pattern selector random choice 
parallel best apply primitive consists adding pattern front patterns connect patterns synchronizers components combiner functions 
framework parallel concurrent apply primitive implemented pattern combiners synchronizers replaced don care function see definition don care pattern 
easily imagine new patterns complete language example pattern apply solver candidate 
just change pattern pattern sends true port pattern sends old problem new problem old new output ports 
fixed point best apply example narrow leq solver filter filter selector pattern parameter fixed point pattern 
terms cooperation compute full reduction problem problem locally consistent constraint requires fixed point 
flattened pattern composed components 
send fp problem leq leq system reduces domains obtain fp answer leq leq 
trace execution shows pattern called times times successfully solver really modified problem unsuccessfully modification problem determines fixed point reached 
narrow leq solver called times times successfully corresponds successes 
times tries reduce domains candidate fails reach fixed point 

set basic components design implement solver cooperations 
advantage provide clear separation computation control ease design implementation cooperations cooperation languages 
notion pattern allows incremental realization cooperations considering kinds complex components patterns complex skeletons behaviors components 
constraint problem structure free cooperation coordination reused domains constraint representations 
languages implemented framework evolve progress 
goal implementation test capacity framework design cooperations cooperation languages 
go produce results need implementation allows distributed computation easily call bigger complex external solvers 
coordination features language manifold candidate implementation 
plan extend framework order able deduce properties constraints cooperations automatically create cooperations problems solved 
referees useful suggestions comments 
authors partially supported national science fund project ist project coconut european community 

apt 
essence constraint propagation 
theoretical computer science 
available arxiv org archive cs 
apt 
role commutativity constraint propagation algorithms 
acm trans 
programming languages systems 
arbab 
iwim model coordination concurrent activities 
ciancarini hankin editors proc 
international conference coordination languages models volume lncs pages 
springer verlag 
arbab 
manifold manual 
cwi amsterdam netherlands may 
arbab 
coordination heterogeneous distributed cooperative constraint solving 
acm applied computing review 
de backer 
combinatorial problem solving constraint logic programming cooperative solvers 
logic programming formal methods practical applications studies computer science elsevier 
kirchner kirchner 
moreau ringeissen 
overview elan 
entcs 
castro 
control language designing constraint solvers 
proc 
rd int 
conf 
perspective system informatics psi volume lncs pages russia 
castro 
basic operators solving constraints collaboration solvers 
campbell lozano editors proc 
th int 
conf 
artificial intelligence symbolic computation volume lncs pages madrid spain 
springer 
fr :10.1.1.10.4679
theory practice constraint handling rules 
journal logic programming october 
gelernter 
generative communication linda 
acm transactions programming languages systems 
benhamou 
symbolic interval cooperation constraint programming 
proc 
th int 
symp 
symbolic algebraic computation issac pages london ontario canada 
acm press 

better communication tighter cooperation 
proceedings computational logic london uk volume lecture notes artificial intelligence pages 
springer verlag 
kirchner ringeissen 
rule constraint programming 
fundamenta informaticae 

model cooperative solvers computational problems 
joint bulletin ncc iis 
series computer science 
mackworth 
constraint satisfaction 
stuart shapiro editor encyclopedia volume 
addison wesley 
nd edition 
papadopoulos arbab 
control driven coordination programming shared dataspace 
proc 
th int 
conf 
parallel computing technologies pact volume lncs pages russia 
springer verlag 
papadopoulos arbab 
coordination models languages 
zelkowitz editor advances computers engineering large systems volume pages 
academic press 
petrov 
automatic analysis composite solvers 
proceedings th international conference tools artificial intelligence 
appear 
ringeissen 
cooperation decision procedures satisfiability problem 
baader schulz editors frontiers combining systems applied logic pages 
kluwer academic publishers 
sam faltings 
maintaining hierarchical distributed consistencies 
cp dcs workshop singapore 

coordination solver cooperation dice 
proceedings workshop cooperative solvers constraint programming held conjunction cp ithaca ny usa 
