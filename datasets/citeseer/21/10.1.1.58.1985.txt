practi replication large scale systems department computer sciences technical report mike dahlin lei gao arun praveen zheng university texas austin replication mechanisms large scale distributed systems exist require designer compromise system replication policy requiring full replication data nodes consistency policy supporting object coherence consistency topology policy assuming hierarchical organization nodes 
practi partial replication arbitrary consistency topology independence mechanisms replication large scale systems 
new mechanisms allow construction systems replicate cache data node provide broad range consistency coherence guarantees permit node communicate node time 
evaluation prototype suggests mechanism policy practi replication enables better trade offs system designers possible existing mechanisms 
example workload study practi partial replication reduces bandwidth requirements order magnitude compared full replication nodes care subset system data 
data replication fundamental technique improving performance availability ubiquity persistence broad range large scale distributed systems personal file systems web service replication systems global scale file systems enterprise data distribution systems :10.1.1.135.7948:10.1.1.12.448:10.1.1.12.2344
replication system perfect performance properties perfect availability consistency systems designed different environments different trade offs factors implementing different consistency policies placement policies topology policies 
informally consistency policies sequential causal regulate quickly newly written data seen reads placement policies demand caching prefetching push caching replicate define nodes store local copies data topology policies client server hierarchy ad hoc define paths communication flows :10.1.1.12.448:10.1.1.113.3119
unfortunately existing replication mechanisms entangled specific policy assumptions 
example bayou allows arbitrary topologies communication nodes fundamentally assumes policy full replication nodes store data volume export 
conversely coda replication policy allows nodes cache subsets data coda fundamentally assumes restrictive client server communication topology :10.1.1.12.448
describes set mechanisms time simultaneously provide practi partial replication arbitrary consistency topology independence properties 
partial replication means system place subset data node 
contrast replication systems require node maintain full copies objects volumes export :10.1.1.119.567
arbitrary consistency means system provides flexible semantic guarantees including ability selectively enforce consistency guarantees constrain order updates multiple objects observable readers coherence guarantees constrain order updates single object observable additionally constrain ordering updates different objects 
contrast replication systems enforce coherence guarantees guarantees consistency :10.1.1.12.2344
topology independence means node communicate node 
contrast systems restrict communication client server hierarchical patterns :10.1.1.12.448
base practi protocols bayou log exchange mechanisms support range consistency guarantees topology independence fundamentally assume full replication order maintain invariant node log represents causally consistent prefix system writes 
adapt protocol support partial replication principles 
separate control path data path separating invalidation messages identify changed body messages encode changes contents files 
contrast bayou protocol assumes invalidations bodies go hand hand modifications require introduce new synchronization rules enforce ordering restrictions mechanisms handling demand read misses protocols enforcing policies minimum safe degree data replication 
second imprecise invalidations allow single invalidation conservatively summarize set omitted invalidations 
define protocol allows nodes compose precise invalidations imprecise ones incrementally exchange logs mixed precise imprecise invalidations allow precise reads see consistent view data imprecise reads see coherent view data recover precision interest set imprecise 
practi mechanisms support broad range replication topology consistency policies design prototype replication microkernel carefully separates mechanism policy 
replication cores communicate asynchronous communication protocol core uses practi mechanisms enforce node safety properties regardless messages nodes sent 
separate controller layer implements system policies provides liveness triggering communication nodes 
implement flavors controller including novel uses dht scalable distributed information management system number purposes including locating data read misses forming interest set spanning trees propagate data interested nodes 
constructed prototype system evaluate microbenchmarks 
primary mechanism policy practi replication enables better trade offs system designers possible existing mechanisms 
example practi possible build system provides causal consistency bayou allows node exchange updates node coda allows node store see updates data cares 
workload study practi partial replication reduces bandwidth requirements order magnitude compared full replication nodes care subset system data practi topology independence reduces synchronization latency factor enable synchronization scenarios impossible compared restricted topology central server system mobile clients weakly connected main server 
find imprecise invalidations effective limiting additional cost providing consistency cost providing coherence 
broadly envision practi step unified replication architecture toolkit simplify development deployment large scale replication systems 
current mechanisms policies entangled replication system built new environment built scratch modify existing mechanisms accommodate new policy trade offs 
practi may help define common substrate broad range replication systems constructed 
note current system provides great deal flexibility fall short eventual goal providing unified replication architecture significant ways 
current system supports wide range consistency options including causal coherence eventual coherence causal consistency eventual consistency acknowledged writes limitations flexibility 
discuss section enhancements appear relatively straightforward extensions current mechanisms extensions include application specific conflict detection resolution tunable quantitative limits inconsistency :10.1.1.12.7323
precisely quantified boundaries semantics conveniently accommodated practi arbitrary consistency 
second accommodate families replication techniques quorums replication callback state coordinating communications nodes leases limiting staleness eventually hope integrate techniques common framework 
contributions 
describes novel mechanisms support efficient scalable practi replication 
knowledge past systems provided practi properties 
second provides prototype replication toolkit practi cleanly separates mechanism policy allows nearly arbitrary replication consistency topology policies 
rest organized follows 
section describes design practi mechanisms section details prototype core mechanisms safety controller policies liveness 
section experimentally evaluates design 
section surveys related section highlights 
practi design section describes key ideas required provide scalable practi replication 
basic idea simple 
section describes basic log exchange protocol similar bayou 
modify protocol separate control path data path separating invalidations update bodies described section separation allows avoid sending body updates nodes avoid storing bodies nodes 
third imprecise invalidations avoid full replication consistency messages state described section 
fourth extend interface basic mechanisms order support strengthening weakening consistency semantics described section 
background log exchange protocol extends bayou log exchange protocol 
order clarify terminology differences protocol bayou review basic protocol 
node issues write assigns write accept stamp comprising node id logical clock value 
logical clock lamport clock advanced local operation communication node advanced exceed maximum local remote nodes logical clocks 
node maintains checkpoint representing writes time represented version vector cpv cpv holds highest accept stamp node reflected checkpoint 
additionally node maintains log writes seen checkpoint sorted writes accept stamps logical clock primary key node id break ties version vector indicates highest node accept stamps log 
bayou core properties 
prefix property invariant node state reflects prefix sequence writes nodes system node state reflects writes including write logical time second node local state reflects causally consistent view writes occurred :10.1.1.12.448
property follows prefix property lamport clocks ensure node observed write subsequent writes accept stamps exceed third system ensures eventual consistency connected nodes eventually agree total order writes 
bayou log exchange protocol enforces properties 
send stream updates sends current version vector connects sends sequence messages startv 
receives incoming stream rejects stream element describe extension bayou log exchange protocol supports batch mode log exchange original bayou batch updates atomically applied node local state streaming log exchange node sends sequence updates individually applied 
stream startv exceeds processes write wi inserting wi sorted log updating local lamport clock 
order support fast local reads node maintains snapshot store object state time contains fields accept accept stamp latest write objid body value write 
processing wi wi accept objid accept update objid body wi body 
note simple protocol described omits features 
notably bayou writes general queries affect multiple different objects carry application specific conflict detection resolution routines :10.1.1.12.7323
furthermore bayou implements primary commit protocol establish final order prefix writes despite nodes 
discuss issues address flexible consistency section 
bayou protocol provides attractive features 
provides topology independence node exchange updates node time 
provides relatively strong consistency causal consistency eventual consistency stronger guarantees just providing coherence 
stronger consistency guarantees essential ensuring bayou application specific detection resolution procedures eventually agree total order writes eventually converge state power bayou conflict resolution mechanisms coherence individual object difference order writes different objects observed cause butterfly effect state different nodes arbitrarily diverge 
separate invalidations update bodies order add partial replication log exchange protocol topology independence flexible consistency separate control path data path separating invalidation messages update messages 
separation allows update bodies sent stored arbitrary subsets nodes system data replication policy 
invalidation messages contain fields objid identifies modified object accept accept stamp assigned writer write occurs 
node local state includes log sorted accept stamp object store representing cur simplicity describe protocol terms full object writes 
practice track writes granularity arbitrary byte ranges invalidation body messages contain offset length field addition fields discussed object state contains byte range accept valid body fields 
rent state object reads 
contains fields accept valid body 
node maintains version vector lamport clock 
invalidation log exchange 
node receives stream updates startv 
rejects stream startv node 
processes wi inserting write sorted log updating store follows wi accept objid accept objid valid inv objid accept wi accept node updates 
applying bodies 
invalidations sent causal sequence number order practi supports distribution bodies arbitrary policies arbitrary order arbitrary topologies 
practi node synchronize arriving bodies invalidation streams applying local state 
correctness practi maintains invariant update bodies applied corresponding invalidation message 
ensure nodes maintain list updates received applied local state sort list accept stamp put earliest numbered update head queue 
body message head pending update queue node waits objid accept accept objid accept accept applies update setting body field object checkpoint state body setting valid field valid objid accept accept discards systems replication policy want bodies demand caching client driven prefetching replicate server driven push globally optimized placement pushing updates objects fetched demand :10.1.1.113.3119
policy advocate having sender enqueue update bodies local priority queue sorted update priority drains receiver list tcp nice background network transfers 
notice causal consistency restricts order node applies incoming invalidations nodes different policies delay application invalidations order improve read latency availability 
particular node receives invalidation immediately apply local state wait apply corresponding update body arrives maximum delay expires 
demonstrate study waiting update arrives applying invalidation increase fraction objects stored locally valid state improves read latency system availability 
maximum delay parameter allows nodes limit worst case staleness pursuing benefits 
demand reads 
system ensures safety property providing causally consistent view data having local read request block requested object status valid 
ensure liveness invalid object read implementation arrange send body 
practi supports policy doing static hierarchy ask parent central server missing data separate centralized location metadata directory location metadata directory hint search strategy push strategy just wait data come reliability 
separating invalidations updates enables partial replication raises issue reliability bayou nodes copies data practi system need enforce explicit policy decision minimum acceptable level replication loss node local cache replacement decision render data unavailable storage system unreliable 
provide simple lowlevel mechanism supports broad range highlevel policies maintaining fixed number gold copies object propagating data provisioned central server replicated server core bayou strategy replicating practi invalidation message types unbound invalidation described bound invalidation contains addition fields listed body field contains body write created bound invalidation :10.1.1.135.7948:10.1.1.12.2344
write created invalidation initially bound 
unbind message contains accept stamp propagated system flooding strategy node receives unbind message checks see corresponding bound invalidation local log converts invalidation unbound propagates unbind message neighbors currently connected 
node seen corresponding invalidation unbound state 
implementation unbind propagation connection topology changes write occurs unbound nodes may see unbind continue propagate invalidation bound state longer necessary 
situation rare hurts performance correctness elected include heavy weight mechanism reliably propagating unbind messages logs 
conversely integrating propagation bound invalidations log conscious choice 
integrating mechanism ensuring reliability log exchange tie reliability causal order guarantees write node log depends explicitly unbound writes judged safe higher level policy bound writes node log safe due fate sharing 
help reliability algorithm decide safe unbind write node provides interface sync asynchronous request asks node send message node stored invalidation corresponding persistent redo log 
addition convenience node receives bound invalidation write originally issued node sends sync reply message regardless received sync request write 
policy controller implement example copy policy issuing sync requests various nodes write occurs receives replies issuing unbind request local node flood unbind neighbors 
analysis 
separating invalidations bodies retains topology independence causal consistency log exchange protocols allows arbitrary policies control replication bodies 
note nodes see invalidations 
imprecise invalidations imprecise invalidations allow node omit details logs sends allowing receivers enforce causal consistency 
imprecise invalidations replacing invalidation messages summary maintaining node data structures track objects safe access 
invalidation log exchange 
imprecise invalidation contains fields start arrays accept stamps target describes objects affected invalidation 
node writes summarized imprecise invalidation start value earliest summarized accept stamp value latest summarized accept stamp 
target may encode covered objects manner long conservative allows receiver invalidation identify objects affected summarized writes 
implementation encodes target list directory paths path represents individual file directory foo bar subtree 
note precise invalidation special case imprecise invalidation single writer start single object target 
term general invalidation refer precise cise invalidation 
system forms imprecise invalidation union operation general invalidations gi gi start arrays entries server gi gi start start min gi start gi start max gi gi target encompassing objects encompassed gi gi targets 
node groups system data interest sets tracks interest set precise meaning node local state reflects invalidations overlapping interest set imprecise meaning node local state causally consistent interest set due overlapping imprecise invalidations 
algorithm summarizes node processes stream general invalidations startv gi gi 
interest set data 
interest set node maintains interest set membership precise version vector lpv represents highest version vector precise invalidations applied current version vector cv represents highest version vector general invalidation applied algorithm startv gi gi 
interest set startv startv return reject stream preserve prefix property pending new set gi gi null max startv gi start pending apply overlapping gi start time log insert gi startv gi target intersects gi isp lpv startv gaps precise inval update lpv max lpv gi start max gi startv gi isp objid update gi start inv pending insert gi gi apply non overlapping pending time target intersects lpv startv lpv max lpv max pending remove rely prefix property reasoning messages stream 
particular stream begins guarantees subsequent invalidations represent causally consistent sequence omissions starting 
support incremental application multiple instances algorithm execute concurrently interleave application invalidations algorithm updates stream set processing invalidation 
simplicity pseudo code shows single interest set version protocol see appendix full version 
node applies general invalidations stream interest set sorted order timestamps handled differently depending overlap interest set 
invalidation overlaps interest set applied start time arrives stream overlap buffered time guaranteed causally dependent remaining start time stream happens time startv value hold invalidation processed start time 
gi start time insert sorted log invalidations update local random access store 
invalidation overlaps advance time invalidation indicating data reflect invalidations order considered current 
advance interest current missing precise invalidation gi general invalidation fact precise invalidation gi introducing missing precise invalidation 
invalidation overlaps interest set advance interest set invalidation precise update object state way described section 
conversely invalidation overlap interest set safely ignored carries invalidations interest set imprecise 
fact invalidation intersect interest set useful shows period time invalidations precise imprecise intersected interest set information help disambiguate general invalidations overlap interest set time 
gi time invalidation target overlap advance gi startv update elements great gi 
log update 
desire support partial replication arbitrary topologies complicates log updates 
simply inserting received invalidation gi local log sorted order sufficient interpreting general invalidation done context stream received 
particular gi interpreted stream startv indicates causally required invalidations ing startv gi start 
order avoid losing valuable information node inserts gi log decomposes gi writer general invalidations uses gap filling intersection operations encode missing invalidations information 
decomposing gi writer general invalidations gi simple server gi start generate gi gi start gi gi target 
gap filling operation writer log maintains gap time element start time element 
node inserts gi writer log startv gi newer newest element log fills gap gi existing element inserting new gap filling invalidation start stamp larger highest existing stamp stamp smaller gi start empty target 
intersection operation maintain invalidation covers moment time writer log 
intersect general invalidations gi gi replacing general invalidations covers time earlier start start targets objects targeted earlier start second covers time start earlier covers targets represented intersection gi gi targets third covers time earlier covers targets 
send stream invalidations node discard gap filling invalidations combine writer invalidations multi writer invalidations policy described section 
demand reads 
demand read occurs blocks interest set targets precise 
blocking ensures safety property reads observe causally consistent view 
section describe reader relax guarantees 
reads invalidated objects system policy selecting nodes connect order retrieve precise invalidations needed interest set precise 
example 
illustrates mechanisms action 
node writes objects node cares object receives precise invalidations imprecise invalidations node cares object receives precise invalidations imprecise invalidations node cares receives precise invalidations imprecise invalidations due imprecision precise invalidations imprecise invalidations 
sends stream node alpha cvv write write write write write write stream start bc bc stream start ab ab node beta cvv bc bc cvv node gamma ab ab cvv cvv node delta stream cvv start cvv cvv bc start ab ab bc delta final writer log alpha fig 
illustration imprecise invalidation mechanisms split join scenario 
nodes share objects node show interest set information precise version vector lpv current version vector cv invalidation stream information startv series generalized invalidations interest set information startv updated generalized invalidation applied 
clarity show component version vectors omit node id accept stamps 
tions precise imprecise 
illustrated invalidation advances invalidation stream interest set startv value interest set precise version vector lpv current version vector cv interest set 
second invalidation bc intersects interest set message causes interest set imprecise subsequent invalidations fail advance interest set lpv processing invalidations stream precise interest set imprecise interest set 
behavior processing stream precise invalidations imprecise invalidations similar 
send log contents show case processes invalidations invalidations fourth invalidation 
shows processing invalidations precise imprecise 
messages precise imprecise 
message brings state desire seeing precise invalidations objects precise interest set despite fact precise messages mixed imprecise invalidations objects may verify gap filling intersection operations log contains sufficient information node receives log contents get precise updates objects conversely note simply interleave messages received gap filling intersection send information lost case current log algorithm extracts bit information stream incoming requests interest set status algorithm sure clean way extract information interest set maintenance 
left imprecise interest sets 
checkpoint recovery 
protocol describes common case streaming incremental log exchange 
nodes garbage collect logs system handle case node requests data newer interest set 
protocol handles case doing full state transfer interest set sends cvv interest set accept stamp object interest set object state 
updates cvv interest set accept time receives object exceeds locally stored accept time updates local accept time object marks object valid 
note checkpoint recovery done interest set basis interest sets updated advanced checkpoint 
analysis 
algorithm retains topology independence causal consistency allows partial replication bodies invalidations 
particular maintain interest set precise state requires number writes interest set precise invalidations plus imprecise invalidation summarizing invalidations intersect interest set 
practice systems may send imprecise invalidations minimum order limit delay assembling sending invalidation stream described section 
tunable consistency basic mechanisms provide solid substrate straightforward weaken system consistency guarantees improve performance availability face partitions strengthen system consistency guarantees meet application semantic requirements 
weakening consistency 
default demand reads block interest set precise ensure data return represents causally consistent view system state 
provide interface overrides behavior allowing imprecise reads skip cvv check return data soon local store record requested object valid regardless interest set resides precise imprecise 
nodes interface observe causally coherent data node reads version vj object writes version vj object node reads version vj object subsequent read return version vj version longer guaranteed observe causally consistent view node reads version va object writes version vb object node reads version vb object imprecise read may observe version object older va potential benefit doing imprecise read node read object currently imprecise interest set communicating nodes interest set precise 
imprecise reads reduce bandwidth consumption improve response time improve availability 
note node executes imprecise reads issues writes protocol ensures log contains sufficient imprecise invalidations put invalidations causally consistent order sends log continue provide causal consistency objects 
strengthening consistency 
library interface built low level mechanisms provided basic practi interface strengthen consistency guarantees 
particular sync interface described allows construction write blocks update propagated specified set machines 
option strengthening consistency plan explore layering tact basic mechanisms provide tunable consistency guarantees 
conflict detection resolution 
simple protocol described provides incremental log exchange writer wins conflict resolution global eventual consistency case concurrent writes 
useful resolve conflicts globally consistent way flag provide information conflicting writes flexible manual programmatic conflict resolution procedure 
discuss extended technical report augment protocol described including hooks detect write write conflicts adding field invalidation messages object store records storing losing writes local unshared object conflict file providing utility functions read delete losing writes conflict files part compensating transaction application specific conflict resolution 
causal consistency opposed coherence useful conflict detection resolution protocol ensures nodes agree set conflicts losing writes 
extended report describes practi mechanisms bayou powerful strategy associating application specific conflict detection resolution functions writes :10.1.1.12.7323
reasons simpler approach support incremental batch log exchange improved performance avoid need commit protocol ensure late arriving writes include detection resolution programs arbitrarily disrupt current state placed committed writes 
implementation practi techniques cleanly separate mechanism policy order support broader range replication policies available current techniques policy choices mechanisms replication consistency topology 
implementation seeks serve replication microkernel provides basic low level mechanisms higher level services built 
practi mechanisms ensure safety 
prototype uses asynchronous style communication incoming messages streams rules processing incoming message completely defined interpreting message require knowledge request triggered transmission 
message handling rules practi algorithms ensure safety regardless policy sending messages machine send legal protocol message machine time receiver rules processing incoming messages embed assumptions communicates assumptions data replicated machines enforce rules track object interest set consistency state messages received 
low level mechanisms enforce safety independent policy higher level policies focus liveness including performance availability concerns 
essentially policy layer job ensure right nodes send useful data right time order things satisfy read prefetch data improve performance provision node local storage data available inval streams body streams sync streams requests remote cores local api practi core log inform read write delete controller local store mgmt 
inval streams body streams sync streams requests remote cores fig 
high level architecture practi prototype 
nected 
node provides interface requesting node send invalidations bodies nodes requests regarded hints loss messages extra messages affect system performance correctness responses application read write requests 
illustrates division labor mechanism policy system 
practi core maintains local state log reliability communication local store random access 
core receives generates streams general invalidations precise imprecise bound invalidations bodies demand replies prefetched pushed data sync replies support unbind consistency policies described sections core provides remote request interface allows remotely generated requests trigger outgoing streams individual messages 
controller purpose send requests asking nodes cores trigger streams messages 
aid task core informs local controller important events connection initiation termination local requests message arrivals 
customize replication system environment different controllers different policies 
example implement static creates static topology nodes propagating invalidations bodies satisfying demand requests permanently leaves invalidations bound state uses dht scalable information management system track state distributed system 
core implementation core implements procedures applying incoming request messages local state ensure rules described section enforced 
core local state main parts log data store 
log 
core log main purposes 
acts replay log reliability 
second maintains causally ordered lists invalidations nodes 
log implementation components 
single disk append replay log invalidation messages local updates unbind messages stored order received 
second maintains memory writer log invalidations local updates sorted accept stamp 
incoming messages appended disk replay log described section decomposed single writer invalidations merged single writer logs gap filling intersection enforce writer log contains list elements overlap time 
data store 
data store maintains interest set status tracks precise version vector current version vector cvv interest set described section 
implementation interest set identified subdirectory name includes path root subdirectory enclosed subdirectories 
data store maintains object metadata body information 
object system file local disk holds body object byte file corresponding byte object 
second file holds object consistency state series records offset length identifying accept identifying accept stamp invalidation applied identifying accept stamp previous write conflict detection described section valid flag indicating body file contents valid invalid range 
simplicity implement object consistency state java object manage memory cache objects serialize dirty objects object disk files checkpoints 
operation 
section outlines core processes incoming invalidation body messages local read requests 
local write delete requests treated incoming invalidation requests applied log local store 
incoming sync replies effect core state 
core interface trigger outgoing streams invalidations 
request start invalidation stream includes destination node id send data version vector indicating desired starting point precise set listing subdirectories receiver prefer receive precise invalidations sender available 
sender thread tasks draw requests logs causally consistent order second reduce network overhead combining invalidations imprecise invalidations sending resulting stream general invalidations causally consistent order 
accomplishes task initializing drawing writer logs element lowest accept stamp exceeds updating include time element 
key accomplishing second task observation causally consistent sequence general invalidations 
gn select subsequences appears element appears elements appear relative order form imprecise invalidation union invalidations defined section sequence represents causally consistent sequence 
property follows fact imprecise invalidation intersects receiver interest set arrives receiver advances cv advance lpv conversely intersect arrives receiver waits advancing cv lpv case processing message gi lpv higher gi processed part original sequence cv high precise processing message gi precise processing message save bandwidth avoiding unnecessarily making interest sets imprecise sender buffers outgoing invalidations aggregates ones intersect outgoing stream draws sequence invalidations log adds gi gi intersect precise set appends gi sequence pending invalidations 
node sends clears timeouts occurs ms elapsed element placed instance ms elapsed non empty 
typically nodes may tolerate longer delays updates information don care 
note current prototype implements limited version logic allows set trigger request assumes 
generating outgoing body streams similar simpler safety system depend order body messages sync replies 
node receives request body node uses data local store generate send body message object id byte range range accept stamp data requested offset valid 
note local data invalid state node reply indicate zero length body semantic effect receiver generate event receiver controller hint retry different node data store record object offset node generates low numbered accept stamp reply effect 
efficiency prototype maintains pool tcp connections body messages amortize tcp setup costs pipeline sends multiple bodies sent node 
core provides interface request node push bodies newer version vector node specified object subtree object name space 
implementation allocates bounded size priority queue drains update body messages low priority network connection inserts priority queue new body matching subtree object priority supplied controller 
recovery garbage collection 
order allow trimming update logs nodes checkpoint local store state 
checkpoint comprises version vector indicates disk state reflects application general invalidations list interest sets interest set version vector indicating time interest set precise object metadata current object interest set object body bound invalidations reflected checkpoint node controller free direct node discard unbound body limit space consumption 
checkpoint stored prefix log may truncated practice keep longer prefix log facilitate incremental synchronization nodes 
controller implementation core controller initiates communication core needs subscriptions invalidation streams subscriptions prefetch body streams requests bodies satisfy demand read misses 
controllers issue maintenance directives local core issues cache replacement garbage collection 
controller subsystem defined interface 
interface anticipate wide range different implementations providing different policies 
interface operation 
controllers interfaces accomplish core calls controller inform interface inform controller important events controller calls remote core remote request interface trigger sends controller calls core management interface maintenance functions cache control 
additionally set controllers implementing specific distributed policy may communicate policy specific interfaces 
core uses local controller inform interface inform controller events interest 
implementation core informs local controller stream connection initiation termination invalidations updates inval sync body message arrival events local events read hit read read imprecise read blocks accessing imprecise interest set write 
controllers respond inform events sending request messages remote core remote request interface 
example informed read controller uses policy specific strategy identify node supply sends request node body 
things happen body arrives core unblocks waiting read request causes core inform controller body arrive event empty body arrives core signifying sender desired data controller receives body arrive event empty body controller sends body read request timeout event occurs controller controller issues body read request 
core local management interface allows controller query core learn internal state set status object state log status connection status manage local state shut connection mark object invalid garbage collect body storage tracking cvv new interest set 
controller concretely illustrate interactions controller core describe controllers built 
controller uses dht system coordinate distributed collection controllers 
note current controller intended proof concept practi mechanisms full fledged replication system 
intend build complete replication system practi desirable features implemented detail 
prototype uses maintain spanning trees invalidation update streams 
illustrates interest set node informs interest aggregates information locality aware administrative unit aware trees selecting interested node subtree function subtree root 
node finds parent creates invalidation optionally update streams parent note updates parent spanning tree fig 
example invalidation update spanning tree formed interest set foo bar 
circles represent virtual tree formed interest set foo bar solid nodes represent nodes interested foo bar numbers denote id node selected spanning tree root subtree arrows show node node connections guidance 
set foo bar relevant interest set foo vice versa root node spanning tree selects parent node spanning tree shorter path formed deleting path 
controller maintains spanning tree connections retrying communication failures notifies node parent spanning tree changed 
similar approach maintaining distributed directory satisfying local read misses 
node informs valid byte ranges caches queries misses find nearby copy data :10.1.1.38.1850
note ensures eventual consistency spanning tree parent body supplier suggested may correct parent may desired data may unreachable 
problem handled continuous probe interface notify controller parent changes 
controller handles stale values timeouts retrying queries flag stored values children distributed tree 
complete version distributed file system require additional features 
plan allow node locate nearby node interest set status interest set precise specified point time 
information useful filling holes node imprecise invalidation interest set wishes maintain precise 
providing information entail maintaining interest set writer aggregation functions subtree identify node subtree highest accept stamp interest set writer 
second plan track read write rates different objects 
prefetch algorithms information prioritize replication 
third complete controller implement policies local cache replacement total bytes transferred mb full replication invalidate traffic data traffic partial replication fig 
scalability practi garbage collection log 
partial replication files evaluation section evaluate properties practi prototype 
flexibility provided practi mechanisms provides significant advantages past systems 
mechanism policy practi represents single flexible system match systems optimized specific topology replication consistency environments 
second providing clean general substrate practi enables better trade offs available existing system important environments 
experiments primary separation invalidations updates reduce bandwidth consumption order magnitude compared full replication systems workloads locality interest imprecise invalidations provide significant reduction synchronization overheads systems large numbers files nodes care subsets files flexible topologies significantly reduce synchronization delays particularly mobile low bandwidth environments imprecise invalidations bandwidth cost providing consistency guarantees approach cost providing weaker coherence guarantees 
show number bytes transferred various replication strategies 
run experiments machines sender writes random files receiver reads random files 
sender generate files bytes perform random writes 
receiver reads files 
assume receiver replicates directories system directory assume receiver replicates files directory 
total bytes transferred mb full replication bayou invalidate traffic data traffic partial replication fig 
scalability practi partial replication files evaluate bandwidth consumed practi configurations full replication sender sends precise invalidates modified files partial replication sender sends precise invalidate message modified file lies directory replicated receiver subset replicated receiver partial replication files sender sends precise invalidate messages exactly files replicated receiver 
evaluate bandwidth consumed practi conservative algorithms sender push files receiver forces receiver demand fetch files necessary 
note restricting sender sending precise invalidate messages files lie replicated directories successfully reduce bandwidth consumption factor 
restrict sender sending invalidate messages exactly files lie receiver interest set successfully reduce bandwidth consumption factor 
due large difference number files written sender number reads receiver bandwidth spent sending invalidate messages result demand data bar visible 
transferring file data consumes bandwidth relative benefits yielded sending imprecise invalidates reduced 
shows bandwidth consumed practi aggressive algorithms modified file sender sends invalidate message sends modified data 
line represents case sender pushes updates receiver done bayou 
note restricting sender sending updates occur files lie replicated directories sender consumes factor bandwidth 
laptop pda phone bw bw replicate kb kb inval interest update kb kb interest update interest inval kb kb hierarchy impossible kb table bandwidth consumption synchronization 
furthermore restricting sender sending updates files replicated receiver sender uses factor bandwidth compared fully replicated configuration 
table shows bandwidth costs synchronizing collection machines various mechanisms policies 
emulated scenario user hotel room laptop pda phone share mbit wireless connection user account fixed server laptop access kbit modem link available 
synthetic workload files kb size exist server files laptop pda phone 
assume synchronization event files location changed 
compare synchronization costs scenarios connection server available laptop pda phone able communicate connection server available 
table compares protocols synchronizing devices 
replicate approach replicates data distributes updates devices similar bayou 
second strategy separates invalidations updates devices subscribe invalidations subscribe hoard updates files interest sets 
third strategy restricts subscriptions interest sets metadata data 
fourth strategy requires communication server client traditional client server systems third approach client server system restricts subscriptions interest set data metadata 
table illustrates separating invalidations update bodies providing nodes access bodies care significantly reduces bandwidth requirements 
example second strategy uses order magnitude bandwidth 
note allowing nodes observe subsets invalidations provides significant reductions 
example laptop server share data third strategy reduces bandwidth universe data larger gb devices shared smaller subsets data number increase 
note advantage topology independence 
centralized synchronization metadata required laptop pda phone sync time sync time replicate inval interest update interest update interest inval hierarchy impossible table synchronization delays 
due time limitations unable complete replicate run slow network link submission cut run short seconds 
bandwidth constraints full run take seconds 
replication systems force user scenario dial order synchronize pda laptop devices room thousands miles away server clearly restrictions burdensome 
table illustrates scenario 
table shows synchronization times unoptimized version system restrict bandwidths values listed 
compared replicate strategy partial replication reduces synchronization delay factor expect gap widen tune system 
optimized peer topeer exchange data reduces time compared hierarchical system network server available 
table illustrates efficiencies come imprecise invalidations benefits having flexibility choose data track detail precise imprecise subscribe bytes bytes subscribe bytes bytes experiment node imprecise directory subtree containing files file subtree 
node precise file question process data subtree may directories include file precise levels ancestors 
show cases node nearest files data precise node nearest files data precise 
note case requires order magnitude bandwidth second approach due imprecise invalidations ability stand large numbers precise invalidations 
note additional overheads required carry imprecise invalidations provide consistency just coherence small compared precise information shown compared body data files accessed 
note imprecise invalidations reduce metadata bandwidth cost synchronizing subset volume orders magnitude compared synchronizing items precisely 
experiments described demonstrate key properties practi approach 
evaluation efforts ongoing expect complete additional experiments immediate 
related replication fundamentally difficult 
example brewer describes cap dilemma replication system provides sequential consistency simultaneously provide availability environment partitioned 
similarly lipton sandberg describe fundamental performance limitations distributed systems provide sequential consistency 
result systems compromises optimize specific workloads 
unfortunately workload specific compromises reflected system mechanisms just policies 
particular state art mechanisms allow system designer retain full flexibility dimensions replication consistency topology policy 
set systems sprite afs coda support arbitrary replication policies principle support range consistency policies practice systems typically implement specific consistency policy protocols fundamentally assume topology policy restricts communications hierarchical paths 
client server systems permit limited client client communication cooperative caching serialization control messages server vital reasoning consistency :10.1.1.110.7161
second set systems bayou tact ivy log propagation mechanism capable providing range consistency guarantees supports arbitrary topologies :10.1.1.119.567
mechanisms assume replicate placement policy maintains copy objects volume node participates volume replication system 
third set systems ficus pangaea maintain synchronization information separately object support arbitrary topology policies arbitrary replication policies 
systems provide coherence guarantees order reads writes individual object considered provide limited consistency guarantees regarding ordering reads writes objects 
practi partial replication arbitrary consistency topology independence mechanism replication large scale systems 
new mechanisms allow construction systems replicate cache data node provide broad range consistency coherence guarantees allow node communicate node time 
evaluation prototype suggests mechanism policy practi replication enables better trade offs system designers possible existing mechanisms 
cleanly separating mechanism policy speculate practi may serve basis unified replication architecture simplifies design deployment large scale replication systems 
tivoli data exchange data sheet 
www tivoli 
com products documents data exchange ds pd 
anderson dahlin neefe patterson roselli wang 
serverless network file systems 
acm trans 
computer systems february 
bent voelker 
page performance 
workshop web caching content distribution september 
blaze alonso 
dynamic hierarchical caching large scale distributed file systems 
proceedings th international conference distributed computing systems pages june 
brewer 
lessons giant scale services 
ieee internet computing july august 
chandra dahlin richards wang anderson larus 
experience language writing coherence protocols 
usenix conference domain specific languages october 
dahlin chandra gao 
wan service availability 
acm ieee transactions networking april 
dahlin gao zheng 
practi replication large scale systems 
www cs utexas edu users dahlin papers practi osdi submission extended pdf may 
dahlin wang anderson patterson 
quantitative analysis cache policies scalable network file systems 
proc 
sigmetrics pages may 
dahlin wang anderson patterson 
cooperative caching remote client memory improve file system performance 
proc 
osdi pages november 
feeley 
measured access characteristics world wide web client proxy caches 
proc usits december 
feeley morgan karlin levy thekkath 
implementing global memory management workstation cluster 
proc 
sosp pages december 
gadde chase rabinovich 
taste squid 
workshop internet server performance june 
gao dahlin zheng iyengar 
application specific data replication edge services 
international world wide web conference may 
gray cheriton 
leases efficient fault tolerant mechanism distributed file cache consistency 
proc 
sosp pages 
griffioen appleton :10.1.1.113.3119
reducing file system latency predictive approach 
usenix summer conf june 
guy heidemann mak page gerald popek 
implementation ficus replicated file system 
usenix summer conf pages june 
gwertzman seltzer 
case geographical 
hotos pages may 
howard kazar menees nichols satyanarayanan sidebotham west 
scale performance distributed file system 
acm trans 
computer systems february 
ahamad :10.1.1.12.448
slow memory weakening consistency enhance concurrency distributed shared memories 
proc 
icdcs pages 
kistler satyanarayanan 
disconnected operation coda file system 
acm trans 
computer systems february 
ladin liskov shrira ghemawat 
providing high availability lazy replication 
acm trans 
computer systems 
lamport 
time clocks ordering events distributed system 
comm 
acm july 
lamport 
multiprocessor computer correctly executes multiprocess programs 
ieee transactions computers september 
lipton sandberg 
pram scalable shared memory 
technical report cs tr princeton 
maniatis roussopoulos tj giuli rosenthal baker 
preserving peer replicas rate limited sampled voting 
proc 
sosp october 
muntz honeyman 
multi level caching distributed file systems cache ain trash 
usenix winter conf pages january 
muthitacharoen morris gil chen :10.1.1.119.567
ivy read write peer peer file system 
proc 
osdi december 
dahlin iyengar 
transparent information dissemination 
proc 
middleware october 
nelson welch ousterhout 
caching sprite network file system 
acm trans 
computer systems february 
petersen spreitzer terry theimer demers 
flexible update propagation weakly consistent replication 
proc 
sosp october 
plaxton richa 
accessing nearby copies replicated objects distributed environment 
proceedings ninth annual acm symposium parallel algorithms architectures pages june 
saito karlsson mahalingam 
taming aggressive replication pangaea wide area file system 
proc 
osdi december 
sarkar hartman 
efficient cooperative caching hints 
proc 
osdi pages october 
terry theimer petersen demers spreitzer hauser 
managing update conflicts bayou weakly connected replicated storage system 
proc 
sosp pages december 
tewari dahlin vin kay 
design considerations distributed caching internet 
proc 
icdcs may 
dahlin 
tcp nice mechanism background transfers 
osdi december 
dahlin 
bandwidth constrained placement wan 
podc august 
dahlin 
potential costs benefits long term prefetching content distribution 
elsevier computer communications march 
dahlin 
scalable distributed information management system 
acm sigcomm conference august 
yin alvisi dahlin iyengar 
engineering web cache consistency 
acm transactions internet technologies 
yin alvisi dahlin lin 
hierarchical cache consistency wan 
proc usits october 
yu vahdat 
costs limits availability replicated services 
proc 
sosp 
yu vahdat 
design evaluation continuous consistency model replicated services 
acm trans 
computer systems august 
details design multi interest set generalization section shows simplified version practi algorithm applying stream general invalidations single interest set actual implementation handles multiple interest sets drawing invalidation stream applying invalidation log interest set status record 
support maintain stream interest set 
algorithm shows extension 
design conflict detection resolution simple protocol described section provides incremental log exchange writer wins conflict resolution global eventual consistency case concurrent writes 
useful resolve conflicts globally consistent way flag provide information conflicting writes flexible manual programmatic conflict resolution procedure 
support flexible conflict detection resolution augment algorithm described adding field invalidation messages object store state 
node receives invalidation inv applies inv local store object obj inv accept obj accept cases consider 
inv obj accept write write conflict 
second case inv obj accept impossible prefix property 
third case inv obj accept represents write write conflict resolved updating obj inv obj higher accept stamp storing losing entry disk local non shared object conflict file bodies match stored losing writes stored 
practi implementations provide local interface reading deleting losing conflicting writes allows higher level code resolve conflicts application specific rules generating compensating transactions 
note different nodes see different series losing writes nodes interest set precise guaranteed see final write algorithm startv gi gi 
process token 
startv sis create apply gap filling imprecise inval start min max start target path target overlaps process general invalidation stream 
pending new set gi gi null max startv gi start pending log insert gi gi target intersects gi startv sis startv sis gi isp objid update gi start inv pending insert gi gi apply non overlapping pending time target intersects startv sis pending remove procedure gi startv gi isp lpv startv gaps precise inval update lpv max lpv gi start max gi procedure startv lpv startv lpv max lpv max causally independent series 
example consider case causal chains writes location nodes 
protocol guarantees eventually precise node agree final state write result write time conflict lost different nodes may see different subsets acceptable causal chain regards important values final state system 
alternative write conflict detection resolution code 
practi mechanisms compatible bayou powerful strategy associating application specific conflict detection resolution code write re executing code time set writes preceding changed log exchange operation 
advantage flexible approach detect write write readwrite conflicts 
chose simpler compensating transaction approach reasons 
restrictive approach allows efficient incremental application interleaved streams updates require roll back current random access state process arriving write determination conflict occurred decision final state object comparing write fields local object fields 
contrast bayou conflict detection resolution code logically run point time write occurs able read state system time 
result apply newly arriving write system rolls back state logical time write applies write subsequent writes 
cost tenable bayou bayou designed batch application updates amortizes cost rolling back reapplying updates batch newly arrived updates 
second simpler approach allows avoid need commit protocol establish final write order differs natural order accept stamps 
bayou line execution powerful conflict resolution code introduces possibility butterfly effect single previously unseen low timestamped write log cause newer writes log execute different conflict detection resolution code path write different values different objects 
principle previously unseen old write applied resulting system state look arbitrarily different previous system state 
bayou limits problem primary commit protocol connected nodes establish order writes causes writes sorted time writes 
conversely writer wins approach vulnerable late arriving writes despite delay write logically newest write object object updated late arriving write logically older writes applied effect logged conflict 
considerations fundamental practi trade offs apply existing systems 
factor may relevant practi centralized commit protocol bayou may limit scalability practi requires primary node see invalidation messages issue limit bayou bayou requires nodes see updates 
open question exists suitable scalable commit protocol avoid need node see invalidations 
implementation checkpoint recovery node boots recovers local store checkpoint memory writer log disk log 
node simply issues request network request interface asking log send stream invalidations precise set comprising union node interest sets starting 
node receives causally consistent stream updates log applied checkpoint processes requests normally adds log ignored redundant data store 
node receives request stream updates earlier start node log node responds sending checkpoint requested interest set followed normal stream invalidations 
apply remote checkpoint node local state interest set node treats checkpoint imprecise invalidation intersects interest sets starts node current ends max node checkpoint applies inferred imprecise invalidation log interest set status 
node update state updating lpv max lpv checkpoint lpv applying invalidation stored checkpoint object state precise invalidation local log local state 

