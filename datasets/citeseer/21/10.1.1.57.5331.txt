specialization perceptual processes ian horswill december report discuss vision support concrete everyday activity 
argue variety interesting tasks solved simple inexpensive vision systems 
provide number working examples form state art mobile robot polly uses vision give primitive tours seventh floor mit ai laboratory 
current standards robot broad behavioral repertoire simple inexpensive complete robot built commercial board level components 
approach treat structure agent activity task environment positive resources vision system designer 
performing careful analysis task environment designer determine broad space mechanisms perform desired activity 
principal thesis broad range activities space applicable mechanisms broad include number mechanisms simple economical 
simplest mechanisms solve problem typically quite specialized problem 
worries building simple vision systems require great deal ad hoc engineering transferred problems 
second thesis specialized systems analyzed understood principled manner allows general lessons extracted specialized systems 
general approach analyzing specialization transformations provably improve performance 
demonstrating sequence transformations derive specialized system general summarize specialization compact form explicit additional assumptions environment 
summary predict performance system novel environments 
individual transformations recycled design systems 
contents approach example coloring algorithm navigation analysis coloring algorithm preview results lightweight vision mobile robotics analysis specialization structure report polly system task environment software architecture detailed example giving tours programming language issues hardware design visually guided mobile robots systems geometric maps non geometric systems outdoor road lightweight vision background problems reconstruction active vision task vision building lightweight vision systems resources simplifying vision distributed representation mediation related summary ii formal analysis specialization part ii background loopholes life computational minimalism transformational analysis synthesis versus post hoc analysis related read part ii framework agents environments equivalence specialization optimization simple example analysis simple perceptual systems derivability equivalence unconditional equivalence transformations transformations simple vision systems analysis action selection environments discrete control problems cartesian products solvability separable agents hidden state sensors externalization internal state progress functions construction dcp solutions decomposition product reduction iii design polly core visual system computation depth detection carpet boundaries vanishing point detection person detection symmetry detection protrusion test gesture interpretation foot waving nod detector second nod detector summary low level navigation speed controller corridor follower aligning corridor avoiding walls integrating control signals wall follower general obstacle avoidance ballistic turn controller steering arbitration fep bump reflex odometric sensing high level navigation derivation geometric path planner navigation polly navigator unwedger place recognition sequencers plan language giving tours iv results experiments polly speed processing speed driving speed complete test runs environments tech square brown cs department burn tests limitations failure modes useful extensions low level navigation navigator unwedger place recognition camera limitations multi modal sensing summary polly works lightweight vision studying world frame database log burn run polly source code main loop tour demo lisp core vision system vision lisp library lisp low level navigation motor control lisp high level navigation place recognition lisp lisp navigator lisp wander lisp giving tours sequencers lisp interact lisp voice chatter lisp lisp list figures office image texture office scene 
viewing textureless cliff carpet blob 
patrol pattern gross anatomy polly high level states leaving office polly habitat basic components layout robot computational components data paths robot hardware coordinate system gpc effect perspective projection fourier spectrum surface patch monotonicity image plane height body depth environment serial product major components core vision system computation texture height source code find dangerous source code carpet boundary 
vanishing point computation source code vanishing point low level navigation system corridor problem nearest points view layout polly environment high level navigation system 
landmarks polly environment qualitative coordinates 
example place frames 
source code frame matcher source match frame source code find districts sequencer leaving office sequencer offering tour sequencer giving tour detail elevator lobby area transcript test run 
transcript test run cont transcript second test run 
transcript third test run 
transcript third test run cont 
transcript test run 
transcript test run cont 
typical robot paths playroom shadow problem peculiarities peculiarities polly runtime system 
list tables partial list visual percepts habitat constraints depth recovery 
habitat constraints vanishing point computation 
constraints nod detection habitat constraints assumed core vision system summary habitat constraints navigation processing driving speeds various visual navigation systems execution times various levels competence acknowledgments advisors rod brooks lynn stein support encouragement 
time graduate student suffered badly right time 
members committee tom knight shimon ullman eric grimson time patience support 
particularly eric time put talking giving suggestions committee 
document owes patrick winston comments talks 
fellow graduate students important part graduate education 
phil agre david chapman orca taught moved 
phil ways advisor 
members lab particularly maja mataric dave miller research scientist grad student anita flynn colin angle patient reading drafts showing build power supply 
dave miller joanna bryson read tr gave useful comments 
various office mates eric paul resnick david michael jose tina kapur gave comments papers talks ideas general nonsense put moody 
local vision people vision people particularly karen mike henry minsky steve white sandy wells david jacobs david clemens gave useful advice encouragement skepticism 
members lab jeanne annika laurel simmons jonathan meyer ron life easier 
patrick sobalvarro carl de marcken dave 
friend ask 
local hardware hackers particularly tom knight mike moore mike henry minsky anita flynn colin angle earned gratitude putting ee questions building robot 
number people helped thesis giving pep talks encouragement conferences 
particularly bruce donald avi kak stan rosenschein takashi ron arkin jim hendler drew mcdermott 
years marshall craig john rob diana walker rick rose stout david omar white remained friends done poor job keeping touch 
parents love care wife louise support research provided part university research initiative office naval research contract part advanced research projects agency office naval research contract 
preface polly demise documents part development testing polly robot 
claim polly fast robust broad behavioral repertoire measured current standards field 
stated record polly dead boards reluctant boot properly base broken gear teeth 
speaks inadequacies hardware 
electronics designed run batteries continuously periodically crashed walls 
base ultra reliable standards robot research hardware designed exert accelerations pounds metal move metal meter second hours day year 
algorithms developed polly live 
low level navigation algorithms reimplemented lab gopher robots 
labs starting algorithms commercial version collision avoidance system available 
writing basics turn detection control reimplemented full place recognition navigation system considerably sophisticated polly 
think odd feel large chunk metal 
didn spend time chasing lab 
ian horswill cambridge september polly robot part approach chapter report discuss vision support concrete everyday activity 
argue variety interesting tasks solved simple inexpensive vision systems 
provide number working examples form state art mobile robot polly uses vision give primitive tours seventh floor mit ai laboratory 
current standards robot broad behavioral repertoire simple inexpensive complete robot built commercial board level components 
approach treat structure agent activity task environment positive resources vision system designer 
performing careful analysis task environment designer determine broad space mechanisms perform desired activity 
principal thesis broad range activities space applicable mechanisms broad include simple economical 
simplest mechanisms solve problem typically quite specialized problem 
worries building simple vision systems require great deal ad hoc engineering transferred problems 
second thesis specialized systems analyzed understood principled manner allows general lessons extracted specialized systems 
general approach analyzing specialization transformations provably improve performance 
demonstrating sequence transformations derive specialized system general summarize specialization compact form explicit additional assumptions environment 
summary predict performance system novel environments 
individual transformations recycled design systems 
example suppose view vision problem answering questions environment images 
shows image office taken robot 
want determine robot turn left right avoid objects scene 
amounts problem finding regions floor free objects top 
correct answer robot turn left obstacles nearby right clear floor left 
fundamental difficulty vision problems projection process camera loses information depth information particular uniquely determine structure scene additional information form extra images extra information assumed problem 
common way solving problem build complete depth map scene multiple images 
project features depth map floor plane determine parts floor obstacles top 
simplest version cameras stereo configuration 
distinctive features usually edges images matched 
matching features compute feature shift due parallax 
camera positions parallax data compute positions surface patches world individual features imaged see barnard fischler 
stereo approach perfectly reasonable approach undesirable features 
computationally expensive particularly matching phase 
requires features localized accurately reliably usually means high resolution data requires computational power 
important problem floor environment textureless featureless 
shows map image pixels significant texture significant intensity gradients marked white 
floor uniformly black 
stereo process depth measurements region image important robot features matched 
problem easily remedied 
floor flat reasonable stereo system interpolate flat surface absence texture 
important remember stereo system working measuring depth floor directly making smoothness assumption happens true floor 
need true general case 
floor slope gently suddenly 
cliff 
sudden discontinuity depth typically generate image features discontinuity features side image office taken robot camera 
dots lower middle image artifacts due quantization rendering process 
structure lower right hand portion image legged office chair 
structures top left left right doorway viewed oblique angle small trash file cabinet 
homogeneous region lower middle left carpet 
pixels significant texture 
pixels marked white differ neighbors right total grey levels possible 
pixels marked black differ grey levels 
image smoothed theta filter remove camera noise 
note floor uniformly black 
image situation observer views cliff textureless surface left 
variations lighting sides cliff may produce local variation image brightness point discontinuity right texture image discontinuity allow observer infer depth presence cliff 
discontinuity detect cliff see 
brings important points 
truly general systems extremely rare claims generality considered carefully 
mechanisms build hidden assumptions fail true 
particularly difficult diagnose typically choose test data fit assumptions 
say assumptions bad 
quite contrary lead great improvements performance 
informed decisions specialization 
coloring algorithm navigation stereo system works scene works floor flat obstacles texture 
different system solve problem efficient facts directly 
treat lack texture floor positive feature environment 
notice floor forms single connected black blob bottom 
blob shown 
call carpet blob 
carpet blob easily computed starting bottom screen tracing image column textured pixel 
set pixels skipped blob 
notice height blob varies amount exposed floor corresponding direction number pixels skipped column gives rough ready measure amount free space direction 
suggests algorithm solving original problem find textured pixels image extract carpet blob turn direction carpet blob taller 
algorithm basis polly navigation set textureless pixels corresponding carpet 
note blob taller exposed carpet 
capabilities 
easily executed real time low personal computer 
analysis coloring algorithm understand relationship stereo blob algorithms follows 
systems determine free space front robot left side right side image 
stereo system measures directly computing depth map projecting floor plane 
concerned determining side larger need know exact distances particular units measure 
measure increases monotonically distance provided measure sides 
substitute system computes monotonic function distance stereo system 
importantly need know monotonic function vary moment moment long uniformly image 
known euclid image plane height monotonic function distance 
means roughly obstacles rest floor substitute image plane height obstacle stereo system provided way labeling pixel obstacle carpet 
general carpet detector recognize carpet equivalently obstacle difficult build stereo system 
carpet environment predictable appearance texture 
means substitute texture detector general carpet detector obstacle detector 
summarize analysis general principles ffl substitute monotonic measure quantity calibrated measure provided measure comparisons 
ffl substitute height image plane distance calculation provided objects rest floor way classifying pixels floor object 
ffl substitute texture detector floor detector provided floor textureless 
principles concisely describe specialization blob algorithm 
describes general transformation possibly inefficient algorithm efficient conditions task environment valid 
transformations applied design systems predict modify performance original system 
example wanted blob algorithm environment textured carpet abandon transformation able 
property texture allowed carpet pixels easily classified property basis new transformation 
preview results report contributes areas design efficient vision systems design mobile robots analysis specialized systems 
lightweight vision vision traditionally thought expensive 
number researchers argued vision significantly simplified dynamics agent interaction environment specializing vision system particular task 
see horswill ballard ikeuchi aloimonos 
see section simplify vision account specific properties agent environment 
view task environment positive resources designer 
task imposes concrete constraints information system extract image performance extract 
far bad constraints thing tell designer required agent required 
knowing constraints important allows designer tradeoffs intelligently 
performance parameters 
parameters typically optimized simultaneously designer decide optimize optimize 
knowing task constraints allows designer choices effectively 
similar situation holds choosing information extract image 
resolution useful case point 
amount computing power rate agent able process frames bounded inverse number pixels image assuming program agent reads pixel 
number pixels quadratic linear resolution image 
means want double accuracy localize feature image drop rate process images factor 
vision research focused relatively high resolution images algorithms discussed operate low resolution images theta theta 
understanding environment allows designer optimizations substitution low level image properties high level object properties 
algorithm discussed case point special properties environment substitute low level image property texture high level symbolic property 
understanding environment tell designer certain pathological situations occur certain performance requirements relaxed 
serve broaden space mechanisms available designer 
task environment space mechanisms solve task environment typically large 
principal claim real world task environment pairs space large include number efficient mechanisms 
call efficient mechanisms lightweight vision systems 
mobile robotics principal contribution report field mobile robotics demonstrate possible build robust economical vision robot board computation standard hardware 
polly robot uses single mip digital signal processor texas instruments tms nearly computation 
modified version chip available quantity 
frame robot recomputes visual percepts compares scene complete database landmarks updates motor velocities 
polly seventh floor mit artificial intelligence laboratory searching visitors may want tours 
finds visitor offers tour 
gesture properly robot leads lab giving informative speeches recognizes landmarks 
task involves wide repertoire behaviors current standards field 
follow paths recognize landmarks detect presence people interpret simple gestures choose paths specified landmark 
robot extremely tested 
lower layers control system running year seen hours service 
time environment steadily changed geometry appearance student population rose fell furniture rearranged small mountain range built part lab really office lighting completely replaced 
robot tolerated changes modified slightly cope see chapter 
robot tested similar environments 
analysis specialization renewed interest ai community relationship agents environments particularly artificial life biologically ai situated action communities see section survey 
analyze relationship formally deriving agent specialized environment hypothetical general agent series transformations justified particular properties agent environment 
performing derivation designer divides agent specialization discrete set reusable transformations paired environment property valid 
call properties habitat constraints set constraints define agent habitat 
generally refer transformations optimizations 
optimizations sense compiler optimizations transformations improve performance necessarily yield optimal performance 
advantage derivation explicit agent implicit assumptions environment 
assumptions design analysis agents 
provides way recycling experience gained designing specialized systems 
possible general fully automate design specialized systems kind post hoc analysis eventually allow develop cookbook methods broad range problems 
technique limited analysis vision systems 
examples application vision motor control discrete action selection 
structure report chapters high level introductions polly lightweight vision specialization respectively 
chapter describes polly task environment high level software design discusses language hardware im 
provides detailed example run robot survey vision robot navigation systems 
chapter discusses history vision research particularly move task active vision 
discusses task environment resources building lightweight vision systems 
chapter draws general framework analyzing specialization 
subsequent chapters detailed technical 
chapter gives formal basis applying transformational theory class simple vision systems 
chapter problem discrete action selection 
reader interested formalism may wish skip 
chapters describe detail robot vision low level navigation high level navigation systems respectively analytical framework explain performance 
chapter discusses number experiments performed polly gives sense reliability categorizes failure modes 
chapter summarizes key points gives 
chapter polly system polly low cost vision mobile robot built explore domain constraints design lightweight vision systems 
polly lives th floor mit ai laboratory gives simple tours th floor 
polly interesting number reasons 
relatively wide range capabilities 
navigate recognize places detect people understand gestures 
second simple inexpensive costing build shelf board level components faster version built 
third fast running meters second perception control systems running hz 
performs tasks exclusively vision 
vision autonomous robots relatively rare cheap fast autonomous systems wide behavioral repertoires built previously 
chapter describe task environment basic structure robot 
section describes robot task habitat 
section describes high level architecture robot 
section gives detailed run robot describes operation robot run 
section briefly describes programming language 
section describes basic hardware components robot capabilities interconnections 
section describes previous visually guided mobile robots 
subsequent chapters discuss software components detail 
task environment polly environment network corridors seventh floor ai laboratory mit see 
task patrol lab find visitors give tours 
patrol pattern shown 
drives hallways searches visitors want tours 
look downward floor detect people looking legs 
way distinguish visitor normal occupant rely fact normal occupants probably sick leave visitors actively investigate 
reason polly responds people stand directly front 
ignores people casually pass lean wall 
polly find leg object directly front introduces offers tour saying person wave foot want tour 
person indicates tour gesturing foot polly leads person lab making comments giving canned speeches recognized landmarks 
example recognizes lounge says lounge 
waste lot time 
polly returns place previously picked visitor says goodbye 
looks visitor 
typical scenario polly event speech polly approaches visitor hello 
am polly 
tour 
wave foot 
visitor waves foot 
please stand side 
visitor moves 
please follow polly drives avoid obstacles follow corridors recognize places navigate point point 
keeps driving vision system runs frames second low cost computer robot passes vision lab right vision lab 
way don understand saying 
robot enters lounge lounge 
waste lot time 
passes office karen mike office 
passes office office anita flynn 
enters playroom playroom 
tour 
nice day 
robot drives 
polly continually alternates searching visitors giving tours switch thrown control panel 
drives back office parks desk 
theory went designed system 
practice exactly way visitors wanting cause problems get robot way lab perfectly happy effort test limits 
layout th floor lab polly patrol pattern 
software architecture polly meant thought group communicating asynchronous processes connected fixed links see example brooks rosenschein kaelbling 
grouped high level structures shown 
group related visual processes core vision system cvs transform images high level percepts encode specific relevant information robot path blocked person view 
percepts effectively broadcast parts robot 
navigation implemented groups processes 
low level navigation system lln controls motors implements obstacle avoidance path wall corridor switching path 
perform open loop turns specified angles 
high level navigation system hln matches landmarks internal map performs goal directed navigation 
higherlevel process gives hln goal landmark hln directs lln series corridors leading goal 
goals usually specified wander system implements patrol pattern alternately instructing high level navigation system go opposite corners patrol circuit playroom vision lab see 
number polly tasks offering tours require robot perform fixed sequences actions 
sequence implemented special kind process called sequencer see section 
set processes control voice synthesizer 
tour announce place process gives canned speech robot recognizes landmark process giving tour 
tour chatter process generates periodic small talk tours vision system runs frames second low cost computer way don understand saying 
cvs sequencers wander hln lln voice synthesizer motors camera speaker position goal turn request motor velocities polly gross 
leave office pick give tour go home patrol high level states transitions messages process generates random messages random times robot idle giving tours 
done purely amusement author 
process programmed give specific message specific interval 
effectively turns robot town 
announce talks 
chatter process requests processes access voice synthesizer 
design processes discussed 
piece globally visible state polly high level mode see stored global variable global mode 
values global mode meaning robot starting going home meaning patrol meaning robot giving tour meaning process offering tour 
global mode wander process determine drive patrol pattern speech system determine give tour speeches pick routine determine attempt pick 
written pickup routine tour routines routines starting going home 
implemented local state information having different processes check see processes enabled hormone mechanism see brooks 
case needs simple global variable sufficed 
detailed example robot begins near desk facing south see 
leaves office performing fixed set steps specified sequencer 
drives south blocked obstacle 
leaves near file cabinet labeled 
turns left drives longer sees wall left bringing office door point 
moves forward feet turns left drives blocked facing east point facing right hand wall point 
turns right degrees face pillar couch moves forward 
robot obstacle avoidance mechanisms sufficient move channel couch wall corridor see point 
point polly normal navigation systems activated 
robot position initialized ian office sets goal landmark vision lab see 
robot begins 
corridor ian office elevator lobby traveling west 
hln determines east goal vision lab allows lln continue move west 
robot reaches elevator lobby wall right hand side suddenly vanishes view indicating robot reached right turn 
robot checks map right turn determines elevator lobby 
entry map elevator lobby says robot veer right remain corridor hln instructs lln small right turn 
lln continues open space elevator lobby reaches side 
lln corridor continues west 
robot drives past leftmost corridor corridor vision lab kitchen left hand wall vanishes view vision system signals presence left turn 
hln finds turn map updates position 
robot reaches vision lab detects left turn hln updates position 
things happen 
hln notices reached goal 
notices reached vision lab desk couch file cabinet starting position robot path leaves office enters corridor 
path floor plan schematic drawn scale 
lounge playroom ian office anita office karen mike elevator lobby kitchen conference room marie office vision lab polly habitat th floor mit ai laboratory 
diagram scale direction north defined convenience geological accuracy 
sets goal southern corner playroom 
turn causes hln wake 
hln determines goal southeast 
turn south instructs lln turn degrees left 
lln turns left begins align new southern corridor happened proceeds corridor 
robot reaches southern wall near lounge things happen 
lln longer move stops 
hln notices reached southern wall updates position 
goal east southeast hln tells lln turn left 
lln turns follows wall lounge proceeds way 
robot continues hln updating position appearance left hand turn robot reaches playroom 
sets goal back vision lab hln tells lln turn north cycle repeats 
giving tours robot continues patrol encounters person hallway 
happens sequencer offer tour started 
sequencer inhibits lln hln halts robot 
says hello am polly 
tour 
wave foot 
looks see motion image 
says ok nice day dis inhibits lln hln 
motion says please stand side waits longer blocked 
says ok follow starts new sequencer give tour 
give tour records current position robot sets robot global mode give tour mode enables tour chatter tour announce place processes 
give tour waits robot return position 
mean time hln lln continue happened 
time hln recognizes new place tour announce place wakes gives speech listed map place 
leaves long periods boring silence robot drives place tour chatter process inserts chatter messages pauses roughly seconds 
eventually robot returns place started 
give tour wakes says tour 
nice day sets global mode patrol disables tour announce place tour chatter turns 
robot continues way looking new visitor 
programming language issues polly meant thought parallel system practice implemented serial processor 
processor programmed subset scheme 
main loop program repeatedly grabs new image processes computes new set motor commands transmits commands waits new image 
execution loop referred clock tick 
parallel processes simulated scheme procedures procedure process 
procedure called clock tick main loop 
occasionally simple processes folded single procedure efficiency 
communication channels processes simulated global variables 
nearly variables thought wires carrying signals wire updated clock tick single process 
example variable direction written clock tick process reads robot rotational odometer 
holds current direction robot 
global variables variable holds goal position robot set rarely may set different processes 
best latches 
nearly vision code implemented set macros vector processing built top scheme 
images represented vectors raster format pixel address theta image th entry vector 
images compared vector equivalent mapcar actual dialect called see horswill 
essentially scheme garbage collection run time type checking removed compile time type inference full macros pointer arithmetic added 
modifications allow relatively simple compiler produce efficient code 
compiler produced better code compiler sold manufacturer computer 
define compare images map vector 
procedure takes input vectors length applies function successive pairs elements inputs writing results true false successive elements output 
vectors shifted pointer arithmetic allows adjacent pixels image compared vector macros 
example procedures define bad vertical edge detector map vector 
shift define bad horizontal edge detector map vector 
shift raster width detect vertical horizontal edges comparing pixel pixel just right just respectively 
function raster width returns number pixels line vector hold image 
shift performs pointer arithmetic 
takes vector integer returns vector displaced specified number elements 
note shifting produce bizarre results boundary left right sides image 
left right sides image connected array pixel nd line right pixel vertical edge detector find artifactual edges near boundary 
avoided nested loops usually easier just ignore boundary pixels 
hardware design commercial robot available appropriate computer frame grabber forced build system commercial board level components 
terrible sounds 
involved making connectors link board gluing ing various components 
roughly year required build robot nearly time spent reading catalogs ordering parts waiting parts frame grabber dsp fep pwr motorcycle battery rwi base camera speaker voice synthesizer lcd display control panel basic components layout robot 
fep dsp ti frame grabber voice control panel video download macintosh camera base rwi computational components data paths 
arrive 
month spent actual assembly 
writing boot roms loaders device drivers systems software take months 
robot hardware resources physical layout shown 
robot principal components commercial omni directional robot base real world interface model bit digital signal processor dsp texas instruments tms words sram model frame digitizing board data translation model black white surveillance camera cx microcontroller front motorola mc hc connects dsp various low speed peripherals voice synthesizer input switches lcd display 
robot base contains motors batteries shaft encoders microcontroller drive motors standard baud serial port send commands microcontroller 
base independent motors driving forward turning place 
motor controlled force velocity position space 
controller report current position velocity motor 
voice synthesizer accepts standard english text converts phonemes audio 
nearly interesting processing done board dsp 
dsp roughly mip machine 
dsp reads images frame grabber performs visual processing control decisions 
dsp frame grabber linked 
camera generates image resolution roughly theta pixels converts image standard rs analog video signal 
frame grabber samples analog video signal resolution theta pixels 
data dsp needs possibly process dsp subsamples image resolution theta pixels 
internal limitations frame grabber limit frame rate hz 
camera fixed place robot look corners pausing turn entire body 
exceptions described microcontroller referred fep front processor interface dsp peripherals 
dsp communicates built high speed serial port 
hardware speak dsp serial protocol implements serial protocol software 
dsp controls base peripherals sending byte stream serial line 
forwards bytes peripherals 
escape codes byte stream allow dsp switch peripheral 
escape codes cause transmit status front panel switches base rotational odometer dsp 
fep intelligent things 
parses status output base serial port find reports rotate motor current position 
converts reports hexadecimal binary sends dsp request 
done dsp dma controller read write link fep interrupt byte 
fep forward character written base dsp slowed dsp 
required complicated device drivers 
non trivial task fep polling bump switches 
fep constantly polls bump switches check robot hit 
robot hits fep stops normal activities sends sequence commands base reverse direction turn away bumper hit 
bumper deactivates fep returns normal activity 
program running dsp approximately lines scheme code plus drivers data 
load image dsp words bytes 
program uses image buffers words size theta pixels total scratch space words bytes 
visually guided mobile robots number mobile robots built vision navigation 
early systems tended vision navigation systems sonar obstacle avoidance relied vision localizing map detecting road path 
systems geometric maps systems vision build detailed geometric maps environments 
earliest certainly shakey see nilsson 
early visions shakey vision construct grid maps environment restricted contain matte polyhedra 
stanford cart see moravec novel stereo algorithm build maintain maps locations feature points immediate surroundings 
maps plan safe paths features 
system worked surprisingly unfortunately required minutes frame perform computations limited computing power available 
serious problems environmental dynamics shadows moving sun 
thorpe fido system stereo vision build grid local models environment 
robot model plan execute safe path sidewalk 
kriegman binford mobi system recognized hallways walls doors dimensional world model 
world model built robot moved environment 
robot stereo find positions strong vertical edges environment tracked time kalman filter 
system able achieve cycle time order seconds frame 
ayache faugeras kak developed systems kalman filtering full stereo track positions vertical edges map localize robot position 
kak able reasonable speeds standard mip workstation 
part efficiency system due fact searches edges model says 
gives system large performance boost means rely sonar obstacle avoidance 
marvel system stereo data build maintain representations environment determine location matching sensor data model 
interesting thing system ability tolerate slow changes environment gradually mutating model 
non geometric systems kortenkamp describe system navigation vision match landmarks described low resolution stereograms 
system detects landmarks corridor intersections doorways sonar algorithm distinguishes vision 
system navigates sort topological map popularized kuipers byun mataric 
nelson describes novel system navigation visual associative memory 
memory trained associate proper actions overhead views planar world 
system return home position repeatedly looking proper action memory executing 
engelson mcdermott describe system recognizing places easily computed image signatures complicated models 
signatures convenient hash functions sufficient distinguish views different places 
number purely reactive systems developed 
developed corridor follower estimates position vanishing point image align corridor 
developed simple stereo system obstacle avoidance back projection images 
system correct correspondence pixels images case cameras viewing floor objects 
system warps left image right image compares 
space front robot unoccupied right image warped left image identical 
offending pixels contain obstacles 
coombs roberts described system uses presence optic flow image avoid obstacles 
horswill built systems moving objects corridors monocular vision knowledge appearance background 
outdoor road large segment visual navigation devoted problem outdoor road 
great deal early road involved construction explicit models road 
large amount done recovering dimensional structure visible road fragments single monocular view 
systems extracted contours road set priori constraints road shape recover shape road 
waxman davis liang describe system reconstructing road geometry computing vanishing points edge segments 
turk gremban simpler system assumption vehicle visible portion road flat plane 
called flat earth model 
flat earth model allowed faster processing sufficient simple roads 
substituted constraint road constant width constraint road lie plane 
allowed system handle roads rose fell termed hill dale model 
hill dale model account curved roads dementhon proposed algorithm zero bank constraint allows hills turns allow road bank turn axis 
outdoor road done carnegie mellon 
early cmu done wallace 
sensor algorithm driven image coordinates motor control 
take approach extracting road edges segmenting road slicing technique 
extensive color information 
cmu warp parallel processor mips floating point processor optimized low level vision reported speeds km hour servo loop time frame seconds 
implemented color road tracker able properly distinguish road pixels pixels presence complicated shadows 
pomerleau described neural network efficiently learns follow roads low resolution images 
arkin reported architecture schema concept 
schema description action appropriate situation similar notion tactical routine 
arkin defined number motor schemas moving path avoiding obstacles run concurrently able navigate umass campus 
dickmanns described number road systems drive speeds km hour 
systems kalman filtering efficiently search road edges small windows image 
multiple processors system able process images frames second 
chapter lightweight vision chapter argue vision cheap suggest general techniques simplifying visual processing 
argument visual tasks solved cheaply 
goal convince reader particularly reader vision researcher cheap real time vision systems feasible variety tasks 
theory build task specific vision systems cheaply possible theory human vision system works build general programmable vision system 
issues raised building task specific vision systems overlap great deal discussions nature general vision systems 
background previous vision focused construction modules hypothesized general vision system 
early viewed vision domainindependent system creating monolithic models outside world 
proposals vary nature models processing performed create general approach series transformations sensory input move call surface structure input deep structure 
borrow terms chomsky refer different levels structure sentences 
relative terms 
example assume vision system takes images transforms edge maps depth maps stereo matching collections geometric descriptions individual objects 
thinks objects really image shadow objects true reality images mere appearance 
object descriptions capture really better images think object descriptions deep structure buried beneath surface images 
vision deep structure people traditionally tried extract detailed geometry environment see aloimonos rosenfeld historical survey marr feldman examples specific proposals 
referred reconstruction approach 
see aloimonos rosenfeld 
approach number appealing features 
complete description geometry environment suitably annotated surface information color convenient form compute information environment may required 
appealing characteristic fully domain independent sense information needed environment derived model provided model sufficiently detailed 
problems reconstruction number problems reconstruction model vision 
criticism easiest difficult assess reconstruction hard engineering standpoint 
formally ill posed inverse problem poggio torre projection process loses information inverting requires additional assumptions smoothness surfaces 
assumptions enforced requiring spatial derivatives image depth map small 
usually reduces reconstruction problem form constrained optimization high dimensional space see poggio torre horn discussions general techniques optimization reconstruction resulting equations frequently non linear tend unstable see aloimonos rosenfeld 
instability means estimates surface structure highly sensitive noise image measurements 
estimates highly sensitive deviations idealized smooth surface 
image discontinuities particular problem discontinuities ultimate non smoothness see aloimonos rosenfeld ibid 
date reconstruction model vision fully instantiated individual modules built varying degrees success 
prove done 
deeper criticism reconstruction best partial theory 
agent goes life need assess different aspects immediate situation 
answering series questions attack direction hallway 
free seats 
questions vary moment moment situation situation 
agent need answer question monolithic model current state environment 
model answer question immediate situation 
important questions quite specific 
agent answer right questions right times successful regardless organization perceptual system 
major attractions reconstruction theory gave domain independent theory visual processing 
information agent needs environment domain dependent 
reconstruction complete theory vision claim processing domain dependent queries transforming sensor data canonical form single domain independent representation allows efficient processing specific queries 
validity claim rests engineering issues 
canonical form really simplify query processing 
canonical form processing easiest surface reconstruction 
savings accrued canonical form sufficient justify processing required build canonical form 
issues hard evaluate 
answered empirically 
reasons skeptical building canonical form simplest solution 
general experience representation indicates expressiveness explicitness trade representation languages see levesque brachman general discussion phenomenon context knowledge representation languages 
thing taught ai classes idea representation information important task explicit 
taken seriously single canonical representation tasks 
hard choose single representation processing equally hard choose single algorithm constructing representation 
problem edge detection tend different algorithms different performance trade offs 
edge detector may optimized localize edge possible cost speed accuracy detecting edge place 
edge detector may opposite 
single approach give right performance possible high level tasks 
problems answered 
people believed reconstruction theory absolute form 
certainly case sort shared intermediate processing needed build system answering wide range queries see section 
intermediate processing need involve building single monolithic representation need involve fixed set processes 
noted said applies task facing designer reconstruction trying build digital terrain maps satellite imagery definition reconstruction 
active vision task vision years number researchers focused agents structure task activity simplify visual processing 
gibson theory direct perception notion agent physiology designed nature resonate particular information inherent environment 
cutting developed gibson theory direct perception take account agent role choosing parts stimulus attend directed perception see cutting 
great number machine vision researchers researchers proposed various approaches active task vision 
emphasized active sensing strategies active focusing zooming 
master thesis argued basing design vision systems concrete tasks 
chapter elaboration 
ballard vision group rochester university developed approach call animate vision 
give examples gaze control agent motion simplify processing 
ikeuchi proposed approach calls task oriented vision 
ikeuchi process developing vision compiler generate custom vision applications descriptions visual tasks 
aloimonos developed approach calls purposive qualitative active vision stresses themes 
proposals overlap great deal 
common feature notion visual machinery greatly simplified computing information needed agent perform immediate task 
common feature new proposals explicit agent dynamics simplify visual processing 
earliest dynamics know gibson senses considered perceptual systems 
earliest explicit machine vision community am aware active tracking feature point simplify equations structure motion 
systematic dynamics dickmanns dynamic vision methodology vision viewed optimal estimation problem space time 
dickmanns uses techniques control theory optimal estimation theory kalman filtering recover metric scene parameters 
final common feature tendency qualitative information metric information possible 
qualitative information twin advantages easier extract images numerically stable metric information 
earliest proposal qualitative information am aware thompson kearney 
building lightweight vision systems want build simplest possible system solve task environment 
general task environment pair solved broad range mechanisms broad range cost performance parameters 
better designer understanding range mechanisms better able choose mechanism best suits needs 
broaden range mechanisms solve problem potential resource designer 
resources simplifying vision agent need compute information needs perform task treat task resource simplify visual processing 
task mean high level task agent 
task specifies albeit loosely indirectly information required perform 
specifies loosely indirectly task obstacle avoidance require particular representation space obstacles distance obstacles places set operational constraints representations sufficient task 
depth map cartesian elevation map simply distance direction nearest obstacle 
units measurement feet meters unknown repeatable system 
looseness viewed positive feature ambiguity need clarification task specification 
fact task choice representation means designer wide range choices available may efficient 
task provides designer concrete performance constraints 
constraints thing 
performance constraints tell designer required required 
concrete performance constraints designer know system perfect performance room endless improvement additional performance may 
importantly single aspect system corresponds performance 
performance parameters 
parameters trade optimized simultaneously 
performance constraints task allow designer intelligent choices aspects performance optimize sacrifice 
particularly important performance trade relation spatial sampling rate temporal sampling rate 
fixed amount computational power designer increase decreasing 
temporal sampling rate places lower bound response time critical trade 
researchers traded temporal resolution spatial resolution 
increasing spatial resolution increase geometric accuracy hopes increase general reliability agent 
unfortunately lead vicious circle 
doubling linear spatial resolution requires reducing temporal sampling rate factor 
agent control decisions rate gets perceptual data bandwidth control system drop factor 
agent wait times long find mistake 
mistakes need corrected promptly agent time recover mistakes graver issue 
usually solution problem think hard control decision making 
means agent needs accurate detailed perceptual data environment means resolution 
high spatial resolution needed geometric accuracy geometric accuracy needed perform task 
processing polly performed theta images theta matching landmarks 
images difficult estimate robot position relative walls precision 
fortunately polly navigation task require know exact position relative walls moving roughly parallel walls close see chapter discussion 
checked efficiently low resolution images 
correlations deep structure objects world surface structure image useful resource simplifying vision 
orientation corridor property geometric structure way finding determine geometric structure corridor extract orientation geometric model 
geometric structure world reflected simple manner structure individual images 
case corridor orientation happens coincide location vanishing point corridor edges image 
vanishing point purely notion surface image structure case happens correlated deep structure corridor 
vanishing point easily computed image easily compute orientation corridor 
intended environment agent important resource designer 
survive wide range environments agent prepared worst cases environments 
means tighter performance constraints larger information requirements 
restricting range environments agent operate relax constraints simpler systems 
surface structure correlations hold restricted classes environments 
restricting range environments agent allow optimizations may needed cases features scene small 
possible see chapter discussion 
distributed representation mediation principle features active task vision parts ai general move away central mediating representations monolithic models distributed representations different parts problem solved different computations largely independent see horswill brooks aloimonos brooks 
computations performed parallel 
fears surrounding practice complicated agent performs wide range tasks need huge numbers parallel processes 
issue parallelism outside scope issue distributed representation important 
distributed representation central mediating representations complementary strengths 
advantage separate computations representations perform separate tasks relaxes design constraints 
subsystem computes pieces information may satisfy agent performance constraints speed accuracy pieces information simultaneously 
solving problems separately may easier solving simultaneously 
useful multiple computations perform single task 
performance constraints task tight particular computation set independent systems different performance trade offs accomplish task reliably 
example system give approximate answer immediately gives accurate answer 
systems independent failure modes perform task reliably 
polly align corridor finding vanishing point corridor turning balance distance wall 
vanishing point computation fails wall balancing algorithm compensates vanishing point computation recovers 
hand tasks may similar performance constraints may perform intermediate steps 
case reason share intermediate steps 
mediation depends mix tasks agent needs perform compatibility performance constraints 
tended build independent systems extracting different pieces information fold similar computations afterward 
related years number active task vision systems built 
common task tracking moving objects 
coombs implemented system fixating tracking objects stereo eye head system 
system disparity filtering localize object 
woodfill zabih optical flow segment track moving object monocular input 
horswill environmental constraints segment track moving object 
aloimonos describes system medusa performs number tasks including tracking 
researchers built vision systems designed extract useful high level information building detailed depth maps 
aloimonos describes number motion algorithms recover information useful navigation having solve general structure motion problem 
nishihara describes minimalist approach early vision particularly stereo 
swain describes system recognizing colored objects geometric information whatsoever 
various researchers developed systems directly detecting occluding contours measuring depth see toh forrest wixson 
horswill disparity filtering implement proximity detection stereo images 
aloimonos medusa system extracts number useful pieces high level information presence moving objects direction translation looming 
tsotsos argued task recognition simpler bottom recognition formal complexity standpoint 
unfortunately proof quite specific particular formalizations task bottom problems 
amounts template matching image position occlusion template matching pose occlusion allowed 
proof presence occlusion drives complexity bottom approach 
results depend requirement templates match correlation metric difference metric 
metric complexity result falls 
consequences abandoning model vision builder monolithic models resource limitations introduced sensing 
robot point camera direction time stereo system fixate depth plane time color histogram unit process task time 
computational physical resources allocated reallocated continually agent 
result sensing series actions traditional problems action planning reaction execution monitoring management multiple conflicting goals perception 
problem generally referred problem control selective perception 
spawned vast literature see collections section xi 
approaches range decision theoretic models see rimey symbolic planning see pryor collins 
visual routines popular framework discussing problems 
notion visual routines due ullman proposed idea visual routine processor vrp acts processor higher levels processing instruction set visual operations 
ullman visual routines patterns processing implemented sequences operations manner subroutines implemented series normal cpu instructions 
agre chapman modified popularized model greater ai community 
agre chapman implemented simulated vrp high level vision 
control inputs vrp tied directly central system treated roughly way effector 
agre chapman visual routines routines sense subroutines agre sense common patterns interaction agent environment 
chapman implemented second simulated vrp system sonja 
chapman proposed system sonja intermediate vision system provisional computational model biological intermediate vision 
shafer implemented simulated vrp model active vision driving 
term broadened considerably effect include sort processor architecture 
swain discusses number existing active vision systems thought active visual routines case visual routine processor 
summary general vision problems building geometric models arbitrary environments difficult expensive build 
build simple effective vision systems specific tasks environments 
structure task environment important resources designing simple vision systems 
task environment specific requirements vision system looser space possible mechanisms perform task grows 
space broad mechanism space efficient 
making clear design constraints hold greatly simplify design vision systems 
general prescription designing systems tried outline general resources available designer simplifying vision problems 
chapters give number examples lightweight vision systems discuss understood 
proper analysis insights gained design system extracted applied design systems 
part ii formal analysis specialization chapter part ii background decade ai seen surprising number negative theoretical results 
formal planning shown computationally intractable undecidable see chapman 
perception problems shown highly numerically unstable see aloimonos rosenfeld 
general ai problems amount search large spaces discrete spaces case reasoning continuous spaces problems inverse optics 
unfortunately search fundamentally hard 
widely believed search problem difficult boolean satisfiability solved polynomial time cook np completeness result see hopcroft ullman 
problem 
search formally intractable ai impossible penrose argues loophole 
candidate loopholes 
loophole search polynomial time algorithms solving search problems average case 
true example way generating admissible heuristics automated manner 
hand loophole life everyday problems facing agents dramatically simpler formal sense typical general search problems 
loopholes life loophole life case deserves elaboration 
mean humans solve hard problems 
people prove theorems play chess time 
question fraction human activity fundamentally hard fraction fundamentally easy 
complexity theory distinction problems instances problems 
problem characterized set instances correct answers 
single instance considered problem trivially computable 
instance answer programmers happen know 
exist program prints answer regardless input 
program boring correctly solves instance constant time space 
single instances uninteresting complexity theoretic viewpoint 
difficulty ai research god doesn tell formal problem specification life ai researchers consider specific instances scenarios infer complete problem form instances design algorithms fit problems 
difficulty problems extremely sensitive details phrasing problem 
researchers look set instances infer radically different problems serious methodological problem 
consider problem getting morning 
people agree navigation ontology navigation 
navigation process getting set cartesian coordinates 
process getting defined area bed office 
choice profound impact computational difficulty problem 
ai researchers may agree agents need get morning disagree agents need cartesian navigation 
believe loophole life real everyday tasks relatively easy compared general case necessarily poor problem formalizations past 
task reopen issue formalization 
explore different problem solutions different problem definitions 
computer scientists 
computer scientists formally prove re right 
process formalization definition informal prove formalization correct 
key question instances encounter regularly lives easy solve 
number overlapping answers proposed 
schank agre argued length tend solve similar identical instances keep recycling old solutions minor modifications 
view means don want think navigation problem meta problem solving long series similar navigation problems minimal amortized time 
number authors stressed importance environmental dynamics explaining intelligent activity 
authors stress world simpler general imaginable case see example agre 
authors stress complexity environment arguing complexity environment allows agents simpler see example simon 
incompatible statements 
statement imaginable possible worlds agent live statement presence simplifying structures environment 
groups agree simplifying structures environment allow agents simpler necessary 
computational minimalism way understanding comparative difficulty problem formalizations compare simplest possible algorithms 
doing allows build natural taxonomies problems solutions 
treat problems task environment pairs environments terms relative difficulty specific tasks 
years researchers tried build minimal mechanisms specific task environment pairs see example agre brooks chapman connell rosenschein kaelbling 
researchers connell minimalism engineering methodology 
agre hand treats largely psychological anthropological methodology 
focus principally engineering issues 
engineering standpoint advantage minimalism small changes task environment greatly simplify machinery needed solve 
disadvantage sensitivity minimalist systems hard understand 
system works environment may fail slightly different environment 
worse effort expended building system environment may tell build system perform task different environment 
minimizing mechanism maximizes specialization 
computational minimalism succeed need set theoretical tools analyzing specialization systems environments 
transformational analysis understand specialization analyzing sense dissecting discrete chunks understood isolation 
perform analysis treating specialized system transformed optimized version general system performs task 
transformation required optimize general system specialized system dependent specific property agent environment 
call computational properties environment environment doing computation computational ramifications 
result analysis series independent optimizations simplifies specific computational subproblem specific environment property 
take simplistic example animals need detect presence animals environment 
non living objects animal environment static motion environment cue presence animal 
consider animals identical detects animals shape color smell information simply treating motion animal 
animals behave identically environment behaviorally equivalent environment 
differences 
animal uses motion may economical sense 
robot cheaper build take power physical space 
animal advantage potentially operate environments violating constraint inanimate objects move 
view substitution motion animal detector shape transformation mechanism transformation preserves behavior exactly way rules logical inference preserve truth value substitution identities mathematics preserves denotation compiler optimizations preserve input output behavior program compiled 
important difference transformation preserves behavior environments satisfying constraint 
view constraint representing possible structure environments inanimate objects move transformation structure computational significance characterize environments compare giving sets useful constraints satisfy 
characterize compare agents giving sets constraints require 
set constraints assumed agent define set environments agent operate habitat reason refer constraints habitat constraints 
application series transformations produces series behaviorally equivalent systems making different engineering trade offs different assumptions world 
compare behaviorally equivalent systems giving series transformations converted 
call series derivation 
particularly useful way analyze specialized system give derivation system general system giving derivation ffl explicit additional assumptions ffl explicit role assumptions play normal functioning ffl easier predict performance novel environments ffl clearer modify operate different environments 
part computational significance allows different useful transformations 
importantly steps derivation reused design analysis systems 
addition define suitable notions equivalence agents components apply analysis recursively subsystems general approach follows 
define spaces possible mechanisms environments 
decide aspects behavior mechanism behaviorally equivalent mechanism 
different criteria required different kinds systems 
definitions find transformations mechanisms preserve behavioral equivalence conditionally unconditionally 
transformation yields efficient mechanisms view optimization 
important classes environments described terms constraints satisfy optimizations facilitate 
optimizations reused design systems 
synthesis versus post hoc analysis frequently interpreted framework automatic programming 
intended technique post hoc analysis existing mechanisms 
claim build mechanism reduce set reusable lemmas simplifying mechanisms 
give rigorous methodology building mechanism 
certainly strong framework doing automatic programming mechanism 
imagine automatic programming systems stock preexisting optimization lemmas simplify new designs 
task doing original design analysis easier harder tasks engineering mathematics 
related relatively little attention devoted environmental specialization computer science begun construct computational systems closely coupled natural environments 
biology great deal attention specialization complete agents environments 
cybernetics artificial intelligence focused agent environment interactions necessarily properties specific complex environments 
ideas areas applied artificial intelligence robotics see mcfarland paton 
meyer 
perceptual psychology gibson proposed ecological theory perception stressed role environment forming agent perceptions 
gibson argued structure environment determines set invariants energy flowing environment invariants directly picked perceptual apparatus organism process akin resonance 
marr argued order properly understand operation perceptual system generally intelligent system understand problem solves level computational theory 
computational theory defines desired input output behavior perceptual system set constraints possible interpretations input 
constraints necessary single stimulus usually generated infinite number possible situations 
virtue computational theory abstracts away details individual mechanism 
single computational theory explain unify different mechanisms instantiate 
marr role constraints computational theories show structure environment interpretation possible efficient 
marr believed human visual system general mechanism constructing dimensional descriptions environment relatively understanding system specialized take advantage useful unnecessary properties environment 
extends marr ideas constraints explain optimizations implementation level 
formal models environments state space descriptions environment usually finite state machines 
rosenschein kaelbling finite state machines represent agent environment see rosenschein rosenschein kaelbling 
formalization allowed specialized mechanisms directly synthesized descriptions desired behavior formalization behavior environment 
formalization powerful form basis programming language program real robot 
rosenschein developed method synthesizing automata internal states provable correlations state environment set temporal logic assertions dynamics environment 
donald jennings geometric similar approach constructing virtual sensors 
wilson specifically proposed classification simulated environments types mechanisms operate successfully 
wilson finite state formalization environment 
divided environments classes properties determinacy 
todd wilson finite state machines grid worlds class artificial agents created genetic algorithm 
littman fsm models classify environments reinforcement learning algorithms 
littman parameterized complexity rl agents terms amount local storage far rl algorithm looks 
empirically classified environments marr actual story complicated levels explanation 
see marr 
minimal parameters allowed optimal control policy learned 
extensive literature discrete event dynamic systems see readable model environment finite state machine assume transition information state information visible agents 
alternative state machine formalism dixon 
dixon derives semantics order logic world comes objects relations state space methods 
dixon open approach avoids need define environment single mathematical structure 
dixon attempts formally model assumptions system environment 
dixon interest individual program means comparing competing programs 
researchers discussed time extended patterns interaction environment called dynamics agre reduce computational burden agent 
lyons hendricks discussed derive exploit useful dynamics formal specification environment 
uniform formalization agent environment process algebra 
temporal logic able identify useful dynamics design reactive behaviors exploit 
hammond converse grass discuss new dynamics designed agent improve stability agent environment system 
read part ii top level claims report task environment design special purpose vision systems lead dramatically simpler robust systems systems analyzed understood principled manner 
polly meant establish plausibility claim 
part ii meant establish plausibility second 
part iii apply techniques part ii analysis polly 
central claims part ii 
behavior preserving transformations concisely describe specialization agent environment 

formal analysis terms transformations allows insights design special purpose system applied design 
ideas need applied formally everyday engineering problems relatively informal manner analysis coloring algorithm section 
analyses useful somewhat hand 
goal part ii show transformational analysis formal rigorous 
doing requires fair amount formalism 
formalisms focus 
transformational analysis focus formalisms set possible tools applying transformational analysis 
chosen simplicity presentation theoretical power 
reader free adopt formalisms formalisms see section informal manner 
reader feels bogged math feel free skip go part iii 
chapter framework agents environments equivalence assume reasonably separate world agent environment 
world need mean entire physical universe portion relevant analysis 
denote set possible agents set environments 
agent environment pair form dynamic system behavior 
assume task specific notion equivalence possible behaviors 
write mean behavior operating equivalent behavior say agents equivalent equivalent environments iff call conditionally equivalent environmental constraint equivalent environments satisfying write iff designer particular behavior want agent achieve 
useful behavioral distinction agent works relation divide possible behaviors classes working working 
habitat ha agent set environments works 
refer environment constraints habitat constraints habitat described constraint conjunction constraints 
specialization optimization suppose want understand agent specialized environment 
efficient general system may smaller habitat find sequence mechanisms domain constraints cn phrase statement english environments satisfy behaviorally equivalent exactly cases 
lets express habitat terms habitat note left right hand sides necessarily equal may situations works 
constraints right hand side overly strong 
call sequence equivalences gradually transformed derivation analogy derivations equations 
restrict attention case derivation step gamma seen result applying general optimizing transformation preserves equivalence gamma defined exhibiting derivation breaks specialization smaller pieces easier understand 
places constraints correspondence optimizations making computational value constraint explicit 
constraints apart helps predict performance agent novel environments 
environment satisfies constraints agent 
know optimizations fail consequently parts design modify 
addition write general lemma effect reuse design systems 
lemmas may greater interest actual agents inspired 
note equally perform derivation subsystem agent possible subsystem 
reason term mechanism mean agent subsystems 
simple example apply framework case specific kind feedback control system order control systems degree freedom 
applying framework requires specifying means systems equivalent 
suppose order system single degree freedom context order means direct control dx dt suppose want desired value 
system converges desired value finite time stable desired value 
say control systems equivalent stable sets values 
second order control problems problems control dx difficult controlling order system trivial 
intuitively get right sign control signal 
isn technically true control signal tolerate wide range variation converge 
means don need accurate estimate error 
turns strictly increasing measure error allow system converge provide maps zero error zero 
formalize optimization substitutes uncalibrated estimates calibrated ones 
call theorem control physical system degree freedom rate change directly controlled 
control systems control laws form dx dt gammaf gamma set nondecreasing iff cause converge set arbitrary values set control systems equivalent definition 
proof loss generality assume set 
want show lim 
equation unique continuous solution initial value see brauer theorem 
note derivative opposite sign zero case zero 
strictly decreasing interval strictly positive strictly increasing interval strictly negative 
suppose positive non positive interval 
nonnegative 
mean value theorem contradiction 
similarly negative zero cross zero 
stay zero reaches zero need consider case stays positive forever negative forever 
suppose strictly decreasing ffl 
want equivalence condition necessary choice 
want include rate convergence maximum speed condition criteria 
system converge incorrect value 
show exists ffl ffl ffl strictly decreasing need show eventually reaches ffl 
suppose 
larger ffl negative gammaf ffl meaning bounded gamma gamma ffl 
drops ffl 
lim 
limit holds similar reasoning remains negative hold general 
caveat theorem live second order universe physical systems accurately modeled order systems zero delay 
case rate change second order system quickly easily measured absolute relative position system difficult measure 
example robot driving room 
robot easily measure speed sensing currents reading shaft encoders accurate information robot position relative obstacles require vision system sensing modality latency large compared accelerations motors produce 
situations reduce second order control problem order control problems control velocity motor torques control position adjusting velocity 
velocity control done fast robot look order system vision 
necessary visual system run fast prevent oscillation 
important implication theorem system insensitive errors calibration perceptual systems provided system estimate error monotonic actual error system recognizes zero error 
calibration major problem perceptual systems particularly systems driven robots periodically crash things getting knocked calibration 
chapter analysis simple perceptual systems chapter perform detailed analysis coloring algorithm section 
need flesh notions environment behavior behavioral equivalence 
state space formalization environment 
section concerned environment states possible transitions 
ignore internal state agent 
section add dynamics internal state 
set possible world states 
model environments subsets consider state spaces section 
habitats defined sets environments effectively just larger regions state space 
habitat constraints constraints possible habitats effectively just subsets ignoring dynamics internal state consider perceptual systems give information instantaneous world state 
perceptual system mechanism identifiable output identifiable set possible states state output causally determined state world 
effectively perceptual system computes function call function information type perceptual system computes 
say perceptual systems behaviorally equivalent compute information type 
information type finite range finite 
note information types confused concept information inverse probability classical information theory see hamming 
certainly compatible classical information theory concerned measuring quantities information concern distinguishing different kinds information 
derivability equivalence interesting information type information types computed 
say information type derivable exists derivation function ffi equivalent written 
range information type irrelevant derivability arbitrarily rename elements range changing derived 
really matters partition induces world states fa elements partition maximal sets world states indistinguishable lemma statements equivalent 
equivalent 

derivable iff derivable 
partitions identical 

differ bijection mapping 
proof recall derivability transitive 
suppose holds 
derivable derivable derivable similarly derivable derivable implies 
assume 
derivability reflexive equivalent 
suppose false 
pair world states vice versa 
loss generality may assume differs 
derivation function ffi contradicts assumption 
hold implies 
note information type trivial bijection rule gamma 
inverses compositions bijections bijections follow 
note follows trivially mapping derivation function 
say conditionally identical written note implies say perceptual systems behaviorally equivalent compute information type conditionally equivalent information types conditionally identical unconditional equivalence transformations single box labeled information type represent perceptual system computes double arrow meant represent connection environment 
want expose internal structure system single arrows represent connections wholly system 
represents system computes applies transformations 
denote predicates 

denotes system outputs true false 
diagrams inherit associativity function composition ffi ffi simple optimization call folding constant folding compiler optimization replacement series computations single computation ffi folding formally trivial technique quite useful practice 
example computing pose information image running grasp planner choose grasping strategy object appearance index directly table grasping strategies 
abuse notation somewhat say recognize model compute pose plan strategy reduced recognize view look strategy example optimizing transformation called 
estimating precise parameters depth difficult require precise sensor calibration 
done information compare empirical threshold 
example estimate distance obstacle decide late brake avoid collision 
generally designer arbitrarily chooses threshold determines experimentally 
situations mechanism computes distance units provided correct threshold 
lemma information type set real numbers strictly increasing function 

ffi 

proof associativity right hand side equivalent 

ffi iff 

ffi 

allows calibrated mechanism replaced uncalibrated mechanism certain cases 
transformations simple vision systems coloring algorithm image plane height discriminate depth texture detector find obstacles 
remainder chapter derive sufficient conditions validity techniques 
show image plane height strictly increasing function object depth provided object rests floor projection floor contained region contact floor 
show floors surface markings spatial frequencies viewed distance low pass filter region 
discriminate objects floor 
need define coordinate systems camera centered forward direction direction axis projection body centered forward direction direction motion see 
assume camera faces forward somewhat camera body centered frames share left right axis call call axes camera body centered systems respectively 
assume ground plane lies 
denote image range set images color images 
ground plane center body coordinate system camera optic axis camera viewing ground plane 
axis shown comes page shared camera body coordinate frames 
body coordinate frame formed camera frame axis projection optic axis camera 
height camera arbitrary point ground plane 
projection process specified coordinate frames 
camera centered coordinates projection process maps point world point fx fy image plane focal length lens 
body centered coordinate system projection best expressed vector algebra 
point world projected image plane point gamma delta gamma coordinates coordinates obtained projecting image plane axes yielding coordinates delta delta 
salience functions ground separation set objects ft fg ground unique information type world states returns image pixels marked imaged world state objects perceptual system compute habitat distinguish background 
arbitrarily difficult consider case set 
fortunately specific cues allow objects recognized specific contexts 
call cues salience functions 
information type salience function conditionally equivalent constraint salience constraint 
simple easily computed functions find particular classes objects common ai see swain turk horswill brooks woodfill zabih biological world see roitblat 
coloring algorithm uses texture detector salience function 
want determine salience constraint required texture detector 
simplicity restrict fourier measures texture 
effectively texture detector examines small patch image 
approximate projection small patch 
fx fy distance center surface patch 
sufficiently small patch treated plane local coordinate system 
suppose patch reflectance varies sinusoid frequency vector 
reflectance point patch sin sin view patch ffl unit distance ffl lens unit focal length ffl direction normal patch ffl axis aligned axis ffl illumination unit intensity image intensity simply consider effect changing viewing conditions 
doubling distance halving focal length halves size image 
sin 
sin 
image sine wave grating projected frequency doubled 
rotating patch angle axis shrinks projection axis factor cos producing sine wave frequency 
cos cos sin sin cos rotating patch axis shrinks axis projection 
rotating optic axis simply rotates frequency vector 
sine wave grating viewed position appears grating identical amplitude frequency vector modified scaling components zero band projected zero band effect perspective projection local frequency distributions 
possibly rotation 
projection process linear extend arbitrary power spectra power spectrum patch projection power spectrum patch rotated stretched axis see 
frequency bands patch transformed elliptical regions frequency domain projection 
bounds possible viewing conditions yield bounds frequency bands deformed 
background texture constraint btc requires surface patches background surface markings power spectra bounded objects surface markings energy surface view closer focal lengths scene uniformly lit 
lemma thresholded linear filtering image interval 
salience function background texture constraint 
proof assumption patch background energy band objects 
reasoning patch object background viewed fronto parallel distance band projects band 
patch imaged object iff projection energy band 
note increasing distance changing viewing orientation increase size projected frequency ellipse 
distance greater viewing orientation patch energy 
iff imaged object 
thresholded linear filter salience function btc 
corollary thresholded linear filter 
conditionally equivalent ground system background texture constraint 
depth recovery depth measured camera centered body centered coordinate system 
call camera depth body depth respectively 
camera depth point distance image plane delta gamma 
body depth ground plane image plane point projection monotonicity image plane height body depth 
rays projected point projection points ground plane pass successively higher points image plane move distant points ground plane 
hand far forward robot drive collides point delta concern body depth 
consider world flat objects lying ground plane 
object points ground plane points zero coordinates 
points linear combinations perpendicular component point contribution camera depth body depth restrict attention dimensional case shown point nz 
body depth simply camera depth delta nz gamma depends camera placement 
see inspection camera depth linear camera depth body depth related linear mapping 
surprisingly image plane height strictly increasing function body depth 
seen 
shown analytically 
image plane height delta nz gamma delta nz gamma delta gamma fh nz delta gamma delta nff gamma ffi nfi gamma fl ff fz delta fi delta fl delta ffi fh delta differentiating respect obtain ff nfi gamma fl gamma fi nff gamma ffi nfi gamma fl fi ffi gamma fffl nfi gamma fl camera looks forward front agent fi ffi flff derivative strictly positive 
ground plane constraint gpc requires camera view set objects resting ground plane completely view projection set points contact pyramids resting bases satisfy restriction pyramids resting points 
gpc coordinate measure depth closest object 
body depth information type gives correct body formalizing notion contact difficult see example fleck chapter treat notion primitive particular formalization unimportant purposes 
depth pixels generated objects pixels generated background 
lemma region image 
minr depth conditionally equivalent rg gpc modulo strictly increasing function 
proof note minimal depth minimal depth object points 
case contact point object point touching floor minimal depth object point ground plane projection contact point contradiction 
minimal depth contact point 
want show object point smaller projected coordinate coordinate invariant respect changes coordinate point projects lesser coordinate smaller coordinate smaller coordinate 
contradict minimal depth point place point ground plane 
minimal projection 
shown contact points projection strictly increasing body depth 
trivial corollary lemma height lowest pixel image column gives distance nearest object direction corresponding column 
chapter analysis action selection chapter apply transformational techniques action selection tasks goal demonstrating number formal conditions reduce deliberative planning systems reactive systems 
continue model environment dynamic system known set possible states 
add actions state transitions environment making full state machine 
model deliberative planning systems reactive systems variants control policies classical control theory see luenberger beer 
gives uniform vocabulary expressing types systems 
examine various formal conditions environment allow simplifications control policy substitution reactive policy deliberative focus chapter transformational analysis specifics notation 
notation needed establish framework apply transformations 
notation largely equivalent rosenschein kaelbling donald jennings 
chosen largely compactness presentation 
formal trick externalizing agent internal state turns useful 
environments allow different environments different state spaces treat actions mappings states states 
environment state machine formed state space set actions mapping example consider robot moving corridor equally spaced offices labeled 
formalize environment gamma dec ig identity function dec map integer gamma respectively proviso dec dec dec dec dec dec dec dec dec dec dec dec dec dec environment left serial product expressed graphs 
function products written pairs thetai written 
identity actions thetai omitted reduce clutter 
gamma gamma see 
note effect performing identity action stay state 
discrete control problems say discrete control problem dcp pair environment goal region state space 
problem getting corridor robot dcp 
abuse notation write dcp triple 
finite sequence actions solves initial state gamma em solvable sequence exists 
solvable general solvable cartesian products state space environment structured distinct components acted independently 
position king chess board row column components example 
think king ona chess board environment product environment rows columns just cartesian product reals 
consider environment car drives theta grid city blocks 
think environment product 
car king theta grids state spaces car change state components time king change moving diagonally 
distinguish different cartesian products environments parallel product corresponds king case serial product corresponds car case 
cartesian product functions thetag 
identity function 
environments define parallel product ke thetas fa thetaa serial product thetas fa thetai fi thetaa products defined obvious way ke thetag thetag state diagram shown 
say environment dcp parallel serial separable isomorphic product environments 
solvability separable important property separable solutions constructed solutions components claim 
solvable state iff solvable solvable proof consider sequence solves product 
sequences actions respectively form sequence thetai thetax thetay thetai thetai 
leave product goal state 
definition goal states solution sequences respectively 
conversely construct solution sequence product solution sequences components 
parallel product case complicated agent change state components 
leaves agent way preserving solved subproblem solving 
consider flip flop environment ff lip gammax 
property state accessible state 
property 
kf 
kf action flips state components 
states accessible state kf state flip 
king problem fixed add identity action possible leave component product intact changing 
identity action sufficient necessary 
weaker unnecessary condition action maps goal states goal states 
claim 
kd solvable state solvable solvable converse true goal state action maps goal state 
solution sequence 
sequences obtained second components respectively element thetax thetay 
solution sequences respective component problems 
similarly form solution product solutions components combining element wise 
solutions components length 
loss generality shorter solution 
action map goal state goal state pad actions keep goal region 
combination padded solution product 
agents assume agent uses policy choose actions 
policy mapping states actions 
say ffl generates state sequence ffl generates action sequence generates ffl solves state generates solution sequence ffl solves solves states 
ffl solves halts solves example constant function dec policy solves dcp halts 
hidden state sensors policy uses perfect information world choose action 
real life agents access sensory information 
information type see section provided agent sensors 
crucial question information derived 
say information type observable derivable choose actions need mapping world states sensor states call mapping policy 
function policy dcp ffi policy say solves state ffi solves solves general solves initial state 
externalization internal state assumed agent internal state actions determined completely state sensors 
real life agents generally internal state 
model internal state form external environmental state perfect sensors effectors 
register environment ra alphabet environment state space actions constant functions write constant function value action writes register 
call ra augmentation alphabet agent operating augmentation point time read states register perform action write new value register 
external state internal state simply mathematical 
agents world external memory 
agent need isolate portion world state appearance sheet accurately sensed controlled 
humans routinely 
appointment books allow people keep plans day world scarce memory 
position glass bar encode type drink intend mix far mixing see beach 
example program uses external state see agre horswill 
progress functions progress function measure distance goal 
particular progress function phi dcp non negative function reals 
phi nonnegative phi 
phi iff 
initial state solvable exists solution sequence phi strictly decreasing phi phi 
term progress function taken program verification literature refers functions internal state program prove termination loops 
progress functions similar functions see luenberger admissible heuristics see barr feigenbaum volume chapter ii artificial potential fields see khatib latombe 
say policy honors non negative function phi phi steadily decreases reaches zero states ffl phi phi gamma ffl phi phi 
policy honors phi thought doing hill climbing phi run reaches local minimum phi 
phi happens progress function dcp local minimum global minimum corresponding goal lemma phi non negative policy dcp honors phi 
solves halts exactly phi progress function proof consider execution arbitrary initial state step value phi decreases ffl reaches remain zero 
phi converge zero phi ffl steps state system confined set phi gamma 
need show phi gamma iff phi progress function phi progress function phi gamma holds definition 
see converse suppose phi gamma want show state solvable solution sequence monotonically decreases phi 
sequence generated sequence 
progress functions generated directly policies 
standard progress function phi policy solves number steps solves state 
important property product construct progress functions products progress functions components lemma phi progress function phi progress function phi 
phi phi progress function serial product 
proof phi phi phi 
similarly phi zero exactly goal states product 
suppose product solvable 
exist solution sequences components monotonically decrease phi phi respectively 
combination sequences form solution product monotonically decrease phi phi progress function product 
parallel case complicated lemma phi progress function phi progress function goal state action maps state goal state phi 
phi phi progress function parallel product 
proof phi phi zero exactly goal states product 
consider state product solvable 
solution sequences component problems phi phi respectively strictly decreasing 
loss generality assume shorter 
solutions 
pad combine solutions produce solution product 
padding change value phi value phi strictly decreasing combined solution 
construction dcp solutions decomposition product tools construct solutions product solutions components lemma policy solves halts states set initial states policy solves halts states policy thetap solves halts states thetai 
note convention treating function pairs function scalars 
lemma policy solves states set initial states policy solves states policy thetai thetap thetai thetap solve halt states thetai proof prove lemmas progress functions 
phi phi standard progress respectively 
sum progress function product 
follows directly serial case fact halt parallel case 
policies products clearly honor sum solve respective products 
note constraint second lemma sufficient necessary 
reduction treat environment abstraction environment retains fundamental structure concrete environment removes unimportant distinctions states 
state corresponds set concrete states actions correspond complicated sequences concrete actions 
projection environment environment mapping gives state concrete state corresponding state 
gamma gives concrete states corresponding state 
sets states gamma gamma 
define implementation action policy reliably moves states corresponding state states corresponding state visiting states corresponding states 
defined implementation solves dcp gamma fs gamma note require stay gamma reaching 
implementations action policy solve problems concrete environment emulating actions 
need look state corresponding current concrete state look action state run implementation 
suggests policy concrete policy works state looking state computing proper action computing running concrete action implementation note policy internal state effectively recomputes action time chooses concrete action 
problem concrete environment state corresponds state implementations allowed visit states state 
handle problem necessary add register environment remember action presently performed 
policy augmented environment computes new action environment concrete state corresponding state 
stores name new action register executing implementation 
environment concrete state state uses action stored register preserves value register lemma projection action implementation policy solves policy thetac thetac solves augmentation alphabet state gamma 
proof phi standard progress function gamma 
phi number actions need solve problem concrete state phi problem solved suppose solves problem states phi consider phi 
policy immediately compute store register 
call action policy immediately executing policy implementation system reach state gamma finite time say reach state assumption solve high level state steps able solve induction solves gamma 
say reducible exists projection implementations actions reducible easily convert solution solution part iii design polly chapter core visual system nearly perceptual processing polly done small group processes call core visual system cvs 
core visual system responsible computing depth information direction corridor detecting people detecting motion sanity checking visual system inputs 
ms cvs processes theta image updates large number percepts see table 
percepts related navigation 
cvs implemented polly code procedures low level vision derived aspects call procedures compute individual percepts 
shows principal components cvs 
cvs subsamples image smoothes passes parallel computation streams 
stream grey computes depth map scene compresses map number scalar values distance closest object robot path center distance left turn view left turn 
computation depth map assumes presence single textureless carpet 
system underestimate depth different textureless abut 
cvs compensates problem second parallel computation check carpet boundaries 
detects boundary instructs depth map computation ignore boundary 
cvs computes vanishing point lines forming corridor 
depth map vanishing point low level navigation system 
symmetry detector searches image tall skinny symmetric regions 
regions typically correspond people legs 
symmetry detector reports direction symmetric region person direction binary value indicating size symmetry region strong person person 
motion unit detect foot gestures 
pair nod head detectors implemented tested robot hardware problems see 
table shows suite high level percepts generated cvs 
camera smoothing edges column heights compress map carpet boundary 
vanishing point center distance left distance right distance vanishing point variance wall detector wall 
symmetry motion person 
person direction major components core visual system cvs 
open left 
open region 
person direction open right 
blind 
wall ahead 
blocked 
light floor 
wall far ahead 
left turn 
dark floor 
vanishing point right turn 
person ahead 
farthest direction table partial list percepts generated visual system 
percepts derived depth map 
blocked 
true closest object ahead robot nearer threshold distance feet 
open left 
open right 
true objects respective direction closer threshold distance 
left turn 
right turn 
true open left right 
true robot aligned corridor 
alignment corridor determined low level navigation system 
lln judges robot aligned robot driven straight sufficient period time 
preferable visual data robot determine axis corridor single image corridor blocked robot reached corridor insufficient information accurately judge corridor orientation 
wall ahead 
wall far ahead 
true flat region ahead depth map 
dark floor light floor true bottom center image pixel intensity threshold 
percepts computed hysteresis compensate transient variations lighting albedo 
robot computes depth map labeling floor pixels right finding image plane height lowest non floor pixel column 
result monotonic measure depth column center 
computation depth polly computation devoted navigation large fraction visual processing devoted finding empty space 
central representation purpose radial depth map 
gives distance nearest obstacle column image 
image columns correspond directions ground plane representation equivalent sort radial map get high resolution sonar ring name 
central pipeline cvs shown grey computes depth information 
robot starts finding edges image 
column image computes height lowest edge pixel column 
right set assumptions height measure distance closest obstacle view column see section 
gives example depth map calculation 
understand assumptions system ramifications performing derivation 
consider arbitrary system computing radial depth map 
example stereo system extract depth map collapse data radial map stereo project approach quite effective set assumptions world smoothness surfaces presence dense texture 
lemma reduce system fg column heights fg computation performs ground separation 
fortunately polly environment satisfies background texture constraint carpet visible texture 
lemma linear filter pass band restricted zero band carpet solve ground problem 
edge detector filter reduce system edges column heights derivation summarized table 
derivation shows background texture constraint simplify ground separation 
importantly shows constraint 
wish run system environment satisfy background texture constraint satisfy ground plane constraint salience constraint holds domain 
example background distinctive color set colors color system swain color histogram method find carpet color column heights wanted build system worked domains implement color system edge detector switch opportunistically provided sufficient information determine 
implement stereo system parallel systems add switch 
particular edge detector polly thresholded gradient detector 
detector chosen compiled short loop dsp 
constraint computational problem optimization ground plane depth perception height background texture ground separation texture table habitat constraints depth recovery 
edge detector lemma free choice computational efficiency 
exact test smoothing theta low pass filter remove noise 
possible range gradients sensitive detector 
avoid driving dark regions edge detection unreliable estimates intensity derivatives noisy edge detector automatically marks pixel darker grey levels 
helps prevent robot driving dark rooms 
edge detector implemented find dangerous procedure source code shown 
procedure named labels pixels avoided 
cvs compresses depth map values left distance right distance center distance give closest distance left side image right side center third respectively 
values derived 
example open left 
open right 
true corresponding distance threshold 
left turn 
right turn 
true depth map open correct side robot aligned corridor 
detection carpet boundaries background texture constraint fails boundaries 
boundaries edge detector fires object robot thinks blocked 
polly explicitly detects condition treats special case 
procedure carpet boundary 
shown checks presence carpet boundary 
returns true find dangerous ignore horizontal edges 
carpet boundary horizontal image robot approaches sufficient cause robot pass carpet boundary 
passes boundary carpet boundary 
returns false find dangerous sensitive horizontal lines 
actual test polly overly simplistic adequate job 
robot examines theta window bottom center image 
searches horizontal edge medium contrast window 
edge pixel brighter grey levels treats image carpet boundary scene 
requirements edge medium contrast pixel bright prevent system classifying dark define find dangerous image dark threshold edge threshold suppress horizontal map vector 
lambda left center 
abs left center edge threshold 
center dark threshold shift image image width shift image image map vector 
lambda left center 
abs left center abs center edge threshold 
center dark threshold shift image image width shift image image source code finding obstacle pixels 
code simplified removing compiler declarations 
suppress horizontal wire set carpet boundary detector detects horizontal boundary 
causes robot ignore horizontal lines see section 
bright wall carpet boundaries 
intelligent test certainly idea 
vanishing point detection polly corridor visual system generates coordinate vanishing point corridor 
vanishing point coincides axis corridor steering discussed section 
vanishing point computation works finding edge pixel image fitting line edge intersecting top screen computing mean intersections see 
visual computations polly computation vanishing point simplified polly knowledge appearance environment 
knowledge explicit deriving polly vanishing point computation general computation 
start system extracts vanishing points running edge finder extracting straight line segments performing clustering pairwise intersections edge segments 
represent system schematically canny edges lines intersect cluster simplify system making stronger assumptions environment 
remove step grouping edge pixels segments treating edge pixel tiny segment canny edges intersect cluster weight longer lines strongly lines corridor dominate scene properly 
edges strong edge detector suffice 
polly uses gradient threshold detector simply compiles efficient code jrij intersect cluster image ri spatial gradient image jrij magnitude gradient image 
tilt angle camera held constant camera mount vanishing point coordinate reduce clustering problem 
jrij intersect cluster 
define carpet boundary 
image vars registers edges edge thresh bad thresh region width region height top line bad edges bottom line im shift image im points row pixel image 
countdown lines region height process line 
countdown pixel process pixel check intensity gradient 
center register data vector ref im delta abs vector ref im center 
center incf bad edges 
delta bad thresh incf bad edges 
delta edge thresh incf edges 
top line set 
top line lines 
lines bottom line set 
bottom line lines im move line 
im 
edges 
edges bad edges 
bottom line top line source code carpet boundary detector 
note countdown dotimes common lisp counts backward 
vanishing point computation edge fragments individual pixels shown circles extended dashed lines intersected top image find horizontal location intersections arrowheads 
mean horizontal locations vanishing point 
assume positions orientations non corridor edges uniformly distributed intersections zero mean 
replace clustering operation looks modes mean intersections result weighted sum means corridor non corridor edges 
mean zero result mean corridor edges multiplied unknown scale factor depend ratio corridor non corridor edges 
result typically underestimate magnitude vanishing point get sign right 
see chapter sufficient purposes 
resulting system jrij intersect derivation summarized table 
cvs reports variance intersections confidence measure 
entire computation performed polly code procedure vanishing point 
procedure computes mean variance directly single pass input array 
procedure contains edge detector tuned find diagonal edges see 
define find vanishing point image start th line image 
image shift image image width sum sum squares points countdown scan line 
countdown image width dx vector ref image vector ref image dy vector ref image image width vector ref image 
abs dx 
abs dy reasonable edge point 
intercept quotient dy dx 
intercept 
intercept set 
sum sum intercept set 
sum squares sum squares intercept intercept set 
points points pixel 
set 
image shift image skip pixel line 
set 
image shift image done image 
compute mean variance 

points 
points mean quotient sum points variance quotient sum squares points mean mean pair mean variance pair source code vanishing point computation 
code walks image bottom top line finding reasonable edges computing mean variance intersections 
mean variance returned pair bit quantities bit word 
edges code gives returns large variance 
note code skip pixel line pixel left 
constraint computational problem optimization long corridor edges line finding pixels lines strong corridor edges edge detection cheap detector known camera tilt clustering clustering uniform non corridor intersections clustering mean table habitat constraints vanishing point computation 
person detection order offer tours people polly needs detect presence moves corridors lab 
robot look downward see people legs 
person detection reduces leg detection 
polly relies fact people generally stand need search straight vertical legs appear tall narrow symmetric objects 
symmetric objects passes 
searches tall skinny symmetric regions image 
tests symmetric region see distinct object 
symmetry detection performed scheme procedure find symmetric 
simplified version technique reisfeld 
simplest measure symmetry vertical axis point gamma gamma dr width region searched symmetry 
give large value pixels gamma tend significant horizontal intensity gradients opposite signs 
bright region front light region dark region front light region positive scores homogeneous region zero score region ramp shaped intensity negative score 
disadvantage measure linear 
superimpose nonsymmetric pattern symmetric scores cancel 
problem edges leg may symmetric surface markings pant leg may 
alleviate problem extent counting pixel pairs symmetric 
adding min integrand gamma min gamma dr problem linearity computation single pair strong edges generate huge symmetry value non symmetric region 
alleviated adding compressive nonlinearity integrand 
reisfeld log function nonlinearity 
polly uses max somewhat faster compute gamma max gammaff min gamma dr ff maximal symmetry value system give single pixel pair 
having scored pixels vertical symmetry local regions centered find vertical lines image strongly symmetric integrating pixel scores columns image 
result vector symmetry values column defined max gammaff min gamma derivatives estimated differences adjacent pixels 
protrusion test having tested different image columns symmetry visual system needs distinguish objects symmetric subregions objects symmetric 
polly specifically looks people standing hallways people show distinct radial depth map visual system requires symmetric region align bulge depth map 
test performed procedure protrusion near 
tests depth map negative depth edge followed positive depth edge specific width region 
edges protrusion visual system asserts person 
signal drives person direction wire coordinate column maximal symmetry 
protrusion test sufficient test guarantee region person leg 
tall skinny vertical object chair leg pass protrusion test 
avoid false positives pick system operates hallways 
trusts person 
signal corridor 
signal asserted 
protrusion test generate false negatives 
person wall protrusion detector generally missed pick system won offer tour 
fortunately useful purposes want robot offer tours people approach robot 
gesture interpretation polly offers visitor tour needs able receive answer 
hear looks particular gesture 
originally nod head 
built working nod detectors ran real time macintosh static camera 
forced waves foot nods 
largely forced hardware considerations 
robot short upward looking camera saw bottom visitor chin nods ended axis oscillations axis oscillations 
axis oscillations difficult measure 
upward looking camera cope great deal glare overhead lights 
glare difficult properly image face 
right solution raise camera human eye level impossible due mechanical stability issues 
upward looking camera broke late design system decided give nod detector wave detector 
foot waving detecting foot waves turned trivial problem interacting robot standing 
typically motion scene 
motion scene intentional shaking leg simple motion detector sufficed wave leg detector contrast various nod detectors 
detector measures total image change frame frame total ji gamma gamma applies low pass filter resulting series total 
low pass filtered motion computed procedure total instantaneous value store 
nod detector detecting nods difficult problem 
suppose person facing camera 
simplicity assume orthographic projection point world projected point image points higher image larger coordinates 
assume objects view rigid piecewise rigid 
treat motion object point time combination translation rotation point point object moves instantaneous velocity gamma theta nod alternating rotation head nod motion head constant direction varying sign remains constant remains zero 
conceptually simplest approach detecting nods find head image determine pose position orientation space track pose time recover motion parameters test parameters rotational oscillation find head pose track oscillating 
system expensive difficult implement certainly conceptually possible 
main problems finding faces determining pose 
particular problem easy confuse translation rotation 
particular difficult distinguish cases bending rotating head downward head translating cm pointing forward 
involve points facing moving downward axis staying point axis 
course translation require neck suddenly grow cm shorter deep knee bends 
simpler system normal flow image bandpass envelope det computes vertical component normal flow field see image integrates field entire image obtain single net vertical motion looks oscillations net motion 
optic flow image apparent dimensional motion texture image 
projection image plane motion vectors actual objects world 
space motion point simply gamma theta optic flow projection simply coordinates vector gamma 
gamma gamma 
gamma 
gamma gamma 
gross oversimplification kinematics jointed objects suffice purposes 
normal flow field component optic flow field direction image intensity gradient 
useful property normal flow field easy compute 
represent brightness point image time vertical component normal flow field gamma derivatives approximated subtracting adjacent points time space respectively compute value quickly 
explain system works performing derivation 
start original system find head pose track oscillating 
recall computing pose difficult translations rotations generate vertical motions image 
head physically capable translating motion head image due rotation person bending knees jumping rapidly standing oscillating platform 
assume people don things may safely interpret vertical oscillation head nod 
call head kinematics constraint translation vector head nearly zero oscillates 
head kinematics constraint allows position head position head image pose 
oscillation position indicate nod 
replace pose module module finds centroid image region occupied head find head centroid track oscillating 
reduced problem finding oscillations head 
finding head difficult 
fortunately re looking arbitrary heads oscillating ones 
need bother searching static parts image 
assume vertical oscillations rare people don nod hands play yo oscillatory motion find head 
ll call motion salience constraint motion parameter object allowed oscillate save parameter head 
motion salience constraint removes need full recognition engine allows system find oscillating points find head constraint problem optimization head kinematics motion disambiguation motion motion salience head detection oscillation horizontal lines flow computation substitute normal flow nod dominance head detection net flow table constraints derivation nod detector problems simplify 
finds oscillating pixels searches head shaped regions oscillating pixels 
find oscillating points computing motion optic flow point image testing motion vertical oscillation 
test done turn applying bandpass filter envelope detector point 
resulting system optic flow bandpass envelope det find head computing optical flow fairly expensive 
normal flow field easier compute fortunately vertical component sign vertical component optical flow provided normal flow non zero 
normal flow zero actual motion nonzero texture image point vertical derivative image intensity zero 
fortunately faces considerable vertical intensity variation problem 
reduce system normal flow bandpass envelope det find head looking oscillations point expensive 
assume motion head dominate motion image look oscillations net vertical motion entire image normal flow image bandpass envelope det exactly system sought derive 
assumption head motion dominates motion rest image needed rule case motions different parts image canceling generate appearance oscillatory motion fact single part image oscillating 
derivation summarized table 
implemented system macintosh personal computer 
system uses theta grey scale images rate approximately frames second 
system performs reliably provided subject nods head times give bandpass filter chance respond 
unfortunately lead frequently different system needed 
second nod detector nod detector adequate general bandpass filter required cycles decide head nod really happening 
known problem linear filters narrower pass band longer takes system respond 
non linear oscillation detector zero crossing detector probably better 
result normal flow image zero crossing det envelope det expect net flow relatively large number random zero crossings head moving 
deal problem backing net flow optimization returning computing oscillations pixel basis normal flow zero crossing det envelope det find head flow zero crossing detectors implemented polly 
unfortunately robot short viewing angle camera wide see bottom person chin difficult get flow detector respond head movements detect nods 
summary polly vision system uses number parallel processes efficiently compute just information needed task 
processes efficient advantage special properties environment 
understand properties deriving systems general ones 
complete list constraints derivations table 
constraint computational problem optimization ground plane depth perception height background texture ground separation texture long corridor edges line finding edge pixels strong corridor edges edge detection cheap detector known camera tilt clustering clustering uniform intersections clustering mean head kinematics motion disambiguation motion motion salience head detection oscillation horizontal lines flow computation normal flow nod dominance head detection net flow table habitat constraints assumed core visual system problems helped simplify 
note known camera tilt constraint agent habitat 
chapter low level navigation lln bottom layer robot control system 
consists speed forward velocity controller open loop ballistic turn controller corridor follower wall follower small amount code arbitrate see 
systems controlled signals speed request turn request inhibit motion 
speed request controls maximum forward velocity effect steering disable wall follower corridor follower zero 
turn request zero turn requested corridor follower wall follower wall visible complete control steering 
turn request driven desired turn angle open loop turn controller issues turn command base inhibits steering time proportional size turn 
inhibit motion 
inhibits lln components forcing robot stand 
asserted visitor pickup see section prevent low level navigation system avoiding visitor 
speed controller robot rate forward motion controlled procedure speed control 
constraints forward velocity robot move forward way close 
want robot move full speed nearest obstacle safe distance safe distance rule speed min max vmax safe gamma center gamma center distance closest object center image center distance output visual system 
robot smoothly approaches obstacle back gets close obstacle 
backing arbitration motor interface odometry speed request inhibit motion vision system turn request direction fep bump switches base controller wall follower speed control corridor follower ballistic turn control inhibit forward motors shaft encoders components low level navigation system lln 
robot direction travel corridor problem 
robot needs turn simultaneously keep large small 
useful allows herd robot place place 
maximum speed max set input speed request 
speed controller modulated inputs 
inhibit forward 
asserted robot drives backward 
inhibit forward 
driven ballistic turn controller see section 
inhibit motion 
set motors disabled robot back away approaching threats 
corridor follower corridor consists basic subproblems aligning axis corridor staying comfortably far walls side 
problems correspond keeping small large respectively 
robot base gives control turn rate dt speed variables coupled kinematics base dl dt gamma dr dt sin change making nonzero 
polly corridor follower uses separate control systems wall distance sums outputs 
aligning corridor polly uses trivial algorithm aligning corridor 
uses control law dt gammaff vp gamma width vp core vision system estimate vanishing point carried variable vanishing point ff gain parameter width width image pixels 
vanishing point needs biased width coordinate system image centered left hand side image middle 
obvious direct way performing task construct model environment find walls corridor model compute multiply gain drive turning motor 
represent schematically model corridor gain dt particularly efficient design models difficult computationally expensive build 
intuitively building entire model environment compress single number waste energy 
system turns minimize system form gain dt 
lemma substitute monotonic function estimate provided get zero right 
system form gain dt monotonic function 
vp gamma width function reduce system vanishing point gain dt system polly uses 
robot nearest points view robot 
dashed curved line indicates robot field view 
distances nearest points view left right walls respectively 
note robot rotates clockwise place gets larger gets smaller 
avoiding walls way avoid walls drive away wall looks closest 
distance closest point view left distance closest point view right see steer equal 
polly control law dt gammafi left distance gamma right distance fi gain parameter 
recall left distance right distance equal unknown monotonic show doesn matter 
unfortunately lemma directly allows replace gamma gamma gamma 
fortunately position robot strictly increasing function strictly decreasing function 
difference strictly increasing 
gamma strictly increasing function 
gamma zero exactly gamma zero 
gamma gamma effectively versions converge value position corridor 
integrating control signals corridor follower sums control signals align corridor avoid walls yielding final control law dt gammaff vanishing point gamma width gamma fi left distance gamma right distance reasoning assumes robot field view wholly right robot walls field view 
large small fields view large values may true 
integration modulated variance vanishing point presence obstacles 
variance estimate vanishing point high ff set zero 
prevents robot steering odd directions oscillating robot enters non corridor areas 
robot blocked obstacle steering turns full speed 
allows robot quickly turn obstacle causing stability problems times 
wall follower robot enters open room wide corridor unable see opposite wall 
situations corridor follower treat opposite wall infinity try balance distances walls 
drive wall seen continue straight path 
idea going 
polly separate control system handle case 
control systems turns keep wall view fixed distance 
control law simply dt gammafl gamma case left wall view dt fl gamma right wall view 
fl gain parameter desired distance 
stored left distance right distance variables 
general obstacle avoidance general obstacle avoidance routine system 
corridor follower wall follower control distance nearest thing side 
normal case nearest objects side walls 
obstacle way nearest thing side robot avoid 
local navigation strategy equivalent method artificial potential fields see khatib 
advantage fast easy compute disadvantage left right distances balance exactly robot blocked obstacle 
cases dealt unwedger unit high level navigation system see section 
ballistic turn controller robot reaches junction needs switch corridor issues open loop turn command base 
command issued ballistic turn controller input line turn request non zero 
turn request normally held low ballistic turn controller driven specific value number degrees turn high level navigation system force turn 
issuing open loop turn controller maintains control turning motors time proportional size turn 
gives microcontroller base time servo correct direction decelerate 
potential problem ballistic turns robot turn face wall 
wall textureless completely fills visual field robot appear empty field robot happily try drive 
theory speed controller back away wall turns 
practice possible robot turn fast speed controller literally sees wall coming 
prevent ballistic turn controller asserts signal inhibit forward 
large turns 
prevents speed controller driving forward place allowing back gets close 
steering arbitration arbitration performed procedure turn controller 
ballistic turns inhibits wall follower corridor follower allowing ballistic turn controller finish turn 
ballistic turn progress uses output corridor follower open left 
open right 
false wall follower true 
speed controller turn controller stops completely inhibit motion 
asserted 
fep bump reflex addition visual collision avoidance implemented dsp fep front processor monitors pair bump switches 
switch closes fep immediately performs fixed sequence actions halts base reverses base issues degree open loop turn away activated bumper 
time dsp disconnected base 
bump switch opens fep resumes normal processing allows dsp drive base 
bump reflex implemented fep processing latency critical issue 
polly normal top speed dsp samples sensors hz robot move cm samples 
bump switches extend roughly cm base require cm travel trigger 
top speed dsp initiate braking action cm robot obstacle 
way robot possibly brake cm 
fortunately fep sample bump switches approximately khz initiate braking actions immediately bumper contact 
practice insufficient robot collides obstacles albeit lower velocity 
base physically capable fast required deceleration robot 
pleasant experience robot owner 
odometric sensing sensing robot odometric 
rwi base provides high resolution shaft encoders dead reckoning turns forward motions 
vast majority information ignored current system 
inherent unreliability odometry reason limited 
course driving building rotational odometer drift degrees base reasonably aligned 
reason simply interested vision odometry chose spend time engineering vision side 
said polly rotational shaft encoder determine direction 
robot assumes starts pointed south shaft encoder reading call receives south reading 
compute rotation relative direction difference current reading encoder drift robot computes orientation degrees 
drives wire direction values north south east west 
odometer drift cause robot direction system robot determines long corridor visual system reports aligned axis corridor assumes exactly aligned compass points recomputes proven effective compensating drift 
technique polly survived drift rates degrees second 
chapter high level navigation navigation central problem current mobile robot research 
robot drive place place thing probably want drive particular place 
problem remains largely unsolved 
navigation suffers problems intractability sensitivity error ai problems suffer 
chapter discuss polly manages navigate reasonably reliably efficiently 
polly navigates particularly benign unmodified environment 
systems polly interesting precise navigation algorithm basic structures environment allow function 
discussing fairly conventional formalization navigation problem reasons difficulty 
add progressively structure problem discuss structure allows simpler mechanisms 
doing derive simple idealized navigation algorithm class worlds mit ai laboratory belongs 
give details polly navigation algorithm describe implement idealized algorithm 
consider problem piloting robot office environment shown 
moment robot decide destination fast turn fast move forward backward 
polly uses policy lounge playroom ian office anita office karen mike elevator lobby kitchen conference room marie office vision lab east west north south approximate layout th floor ai lab mit left topological structure right 
corridors reaches intersections 
intersections compares coordinates intersection coordinates goal presumed intersection turns north goal north south goal south polly sensors goal turn north north goal turn north turn south south goal turn south turn north south goal pointed south turn south north goal pointed north follow corridor details perception control systems 
derivation geometric path planner geometric path planning common technique solving type problem 
detailed description environment start position goal position path planner computes safe path environment start goal see latombe 
path planned separate system follows path 
geometric planning versatile produce efficient paths computationally efficient 
requires detailed knowledge environment perceptual system may unable deliver 
clarify relationship path planning system polly reactive algorithm deriving polly algorithm planning system 
dcp states position orientation pairs actions small translation rotation pairs robot move clock tick 
clearly polly modeled policy 
planner equally modeled policy 
planner executive simply policy uses internal state compute execute plan 
planning portion uses scratch memory gradually compute plan store plan register executive reads finished plan register executes segment turn 
planner executive architecture form plan scratch theta plan scratch plan incomplete execute plan theta execute plan head plan theta tail plan agent spend nearly time corridors 
real choice points environment corridor intersections 
graph corridors intersections need searched full state space see 
lemma augment environment register hold current north south east west action replace policy action theta intersection action theta action ffl intersection state ffl different action policies implement north south east west corridors respectively ffl arbitrary policy 
lemma requires goal corridor intersection robot started corridor intersection 
solve adding plan scratch registers plan execute policy plan scratch theta plan scratch plan incomplete execute plan theta simplify noting isomorphic corridor network theta grid 
lemma replace policy interleaves actions reduce grid coordinate differences current location goal 
remove plan scratch registers reduce action theta intersection action theta action policy satisfying constraints stops goal moves north south east west goal north south east west 
important differences polly polly uses different set actions turn north go north internal state keep track action 
appears qualitatively different policy derived 
short period north action agent pointed north 
similarly east south west actions 
orientation robot effectively action register turn commands effectively write register 
need internal memory 
polly stores state motor 
summarize transformations derivation follows see table 
constraint environment consist network corridors goal corridor intersection allows replace geometric planning constraint optimization ground plane constraint height depth estimation background texture constraint texture obstacle detection corridor network replace planning planning grid structure replace planning difference reduction orientation correlation store state orientation table summary constraints optimizations polly navigation system 
planning corridor graph 
isomorphism corridor graph grid allows replace planning difference reduction 
correlation robot orientation internal state allows store current action orientation 
important note subproblems abstracted environment corridor solved deliberative planning decisions orthogonal 
implemented planners resulting system effectively hierarchical planner see sacerdoti knoblock 
polly environment happens allow simple reactive policies layered reactive system brooks 
environment complicated graph topology reverse second optimization deliberative planner leaving optimization intact 
result hybrid system planning top reacting bottom see spector hendler lyons hendriks bresina drummond gat examples 
hand imagine environment individual corridors cluttered connected grid 
environment problem solved reactively corridor require deliberative planning 
navigation polly seen polly navigation problem easier general case navigation specific properties environment 
properties allow idealized policy polly solve navigation problem planning 
fact bits state information direction register telling go north south east west 
polly implements version policy network parallel processes shown 
navigator chooses corridors steer goal 
robot comes intersection signals ballistic turn controller align new corridor 
effect low level navigation system implements north south east navigator implements position information navigator speed request unwedger turn request vision system direction goal frame matcher high level navigation system 
orientation robot implements internal state ballistic turn controller implements write circuitry internal state 
navigator navigator receives messages inputs goal goal sends messages wires speed request turn request handled speed controller ballistic turn controller respectively 
navigator monitors outputs frame strobe 
place recognition system 
hold coordinates recognized landmark 
frame strobe 
asserted clock tick new landmark recognized 
navigator goal inputs zero navigator inhibits motion setting speed request zero 
goal inputs non zero navigator sets speed request full speed continually checks frame strobe 
new landmark reached checks landmark intersection place recognition system allows types landmarks left right turn point direction goal 
waits seconds issues turn setting turn request 
second delay needed vision system detects turn robot reaches intersection 
navigator informs unwedger direction turn reach intersection see 
robot moving navigator continually checks reached goal goal goal 
reaches goal clears goal goal stopping robot 
place recognition system fail navigator continually checks goal 
initiates turn 
unwedger problem local navigation strategy corridor follower get stuck local minima 
happens example robot perfectly perpendicular wall case difference space left space right zero robot turn blocked 
unwedger takes care problem 
robot blocked seconds unwedger initiates degree ballistic turn 
turn direction navigator turn navigator intersection 
useful robot intersections sees wall front tell unable turn head 
navigator aligned goal axes traveling axis want turn intersection 
case unwedger forced turn direction turn saw 
useful strategy getting cul de sac 
cases turn initiated unwedger sufficient direct corridor follower new corridor 
robot driven dead unwedger fire seconds robot turned point robot leaves way came 
occasionally polly aligns corner unwedger corridor follower fight unwedger turning away corner corridor follower turning 
problem rare ignored 
place recognition polly keeps track position recognizing landmarks larger scale districts 
places advance 
lab landmarks shown 
job place recognition system determine clock tick entered region corresponding landmark district qualitative coordinates 
coordinates qualitative navigator requires order landmarks properly north south east west axes 
coordinates warped monotonic strictly increasing deformation 
coordinates different landmarks shown 
information landmarks stored associative memory lounge playroom ian office anita office karen mike elevator lobby kitchen conference room marie office vision lab landmarks polly environment qualitative coordinates 
kitchen position direction west veer image 
corridor position direction west veer features left elevator lobby position direction east veer features right wall example place frames 
tively searched clock tick ms 
memory consists set frame structures possible view landmark see 
cases frame view compensate variations lighting geometry time 
frame gives expected appearance place particular direction north south east west 
frames contain place name qualitative coordinates direction specification landmark appearance theta grey scale image set qualitative features left turn right turn wall dark floor light floor 
explicit connectivity information represented 
frames tagged speech give tour open loop turn perform 
deal jog corridor elevator lobby 
complete set frames describing th floor appendix glance may inefficient mechanism fact quite compact 
complete set frames th floor requires approximately kw storage 
system scan frames find best match hz fraction cpu 
code frame matcher shown 
matcher process implemented procedure frame matcher 
clock tick frame matcher computes score frame 
best frame score threshold low scores frame matcher takes robot new position 
matcher asserts output frame strobe 
clock tick latches matched frame output current frame latches coordinates 
prevent false matches matcher disables moving corridor blocked matched place 
implemented internal counter frame holds number clock ticks ths second wait matching 
time wait matching frame stored frame slots 
default value seconds ticks 
procedure match frame computes scores see 
score sum penalty terms 
position difference recognized landmark 
direction difference frame current odometry 
appearance difference position penalty depends direction robot moving east frame west north position penalty higher east position 
polly uses ways encoding landmark appearance 
image frames contain theta grey scale images respective landmarks taken specific position 
image frame exactly image landmark multiple image frames 
appearance difference image frame sum squared differences pixels current image 
feature frame contains vector binary features left turn right turn dark floor wall ahead computed visual system 
appearance difference feature frame small current feature vector frame feature vector exactly large 
feature frames matched new feature appears disappears world 
requirement feature bits change amounts requirement robot leave intersection open space matching 
nature wall detector sensitive walls specific distance disappearance wall enable frame matching 
prevents false positives wall bit intermittent 
frame matching relies fact robot views landmarks specific directions 
restricted viewing angle due geometry building long narrow corridors fact corridor follower tends center robot corridor 
roughly speaking hard parts recognition variation lighting variation viewpoint variation landmark occlusion 
polly fails cases systems handles relying fact don vary domain 
lighting office buildings usually internally generated kept constant level 
viewing parameters held fixed camera mount 
rest fixed corridor follower 
viewpoint parameter normally varies robot distance 
parameter searched mechanically robot drives 
define frame matcher corridor 
speed blocked 
set 
frame frames address list frames matched 
frame pointer current frame 
frame frames best frames best value frame set 
frame strobe 
false 
frame find districts dotimes frame count match frame mini frame 
best value frame frame frame frame setf best frame setf best value advance frame start frame 
setf frame shift frame image frame 
frame image frame length feature frame length 
best value setf frame frame place size best setf frame strobe 
true setf current frame best setf frame best setf frame best set 
match bits feature bits source code frame matcher process 
code slightly simplified removing compiler declarations 
define match frame mini image frame frame image frame sum bits changed 
feature bits match bits wall 
set 
bits changed 
true compute penalties estimated position direction motion 
delta frame frame delta frame frame encoding direction north east 
incf sum abs delta vector ref direction 
delta incf sum abs delta vector ref direction 
delta large penalty getting direction wrong 
frame direction frame direction incf sum image frame 
frame mini image version current image 
incf sum compute difference mini image incf sum frame features frame feature bits bits changed 
sum source code matching process 
code slightly simplified removing declarations code computing image differences 
computational search needed viewpoint dependent template matching sufficient 
call constant viewpoint constraint robot approaches landmark approach includes specific viewpoint image frame 
polly recognize large scale districts correct position estimate determine exactly evidence humans information see lynch 
robot presently recognizes long east west corridors districts 
example robot sees left turn driving west southern east west corridor coordinate regardless coordinate 
helps polly recover recognition errors 
recognition districts implemented separate computation 
ought folded frame system 
district recognition implemented find districts see called frame matcher 
implemented wander process alternately sets navigator goal playroom robot gets far west vision lab vision lab robot gets far east playroom 
wander implements patrol pattern path giving tours 
wander sets navigator goal robot starts goes home 
sequencers plan language parallelism default polly separate mechanism necessary introduce 
polly uses simple plan language specify fixed action sequences 
macro define sequencer creates sequence 
takes sequence condition action pairs defines new process scheme procedure run actions program counter keep track process sequence 
process checks program counter clock tick 
negative 
positive number checks nth condition 
condition true executes nth action increments program counter 
basic condition action pair form condition action condition action may arbitrary pieces scheme code terminate quickly allow rest system run clock tick 
various bits syntactic sugar available readable wait condition action ways specifying pairs null actions conditions define find districts stricter criterion turns don get doorways 
left turn 
left distance right turn 
right distance aligned 
ns corridor 
wall 
direction north set 
direction south set 
ew corridor 
dark floor aligned long time 
blocked direction west open right 
open left 
corridor 
set 
direction east open right 
open left 
set 
direction west open right 
open left 
set 
direction east open left 
open right 
set 
source code find districts 
repeated tests collapsed single disjunctions required author done better job implementing boolean tests compiler 
define sequencer leave office import goal leave office blocked 
robot far wall set 
global mode turn door turn 
sleep open left 
robot office goal align sleep want parallel corridor 
turn east wall playroom turn 
sleep direction east blocked 
aligned east wall turn turn 
wait ew corridor 
sleep robot thinks aligned set position 
set 
set 
source code sequencer leaving author office entering corridor 
goal macro displaying string lcd display 
respectively 
sleep seconds causes process inactive specified period 
sequencer started fired process executes form 
sequencer name 

simply clears program counter 
sequencer executes finishes condition action pair point sets program counter waits fired 
multiple firings executions 
produce multiple copies sequencer just reset program counter 
shows example sequencer leave office enter hallway 
fired boot time 
import parameter compiler declaration 
define sequencer offer tour import set 
global mode set 
inhibit motion 
true done talking 
new say hello 
am polly 
tour 
wave foot sleep blocked 
person 


give tour new say ok nice day set 
global mode set 
inhibit motion 
false person gone 
set 
global mode set 
inhibit motion 
false sequencer code offering tour 
giving tours sequencers offer tour give tour implement tour giving 
robot patrol mode east west corridor blocked person offered tour seconds interact process fires offer tour 
offer tour fires give tour visitor accepts see figures 
define sequencer give tour import new say ok please stand side set 
tour set 
tour set 
tour set 
tour blocked 
new say 
please follow set 
inhibit motion 
false set 
global mode wait frame strobe 
wait place 
tour tour sleep new say tour 
nice day set 
global mode sequencer code giving tour 
part iv results chapter experiments polly great thing optimality criteria choose 
anonymous robotics conference attendee polly best tested vision robots date 
low level navigation system seen hundreds hours testing different environments 
coloring algorithm ported half dozen robots run conferences classrooms 
high level navigation system tour giving components newer tested 
spring robot tours 
performance complex robot systems extremely difficult quantify meaningful manner 
suggested robot rms deviation mid line corridor evaluate low level navigation system 
unfortunately staying center corridor part task 
necessary particularly desirable robot stay exactly center 
task requires safely get side 
alternatively try prove time power optimality paths generates unclear variations find corridor followers matter real user 
worse real world users care power time care total power consumption including consumption computers 
motor power consumption computer power consumption polly electronics compared motors 
optimizing may require increase computer power worse unclear time power consumption path meaningful 
serious problem quantification measures ignore cases robot fails completely environmental assumptions fail 
choice optimal robot fails time optimal robot fails time users generally choose optimal 
slightest idea optimal fails time really mean realistic global sense measure 
far variables involved able controlled experiments 
reasons data necessity anecdotal 
information tends qualitative quantitative dependent particular environment tested 
true complicated artifact interacting complicated environment 
see real alternative 
time robot works fine focused classifying errors occur 
tried catalog different types failure modes observed system moved outside design envelope 
tried document ways recovers problems cases 
information definitive numerical tests speed accuracy feel 
gives accurate picture performance system 
say robot unreliable 
quite contrary robot works normal cases designed focus performance pathological situations 
failure modes discussed darkened rooms presence specular reflection presence edges cause problems vision systems 
speed polly fastest indoor vision robot date 
fastest terms processing speed rate motion 
table shows processing driving speeds number robots literature 
different systems perform different tasks difficult draw firm numbers 
sufficient show polly fast system standard 
processing speed low spatial resolution polly allows high temporal resolution frame rate 
summary processing time different levels capability table 
reader note elapsed time decrease amount processing decreases system bound 
time spent waiting serial link base waiting transfers frame grabber waiting frame grabber finish grabbing frame 
hard test directly believe principle limitation frame grabber grab consecutive frames double buffering system frames sec mips speed obstacle detection 
polly stanford cart moravec 
kak mobi thorpe 
dickmanns 
dickmanns scarf alvinn pomerleau 
aura path follower table processing driving speeds various visual navigation systems problems solve 
group indoor navigation systems intended office buildings stanford cart run outdoors 
second group outdoor path followers road followers 
implemented sacrificing video output debugging 
restriction removed shifted bottleneck base 
baud time transmit bytes video frame time base 
base commands require bytes input characters output prompts sufficient time perform necessary transactions base video rate 
fps half video rate just barely time reset velocities acceleration caps poll base odometry 
room great deal improvement 
better compiler able halve processing time 
system bound case worth implementing compiler improvements 
driving speed driving speed limited dynamics robot base processing speeds 
robot center gravity midpoint fall torques applied bottom robot 
result wheels moving robot card cage keeps moving robot falls 
controlled imposing acceleration caps cost greatly increasing stopping distance robot 
problem internal control system base calibrated unloaded conditions 
base tries go maximum speed motors provide sufficient force accelerate base rate control system wants 
test time sec frames sec full system corridor follower vp table execution times frames 
full system code presently implemented including person detector 
corridor follower frame grabbing output base single frame grabbed processed repeatedly 
vp collision avoidance system run vanishing point box 
execution times texas instruments tms dsp board running wait states 
processor ns instruction time 
lines system digitize frames faster fps 
control system notices isn moving fast signals error shuts 
speeds require pushing robot help accelerate 
control system disabled allowing dsp directly specify motor currents robot tends pop human intervention required keep falling 
believe system run fast mode calibrated velocity measurements 
apart stability low level control considerations navigation system appears able pilot robot fast physically capable moving 
polly run different bases 
robot generally run old base 
unfortunately base damaged testing bump sensors new base substituted 
new base functionally equivalent different gear ratio internal control system 
new control system grossly damped 
new base regularly accelerated regardless velocity point brake fall 
necessary add extra damping dsp control system compensate 
new base safely run complete test runs night pick system implemented videotaped test runs 
traces test runs shown figures 
robot successfully gave tour tests 
run visitor misunderstood instructions robot thought robot said move way 
visitor moved part way correct path detail area near elevator lobby robot intended path actual path test run 
way robot misinterpreted motion wave foot 
correctly believed visitor wanted tour wrong reasons 
robot started tour close elevator lobby recognize landmark 
recognized previously occluded visitor 
robot recognized area right continued forward blocked wall 
fortunately unwedger navigator able successfully pilot robot corridor spite failure see 
robot reached kitchen place recognition system robot continued incident 
second test place recognition error caused inappropriate turn took long time recover 
run terminated robot allowed run navigator turned place recognition system 
robot errors point 
test runs performed properly 
environments polly efficiency due environmental specialization 
robot specialized particular environment class environments habitat 
aim analytic part understand environmental features necessary robot operation 
put way want understand robot habitat really analysis low level navigation code environment corridors textureless place action comments corridor drive west detected person hello speech pause confused visitor moves way please stand side polly mistake visitor moves drives forward please follow visitor follows elevator lobby drives west robot misses landmark west wall turn right unwedger takes drive north north wall turn left unwedger takes robot course avoid obstacles chatter speech kitchen follow corridors robot making previous speech intersection left kitchen place speech vision system runs chatter speech vision lab turn left south right 
vision lab speech drives south lounge wall way chatter speech turn left east unwedger takes drives east couch drives east couch lounge place speech lounge god place chatter speech drives east karen office place speech drives east anita office place speech drives east playroom turns left place speech drives north near chair stops turns left obstacle avoidance 
goodbye speech drives cruise mode transcript test run 
place action comments west wall stops turns right obstacle avoidance drives north north wall stops turns left unwedger takes drives west transcript test run cont place action comments corridor drive east detected person hello speech pause visitor waves foot please stand visitor moves drives forward please follow visitor follows anita office playroom place recognition error turns left drives north drives printer transcript second test run 
place action comments corridor drive east detected person hello speech pause visitor waves foot please stand visitor moves drives forward please follow visitor follows anita office place speech drives east avoid obstacles chatter speech playroom turns left drives north place speech drives north near chair stops vision system chatter speech turns left obstacle avoidance drives west wall stops turns right obstacle avoidance drives north north wall stops turns left unwedger takes drives west way chatter speech drives west elevator lobby right north wall stops turns left obstacle avoidance drives west kitchen left place speech drives west god chatter speech vision lab turns left right place speech drives south lounge wall turn left east unwedger takes drives east transcript third test run 
place action comments couch drives east couch lounge place speech drives east karen office place speech drives east goodbye speech transcript third test run cont 
obstacles rest ground 
conjectured properties true office buildings tried test conjecture empirically testing robot alternate environments 
note parameters changed tests 
difference code run tests code run th floor navigator disabled robot map floors 
tech square tech square common term building houses ai lab laboratory computer science 
test polly take different floors tech square 
building floors plus basement 
corridor follower obstacle avoidance floors ninth floor basement 
floors shiny tile carpet 
tile shiny acts dirty mirror viewed feet ground 
result images overhead lights appear floor 
worse move robot happens close robot back robot back wall 
roughness floor serves diffuse light somewhat possible edge detector tuned high frequency band ignore lights 
floors carpet boundaries 
robot problems boundaries appeared horizontal field view carpet boundary detector specifically tuned horizontal boundaries boundaries paralleled walls 
boundaries restricted robot channel wall boundary 
robot turned degrees right point probably crossed boundary 
intelligent algorithm detecting carpet boundaries great asset 
place action comments corridor drive west detected person hello speech pause visitor waves foot please stand side visitor moves drives forward please follow visitor follows elevator lobby right north wall turn left avoid obstacles avoid obstacles chatter speech kitchen follow corridors robot making previous speech intersection left kitchen place speech vision system runs chatter speech vision lab turn left south right 
vision lab speech drives south lounge wall way chatter speech turn left east unwedger takes drives east couch drives east couch lounge place speech lounge god place chatter speech drives east karen office place speech drives east anita office place speech drives east playroom turns left place speech drives north near chair stops turns left obstacle avoidance 
goodbye speech drives cruise mode transcript test run 
place action comments west wall stops turns right obstacle avoidance drives north north wall stops turns left unwedger takes drives west transcript test run cont 
brown cs department polly tested computer science department brown university 
system worked successfully followed corridors avoided obstacles including people moved open spaces 
problems 
robot major problem lack light 
lights dark seriously inhibit response video camera 
edges walls carpet low contrast edge detector running low light levels 
robot saw wall drive invisible walls 
situation problem nearly vision system 
aspects environment geometry problematic 
presence downward staircase 
possible robot seen staircase boundary stopped brave test 
corridors narrow robot turn backing wall process 
problem corridors narrower polly minimum safe distance 
robot perform place degree turns reached dead ends relied unwedger turn degrees time problems 
solved rear bumper 
burn tests conducted number burn tests robot letting robot run laps minutes time 
performed controlled burn tests 
longest minutes 
runs worked running incident extended periods 
runs ran terminated human intervention 
described 
test robot ran minutes incident 
test terminates series 
base damped started fast broke tipping 
generated internal error firmware control system base causing base halt limp 
reset base forgot resetting error resets odometer robot think pointing south 
robot performed lap spite having wildly incorrect odometry information 
reset odometry realized problem 
accidentally triggered go home function process 
time go home turned worse interlocked 
go home sequencer fought control navigator laps 
eventually brought robot near office go home routine forcibly parked base run 
series took laps complete 
final test terminated failure motor battery 
battery appears weakened racing control system new base 
robot maneuvers tight passages oddly shaped areas frequent start stops causing internal base control system race 
racing base typically accelerates brakes racing huge amounts energy motors accelerate robot pour energy motors slow 
racing seriously weakened polly motor batteries 
alas weak batteries lead sluggish motor performance cause internal base control system race 
matters worse playroom just rearranged channel robot follow playroom complicated usual see 
complexity meant starting stopping 
run base repeatedly shut obtain sufficient performance motors 
required elaborate human intervention restart base maintaining odometric data 
apart problems robot functioned running roughly laps 
robot errors 
due overhead lights having replaced ones 
space lights strong shadow right side drive robot away robot avoids places dark edge detector fail 
robot left sufficiently gradual manner thought straight corridor see 
past shadow turned far left right wall view 
believed aligned corridor concluded come landmark turned accordingly 
problem diagnosed compensated placing obstacle shadow prevent robot 
solved problem 
unfortunately hard compensate new lights 
dropping darkness threshold fact prevent making error prevented robot halting approached dark obstacles dark areas 
appears brighter lights sensitive camera answers 
problems due shafts bright morning sunlight coming layout playroom rearranged typical paths robot 
note layout paths metrically accurate measured accurately 
qualitatively accurate paths accurately represent pieces furniture redirected robot path 
shadow problem burn run 
overhead lights replaced area corridor dark robot see 
robot avoided area lost sight right wall passed thought reached elevator lobby 
robot right elevator lobby 
office doors 
shafts sunlight saturate camera pixels appear obstacles 
robot halted tried find way sunlight vain 
case tried enter office doorway way 
problems solved closing office doors 
complete log run appendix limitations failure modes useful extensions low level navigation general low level navigation problems obstacle detection problems 
fortunately false positives false negatives system conservative 
system major failure mode braking shafts sunlight 
sunlight coming office doors hallway sufficiently strong causes robot brake fact obstacle 
shadows problem generally diffuse trigger edge detector 
false negatives caused number common conditions 
system memory brake object camera field view 
objects lab surface reflectance carpet rest distinguished color 
robot black white camera distinguish edges 
edge detector fail low light levels 
course vision systems object find edges failure mode surprising 
inability see backward major collision avoidance problem 
adding rear bumper solve backing wall problems 
navigator high level navigation performance determined accuracy place recognition 
general system works robot gets lost 
robot gets lost navigator generally overshoot turn 
robot gets severely lost navigator place recognition system gets 
worst case place recognition system thinks east goal western edge building west goal east 
case navigator unit unwedger continually opposite course corrections 
navigator probably modified give situations 
general system benefit able explicitly notice lost 
unwedger general unwedger works 
failure mode appears robot gets corner 
corridor follower tries point robot corner 
unwedger turns robot degrees insufficient move attractor basin corner 
robot loops alternately turning away corner 
fixed increasing turn angle cause problems situations 
best solution explicitly note looping behavior force turn 
place recognition recognition matching images quite general fragile 
particularly sensitive changes world 
chair view landmark template continue view place orientation forever 
chair moves landmark new template 
problem robot camera pointed floor isn interesting seen 
reasons feature frames preferred image frames 
image landmark kitchen 
trials robot recognized kitchen times going west times going east 
kitchen recognition fails completely kitchen rearranged 
methods consistently landmarks person standing way 
fail robot process course driving obstacle corridor wide large amount junk 
conditions cause constant viewpoint constraint fail 
cause robot turn walls invisible 
recognition districts reliable confused robot driven cluttered open space corridor 
camera limitations dynamic range major problem vision systems 
polly suffers greatly fact camera digitizer dynamic range means scene illuminated office lights sunlight necessarily lose pixels ends scale 
regions effectively invisible 
polly suffers greatly limited field view 
field view huge standards easily nearby obstacles view 
field view causes intersection detection problems 
able turn head look see really passing corridor 
wider field view ability steer camera great asset 
liked able color stereo information 
able hardware limitations frame grabber 
believe cues greatly improve performance robot 
multi modal sensing current state vision technology bad idea rely exclusively vision obstacle avoidance particularly vision camera limitations discussed 
avoided sensing modalities limited time modalities essential development industrial strength version polly 
bump switches extremely useful 
robot bump switches idea 
unfortunately bump switches little high speeds 
bump switch extending cm forward gives ms collision warning stopping ms require deceleration 
extremely useful translational odometry disambiguate adjacent landmarks visually similar 
polly hardware physically capable required complicated device drivers 
robot dead turn look turn waste time greatly increase risk getting rear ended human 
chapter summary polly works polly efficiency reliability due number factors 
specialization task allows robot compute information needs 
specialization habitat allows robot substitute simple computations general ones 
polly existence proof robust system large behavioral repertoire built simple components specialized task environment 
demonstrates analyze specialization may better understand system transfer insights gained design design systems 
number architectural features polly favor 
polly uses multiple strategies parallel reduces likelihood catastrophic failure 
strategies independent failure modes combination quite robust 
vanishing point computation generates bad data depth balancing strategy compensates distance control system prevents collisions vanishing point corrected 
polly control perception loops run fast visual percepts motor commands recomputed ms rapidly recover errors 
think polly control problem problem generating ms safe path 
ms cm inches 
navigation systems process image seconds minutes compute path segments order meters 
verifying safety cm path simply lot easier verifying path particularly size robot meter 
committing path robot needs precise reliable measurements insure path fact safe 
measurements take great deal computing time 
takes control system seconds control decision control system commit path long maintain speed turn requires precise measurements resulting vicious circle 
robot small size significantly simplifies navigation problems 
office buildings designed human sized creatures width doorway determined human shoulder width 
office door inches shoulders inches 
leaves inch clearance side 
robot feet diameter inches clearance minimum operating distance standard sonar sensors 
robot rely short range sensors tactile feedback 
tactile feedback bad idea robot weighing pounds 
polly foot wide survive great deal navigation 
small size relatively light weight simplify vehicle dynamics high speeds 
lightweight vision things prove vision 
claim lightweight systems replacement reconstruction systems 
claim proven long term efficacy task vision active vision qualitative vision research strategies 
report best taken reminder number resources available designer vision systems may forgotten 
important resource structure environment 
presence simplifying structures environment allows simple computations substituted expensive ones 
simplification done principled manner making structures explicit form habitat constraints describing simplification form general lemma 
advantage lemma allows people perform optimization 
shows important simplification 
particular edge detector robot ground separation unimportant 
important fact thresholded linear filter restricted right band 
structure task complementary resource 
tells designer information needed performance required 
importantly tells design information needed performance required 
computing information means computing representations obviously expensive squeezing information existing representations worse 
principle taught undergraduate ai classes representation important information explicit 
information representation information explicit non trivial processing required just look representation extract information needed place 
representation expressive power original image nearly difficult interpret 
improving performance parameters hand generally requires making trade offs usually trading cost performance trading performance characteristic 
improving unimportant performance parameters wasted effort waste performance parameters 
resolution useful case point 
researchers talked taken granted images theta useless polly uses resolutions low theta 
polly demonstrates surprisingly results obtained surprisingly low resolutions see horswill brooks pomerleau examples 
obviously tasks environments require higher resolution 
system need sample resolution 
smooth finely textured object moves past camera intensity field vary rapidly space time finely sampled estimate motion field 
motion field vary slowly need sampled nearly finely 
fear vision difficult get people admit writing common attitude ai robotics vision worth considering sensor expense unreliability 
course really expensive 
tasked constructing digital terrain maps high resolution satellite images option build full stereo shape shading system computational resources necessary job 
simpler options available simpler tasks corridor 
reactive planning researcher wanting give planner execute content job 
researchers put inadequate sensory suites simply felt vision impractical 
hope succeeds convincing users vision safe try 
studying world argued need study structure agents structure environment relationships agent structures environment structures 
short need study world 
approach define formal semantics set possible agents set transformations agents preserve semantics constraint holds 
approach allows assumptions agent separated computational significance drawn 
assumptions constraints cataloged designs checked different domains computational profiles domains 
doubtless approaches explored 
may object project applicable specialized systems truly general systems 
truly general systems extremely rare 
general vision systems tacitly assume world non specular surfaces completely smooth 
assume piecewise planar 
planners assume world completely stable 
requires things planner agent world 
assume world deterministic boundedly unpredictable effects action easily determined advance 
necessarily faults 
habitat constraints 
habitat constraints judged usefulness match agent environment 
choice habitat constraints ones 
chooses constraints need stated explicitly computational significance 
true simple reactive robots complex reasoning systems 
short need learn intelligent consumers specialization 
need understand real underlying difficulties actual test domains systems 
done examining world agent 
failure analyze test domains seriously undermines agents 
studying world help design general purpose systems 
helps clear tasks hard easy 
problems hard general case majority actual problem instances encountered agent relatively simple agent may thrive simple methods possible saving cognitive resources truly hard instances 
ai natural science 
continually test hypotheses nature external world 
algorithms representations formalizations world eventually compared external reality 
doing early reduces risk wasted effort 
understand intelligence study world live 
appendix frame database database frames presently robot 
frame defined defframe form takes name landmark coordinates set features direction robot pointing landmark saw features 
features image bits 
possible bits left right wall dark meaning dark floor 
appearance place variable multiple frames specify possible appearances 
veer parameter amount veer left right degrees right positive reaching landmark 
default veer zero 
speed parameter specify string send voice synthesizer giving tours 
note spelling required get voice synthesizer say right thing odd 
place size parameter amount time take robot drive landmark 
default seconds 
passage 
parameter means landmark grid point navigator consider making turns landmark 
defframe ian office starting point ian office 
direction south left 
defframe ian office direction east speech office 
place size left 
wall 
dark 
defframe office direction west place size passage 
left 
dark 
defframe elevator lobby direction west veer place size right 
wall 
dark 
defframe elevator lobby direction west veer place size right 
wall 
defframe elevator lobby direction west veer place size right 
dark 
defframe elevator lobby direction west veer place size right 
defframe elevator lobby direction east veer place size right 
wall 
defframe kitchen direction west speech left copier room kitchen 
image 
defframe kitchen direction east image 
control algorithms loose junction place size large give chance stabilize 
defframe corridor direction west passage 
place size left 
defframe corridor direction west passage 
speech right lab 
left 
deal effects having marc raibert door open hall sunny days 
overwhelms agc camera corridor appear dark playroom 
defframe corridor direction west passage 
speech right lab 
left 
dark 
defframe corridor direction east passage 
right 
defframe corridor direction east passage 
speech right lab 
right 
defframe corridor direction east passage 
speech right lab 
right 
dark 
defframe marie office direction west veer left 
defframe marie office direction west veer left 
right 
defframe marie office direction north right 
defframe marie office direction north right 
left 
defframe conference room direction west right 
defframe lounge speech 
direction east passage 
left 
defframe lounge speech 
waste lot time 
direction east left 
place size defframe lounge direction west speech 
waste lot time 
place size right 
defframe lounge passage 
direction west right 
defframe anita office 
direction east speech office 
left 
place size defframe anita office direction west place size right 
defframe robert office direction east place size right 
dark 
defframe play room speech playroom 
direction east passage 
left 
dark 
defframe play room direction east passage 
speech playroom 
left 
right 
dark 
defframe hi karen direction west right 
defframe hi karen direction east speech karen mike office 
left 
appendix log burn run am channel playroom 
started robot 
robot consistently left room loses wall mistakes room elevator lobby 
experimented changing lighting conditions room 
effect 
determined problem due shadow cast new lights 
shadow dark force robot avoid 
problem solved placing new obstacle shadow balance 
try dropping shadow threshold 
door room opened 
morning sun casts band light strong barrier hallway 
robot enters office skims doorway halts 
reorient reset base robot continues 
robot believes 
place recognition system resets playroom continues normally 
uneven geometry playroom making robot lot obstacle avoidance 
control system base racing starts blocked 
collisions far 
damping dsp compensating 
robot path playroom quite variable 
base control system worse 
popped accelerating playroom 

base shuts 
manually reset base robot continues normally 
door room opened 
sunlight video camera robot stops trying get past sunlight 
disable base 
occupant leaves closes door 
robot restarted 
base halts twice row 
possible battery problems 
reconfigure playroom corridor robot 
robot runs playroom stopping 
base halts 
restarted 
base halts 
run terminated 
appendix polly source code chapter contains source code parts polly matter ai researchers 
brevity contain system code device drivers utility functions macro definitions fep code assembler compiler 
changes portions commented deleted entirely 
compiler directives removed 
comments added 
code written statically typed subset scheme supports pointer arithmetic 
support garbage collection enforce stack discipline activation records 
means closures effectively unsupported 
includes number useful forms common lisp 
summary linguistic peculiarities 
run system features peculiar polly 
caveat complicated expressions exercise obscure bug register allocator 
graduate didn fix register allocator problem 
reader find occasional places constructs unpacked 
apologize code somewhat readable 
main loop top level system series initializations followed main loop 
main loop grabs new image processes computes new motor actions outputs serial port fep forwards base 
implementation notes serial little odd polly 
chip peripherals sufficiently decided phase system 
cpu fills output buffer dma controller transfers serial port 
serial calls compiler declarations vars registers informs compiler place possible registers 
hardware looping enables compiler generation special zero overhead looping instructions 
register forces register allocation argument 
iteration constructs countdown macro just dotimes counts backwards 
faster 
pointer arithmetic shift performs pointer arithmetic vectors read shift 
equivalent construct write shift 
abbreviation read shift 
equivalent set 
shift offset mapping map vector 
macro mapcar takes vectors input destructively modifies output 
vectors output argument 
procedure called effect 
map region 
map vector processes sub vector specified start position length parameters 
regions output 
ash arithmetic shift forge equivalent type casting compiler think argument specified type 
external forces assembly language label 
useful interfacing run time system 
macro common lisp body consequent null alternative 
macro common lisp opposite 
pair compresses bit integers single bit integer 
pair pair extract components pairs 
peculiarities character write line writes string serial port crlf 
write line formatted writes string hexadecimal number string crlf 
display line writes string specified location robot lcd display 
display formatted line write formatted line display 
display packed line display line uses special packed strings 
macro packs argument string generates call display packed line 
switch 
returns true specified front panel switch 
true time macro returns number consecutive clock ticks argument predicate returned true 
define box macro defines named procedure allocates space wires named outputs 
peculiarities polly runtime system 
performed dma controller running 
greatly simplifies library code little weird 
wait output call synchronize cpu dma controller insure safe cpu write output buffer 
start output re initiates dma 
serial input done polling 
interrupts relatively easy write debug experiences serial port reluctant spend time debugging interrupt driven serial fep interface call poll serial port 
note calls main loop sure bytes get lost 
state loop macro expands infinite loop plus extra housekeeping code true time macro see 
tour demo lisp define main setup 
initialize hardware initialize library set 
set 
set 
current frame frames wait output 
leave office start output real loop 
state loop low level vision fep interface derived aspects test gotten moved frame matcher code 
corridor 
looking 
speed frame matcher unwedger wait output fep interface odometry run sequencers navigator interact update display chatter messages needed prevent kind weird race condition determined 
fep crash bring halt mode 
dotimes motor control start output core vision system cvs implemented files vision lisp contains vision routines library lisp contains calls routines code set various global variables 
name library due historical reasons 
routine low level vision computes basic percepts depth map 
derived aspects computes additional percepts percepts computed low level vision 
vision lisp separable low pass filter 
define smooth scratch hardware looping map region 
scratch vector length scratch lambda left middle right left right ash middle shift shift map region 
vector length lambda middle ash ash middle shift scratch scratch shift scratch edge image compute column heights write vector 
image argument longer 
define find distances edges image vector mark top image simplify loop termination test 
hardware looping mark top edge image insure edge column 
map region 
edges image width lambda shift edges image width countdown column find height column column 
pointer register address shift column distance register data scan bottom find non zero pixel 
read shift 
pointer set 
distance distance write distance 
vector set 
vector column distance define find vanishing point image vars registers image shift image image width sum sum squares horizon points reciprocals forge vector integer external reciprocal table quotient lambda ash vector ref reciprocals countdown scan line 
hardware looping countdown image width try pixel compute gradients 
dx register index vector ref image vector ref image dy vector ref image image width vector ref image test gradients reject small 

abs dx 
abs dy reasonable edge point 
compute intercept top screen assumed vanishing point 
intercept quotient dy dx sure view 

intercept 
intercept view average 
set 
sum sum intercept set 
sum squares sum squares intercept intercept set 
points points pixel 
set 
image shift image line 
skip ignored pixel line 
skip compute gradient 
set 
image shift image done pixels 
check got sane number edge pixels 

points 
points return mean variance 
mean quotient sum points variance quotient sum squares points mean mean pair mean variance didn return center screen infinite variance 
pair define suppress horizontal false find pixels want avoid 
return number edge pixels 
define find dangerous image dark threshold bright threshold brightness threshold 
edge threshold artifact edges vars registers hardware looping total edges suppress horizontal map vector 
lambda left center 
abs left center edge threshold 
center dark threshold 
center bright threshold incf total edges shift image image width shift image image map vector 
lambda left center 
abs left center abs center edge threshold 
center dark threshold 
center bright threshold incf total edges shift image image width shift image image total edges artifact edges compute map vertical pixel 
grey scale image 
image write pixel symmetry values 
results element vector 
exit ith element results holds sum symmetry values pixels column 
define find symmetry results scan width number pixels side compare computing symmetry image width lines skip don bother top lines 
vars registers shift image width lines skip shift image width lines skip scan width res results countdown lines go lines skip line 
countdown pixels go image width scan width compute symmetry score particular pixel 
score left register address left register address shift right register address shift scan width right register address shift scan width compare derivatives pair opposing pixels 
hardware looping countdown scan width left deriv left left right deriv right right compare derivatives specific pair 
incf score min left deriv right deriv got symmetry value 
impose min max limits 
true score min ash max score write 

true score 
res vref res ash true score done pixel shuffle pointers 
res done line 
set 
res shift results scan width scan width scan width return true bump distance vector near specified offset 
define protrusion near 
distance vec offset vars registers edge thresh neg edge plus edge shift distance vec offset start columns left offset scan right 
look negative going distance edge followed positive going distance edge 
dotimes left vref right vref diff left right edge 
abs diff edge thresh neg edge 
diff edge 
neg edge 

neg edge set 
neg edge set 
plus edge 
neg edge 
plus edge 
plus edge neg edge find carpet boundary 
define carpet boundary 
image vars registers edges edge thresh bad thresh region width region height top line bad edges bottom line im shift image countdown lines region height countdown pixel center register data vector ref im delta abs vector ref im center 
center incf bad edges 
delta bad thresh incf bad edges 
delta edge thresh incf edges 
top line set 
top line lines 
lines bottom line set 
bottom line lines im move line 
im 
edges 
edges bad edges 
bottom line top line compute sum absolute differences old new 
routine 
compute horizontal flow name difference images turned reliable 
define define total old new sum vectors lambda old new right abs new old 
incf sum old new shift new set 
ash sum ash return smallest element region distance vector 
define region min vector start length register data regions start length lambda 
set 
vector return index largest element vector specified region 
define region max point vector start length vars registers maximum max point length shift vector start countdown 
maximum set 
maximum set 
max point max point return number elements vector values near value 
define region value count vector start length value vars registers value value get register count regions start length lambda 
abs value incf count vector count smooth distance map 
define smooth map vector 
lambda ash ash shift shift library lisp subsampled image camera 
define image null vector image averaged 
define mini null vector low pass filtered version image 
define smoothed null vector define old smoothed null vector define motion null vector define reversals null vector define old motion null vector edge map 
define edges null vector radial depth map 
define distance vector null vector values symmetry pixel 
define symmetry image null vector values symmetry calculation column image 
define symmetry vector null vector define initialize library set 
distance vector vector image width set 
image image set 
old smoothed image set 
mini mini image set 
smoothed image vector fill smoothed vector fill old smoothed set 
edges image set 
symmetry image image set 
symmetry vector vector image width visual system 
tuning parameters 
define constant dark floor level define constant light floor level number noise edges introduced frame grabber dumb edge algorithm 
define constant artifact edges consider ourself blind see fewer number edge pixels 
define constant blindness threshold define box low level vision outputs left distance right distance left space right space center distance center space wall ahead 
wall far ahead 
boundary 
farthest direction dark floor light floor blind 
edge count vanishing point variance reversals person 
person direction get image preprocess 
grab start image shrink image image mini swap smoothed old smoothed buffers temp register data old smoothed set 
old smoothed smoothed set 
smoothed temp smooth image smoothed edges find edges distance finder 
set 
boundary 
direction carpet boundary 
smoothed set 
suppress horizontal boundary 
set 
edge count find dangerous smoothed edges set 
blind 
true time 
edge count blindness threshold compute distances 
find distances edges image distance vector set 
left distance region min distance vector set 
right distance region min distance vector set 
center distance region min distance vector set 
wall far ahead 
region value count distance vector set 
wall ahead 
region value count distance vector look symmetry people 
vector fill internal symmetry vector find symmetry smoothed symmetry image symmetry vector set 
person direction region max point symmetry vector set 
person 

vector ref symmetry vector person direction protrusion near 
distance vector person direction find vanishing point 
vp computation returns pair 
pair register data find vanishing point smoothed set 
vanishing point pair pair set 
variance pair pair floor vector ref mini dark floor 
floor set 
dark floor false 
floor set 
dark floor true set 
light floor 
true time 
floor light floor level temp register data old motion set 
old motion motion set 
motion temp set 
total old smoothed smoothed define macro bit value pos forge integer value ash pos define box derived aspects outputs blocked 
open left 
open right 
turning 
aligned 
left turn 
right turn 
aligned long time 
corridor 
feature bits previous bits wall 
open region 
person ahead set 
previous bits feature bits set 
turning 
abs turn rate set 
aligned 
turning set 
aligned long time 
true time aligned 
set 
blocked 
center distance set 
corridor 
true time 
center distance set 
open left 
left distance set 
open right 
right distance sorry 
expression register allocation compiler turning 
set 
wall 
forge boolean forge integer wall ahead 
forge integer 
true time blocked 
forge integer wall far ahead take bunch readings wall open left right dark floor package bit value match bit feature values place frames 
set 
feature bits bit wall 
bit open left 
bit open right 
bit dark floor set 
open region 
true time open left 
open right set 
person ahead 
open left 
open right 
person 
corridor 
aligned 
abs person direction low level navigation top level entry point motor control system motor control 
calls speed control turn controller call routines turn 
turn controller ballistic turn controller speed control routines generate motor outputs 
routines just pass numbers representing speeds 
odometry procedure talks fep processes odometry information come 
updates direction wire updates direction lcd display corrects drift odometer offset 
idea robot going straight line long time perfectly aligned corridor 
means know true value odometer ought compute offset difference ideal actual readings 
implementation notes part file intended intimately familiar rwi base control language want know dirty details running large payload motor control lisp motor control tunable parameters define constant maximum speed define constant maximum turn define constant degrees encoder degrees degrees define constant degrees delay degrees ash abs degrees latching inputs ballistic turn speed 
speed higher levels want move 
continuously adjusts speed 
define speed request maximum speed forward motion turning 
define inhibit forward 
false robot looking motion 
define inhibit motion 
false turn requested higher levels 
moment set motor control unit initiate ballistic turn specified number degrees 
ignore input turn complete 
reset input completion turn 
turn specified corridor follower runs define turn request state variables 
number ticks wait turn finished 
define turn delay define box motor control outputs speed turn rate set 
speed speed control set 
turn rate turn controller define turn controller steer ballistic turn controller set 
turn request turn delay set turn rate 
define speed control set speed 
speed blind 
min speed request max center distance 
speed inhibit forward 
set 
speed inhibit motion 
set 
speed set speed 
speed speed define steer turn speed request inhibit motion 
camera current camera set 
turn eq 
open left 
open right 
follow corridor follow wall blocked 
set 
turn 
abs turn 
turn turn define ballistic turn controller 
turn delay turn delay turn delay set 
inhibit forward 
false inhibit motion 
current camera camera turn delay turn request turn 
turn request start ballistic turn 
define turn 
turn start open loop turn 
turn set 
turn request set 
turn delay degrees delay turn set 
inhibit forward 
true 
turn align corridor free space 
define follow corridor left badness max left distance right badness max right distance see corridor 
variance left badness right badness see corridor 
blocked vanishing point define follow wall open left 
right distance left distance define wedge counter define constant wedge time define box unwedger outputs turn blocked 
inhibit motion 
inhibit forward 
looking 
speed request wedge counter set 
wedge counter wedge time open left 
open right set 
turn open right 
open left set 
turn wedge counter set 
wedge counter wedge time set 
turn request turn odometry 
import odometer aligned 
define old ode define corridor counter define prev direction north define corridor time secs ticks direction perfect south 
define odometer offset define box odometry outputs direction direction corridor 
ew corridor 
ns corridor ask fep switch word base odometry reading 
write line rw update direction 
set 
direction direction set 
direction south quotient ash odometer odometer offset 
true time 
speed 
abs old ode odometer direction east set 
odometer offset odometer direction west set 
odometer offset odometer set 
old ode odometer true time direction south line south true time direction west line west true time direction north line north true time direction east line east re corridor district 
direction prev direction set 
corridor counter corridor time 
turn delay set 
corridor counter corridor time blocked 
speed corridor counter set 
prev direction direction set 
corridor 
corridor counter set 
ew corridor 
false set 
ns corridor 
false corridor 
set 
ew corridor 
direction set 
ns corridor 
direction stuff specific rwi base 
manually damp base control system 
define old speed define set speed 
speed don accelerate fast 

speed old speed set 
speed min speed old speed set 
old speed speed clock write line ta write line formatted tv min maximum speed abs speed write line 
speed speed th fast rotate 
causes set turn rate reset rotate acceleration 
define fast rotate 
true define set turn rate 
rate fast rotate 
set 
fast rotate 
false write line ra set 
turn rate ash turn rate write line formatted rv min maximum turn abs rate write line 
rate rate rh define start open loop turn 
turn write line formatted 
turn degrees encoder abs turn request write line ra write line rv set 
fast rotate 
true define box fep interface outputs odometer switches listen port 
info set 
info read port info low order bit set switch word 
set 
switches info odometer word 
set 
odometer info old value vector ref serial port global control 
serial port global control old value assemble nop nop nop nop 
serial port global control old value high level navigation place recognition lisp place memory frame system 
define constant square register data frame reduces effects random bits furniture placed large open spaces 
furniture world look extra turns 
define frame define match bits compare current sensory data frames 
define box frame matcher outputs current frame frame strobe re blocked obstacle 
blocked 
set 
frame frame frames frames points vector frames 
best frames pointer best frame far best value best score far frame set 
frame strobe 
false frame says matched frame 

frame try fix axes independently looking districts 
find districts compare frame 
countdown frame count match frame mini frame 
best value frame frame frame frame setf best frame setf best value setf frame shift frame image frame 
frame image frame length feature frame length match update outputs 

best value setf frame frame place size best setf frame strobe 
true setf current frame best setf frame best setf frame best set 
match bits feature bits match specific frame current sensory data 
define match frame mini image frame vars registers frame image frame image register address mini image sum bits changed 
feature bits match bits wall 
set 
bits changed 
true compute penalties estimated position direction motion 
delta frame frame delta frame frame incf sum abs delta vector ref direction 
delta incf sum abs delta vector ref direction 
delta large penalty getting direction wrong 
frame direction frame direction incf sum image frame comparison 
image frame 
frame loop compares image image frame mini image 
doesn support byte addressing image templates frames stored packed format bit pixels bit word 
shifting masking 
hardware looping pixels template words template 
countdown bytes register data compare word worth pixels 
incf sum square abs bytes xff image incf sum square abs ash bytes xff image incf sum square abs ash bytes xff image incf sum square abs ash bytes xff image feature frame comparison 
incf sum frame features frame feature bits bits changed 
sum check prove re particular part building knowing precise location 
define find districts stricter criterion turns don get doorways 
left turn 
left distance right turn 
right distance decide reached corridor 
aligned 
ns corridor 
wall 
direction north set 
direction south set 
re corridor see turn know side building re 
ew corridor 
dark floor aligned long time 
blocked direction west open right 
open left 
corridor 
set 
direction east open right 
open left 
set 
direction west open right 
open left 
set 
direction east open left 
open right 
set 
lisp define isn remotely corridor playroom 
gotten worked district recognition code 

direction north wall 
set 
navigator lisp simple algorithm navigating specified place 
define goal define goal define display packed goal string line goal display packed string define box navigator steer goal place frames tagged small turns executed veer delay ticks recognizing frame 
takes care embedded turn northern corridor near elevator lobby 
define constant veer delay secs ticks define check frame strobe 
rose fell veer delay ticks ago 
true time frame strobe veer delay turn 
set 
turn request frame veer current frame real meat navigator 
computes difference current coordinates goal coordinates axis opportunistically turns reduce difference 
define box steer goal update display 
hardware issue need true time switch 
true time switch 
sw navigation enabled true time switch 
sw clear line choose turns 

true time switch 
sw 
goal re start driving 
speed 
compute difference current desired positions 
decide turns useful 
delta goal time strobe true time frame strobe desired direction 
delta east west delta goal desired direction 
delta north south left direction direction right direction direction clear goal re 
delta delta set 
goal set 
goal speed 
tell unwedger turn 
unwedger activates executes turn turn 
delta blocked 
left direction desired direction set 
turn delta blocked 
right direction desired direction set 
turn delta blocked 
left direction desired direction set 
turn delta blocked 
right direction desired direction set 
turn turns 
turn 
delta ew corridor 
time strobe aligned long time 
direction desired direction open left 
open right set 
turn request delta ns corridor 
time strobe aligned long time 
direction desired direction open left 
open right set 
turn request turn intersection 
turns turn little bit early ll pointed far wall near 
time strobe frame left turn 
current frame delta left direction desired direction set 
turn request frame right turn 
current frame delta right direction desired direction set 
turn request frame left turn 
current frame delta left direction desired direction set 
turn request frame right turn 
current frame delta right direction desired direction set 
turn request wander lisp define global mode define constant wander mode define constant tour mode define constant offer mode drive loop lab 
endpoints determinate direction motion clockwise counterclockwise depends initial configuration robot 
define wander 
global mode turn 
place 
frame strobe 
direction west set 
turn request gotten vision lab go playroom 

set goal playroom gotten playroom go vision lab 

set goal vision lab giving tours sequencers lisp define run sequencers go home wander offer tour give tour leave office tour chatter enabled drives desk hallway 
define sequencer leave office import goal leave office blocked 
set 
global mode turn 
sleep open left 
goal align sleep turn 
sleep direction east blocked 
turn 
wait ew corridor 
sleep set 
set 
speed 
tries drive arbitrary place back desk 
define sequencer go home import 
give tour set 
global mode go home speed 
blocked 
turn 
speed 
sleep direction north blocked 
goal done set 
inhibit motion 
true say home speed 
offer tour person 
wave foot fire give tour 
define sequencer offer tour import set 
global mode set 
inhibit motion 
true done talking 
new say hello 
am polly 
tour 
wave foot sleep blocked 
person 


give tour new say ok nice day set 
global mode set 
inhibit motion 
false person gone 
set 
global mode set 
inhibit motion 
false coordinates place started tour 
get back safe 
define tour define tour give tour 
define sequencer give tour import new say ok please stand side set 
tour set 
tour set 
tour set 
tour blocked 
new say 
please follow set 
inhibit motion 
false set 
global mode wait frame strobe 
wait place 
tour tour sleep new say tour 
nice day set 
global mode interact lisp define constant hello interval secs ticks define hello counter define interact announce current place just reached new landmark 
frame strobe 
announce place go home switch thrown 
true time switch 
true time switch 
sw 
go home true time switch 
sw 
go home right list magic conditions holds offer tour 
person 
turn delay ew corridor 
blocked 
switch 
sw 
abs person direction global mode hello counter fire offer tour sequencer 

offer tour prevents repeated offering tours 
important back polly programmed say hello time saw person distance 
probably needed anymore 

hello counter hello counter active 
offer tour set 
hello counter hello interval put current place screen 
define announce place tour announce place display packed line frame name current frame send speech current place voice synthesizer provided re tour mode 
define tour announce place global mode tour mode set 
priority message frame speech current frame update lcd display position information 
define update display clear line 
feature bits left 
feature bits wall 
feature bits dark 
feature bits right display digit quotient display digit quotient display digit quotient goal display digit quotient goal voice chatter controls voice output 
takes inputs pointer unimportant chatter message priority message 
priority message sends voice synthesizer 
chatter message sends voice synthesizer 
silent 
priority message arrives middle saying chatter message chatter routine terminates chatter message says priority message restarts chatter message 
priority messages generated tour announce place landmark recognized tour mode 
chatter messages generated try chatter tour mode messages patrol mode 
list messages 
try chatter works order messages generates randomly rarely looking low order bits odometer 
implementation notes voice synthesizer driven fep 
escape code fep output stream causes subsequent bytes diverted base voice synthesizer 
cr output back base 
prevent large block speech output starving base chatter sends bytes clock tick 
feedback channel voice synthesizer robot doesn know speech done synthesizer input buffer full 
deal problem chatter waits saying messages 
length wait proportional length previous message 
save memory messages stored packed strings bit bytes bit word 
chatter lisp define priority message null vector define chatter message null vector define constant chattering define constant priority define talk state chattering define string position define chatter delay define box chatter outputs done talking check speaking inhibited previous utterance 
chatter delay 
chatter delay ok talk 
chattering priority message comes break chatter start priority message 
talk state chattering eq 
priority message null vector interrupt chatter move priority message 
set 
talk state priority set 
string position buffered write char char code buffered write char char code buffered write char char code return string talk state chattering chatter message priority message eq 
string null vector send 

string position vector length string say string done utterance set delay setup utterance 

string position vector length string set 
chatter delay vector length string set 
string position talk state chattering set 
chatter message null vector set 
priority message null vector set 
talk state chattering set 
done talking 
talk state chattering eq 
chatter message null vector define say string word vector ref string string position send fep escape code initiate voice output 
buffered write char char code send word worth bytes current speech 
buffered write char word xff buffered write char ash word xff buffered write char ash word xff buffered write char ash word xff update pointers 
string position vector length string buffered write char incf string position turn speech output 
buffered write char char code return define message counter define messages rand ash odometer yow external 
yow keep talking base connected 
odometer odometer offset eq 
chatter message null vector global mode 
rand vector length yow message counter message counter set 
message counter set 
chatter message vector ref yow rand define constant tour chatter delay secs ticks define tc index define tc delay tour chatter delay define tour chatter global mode try chatter set 
tc index define try chatter tc delay tm external 
tour messages done talking 
tc delay 
tc index vector length tm set 
chatter message vector ref tm tc index set 
tc delay tour chatter delay incf tc index lisp file creates separate loader segment polly phrases 
phrases stored packed strings 
eval load toplevel compile toplevel execute define assembler symbol name address start packed string string 
defmacro define phrase name string code string converts string packed string list bit integers 
code code string string name polly code name rest code define assembler symbol name points vector pointers packed strings defmacro define phrases name rest phrases code list length phrases name phrase phrases sym gensym code string phrase setf code list sym rest code word sym name polly code messages randomly generated messages chatter lisp robot patrol mode 
note misspellings deliberate re needed fool voice synthesizer saying right phonemes 
define phrases yow 
having fun 
full 
think ought know feeling depressed 
terrible pain left side 
playroom full purple jello people 
help having zen experience 

think experiencing natural stupidity 
buy scratched 
hey buddy spare change messages generated order chatter tours 
define phrases tour messages avoid obstacles follow corridors recognize places navigate point point 
vision system runs frames second low cost computer 
way don understand saying 
god place dump bibliography philip agre ian horswill 
cultural support improvisation 
tenth national conference artificial intelligence cambridge ma 
american artificial intelligence mit press 
philip agre 
dynamic structure everyday life 
technical report massachusetts institute technology artificial intelligence lab october 
philip agre david chapman 
pengi implementation theory activity 
proceedings sixth national conference artificial intelligence pages 
john aloimonos 
purposive qualitative active vision 
darpa image understanding workshop 
aloimonos rosenfeld 
computer vision 
science september 
ronald arkin 
motor schema navigation mobile robot 
ieee internation conference robotics automation pages 
ieee march 
ayache faugeras 
maintaining representations environment mobile robot 
ieee transactions robotics automation 
bajcsy 
active perception vs passive perception 
proc 
third ieee workshop computer vision representation control pages 
ieee october 
dana ballard 
animate vision 
artificial intelligence 
chandra ballard 
egomotion active vision 
proceedings cvpr ieee computer society conference computer vision pattern recognition miami beach fl june ieee publ ch pages 
ieee 
stephen barnard martin fischler 
computational biological models stereo vision 
proc 
darpa image understanding workshop september 
avron barr edward feigenbaum 
handbook artificial intelligence 
william kaufmann 
fred bauer john 
ordinary differential equations course 
benjamin new york 
king beach 
role external memory cues directed educational activity 
journal applied cognitive psychology 
randall beer 
dynamical systems perspective autonomous agents 
ces case western reserve university cleveland ohio 
verri torre 
navigation tracking vanishing points 
aaai spring symposium robot navigation pages stanford university march 
aaai 
andrew blake alan yuille editors 
active vision 
mit press cambridge ma 
david 
marvel system recognizing world locations stereo vision 
technical report mit artificial intelligence laboratory 
bresina drummond 
integrating planning reaction 
hendler editor aaai spring symposium planning uncertain unpredictable changing environments 
aaai march 
rodney brooks 
robust layered control system mobile robot 
ieee journal robotics march 
rodney brooks 
behavior language user guide 
ai lab memo apr 
christopher brown david coombs john 
real time smooth pursuit tracking 
blake yuille pages 
david chapman 
planning conjunctive goals 
artificial intelligence 
david chapman 
intermediate vision architecture implementation 
tr research 
david chapman 
vision instruction action 
technical report massachusetts institute technology artificial intelligence lab april 
david chapman 
vision instruction action 
mit press 
noam chomsky 
aspects theory syntax 
mit pres cambridge ma 
jonathan connell 
minimalist mobile robotics 
academic press 
david coombs karen roberts 
bee bot peripheral optical flow avoid obstacles 
proc 
spie conf 
intelligent robots computer vision xi algorithms techniques active vision boston ma november 
jill 
color region tracking vehicle guidance 
blake yuille chapter 
james cutting 
perception eye motion 
mit press 
darpa 
proceedings darpa image understanding workshop washington 
morgan kaufman 
dementhon 
zero bank algorithm inverse perspective road single image 
ieee internation conference robotics automation pages 
ieee march 
ernst dickmanns 
expectation dynamic scene understanding 
blake yuille chapter 
michael dixon 
embedded computation semantics programs 
tr ssl xerox palo alto research center palo alto ca september 
bruce randall donald james jennings 
constructive recognizability task directed robot programming 
robotics autonomous systems 
sean engelson drew mcdermott 
image signatures place recognition map construction 
proceedings spie symposium intelligent robotic systems sensor fusion iv november 
jerome feldman 
frames suffice model vision space 
tr computer science department university rochester rochester ny september 
margaret fleck 
boundaries topological algorithms 
tr mit artificial intelligence laboratory cambridge ma 
erann gat 
integrating planning reacting heterogeneous asynchronous architecture controlling real world mobile robots 
proceedings aaai 
gibson 
senses considered perceptual systems 
houghton mifflin boston 
gibson 
ecological approach perception 
houghton mifflin boston 
richard hamming 
coding information theory 
prentice hall englewood cliffs 
kristian hammond timothy converse 
stabilizing environments facilitate planning activity engineering argument 
ninth national conference artificial intelligence pages menlo park ca july 
american association artificial intelligence aaai press 
john hopcroft jeffrey ullman 
automata theory languages computation 
addison wesley 
horn 
robot vision 
mit press 
ian horswill 
programmer manual 
unpublished technical note mit artificial intelligence laboratory 
ian horswill 
hack 
unpublished technical note mit artificial intelligence laboratory march 
ian horswill 
proximity detection spatial filter tuned space 
proceedings aaai fall symposium sensory aspects robotic intelligence 
ian horswill 
specialization perceptual processes 
phd thesis massachusetts institute technology cambridge may 
ian horswill rodney brooks 
situated vision dynamic environment chasing objects 
proceedings seventh national conference artificial intelligence august 
ian horswill 
reactive navigation mobile robots 
master thesis massachusetts institute technology june 
ikeuchi martial herbert 
task oriented vision 
darpa image understanding workshop 
khatib 
real time obstacle avoidance manipulators mobile robots 
international journal robotics research 
craig knoblock josh tenenberg qiang yang 
spectrum abstraction hierarchies planning 
proceedings aaai 
david 
applying computational theories cognitive mapping mobile robots 
marc slack erann gat editors working notes aaai spring symposium control selective perception pages 
aaai cambridge massachusetts 
kak 
fast vision guided mobile robot navigation model reasoning prediction uncertainties 
computer vision graphics image processing september 

control discrete event systems 
grasp lab report university pennsylvania computer information science department philadelphia pa april 
david kriegman ernst 
stereo vision navigation buildings 
ieee internation conference robotics automation pages 
ieee march 
david kriegman ernst tomas binford 
mobile robot sensing planning locomotion 
ieee internation conference robotics automation pages 
ieee march 
benjamin kuipers yung tai byun 
robust qualitative approach spatial learning mobile robot 
spie advances intelligent robotics systems november 
jean claude latombe 
robot motion planning 
kluwer academic publishers boston 
hector levesque ronald brachman 
fundamental tradeoff knowledge representation reasoning revised edition 
ronald brachman hector levesque editors readings knowledge representation pages 
morgan kaufman los altos ca 
michael littman 
optimization categorization reinforcement learning environments 
meyer wilson pages 
david luenberger 
dynamic systems theory models applications 
john wiley sons 
kevin lynch 
image city 
mit press 
lyons hendriks 
exploiting patterns interaction achieve reactive behavior 
submission 
david marr 
vision 
freeman 
maja mataric 
minimizing complexity controlling collection mobile robots 
ieee international conference robotics automation pages nice france may 
david mcfarland 
means robot behavior adaptive 
meyer wilson pages 
jean meyer 
simulation adaptive behavior animats review prospect 
meyer wilson pages 
jean meyer stewart wilson editors 
animals animats proceedings international conference simulation adaptive behavior 
mit press cambridge massachusetts 
jean meyer stewart wilson editors 
animals animats second international conference simulation adaptive behavior 
mit press cambridge massachusetts 
hans moravec 
stanford cart cmu rover 
technical report robotics institute carnegie mellon university february 
randal nelson 
visual homing associative memory 
proceedings darpa image understanding workshop pages 
ed 
nils nilsson 
shakey robot 
technical report sri international april 
keith nishihara 
minimal meaningful measurement tools 
tr research 
patton nwana shave bench capon 
computing tissue organ level particular liver 
varela bourgine pages 
roger penrose 
emperor new mind 
oxford university press 
poggio torre 
ill posed problems regularization analysis early vision 
lee baumann editor image understanding workshop new orleans la october pages 
defense advanced research projects agency science applications international 
dean pomerleau 
efficient training artificial neural networks autonomous navigation 
neural computation 
louise pryor gregg collins 
planning perceive utilitarian approach 
simmons pages 
douglas steven shafer 
active vision system level robot driving 
simmons pages 
daniel reisfeld haim wolfson yeshurun 
detection interest points symmetry 
proceedings third international conference computer vision pages osaka japan december 
ieee computer society 
herbert roitblat 
comparitive cognition 
freeman 
stanley rosenschein 
formal theories knowledge ai robotics 
report csli center study language information stanford ca 
stanley rosenschein 
synthesizing information tracking automata environment descriptions 
ronald brachman hector levesque raymond reiter editors proceedings international conference principles knowledge representation reasoning pages may 
stanley rosenschein leslie pack kaelbling 
synthesis machines provable epistemic properties 
joseph halpern editor proc 
conf 
theoretical aspects reasoning knowledge pages 
morgan kaufmann 
earl sacerdoti 
planning hierarchy abstraction spaces 
artificial intelligence 
roger schank 
tell story 
charles sons 
reid simmons editor 
working notes aaai spring symposium control selective perception stanford california 
american association artificial intelligence 
herbert simon 
sciences artificial 
mit press cambridge massachusetts 
lee spector james hendler 
architecture 
avi kak editor working notes aaai fall symposium sensory aspects robotic intelligence pages 
aaai press asilomar california 

early detection motion boundaries 
technical report mit artificial intelligence laboratory 
mallot von seelen 
visual obstacle detection automatically guided vehicles 
proceedings ieee international conference robotics automation pages may 
michael swain 
color indexing 
technical report university rochester computer science department november 
michael swain 
active visual routines 
simmons pages 
thompson kearney 
inexact vision 
workshop motion representation analysis 
thompson 
dynamic occlusion analysis optical flow fields 
ieee transactions pattern analysis machine intelligence 
thorpe 
fido vision navigation robot rover 
phd thesis department computer science carnegie mellon university december 
look bayes net tea system directions 
raymond rimey 
simmons pages 
peter todd stewart wilson 
environment structure adaptive behavior ground 
meyer wilson pages 
peng seng toh andrew forrest 
occlusion detection early vision 
proceedings international conference computer vision 
john tsotsos 
analyzing vision complexity level 
behavioral brain sciences 
matthew turk david keith gremban martin 
video road autonomous land vehicle 
ieee internation conference robotics automation pages 
ieee march 
shimon ullman 
visual routines 
cognition 
varela bourgine editors 
practice autonomous systems proceedings european conference artificial life 
mit press cambridge ma 
wallace 
robot road adaptive color classification shape tracking 
ieee internation conference robotics automation pages 
ieee march 
wallace goto webb kanade 
progress robot road 
ieee internation conference robotics automation pages april 
wallace thorpe moravec whittaker kanade 
results robot road 
ijcai 
waxman srinivasan 
visual navigation 
ieee internation conference robotics automation april 
norbert wiener 
cybernetics 
mit press cambridge 
stewart wilson 
animat path ai 
meyer wilson pages 
lambert wixson 
detecting occluding edges computing dense correspondence 
iu pages 
john woodfill ramin zabih 
motion vision simple robotic task 
aaai fall symposium sensory aspects robotic intelligence 
