adaptive java optimisation instance learning describes portable machine learning approach java optimisation 
approach uses instancebased learning scheme select transformations drawn pugh unified transformation framework 
approach implemented applied number numerical java benchmarks platforms 
scheme able gain performance improvement exhaustive iterative search best compiler optimisations 
scheme gives high level portable performance excessive compilations 
general terms languages performance categories subject descriptors programming languages processors compilers optimisations artificial intelligence learning keywords java optimisation space adaptive optimisation instancebased learning 
demand greater performance led exponential growth hardware performance architecture evolution 
rapid rate architectural change placed enormous stress optimising compiler technology 
traditional approaches compiler optimisations hardwired static analysis transformation longer computing environment continually changing 
required ap permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
ics june july malo france copyright acm 
shun long michael boyle institute computing systems architecture university edinburgh edinburgh uk shun long ed ac uk mob inf ed ac uk proach evolves adapts applications architectural change sacrificing performance 
describes machine learning approach java optimisation utilises prior knowledge successful optimisation 
java highly portable language cost poor performance 
approach automatically builds optimisation strategy platform specific experience compiler framework allows portable performance 
feedback directed iterative compilation approaches require multiple compilations runs particular program order find best optimisation 
record execution time behaviour program respect selected transformations executed 
information accumulated time knowledge programs transformations particular platform interact grows allowing compiler strategy adapts improves time 
approach uses instance learning pugh unified transformation framework 
framework provides systematic description large optimisation space includes loop array transformations 
scheme able gain performance improvement exhaustive feedback directed search iterative compilation 
scheme gives high level portable performance excessive compilations 
outline follows 
section provides motivating example section describes features learning technique 
section presents instancebased learning optimisation approach 
section evaluates performance approach followed review related section concluding remarks 

motivation example basic idea decision optimise particular program previous experience 
time program optimised transformations applied resulting performance stored description program 
encountering new program optimise database previous cases searched similar programs 
transformations beneficial similar programs considered current program hand 
idea long static compilation analysis usually examines key features program see fits model optimisation known 
illustrate consider highly simplified example features features false true transformation reversal transformation skewing speedup speedup transformation statement reordering transformation tiling div div div div speedup speedup features features false true transformation reversal speedup transformation distribution speedup shows programs program features 
features loop nest depth number arrays number array number statements containing dependencies 
transformations applied speedup obtained shown compiler determine transformation apply shown 
main boxes show code details simple loops executed system performance noted different transformations 
information question transform program 
determine program similar program small list features summarising key characteristics 
example just features shown loop simplify explanation loop nest depth number distinct arrays number array number statements flag denoting flow dependencies 
comparisons loops matches just feature statements loop bodies 
statements loop bodies 
addition double nested loops 
deciding matches feature true exists flow dependencies statements corresponding loops whilst matches feature contains array loop body 
flow dependency feature considered important assign greater weight 
considered similar program 
consider transformations applied resulting speedup 
details transformation representation section 
transformation skewing speedup slowdown second transformation tiling speedup 
apply tiling transformation highly simplified example program segments just simple loops 
approach readily applied general programs sets transformations 
key characteristic approach optimisation decisions real platform performance static model compiler heuristic 
furthermore number programs encountered increases database examples improving performance scheme 
main technical questions describe program manner useful optimisation determine program similar appropriate transformation selected 
addressed sections 

features learning compiler correlate programs optimisations applied resulting performance improvement systematic manner 
machine learning terms inputs features problem description program transformation output execution time 
problem features formally specified allow application instance learning 
features reveal important details program help compiler classify retrieval shown 
program features suitable program abstraction depends circumstances 
call graphs instance may appropriate inlining optimisation 
focus java applications sense concentrate loop array structure program 
consider abridged set features listed 

memory access number array number arrays linear array access array elements reuses iteration uniform data dependency 
loop structure loop nest depth loop size inner perfectly nested loop loop step 
code abnormal exit number arithmetic operations number method calls conditional control structure loop number statements loop nest features readily obtained program representation pugh unified transformation framework described compiler internal representations program 
compiler automatically extracts features java program 
transformations pugh unified transformation framework utf provides uniform systematic representation iteration reordering transformations arbitrary combinations 
encompasses nearly high level iteration reordering transformations literature state art commercial compilers 
importantly formal mechanism represent reason transformation arbitrary combinations dataflow optimisation included 
utf considers statement iteration space set iterations statement executed 
points space executed lexicographic order 
loop reordering transformation transformation sequence considered mapping old iteration space new 
statement nested loop mapping expressed im fn im iteration variables fn functions usually quasi affine functions iteration variables optional restriction 
represents fact condition true iteration im original iteration space mapped iteration fn new iteration space 
specifically mapping loop components quasi affine functions iteration variables odd numbered levels syntactic components integer constants program loop distribution numbered levels 
example consider program 
second transformation form mappings represents happens statements transformation respect iterators integer entries right hand side represent syntactic structure transformation 
differ entry vs means share outer iterators loop distributed shown 
details notation please see 
variety mapping notation results optimisation space point stands arbitrary combination iteration reordering transformations unified manner 
space significant large contain useful minima points 
learning compiler explore space search best points 
program features transformation representation provide formal succinct method describing task program optimisation terms suitable general machine learning 
section describes representation 

instance learning iblo instance learning models complex target function collection complex approximations 
learning compiler case new program encountered instance learning optimisation iblo approach identifies programs closest previous evaluations 
selects suitable transformation prior information applying new program 
main tasks iblo classification knowledge storage transformation selection 
classification classification record information program means detect similar previous cases trying optimise current program 
observation programs sharing common characteristics usually benefit transformation 
iblo defines similarity program category equation 
similarity wi match fi fi number program features wi weights assigned features fi fi values feature fi respectively 
match equals 
similarity wi belongs category similar clearly higher value similarity similar vice versa 
example consider code segments equal weight features similarity similarity conclude similar program features true similarity belong category 
similarity programs categories defined similar manner 
knowledge storage category compiler records transformations applied program category results 
grouped areas similarities 
instance loop unrolling transformations differing unrolling factor naturally grouped 
area stores information specific transformation transformation sequence 
example area created loop tiling loop unrolling transformation sequence tiling unrolling 
point area stands transformation transformation sequence program category set parameters corresponding runtime feedback 
compiler database currently implemented hash table enables quick program comparison low overhead 
space utilisation premium fixed number positive transformations bring performance improvement stored 
category created stored compiler encountered candidate programs applies areas category 
worth noting maximum number categories depends number program features values number training examples 
storage approach simple efficient 
provides fast low overhead classification hash function program features 
approach improved storing information selectively merging similar categories storing model built training examples necessary deleting useful information periodically 
amount data grow excessively may need replaced sophisticated data management mechanism scope 
transformation selection order select appropriate transformation new program iblo locates category belongs similar classification mechanism 
exists category transformation chosen directly prior experience programs iblo find similar categories base decision 
category probability transformation provides performance improvement program considered function defined optimisation space 
nearest neighbour algorithm point space performance improvement determined neighbouring points 
majority improve performance statistically transformation point represents bring performance improvement 
crowded area point transformation stands improve performance program category 
different transformations different performance impact different programs significance area simply defined xi consists set transformation points xm performance improvement point 
cases category chosen program virtual category constructed areas obtained merging corresponding areas categories 
example new program iblo finds similar categories areas areas virtual category constructed areas iblo selects transformation chosen category dividing area evenly number sub areas order find crowded sub area 
repeated densest sub area contains small number points transformation selected randomly 
heuristic random selection prevents overfitting optimisation space 
demonstrates algorithm works 
suppose program algorithm locates similar program category crowded area dimensional area corresponding schedules tiling double nested loop various tile size combinations 
divided evenly subareas point respectively shown left 
crowded subarea chosen division result shown right 
resulting subareas contain points respectively 
division needed subarea contains small number points 
crowded algorithm randomly selects points uses corresponding tiling schedule schedule strategy order optimise new program effectively sufficient prior knowledge previous optimisations base judgment 
ways achieved 
reasonable approach initially allow existing high level optimise new program record behaviour 
suitable number cases optimised learning approach applied 
advantage existing approach reasonable time wasted selecting transformations incur significant slowdown 
main problem approach wide range different programs encountered transformation selection hard wired preventing large dataset evaluate transformation behaviour 
example transformation selection algorithm area left evenly divided subareas crowded 
divided subareas transformation chosen crowded 
alternative approach try transformations set suitably chosen programs training examples 
transformations selected randomly range competing pre existing analyses 
benefit exploring program transformation space expense potentially worthless optimisations 
training examples suitably short execution time learning phase considered part porting system cost 
adopt scheme iblo continuous process allows adaptation system upgrade 
initial training phase various transformations randomly selected applied set programs results training examples 
new program encountered transformation selected applied result new training example 
discussion worth noting trained iblo easy quick 
simply extracts program features program comparisons locate best category constant time needed hash table splits target area rounds selecting transformation crowded area 
iblo automatically adapt new machine apply heuristics learned machine optimising 
allow need introduce set features sufficiently characterise architecture 
iblo trained applies learned heuristic program encountered update heuristic training completed 
transformations new program selected prior examples initial phase utilise information programs encountered training 
instance iblo learned combined transformation loop tiling unrolling training phase provide transformation afterward 
set available transformations remains intact set program categories may keep increasing 
drawback iblo amended hybrid approach integrates iblo heuristic random search program kernel livermore kernel livermore kernel livermore kernel livermore kernel livermore kernel livermore kernel livermore kernel livermore kernel livermore kernel livermore euler 
euler 
rung euler 
euler 
runs euler 
mm matrix multiplication kernel livermore summary benchmarks compiler consider transformation chosen iblo variants different parameters additional transformations 

evaluation learning technique described implemented java restructuring compiler evaluated separate platforms range benchmarks 
experimental method results platform described 
method platform contains celeron processor mhz ram java runtime environment java hotspot client vm running redhat linux 
second platform java runtime environment java hotspot client vm contains mhz ram running ms windows 
sixteen methods chosen known livermore benchmark java grande forum benchmark suite evaluation 
summarised 
experiments conducted sixteen benchmarks cross validation manner typical method evaluating machine learning approaches 
means benchmark system previously seen optimised fifteen benchmarks act training examples 
mimics behaviour live system optimisation previous experience 
initially training examples classified different categories 
summarises resulting categories similarities 
considering program optimised category belongs contains programs iblo simply chooses starting point selecting appropriate transformation 
iblo chooses source transformation benchmarks selected similar categories benefited previous optimisations 
example wish optimise kernel belongs category contains program kernel category programs included similar categories kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel rung runs mm categories benchmarks similar categories program transformation source kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel rung kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel rung runs rung runs runs rung mm rung runs benchmarks transformation sources transformation kernel kernel 
optimising kernel category program category select programs categories kernel kernel kernel 

summarises transformation sources sixteen benchmarks cross validation experiment 
programs selected suitable candidates base optimisation transformation selected described section 
experiment training examples previously optimised executed times simple search strategy resulting speedups recorded 
transformation selected area transformation space giving best prior performance 
linux experimental results linux platform shown 
average column shows speedup obtained average iblo case speedup final selection transformation stochastic average behaviour program iblo search best average sd best kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel rung runs mm average comparison heuristic search learning linux shows average performance improvement iterative search obtained iblo just attempt 
achieved 
small standard deviation performance shown sd column demonstrates learning technique selects optimisation prior knowledge capable delivering consistent performance improvement 
benchmarks iblo fails provide significant performance improvement instance kernel kernel kernel kernel 
higher performance available shown best column 
example kernel modest average performance improvement iblo select transformation double performance 
wish compare performance iblo approaches 
commercially available java compare algorithm extensive iterative search optimisation space simple search strategy 
strategy selects transformation random manner favouring simple short transformation complex longer ones 
gives excellent performance cost potentially compile run cycles making prohibitively expensive 
compiler approach performance extensive scheme rigorous test approach 
results search column labelled search best best speedup evaluations 
results show cases iblo capable achieving performance exhaustive search just compilation 
average search technique gives speedup iblo 
properly trained iblo capable achieving performance extensive search just compilation 
furthermore examine best performance iblo average see outperform search approach cases 
linux iblo achieves similar results heuristic search algorithm windows experimental results windows show iblo able find performance improvement majority cases 
linux cases iblo unable average find improvement best transformation fails improve kernel rung runs 
examine exhaustive search performance see unable find significant improvement majority cases 
iblo fails provide significant improvement cases available 
results show cases iblo capable achieving performance exhaustive search just compilation 
finds available performance 
comparison linux windows iblo achieves average speedup linux windows 
cases significant difference performance obtained 
case kernel example difference vs 
iblo achieves significantly higher speedup kernel kernel kernel windows linux 
remaining kernel kernel kernel mm average speedup higher linux windows 
believe difference performance improvement platforms mainly due relatively cost memory latency linux greater benefit cache restructuring optimisations 
average performance improvements remarkably similar show general robustness technique 
show properly trained iblo able deliver significant improvement relative exhaustive search just compilation 
program iblo search best average sd best kernel kernel kernel kernel kernel kernel kernel kernel kernel kernel rung runs mm average comparison heuristic search learning windows shows average performance improvement iterative search obtained iblo just attempt 

related number isolated attempts employing machine learning compiler research 
aim solving specific optimisation problems steering optimising compiler system level 
vary cost efficiency 
greedy local instruction scheduling approach iteratively selects best instruction available 
task considered supervised process learning preference relations triples partial schedules 
number classic machine learning approaches applied 
achieves results relies hand coding processor specific features port platforms 
avoids difficult cyclic code structures improve performance time 
simple learning scheme determine unrolling useful transformation loop 
general loops considered approach effectively models decisions linear hyperplanes transformations space 
training cases sharing common characteristics grouped classes 
class labelled positive unrolling improves performance majority class negative 
way learning task cast building decision tree leaf represents unrolling heuristic corresponding test values loop features 
approach main drawback works simple single transformations polynomial behaviour may fail complex coupled spaces 
digital signal processing transforms represented matrices 
different matrices vary significantly runtime performance 
represented split trees spiral explores factorisation space walsh hadamard transform stochastic evolutionary algorithm 
reinforce iblo achieves similar results heuristic windows ment learning learn construct fast formulae data sizes training data size 
achievement comes cost checking large number formulae applicability confirmed dsp transforms 
genetic algorithm stochastic approaches known effective machine learning approaches 
instance tries solve phase order problem selecting transformations pool applying global manner 
selection steered adaptive genetic algorithm uses probabilistic model built runtime feedback 
genetic programming particular form genetic algorithm optimise priority functions compiler uses decide best optimisation heuristics 
example genetic algorithms case instruction scheduling 
list scheduling approaches assign node weighted sum key parameters priority 
parameters genetic algorithm search optimal weight combination scheduler architecture pair 
results show genetic algorithm bring adaptability instruction scheduler 
case reasoning complement existing compilers automatic help users performance tuning process 
similar spirit iblo uses set code properties indices loop structure code patterns order identify potential optimisation opportunities 
iblo fully automatic 
compiler writer needs specify advance transformations conditions applied 
addition new knowledge obtained runtime feedback 
area machine learning reinforcement learning adaptively optimise performance conventional garbage collection techniques memory allocation information running application 
closely related learning best optimisation task searching best 
iterative compilation compiler tries optimise program repeatedly executing different versions feedback decide optimisation attempt 
various approaches developed explore different optimisation spaces instance genetic algorithm tree grid search exhaustive search random search approaches vary efficiency require hundreds iterations gain significant performance improvement 
compiler framework program information collected stored unified low level typed representation order enable life long code optimisation 
machine learning approach described naturally fit scheme 
java optimisation achieved efficient virtual machine optimisation techniques parallelisation 
virtual machine approach inevitably architecture specific parallelisation approach relies architectural support whilst jit compilation considers light weighted optimisations 

described machine learning approach optimising java programs 
shown instance learning viable automatic approach building optimising strategy 
inherently portable adapting platform actual machine performance static analysis 
shown properly trained modest fixed training cost approach achieve performance available aggressive exhaustive search approaches 
due program features high level transformations considered utf iblo restricted loop array intensive java programs 
help powerful compiler framework enhancements discussed believed applicable generic programs 
furthermore experience accumulated training period believed able optimise difficult real world applications time 
investigate optimisations outside utf framework consider general java programs 
program architecture features included examine iblo applicability various platforms 
order put iblo practice shall consider training example selection order balance tradeoff training set size efficiency iblo 
examine machine learning approaches gaussian process prediction alternative means predicting performance 

adl tabatabai cierniak parikh 
fast effective code generation just time java compiler 
acm sigplan conference programming language design implementation pldi 
alpern cocchi lieber mergen sarkar 
jalapeno compiler supported java virtual machine servers 
workshop compiler support software system 
hoffman lindholm 
collect collect 
machine learning memory management 
nd java virtual machine research technology symposium jvm 

genetic algorithm fine tune instruction scheduling heuristics 
international conference massively parallel computer systems 
bik gannon 
prototype java reconstructing compiler 
concurrency practice experience 

bull smith davey 
benchmark suite high performance java 
concurrency practice experience 
cooper subramanian torczon 
adaptive optimizing compilers st century 
journal supercomputing 
davis 
handbook genetic algorithm 
van nostrand 
boyle 
evaluating iterative compilation 
th workshop languages compilers parallel computers 
java grande forum 
making java high computing 
sc high performance networking computing 
kelly pugh 
framework unifying reordering transformations 
technical report university maryland cs tr 
boyle 
combined selection tile sizes unroll factors iterative compilation 
international conference parallel architecture compilation techniques pact 
lattner adve 
llvm compilation framework lifelong program analysis transformation 
international symposium code generation optimisation 
long boyle 
adaptive java optimising compiler empirical evaluation program transformations 
rd workshop java high performance computing 
long 
adaptive java optimisation machine learning techniques 
phd thesis school informatics university edinburgh 


computer aided hand tuning applying case reasoning performance tuning 
th acm international conference supercomputing ics 

machine learning approach automatic production compiler heuristics 
th international conference artificial intelligence methodology systems applications 
mitchell 
machine learning 
mcgraw hill 
moss utgoff precup brodley 
learning schedule straight line code 
neural information processing systems 

gaps iterative feedback directed parallelisation genetic algorithms 
nd acm international conference supercomputing ics 
boyle 
feedback directed iterative compilation 
th workshop languages compilers parallel computing 
shirazi 
java performance tuning 
reilly 
singer veloso 
learning generate fast signal processing implementations 
international conference machine learning icml 
singer veloso 
stochastic search signal processing algorithm optimization 
scientific computing sc 
stephenson reilly martin amarasinghe 
genetic programming applied compiler heuristic optimisation 
th european conference genetic programming 
stephenson amarasinghe martin reilly 
meta optimisation improving compiler heuristics machine learning 
acm sigplan conference programming language design implementation pldi 
