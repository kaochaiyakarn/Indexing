distributed trees peer peer systems chi zhang arvind krishnamurthy randolph wang increasing demand locality preserving distribution complex data structures peer peer systems 
current systems preserve object locality suffer imbalances data distribution routing state query processing costs 
position take systematic approach enables deployment searchable tree structures environments 
achieve distributed tree traversal efficient routing distance routing state 
show implement applications distributed tree structures 
years group distributed hash table dht peer peer infrastructures exemplified chord pastry tapestry received extensive attention 
systems provide attractive properties including scalability fault tolerance network proximity 
number applications built dhts distributed file systems application level multicast 
original dht schemes provide searching hashed key space sufficient support applications complex data structure semantics 
support applications specific schemes proposed enhance dhts 
example space filling curves prefix hash tree support range queries approaches specific target problems 
applications clear distribute existing data structures destroying intrinsic locality critical performance 
propose general paradigm distributing searching tree data structures peerto peer environments preserving data locality 
princeton university cs princeton edu 
yale university arvind cs yale edu 
locality sensitive applications target data intensive applications benefit locality preserving distributions manners 
hand target applications require support queries complex exact lookups flat name space 
applications data typically organized hierarchical search trees enable perform similarity queries updates 
hand target applications locality preserving data organization critical performance issue 
applications exhibit strong correlation data accesses 
example file system users frequently access small set files directories 
logical structure tree hierarchy representation access locality applications 
centralized systems benefit access locality data structure laid appropriately secondary storage 
distributed peer topeer system high communication costs thought analogous storage access latency throughput limits centralized systems locality preserving distributions essential 
issues lead question implement hierarchical tree data structures peer peer computing platforms preserving locality 
challenges peer peer systems common requirements scalable peer state efficient routing peer peer searchable tree faces problems tree lookups trees search key tree path 
general cases path id destination node known priori discovered top tree lookup data key 
high network communication costs efficient lookup demands high locality mapping nearby tree nodes minimal rout ing steps nodes apart 
systems dhts distribute individual tree nodes possibly hashing node unique key 
search trees dht lookup needed tree edge starting root resulting lookup costs high log log log log structures balanced depth 
process inefficient tree long branches 
root tends bottleneck single point failure 
skewed data load balancing dhts depend hashing ensure uniform distribution data participating processors 
hashing destroys data locality suitable application settings 
data keys suffers skewed data distribution 
systems sampling techniques achieve asymptotic load balance :10.1.1.4.8363
case dynamic load changes reactive load balancing schemes desirable :10.1.1.102.473
tree maintenance practical tree structures dynamic subject online insertion deletion structural changes 
maintenance easy centralized settings affect nodes distributed tree 
example distributed tree replicates internal nodes improve search efficiency 
optimization requires system perform tree updates consistent manner requiring complex protocols maintaining tree consistency 
propose distributed tree scheme called 
solve problems partition tree preserving locality load balance search partitioned tree efficiently peer peer systems 
design solution linearization tree 
upper half illustrates file system tree 
directories drawn circles 
edges labeled names represent directory entries 
linearize tree nodes pre order traversal partition segments shown dotted vertical bars 
partitioning method preserves locality low level subtrees split 
partitions assigned processors shown rectangles tree 
word processor denote peer peer nodes order avoid confusion tree nodes 
processor identified left boundary left tree node partition 
path name inside bin bin home usr ls vi bin src bin home home home usr www home usr usr usr src home bin src usr partitioning distribution file tree 
processor box shows left boundary partition 
ensure system scalability limit knowledge individual processors tree peers 
processor knows log peers partition boundaries processor system 
tree lookup done log steps regardless shape tree 
extend skip graphs nets achieve efficient lookup 
conceptually processor skip graph maintains log levels peer pointers pointing exponentially farther peers linear ordering processors 
arrows processor boxes depict levels peer pointers processors 
processors construct local partial view tree boundaries peers 
show partial view respectively 
show perform object location distributed tree illustrating lookup file bin processor uses partial view find peer farthest direction target pre order linearization tree nodes passing target 
example determines target left peer boundary home forwards request turn uses partial tree view determines peer closest target peer left boundary bin 
forwards request tree lookup performed starting processor jumping processors hop reducing distance target traversing tree path root target 
number hops logarithmic number processors regardless tree depth 
generally application tree provides pieces information enable distributed lookup target key label ledge tree edge 
total order labels edges node example dictionary order entry names 
comparison function tree node 
function compares target key label edge node telling matches edge falls left right 
node identifies partition sequence ledge values root left boundary node 
define sequence tree id id sent peers partial tree view constructed 
nature target key ledge values specific application 
example file system tree target keys directory paths ledge string simply string comparison 
general trees target specified explicitly tree path 
example high dimensional index tree see section tree node corresponds region space target key simply point coordinate range encapsulates information regarding split plane decide branch follow 
certain operations range query high dimensional space section target objects located generalization process 
querying node may find target range relevant branch forward request multiple peers simultaneously resulting multicast query 
maintaining partitioned tree scheme quite simple 
insertion deletion branch affects processor boundaries enclose target branch 
instance insertion home affects processor optimizations possible distributed tree 
provides data redundancy allowing neighboring processors maintain overlapping partitions 
added availability improves locality partitions cover larger subtrees 
table mechanism skip nets provides routing similar pastry 
enhanced proximity aware load balancing section 
choice routing substrate tree routing depends linear ordering partitions 
sense linear space dht routing ity 
choose skip graphs reasons 
skip graphs impose constraints nature structure keys 
complex keys variable length tree ids long total ordering 
second encode tree nodes key values skewed keys cause routing imbalance dhts key values decide peering relation 
skip graphs suffer problem peering decided purely random membership vectors keys 
max node degree chord chord skip graphs number nodes max mean routing load chord skip graphs number nodes max node degree max mean routing load imbalance skewed key distribution simulated chord skip graphs skewed key distribution show imbalance routing 
depicts maximal processor degrees chord skip graphs processors 
processor keys derived normal distribution standard deviation range 
keys chord processors falling sparsely populated regions manage larger portions keyspace large number bound peers 
furthermore imbalance peer distribution leads imbalance routing costs 
route messages random pairs nodes 
shows imbalance ratio maximal routing load mean load 
load balancing balancing assignment tree nodes processors important issue distribution items tree skewed change time 
propose dynamic load balancing scheme augments previous :10.1.1.102.473
processor maintains load information nodes partial tree 
load internal node aggregated load processors managing portions node 
root node associated global average load 
processor periodically gets load information peers aggregation bottom partial tree 
load information propagates entire system combination local aggregation steps peer topeer exchanges 
process proved converge log steps 
types load balance operations advantage load information partial tree 
processor joins navigates tree find processor high load partitions data set 
processor sustains significantly higher load global average may navigate tree find underloaded processor 
processor forced quit current position rejoin take half load overloaded processor 
favor physically nearby processor navigation data items may retain network proximity partition 
applications multi dimensional indexing application build high dimensional index supporting complex queries 
data set indexed points dimensional cartesian space 
typical queries exact point matches searches points falling certain range close point 
data sets frequently multimedia databases geographic information systems data mining decision support pattern recognition text document retrieval 
partitioning tree partitioning search space peer peer high dimensional index distributes tree 
tree widely index tree high dimensional data 
hierarchically partitions search space data set smaller smaller regions 
internal node specifies partition dimension split position splits region children 
data points stored leaf nodes 
illustrates partitioning search space processors shows corresponding tree skip graph routing tables 
insertion query operations navigate distributed tree reach appropriate leaf nodes 
target specified high dimension point insertion range range query 
enable tree lookup defines elements ledge denoting left right child 
compares target point range splitting plane node 
point returns matching child branch 
range may return branches 
described tree id processor tree path root left boundary node partition 
internal node path includes tuple pos split specifying dimension position split plane branch taken 
processor builds routing state partial tree containing tree ids peers 
processor joins locates heavily loaded node section partitions search space 
key benefit provided flexible choice split plane 
partition distinguishing dimension points partitions similar partitions involved query 
split median items balance load 
insertion lookup point straight forward 
hop processor navigates partial tree comparing point split planes tree nodes root forwards request peer maintaining region closest target point 
complex queries range query exploits type tree lookup 
target range high dimensional space 
navigating partial view tree node target range tested intersection regions corresponding children 
intersecting branch traversed traversal reaches leaves partial tree 
leaf remote region request routed peer search region 
local search performed find matching points 
nearest neighbor search returns points having smallest euclidean distances query point 
range query performs parallel lookup tree nearest neighbor search algorithm performs sequence lookups gradually refining results 
lookup step search request routed processor managing search region close query point 
regions searched order expanding dis number hops dimensionality max number peers processor psearch number processors max number points processor psearch average load number processors accumulated query cost psearch approx 
percentile processors routing distance peer imbalance load imbalance query load cdf query point 
perform exact search exhaust processors may contain closer point 
provide approximate search significantly reduces search cost controllable accuracy 
number processors visited query psearch approx 
number processors nearest neighbor search cost 
evaluated dimension image feature vector data set 
data set highly skewed 
compare psearch uses index high dimensional vectors :10.1.1.4.8363
compared allows flexible partition search space 
routing stable face skewed data distribution 
routing shows routing distances unaffected data dimension psearch suffers dimension low 
compares maximal number peers 
routing exhibits stable routing state confirms analysis section 
skewed data distribution enjoys better load balance shown 
compares nearest neighbor search cost measured average number nodes visited queries 
achieves lower exact search cost balanced query load flexibility space partitioning 
approximation reduces cost significantly 
routing load balance comparisons 
distributed file service go back example section review potential implementing partitioned file service 
known disk locality critical file system performance 
distributed file service locality file directory impacts performance lookup objects costs network communication 
keeping related objects processor reduce lookup overhead 
availability reason consider distribution locality 
accessing large set processors task vulnerable failures accessing redundancy level 
analyze nfs trace harvard university confirm observations 
trace collected eecs department server running research workload 
week long period october 
total requests involving file handles 
reconstructed file system tree trace 
tree split partitions load balancing process described section 
measure access locality identify user sessions trace activities 
session defined series operations sent user intervals minutes 
maximal length session limited hour 
total sessions period average duration seconds 
user activity shows strong locality session 
table gives number unique blocks files directories partitions accessed average session 
tree partition appears best granularity exploit locality 
evaluate availability replay trace poisson failures 
set mean time failure hours mean time repair minutes simulate dynamic peer peer environment 
file system distributed processors different schemes hashing block id hashing file id hash ing directory id tree partitioning 
randomly place copies block file directory partition processors 
replicas fail request fails 
second row table shows number sessions experiencing request failures different distribution schemes 
data locality improves client depends number servers perform task 
better locality reduces chance encountering server failures 
distribution scheme block file directory partition number unique objects accessed session number sessions seeing request failures related table trace analysis results far know general scheme efficiently distribute maintain traverse search trees peer peer systems 
previous efforts distributed search trees replicated tree focus parallelizing operations exploit symmetric node capability peer peer systems 
dhts chord pastry tapestry achieve scalability resilience building self organizing overlays locate resources peer peer systems 
systems hashing achieve load balance suitable maintaining complex data structures 
schemes dhts complex queries flat key space clear build general search tree :10.1.1.102.473
dynamic load balancing scheme inspired previous :10.1.1.102.473
random sampling scheme uses peer wise gossiping aggregate load information distributed tree directs reactive load adjustment operations 
similar aggregation schemes previous systems 
multi dimensional queries peer peer systems addressed systems 
discussed psearch earlier 
mercury provides range query indexing data set individual attributes 
uses random sampling ensure efficient routing log hops skewed data distribution 
attribute index mercury inappropriate nearest neighbor query involves dimensions 
propose general scheme efficiently distribute navigate tree data structures peer topeer systems 
approach shown effective locality sensitive applications 
believe applications benefit system maintaining complex data structures peer peer environments 
xu 
scalable efficient range queries grid information services 
second ieee international conference peerto peer computing 
aspnes kirsch krishnamurthy 
load locality range data structures 
proc 
podc 
aspnes shah 
skip graphs 
proceedings symposium discrete algorithms 
awerbuch scheideler 
peer peer systems prefix search 
podc 
bentley 
multidimensional binary search trees associative searching 
commun 
acm 
bharambe agrawal seshan 
mercury supporting scalable multi attribute range queries 
sigcomm 
ellard seltzer 
passive nfs tracing email research workloads 
usenix conference file storage technologies 
harren hellerstein huebsch loo shenker stoica 
complex queries dht peer peer networks 
proceedings iptps 
harvey jones saroiu theimer wolman 
skipnet scalable overlay network practical locality properties 
usits 
johnson krishna 
lazy updates distributed search structures 
proceedings acm sigmod 
karger ruhl 
simple efficient load balancing algorithms peer peer systems 
iptps 
keleher bhattacharjee 
virtualized overlay networks thing 
proc 
iptps 
ratnasamy francis handley karp shenker 
scalable content addressable network 
proceedings acm sigcomm 
ratnasamy hellerstein shenker 
range queries dhts 
technical report irb tr intel research 
rowstron druschel 
pastry scalable distributed object location routing large scale peer peer systems 
icdcs 
stoica morris karger kaashoek balakrishnan 
chord scalable peer peer lookup service internet applications 
sigcomm 
tang xu dwarkadas :10.1.1.4.8363
peer peer information retrieval self organizing semantic overlay networks 
proceedings sigcomm 
van renesse birman 
scalable management data mining astrolabe 
iptps 
zhang krishnamurthy wang 
scalable peer peer index service high dimensional data 
technical report tr princeton univ cs www cs princeton edu pdf 
zhao huang stribling rhea joseph kubiatowicz 
tapestry resilient global scale overlay service deployment 
ieee journal selected areas communications 
