evaluation software architectures control system case study sylvia jan van delft university technology 
give view software architecture phase development process 
phase distinguish modeling structuring activities 
system modeled certain approach model instantiate certain architectural style 
general activities intertwined 
choice certain software architecture implications nonfunctional properties system 
illustrate view case study software controller toy railroad system available software lab 
models system expressed formal specification languages past able produce software architecture system carrying activities separately 
resulting software architectures evaluated respect timing aspects scalability fault tolerance extendibility 
extendibility software system especially important domains changes applicable line 
design change start software architectural level 
illustrate view software architecture phase development process implications choice certain architectural style phase case study railroad system 
essence view distinguish modeling structuring activities 
choice certain software architecture primarily impact non functional requirements system 
evaluating different architectures certain system take account non functional properties relevant 
roughly said addresses functional requirements modeling activities non functional requirements structuring activities 
software architecture driven development process consists requirements analysis phase software architecture phase construction phase maintenance change phase 
software architecture phase models system chooses software architecture style instantiates style refines instantiation adding detail decomposing components connections going modeling choosing style instantiation refinement 
process result architecture choose architectural style style model system model architectural style instantiate style problem architecture refine apply problem choose modeling technique modeling technique fig 

software architecture development process defined detail reusable components connections fitted components connections designed implemented 
note view support sequential iterative incremental development process general modeling structuring activities intertwined 
software architecture phase view depicted fig 

ovals denote activities boxes represent products 
input activities requirements shown 
architectural style pattern organization software somewhat precisely set design rules identify kinds components connectors may compose system subsystem local global constraints way composition done 
architectural styles categorized taxonomies order provide guidelines mapping classes problems classes solutions 
boasson argues highest level fundamentally distinct approaches software architectures discerned data centered function oriented approach 
relate statement view software architecture phase development process say data centered function oriented model leads different sets software architectural styles 
describe software architectures high level abstraction different approaches system modeling toy railroad system available software lab 
data centered model system described formal specification language ae vdm 
model railroad system described paisley 
railroad network described case study differs points toy railroad system adapt models 
architecture derive implications quality properties important railroad controller timing requirements real time system usually contain temporal constraints 
case railway network strict temporal constraints safety reasons strict temporal constraints respect schedules 
performance respect constraints measured design decisions 
highly desirable decrease gap temporal constraints performance architectural level 
discuss time aspects proposed architecture 
scalability toy railroad system railway network case study scale models real life situations 
scalability requirement software architecture 
fault tolerance problems controlling physical system system behave exactly whichever model represent 
reliability addresses behaviour system environment behaving model robustness addresses behaviour system abnormal circumstances 
behaviour abnormal circumstances indicated term incident handling 
architecture indicate changes needed incorporate incident handling order achieve certain degree robustness 
incidents formed unexpected events railway network failing communication hardware 
extendibility requirements static final usually treated 
change result inaccurate modeling environment changing world 
answer changing requirements changing system 
system railway network necessary apply changes line 
possible mechanisms line changes software literature change architecture level consisting adding destroying components connections 
model dynamic change management lines kramer magee 
change source code level 
frieder segal described scheme procedure replacement 
opinion design change start architectural level 
evaluating architecture bear mind mechanism applicable changes think 
architectures proposed discussed sects 

section contains suggestions research 
data centered approach global state architecture type architecture analyze data centered model railroad controller toy railroad system described detail 
solution meant example global state architecture don pretend propose optimal solution 
event action model parnas behaviour reactive systems successfully modeled terms events actions 
events defined terms changes global state system including time 
actions consist computations resulting changes global state 
similarly functionality railway system described rules specifying action discerned event 
place speed behaviour individual train modeled finite state machine shown fig 

state halt train stopped temporarily 
state acc state gently accelerating train state dec gently 
train state const drives certain constant speed 
train state emergency stops soon possible 
halt acc dec emergency const fig 

state diagram train transitions finite state machine described action event rules stating events trigger transition table 
events involve information desired speed train generated fly schedule train 
column shows state transition column state transition event column describes event triggers transition 
finite state machine model behaviour train fig 

states discerned station state train situated station state start route station determined table 
speed train event halt const acc dec actual acc halt dec desired speed actual speed halt acc const dec actual const acc const dec actual dec acc const dec state train error emergency emergency actual speed halt wait go start station error fig 

state diagram train state go train driving state wait train stopped route state error cases failures 
assumed initial state train positioned station 
transitions showed table 
table 
behaviour train event station departure time reached start start go part route free go start go part route blocked wait go destination reached station wait part route free go wait deadlock occurred start states error occurred error data desired speed set side effect state transitions 
table shows simple way setting desired speed 
side effects consist determining route taken setting switches railway network 
table 
setting desired speed state transition desired speed start go desired speed maximum speed go wait desired speed go station desired speed software architecture shows architecture model 
central data store component contains relevant data sends events representing changes state time components acting events 
components able read write data 
proposed architecture seen instantiation blackboard style 
global data store controller controller controller train behaviour train speed switch railroad train behaviour states system route train speed states actual train info parameters trains railway topology actual railway info schedules routes desired speeds time switch settings planner fig 

global state architecture global data store store global state 
essential architecture fact data stored globally 
result data needed components global data store 
information kept global data store consists state behaviour speed train actual information speed position train parameters trains schedules derived routes desired speed topology railway switch settings time 
certain transitions global state represent events 
train behaviour controller carries responsibility maintaining finite state machine representation behaviour trains rules described table 
information needs consists train behaviour states schedules time positions speed directions trains train parameters 
component modifies train behaviour states desired speed switch settings 
route planner responsible determining route taken station mentioned schedule train 
may implement deadlock avoiding route planner planning ahead 
case second task route planner deadlock detection consequently determine new routes 
information needed route planner consists schedules railway topology positions speed direction trains 
train speed controller responsible maintaining desired speed comfortable way rules table 
task component update information actual position speed direction trains 
changes desired speed train transition behaviour state error form events interest train speed controller 
switch controller task updating information state switches setting 
multiplicity components architecture proposed state multiplicity components 
obviously data store 
hand train behaviour speed controller route planner 
multiplicity switch controller possibility 
multiplicity components open design decision architecture 
implications properties timing able analyze timing behaviour system implemented lines components performing functionality implemented cyclic asynchronously communicating processes 
processes poll global data store obtain information relevant data 
consequently restrictions cycle time derived temporal constraints speed duration connections computations 
scalability case routes trains generated fly possibility deadlocks 
increasing number trains driving railway network deadlocks occur frequently 
deadlock avoidance may necessary implications timing aspect 
deadlock avoidance chosen architecture suits solutions 
global state contains data trains deadlock avoiding algorithm introduced easily 
scalability reasons possible parallelize computation 
seen train behaviour train speed controller parallelized train 
train speed controller split component maintaining speed component polling train actual speed position direction information 
route planner parallelized case deadlock avoidance better performed separate component 
cases computation time increases increase complexity railway network 
possible bottleneck formed access global data store 
parallel agents detecting changes parts state able read write data needed increase railroad system 
extendibility changes topology network introduced changes data global state 
component responsible deriving new schedules introduced 
case timing issue components new data soon late trivial physical change railway network topology take place trains safe distance new situation read controller components time train reached new situation 
changes parameters trains introduced way changing data global data store 
changes applied train state station station new parameters time 
applies changes schedules trains schedule read route planner component train going leave station new data time 
general proposed architecture easily extendible architecture 
data changed fairly easy extension functionality done adding changing components adding changing data global data store 
big changes architecture needed components communicate directly 
prerequisites changes global data store applied outside components new data datatypes added runtime 
fault tolerance failing train result emergency 
model event error occurs global data state table 
error detection extra task train speed controller actual speed differs expected speed new component 
incident handling requires view system 
global state architecture component conceptually overview 
result add components intelligent incident handling capacities fairly easy 
failing communication network source problems 
discern different type data data store information updated frequently actual position speed direction trains information representing state change major difference old data 
loss messages containing type data really problem long time restrictions tight decision information slightly older harm 
messages containing information event state transition may get lost 
solution handle kind information way continually updated information waiting event components poll data global data store 
time poll update state information data changed side effect global data store 
system fault tolerant global data store duplicated distributed different hardware 
case information stored global data store setting extra processor components fails easy local data don exist 
function centered approach data flow architecture second software architecture loosely paisley model railroad controller described 
paisley model computation models asynchronously interacting concurrent processes functional programming 
specification written paisley requires process structure definition structure interprocess communication mapped directly software architecture 
paisley specification railroad controller consists cyclic asynchronously communicating processes 
software architecture dataflow architecture depicted fig 
instantiation architectural style 
position train process variable control 
actual position compared desired position differences trigger speed direction commands 
desired position computed consulting route contains time information parameters train 
actual position obtained polling trains 
railroad system actual position computer desired position computer comparator route planner switch controller switch commands position speed direction route deadlock info speed direction commands desired switch settings fig 

dataflow architecture route planner computes route trains 
data local component schedules 
case deadlock route planner gets message comparator computes new routes 
comparator compares actual desired position 
simplify comparison positions attributed indication time 
difference positions time indicates need control executed form speed direction commands train commands set switch 
information needed comparator consists position speed trains state switches railway network 
actual position computer polls trains derives time position speed 
trains 
desired position computer derives desired position train route sent route planner 
switch controller keeps track state switches railroad sets messages comparator 
multiplicity components position computers comparator architecture multiple instances train 
route planner obvious 
introducing deadlock avoidance system route planner train difficult require severe communication different components 
system routes trains computed component information needed avoid deadlocks available right place 
implications properties timing comparator switch controller triggered position controllers drivers system 
cycle time processes speed connections time needed different computations analyze system respect temporal constraints 
question deadlock avoidance detection 
deadlock avoidance performed route planner 
case route planner system 
logical place deadlock detection comparator receives information position train 
computation time needed deadlock detection conflict temporal constraints comparator 
case extra component introduced 
scalability seen parallelization introduced position computers comparator 
inherent solution computation time comparator increases increase number trains determine train able go comparator needs information speed position trains 
extra component filtering relevant information comparator needed system 
applies route planner computation time increases increase complexity railway system 
extendibility change railway topology network applied data components 
changes parameters train applied comparator train 
new schedules added route planner 
general data computation intertwined architecture opposed previous change data determine components information 
case extension functionality determine information needed component components information derived 
changes inherently harder apply previous architecture 
fault tolerance failing train detected comparator increasing difference actual desired position 
system comparison desired actual situation extra measures needed take failing trains account 
comparator component view system receives speed position information trains 
component appropriate charged incident handling perform strict temporal constraints 
adding incident handling case adding functionality said straight forward dataflow architecture global state architecture case components communicate directly data functionality separated 
connections components dataflow type cases continuously updated information case connection railroad system actual position computer connection position computers comparator 
connections commands information delivered new route deadlock situation 
connections fail deliver message result may disaster 
obvious solution deliver kind messages multiple times 
failing processors system harder replace previous architecture 
component local data 
way able replace processor keep track local data redundant hardware 
software architecture development process illustrated view software architecture phase development process sketched fig 
case study railroad controller software 
concerning development process remarks case study software architecture phase carried sequentially modeling system took place style chosen instantiated 
reason order models system available 
general system modeling choice instantiation architectural style carried time 
case study clearly shows existence relations activities software architecture phase 
choice model influences choice architectural style vice versa 
adequacy different approaches system modeling different architectural styles added taxonomies styles 
architectural styles differ degree satisfy non functional requirements functional requirements 
implications architectural styles non functional requirements summarize effects proposed architectures quality properties important 
timing temporal constraints met determined fully implemented system 
architectures able reason conditions timing analysis possible reason possible bottlenecks 
level abstraction proposed architectures difference solutions respect timing issues 
scalability big difference proposed architectures global data store architecture information available component 
result easy divide functionality component 
dataflow architecture breaking component ones functionality components controlled system bear mind newly created components get information 
fault tolerance introducing incident handling requires hand possibility component run separate thread hand possibility gather information global state system 
global state architecture requires decision multiple threads 
dataflow architecture multiple threads part style 
hand extending functionality architecture easy components communicate directly determine necessary information obtained 
failing hardware handled easily global state architecture state available 
global state duplicated 
extendibility changes data topology railroad network parameters trains schedules easy apply global data store architecture 
dataflow architecture determine components store information locally 
general changes functionality system easier apply global data store architecture need analyze information needed component obtained 
requirements possibility line changes possible add components data data types line 
directions line system evolution real time systems considered challenges area 
promising approach explore possibilities global state architecture respect 
changes functionality architecture applied adding substituting components 
addition facilities change global state generation distribution events developed 
facilities change global state comparatively easy handle failing processors global state architecture assuming global state component fail proof components performing computation may substituted components loss data 
description architecture evokes static view components connections 
architectures possibilities line system evolution dynamic 
apparently techniques describe analyze dynamics architectures lacking 
representation dynamics architectural styles instantiations form interesting subject research 

brink van 
simple railroad controller case study real time specification 
technical report delft university technology department technical mathematics informatics 

boasson 
software architecture 
ieee software november 

frieder segal 
dynamic program updating distributed computer system 
proceedings ieee conference software maintenance phoenix arizona october 

hayes roth pfleger balabanovic 
domain specific software architecture adaptive intelligent systems 
ieee transactions software engineering april 

jeffay 
real time producer consumer paradigm paradigm construction efficient predictable real time systems 
proceedings acm symposium applied computing pages indiana february 
acm press 

kramer magee 
evolving philosophers problem dynamic change management 
ieee transactions software engineering november 


view model architecture 
ieee software november 

monroe melton garlan 
architectural styles design patterns objects 
ieee software january 

parnas van kwan 
evaluation safety critical software 
communications acm september 

shaw 
objects software design paradigm process control 
acm software engineering notes january 

shaw 
field guide preliminary classification architectural styles software systems 
manuscript www cs cmu edu afs cs project compose www html publications html 

shaw garlan 
software architecture perspectives emerging discipline 
prentice hall 

stankovic 
real time embedded systems 
group report realtime working group ieee technical committee real time systems www ccs cs umass edu rt ps 

tanenbaum 
structured computer organisation 
prentice hall 

van 
experience paisley real time specification 
technical report delft university technology department technical mathematics informatics 
article processed macro package llncs style 
