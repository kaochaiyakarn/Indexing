mix years neil jones diku university copenhagen dk copenhagen denmark mail neil diku dk rst article reporting running nontrivial self applicable partial evaluator appeared 
described results year intense done peter sestoft harald diku led activity worldwide 
signi cance rst time demonstrated practice feasibility generating compilers compiler generator partial evaluator foreseen principle futamura independently soon 
partial evaluation undergoing rapid expansion places world continuing stream new techniques applications fundamental insights 
gives view important developments taken place eld past decade 
researchers may di erent versions re ecting philosophical visions emphases taken truth truth version truth 
parts adapted 
partial evaluation partial evaluation pe short program specialization 
aim computer programs run faster ect mechanically trading program generality order gain eciency 
pe just intellectual curiosity evolved automatic tool program transformation optimization arguably part programming workbench 
past decade interest activity pe grown rapidly 
essentially similar concepts regularly reinvented di places sub elds computer science sure sign emerging signi cant body ideas 
practical potential 
unfortunate programming described cottage industry little way machinery 
programming requires enormous amounts human write maintain adapt programs 
labor intensive practice aptly described ifip congress high technology basket weaving bill wulf world leader software development 
today approaches software engineering programming methodology best practice case tools ways better organizing akin giving foot soldiers better training 
clear automatic mechanical treatment programs needed lift software development current state 
promise pe just ability lift parts program development highly automated near industrial process human creativity human comprehension individual programs occasionally required high level computational decisions taken 
roots partial evaluation partial evaluation meeting point areas dealing programming languages di erent ways compilation semantics computability theory 
pe techniques extend compilation technology practice theory 
compiling concepts overlap heavily pe include procedure cloning inlining loop unrolling constant propagation 
program ow analysis semantics counterpart interpretation essential pe systems ow analysis online specialization ine program preprocessing phase 
principle partial evaluator regarded unusually aggressive compiler applications reach far considered normal highly optimizing compilers 
view programs data objects requires precise knowledge program semantics correct transformation analysis semantics formal informal foundation pe 
operational semantics best medium formulations correctness proofs pe treats programs data objects manipulated data addition run constructed decomposed transformed 
line thought stems 
recursive function theory rst 
researchers explicated meaning recursive de nitions introduced rst self interpreters universal machines undecidability halting problem kleene second recursion theorem 
pe just ecient implementation kleene theorem 
rest article program textual object view entirely compatible recursive functions compilation contrast say calculus program equivalence class problem denotational models re exive function domains lack full abstraction meaning adequately formalize programs operational behavior 
consequence models conservative replacing program fragments equivalent ones 
convertibility 
language de nitions problem speci cations regarded concrete data objects 
notations describe pe write meaning function rst order inputs outputs 
wish specify language written write output resulting running input written 
manipulation multistage programs compilers interpreters specializers requires precise notations ect program runs correctness manipulations 
runs described expressions describes step run compiler source describes step run rst compiles program source runs resulting target program input equalities expressions describe criteria correctness target program correct respect source program source target input 
equality include side unde ned case side unde ned 
de nes way meaning target program interpreter compiler 
equational speci cations give clear precise statements goals equalities expressions allow reasoning predict advance net result certain runs may hard grasp intuitively terms program execution 
notorious familiar example keeping track program versions bootstrapping 
correct partial evaluator generically called mix easy de ne equationally 
program expecting inputs program mix satisfy mix name mix partial evaluator coined ershov express fact ecient pe mixture execution actions actions depend compiling actions remainder 
program output mix appropriately called residual program 
results predicted equational reasoning equations mentioned de ne desired net results computer runs time space eciency hard anticipate practice 
virtue possible advance state wishes achieve going operational detail 
gives way check goal fact achieved perform runs compare results going details done 
idea familiar mathematics instance nd roots algebraic equation 
symbolic algebraic thought patterns natural programming languages 
output source input target input interp source input target compiler source compiler cogen int interpreter target compiler compiler generator target mix int source compiler mix mix int cogen mix mix mix futamura projections examples futamura projections explained section ceres compiler generator system 
case certain equations solvable implied existence programs desirable properties cases compiler generators 
case intuitive idea programs satisfying equational speci cations look eciency existed fact surprise compilers compiler generator produced ceres turned reasonably ecient 
limitation ceres automated code generation task took account statically actions looking variables symbol table 
analogously dave schmidt saw need separate binding times static dynamic parts computations calculus approach compiler generation aarhus semantics directed compiler generation workshop quite unclear 
partial evaluation gave answer years 
self application idea self application program specializer lead automatic program generation understood independently japan futamura ussr turchin ershov sweden rst heard idea sandewall group 
precise concise expression idea futamura projections 
consequence easy verify de nitions cogen mix cogen mix mix mix generating extension 
claim input program corresponding generating extension gen term due ershov property gen mix static known rst data value words gen generator specialized versions pro just equations roots write equalities describing unachievable program behavior 
gram gen directly generates specialized version having run general program mix 
know program exists 
easy algebra veri es mix mix cogen program de ne satis es equation 
consequently generating extension gen may built runs involving cogen faster 
generating extension specialized version mix expected run signi cantly faster mix 
fast specialization exciting potential application runtime code generation operating system consel lee massalin pu 
user asks specialize program may deliver generating extension gen consequences 
user create specialized versions desired simply running gen need know complex partial evaluator mix 
second ect security little risk gen reverse engineered reconstruct partial evaluator 
fruitful application concept involving self seen 
origins partial evaluation early times 
pe independently discovered times rst kleene computability theory times lisp markov algorithms devised 
early researchers include california futamura japan turchin ershov ussr sandewall group sweden 
insights purely theoretical kleene construction gave program slowdown speedup 
early practical ad hoc unpredictable results 
weaknesses completely understandable formal semantics existed time correctness criteria hard express exception pruning proof trees 
futamura discovered potential self application pe compiling compiler generation 
independently valentin turchin pursued topic ussr early mid building research group moscow active eld 
andrei ershov major contribution series lectures west clarifying concepts emphasizing way pe uni es concepts interpretation compilation program optimization 
dream compiler generation denotational semantics 
learning denotational semantics discovered peter mosses sis project denotational semantics de nitions executable doing reduction 
occurred information execute language de nitions source program input data information compile source program target program 
dream led early conference compiler generation aarhus 
gaining high eciency staying faithful purely denotational semantics turned quite dicult partly domain theoretic reasons 
goal true compiler generation remained elusive years approaches tried researchers included appel christiansen gaudel lee mosses slow limited power complex hard automate semantics 
led sophisticated example appel thesis ideas realized sml nj compiler 
better techniques separate compile time run time actions commonly seen necessary unclear full generality 
years dream ful lled pe successful experiment rgensen generated purely denotational de nition lazy functional language similar spirit miranda tm language compiler yielding faster target program run times turner commercial system 
unfortunately time interest purely denotational language de nitions 
de ciencies denotational semantics tool language de nitions example problems concurrency full abstraction problem lack readability led alternative language de nition formalisms example mosses action semantics 
experiments implementation partial evaluation interpretation done bondorf palsberg rb steps self applicable pe 
partial evaluators implemented sandewall group sweden dealt full lisp 
important step development thought handwritten version cogen 
ershov asserted compilers generated self application pe didn say achieved computer 
ershov told ifip paris 
rst purely intellectual question arose futamura projections realized nontrivial specializer developments conceptual understanding online ine pe kleene construction mix simple identical code initialize rst input argument trivial pe requires operations unfolding symbolic computation unbounded length 
task perform certain necessarily static operations commands depend suspend generate code remaining ones called dynamic 
common problems overcome include suciently strong specialization ensuring specialization terminate dealing data containing static dynamic components static components built dynamic control 
problem mix deal possible run time execution patterns specialization loop trying account nitely di erent run time computations single computation terminates individual acts unfolding symbolic computation simple obviously semantics preserving main problem controlling repeated 
major paulson tofte vickers wand weis 
kleene theorem gives true solution useless practice 
schools thought oldest online specialization execution mimicked directly decisions taken operations suspend 
comparison ine specialization begins program known inputs known specialization values decisions advance simulate suspend 
online methods sophisticated loop detectors applied pe time ine methods perform sophisticated program analyses preprocessing 
forms interpretation manipulating descriptions sets possible runtime computational states achieve termination generalization replacing state set description precise describes larger set states 
online pe 
rst partial evaluators online approach useful 
online specialization seize opportunities code improvement squeeze microseconds performance 
approach naturally allows partially static data structures binding times 
means instance function say arguments give rise specialized versions rst known second 
swedish systems developed sandewall group lisp prolog online 
newer systems named advanced techniques ensure termination 
ine pe 
motivation rst ine pe systems get self application see section time reasons discovered favoring ine pe 
choice online ine black white applications pe favor approach 
larger systems usually measure similix system extensive ine analyses postprocessor nal tidying essentially simple online pe pass 
ine preprocessing phase called binding time analysis bta short program analyses ranging simple dependency analysis see value computed knowing dynamic argument spectrum analyses ensure behavior specialization 
mentioned 
output preprocessing typically annotated program ann identical marks placed ect say perform operation specialization generate code operation generate specialized program point control reaches 
specializer proper small fast task just obey annotations having take decisions online 
bene approach unfamiliar mysteries pe annotated program ann gives user feedback terms user program little need know mix works 
binding time improvements 
shows small speedup large 
binding time improvement modi cation working program obtain better results partial evaluation 
ine methods user study annotated program ann tweaked get ann numerous static computations 
note analogy tuning grammar acceptable parser generator yacc 
annotations easier reason problems code explosion specialization online methods rst resort easy examine output mix see went wrong resort unreasonable users study behavior structure mix 
achievement self application experiments diku began peter sestoft harald students late construct self applicable mix parallel months tried seriously 
prove self applicable program specializer trivial 
half year frustrating experiments rst enormous correct generating extension produced line program yielded gen mix mix worked pages length acceptably ecient fully self applicable mix rst produced november 
took time understand mix mix huge overly general code determining computation online generate code situations perfectly clear choice taken 
rst solution problem hack hand addition ad hoc annotations tell second mix operations simulate generate code 
gave enormous reduction size gen pattern seen holds today mix generated compiler times larger interpreter derived running mix generated target program times faster running interpreter 
began understand annotations essence carried information times various parts mix performed rst automated annotation process coined term binding time analysis 
biasing inputs 
general form second futamura projection gen mix mix 
bindingtime information sort second mix information specialized rst argument example second 
unannotated mix take account possibilities 
saw case interpreter gen compiler 
annotations similar information result fact program tailored specialize special case task compiling source program 
seen compiler peculiar cient able compile specializing interpreter program input specialize interpreter second runtime data input program input unknown 
annotations implies generating extension gen mix mix ann ann gen mix mix 
role annotation indicate binding time bias program gen applied value rst input second 
technical advances rapid activity occurred locations past decade 
selection advances particularly signi cant apologies may omitted 
partial evaluation systems 
include mix strictly conforming ansi standard programs fuse scheme essentially prolog sage strongly logic programming language odel similix scheme rstorder subset lisp 
experimental systems include subset fortran pel monomorphic typed rst order functional language mix untyped lambda calculus constants polymorphic rst order functional language sml mix subset standard ml supercompiler 
ine exceptions supercompiler fuse 
self applicable systems include mix sage similix restricted supercompiler 
moscow system particularly elegant simple cleanly written example study newcomers 
follows lines original system longer available arity raising postprocessor specialized programs readable 
similix diku complete system publically available user manual advice user feedback aid binding time improvements copied ftp sites 
credits mix mix similix sml mix diku andersen carsten gomard anders bondorf olivier danvy lars birkedal morten 
fuse dan weise students mit stanford microsoft oregon 
sics sweden dan sage bristol corin gurr 
consel danvy france paris rennes oregon ogi 
moscow sergei 
vienna robert gl students 
pel glasgow john launchbury 
leuven anne de dirk 
partially static data structures online systems fuse turchin supercompiler handle partially static structures quite naturally 
sml mix sage pel handle partially static structures virtue type systems 
torben mogensen rst implementation ine pe system able handle data structures partially static partially dynamic 
approach tree grammars 
ability added similix tables binding information data structure creation points essence way grammar 
higher order functions years extension rst order done breakthrough happened nearly simultaneously mix gomard jones diku calculus constants similix scheme bondorf visiting dortmund danvy 
extended higher order functions long consel danvy 
novel form binding time improvement achieved systems converting programs continuation passing style 
point programs better binding time separation programs derived 
preservation termination properties side ects 
similix system am aware careful analyses detect expressions cause side ects ones duplicated eliminated specialization 
similix conservative cases avoid causing change whatsoever program semantics specialization 
maintain dangerous reduce car cons 
semantic changes happen example loops increased termination bad commit error write output le serious 
code size explosion 
analysis reduces eliminate entirely risk code size explosion 
reason avoid repeated side ects especially undesirable input output involved similix inserts expressions computations involved performed 
ensures code appears specialized program 
problems code size explosion discussed 
imperative languages mix systems handle explicitly languages similix allows side ects 
imperative languages trickier specialize functional logic 
reason imperative languages allow access variables current scope code explosion occur care taken specialize dead static variable values 
pe system account possible run time states ects assignment cause nonlocal ects accounted 
particular language requires pointer analysis assignment dynamic value pointer variable ects may aliased 
binding time improvements growing compendium experience subtle art 
similix manual section binding time improvements techniques described 
staging levels evaluation times multistage program runs bootstrapping confusing 
keep language levels unambiguous semantic function program runs explicit write expressions implicitly assume rst executed 
rudimentary type system explicitly express notion staging level help keep track levels 
recall programs textual objects need odel numbers indirect program representations 
underlying idea values types integer boolean programs program types explicitly give language interpret 
simplicity avoid need type coercion functions assume rst order values expressed common format ignore encodings values domain 
assumption re examined 
types keeping levels distinct implies change conventional notations 
example write int example int ml meaning expression expression evaluated language ml yield value type int 
de ne meaning type expression programming language set fl program compiler translate source program target language program meaning identical source program 
words compiler program transformation insensitive type input program 
identity function type types trivial typed compiling function types polymorphic range rst order types 
source program denotes value type interpreter run return value type partial evaluator inputs program value rst input 
convenience curried notation writing mix 
input language interpreter compiler compiler target language 
describing partial evaluation omit subscript types assigned interpreters assume observable values types 
interpreter compiler comparison mix cogen remarks 
di erent output types compiler interpreter quite natural 
note interpreter illustrates dependent types extreme manifestation value produced interpreter source data type expressed program 
consider simple type deduction rule assume conclude types mix cogen mix gen rudimentary type system sucient account self application futamura projections shown preserve expected types notation 
details see 
writing cogen mix 
advantages accrue writing cogen mix especially dealing typed languages 
reason seen comparing level types mix cogen merely code code transformer mix deal input values type program texts type time 
partial evaluators diku written way 
earlier version mix mix type revised cogen type sml mix written way 
net result similix mix enlarge range language features handled increase ciency specialization quite substantial amounts 
assessment opinion major progress technical problems 
remains done partly concerning typed languages especially concerns making pe usable 
past decade began puzzle achieving self application 
achieved full success respect objective criterion optimality explained 
new insights basic con ict computational completeness versus termination 
clearly desirable specialization function mix total program partial input leads de ned output mix 
hand demand computational completeness equally natural program partial data computations depend input performed 
online pes favor totality ine ones tend favor completeness 
unfortunately fundamental con ict 
example computations independent second input partial function computational completeness require mix fail terminate 
tempting way allow completely specialized case produce trivial specialization 
impossible full generality require solving halting problem 
online specializers typically monitor static computations performed force thorough specialization risk nontermination detected 
strategies capable detecting nontermination necessarily complete cases perfect solved halting problem 
typical example hard specialize nontrivially having specializer fail terminate complex true condition nil true cons reasonably expect specializer determine condition true 
specializer aiming computational completeness attempt specialize branches loop leading nontermination specialization time 
optimal interpreter specialization 
specializer optimal compiling meaning removes overhead 
precise self interpreter sint 
rst futamura projection input sint sint mix sint program sint semantically equivalent reasonably say specializer removed overhead sint ecient concept optimality proven useful constructing practical specializers mix specialized program sint identical variable renaming program achieving optimality shown excellent stepping stone achieving satisfactory compiler generation self application 
linear speedup rule 
pe systems know ect simulate program specialized computation order consequence computations specialized program input embedded order computations input suppose xed compares run times input grows nity 
consequence previous point superlinear speedup occur computations saved precomputed mix necessarily function static data 
factors rst speedup large major practical signi cance 
second coecient may depend static data larger values result larger speedups 
complexity theorists told years constant factors trivial proved fact true realistic computation model turing machine 
interestingly insight led result came result explaining self interpreters visiting complexity theorist 
specialized program points means projections 
early insight underlying nature program specialization see existing systems worked projections total computational state con guration mix proceeded throwing away part depending dynamic input maintaining description remaining static part 
formalized john launchbury extended ideas typed programming languages domain projections ph thesis 
specialized program points means interpretation 
robert gl andrei clari ed turchin said earlier supercompilation achieve degrees specialization done projections 
clear happening kind online interpretation relational independent attribute sort formulated language independent terms 
code size explosion 
pe gives rise specialized programs large practical rarely happens compiling interpreters 
insight gained problem parts solved code duplication analysis part similix 
source code explosion presence functionally independent static variables 
mix account possible run time scenarios specialization say function independent static arguments lead specialized versions function 
problem especially imperative languages dead static data 
problem imperative programs possibility access variables scope includes current control point 
static dead tested just previous point give rise numerous specialized program points 
contrast specialized program points equivalent code duplication completely utility 
single universal data type versus type universe type 
strongly typed programming languages popular advantages human programmers 
ideas involved pe extended rst order typed values thesis john launchbury glasgow sml mix birkedal 
extending concepts types creates diculties partly attempting compile specializing interpreters especially attempting self application 
futamura projections equations assume universal data type containing rst order values including texts programs 
example definition interpreter states output identical program simulating type may 
typed context type de nition de nes particular domain discourse church view curry view types interpretation typed programs necessarily involve form coercions interpreter input type example encode decode world typed partial evaluation sees expressions exp standing representation arithmetic expression exp encoded lisp list 
time space overhead usually constant factor quite large 
pattern extended domains containing functions 
direction quite programs 

natural inverse 
programs problem exist case computable function 
computable notation dangerously ambiguous nitely di erent programs compute computable function may vary widely respect run time factor wishes optimize pe 
lucky accident rst partial evaluators written untyped languages practitioners unaware problems time 
escaped problems universal data type rstorder data lisp lists avoiding need functions encode decode 
problems specializing strongly typed languages 
program mix clear type part interpreter part compiler 
interpretive component especially problematical strongly typed languages 
interpreter form universal type abe encode values manipulable program interpreted example int bool 
problem specialized versions interpreter naturally inherits universal type single run time value involves type tags associated experiments reveal unexpectedly high costs terms run time storage time set test remove unnecessary run time type tags 
overhead removed 
reasonably ecient special solutions devised specialization time launchbury de target programs remain quite unnecessarily slow large 
obvious general answer form type specialization unclear formulate concept solve 
researchers worked problem doing include launchbury de mogensen 
advantages writing cogen mix reasons just partial evaluator mix strongly typed language certainly inecient specialization time due need universal type compilers generated self application slow generate slow target code 
fortunately way write cogen writing mix 
input annotated program ann output generating extension gen able produce specialized versions examining type cogen reveals deal values program texts interpreters mix 
program cogen simply text transformer 
somewhat ed task just generate code appear gen statically annotated parts ann generate code generation instructions dynamically annotated parts ann code part gen simply copy static parts ann including static type declarations need static computations performed 
side ects approach include greater eciency specialization time static computations performed directly ease handling semantically complex language constructions just gen specialized version warning correctness verify true semantically complex constructions preserved unfolding done specialization 

eld partial evaluation 
answer expand horizons solve new problems build new systems greater eciency handling powerful languages able handle new applications 
improvements clearly desirable long run danger getting larger programs failing gain new insights usable 
second understand precise terms just methods programs accomplish evaluate nd limitations 
understanding essential practical reasons communication results adapted solve related problems 
achievement greater automation program handling 
ideally program transformation tools anonymous parts program management system invisible user gears transistors requires precise knowledge characteristics 
general directions development quite remarkable impact software development automatic specialization tools allow design reusable software general structured easier maintain penalty inecient 
new idea example macro processors long customize say operating system kernels particular hardware con gurations 
ideas software procedure cloning involve concepts 
pe aid software maintenance reuse 
reuse achieved di erent view specialization program rst hand generalize generic program adding parameters give broader functionality 
program automatically specialized respect di erent parameter settings 
simple test verifying correctness generalization specialize parameters de ning original problem see result close making pe usable 
goal requirements 
discover types problems yield specialization environmental support tools needed ective specializer 
important identify trouble spots specialization achieved achieved methods hard learn industrial users 
binding time improvements 
pe eld growing accumulation experience strongly desirable consolidate experience publically accessible compendium 
needed achieve wider acceptance pe 
wider partial evaluation requires abandoning remaining black magician attitudes making concerted orts understand communicate put partial evaluation practical 
various real world factors follow 
real computer languages 
goes saying partial evaluators restricted say scheme haskell win widespread acceptance alas 
progress specialization fortran quite relevant obvious step take 
convenient systems threatening 
category demands smooth user interfaces convincing demonstrations 
requires pe practitioners moderation stating claims 
speedup factor partly due specialization partly due language changes hard separate individual threads entering result 
people say industrial practice impressed believe speedup factor algorithms languages daily practice 
users need know program mix 
go saying expect users understand continually evolving mix expect understand parse table compression techniques yacc uses 
modularity specialization 
specializers require entire program advance 
instance modular binding time analysis done consel jouvelot rb reached maturity similar example ml module system 
predictable results specialization better termination properties 
desirable traits 
current andersen holst holds promise termination algorithm add similix 
pe results require things computer estimate speedup pe expected give 
steps direction taken andersen gomard 
better control code explosion 
mentioned analyses devised identify possibility cause code explosion 
pe specialists look people programs 
real danger seen computer science communities 
nature pe broad spectrum possible application areas help people better solve problems 
pe possibility motivation wider external contacts exploited 
technology transfer technology matures man factory oor clear need special courses means technology transfer 
rst step direction conference tutorials summer schools held carnegie mellon france 
role open problems state art intellectual communities expressed widely known collection important open problems solution advance state 
collection developed broad consensus invaluable inspiration contribute signi cantly maturing eld 
complexity theory np context free language recognition require superlinear time central problems solution positive negative widespread consequences 
classical example hilbert famous list problems mathematical congress greatly stimulated branches mathematics including particular recursive function theory understanding fundamental limitations formal mathematical systems 
precision problem de nition criteria evaluating solutions aim bring research directions partial evaluation mixed computation sharper focus listing set important problems near solution 
essential point understand just aim advance objective communicable evaluable terms 
essential criteria selecting problem challenging include precise de nition exactly problem solved 
potential utility problem solved useful just intellectual curiosity solutions lead insights problems lead investigations 
abstraction vital principles new program system described terms free possible situational context created 
details abstracted away include particular programming language special jargon set tricks ways looking problems particular user community particular set possible application areas 
new results abstractly chance adapt ideas novel applications new languages bene gain copying running described programming system 
judgement criteria methods apparent ascertaining alleged problem solution fact correct solution 
challenging problems section collects variety problems partial evaluation mixed computation appear worth solving lack solutions cases precise formulations 
rst part concerns problems workshop partial evaluation mixed computation 
newer problems de nitive far reaching known open problems complexity logic temporary purpose encourage researchers eld clarify understand goals state precisely move broader deeper understanding needed prepare de nitive lists 
challenging problems control data 
residual program essential loops recursions source program 
source program loops target program 
suspension parts composite structured data achieved 
pe adapted cope data partially dynamic partially static 
arbitrary residual programs produced 
answers 
strength discussed 
residual program composite values composite source 
pe generate new specialized data types way analogous generating specialized functions 
answer fully realized done constructor specialization torben mogensen dirk 
target code 
mix produced compilers target programs achieve eciency traditional runtime architectures 
architectures ecient tested level necessary minimal 
traditional runtime architecture derived automatically interpreter text 
example residual programs techniques resembling pascal stack activation records automatically generated interpreter 
answer progress example john hannan 
traditional compiler techniques symbol tables multiple passes constant folding derived automatically mix interpreter partial evaluation pe techniques typically yield target programs written interpreter language 
pe yield ecient low level machine code 
done writing interpreter text uses machine subset source language 
rationale target program residual form interpreter inherits characteristics 
answers holst berlin weise generate parallel target code 
achieved 
source large gains ciency yielded straightforward partial evaluation automatically achieve linear speedups 
answer discussed 
automatic tools program generation partial evaluation raises possibility automatically transforming wider classes problem speci cations algorithmic solutions 
application parser generation 
generally suppose computable function solve problem specification parameters outputs solutions acceptable problem speci cations de ned class certain parameters 
finder mix solve program probl specification solution nder parameter value yields solution grammar example nder specialized parser mapping input strings parse trees 
transformer mix mix solve program transforms problem speci cations solution transforms general parser parser generator 
far approach carried practice 
examples problem speci cation solution nder transformer context free grammar parser parser generator interpreter target program compiler set horn clauses prolog system prolog compiler categorical lang 
def 
interpreter rst order logic formula specialized prover prover generator second order calculus constructive type theory nearing higher order logic executability automated answers mossin thiemann produced parser generators pe 
generated compilers 
hans realized hagino categorical framework de ning programming languages results 
program composition decomposition partial evaluation decomposes program executable part part 
rst executed partial evaluation second residual program 
interpreters executable part consists compile time actions part target program 
part semantics syntactic semantic program composition operators executable part part semantics semantics executable part semantics part program composition operators studied example serial composition homomorphisms attribute coupled grammars parallel composition basis divide conquer algorithms 
problem study program composition decomposition operators suitable describing implementing partial evaluation 
common technical problem generalization problem appears root termination problems plagued nearly partial evaluation 
partial evaluators constructing set con gurations represents set run time computational states parts reachable computations run time input data satisfying input restrictions 
instance con guration contain values subject program variables 
known values call static dynamic 
dicult balance achieve con gurations enumerated detail exploit known input computation possible done pe time detail recorded strong chance con guration set nite lead pe time nite loop 
call con guration generalization represents larger set run time computational states 
problem develop generalization strategy marking new con guration dynamic guarantee niteness keeping static get ecient residual program 
devise strategies generalizing con gurations 
answers online ine strategies brie discussed problem far fully solved 
great majority ecient fully self applicable partial evaluators line generalization 
expressive languages progress occurred area 
successful partial evaluators see discussions 
functional languages higher order functions 
compilation logic programming pe 
imperative languages recursive procedures nonlocal variables structured data pointers self applicable partial evaluator term rewriting systems 
done bondorf 
aid ecient implementation equational speci cations aid knuth bendix algorithm 
results sherman 
problems fully solved 
pe machine assembly low level language languages lazy evaluation 
object oriented languages 
pe nondeterministic parallel languages semantics preserved 
mean 
speci problems broader implications progress areas decisive results lacking 

extend existing languages automatic insertion debugging code pro ling instrumentation 
type checking 
achieve type security run time type tests possible 
worked henglein 
determine interpreter language interprets strongly typed exploit information generate highly ecient residual programs 
derive interpreter algorithm static type checking interpreted programs possible automatic methods 
program transformations 
apply partial evaluation self interpreter order generate automatic program transformer example recursive form tail recursive form lazy evaluation eager evaluation automatically introducing memo functions implement truly user extensible language acceptable eciency 
semantics directed compiler generation pe 
answer 
done rgensen see 
distant horizons 
partial evaluation practical second recursion theorem recursive function theory kleene ju 
ershov 
develop system observe program runs adaptively specialize program seen spending time restricted class input data 
applications automatically compiling frequently run program automatically generating compiler frequently run interpreter implementing closures high level language partial evaluation 
automatically construct program estimate subject program running time 

apply divide conquer algorithm equalize sizes subproblems distribution network parallel processors 
study relationships learning partial evaluation 
new challenging problems spite enormous scope preceding list new problems arisen past decade 
reader doubtless supply 
dependence speci architectures compilers 
pe interacts unexpected ways speci architectures compilers 
problem tuned handwritten code code di erent characteristics 
newer computer architectural features pipelines data instruction caches levels hard predict example unrolling loop static bounds speed execution 
principle slow due increased cache misses haven seen solid evidence problem 
symbolic operations programs 
operations programs imagined program texts realize known mathematical operations meanings texts composition realizing currying application tupling inversion problem course realize eciently 
answer phil wadler deforestation form symbolic composition studied chin rensen partly implemented glasgow haskell compiler 
combining best features deforestation specialization 
deforestation program optimizations reach traditional pe 
system combining best features quite interesting 
self applying fully automating turchin supercompilation 
turchin supercompilation deforestation specialization 
fully automated version supercompilation traditional programming language quite interesting 
transition turchin philosophical concept transition led realize accomplished pe 
appears framework may consequences programming language processing 
topic 
multiple levels specialization 
just binding times 
applications multiple specialization levels natural formulations experiments 
open questions include express bias mentioned mixed level analogues futamura projections 
gl rgensen done experiments realizing specializer projections generalize futamura projections currently doing multilevel experiments 
better de nition optimality 
weakness de nition optimal pe 
unfortunately 
condition proposed expressed relative particular self interpreter sint 
cheated letting mix structure read program program sint result result trivial specialization program write result hand demand mix yield optimal specializations possible self interpreters 
concept optimality pragmatically mathematically speaking unsatisfactory 
problem resolved time writing research topic reader 
specialization adapt changing contexts examples include generating special purpose code tailor various parallel computing environments automatically producing highly ecient kernel code operating systems cryptography protocol implementation 
self critique hard see published works partial evaluation just problem solved solution extended adapted languages program transformations application areas 
spite rapid progress impressive new results pe large gap state art current research potential signi cance 
parts computer science including lack international intellectual community analogous atomic physics mathematical logic numerical analysis complexity theory just name 
communities established fundamental concepts agreement major problem areas ability tradition nd essential contribution new piece seeing small methodological terminological di erences 
bring community closer state 
greater scienti maturity important problem little research classical meaning term result works reinvent wheel omit highly relevant 
problem papers discuss limitations results methods reader left puzzle part said routinely lled part completely reach methods 
relevant example widespread parallel development partial evaluation ideas functional progamming logic programming communities far little discussion groups boundaries 
problems hinder forming true scienti community 
far helpful new scienti contribution emphasize commonality usually exists predecessors super cial di erences consistent notation terminology essential clarify powers limitations new results 
special due robert gl dirk discussions group diku things mention 
acknowledge people research contributed eld 
bibliography contains mentioned full extensive proceedings 
curious invited look rst group diku web fail send mail personally ask 
personal chronology pe futamura projections discovered futamura published obscure japanese journal moral self application generate programs run faster 
middle self application independently rediscovered turchin ershov ussr sandewall group sweden uppsala link oping lectures west ershov potential partial evaluation dream semantics directed compiler generation conference semantics directed compiler generation aarhus idea binding time separation denotational semantics dave schmidt nj ceres system christiansen nj generated true compiler generator complex strong partial evaluation prolog link oping komorowski rst hear self application partial evaluator link oping meeting andrei ershov rst understand full potential partial evaluation meet ershov paris ifip ask mix exist 
answer initial self application focus long breakthrough article polyvariant specialization diku november rst running nontrivial self applicable mix order statically scoped lisp hand annotations call unfolding typically target times faster running interpreter compiler times larger interpreter re ection experiments simple binding time analysis nding data dependency mark dynamic expressions depend inputs available mix conference self applicable pe rewriting techniques applications nancy just really accomplished 

formalize better understand binding time analysis applications toy interpreters parser generation ray tracing functional language mogensen fully automatic mix sestoft system moscow conference programs data objects valentin turchin guest professor copenhagen partial evaluation mixed computation conference denmark people expensive north holland proceedings double issue new generation computing mix partially static data structures mogensen projections specialisation launchbury mix machine code output language holst automatic call unfolding sestoft partial evaluation bibliography anonymous ftp sestoft mix programs form term rewriting systems bondorf visit nj researchers moscow death ershov breakthroughs journal self applicable pe lisp symbolic nancy mix simple imperative language gomard nj mix mix generated compiler full detail mix higher order functional languages lambda mix lambda calculus constants gomard nj similix scheme language bondorf invited talk logic computer science nj french ph thesis partial evaluation scheme consel prize winning ph thesis pe typed language launchbury glasgow progress experiments book ceres compiler generator tofte implement hagino categorical programming language framework invited talk icalp nj pe scienti computing ieee computer berlin weise progress american recognition yale conference pepm partial evaluation semantics program manipulation people sigplan notices tutorials invited talks pepm tutorial yale launchbury popl tutorial orlando fpca tutorial boston amast algebraic methodology applications software methodology nj better understanding types compilers interpreters partial evaluators compiling sizable lazy language denotational semantics scheme rgensen partial equivalence relations bta hunt sands pe object oriented language steensgaard release similix partial evaluator scheme bondorf rgensen anonymous ftp widely fetched user manual binding time debugger binding time analysis ecient type inference henglein progress experiments pepm workshop san francisco self applicable pe subset andersen self applicable pe pure calculus mogensen ecient bta analyses similix bondorf rgensen pepm conference copenhagen popl tutorial consel danvy book prentice hall partial evaluation nj gomard sestoft prolog subset bondorf mogensen sml mix subset standard ml birkedal special issue pe functional programming special issue pe logic programming pepm workshop orlando self applicable odel partial evaluator gurr bristol essence driving pe nj pe ansi strictly conforming andersen pe fortran subset vienna gl supervisor specializer generation gl rgensen pepm conference san diego book mit press partial evaluation consel danvy andersen program analysis specialization programming language 
diku department computer science university copenhagen 
diku report 
baier gl partial evaluation numerical programs fortran 
acm sigplan workshop partial evaluation semantics program manipulation 
report university melbourne australia 
beckman partial evaluator programming tool arti cial intelligence 
berlin weise compiling scienti code partial evaluation ieee computer december 
birkedal partial standard ml 
diku department computer science university copenhagen 
diku report 
bj rner ershov jones eds partial evaluation mixed computation 
proceedings ifip tc workshop denmark october amsterdam north holland 
bondorf danvy automatic recursive equations global variables data types science computer programming 
consel new insights partial evaluation experiment ganzinger ed esop nd european symposium programming nancy france march lecture notes computer science vol 
pp 
berlin springer verlag 
de de partial evaluation polymorphically typed functional languages representation problem 
eds analyse en programmation logique bordeaux france vol 
pp 
rennes irisa 
ershov mixed computation potential applications problems study 
theoretical computer science pp 

futamura partial evaluation computation process approach compiler compiler systems computers controls 
robert gl andrei occam razor metacomputation notion perfect process tree 
static analysis proceedings eds 
cousot falaschi fil 
lecture notes computer science pp 
springer verlag 
automatic construction special purpose programs loveland ed th conference automated deduction new york usa lecture notes computer science vol 
pp 
berlin springer verlag 
gomard jones partial evaluator untyped lambda calculus journal functional programming january 
gurr self applicable partial evaluator logic programming language odel ph thesis university bristol 
jones ed semantics directed compiler generation aarhus denmark january lecture notes computer science vol 
berlin springer verlag 
jones schmidt compiler generation denotational semantics jones ed semantics directed compiler generation aarhus denmark lecture notes computer science vol 
pp 
berlin springerverlag 
jones sestoft experiment partial evaluation generation compiler generator 
jouannaud ed rewriting techniques applications france 
lecture notes computer science vol 
pp 
berlin springer verlag 
jones automatic program specialization re examination basic principles bj rner ershov jones eds partial evaluation mixed computation pp 
amsterdam north holland 
neil jones gomard sestoft partial evaluation automatic program generation prentice hall international series computer science 
jones constant time factors matter acm symposium theory computing acm press homer ed 

jones essence program transformation partial evaluation driving logic language computation festschrift honor satoru edited sato jones hagiya pages april 
rgensen generating compiler lazy language partial evaluation nineteenth acm symposium principles programming languages albuquerque new mexico january pp 
new york acm 
launchbury projection partial evaluation cambridge cambridge university press 
compiler generator produced self applicable specializer surprisingly natural understandable structure bj rner ershov jones eds partial evaluation mixed computation pp 
amsterdam north holland 
approach automatic partial evaluation full prolog debray hermenegildo eds logic programming proceedings north american conference austin texas october pp 
cambridge ma mit press 
morten heine rensen robert gl neil jones unifying partial evaluation deforestation supercompilation gpc 
european symposium programming esop 
lecture notes computer science springer verlag 
valentin turchin concept supercompiler 
acm transactions programming languages systems pp 
july 
tofte compiler generators 
probably volume eatcs monographs theoretical computer science berlin springer verlag 
earlier version diku report diku university copenhagen denmark 
philip wadler deforestation transforming programs eliminate trees 
european symposium programming esop 
lecture notes computer science pp 
nancy france springerverlag 
