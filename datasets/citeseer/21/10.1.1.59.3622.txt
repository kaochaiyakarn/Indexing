unison 
formal specification implementation file synchronizer benjamin pierce university pennsylvania vouillon cnrs technical report ms cis department computer information science university pennsylvania february file synchronizer tool reconciles disconnected modifications replicated directory structure 
trustworthy synchronizers difficult build deal correctly semantic complexities file systems unpredictable failure modes arising distributed operation 
hand synchronizers packaged stand user level utilities intended behavior relatively easy isolate functions system 
combination subtlety file synchronizers attractive candidates precise mathematical specification 
detailed specification particular file synchronizer called unison sketch idealized implementation specification discuss relation idealized implementation actual code base 
gradual shift users computer computers user accompanied significant increase replication important data 
replicating data ensures availability periods disconnected operation reduces latency connected operation helps protect loss due system failures user errors 
increase replication comes inevitably problem propagate updates replicas 
tightly coupled systems issue addressed conservative schemes preserve single replica semantics systems parts continue operate disconnected designers rely optimistic strategies achieve acceptable performance availability 
schemes allow concurrent updates replicated data reconciled automatically propagating non conflicting changes replicas detecting resolving conflicting changes 
tools system components perform sort reconciliation generically called synchronization reconciliation technologies come forms distributed filesystems operating systems databases middleware layers pda managers laptop synchronizers focus subcategory file synchronizers lightweight user level tools job maintain consistency replicated directory structures 
file synchronizers similar ways big brothers distributed filesystems fact user level programs means run special access operating system structures generally invoked explicitly users working transparently background 
engineering file synchronizer challenging task 
reason synchronizer deal semantic complexities low level quirks real world filesystems 
file synchronization inherently distributed task demanding robust operation face range possible host network failures 
correctness critical issue misbehavior corrupt arbitrary user data 
designed implemented file synchronizer called unison 
modest beginnings mid unison grown mature tool sizeable tens thousands user community high ambitions portability robustness smooth operation different os filesystem architectures 
unusual feature unison history engineering system proceeded parallel serious effort specify behavior mathematically 
main contribution simple precise specification unison phrased terms implementors users understand 
core specification earlier specification pierce extends generalizes respects discussed detail section 
second contribution careful discussion modeling gap specification implementation hand actual unison code base 
gaps fact life specifications full blown systems programs generally complex messy formalize full detail 
render specification implementation meaningless imply formal artifacts supplemented significant engineering insight increase confidence actual code 
address issues section 
final contribution implementation illustrating lines code main data control structures full scale implementation 
complete implementation appendix carried formalized machine checked proof coq proof assistant implementation satisfies specification describe outline proof 
survey related section 
sections develop core specification properties 
section sketches implementation proof correctness section discusses modeling gap real implementation 
section shows basic model extended handle file meta data 
section describes implementation extended deal possibility failures synchronization 
section describes ongoing 
appendix presents code implementation 
www cis upenn edu unison 
related implementation level large body research optimistic concurrency control distributed databases filesystems operating systems related 
goals systems especially distributed filesystems similar unison 
main differences synchronization operations intended transparent user built os packaged user level tools adopt operation approach synchronizer see trace filesystem activities just final state moment synchronization 
rumor reconcile hand user level synchronizers share static approach 
systems go unison providing multi replica synchronization unison works just replicas comes precise specification behavior 
design space synchronization techniques emphasis operation approaches discussed excellent survey saito shapiro 
level specifications main focus previous synchronization sparser 
early specification file synchronizer reported pierce 
specification reformulated elegant algebraic style ramsey 
extends generalizes earlier specifications respects 
presents unified specification synchronizer behavior user point view 
major phases synchronization update detection reconciliation specified separately connected notion dirty predicates possible behaviors synchronizer difficult calculate specification 
second specification deals explicitly possibility system failure synchronization notion maximality section 
earlier specification simply gave synchronizer nondeterministic choice range outcomes 
third specification simpler data structure filesystems section 
enables simple specification synchronizer core behavior section refined specification dealing file metadata section common notation framework 
implementation machine checked proof correctness discussion modeling gap actual unison codebase new 
specification plays central role project microsoft research 
ambitious effort unison aiming just synchronize filesystems construct reconciliation middleware platform arbitrary synchronization aware application programs 
specification parameterized collection application actions accompanying notions conflict 
major difference discussed section operation 
operation implemented coworkers uses idea operation transformation operation performed user replicas propagated calculating appropriately modified version account operations applied replica 
session guarantees developed context bayou replicated storage system superficially similar synchronization laws section different detail specifying precise behavior synchronization operation take replicated storage system black box provide layer top presents manageable semantics application writers 
session sense abstraction sequence read write operations performed execution application 
idea guarantees read writes monotonic reads writes follow reads monotonic writes applications view database consistent actions read write potentially inconsistent servers 
results operations performed session consistent model single centralized server read updated concurrently multiple clients 
different area specification standard proposed industrial consortium computer pda manufacturers including panasonic nokia eriksson motorola palm ibm lotus 
protocol specification system specification mainly concerned making sure devices engaging synchronization operation speaking language constraining outcome operation 
major difference deals flat record structures mappings atomic record identifiers records simple data 
multiple data formats different devices related cross platform goals supported application specific mappings regarded outside purview specification 
design choices probably significant choice unison design making user level tool building coupling closely operating system 
factors motivated choice 
user level synchronizers easier build deploy synchronization components distributed filesystems stand rest filesystem interact apis user programs relative isolation system components eases specification task 
second user level tools better suited heterogeneous settings wanted address building cross platform synchronizer involves extending kernels operating systems 
third user level synchronizers interesting subject research common category tools real world far received little direct attention literature distributed systems formal specifications 
choice consider synchronizers user level programs imposes important constraint behavior 
generally possible portable fashion user programs get access log trace updates filesystem 
synchronizer runs information available current contents replicas plus information may saved run 
user level synchronizer maintains record synchronized state replicas avoid ambiguities creation replica deletion 
leads view synchronization task matter reconciling merging current states replicas 
operating system level synchronizers contrast operation leading view synchronization question merging traces actions different replicas 
different perspectives lead different synchronization behave 
example framework synchronization defined operation pairs traces produce single new trace incorporating actions possible input traces 
synchronization put replicas state resulting applying merged trace common state user updates may undone process traces partly incompatible 
unison hand focuses trying reconcile states traces leads different compromise take primary responsibility protecting user changes overwritten synchronizer cost leaving replicas different states synchronization 
having adopted static view synchronization task simplify specification static view filesystems 
represent filesystems labeled trees internal nodes directories leaves files labels filenames 
view synchronizer simple function trees representing current states replicas inputs producing trees synchronized replicas outputs 
course view abstraction reality synchronizers run live filesystems may modified concurrently processes 
validate abstraction required level implementation 
point discussed section 
issue concerns treatment user interface 
file synchronizers unison provides user interface allows user examine override recommendations replicas changed 
specification simply ignores user interface assumes synchronizer run batch mode non conflicting changes automatically propagated action taken conflicting changes 
essence consider user interface completely separate tool just happens compiled binary core synchronizer convenience loosely integrated operation 
simplifying specification view effect code base leads architecture complexities user interface code kept rigorously separate complexities synchronization logic 
final limitation specification implementation unison address case exactly replicas synchronized 
extension multi replica synchronization discussed section 
basic definitions speak rigorously synchronization need precise notations filesystems operations 
give filesystem node sort writing set sorts 
core definitions correctness conditions assumptions treatment helps keep things simple facilitates uniform treatment file contents metadata 
basic synchronizer take sorts just directory written dir file contents written file 
come synchronizing filesystem metadata section add sorts representing permission bits modification times refine atomic files pseudo directories nodes new sorts children 
assume set filenames just names 
intuitively names thought ordinary filenames section enrich special names perms children pseudo directories representing files 
definition filesystems instantiated simple refined variants needed simply changing sets filesystem just filesystem unordered tree nodes labeled sorts edges labeled names 
formally set filesystems smallest set node 
note take children directory total function names filesystems extend filesystems absent element 
equivalently omit take partial function 
formulation streamlines development allowing creation contents change deletion treated uniformly 
variables range filesystems 
convenient talk contents filesystem path 
formally path just sequence names 
write empty path path formed prepending name write sub filesystem rooted defined follows node 
need kinds comparisons filesystems 
say filesystems root sort written node node sort second write mean filesystems structurally equal standard sense names node node 
core specification discussed section specification phrased completely static terms filesystems just trees synchronizer viewed function maps pairs trees pairs trees focus attention states replicas synchronization ignoring actual sequences low level filesystem operations take case synchronization remote hosts way commands performing operations sent network 
picture precise need refinements 
deal create delete ambiguities 
inputs synchronizer current states replicas example way tell replicas new file contents ag created replica existing file deleted replica dir file ag file cl replica dir file cl replica know change propagate synchronizer needs know common original state replicas diverged 
example knows original state dir file ag file cl see changed 
reason state synchronizers store kind archive synchronizations describing synchronized state replicas archive provided additional input synchronizer 
precise information stored archive varies synchronizer essentially just filesystem 
archive useful resolving create delete ambiguities 
gives clean definition change filesystem simply say path changed replica compared archive root subtree labeled sort root subtree 
second refinement follows fact synchronizers may fail want specification apply case failure 
obviously demand synchronization fail talking distributed program 
just obviously want allow arbitrary outcome fails mid synchronization 
failures may prevent synchronizer completing set inputs may general lead possible outputs regard synchronizer relation function inputs outputs 
formally specification phrased set properties satisfied run correct synchronizer run tuple filesystems representing original synchronized state states replicas just synchronization states replicas synchronization 
brevity define property locally state means property hold just root nodes filesystems demand property hold locally sub filesystems avoids cluttering properties quantifications paths 
propagation changes property correct synchronizer satisfy overwrite change user 
requirement formalized follows run said preserve user changes locally strictly speaking input output purposes specification elide new archive calculated unambiguously new states replicas 
discuss point detail section 
different sorts root user changed filesystem root synchronization synchronizer leave root sort unchanged result similarly replica example sort file ag dir sort post synchronization replica dir 
hand sort file ag may different sort file cl 
condition states correct synchronizer change replicas copying changes user run said propagate user changes locally synchronizer changes sort root filesystems differs value may safely change sort root filesystem agree replica 
example sort file ag dir original replica sort dir 
treatment conflicts delicate point unison specification definition conflicts 
naturally expect changing file node different ways result conflict dir file ag file cl archive dir dir file fe file cl replica file cu file cl replica deleting file replica changing contents dir file ag file cl archive dir dir file cl replica file cu file cl replica reassuring guarantee able users interestingly synchronizers built microsoft windows file sharing service obey constraint simply overwrite version earlier timestamp 
choice reflects assumption better faced conflict assumption justified scale systems intended deployed tens thousands replicas just 
file changed simultaneously calcutta san francisco incompatible changes meet machine am conflict reported 
creating new file different contents 
dir file cl archive dir dir file fe file cl replica file cu file cl replica synchronizer behavior cases completely determined condition replicas changed user changed synchronizer 
filesystems tree structured cases consider 
example suppose replica change contents file delete file parent directory dir dir file ag file cl archive dir dir file fe file cl replica replica different synchronizers treat situations variety ways 
unison adopts conservative approach defining case conflict refusing take action explicit instructions user 
leads definition conflict 
say conflict written conflict 
filesystems conflict roots labeled different sorts dir example replicas changed path example 
note kinds equality definition root label equality tree equality third safety condition straightforward 
run said conflicts locally conflict 
dir conflict recognized path synchronizer allowed change replica 
example conflict occurs path synchronizer 
note omitted third condition conditions prevent synchronizer doing paths permit delete sibling file replica synchronizers exhibit behavior find counterintuitive feel just signalling conflict safer 
safety extend local versions properties filesystems saying synchronizer run property globally path run property locally 
note need consider paths may valid filesystems involved 
example want prohibit modification synchronizer 
technically convenient simply quantify paths 
state harm property want synchronizer obey 
definition run said safe written safe satisfies properties preserves user changes propagates user changes stops conflicts globally 
maximality safety conditions give clear specification synchronizer may commit doing identity function safe synchronizer 
course want synchronizer runs harm failures occur useful possible 
intention captured notion maximality 
say run maximal safe similar possible safe safe run leaves sorts path equal maximal run leave equal 
words maximal run propagates non conflicting changes 
iterated synchronization intend run synchronizer times interleaved changes replicas archive input output run original state run synchronizer calculated final state run 
calculation new archive trivial possibility conflicts 
synchronization completely successful simply take filesystem new archive 
run encountered conflicts need update synchronized state just files synchronization succeeded retaining previous synchronized state paths left unequal 
precisely path new replicas agree take common value contents path archive agree copy contents input archive formally expressed run tuple filesystems 
extend conditions new type runs trivial way ignoring add final condition specifying calculated run returns correct archive locally brevity rest ignore refinement revert old place notion runs 
properties specification going worthwhile state properties specification sanity checks definition deepen understanding implications 
theorem laziness safe run safe 
proof observe run satisfies local properties easily verified case 
theorem mirroring special case run maximal 
proof clearly run maximal safe 
check safety proceed previous proof 
theorem maximal runs unique unique maximal 
proof sketch suppose maximal runs 
definition maximal runs particular local safety properties argue symmetry definition gives theorem success absence conflicts path conflict exists filesystem run maximal 
proof induction size take maximal 
know conflict cases done run maximal 
apply induction hypothesis form 
exists function maximal 
take node common sort easy check maximal 
implementation specification described provides concise description intended behavior file synchronizer 
know particular synchronizer implementation unison satisfies specification 
unison lifetime best answer query don know implementors understood specification tried hard write code satisfy writing decided try little ambitious 
extracted current unison code base implementation keeping essential control data structures abstracting away low level complexities real filesystems networks specification filesystems represented simple tree structures network ignored major improvement didn precise specification mind thought hard coding decisions reasonable time 
completely assume filesystems archive inputs top level synchronization function 
proved implementation satisfies specification 
implementation straightforward lines ocaml code complete version nontrivial functional program 
unison works phases update detection reconciliation propagation updates 
sake brevity simplified core actual implementation omitting file directory metadata symbolic links modeling failures concurrent filesystem updates synchronization 
extensions needed handle metadata failures outlined sections 
update detection function compares archive filesystem returns data structure uia describing differences archive filesystem 
phase performed separately replicas 
separation important practice replicas separated slow network need avoid transmitting contents replica network 
achieve storing copy archive host doing update detection locally sending just description changes 
reconciliation function reconcile uses update information computed previous step build set transport instructions describing path replica replaced corresponding subtree replica 
propagation function propagate performs actions original filesystems transport instructions act returning updated filesystems reason performing reconciliation propagation separate steps full version unison inserts user interaction phase displaying transport instructions giving user opportunity verify desired override unison recommendations changes propagated 
pieces combined follows give top level synchronization function 
sync uia uib act reconcile uia uib propagate act give detailed picture job performed phase useful look data structures flow phases 
structures similar actual unison codebase 
inputs update detection phase synchronization current replicas archive 
filesystems defined follows 
define abbreviations name contents represented strings types path names file contents 
type name string type contents string filesystem directory represented tag dir plus list pairs names file represented file plus string represented bot 
bot case represent complete absence information missing archive completely replica 
type fs dir file contents bot name fs list function takes filesystems archive replicas returns representing difference 
define type define enumerated type describing filesystem previously contained location 
type dir file absent tree structure corresponding modified part replica 
subtree corresponding part filesystem identical updated describing difference filesystems describing contents filesystem error signalling non fatal error happened update detection real implementation instance unreadable file 
may different forms depending new contents replica point 
case directory contains list pairs name corresponding children 
case file gives new contents 
type updated error contents name list function takes replica returns representing actions need performed bring replicas agreement close possible full agreement 
define type define enumerated type describing direction propagation take place 
equal correspond null action provide information reason action take place provided user 
type direction conflict equal tree structure indicating location filesystem need modified 
transport instruction type associated node tree 
actual instruction instr dummy instruction case needs done location dummy instruction problem indicating synchronizer know done location error occured update detection 
update items replica direction associated instruction 
propagation agent uses check destination modified update detection propagate changes 
type instr direction problem type node name list informally sketch correctness proof 
state correctness implementation pick particular instantiation definition filesystems give sets sorts labels provide abstraction function mapping concrete filesystems ones 
bare bones filesystems implementation sorts need directory written dir file contents written file 
dir file contents take set labels exactly set concrete names names 
define auxiliary function lookup ch yield concrete filesystem associated association list ch bot 
abstraction function fs defined follows bot dir ch node dir names 
lookup ch file node file names 

say accurately transforms filesystem fs filesystem fs information accurate information patch fs fs 
write mean evaluation yields result lemma fs fs ui ui accurately transforms fs fs proof sketch induction fs case analysis corresponding nodes fs fs filesystem act action tree apply left act denotes filesystem obtained applying right left updates described act apply right act denotes filesystem obtained applying left right updates described act say valid filesystems accurately transforms corresponding filesystem lemma reconcile uia uib act uia uib accurately transform filesystem respectively run maximal act valid 
apply left act apply right act proof sketch induction uib 
lemma propagate act act valid run maximal maximal 
apply left act apply right act proof sketch induction act 
theorem sync maximal 
proof composing lemmas 
sketch assumes errors occur synchronization 
proved stronger theorem full implementation asserts run safe errors occur update detection transport 
connection implementation actual unison codebase informal abstractions embodies validated means engineering insight 
insight required quite local discuss section verification step manual demanding checking full blown unison implementation meets specification 
believe connection implementation real proceed completely formal machine checked manner 
demonstrate formalized implementation set inductive definitions language coq proof assistant showed satisfies conditions sections formalized proofs properties specification section 
nontrivial difficult exercise formalization proof script development requiring weeks effort experienced coq programmer increasing confidence unison implementation formalization exercise revealed subtle bug unison treatment failures previously noticed cases failure reported times just file occurred directories containing file 
general felt effort put formalization exercise results 
modeling gap fully specifying verifying real world system program unison size complexity proving actual codebase meets specification task 
require things precise specifications posix filesystem socket apis gtk user interface toolkit 
hand program unison complexity difficult get right precise specification guide design 
building rebuilding unison years tried steer middle way working seriously days week mathematical specifications implementations writing code days living fact gap activity 
obvious difference real implementations implementation functional program takes replicas archive arguments returns new versions result real imperative modifying real filesystems place 
sense difference purely stylistic 
implementation exploits fact updates path filesystem old version filesystem available filesystems treated linear fashion functional updates just implemented real place updates 
compiler sophisticated type analyzer literally 
difference functional imperative formulations correlated problematic distinction implementation written owns filesystems synchronization real implementation runs live filesystems actions users programs may modify replicas unison working 
unison addresses discrepancy noticing concurrent modifications taken place signaling failures paths 
looks path replica just update detection happens quite bit practice people unison manage multi gigabyte replicas update detection take minutes 
users start unison leave performing update detection forget telling go ahead propagate changes 
extracts information needs looks filesystem moment contents path propagated replicas final phase synchronization 
point double checks just making change path replica contents path replicas detected updates 
note double check completely reliable possible modifies file just safety check change propagated cost building unison portable user level program 
note quite snapshot filesystem update detection process look different files different times difference confusing users 
related issue real implementation operates real file systems posix system calls file descriptors inodes implementation regards filesystems simple mathematical tree structures inspects manipulates directly 
time difference cause serious confusion place real implementation inspects modifies real filesystem check locally doing corresponds action idealized implementation structure point 
times operation easy express implementation hard impossible implement terms operations provided mainstream operating systems 
example unison propagates change file writes new data temporary file comes network file arrived uses rename system call move place atomically 
unfortunately atomic rename works certain circumstances 
windows systems new name refer moment rename called rename fails unix new name may refer existing file deleted side effect existing directory 
general new version file moved place old file deleted renamed backup version 
host happens crash system calls replica left path violating specification 
obviously better assumed persistent storage substrate kind ensure durability transactions databases 
unfortunately unison designed run ordinary application program crashed simply killing process straightforward way ensure executed soon process transaction log take appropriate action user chance observe filesystem inconsistent state 
final difference implementation real implementation treats archive full blown filesystem real implementation stores just fingerprint file contents 
consequence safety properties contents file final filesystem comes initial filesystems synchronizer needs archive checking updates 
means need keep contents long retain information tell files changed keeping cryptographic fingerprints contents file allowing detect modifications high confidence 
dealing metadata unison matured user base grew requests began arrive variety new features 
large proportion handling various sorts metadata properties files just contents permissions user ids group ids modification times esoteric properties spelling filenames systems windows capitalization names insignificant reading writing files significant listing contents directories 
positive effect working specification parallel implementation slowed process engineering features making reluctant add piece functionality understood effect specification behave cases full interactions existing features 
process exposes natural tension users generally care feature behave cases long gives behavior want case stopping getting done moment developers deal long term consequences quick hacks 
obvious ways think metadata associated file directory take metadata simply part contents files consider metadata separate independent contents 
lead different views synchronizer propagate changes particular leads different definitions conflicts 
take file metadata part contents example changing file byte replica making world writable replica lead conflict just conflict changed file byte replica second byte 
consider metadata completely independent contents scenario expect synchronizer propagate contents change direction permissions change 
unison chooses middle way feel combines virtues extreme views keeping program behavior easy understand avoiding spurious conflicts 
regard file contents metadata atomic unit purposes propagating changes purposes defining conflicts 
require file contents metadata equal synchronization starting state replicas part metadata modified identical way replicas contents modified just replica conflict registered synchronizer allowed propagate contents update 
specification section easily refined allow behavior 
define atomicity predicate atomic sorts atomicity extended filesystems saying atomic written atomic node atomic 
add new constraint definition safety 
run said respect atomicity locally atomic atomic 
note property satisfied atomicity predicate constantly false 
original specification special case refined 
instantiate refined specification introducing set properties file directory metadata 
set sorts defined follows dir file contents pr pr properties pr pr properties define predicate atomic atomic file true atomic false sorts 
ensures changes contents file associated meta data treated atomically changes directory metadata treated independently changes directory children 
define set names set filenames plus special labels contents props names contents props 
treatment meta data introduces new issue modeling gap discussed section specification implementation assume file metadata modification times permission bits semantically disjoint file contents real filesystems case 
cases meet specification special properties metadata 
example unison finds needs create file readonly directory directory side writable file created directory read way create file directory briefly writable repository program crashes just moment filesystem left incorrect state directory properties corresponding starting properties replica 
current version unison simply fails case making directory writable side 
note failure satisfy specification result maximal benign result safe 
modeling failure close sketching refinement implementation modeling various sorts failures synchronization 
possible sources failure synchronizer subject network problems transient filesystem problems user interruptions concurrent updates synchronization bugs failures quite common practice critical synchronizer behave safely predictably occur 
unison implementation goes considerable effort avoid misbehaving case failures able claim succeeds 
full implementation formalized proof incorporate model run time failures 
real unison implementation distinguish categories failures 
transient failure unreadable file local path handled simply skipping path 
synchronization paths continued safely 
fatal errors hand unexpected failures synchronizer bugs instance disastrous conditions user interruptions permanent network problems 
option cases display diagnostic message exit leaving filesystem archive clean state 
extension implementation models transient errors fatal ones 
extended handle fatal errors cost readability 
done practice fatal errors simpler think 
protect need sure moment execution state replicas disk archive satisfies safety conditions specification explicitly recorded fact briefly breaking described section 
property implementation follows modeling transient failures moment state replicas satisfy safety conditions specification possible subsequent update operations may encounter transient failures 
transient errors hand get incorporated unison data structures dealt explicitly downstream code 
implementation augmented deal failures inserting explicit failure checks point operation performed real implementation fail 
enforce constraint points annotated checks established straightforward inspection code implementation 
details modeling failures appendix discussed unison cross platform capabilities 
fact surprisingly large fraction engineering implementation gone tricky problems synchronizing filesystems hosted different operating systems particular posix win filesystems 
experimenting extending specifications setting 
discussion engineering issues involved unison addresses important direction extending specification ideas case multi replica synchronization 
principle unison purpose replicas brought agreement performing pairwise syncs 
practice method tends cumbersome small number replicas 
fact unison stores archive pair replicas lead spurious conflicts replicas modified pairwise synchronizations finished 
generalizing multiple replicas demands deeper re examination basics specification particular archive replaced notion common state tempting try enforce failure checking points required 
try replacing direct manipulation concrete tree datatype filesystems calls filesystem api implementation incorporate required failure checks 
correctness proofs complex 
possible write terminating functions coq 
termination function traversing filesystem recursively obvious filesystem concrete inductive data structure harder see filesystem treated abstractly 
derived causal history system 
step appears straightforward outline involves significant novelties compared past causal histories realization structures vector clocks 
particular standard treatments causal history consider agreement events synchronizer recognizes equal replica states synchronized independent relation previous synchronized state causally independent states considered conflict 
consequences adding events standard account clear mechanisms version histories hash histories related studied far mainly perspective algorithms efficient implementation behavioral specifications 
final direction concerns synchronization structures filesystems 
current project dubbed harmony www cis upenn edu harmony aims extend intuitions developed unison synchronization arbitrary tree structured data example xml documents 
main collaborator unison system trevor jim contributed ideas specification 
worked earlier synchronizer specification contributed ideas 
discussions peter druschel sylvain michael greenwald anne marie kermarrec sanjeev khanna james leifer norman ramsey antony rowstron marc shapiro alan schmitt yang participants unison users mailing list deepened understanding synchronization 
careful readings earlier drafts jon moore alan schmitt helped improve presentation 
pierce unison supported nsf ccr itr principles practice synchronization 
vouillon supported fellowship university pennsylvania institute research cognitive science ircs 
complete implementation appendix presents synchronizer implementation full form complete executable objective caml program 
actual machine checked implementation collection inductive definitions coq 
ocaml syntax coq familiar readers 
ocaml code shown obtained automatic translation coq definitions followed little manual tidying readability 
modeling failure action monad described section implementation models transient failures file read errors decorating operation fail real implementation call failure check function 
synchronizer parameterized function errors time represented integer counter booleans 
errors int bool checking error occurs particular operation consists applying errors function current time increasing time 
say error occurred synchronization error function returns true time synchronization 
implementation functional program current time needs threaded function calls returns 
notational burden threading mitigated encapsulating time type reorganizing code monadic style time passed implicitly automatically incremented time errors called 
specifically encapsulate time action type assume existence functions manipulate actions 
assume evaluation function eval performs action takes action starting time action returns pair containing time action result evaluation action eval action int int action testing error increments time returns boolean indicating error time action performed 
assume function test bool action satisfies equation eval test errors 
ways creating action 
define action evaluating expression operator 
return action eval return 
actions performed sequence bind operator bind action action action satisfies property eval eval eval bind 
bind operator understood intuitively binding expression bind fun corresponds keeps track time 
proof correctness implementation concrete definitions functions bind test return eval left unspecified proof relies axioms 
ensures proof guarantees safety arbitrary failure scenarios 
course want experiment implementation supply definitions functions 
example trivial implementation generates errors type action bind action action test action false return action eval action int interesting implementation generates transient error fifth operation type action int int bind action action fun int test bool action fun int mod return action fun int eval action int filesystems inputs update detection phase synchronization current replicas archive 
filesystems defined follows 
define abbreviations name contents properties represented strings types path names file contents file properties 
type name string type contents string type properties string filesystem directory represented tag dir plus pair properties list pairs names sub filesystems file represented file plus pair properties contents symbolic link represented symlink plus contents represented bot 
type fs dir properties file properties contents symlink contents bot name fs list point implementation precisely follow general formulation proposed section 
file directory properties built directly file directory nodes filesystem 
done formulation related general means abstraction function 
formally bother ensuring set assume may contain duplicate bindings single name bindings ignored 
utility functions filesystems useful 
returns filesystem associated name directory contents rec assoc match bot fs rem fs assoc rem function returns filesystem contained path filesystem rec match assoc match dir pr function reverse reverses path just standard polymorphic list reverse rec reverse match reverse function mem checks child named list name filesystem pairs rec mem match false fs rem mem rem update detection function takes filesystems archive replicas returns representing difference 
define type define enumerated type describing filesystem previously contained location 
type dir file symlink absent function associate filesystem state root 
function dir dir file file symlink symlink bot absent records modification leaf replica property content modification 
case corresponding part filesystem identical pair new value old value case modification 
type option tree structure corresponding modified part replica 
subtree corresponding part filesystem identical updated describing difference filesystems describing contents filesystem error signalling non fatal error happened update detection real implementation instance unreadable file 
may different forms depending new contents replica point 
case directory contains properties list pairs name corresponding children 
case file contain properties contents 
case symlink contain contents 
type updated error properties properties contents contents name list define required operations need couple utility functions 
generic function remove takes argument key list key value bindings returns list bindings key removed 
rec remove match ui rem remove rem ui remove rem utility function deletions generates list representing fact files list deleted 
rec deletions match bot rem remove deletions rem fs rem updated fs deletions rem main update detection function takes archive filesystem fs returns appropriate 
action check error return special 
considers root filesystem fs accessed builds pattern matching state filesystem archive archive 
case current filesystem contains directory uses recursively process contents directory 
rec archive fs bind test fun err err return error match archive fs dir pr dir pr bind fun uch pr pr pr pr uch return return updated uch dir dir pr bind fun uch return updated pr uch archive file pr file pr pr pr pr pr uc uc return return updated uc file file pr return updated pr archive symlink symlink return return updated archive symlink return updated archive bot bot return bot return updated archive match return deletions fs rem bind assoc fs fun ch bind rem fun uc rem remove uc ch return rem return ch rem note yields minimal tree mentioning paths updates occurred 
instance directory mentioned tree properties changed children updated 
important keep tree small actual implementation replicas transmitted network order compared reconciliation step 
reconciliation reconcile function takes replica returns representing actions need performed bring replicas agreement conflicts errors close possible full agreement 
define type define enumerated type describing direction propagation take place 
type direction conflict equal directions conflict equal direct phase transport take action particular path distinction provides information reason action take place actual implementation displayed user 
tree structure indicating location filesystem need modified 
transport instruction type associated node tree 
actual instruction instr dummy instruction case needs done location dummy instruction problem indicating error occured update detection 
update items replica direction associated instruction 
propagation agent uses check destination modified update detection propagate changes 
type instr direction problem type node name list function takes transport instruction act argument checks update items associated instruction contain error 
error transport instruction returned problem returned 
function checks update item ui contains error 
rec ui match ui updated uch uch error true false uch match uch false ui rem ui rem act match act instr ui ui ui ui problem act act function handles case replicas changed needs done just copy current state replica 
argument type side indicates source replica 
type side left right ui match left instr ui right instr ui rec ui match ui node updated uch dir act match ui node act uch updated node ui error node problem uc match uc ui rem ui rem note function called instructions corresponding locally updated directory 
case property part 
functions generate instructions leaf updates 
function decides direction update take place 
function computes direction corresponding distinct updates file content update file property update 
match equal conflict equal match conflict conflict conflict equal equal equal utility looks association lists returns associated name list children exists 
rec uch match uch ui rem ui rem top level function reconciliation phase reconcile takes update items representing updates occurred replicas respect synchronized state returns structure applied replicas explained subsection yield new replicas close synchronized possible 
proceeds cases top nodes construct simply copies state replica top changed updated directories calls recursively deal contents files uses appropriately atomically combine changes contents properties signals conflict 
function handles directory contents modified second replica calls helper function handle contents modified left replica 
rec reconcile uia uib match uia uib error error node problem left uia right uib updated upa updated act upa instr uia uib upa node act updated upa updated ucb node instr uia uib ucb upa updated updated ucb node instr uia uib ucb node instr uia uib conflict match ui rem reconcile ui rem match ui rem match left ui rem rem propagation final phase propagation takes calculated applies current replicas 
possibility concurrent updates replicas synchronization real implementation goes considerable trouble paranoid possible propagating updates 
blindly overwriting replica new contents transfers new information temporary file directory structure host double checks current contents replica exactly update detection performed moves new information final position 
double checking process modeled implementation providing inputs top level synchronization function see section archive replicas filesystems representing states replicas just moment propagation begins 
propagation code section update items replicas construct predicted current replicas compares current replicas function takes archive update item ui computes expected contents replicas starting archive update item corresponding modified replica compared archive contents 
helper function performs update leaf file contents properties value match rec ui match ui updated bot updated uc file pr file pr uc updated pr file pr updated symlink updated uch dir pr ch dir pr ch uch updated pr uch dir pr uch ch uch match uch ch ui ucs assoc ch ui ch remove ch ucs bot ch ch function checks source filesystem contains path filesystem path immediately contained directory 
note conflict condition satisfied 
match true match dir true false bot helper function reads copy archive filesystem current filesystem returns inside 
reason take trouble perform copy just directly real implementation archive stored compressed form cryptographic fingerprints place full file contents 
job copy reconstruct full filesystem corresponding 
rec match dir pro cho dir pr ch pro pr match ch cho ch dir pr ch file pro file pr pro pr symlink symlink bot bot ch ch cho match cho cho mem ch ch ch cho match assoc ch ch ch cho ch ch copy bind test fun err err return match bot return bot return function just change replica verify sanity check current contents matches previous contents recorded transport instruction 
ui bind ui fun updates return updates replace function returns new version input contents path replaced filesystem filesystem returned unchanged error parent directory endpoint path exist 
inner loop function performs additional checking transient errors assume error going happen replacement happens 
words replacement assumed atomic 
rec match dir pr ch dir pr assoc ch remove ch replace bind test fun err err return return reverse path needs reversed simultaneously traverse starting root starts wrong order traversal 
wrapper 
performs replacement target contents source contents specified 
src trg bind copy src fun cpy match cpy bind trg fun replace trg return trg return trg function calculates new properties necessary directory 
ui match ui updated dir pr ch pr dir pr pr function tests properties directory changed recorded update detection 
pr match dir pr ch pr pr false function called update just properties existing directory 
takes arguments returns new version target properties directory path copied source 
contents target directory properties source target changed looked originally return target unchanged 
src trg bind test fun err err return trg match src trg match trg dir ch replace trg dir ch return trg return trg return trg function dispatches depending form update item processing 
src trg match updated src trg src trg main workhorse function update propagation 
path archive current replicas possibly identical update items originally computed transport instruction act act see needs done returns unchanged instruction indicates conflict equal replicas calls perform action 
note assumes changes propagated left right propagate right left exchange senses call 
act match act instr ua ub dir match dir conflict return bind ua ub fun return bind ub ua fun return equal return return main function propagate recursively traverses tree executes corresponding instructions 
helper function recursively calls propagate apply actions paths strictly longer propagate action 
rec propagate function node act ts bind ts fun fs fs act match return act acts bind propagate act fun fs fs acts main program sync binds phases described complete synchronization function 
note takes extra inputs passes propagate modeling possibility concurrent changes replicas update detection reconciliation 
sync bind fun ua bind fun ub propagate reconcile ua ub pierce 
file synchronizer 
fourth annual acm ieee international conference mobile computing networking mobicom oct 
full version available indiana university technical report april 
barras cornes courant 
herbelin huet munoz murthy parent paulin mohring werner 
coq proof assistant manual version 
technical report rt inria institut national de recherche en informatique en automatique france 
birrell levin needham schroeder 
grapevine exercise distributed computing 
communications acm apr 
davidson garcia molina skeen 
consistency partitioned networks 
acm computing surveys september 
demers petersen spreitzer terry theimer welch 
bayou architecture support data sharing mobile users 
proceedings workshop mobile computing systems applications santa cruz california december 
edwards mynatt petersen spreitzer terry theimer 
designing implementing asynchronous collaborative applications bayou 
acm symposium user interface software technology pages 
greenwald moore pierce schmitt 
language bi directional tree transformations 
workshop programming language technologies xml plan jan 
long version available university pennsylvania technical report ms cis 
guy popek jr consistency algorithms replication 
proceedings international conference network protocols october 
howard 
reconcile user guide 
technical report tr mitsubishi electronics research lab 
rusinowitch 
proving correctness transformation functions real time groupware 
proceedings th european conference computer supported cooperative september 
helsinki finland 
jim pierce vouillon 
build file synchronizer 
manuscript available www cis upenn edu papers 
kang wilensky kubiatowicz 
hash history approach reconciling mutual inconsistency optimistic replication 
rd ieee international conference distributed computing systems icdcs 

kermarrec rowstron shapiro druschel 
approach reconciliation divergent replicas 
principles distributed computing podc 
kistler 
disconnected operation distributed file system 
phd thesis carnegie mellon university 
kumar satyanarayanan 
flexible safe resolution file conflicts 
usenix winter pages 
leroy 
objective caml system documentation user manual 
damien doligez jacques didier vouillon 
available caml inria fr 

safe generic data synchronizer 
rapport de recherche loria france may 

transformational approach build safe generic data synchronizer 
proceedings acm group conference november 
sanibel island florida 
page jr guy heidemann ratner reiher goel kuenning popek 
perspectives optimistically replicated peer peer filing 
software practice experience december 
petersen spreitzer terry theimer demers 
flexible update propagation weakly consistent replication 
proceedings th acm symposium operating sosp saint malo france october 
badrinath 
conflict resolution reconciliation disconnected databases 
mobility databases distributed systems florence italy sept 
pierce schmitt greenwald 
bringing harmony optimism synchronization framework heterogeneous tree structured data 
technical report ms cis university pennsylvania 
ramsey 
algebraic approach file synchronization 
proceedings th european software engineering conference pages 
acm press 
reiher 
rumor user manual 
fmg www cs ucla edu rumor 
reiher heidemann ratner skinner popek 
resolving file conflicts ficus file system 
usenix summer conference proceedings pages 
richard 
clique transparent peer peer collaborative file sharing system 
proceedings th international conference mobile data management mdm jan 
melbourne australia 
saito shapiro 
replication optimistic approaches 
technical report hpl hp laboratories palo alto feb 
satyanarayanan kistler kumar okasaki siegel steere 
coda highly available file systems distributed workstation environment 
ieee transactions computers apr 
shapiro rowstron 
kermarrec 
application independent reconciliation nomadic applications 
proc 
sigops european workshop pc new challenges operating system denmark sept 
acm sigops 
www sor inria fr shapiro papers ew html 
new era data synchronization 
www org 
terry demers petersen spreitzer theimer welch 
session guarantees weakly consistent replicated data 
proceedings third international conference parallel distributed information systems pdis austin texas september pages 
ieee computer society 
terry theimer petersen demers spreitzer hauser 
managing update conflicts bayou weakly connected replicated storage system 
proceedings th acm symposium operating systems principles sosp copper mountain resort colorado december 
wadler 
monads functional programming 
broy editor marktoberdorf summer school program design calculi volume nato asi series computer systems sciences 
springer verlag aug 
jeuring meijer editors advanced functional programming springer verlag lncs 

