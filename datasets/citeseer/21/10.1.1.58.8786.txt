resource management open tuple space systems de menezes submitted degree doctor philosophy department computer science august thesis investigates problem resource management memory open distributed implementations linda model 
principal focus research deal problem memory ex implementing garbage collection techniques kernel level linda explicit methods rely users computational languages feasible 
problem explored side effects solution garbage collection 
dissertation shows main problem overcome implementing garbage collection scheme linda lack information processes tuple spaces 
order solve problem graph maintained kernel level necessary information 
ways maintaining graph explored centralised distributed 
construct graph question new techniques proposed pro cess registration checkout tuple monitoring 
techniques form basis graph maintenance kernel level 
model named ligia proposed incorporating techniques implementation model 
looking general solution garbage collection problems related operations apparent 
proving coordination problem solution bring ligia model 
achieved new operation called enables done tuple spaces 
ii contents ii dedication acknowledgments declaration thesis overview 
contributions 
review coordination models implementations 
linda coordination model 
multiple tuple space linda 

york linda 
york linda 
plinda 
bonita 
bauhaus 
laura 
pagespace effort 
iii contents iv javaspaces 
spaces 
garbage collection schemes 
counting 
listing 
tracing 
distributed 
final remarks 
ligia model general description 
universal tuple space 
class tuple space handles 
tuple space 
ordering 
process identifiability 
tuple monitoring 
termination ordering 
final remarks 
incorporation garbage collection garbage collection scheme 
centralised graph structure 
graph general description 
node 
node 
spawning main processes 
process registration 
creation tuple spaces 
creating bridges tuple spaces 
process termination 
retrieving handles tuple spaces 
contents execution primitives 
centralised garbage collection 
distributed graph structure 
building distributed graph 
distributed garbage collection 
counting phase 
local tracing phase 
global tracing phase 
algorithm general description 
final remarks 
coordination input output operations distributed 
garbage collection 
internal aspects 
semantics operations ligia 
operation 
management file spaces 
ligia generalised 
extending abstraction location 
overlapping computation 
distributed files 
fault tolerant file system 
locking records creating gaps 
associative access files 
persistent tuple spaces 
final remarks 
implementation ligia ligia architecture 
server system 
agent system 
contents vi garbage collector 
registering processes 
scoping 
process checkout 
centralised garbage collection 
distributed garbage collection 
system 
final remarks 
experimental results configuration details 
garbage collection 
memory exhaustion 
process registration checkout 
avoiding memory exhaustion 
garbage collection overhead 
hiding overhead 
input output 
general results 
java tuple building 
separate thread 
storing retrieving tuples 
bulk operations tuples 
multi thread servers 
final remarks 
research research 
contributions 
garbage collection 
bringing operations model 
novel run time system 
contents vii closing remarks 
ligia classes definition ligia java classes description 
agent system 
server system 
system 
list algorithms creation processes process registration 
creation tuple spaces 
storing handles tuple spaces 
destructive retrieving handles 
non destructive retrieving handle 
update graph bulk primitives 
process termination 
viii list codes part program 
bonita simulation 
linda program stores tuples removes 
bonita implementation linda example code 
service large specialised shop offering operations 
service licence shop offering operation 
code ligia main process 
code executing different primitives 
sketch processes code part job scheduling problem 
ix list programs pro program process offers service cess request service tuple space 
example ordering behaves differently ligia bonita 
termination ordering 
termination ordering primitive keeps agents create tuple space termination ordering assuming standard semantics 
termination ordering primitive ligia case 
termination ordering primitive 

toy program composed processes 
spawning terminate 
example program tuple spaces specific scope 
modification program introducing scope coordination di 
method java process shown program 
method waits completion thread charge 
java wait implementation waits completion thread 
list tables execution primitive compared execution prim itive 
creation values expected measured real showing scalability ligia objects ligia 
server 
xi list figures pictorial representation formals actuals part tuples matching mechanism 
pictorial representation standard linda 
processes spawned tuple space 
pictorial representation gelernter original multiple tuple space pro 
tuple spaces created inside tuple spaces processes ac tive tuples execute tuple space 
representation flat tuple space structure proposed york linda 
representation flat tuple space structure proposed york linda 
formula time costs original linda primitive 
representation coordination structure 
example illustrating execution primitives 
pagespace architecture ctv 
cyclic garbage created detected counting properly cyclic structures 
invariant weight counting algorithm 
situation indirect weight counting 
xii list figures xiii listing method cell list op posed counter 
illustration problem mutator collector running concurrently possible solution collaborate 
example showing gelernter proposal represent files tuple spaces 
ligia structure tuple space processes 
universal tuple space processes unable commu 
impossible cases ordering termination message primitive 
create boundary separating ligia outside world 
graph situation creation nodes ligia system 
main processes register kernel just start running 
creation tuple spaces 
tuple space linked creator 
execution steps code 
process terminates generating garbage 
possible cases handle retrieval 
pictorial execution code 
tuple spaces garbage collected counting 
tuple spaces garbage collected tracing 
local global collectors cooperating collection objects ing distributed graph structure 
distributed representation graph structure divided loca tions 
pictorial view graph distributed execution operations ligia 
list figures xiv pictorial view graph distributed execution operations ligia continuing 
local counting phase location finds tuple space garbage 
example situation local marking phase system local graphs 
scenario just local tracing phases 
global graph 
result graph marked global tracing phase 
update garbage collection graph operations 
implementation process migration ligia causes problem 
representation file space tuple space terms structure ligia kernel terms fsms 
scenario depicting location free abstraction objects 
execution primitive file space 
dependence graph job scheduling problem 
pictorial view ligia architecture 
number messages generated routing ligia operations 
flow message server system 
structure tuple spaces tuples 
processes running locations server running memory exhaustion ligia server due tuple space creation 
overhead added process registration checkout 
memory exhaustion problem 
overhead added tuple monitoring existence active process representing garbage collector server 
raw garbage collection overhead 
experiment file operations 
creation objects ligia 
list figures xv comparison time taken time observed user sequence performed 
comparison time taken execute followed 
tuple movement 
scalability ligia server relation number processes 
relationship ligia agent classes java classes inter faces 
relationship ligia server classes java classes inter faces 
relationship ligia classes java classes interfaces dedication sarah support help love 
acknowledgments difficult remember forget please give dr alan wood keen help personal problem keeping door office open receptive times knocked 
dr antony rowstron help support innumerable hours spent discussing tea time 
dr colin runciman dr robert tolksdorf comments surely helped improve quality thesis 
friends department computer science specially great friends jos campos paulo pedro ribeiro jr providing friendly environment 
pedro rafael innumerable hours spent chatting telephone bill surely high surely happy 
friends york dominic richardson cesar ortega sanchez paul sparks burnett 
time spent 
jorge braga friendship friend ship bounded land limits 
forget family brothers sisters fl vio fl robson side decisions 
parents fl vio maria carmo basically love list figures 
certainly wife helping re viewing english thesis despite things wife friend 
say son reason life 
declaration thesis result 
substantially re port submitted qualification university 
contents published 
chapter partially published nd workshop distributed sys tems brazil men 
chapter part published th international conference parallel distributed computing systems usa mw th international symposium computer information sciences tur key mw earlier subject published th brazilian computer networks symposium brazil mw 
chapter part published st hawaii international confer ence system sciences usa mw linda web framework directly associated dissertation published 
technical report mw described thesis published department computer science university york 
chapter linda proposed gelernter gel formed basis sever research application projects 
linda introduced concept ty computation coordination gelernter carriero gc proposed separation arguing way build complete distributed lan guage take computation language pascal add coordination 
coordination part distributed language responsible dealing tasks involve process completion tasks include synchronization communication processes 
linda coordination model concept tuple spaces shared associative memories 
communication performed structures concept communication concept synchronization 
apart version linda implementations allow processes create tuple spaces create local memories 
originally proposed linda model parallel computing dis tributed computing means general implementations linda closed implementations 
started noticed intrinsic charac model mentioned orthogonality argument linda interesting distributed computing 
general purpose distributed systems may restricted implemented closed systems open implementations lin da started appear 
far story flowing perfectly 
put con cepts may cause problems 
closed implementations linda system controlled optimisations sorts done compile time information application available linda implementation manage resources best possible way 
concept compile time exist system 
application implemented top open implementation linda 
thesis comes 
open systems general mean heterogeneity processes running dif ferent machines running different operating system implemented different lan guages 
linda open systems linda provides processes homogeneity 
tuple spaces created 
memory finite re source may large surely limited certain degree 
tuple spaces created deleted 
closed implementations linda com pile time application optimised compiler eliminate tu ple space system soon unnecessary easy know unnecessary compiler basically knows may happen system 
open systems story completely different 
process decide tuple space created necessary system termi nation course cases possible general clearly case 
individual computational languages decide linda tuple spaces usefulness tuple spaces objects exist boundaries computational language 
users bothered tasks able securely decide tuple space necessary 
solution 
tuple spaces surely need removed system able implement securely 
solution called garbage collection 
mentioned linda pro vides homogeneity implement data structure linda level keeps track processes tuple spaces garbage collection system implemented structure remove unnecessary tuple space 
thesis overview system 
thesis explores structure maintained centralised distributed fashion ligia linda open implementation dissertation 
heterogeneity bring concerns apparently linked garbage collection shown attached garbage collection problem 
carrying research garbage collection linda apparent problem dealt stable correct solution garbage collection problem 
problem noticed depending process garbage collection behave differently 
happen computation garbage collection dealing coordination structures 
answer obvious operations side effect coordination environment management coordination problem 
second part thesis describes bring linda model time garbage collection system aware process es consequently information removing structure linda system 
incorporation linda done existence new primitive implemented ligia called abstracts files tuple spaces processes deal files similar way dealing tuple spaces 
dissertation proves need garbage collection system need abstracted linda terms linda general purpose dis tributed system 
thesis focusses open implementations linda cause problems exist closed implementations control compiler solution implemented compiler level 
thesis overview chapter reviews areas relevant thesis 
linda models implementations discussed highlighting fact pays 
contributions necessary attention problem garbage collection review relevant garbage collection algorithms done ed area 
chapter introduces ligia model 
model proposed open sys tems assumes existence garbage collection system attached ligia implementation 
chapter explores theory incorporating garbage collection ligia 
centralised distributed solutions explored 
chapter introduces theory distributed tu ples spaces implemented ligia 
exhaustive account possibilities supported proposal 
chapter describes implementation ligia model imple mentation centralised distributed version garbage collection 
implementation restricted version distributed system described 
chapter presents number experimental results extracted ligia im plementation 
experiments test performance garbage collection system general performance results 
chapter discusses research described tion 
section briefly explores questions appear result described 
contributions dissertation contributions problem maintaining information linda garbage collection algorithm fully described explored 
contributions definition coordination problem proposal bringing ligia new operation run time system called ligia implemented providing interesting innovative ideas process registration kernel enables implementation optimisations kernel level implementation tuple monitoring kernel process registration gives control kernel enabling tions implementation stage garbage collection system abstraction files tuple spaces concept file spaces 
chapter review chapter reviews important areas related thesis distributed coor particular linda garbage collection distributed input output 
ordination models implementations reviewed section concept coordination defined number linda coordination models implemen tations described 
descriptions try emphasise strong weak points proposal highlighting time cope problems re lated resource management 
model implementation descrip tion garbage collection distributed put context need clear 
section garbage collection explained algorithms described emphasis standard algorithms considered adapting linda case 
section problem distributed put context solutions related systems described 
distributed case linda completely different cases described important realise problem dealt distributed environ ments 

coordination models implementations coordination models implementations questions normally comes mind regards coordi nation models sort coordination spoken stands coordination vague term meaningless 
refers coordination models idea model able coordinate distributed parallel tasks involving process 
normally coordination needed communication synchronisation processes necessary specific distributed systems 
term coordination needs definition 
carriero gelernter gc coordination process building programs gluing active pieces processes definition observe coordination defined computation definition changes pro cesses required process gluing 
words coordination seen process managing activities distributed system involves processes 
derived term coordination definition coordination models 
carriero gelernter gc gave definition coordination model glue binds separate activities processes ensemble formal definition coordination model states coordination model triple cia entities need coordinate 
entities active objects performing tasks dependent active objects 
terms thesis entities processes 
set media media short coordination 
media way entities interact 

coordination models implementations laws rule actions coordination entities 
coordination languages implementations laws coordination models put host computational language 
coordination computational languages combined form complete distributed language able construct distributed systems idea orthogonality computation coordination 
computational languages coordination model described section 
definition ciancarini cia general consider sev eral levels abstraction coordination models 
short triple defined seen coordination model 
instance language combined unix operating system easily considered coordination model entities media laws defined 
processes entities unix sockets media coordinate 
laws model clearly laws govern communication sockets 
coordi nation models include gamma general model multiset manipulation bl cham chemical machine bb iam interaction ma chine acp lo linear objects ap manifold ar actors agh 
problems garbage collection distributed exist models thesis concentrates variations linda model gel 
linda coordination model linda gel far studied coordination model 
proposed linda aimed parallel computation properties studied applicability distributed systems apparent 
nutshell stan dard linda model consists shared associative memory accessed processes primitives provided 
linda introduced new model concurrent programming 
novelty relied fact linda different model communication generative communication 
generative communication argued different models shared variables message passing remote calls con different model 

coordination models implementations coordination model linda defined triple 
entities linda processes tuples 
processes executable codes tuples ordered lists typed elements may actual value formal definition value 
media called tuple space seen multi set bag tuples 
tuple space shared resource process access 
laws allow processes interact associative addressing matching mechanism compares tuples see similar characteristics 
linda provides primitives access tuple space list elements formals actuals forming tuple 
different fields specially iden tag allows tuples organized groups 
execution primitive results insertion tuple tuple space 
tuple tuple actual 
primitive execution execution resumes 
list elements formals actuals forming executed tuple matching withdrawn tuple space 
tuple suspended blocked tuple available primitive executed behaves similarly matching tuple tuple space tuple read withdrawn 
idea tag tuples soon dismissed tag guarantee application side effected execution 
seen early version tuple space handles introduced multiple tuple space linda gel see section 
concept derived associative addressing non determinism 
match ing mechanism finds matching tuple guarantee retrieval par gelernter refers name operations name primitives thesis 

coordination models implementations ticular tuple matching tuple returned 
non determinism central concept linda linda communication scheme different approaches message passing shared variables instance 
non determinism known concept formally expressed property 
property non determinism relation non deterministic exist matching mechanism linda uses gelernter called structured nam ing gel consists ordered list actual elements belonging tuple order appear tuple 
instance tuple structured name tuple matches tuple func tion returns number fields tuple function returns type th field tuple set formals types available language 
defined gelernter gel formals stored tuple space words exist tuple 
order retrieve tuple formal tuple actual match formal formals match formals 
idea jigsaw puzzle pieces matter holes formals bumps straight lines actuals put fit form object 
gives pictorial idea matching mechanism 
shows possible cases matching actual formal matching matching matching actual actual matching 
matching formal actual linda provides communication orthogonality allows data sent sender having knowledge receiver case receiver need know sender order receive data 
communication consequences defines basic behaviour linda model space uncoupling concept called location free 
refers fact 
coordination models implementations pictorial representation formals actuals part tuples matching mechanism 
formals actuals actuals formals linda processes aware physical location objects 
tuple stored tuple space retrieved removed read process location long process knows format match time uncoupling means notion time exist linda consequently processes communicate execution times intersect 
tuple stored tuple space removed pro cess remains forever 
gelernter proposal introduced linda world formed basis number proposals linda published gel bz ns tol 
implement standard linda implement modified model theoretical concern modifying standard model implementing 
scope thesis open linda implementations 
term linda identify family implementations general properties linda described 
gelernter colleagues yale university published series papers linda refining model regarded standard linda model 
non blocking versions primitives introduced primitives de fined informal way 
primitive proposed linda 
coordination models implementations mechanism spawning new processes 
standard primitives known today stores tuple space 
removes tuple matching blocks matching tuple 
returned 
tuple space non blocking version matching tuple reads tuple tuple space matching 
returned 
non blocking version spawns active block matching tuple tuple space 
original proposal assumes existence single tuple space known process system tuple space called tuple pace multiple tuple space proposal 
gives pictorial view standard linda model processes represented squares execute single tuple space tuple space 
originally proposed parallel computation model appropriate large scale applications open distributed systems conflicts may arise 
large scale applications conflicts format template happen 
model single tuple space single shared memory exists provide separation concerns important large scale applications open dis tributed systems 
single tuple space tuples include tion tag common tuples part concern certainly sufficient avoid conflicts 
separation concerns driving forces proposal multiple tuple space version described section 
model require garbage collection tuple space sistent object collected 
argue reason garbage 
coordination models implementations pictorial representation standard linda 
processes spawned tuple space 
default collection done tuple level 
note originally defined lin da tuple uniquely identifiable model changed garbage collection employed level 
decides change model unique identification tuples model surely linda tuples implies sort communication model breaking important linda characteristic 
multiple tuple space linda multiple tuple space linda model proposed gelernter gel ex tension standard model described section 
time proposal multiple tuple spaces idea accepted linda research com considering original description assumed possibility limitations single tuple space model evident 
main difference multiple tuple space model processes able create tuple spaces 
multiple tuple spaces linda model modular introduce tion concerns 
open distributed implementations linda existence multiple tuple spaces crucial 
systems applications tend run 
coordination models implementations longer period time tend large multiple tuple spaces provide better way implement sort applications 
new operation called introduced execute task creating tuple spaces new type defined 
argue underlying model multiple tuple spaces just imple mentation feature 
view thesis multiple tuple spaces introduce different model clearly similarities linda central concept 
model different triple defining model modified 
entities standard linda model 
media clear ly modified multiple tuple spaces characteristics media triple defined characteristics media 
element triple laws modified differ ence subtle easily pass unnoticed 
way associative matching performed different occurs context tuple space noticed expression laws primitives signifi cantly changed 
said new operation added allow creation tuple spaces semantics follows defined operation spawned process order create tuple space 
execution create tuple space ation onwards process execute tuple space 
point cre creation tuple spaces introduces hierarchy tuple spaces similar structure directories file system 
operations possible tuple space contains tuple spaces depicted 
gelernter implementation model called linda quite general proposal new concepts 
semantics missing weakness proposal try general introduce new ideas 
coordination models implementations pictorial representation gelernter original multiple tuple space proposal 
tuple spaces created inside tuple spaces processes active tuples execute tuple space 
ts default ts ts explaining detail disregarding problems involved 
ts ts ts gelernter proposed ideas today understood 
notwithstanding problem trying tackle problems gelernter intro duced important concepts linda developing distributed model separation concerns permitting creation tuple spaces 
multiple tuple spaces provide interesting environment distributed systems 
intro duction new concept primitives extended multiple tuple space case 
description primitives assumed gelernter linda similar original primitive stores tuple space defined primitive 
tuple space defined execution occurs tuple space 
blocks removes tuple matching suitable tuple 
tuples outside verified matching mechanism 

coordination models implementations returned 
non blocking version matching tuple reads tuple matching tuple 
returned 
primitive 
non blocking version spawns active blocks matching tuple tuple space defined notice linda implement primitives originally proposed 
defined model level primitives preceded tuple space handle handle defined argument primitive 
linda distinguishes tuple space handle 
surprisingly handle defined string 
handle primitives necessarily unique name semantics primitives collision names occurs clear 
uniqueness handle important feature open systems conflicts names lead undesired inconsistencies 
taken consideration regarded im provement multiple tuple space linda implemented string handles similar single tuple space case 
creation handles dealt linda implementation left users decide 
large appli cations different tuple spaces handle 
users define handles separation concerns guaranteed way guaranteed single tuple space system spe cial identification element tuple 
linda tuple spaces class objects 
today obscure linda community primitives behave semantics tuple spaces class objects 
chapter see linda implementations avoid idea 
class objects tuple spaces elements tuples 

coordination models implementations concept active tuples processes 
pro cesses class objects tuple elements instance affected operations tuple spaces 
gelernter argues active tuple space retrieved processes tuple space stopped 
resume tuple space ed 
certainly interesting idea implemented issues tackled question active tuples processes stopped resumed trivial answer 
languages implement continuation passing style paradigm clearly option language 
order process store minimum data allow resumed 
comprises minimum data 
possible avoid undesirable side effects 
implemented 
tuple space retrieved linda associated variable complex data type contain tuples active passive 
retrieval active tuple spaces means solving question processes executing tuple spaces duplicated 
tuple spaces removed read duplicated 
implying processes executing security problem 
spawns process expects process execute done prevent 
model allows processes retrieve tuple space question consequently spawned processes 
shows separation concerns perfect impossible spawn process inaccessible process 
say spawning process local tuple space happen local tuple space handle just simple string 
able describe process resumed 
continu ation passing style programming languages tuple space containing active tuple 

coordination models implementations 
order resume process state stored trivial task may involve storing state structures may side effected 
gelernter tries envision possible applications multiple tuple space mention multiple tuple spaces open implementations requires garbage collection 
talking persistent tuple spaces gelernter says persistent tuple space tuple space created contin ues exist explicitly destroyed fact processes inside tuple space terminated mean words tuple space disappears reality read statement tuple spaces assumed destroyed disappear sort explicit garbage collection 
feasible open distributed implementations 
order safely destroy tuple space primitive process aware processes accessing tuple space 
case tuple space local done safely linda processes mechanisms purpose 
clearly problem argument tuple spaces class objects happens process accessing tuple space removed primitive apparently linda assumes tuple space local persistent object 
open systems consider non local tuple spaces persistent default lead system memory exception linda closed implementation feasible sort compile time analysis 
compile time analysis open systems compile time concept entire system defined 
garbage collection thesis adapted case tuple spaces stored extension tuples spaces class objects scope thesis 
gelernter gel discusses interesting considerations regards 
coordination models implementations tuple space mechanism 
view file system re placed persistent tuple spaces directions go doing persistent tuple space execute instance mimics index file 
argued abstraction eliminates overhead linda system data ready linda format conversion unnecessary 
step taken argued persistent tuple spaces separate file system essary 
multiple tuple spaces persistence job file system offering advantage users provides unified semantic frame 
gelernter ideas original motivation thesis tackle distributed problem linda ideas investigated issues mentioned considered 
tion file system completely impractical world linda 
linda deal files thesis proposes original file system preserved abstraction brought linda 
tion model visible advantage users completely unaware location resources extending abstraction location model 
open systems may interesting property persistent tuple space defined creation tuple space necessarily time creation tuple space tent execution program 
proposal possible new primitive associates tuple space file tuple space persistent 
multiple tuple space linda model goes step gelernter linda gel 
terms implementation considers tuple spaces processes class objects 
possible create read snapshot suspend destroy archive re activate processes tuple spaces 

coordination models implementations subtle distinguish modification occurring model implementation level assumed linda defines triple model 
implementation level assumes existence tuple space contains known process 
linda ready assumes tuple spaces class objects basic difference encountered implements class processes 
argued section difficult deal tuple spaces active dealing active processes hard fact problems explicit case 
overcome problem dealing active objects introduces type modifier type object type defined type passive 
noticed role type modifier allow operations active processes 
instance process type executed tuple space able suspend execution snapshot process resume execution store execution type type role type modifier clear questions concerned meaning operations remain unanswered 
argues active tuple space suspended active tasks suspended 
due linda impossible guarantee immediate termination task author answer tasks soon possible 
meaning statement 
suppose instructions shown code 
operation shown causes image active tuple space assigned 
coordination models implementations code part program lines code represent duplication tuple space contents including active tuples 
come back problem stopping soon possible 
really ed tasks stopped block waiting processes 
taken continuation hf active tuple space continuation defined raises doubts regards continuation 
interpretative problems model semantics assump tion processes class objects implemented modifications model order avoid users stopping processes deliberately ex section 
inclusion concepts access rights tuple spaces tuples woo help 
implementation recognises different tuple spaces classification persistent 
tuple space defined persistent required live outside scope creator 
context garbage collec tion information important guaranteed non persistent tuple local garbage collected scope 
assump tion having users deleting persistent tuple spaces explicitly argued option 
complex users decide usefulness tuple space require sufficient knowledge tuple space situation entire system possible 
garbage collection scheme proposed thesis fit closed implementation certainly better compile time type optimisation 
distributed considered elaborate 
coordination models implementations basic ideas linda 
york linda york linda kernel open implementation variant multi ple tuple space linda model 
model implemented significantly different standard multiple tuple space model considered new model 
entities standard multiple tuple space model media mainly laws different 
media tuple space idea affected non existence tuple space 
remember media way entities interact surely case different flat struc ture tuple spaces contribute difference 
laws modified bulk operations exist introduces new way processes media 
implementation includes new primitive called bwa realizes concept bulk movement tuples 
primitive move set tuples matching template tuple space 
informal semantics follows moves tuples matching tuple space source tuple space destination returns number tuples moved 
semantics imprecise active tuple spaces definition tuples context active tuple space clear 
despite multiple tuple space implementation model supposes universal tuple space tuple space known process similar tuple space proposed gelernter gel tuple space previously defined 
primitives deal tuple spaces define explicitly tuple space involved operation 
structure model completely flat depicted 
multiple tuple spaces exist class objects stored 
refers tuple space global tuple space 

coordination models implementations representation flat tuple space structure proposed york lin da 
ts ts ts ts ts ts implementation processes supposed execute outside tuple spaces process supposed turn tuple inside previously defined tuple space tuple space defined processes linked tuple space 
primitive means point question arises process linked tuple space tuple space main processes processes started outside linda sys tem linked 
douglas processes exception rule turn tuple finish execution 
exten breaks characteristic abstraction concept uniform entire system 
lack implementation suitable general open sys tems 
observe global resource tuple space processes running independently get communicate 
separation envi ronments restrictive implement large general purpose applica tions 
processes communicate ancestor common hierarchy process spawning 

coordination models implementations terms distributed york linda allow spawned processes operations main processes computation able reason restriction authors envision migration processes differ ent operating systems may compose open system question 
migration processes causes problem underlying environment heterogeneous 
chapter shows motivations bringing distributed linda model 
ordering problem highlighted proposal 
problem quite relevant forgotten implementations linda 
ordering guarantees implementation coordination tasks 
imple mentation guarantees series tuples stored tuple space pair tuples appear tuple space order sent 
words order arrival tuples tuple spaces order sent dissertation shown variation situation required proposal described 
authors argue tuple spaces class objects proposal fact description handles tuple spaces class objects 
important difference 
operations handles easily implemented handles pointers tuple spaces 
hand operations tuple spaces difficult semantics operations missing 
garbage collection definitely issue 
open implementation compile time optimisations possible 
hand lack universal tuple space causes system separated disjoint groups processes tuple 
means garbage collector account basically run disjoint group independently 
chapter scheme garbage collection described idea clearer 
york linda york linda rw open implementation linda 
generally peaking implementation uses model york linda 
coordination models implementations representation flat tuple space structure proposed york lin da non local tuple spaces uts ts introduced shown 
implementation assumes handles tuple spaces class objects preserves ordering feature 
concepts terms york linda implemented 
york linda seen improved implementation york linda 
implementation introduces important new ideas paying attention need authors tackle problems called multiple lem performance improving organization tuple space structure 
proposal ts ts ts ts ts prob pursuit semantics replace problematic primitives observed operation necessary fill gap left primitive 
problem called multiple problem occurs process repeatedly perform tuple tuple space 
due non deterministic characteristics linda idea bulk primitives alive 
primitive matching mechanism process keep reading tuple 
removal tuples option primitive necessary perform operation proposed 
primitive copies 
coordination models implementations set tuples matching template tuple space solve multiple problem copying tuples tuple space tuple space remove tuples side effect processes keep accessing original tuple space 
semantics follows copies tuples matching tuple space source tuple space destination turns number tuples copied 
re second important modification differentiation local global tuple spaces local tuple space known process 
authors implement simple idea tuple space remains local handle passed process tuple space 
point tuple space global 
simple rule managed improve performance implementation storing local tuple spaces locally processes 
shows non local tuple spaces marked 
respect garbage collection information kind useful better decisions tuple space local process accessing terminates tuple space automatically garbage collected 
plinda plinda persistent linda fault tolerant linda implementation 
context dissertation fault tolerant properties plinda considered 
fact plinda reviewed persistency issue distributed scheme described chapter 
plinda said persistent system fault tolerant 
persistency thesis tuple space level occurs consequence proposal 
fault tolerance completely related implementation model level affected 
plinda implements multiple tuple space model implement ed linda 
fact jeong extend standard single tuple space linda result basically 
multiple tuple space idea achieved 
coordination models implementations creation tuple groups group unique id class ob ject consequently stored global tuple space tuple groups 
pictorial view model exactly fact tuple groups tuple spaces linda nomenclature plinda uses name tuple space refer problems linda implementation addressed 
tuple space calling tuple groups 
instance tuple space tuple groups class objects making ger argument assumption realistic 
overcome separation concerns having handle generated server 
im proves idea separation concerns difficult guess han dle said handle uniqueness 
fault tolerance achieved transactions plinda adds operations define start transaction sort programming style fault tolerance achieved 
addition operations added model provide fault tolerance primitive delete tuple groups implemented 
primitive takes argument tuple group id kill group 
view taken thesis task deleting tuple groups rely users 
users aware entire system situation primitive lead system inconsistent situation 
plinda closed implementation compile time analysis verify destroy group cause side effects 
plinda processes migrate said problem may cause 
possibility process migration fact motivations including linda 
having described problems fair say plinda suffer consequences plinda closed implementation 
means redirection tuple space deletion handle uniqueness dealt dur ing compile time solving possible inconsistency 
authors refer explicitly existence tuple space distinguish tuple groups unique tuple space probably global 

coordination models implementations formula time costs original linda primitive 
bonita bonita rw variation linda primitives provide asynchronous access tuple spaces process synchronous provided original linda primitives 
generally means model implemented bonita different laws modified 
model implemented quite similar model implemented york linda laws modified 
rowstron wood motivated current trend linda community produce better semantics primitives alter better applied distributed coordination 
linda proposed model parallel computation noticed produces results distributed environments 
linda primi tives optimised parallel computing distributed comput ing 
observed open distributed implementation costs associ ated linda primitives due time taken send receive message network 
bonita tries pipeline concept time message spent travelling network 
take instance case primitive 
semantics pro cess executing block case tuple available tuple space 
noted true distributed environment process es block time matching tuple available 
practice time cost linda primitive generally described formula 
term formula identifies specific cost regardless open linda system implemented 
time taken construct message 
local process er information necessary create tuple template arrange message communication 

coordination models implementations time taken message sent kernel communication chan nels 
time message wait processed linda kernel 
processing time 
time taken kernel process message received 
includes unpacking message finding suitable tuple accord ing template sending return message user process 
time primitive remains blocked tuple available 
time taken message sent kernel process communication channels 
time taken user process extract interpret message sent linda kernel 
cost measured user point view server point view 
means costs costs involved affect server kernel side 
user process point view cost packs message sends kernel carries 
aim bonita try primitives take approx cost local computation 
describing improved set primitives authors introduce different time cost necessary realistic account cost new set primitives 
time taken check locally message kernel arrived 
cost new set primitives proposed achieve goal 
primitives preserve functionality linda primitives easily simulated 
store request tuple primitive store tuple specified tuple space 

coordination models implementations tuple space tuple required removed case read tuple space case 
primitive takes tuple required process blocked waiting 
primitive manages bulk movement tuples tuple spaces 
request sent kernel requiring tuples match moved case copied case 
primitive takes process blocked result tuples moved copied retrieved 
primitive tests see result associated locally available 
primitive non blocking returns depending result 
cost primitive result 
independent blocking primitive bonita 
blocks waiting associated result arrive locally 
primitive making new method trying simulate linda primitive cost parallelism comes fact cost relative local computation 
code bonita simulation said bonita primitives mimic linda primitives exceptions rowstron wood argue primitives 
coordination models implementations code linda program stores tuples removes 
code bonita implementation linda example code 

coordination models implementations unnecessary primitives 
code shows new set primitives simulate cost simulation shown code argued better ways bonita primitives order operations 
suppose instance linda code example code stores tuple removes 
costs described authors example code time cost greatly reduced bonita primitives 
code shows linda code code implemented efficiently 
account scheme cost bonita example code clearly improvement guaranteed cases expected shown rowstron row 
bonita clearly multiple tuple space system argued authors selves model open distributed system 
garbage collection addressed papers improvement terms speed irrelevant system stops due exception 
place garbage collection fault tolerance area 
garbage collection falls basic area 
fault tolerance soft ware tries achieve hardware faulty garbage collection scheme tries software reliable run long period time 
distributed addressed 
bonita proposes new way access tuple spaces 
flaw linda system presents terms handling bonita 
bauhaus linda originally proposed fill gaps left multiple tuple space linda model gel 
carriero argue multiple tuple spaces lacked important characteristics multiple class tuple spaces operators unify way objects stored tuple spaces processes tuples tuple spaces dealt 

coordination models implementations model underlying significantly different original multi ple tuple space model 
entities tuples processes called multisets passive active distinction disappears point view model laws apply dia referred multiset fact multiset laws reflect changes described far multiset sole structure matching mechanism replaced multiset inclusion operation 
authors argue powerful time simpler linda 
case seen generalization multiple tuple space idea tuples tuple spaces multisets replaces ordered tuples multisets time tuple spaces replaced unordered multisets 
surely unifies operations tuple space tuple opera tions tuple spaces removal objects adding objects applica ble tuples operations tuples primitives applicable tuple spaces 
furthermore unification concepts naturally implements hierarchy multiple tuple spaces 
templates multisets templates superseded multisets 
semantics primitives different described section 
basically matching mechanism replaced operations mul 
processes multisets processes active tuples represent ed multisets active multisets 
automatically processes class objects 
primitives passive active mul 
semantics primitives changed 
important concept order understand semantics primitives location process structure tuple spaces 
process executing multiset scope primitives executed process process 
coordination models implementations hop multiset operates multiset currently 
general semantics primitives follows primitive puts object multiset containing object said multisets hierarchical level process executing primitive considered 
empty composed element 
idea multiset removed assigned multisets level process consid ered primitive multisets contain chosen removed returned 
primitive behaves multiset returned removed just read 
important difference processes stored multisets behaviour relation active processes different 
primitive active objects remain active outside coordination structure case image active object indication state time execution primitive returned original active object keeps executing coordination structure 
primitive moves process executing primitive level multiset containing special symbol represent process moving level 
primitive implemented handles exist order get access multiset process move hierarchy 
shows pictorial view coordination structure written shows situation coordination structure dif ferent executions primitives 
execution observe possible situation 
execution process execution 
coordination models implementations representation coordination structure paul idea unifying treatment tuples tuple spaces processes interesting certainly advance distributed coordination area 
problems dealing active multisets persist 
observe example carriero say command somewhat similar command 
returned maintain active processes active processes removed coordination structure obvious question 
discussed trivial solve problem side effects difficult solve happen multiset con tain multiset active objects turn contain multisets active objects 
linda implements quite different model 
garbage collection scheme described chapter apply directly 
fact reason incompatibility method introduced thesis way defined 
carriero consider garbage collection certain 
multisets 
coordination models implementations example illustrating execution primitives paul paul paul non unique identifiability characteristic tuples linda 
brings concern regards applicability ideas open systems multiset persistent linda system composed tuples tuples collected 
internal links created availability multiset process garbage collection impossible 
carriero address method described chapter adapted fit lack true separation concerns ish validity proposal file abstracted multiset lose access rights available processes 

coordination models implementations laura laura tol tol service coordination language open distributed systems 
laura understands processes open systems need coordinate order offer services 
due nature open systems coordination uncoupled processes coordinate direct communication 
direct communication assumes system static nature processes perform repeated tasks long period time 
surely true open systems dynamic nature impossible known process executing time 
establishing connections open systems lead errors process leave system anytime 
user uncoupling offering services driven proposal laura 
variation linda renaming primitives changing matching mechanism specific services laura offers insight coordination models distributed service paradigms 
laura composed service space equivalent linda forms special tuples specific service communication stored 
processes provided variations linda primitives offer request service get result service 
vice arguments adds request form ser operation required performed service quired operation 
generally arguments formal formal actuals re represents result value process looking 
blocking primi tive primitive waits offer form appear service space process write result form 
ing service adds form service space offer blocking primitive case request form added primitive exist service space 
exists process answers request outputs re sult 

coordination models implementations primitive store result forms service space consequently unblock process executing primitive matching mechanism differs original linda mechanism order better forms 
form composed set operation signatures interface defined name operation argument types result type 
matching mechanism request form added kernel try find service form service offer interfaces match 
laura names trying identify service interface signature 
forms service form matches request form type inter face service form subtype interface request form 
generally speaking means services serve sophisticated requests 
code service large specialised shop offering operations 
code service licence shop offering operation suppose definitions services code 
code describe ser vice provided large shop operations provided users 
coordination models implementations service require extra information 
licence shop code offer operation required users 
service form large shop put service space offering service match request form licence shop available 
operation proposed open systems service space implementation large realistic application hard achieve 
large systems complexity managing sole service space huge distribution concerns impossible 
short laura falls single tuple space trap motivated linda models provide multiple tuple space environment 
terms garbage collection single service space means garbage collection done 
forms identifiable uniquely open systems impossible know form stored service space required 
real world service space tend grow size lead system memory exception 
multiple service space version laura appear garbage collection implemented 
scheme proposed thesis applied laura little modification long model im plemented significantly differ multiple tuple space model gel 
distributed laura easily implement distributed system services offered distributed implementation accordance fact distributed coordi nation problem fact location transparent im plemented services breaks important characteristics laura lo cation transparency 
pagespace effort pagespace ctv effort integrate www coordination models order provide real distributed capabilities applications running web 
ba web provide support distributed cooperative applications active entities necessary 
main questions linda improve existent envi 
coordination models implementations ronment words linda attractive distributed applica tion web 
ciancarini identified points showing attractive ness coordination models linda www environment tuple spaces concept tuple spaces distributed environment pro vided notion asynchrony concurrency important points bet ter www free 
concurrency achieved having processes ing tuple space communication channel synchrony achieved due shared memory flavour tuple spaces 
message passing opposite shared memory extremely synchronised communication involves synchronization 
uncoupled structure agents unaware physical location bringing www environment level terms abstraction space uncoupling 
con cept time exist linda coordination models processes communicate exist time time uncoupling 
associative addressing data tuple space retrieved contents name 
www greatly take advantage characteristic imple scheme way pages retrieved urls 
orthogonality coordination concept orthogonal computation ing coordination model www influence way com putational programs behave web 
availability web causing users demand sophisticated ap plications including distributed applications integrated 
coordination models play central role 
applications came bunch useless programs integration coordinated properly 
pagespace proposed provide platform web integrate distributed applications 
mechanisms transforming web platform suitable distributed computing widely available 
common gateway interface cgi instance name agents represent client server processes 

coordination models implementations mechanism interfacing external applications information servers web servers 
plain html document web daemon retrieves static means exists constant state text file change 
cgi program hand executed real time output dynamic information 
noticed cgi provides means creating distributed application matter fact application interfaced cgi server part doing processing 
time client requests url corre sponding cgi program server execute real time 
clients limit mere query formulation html 
side story occurs activity done clients case applets plug ins instance 
despite impression called distributed generally stand applications perform distributed cooperative 
cases perform cooperative distributed problems security complete abandonment web central unifying environment happen 
pagespace poses environment coordinate dis tributed agents clients servers integrated functionalities www hypermedia unified view offers 
pagespace proposed linda environment 
ciancarini claim original linda model defined section suitable open computing comes hard support multiple applications sharing single tuple space 
pro pose expand basic coordination behaviour linda allowing declarative rules coordination implemented shade ccr con cept laura coordination language tol tuple spaces replaced service spaces containing forms describing service offers requests results matching performed interface included form see sec tion 
pagespace architecture composed classes agents 
agents run concurrently cooperation provide functionalities required www communicate shared coordination media 
clas ses follow 
coordination models implementations user interface agents agents agents represent front applica tions 
depending sophisticated agent different activities sup ported 
web composed plethora activities place client server middle 
interface agents support activities depending interface 
avatars agents persistent representation user agents pagespace 
provide asynchrony time uncoupling 
point view pagespace avatars agents users required logged system exe cution 
avatars connected users take role user agents return communication behaviour set user demand periodically continuously 
application agents agents ones constitute distributed ap plications interacting agents providing services 
application agents ones distributed processing specific user interface agents agents providing applications specific function server agents providing generic services 
kernel agents agents provide coordination mechanisms applica tion agents 
implemented java exist location executing pagespace possibly different java virtual machines characterising page space open systems 
kernel agents central part coordi nation environment pagespace machine providing access page space users avatar managing home agent operations spawning new application agent managing application agents executed lo cally kernel implementing coordination primitives matching rules shared space implementing distributed architecture having kernel interface kernel agents 
gateway agents agents similar application agents gateways differ cause provide services interact external entities 
pro vide communication coordination systems 
gateway agents serve 
coordination models implementations pagespace architecture ctv pagespace users processes linda wrapper agents external applications wanting access services page space system 
depicts pagespace system environment 
example user processes web browsers pagespace communica tion 
agents representation users pagespace communicate agents services offered 
communications agents offer services 
pagespace distributed open system provide means col unused data repositories tuple spaces created deleted unnecessary system 
additionally agents need collected services cease exist anytime 
garbage collection active ob jects agents achieved garbage collection scheme described chapter properties guaranteed 
distributed addressed pagespace clearly important 
quoting authors say user programmer provided conception distribution heterogeneity invisible 
coordination models implementations means say users programmers false sion operations local considered impression broken 
location breaks abstraction distribution 
menezes wood mw shown coordination problem chapter explores proposal detail showing embedded linda coor implementations 
project terminated pagespace greatly contributed understanding coordination mechanism enhance quality services offered web 
javaspaces implemented sun microsystems javaspaces sun represents endorse ment tuple communication abstractions 
javaspaces proof coordination technology impact way distributed systems de signed 
javaspaces considered model commercial open embed ding linda java 
javaspaces tries new model differs significantly linda 
specification analysed comes clear differences reality minimal 
javaspaces introduce new concept model level imple mentation uses aspects java language distributed events sun transactions sun lease sun making javaspaces interesting embed ding 
model implemented javaspaces similar model implemented york linda see section multiple tuple space model necessarily ideally flat 
theory javaspaces objects stored javaspaces active objects bring problems system terms semantics 
clear specification space just handle 
class defines garbage collection surely issue 
open system 
coordination models implementations restricted java processes 
handles exist passed processes despite remote method invocation rmi system control passing handles 
rmi access methods remote object gain information usefulness distributed object 
apparently distributed garbage collection system developed tackle garbage collection javaspaces gro system collect objects different java virtual machines 
important garbage collection scheme proposed report misunderstood 
garbage collection provided java language ideal general purpose open systems include different host languages garbage collection scheme pro vided particular host language able heterogeneous sys tems 
garbage collection coordination objects provided ordination dimension computational host language 
distributed considered javaspaces surely brought inside system adapting scheme described chapter 
spaces proposed ibm version linda spaces learning linda implementations analysing advantages variations multiple tuple space model open linda implementation 
proposed middleware ubiquitous computing spaces tries fuse ease linda systems power relational database systems provide framework seamlessly provide high quality communication devices rang ing tier smaller laptop computer tier mainframes 
spaces implement different distributed tuple space model 
surprisingly entities tuples processes media composed multiple spaces similar tuple spaces main difference lies definition laws interesting change laws inclusion access controls spaces users establish access rights user group level 
fully explored spaces inclusion model shows concern way primitives defined indicates handles 

coordination models implementations important aspect open systems access control open distributed tuple spaces system extensively explored suitable solution capabilities proposed woo 
effect access control laws clear way processes interact tuple spaces different process access tuple space handle available process 
interesting modification laws space gain dynamic aspect 
addition default set primitives representation laws new primitives defined dynamically 
default primitives implemented spaces basic linda primitives plus additional ones related query synchronization 
de scription primitives implemented semantics primitives writes object tuple space primitive removes object tuple space matching object 
object template contain formals non valued typed objects 
blocking primitive process blocks matching stored space matching primitive removes primitive block 
matching object removed 
copy returned 
object 
opposed copy returned matching object object object returned 
object object removed 
returned 
space version primitive re turns tuple containing tuples matching template original tu ples remain tuple space 
difference primitive tuples copied tuple 
coordination models implementations pace copied internal data structure form object 
spaces version prim itive returns tuple containing tuples matching template removing original tuples tuple space 
primitive differ moves matching tuples tuple space removed assigned local ples matching takes object 
primitive returns count number tu primitive perform atomic synchronisation 
matching tuple template objects second template atomically swaps set primitives implemented spaces quite complete primitive allows simple form rendezvous expressed proposed 
spaces paid attention need bulk primitives row spaces implementation forces tuples class objects unnecessarily primitive meaning dynamic environment process find object accessed people result primitive reliably way 
garbage collection space provided java language 
due rmi implementation due java sole language pace java garbage collector possible 
na think language universal standard 
general open systems lin da common infrastructure necessary garbage collection linda objects infrastructure 
spaces specification forecasts implementations corba interface im plemented allow spaces communicate non java platforms 
hap pens ibm implement garbage collection linda level proposed thesis 

garbage collection schemes distributed explored spaces implemented model affects garbage collection coordination problem 
spaces assume im clients mobile 
explained chapter reinforces idea implemented common infrastructure redirected independently process migration 
garbage collection schemes garbage collection process searching reclaiming unused memory space hard task handled users 
modern distributed environ ment provide transparent garbage collection objects similar way access local remote locations provided 
dlm garbage collection algorithm generally composed mutator collector collector generally divided phases searching reclaiming phase 
mutators processes modifications structures objects collector uses structures decide situation objects 
section describes garbage collection algorithms distributed sys tems 
number papers proposing solutions distributed garbage collection enormous different approaches counting listing tracing 
review section concepts particular papers 
description general common characteristics highlighted single characteristics 
aim give idea alternative approaches pros cons 
counting basic idea counting cell counter number cell garbage counter falls zero 
naive extension concept distributed environment consists 
garbage collection schemes cyclic garbage created detected counting properly cyclic structures 
root idea difference pointer cell local remote environment divided spaces 
counting technique considered acyclic solution works graph acyclic 
cyclic structures method incomplete collect cyclic garbage exemplified 
deleted 
counter field reduced cyclic garbage structure composed created 
nodes counter field equal garbage eyes counting algorithm truly garbage root access 
drawback approach potential race condition maintenance counters 
implementation increment decrement messages asynchronous distributed environment difficult achieve race condition careless cell counter set zero garbage 
due distributed systems race conditions avoided solutions increase overhead system ing messages 
idea aiming eliminate increment decrement messages type message proposed watson watson ww independently 
known weighted counting 
proposal consists having node weights partial weight 
garbage collection schemes invariant weight counting algorithm 
total weight partial weight partial weights total weight 
additionally cell list partial weights cells refers referred cells 
total weight change creation new refer ences cell decreased deleted 
creation cell referred total weight initialised value greater zero partial weight initialised half total weight half sent cell refers referring cell stores value list partial weights 
time created referred cell partial weight halved half sent message initialise partial weight referring cell 
duplication operation involve referred cell 
operation consists having referring cell sending copy cell 
duplication partial weight referring cell halved remaining half initialise partial weight new referring cell 
pointer deleted weight decrement total weight referred cell 
assuming loss messages duplication shows invariant guaranteed 
shapiro ps main problem approach initialisation total weight limitation number pointers cell initialisation duplications possible 
weight trivial solution adding value cell partial weight total weight taken 
observe invariant guaranteed sum possible length cell limited 
better way overcome limitation indirect ww 
cell drops partial weight needs duplicate object created total partial weight 
duplication creates 
garbage collection schemes situation indirect weight counting 
rt rt indirect pointer shown describes case needs duplicate unable counter divided anymore 
new cell created duplication done making point points dashed objects represent added 
showed points assumes different spaces failure space poison unable reach kind solution exhibit domino effect failure causes failure spaces rud 
drawback chain indirections created looping back space times adding enormous overhead system 
despite problems weighted counting better distributed sys tems basic approach 
overhead general tends smaller duplication involve referred cell 
listing basic idea listing replace counter list shown 
concept garbage remains 
node empty list garbage 
race condition problems counting apply listing increment decrement messages replaced create delete messages 
advantage method comes reliability message duplication loss details characteristics considered 
garbage collection schemes listing method cell list opposed counter 
rt rt counting rt scope report 
rt rt listing shapiro sdp propose ssp chains stub pairs implementation listing 
proposal call classical distributed system avoids race conditions time stamped messages 
principle proposal unsuitable linda concept time stamps breaks chronous property linda 
ben interesting proposal listing birrell context network objects small non mobile objects referred remote space 
context thesis important point birrell proposal way race conditions avoided 
birrell suppose ordering operations graph implemented acknowledge ment messages 
linda implementation proposed thesis need similar solution order guarantee absence race conditions 
counting techniques listing acyclic method garbage collection 
listing techniques unable collect cyclic garbage 
tracing spite considered better tracing distributed systems counting listing suffer incompleteness 
explained shared memory partial failures unreliable costly messages 
rt 
garbage collection schemes methods unable collect cyclic structures 
tracing techniques search graph marking reachable nodes roots 
search unmarked nodes graph garbage 
main advantage tracing techniques suitability cyclic structures 
tracing algorithm usually described colours cell black marked white 
implementation tracing distributed environments consists typically combining local collectors working local spaces global collector looking situation entire system 
local collectors responsible deciding usefulness local objects whilst global collector public objects 
main problem distributed tracing methods maintain consistency graphs mutators operate graph concurrently collec tor 
shapiro ps cases consistency achievable collectors rely snapshots structure inconsistent 
dlm step solution distributed tracing taken dijkstra proposal fly marking 
despite distributed solution introduce idea having mutator cooperating collector concurrent way 
set new color indicate cell just created 
illustrates problem occurs mutator collector running concurrently shows solution proposed dijkstra algorithm execution cell black grey white 
white cells unreachable roots 
grey cells created collection missed marking searching phase 
black cells useful system time marking 
reclaiming phase white cells reclaimed colours whitened 
said proposal dijkstra distributed solve consistency problems related distribution data 
consistency problems caused race condition situations 
common situations de 
garbage collection schemes illustration problem mutator collector running concurrently possible solution collaborate 
rt rt mutator collector collaborate rt rt mutator collector collaborate scribed shapiro ps inconsistent snapshot problem message transit problem 
inconsistent snapshot problem consists having erroneous collection snapshot taken global collector done concurrently mutator consequently reflect true stable situation system 
similarly message transit problem snapshot 
case snapshot take account messages transit system 
noticed latency system variable causal order messages lost 
standard solution inconsistencies synchronisation 
barrier synchronization snapshot problem high cost 
solution time stamps replacing marking field proposed hughes hug 
basic idea compute threshold global clock propagate time stamps roots initialised global clock reachable nodes 
nodes time stamp threshold garbage 
details considered time stamps need notion time 
notion time relies implementa tion global clock tricky asynchronous environment 
defined lamport lam 

garbage collection schemes lang introduced new idea doing tracing groups 
basic idea nesting spaces independent groups 
space belongs group cooperates graph construction group 
algorithm consists basically phases group negotiation space chooses group take part creates new 
phase predefined configuration spaces groups 
initialisation phase distinguishes internal external 
node referred outside group external marked black 
propagation marking phase executed group propagating black mark local structure marking nodes roots 
reclaiming white node reclaimed 
matter fact algorithm pure marking strict sense 
pro relies variant counting initialisation phase 
proposal cyclic garbage collection algorithm strict sense col lection garbage cycles depends configuration groups cyclic garbage structure collected fully included group 
get round problem authors assume space necessarily member group 
hierarchy groups built order guarantee cycle contained group 
implementa tion hierarchy groups require node marking node group belongs unfortunately expensive terms space 
lang argue proposal efficient imple mented 
accurate results performance missing 
linda context performance main concern perfor mance results fully valid linda 
described chapter idea nesting processes groups appears interesting linda unfortunately application suffers problems race conditions solved 
space name representing processor process location 
distributed distributed section describes works incorporating capability message passing environments respectively mpi message passing interface cff pvm par virtual machine ms 
reason describing message passing pro clear problem dealt thesis linda identified solved platforms 
proposals message passing described outline direct linda discussed gel basic idea corbett cff describing extension mpi described terms message passing 
operations writing screen printing job writing file analogous sending message waiting necessary 
despite related message passing corbett justify inclusion system mpi arguments equally applied linda sys tems proposal corbett intended extension standard mpi system mpi lacks ability deal file standard distributed systems mpi rely 
mpi io mainly concerned performance functionality left second priority 
thesis takes opposite view concerned functionality unifying concepts 
parallel input output system ms inclusion capability pvm 
mpi io moyer sunderam identified lack standard system distributed environments pvm 
parallel file system view occurs operations files unix abstraction 
generalises pvm proposing new primitives deal files 
increases complexity system significantly users stand new primitives interact 
main advantage linda case case modifications necessary 
solution proposed chapter new primitive link devices linda tuple spaces necessary linda primitives access files 

distributed example showing gelernter proposal represent files tuple spaces 
steve male mary female john male joanna female cris female 
paul male mary female cris female joanna female paul male john male steve male gelernter gel briefly described abstraction file systems terms sistent tuple spaces 
suggested files represented tuple spaces having tuples form representing file elements repre sents sequential position fields file shown 
gelernter described generalisation suggestion proposing elimi nation file system favour composed persistent tuple spaces 
file visualised unix byte stream storing tuples form binary files storing tuples form approach thesis differs conventional idea files maintained abstraction layer existing file system creat ed 
thesis propose replacement concept accepted world consist linda processes sumed replacement file system linda modify non linda processes incorporate concept tuple space create layer abstraction linda file system order ate conventional view 
proposal differs gelernter provides persistent tuple spaces having files underlying tuple spaces op 
final remarks 
thesis proposing novel way creating persistent tuple spaces persistent tuple spaces achieved free consequence proposal distributed linda 
question inclusion linda differs proposals mpi pvm respectively mpi io easily answered re lated linda differs mpi pvm 
linda provides pow programming environment simpler 
linda abstracts low level issues addressed systems mpi pvm 
implementation linda underlying model mpi css pvm gal 
implementations shared memory commands translated message passing 
idea introducing linda provide model high level operations deal 
primitives translated equivalent mpi io 
instance mpi io provides ways accessing file blocking non blocking pointers explicit offset 
operations require series oth er operations executed telling instance way file partitioned 
primitive introduced thesis allows files file access functionalities mpi io removing users burden low level operations 
file partitioning access rights provided automatically linda file abstracted tuple space tuple spaces partitioned file feature see chapter details 
chapter shown problems related linda far intricate gelernter proposal suggest need deeper analysis order linda coordination system working properly 
final remarks chapter overview area explored dissertation 
com description linda models implementations allows background area realise need garbage collection system open implementations linda 
possible model implementation 
final remarks description considerations regards garbage collection ed 
regards chapter showed models pvm mpi considered adding basic model 
chapter ligia model chapter implementations different variations linda model described unfortunately fail address resource management issues 
ligia variation linda model tries consider issues memory man agement distributed concept time ligia proposed fair understood concepts implemented 
goal chapter give full account choices ligia 
existing gaps left models ligia tries trade needed de features 
chapter divided follows section general issues model described aim section overview model important issues explained separate sections 
section universal tuple space case need global resource open implementations emphasised justification definition ligia model 
section explains handles ligia class objects tuple spaces processes problem handles worldwide unique iden explored 
section coordination problem explained motivation having tuple space defined model 
section mally describes ordering problem defined douglas motivates inclusion ligia 
similar problem universal identifiability tuple spaces section explores need processes identifiable 
general description model need identifiability universal worldwide sense 
section describes concept tuple monitoring introduced ligia assumed model monitor content tuples stored tuple spaces 
section introduces concept termination ordering essential correct implementation garbage collection 
general description ligia multiple tuple space model gel implementations previously done university york rw 
linda model communication done solely tuple spaces created processes ex cept universal tuple space persistent distributed tuple space provided model 
additionally model assumes existence tuple space represents abstraction model 
tuple spaces known process executing ligia corresponds saying process ligia ability access global resource provided 
concepts implemented ligia different models 
model includes new primitive assumes existence tuple space 
organizational terms structure tuple space flat similar york linda kernel sees flat structure links processes tuple spaces 
flat structure means tuple space stored eliminates need class tuple spaces 
handles hand exist tuple spaces handle universal unique name process possession handle get direct access structure independently tuple space physical location 
processes subject controversy 
defined original linda model processes identity means say messages anonymous process kernel 
ligia avoid confusion kernel implementation chapter kernel refers equivalent kernel implementation model level 

universal tuple space processes tuple spaces uniquely identified kernel processes kernel necessary monitor process activity 
flat structure concept processes exist inside tuple spaces turn passive tuples finish execution 
process spawned linked tuple space historic reasons linda users expect case necessary kernel understand scope process system 
tuple space defined primitive known process start operate tuple space 
terms primitives ligia implements standard primitives non preemptive version bulk primitives new primitive deals 
primitive create tuple spaces spawn processes shows ligia flat structure tuple spaces processes 
processes execute outside tuple spaces maintain link tuple space spawned 
assumed processes turn passive tuples inside tuple space terminate may difference model links processes tuple space pure organizational kind hi created 
assumed main processes started non outside linda model linked means links assumed model implementation ex pand structure attend need garbage collector 
structure start point build structure garbage collec tor 
universal tuple space ligia model aimed open distributed applications presupposes tence universal persistent resource called universal tuple space 
tuple space model assume direct communication processes communication done tuple space existence universal resource way processes separated different contexts set 
universal tuple space ligia structure tuple space processes 
uts ts ts ts ts ts communication 
ligia model linda family inherits properties time space decoupling generalization characteristics demand existence order need open systems clearer consider exam ple program 
shows sketch process wants offer service ken tuple space offer 
world ligia linda way put service tuple service name handle requests offered tuple space process stores process blocks tuple space waiting requests 

universal tuple space program program process offers service cess request service tuple space pro process request service process program unblocks computes result stores result back tuple space making result avail able requesting process 
simplified idea situation reasonably common 
problem example process offering service restricted scope tuple space known process provided process access depicts open environment showing situation described system ed halves unable communicate resource allow communication 
shows processes get access tuple space consequently see service offered tuple space separated half virtual wall barrier dividing system halves 
necessary tuple space overcome barrier stance communicate global resource context 
obviously specific case solution formulated problem generalized solved global resource chapter explained concept garbage object vis outside world 
garbage collection scheme ligia closest outside world process get 

universal tuple space universal tuple space processes unable communi cate 
offer ts ts 
class tuple space handles acts start point garbage collection scheme useful object visible outside world special case created process 
tuple spaces created processes processes spawned linked tuple space pro vided model exception rule avoid chicken egg problem process created tuple space process linked 
class tuple space handles object said class object language assigned vari ables compared object structures language short ma language 
linda objects tuples tuple spaces pro cesses 
linda community endlessly discussed topic class objects implementations assume tuple spaces process class ob jects 
class tuple spaces processes interesting idea despite posing generalization model practice implementation leads questions remain unanswered 
idea tuple spaces class objects proposed gelernter gel description multiple tuple space model 
thought tuple spaces class objects exist tuple elements stored tuple spaces 
idea general interesting semantics need defined decides implement 
idea linda primitives understood 
model provides primitives store read remove tuple tuple space 
seman tics primitives defined 
removing tuple process side effect process template effect predictable model process blocked suitable tuple placed tuple space 
tuple spaces assumed exist tuple elements process poten tially remove tuple read tuple 
semantics case 
far implementation full account implications assumption may 
instance process removes tuple containing tuple space 
class tuple space handles happen processes accessing tuple space 
access tuple space tuple space longer exists linda envi ronment exception occur process 
tuple read removed 
tuple space duplicated 
version tu ple space processes access 
questions difficult answer surely situations examined model level implementation model done 
unfortunately far implementation reasonable semantics problem 
idea processes class objects exists 
leads intricate questions processes active objects 
tuple containing process 
process duplicated 
side effects du plication 
tuple removed sort problem occurs tuple containing process removed tuple space process 
process just blocked 
process resumed 
son en vironment process requires kept 
general tuple spaces processes class objects brings ques tions model 
answer means complicating model 
ligia chooses implement tuple spaces processes class objects order simpler model implementation features essential 
ligia implements tuple space handles tuple spaces class objects 
names manipulated problem complication structure tuple space considered 
duplication names done side effect model 
ligia tuple space handles generated automatically kernel 
case uniqueness names essential avoid conflicts large scale applications 
fact universal naming problem com mon problem distributed systems due growing number application web applications name conflicts avoided 
corba gro faces problem corba object model relies great extent semantics ob ject uniquely identifies local remote object instance hen 
ligia tuple space handles guaranteed unique model 

tuple space tuple space main ideas linda introduced abstraction physical loca tion 
processes linda aware location objects tuples tuple space processes 
location free characteristic broken considered 
ideally process linda need pay attention location considered process deal location fashion concept intrinsically attached location 
model far considered problem distributed pose abstraction location 
problem justification linda dealing model 
distributed problem facets 
open distributed systems heterogeneity distributed hard perform 
common framework ease things common way deal regardless differences underlying system extent extension space decoupling idea introduced linda 
linda pose com mon framework model provide ways allow linda ligia model assumes existence tuple space tion input output model way hiding physical location users 
nutshell ligia capability tan passed tuple spaces gives kernel knowledge process able perform operations 
model level tuple space represents capability doing kernel point view process handle process chapter shown implementation level sin gle tuple space exist ligia implementation uses new primitive bring system 
concept single tuple space useful garbage collection structure 
point clear having ligia dealing model smooth 
users deal fewer concepts abstracted terms tuple space operations 
filling gap model nation case ligia irrefutable 
start premise linda general coordination language able deal coordination problem problems involving pro 
tuple space cess including existing linda models leave problem dealt computational host language implementations embedded 
gelernter carriero gc language divided orthogonal parts coordination computation part 
linda acts tion add existing computational languages 
orthogonality say problem said coordination problem com putational 
argued fact distributed coordination prob lem opposed kie classes computational 
order demonstrate case take orthogonality argument gelernter carriero ask computation coordination problem 
areas orthogonal problem classified 
consequently lin da coordination model affected computation problems 
re phrase question interfere linda model 
answer linda location free model distributed systems done computation languages coordination problem 
possible state coordination problem view corbett cff see message passing operation 
message passing operation involves process consequently needs coordination 
coordination problem suitable dealt ligia ligia intends seen general coordination model open systems 
said tuple space view model 
implementing model single tuple space necessarily exist rep resent ligia ability doing represented process having knowl edge tuple space 
sake implementation new primitive proposed 
specific details primitive described chapter 
model point view primitive links process tuple space 
important notice brought inside model just sake garbage collection 
fact trying solve garbage collection 
ordering problem appeared ligia incorporates idea distributed coordination problem 
ordering introduced douglas see section ordering property expected users forgotten majority linda implementations 
ligia model assumes existence ordering defined douglas represents expected property open systems 
basic semantics ordering explained ligia assumes formally described property 
property ordering ordered sequence tuple space executed process causal order ordered sequence arrive ordering guaranteed important notice ordering property achieved ad hoc programming techniques 
model guarantee ordering messages impossible process find message just read series message says 
non deterministic model process find message arrive 
model kernel implementation guarantee ordering execution primitives model achieve result 
bonita rw assumes ordering multiple tuple space perspective 
hand models consider ordering description consider single process perspective introducing global state viable open distributed case 
consequently ligia assumes example shown program ordering behave differently ligia ordering single tuple space perspective 
bonita 
assuming process executing program ac cessing bonita guarantees result primitive 
process identifiability program example ordering behaves differently ligia bonita 
ordering relative multiple tuple spaces 
ligia result primitive guarantee tuple ordering guaranteed multiple tuple spaces 
gets tuple stored 
guarantee relation tuple ordering problem relates questions expected model programmer guarantee 
ligia implement cross tuple space ordering ordering expected object report takes view user expect ordering dealing differ ent tuple spaces 
general tuple spaces represent different contexts stored different locations reason overheads af fect 
cross tuple space ordering required programmer guarantee explicit methods 
process identifiability clear ligia provides means spawning processes ligia primitive spawns process active tuple process turn tuple 
description ask primitive needs tuple space handle process completely unlinked tuple space 
explanation historic reasons ligia defines handle semantics primitive closer users linda models second handle defined comprises scope process means 
process identifiability process start executing having knowledge tuple space de fined primitive ligia concerned memory recycling implementations important handle defined structure tuple space usage built accordingly garbage collection scheme 
leads question process identifiability 
view linda model processes uniquely identifiable anonymous com munication important characteristic linda model 
structure tuple space usage built process identified 
simple ligia introduces concept process identifiability ker nel process point view 
concept introduced menezes wood mw implemented authors mw row 
process identifiability introduces awareness processes kernel level model 
knowing processes accessing tuple spaces kernel build structures allow optimisations implementation 
currently lot debate optimisation linda implementations migration processes mi tuple spaces fair distribution tuples network resource management just examples 
process identifiability enables kernel maintain necessary structures optimisations sort imple mented 
take instance tuple space migration 
desirable open linda implementation tuple space maintained closer processes ac cessing moving tuple space location sole process accessing executing reduce unnecessary overhead communication process tuple spaces 
move tuple space closer pro cess kernel identify process question 
take case local tuple spaces 
interesting new tuple space created linda local creator name public 
kernel attach lo cal tuple space process move tuple space process process migrates 
short process identifiability solve practi cal problems related optimisations open linda systems breaking 
process identifiability concept anonymous communication user processes know uniquely identify 
idea process willing coordinate ligia tell kernel advance 
kernel point view registration done implementation irrelevant done various ways ranging explicit registration registration hidden users 
choice im operation depends factors computation language chosen important 
process registered kernel ligia able uniquely identify process idea process unique name model uniquely identifiable 
name process kernel 
generated way process attached kernel name 
worldwide context problem unique universal naming appears 
feature im plemented irrelevant model level clearly done instance uri part process name 
dual process registration process check process tells ligia point time onwards intend model facilities require coordination operations 
point view coordination process exist check 
operation happens impor tant garbage collection generate garbage explained detail chapter 
needless say model point view check scheme implemented important done termi nation detection scheme explicitly check operation instance 
chapter choice explicit check mechanism allows user leave ligia world process termination 
termination detection schemes see processes consisting coordination compu tation ligia computational part process irrelevant check mechanism allow user inform kernel process finished coordination part finished computation 
uri universal resource identifier naming scheme provides unique global tion useful large scale internet applications 

tuple monitoring tuple monitoring tuple monitoring concept concept process registration helps kernel prepared optimisations may necessary implementation 
general ideal kernel able monitor tuples stored retrieved tuple spaces allow kernel aware vital information passed tuple spaces sole form communication processes 
section example process want create local tuple spaces 
said tuple space remain local name passed processes 
kernel know tuple space name ing passed 
clearly tuple space handles class objects stored tuples way processes tell processes names local tuple spaces putting names tuple subsequently storing tuple tuple space 
case kernel able monitor contents tuples find handles passed 
tuple monitoring introduced rowstron row shows improve performance open linda implementations building hierarchical structure tuple spaces 
ligia model assumes tuple monitoring occurs essential maintenance structure related tuple space usage 
chapter way tuple monitoring implemented ligia explained 
con regards performance degradation due overhead doing monitoring discussed showing avoid big overhead tuple flagging client processes flag tuples supposed analysed kernel 

termination ordering termination ordering similar ordering problem termination ordering ligia assures termination message message process arrive ker nel 
fact consider ordering termination message messages representing primitives store information tuple pace ligia store information tuple space considered ordering passing infor mation occur spawning parameter 
ligia model open systems garbage collection essential context garbage collection termination processes plays important role receiving ter message garbage collection decide collecting object 
words considering garbage collection tuple spaces receiving process termination message tuple space may considered garbage collected 
termination ordering guaranteed tuple tuple space arrive kernel cause exception process retrieve tuple try access tuple space tuple space may longer exist 
property formally describes termination ordering property 
ligia mo del assumes property implementation ligia tee property 
termination ordering property aims guarantee garbage collection done free race conditions 
done similar way douglas ordering problem 
douglas introduces messages execution executed previous acknowledged 
property termination ordering ordered set messages causal order sent process ordered set messages order received server process 
termination ordering guaranteed problem race conditions operations updating structure term termination mean different things clear termination occurs instruction process external intervention considered 

termination ordering garbage collector known 
usually way solve problem implement variations distributed garbage collection algorithms take ac count problem 
case ligia ligia assumes ordering option extending characteristic take account termination attractive implementing complicated garbage collection algorithms take problem account 
glance termination ordering may restrictive look ing carefully see restrictive 
termination ordering imposes ordering termination message mes sage sequence storing primitives 
analysing property see ordering imposed subset messages processed suitable order turns mes sages ordered due ordering 
additionally termination ordering pay attention primitives semantics primitives wait result point message sent result received 
termination ordering property imposes ordering set implemented atomic contains messages primitives operations need considered result returned operation carried 
order clarify case primitives consider 
depicts possible cases primitive arrive af ter termination message receiver side 
case primitive followed sequence primitives termination message receiver order primitive arrives ter message 
case clearly impossible sequence primitives sent receiver primitive executed receiver due characteristics 
second case primitive follows sequence primitives followed termination message 
arrives receiver termination happen termination 
termination ordering impossible cases ordering termination message primitive sender receiver sequence sender receiver termination sequence message sent receiver sender receiver termination sequences processed receiver 
third case similar case order receiver side happen second sequence primitives sent processing primitive replaced atomic sequence atomic 
case ordering maintained automatically guaranteed primitives replaced sequence composed prim termination ordering property 
order show termination ordering guaranteed primitives consider primitives atomic operations 
individually 
considered case common case program store handle created just execu tion process executing program aware existence point execution handle available process accessing observe termination executed 
termination ordering program termination ordering garbage collection scheme decide garbage remove garbage collector information related storage tuple space handle 
anticipated execution occur non blocking primitive sends message server tuple stored 
executed handle available processes access tuple space longer exists system 
conclude termination ordering necessary consider ing primitive program termination ordering assuming standard semantics program shows case primitive case primitive similar field tuples evaluated parallel 
case ligia interesting show behaves originally defined problem considered side effects avoided 
simi lar case termination message processed primitive 
noted impose restriction parent wait completion child process 
active tuple stored tuple space form termination message processed 
parent process terminate case process executing executing 
existence active tuple sufficient garbage collection scheme implemented 
ligia model considered process receive handle parameter 

termination ordering case program look program 
execution completion child process carried avoid pre mature collection kernel realise process knowledge monitoring 
program termination ordering primitive program termination ordering primitive ligia case 
considering primitive problem bit subtler 
returns value execution different 
atomic operation implementations choose lose ty gain performance due implementation choice 
ligia model prepared deal ordering implementation atomicity 
program shows example primitive spaces created handle stored immediately read tuple guarantee took place 
see divided parts matching removes tuple matching stores executed moving tuples tuples termination ordering property guarantee second part occur termination message 
part removes tuples containing handles tuple space lost termination message processed wrong time 
second part 
final remarks stores handles tuple space executed guar tuple spaces restored 
program termination ordering primitive program shows case primitive similar case primitive shown program 
basic difference tuples copied moved reason think ordering required original links lost 
observe true tuple space question accessed processes 
original links removed second part causing situation similar primitive message executed second part final remarks termination chapter ligia model highlighting differences models described previous chapter 
new concepts introduced ligia important dissertation process identifiability introduces concept processes uniquely identifiable ligia tuple moni states model analyse contents tuples stored retrieved tuple spaces termination ordering says message informing kernel process termination arrives server message process arrive server 
chapter incorporation garbage collection garbage collection done ligia 
importantly done 
answer question clear ligia aimed open sys tems 
open environments compile time optimisation option concept compile time entire system 
garbage collection nec essary objects created ligia removed system 
general open environments impossible process decide object required system process ligia view global situation 
question done depends way looks problem 
argue primitive way garbage collection process removes tuples sary 
solution controlled environment solution general case tuple stored tuple space process guaranteed retrieve tuple tuples template exist tuple space 
carefully analysing characteristics ligia linda models easily see concept ownership tu ple exist tuple uniquely identifiable identification retrieve tuple matching mechanism 
answer garbage collection done case 
noted statement answer problem statement direct garbage collection tuples impossible standard linda model 
garbage collection implemented model provide suitable way model changed provide means doing memory recycling essential open system 
turns model need modified model provides structure garbage collection 
proposal multiple tuple spaces gel pro cess create tuple spaces opposed tuples uniquely identifiable 
tuple spaces handles process access tuple space handle known process 
garbage collection tuple spaces feasible tuples collected consequence stored tuple spaces difference granularity collection coarser 
similarly case remove unnecessary tuples tuple spaces argue delete tuple space type operation implemented remove unnecessary tuple spaces 
case similar tuple case operation nature securely implemented process declare tuple space garbage global view situation tuple space hard obtain process point view 
tuple spaces unique handles handle stored tuple spaces process know process retrieved handle kernel hand know information ligia underlying model 
clear main problems doing garbage collection tuple spaces linda information processes require tuple space insufficient 
ligia introduced concepts processes unique universal tuple space naming tuple monitoring conse quently allow ligia maintain structure kernel garbage collector 
construction structure race condition free owing tence termination ordering property see property 
argument indicates main problems overcome 
garbage collection scheme 
correctly maintain information necessary doing garbage collection 
der chapter concepts introduced kernel level propose way maintain graph information accessibility tu ple spaces processes 
chapter divided follows section garbage collection scheme briefly discussed aiming form background graph structure understood 
section general structure graph explained introducing concepts necessary building struc ture described centralised 
section solution extended distributed case structure distributed graph explained concepts involved doing 
section main procedures involved graph maintenance described high level terms regardless graph centralised distributed 
section execution garbage collection scheme briefly described section explored examples show ing graph situation execution garbage collector depicted 
garbage collection scheme 
section standard garbage collection schemes described 
order decide scheme appropriate ligia look concept garbage ligia 
said object garbage visibility outside world 
structure implemented represent outside world tracing method easily 
turns ligia representation specification tuple spaces 
tuple spaces create boundary ligia outside world see 
represent outside world channel processes setup communication previous knowledge 
tuple space represents outside world represents capability process nutshell seen representation outside world ligia processes access outside world 
tracing methods difficult expensive implemented 
garbage collection scheme 
create boundary separating ligia outside world 
comm channel uts devices file system distributed case counting listing 
tracing complete method identify garbage nodes graph 
order points tracing completeness counting suitability distributed graphs idea build graph hybrid method counting executes tracing performed required 
tracing phase necessary cycles hap pen graph explained section listing refer ence counting collect garbage cycles nodes 
methods counting listing garbage cycles collected lin jl 
ligia case benefit implementing complicated algorithm costs expect listing collect garbage making tracing phase plus necessary 
additionally stan dard algorithms suffice distributed case model guarantees implementation race conditions ligia resolves race conditions model level 
garbage collection scheme implemented ligia phase 
centralised graph structure garbage collector composed counting phase tracing phase tracing phase reachability seen see garbage 
graph structure follows common tracing graph concept tracing methods containing information counting algorithm counter 
specific ligia terms object considered garbage 
node graph counter field equal zero concept valid tuple space objects processes referenced ligia processes know 
node graph unreachable said graph contains representations active objects tracing resume active nodes see reach idea clearer chapter 
object considered garbage due case considered garbage case opposite hold cases shown separate ly 
expected cases objects identified garbage owing case identified counting phase 
structure invariant object considered garbage useful 
invariant guarantees erroneous collection occurs collecting node eventually 
centralised graph structure generally linda implementations provide information directly identify tuple space required system 
section describes way build data structure information accessibility tuple spaces process 
processes ligia physically attached tuple spaces tuple space defined primitive defines implicit link 

centralised graph structure additionally multiple tuple space model tuple spaces created process primitive 
characteristics central constructing graph representing processes tuple spaces principle processes linked tuple spaces indirected arcs tuple spaces able linked special directed arcs 
idea represent tuple spaces linked process access processes linked tuple space represent knowledge graph represent view object garbage seen outside world see outside world fact reason having second part clause graph represents active objects processes passive objects tuple spaces active objects change graph way objects visible outside world visible 
graph constructed kernel represent idea garbage object 
graph general description ligia kernel maintains graph containing direct indirect arcs acts main source information garbage collector 
assumptions maintenance structure points addressed detail 
point description graph maintenance done regardless distribution issues section having understood simpler case described distribution issues explored 
nodes representing roots graph 
nodes starting points tracing phase decides node garbage reachability starting nodes 
nodes counter fields set infinity garbage collected 
god process assumed spawn main process linked god process abstraction users 
represented created god process bootstrap operation 
concept main process linda defined 
purposes process considered main process process spawned means 
centralised graph structure graph existence clear order unify concept process represented graph linked tuple space 
links processes tuple spaces indirect arcs links tuple spaces done weighted directed arcs called bridges 
processes tuple spaces represented graph 
nodes repre senting tuple spaces additional field counter 
node representing process linked initial tuple space process linked 
link represents fact process knowledge tuple space operate 
tuple space node linked process node representing creator 
tuple spaces created primitive due tuple monitoring process registration ligia knows process executing primitive 
node representing process linked tuple spaces knowledge 
knowledge initial tuple space tuple spaces creates process acquire information tuple spaces receiving handles ways spawning process parameters passed handle 
process registration kernel links node representing process nodes representing tuple spaces handles received parameters created 
tuples stored tuple spaces 
soon process read withdrawn tuple containing handle link graph created represent situation achieved tuple monitoring 
nodes representing tuple spaces linked bridge handle initial tuple space tuple space defined primitive 

centralised graph structure stored 
bridge outgoing containing tuple space incoming contained tuple space 
points construction graph unclear con cept involved understood 
sections point explored detail necessary pictorial view 
node section case ligia clear open systems require existence global persistent resource 
report moves implementation model concepts introduced model level restricted achieve stable implementation 
defined resource known processes concept modified problems concept known main processes 
order spawned processes processes descendent main processes know handle passed explicitly 
note concept interfere argument global resource exist 
fact global resource exists access controlled 
choice making access automatic main processes hap operations side effecting process get access process consequently nodes reachable garbage collected 
controlling access occurrence side effecting opera tions minimised number tuple spaces garbage collected maximised 
regard creation graph node representing added graph ligia system starts 
node garbage collected cre ated counter field set infinity starting point tracing phase 
ceases exist ligia terminates execution 
context report case considered worth talking problem system system running 

centralised graph structure graph situation creation nodes ligia system 
node uts section concept coordination problem introduced 
context garbage collection ability handle 
process knows tuple space implementation clear tuple space exist reality existence context garbage collection 
practice implementation introduces primitive called abstracts file tuple space explained chapter 
tuple space node graph seen representation process perform capability passed processes 
practical terms process linked node execute primitive link created structure ligia system starts execute 
initialisation ligia system graph depicted 
report graph structure shown dashed lines added graph dotted lines identify removal object graph 
case main processes assumed able linked node start 
maximises power garbage collector processes garbage collected process executing communicate outside world process garbage doing process get know 
achieved ligia provides boundary system outside world fact need explanation idea process garbage process doing untraceable outside world 
means say process direct link outside world represented considered alive garbage long communicate 
centralised graph structure process links outside world 
process garbage communicate outside world directly indirectly 
spawning main processes ligia assumes existence primitive normally called allow processes spawn parallel 
semantics primitive ligia tuple space specified process initial tuple space 
ligia process implicitly linked tuple space tuple space main processes supposed linked 
main processes started ligia external entity onwards spawn processes main processes ligia processes linked tuple space require start executing 
order change say ligia processes linked tuple space define tuple space 
appears natural candi date created kernel known main process 
terms suppose god process creates represents union users sense user wants start process tells god process spawns process main process linked god process user job exists concept process creation unified model ligia processes linked tuple space 
god process represented graph structure god process relation concerning tracing phase garbage collector reachable reach able god process vice versa existence representation redundant 
additionally god process exist reality just abstraction users graph structure represents ligia ob jects 
take view ligia processes exception created explicitly primitive 
execution primitive node graph created linking process tuple space defined primitive 

centralised graph structure order assign unique name node representing process graph process registration explained section immediately follow spawning 
process registration described processes ligia register require ligia coordination facilities 
done ligia able uniquely identify process 
ligia processes mutators garbage collection algorithm 
primitives executed require modification graph structure 
mutators kernel able iden tify execute primitive alter graph 
processes keep track tuple space usability 
process registration occurs processes spawned registration consists messages sent process kernel assigns unique identifier process sent back kernel informs process identifier 
process identifier executing ligia primitives 
unique identifier transparent processes 
unique identifier assembled messages sent kernel 
seen done processes assembling hidden programmer point view exist 
registration process links process tuple spaces handles passed parameters updated links process created ligia point view process starts exist 
shows graph situation main processes start run linda environment register kernel 
depicts processes necessary links added graph 
particular case processes main processes default know names processes appearing figures simpli fied better clarity 
fact ligia implements unique process naming real identifier uniqueness achieved explained chapter 

centralised graph structure main processes register kernel just start running 
uts creation tuple spaces 
tuple space linked creator 
uts creation tuple spaces ts ts ts linda model provides primitive create tuple spaces 
primitive cre ates local tuple space returns unique handle 
blocking operation unique handle returned handle primi tives 
unique handle identifies tuple space kernel label tuple space node graph structure 
creation tuple spaces kernel operation process requests cre ation operation performed kernel level 
receiving handle process graph updated accordingly 
kernel identify creator tuple space message requesting creation contain process identifier 
tuple monitoring kernel extract identifier create node represent new tuple space graph nique handle create arc linking process tuple space just created tuple space linked creator process 
shows graph situation just creation tuple spaces 
centralised graph structure process tuple space process starting 
creating bridges tuple spaces ligia assumes handles class objects manipulated class objects 
class handles placed tuples consequently stored tuple spaces 
storing handles tuple spaces important operation garbage collection algorithm 
handle stored dependency created tuple spaces handle stored dle kept stored garbage happens process access gain access tuple space processes accessing long han garbage retrieve handle potential access order graph structure represent dependency concept weighted directed arcs called bridges linking tuple spaces 
bridge outgoing containing tuple space incoming tuple space handle stored 
weight attached bridge indicates number tuple space handles stored particular tuple space 
depicts graph modified steps shown code 
code code ligia main process 
depicts registration process assignment unique name case node representing process created graph 
centralised graph structure execution steps code uts uts line ts ts line uts ts ts line uts ts ts line uts uts line ts ts line ts 
centralised graph structure linked main process 
depicts creation tuple space kernel assigns unique name new tuple space creates node graph represent tuple space executed primitive created linked node created counter set shows creation tuple space kernel assigns name tuple space node created represent graph step similar previous step 
depicts creation bridge linking tuple contain ing handle stored bridge created width bridge created previous bridge linking tuple spaces counter updated due bridge creation tuple space clearly counter field tuple space node takes account incoming bridges node 
step code depicted stores tuple contain ing handle case bridge linking tuple spaces bridge wider having width updated counter field increased new handle potential created new 
step process depicted 
process termination checks kernel node representing process links node deleted graph necessary updates counters tuple spaces linked process done 
execution tuple space garbage refer ence counter fell zero hand tuple space alive counter field set process termination ligia context process terminates checkout operation executed process 
process execute ligia facilities ordinate 
process termination may understood differently important 
centralised graph structure process terminates generating garbage 
uts ts ts ts clarify report abnormal termination considered 
process termi nation triggered users due failure system left 
process termination important operation garbage collector way garbage created 
bridges removed oper ation generate garbage bridge deleted process removed tuple space handle 
handle removed tuple space bridge removed tuple space transfered process removing handle lost 
hand process terminates process holds lost garbage created 
implementation termination ordering ligia guarantees ob ject garbage process termination links created resurrecting object primitive storing han dle executing termination agree termination ordering property process terminates primitives executed termination order appear code executed 
shows situation graph depicted termi node representing process links deleted graph 
particular case tuple space considered garbage time garbage collector analyses graph structure 
registration checkout operation multiple times possibly 
centralised graph structure overlapping single process 
gives user control garbage collection mechanism creating multiple scopes 
discussed detail chapter 
retrieving handles tuple spaces retrieval handles placed tuples tuple spaces commonest way process getting access tuple space handle placed tuple space processes having access tuple space retrieve handle 
tuple moni implemented ligia allows kernel aware operation involving handles including retrieval handles 
handle retrieved process modifications may graph represent operation executed 
graph modified differently depending primitive retrieve tuple containing handle 
ways retrieving tuples tuple space ligia destructively non destructively 
destructive retrieval tuple containing handle bridge exist linking tuple spaces involved operations narrower deleted depending val ue value greater subtract value exactly bridge deleted width fall zero 
bridge modified counter tuple space need mod ification process retrieving handle access counter decreased process acquiring knowledge tuple space counter need modification new arc link ing process tuple space created update done increment followed decrement zero 
non destructive case simpler 
handle non destructively retrieved bridge need modified handle withdrawn hand counter tuple space node handle withdrawn need updating 
case similar destructive case 
process retrieving handle knowledge tuple space counter need modification process acquiring knowledge handle 
centralised graph structure counter needs increased new arc linking process tuple space created 
property retrieval tuple space handles generate garbage operation executed counter increase remain decrease counter increase retrieval process knowledge see 
remain retrieval destructive knowledge non destructive case knowledge see respectively 
case assumed generate garbage counter decrease retrieval destructive knows counter decreased despite decreasing guaranteed counter case process due existence bridge see 
execution primitives specific primitive change structure 
crucial answer question clear 
primitives modify graph different ways 
examples shown primitives 
order clarify consider code called graph structure 
code code executing different primitives depicts modifications graph respect execution process depicts initial configuration exe 
centralised graph structure possible cases handle retrieval 
uts rd rdp pn uts tsm tsn tsm tsn uts pn inp uts pn tsm tsn tsm tsn uts rd rdp pn uts pn tsm tsn tsm tsn uts inp pn tsm tsn tsm uts pn pn tsn 
centralised garbage collection just execution line assumed example process executing modifications consequence execution 
process registers kernel assigned name point onwards message sent process identified 
fig ure executes primitive creating tuple spaces respectively tuple spaces created counter field set point time creator aware existence 
spawns process linked registration process kernel name assigned linked pro cesses aware initial tuple space 
depicts modifications associated execution time process spawned linked receiving handle parameter process registers assigned name registration node graph linked initial tuple space having received handle parameter spawning process 
figures stored handles respectively consequence bridges created having width set handle execution template contains tuples matching template depicted primitive copies tuples matching copying tuples bridge created self bridge necessary bridges represent depen tuple spaces self bridge identify obvious 
centralised garbage collection section subtleties building centralised graph explored solution ligia implementation results implementation chapter 
important scheme doing garbage collection understood 
section shows 
centralised garbage collection pictorial execution code 
uts uts initialisation ts ts line uts ts ts line uts ts ts line uts uts ts line line uts ts ts ts line uts ts ts line uts ts uts ts ts line ts line uts ts line uts ts ts termination 
centralised garbage collection garbage collection scheme behaves executing centralised struc ture 
explained graph built phase garbage collection gorithm takes place 
phase counting basically analyses graph garbage collects tuple space node counter set zero 
phase executed frequently collects passive objects garbage collection processes done 
depicts possible graph situation point execu tion ligia counting takes effect identifies col objects dotted lines 
tuple space identified garbage node graph counter field set zero 
observe outgoing bridges add counter bridges outgoing tuple spaces process access node representing removed counter tuple spaces referenced updated doing counter falls zero causes garbage collected 
reason doing garbage collection processes expected sorts garbage collection occur frequently 
processes expected terminate normally process deadlocked dis appear structure processes persistent objects ligia 
fact processes identifiable garbage counting phase odes include counter 
allow collected tuple space attached constitute 
tracing phase intended run occasionally alternative counting 
explained chapter counting incomplete collect garbage cycles 
structure ligia maintains problem worse tu ple spaces referenced processes unable communicate outside world identified garbage case tuple space instance 
depicts graph situation just collection node iden garbage counting phase 
depicts graph af 
centralised garbage collection tuple spaces garbage collected counting 
uts ts ts ts ts uts ts ts initial scenario 
ts ts ts ts ts ts ts ts ts ts counting 

centralised garbage collection tuple spaces garbage collected tracing 
uts ts ts ts ts ts initial scenario 
uts ts ts ts ts ts ts ts tracing 

distributed graph structure ter tracing phase nodes left considered garbage case tuple spaces plus processes garbage collected 
tracing phase implements concept view outside world ex 
trace graph performed starting roots node path marked black identify node useful 
trace resumes blank process nodes goal see processes seen outside world see outside world problem case process seen seeing outside world anytime modify graph seen outside world 
case garbage seen outside world see 
linked instance collected remain graph 
needless say examples depicted simplified 
order basics algorithm understood cases assume pas sive graph structure process adding 
real case situation different processes may mutating graph garbage collection phases take place 
care taken avoid con currency problems section refrains explaining subtleties explained section 
phases centralised graph implemented allowing concur mutators ligia processes garbage collector note solution passive structure snapshot graph fea sible 
conservative approach thesis implemented error prone nodes garbage come useful 
distributed graph structure solution described far centralised graph structure cause clear distributed graph bring benefit 
distributed graph structure system 
ligia uses distributed central servers strategy cg ad distribution graph clear distributed version solu tion described previously avoid possible bottlenecks processes modifying graph time 
linda systems processes migrate ed solution necessarily better centralised case 
central elements proposed garbage collection scheme tuple spaces linda systems single tuple space stored single location 
tuple space im done having contents distributed fore single tuple space partitioned 
case absolutely clear application existing distributed garbage collection method non partitioned objects produce better performance 
graph distributed order distributed garbage collection algorithms method forced arbitrarily choose location nodes representing tu ple spaces question realistic choice tuple spaces partitioned 
addition garbage collection method unable choose proper locations processes mutators garbage collection algorithm processes move location best location put representation process migrate anytime 
instance process located mutating graph located process located mutating graph located commu nication remote 
solution proposed section different locations assumed single graph stored locations process local communication 
having said advantages distributed solution ligia case processes migrate tuple space stored single location exist produce better performance noticed large applications 
order extend centralised solution described previously distributed case modifications necessary order guarantee correctness central servers distribution strategy assumes tuple space physically stored single location see property 

distributed graph structure local global collectors cooperating collection objects distributed graph structure 
kernel local collectors global collector linda processes algorithm 
intention local garbage collectors working independently time cooperating global collector shown 
division forces inclusion sort identification locality objects graph local objects collected local collectors collected global collector 
said ligia implement process migration distri bution tuple space contents implementation linda 
important consider problems solution 
main problems overcome distributed case related location representation linda objects 
processes tuple spaces able migrate problem store representation object process tuple space important try minimize communication overhead 

distributed graph structure order implement garbage collector representation tuple processes anchored location solution migrating representation hard implement probably inefficient processes tuple space migrate frequently migration ob ject imply messages sent structure due dynamic nature structure race conditions appear anchoring processes tuple space representations implemented unique naming processes tuple spaces ligia assigns names contain location object created 
anchoring node graph defined creation ligia object node represents representation process created location process tarts execute 
event process migration representation move 
kernel extracts name original location process unique identifier 
representation tuple space created location rep resentation creator process process executes prim itive creating tuple space 
case process migrated original location tuple space representation created original location 
ligia system composed single kernel kernel divided locations assumed ligia executing location 
forms kernel collection ligia system aware existence communicate 
graphs shown onwards extra nodes representing processes labelled name location originally started remind location extracted names 
names diagrams simplified explained chapter formation names assumes complex structure 
said distributed solution constructed local global col local collectors verify object garbage locally considering 
distributed graph structure distributed representation graph structure divided locations 
uts ts uts ts non local object ts reachability objects local graph 
neces sary introduce concept distinguish local global nodes 
distributed case node considered global object outside location processes process es tuple spaces nodes differentiated graph 
notice concept related concept local global tuple space proposed rowstron wood rw context local garbage collector tuple space local referred processes representa tions node tuple space rowstron wood define local tuple space known process 
early example suppose scenario locations avail able distributed open linda system 
processes start execute loca tion migrate demand 
shows locations squares containing local graph 
processes currently ing location depicted linked outside square representing location labelled showing location originally started necessarily linked time 
shows case processes currently running location process currently running note linked location graph representation exists location means 
distributed graph structure starts execute linked represent ed local graphs tuple space representation exists location 
case local tuple spaces global tuple space clearly local process access represen tation location local represented location process representa tion bridge exists location remains local handle retrieved process location global tuple space 
global represented location storing handles 
rules graph creation explained section valid dis tributed variation 
apart rules distributed graphs follow ing characteristics root nodes mandatory objects graph 
new location available system graph creat ed containing nodes stay location removed system 
simplicity thesis assumes location removed local graph contains nodes 
solution location removed anytime possible require rules migrating local garbage collection graphs 
removal opera tion seen fault system outside scope current fault tolerance important tackled thesis 
rectangle involving graph represents location labelled capital roman letter 
nodes representing processes shown outside rectangle rectangles labelled form label name process plus original place spawned 
emphasises possibility process migrate 
nodes representing processes shown graph unique 
representation process exists local graphs 
location local 
distributed graph structure graph identified name process represented squares outside locations 
nodes representing tuple spaces shown graph labelled ovals form form shown graph real name tuple space representation location redundant diagrams tuple space name ends case processes label identifies kernel able say tuple space represented location nodes counter fields centralised case 
similarly centralised case undirected directed arcs bridges linking objects 
distributed case local arcs link objects location remote arcs involve objects different locations 
ligia processes mutators graph 
guaranteed cen case mutation race condition free due level ordering messages arrivals kernel implemented solution ordering problem termination problem mw explained chapter 
building distributed graph similarly done centralised case distributed maintenance graph calls examples better understand operations 
operations involved basically centralised case migration processes similar sequence actions 
systems starts locations 

processes start execute location location 

process creates tuple spaces process creates tuple space process creates tuple spaces 

distributed graph structure 
process spawns process linked process linked process process creates tuple space process spawns process linked spawns process linked receiving handle parameter 


process stores handle process stores handle stores handle 

process removes tuple gets handle terminates terminates terminates 

centralised case explained understanding operations shown figures straightforward 
depicts locations local graph containing depicts graph situation processes start execute graph nodes representing processes labelled location squares outside boxes representing locations labelled lo cation remind process name contains location representation graph 
depicts creation tuple spaces label contain locations representations remind tuple space handle formed containing location representation counter field nodes behave similarly centralised case counts number refer ences tuple space available system remote ones 
simple depicts spawning processes assumed process spawns processes location executing processes migrate different locations execution 
depicts cre ation local bridges link tuple spaces location 
retrieval remote handle caused node representing tu ple space marked non local identifies node local garbage collector node needs analysed global context system fore collected processes terminate causing links removed 
shows nodes garbage col lected garbage collector starts execute 
execution distributed 
distributed graph structure pictorial view graph distributed execution operations ligia 
uts uts uts uts uts uts ts ts ts ts ts ts ts ts ts ts ts uts uts 
distributed graph structure pictorial view graph distributed execution operations ligia continuing ts ts ts ts ts uts uts uts ts ts ts ts ts uts ts ts ts ts ts ts ts uts uts ts 
distributed garbage collection garbage collection explained section graph situation 
distributed garbage collection open systems require fly garbage collection dynamics system possibility distributed large scale networks require garbage col lection done system execution 
alternative way implementing garbage collection algorithm world policy ble open systems adds huge overhead time taken process es unpredictable 
maintenance graph guaranteed happen fly freed race conditions due nature ligia system 
ideally maintenance graph collection phase occur fly section describes implemented fly distributed case explanations valid implementation centralised case explained section 
definition garbage ligia similar case actors agh de fined jones lins jl object ligia considered garbage experiment detect object outside world 
nodes distributed graphs represent boundary outside world representation outside world ligia 
tracing phase garbage collection scheme implemented ligia roots algorithm 
scheme implemented distributed case composed additional phase compared centralised case 
algorithm divided main phases local counting local tracing global tracing 
particular order execution global tracing phase described section needs result graph situation local collection execution local tracing phase described section local collectors 
required remaining nodes graph represent non garbage objects collection phase garbage created 
distributed garbage collection phase identified 
guaranteed object garbage eventually collected collections 
counting phase phase counting 
choice counting algorithm adds little overhead system easy implement concurrently execution ligia processes drawback counting unable collect garbage cycles appear graph ligia 
cycles exist graph minimal compose majority garbage nodes 
observation linda systems shows tuple spaces local process known processes part cyclic structure programmers tend global resource creating tuple space making global 
shortage linda applications fact killer application 
observations mentioned done experience prototypes examples literature general tuple space short lived 
difficult draw prototypes reasonable believe tuple space behave manner memory locations context general garbage collection short lived ar 
phase intended run frequently hopefully collect garbage objects created 
choice method overhead distributed systems counting algorithms ones perform best jl 
point execution system local collectors explore local graphs searching tuple space nodes counter field set zero 
representation removed graph equivalent tuple space deleted system 
tuple space representation counter field set zero said garbage means process access tuple 
distributed garbage collection local counting phase location finds tuple space garbage 
uts ts ts ts ts ts ts uts space 
overhead minimised method implemented processors idle time system analyses load processor 
structure graph important phases garbage collection phase graph traversed suitable way fact programmer forget graph connectivity traverse graph data structure represents graph implementation 
shows creation garbage due termination process 
centralised case process termination way cre ating garbage 
tuple space garbage existence detected external observer counting directly find observed outside world garbage particular case links whatsoever fore reached outside world 
nodes graph garbage detected counting phase 
chosen collect processes counting phase tuple spaces ligia active objects refer ence counter represents number tuple space 
processes hand active objects counter representing needed ligia communicate directly 
active ob 
distributed garbage collection jects able side effect outside world 
process garbage col lected 
counting phase modified consider processes counters introduce concept algorithm part definition linda systems processes decided specification method implemented algo rithm perform operation fact motivations implementing multiple phase garbage collection scheme tracing find garbage processes introducing concept processes 
local tracing phase main goal local tracing phase collect local cycles build stable framework global tracing phase follows collect active objects outside world collected counting phase 
local graph traversal started roots 
traversal local follow remote bridges arcs 
information remote stored passed global tracing phase 
phase garbage collection takes conservative approach algorithm implemented aims avoid false reclaims live objects 
jones lins jl tracing algorithm live object falsely garbage collected object invisible collector collector reach object needed mutator 
standard tracing algorithm visited objects marked black ob jects revisited course marking phase algorithm reach es black object explore path 
black object white object due changes mutator white object explored path reaching object 
problem standard approaches tracing guarantee side effecting conditions happen 
candidate method ligia guarantee cases way avoid false collection objects 
distributed garbage collection 
avoid black white 
keep original 
approaches choose keep original case object collected mistake costly 
idea garbage collected object appears system system able restore ob ject 
problem type approach generate sort chain reaction recovery object forces recovery object forth 
question long kept 
words garbage collected object chance referred mutator method implemented tackles problem satisfying condition 
third color grey introduced similar way dijkstra dlm phase seen divided different parts marking collection 
marking aims traverse graph mark useful system collection uses coloring done marking collect objects 
ligia marking done steps initialisation nodes local graph coloured white 
need follow graph structure done internal data struc ture represents graph ligia implementation fact graph structure nodes colored white left system forever 
initialisation exclusive access graph execu tion impose big overhead graph local initialised quickly 
creation new objects algorithm fly 
graph mutated time local collector doing graph traversal 
new objects created black white objects objects colored grey entry grey table created 
new objects black grey objects requires action 
creation new objects initialisation step done quite intricate 

distributed garbage collection necessary care taken generate black white 
ligia creation new objects graph delayed initialisation 
graph traversal node locally reachable roots coloured black 
ode colored black paths descendent nodes followed nodes colored way back search black white condition holds 
active objects represented graph necessary verify nodes reach roots active object reachable outside world able reach fore able mutate system 
graph traversal resumes active object marked black 
traversal algorithm find nodes colours black grey white 
node coloured black path need explored node left black 
node coloured white grey algorithm continues explore paths node colored black care remove entry visited grey node grey table 
grey table nodes colored grey result creation new objects graph 
new object created white nodes colored grey 
grey nodes need explored traversal reason existence grey table 
table traversal node table traversal resumed 
marking phase nodes graph colored black white 
algorithm terminate grey node grey ta ble emptiness grey table condition termination 
important understand algorithm terminates deadlock livelock prop erty informal proof termination 
marking finishes nodes graph colored 
black nodes non garbage whilst white nodes considered garbage locally 
white nodes collected investigation situation 
dis tributed nature graph calls care collecting white nodes locally 
disconnected component white graph component 
distributed garbage collection property local tracing phase terminates local tracing phase local graph divided graphs possibly empty white nodes possibly disconnected black nodes connected 
reasoning graphs referred white black graphs 
reasoning white nodes grey necessary concentrate behaviour white nodes marking phase 
trivial see number white nodes candidate grey nodes graph tend diminish new white node appear system initialisation phase marking executes white cells marked black soon algorithm reaches grey new node black created 
way observing evolution marking phase degree connectivity minimum number edges completely separate parts graph case black white parts white black graphs marking executes degree connectivity tends diminish get zero 
note connectivity graphs diminishes chances node grey diminishes case new node gets object nearly disconnected black graph alive nodes rare white graph disconnects completely black graph chance node grey zero mutator entity color nodes grey way get white nodes 
number grey cells appear graph bounded number white cells 
algorithm resumes explore grey table grey entries included graph number limited number white cells finite possibility livelock algorithm consumes grey entries table 
number grey nodes eventually fall zero causing algorithm terminate 

distributed garbage collection example situation local marking phase system local graphs 
ts uts uts ts ts ts ts collected cells marked global objects compo nents contains non local node graph collected global collector verify situation component phase collection 
depicts situation just termination local tracing phase 
white graph divided components location identi fied possible garbage 
observe components collected locally elements local 
component composed identified possible garbage collected local collector marked non local object 
local collector start doing local tracing anytime complete ly independent 
global collector start making decisions global state non local objects local collectors reported local situation 
global tracing phase global tracing phase garbage collection method implemented ligia 
particular case tracing chosen reasons firstly cycles appear graph secondly graph static 
global graph phase built combining local graphs 

distributed garbage collection concurrency continues local graphs global graph concurrent access 
aim global collector identify nodes garbage said local collectors follow links side boundaries locations 
conservative approach exists important property guarantee alive objects col lected mistake 
phase collect garbage cells global graph cells represent actual situation freeze local graphs 
mutation allowed local graphs possi ble object global graph garbage fact garbage point time 
noticed local graphs roots nodes replicated representation process tuple space system 
case possible join local graphs representing status system 
global tracing decides execute sends message local collectors requesting local graph situation 
possible solutions implemented local collectors send graph performing local tracing send graph performing local tracing 
second option appropriate minimises size graph sent situation local graph local tracing global tracing 
example suppose scenario local tracing phase lo cations case depicted scenario start point 
node location garbage local trac ing collected marked non local object likewise node collected reason 
location compo nent white graph garbage local tracing case component analysed node belonging marked non local component collected local collector 
global graph constructed local graphs 
construction 
distributed garbage collection scenario just local tracing phases 
ts uts ts ts uts ts ts global graph 
result graph marked global tracing phase 
ts uts ts ts ts ts done combination exist graphs roots global graph result operation shown 
global graph constructed new tracing started order trace nodes initialised white 
choose result local tracing black nodes generate possible black white particular case generate problems global graph stable 
important understanding method properties consistent phases garbage collection 
case depicted cycle composed garbage removed graph 
nodes identified possible garbage local collector see 
algorithm general description collected local tracing guarantee case entire system 
cycle composed example 
previous stage local tracing identified cells possible garbage reality garbage entire system considered 
clearly shows conservative approach local tracing collecting nodes guaranteed garbage correct 
algorithm general description garbage collection scheme described details ally implemented 
question difficult answer showing code 
garbage collector phases works race condition free manner maintenance graph guarantees 
section aims explore maintenance graph implemented showing meta codes operations involved information necessary counting garbage collector tracing maintained graph 
algorithms sketch individual parts maintains graph supposed running kernel 
description existence functions assumed clarify codes meaningful names functions hoping clear 
description algorithms consider coloring odes clear alive cells collected necessary coloring done 
order avoid race conditions best way see algorithms described occuring atomically words updates require exclusive access structure 
algorithm describes update graph process starts execute 
creation unique identifier process line node representing process graph created line 
node representing pro cess created graph step update counter field nodes representing tuple spaces node knowledge counter process initial tuple space updated followed creating link 
algorithm general description algorithm creation processes process registration 
nodes lines 
line main part process registration done necessary update graph regards tuple spaces handles passed process parameters 
loop performed operations case initial tuple space tuple spaces handles received parameters 
loop line handles parameters line tests see link nodes ex graph exists needs done regards tuple space node question knowledge process represented 
link counter tuple space node incremented link created lines 
step algorithm consists returning unique name process process point onwards process name communications ligia kernel 
spawning new process cause race conditions system tackle necessary problems 
instance process knowledge tuple space say process process spawns called linked happens terminates starts 
typical case race condition exist ligia 
solution problem addressed ligia level left garbage collector deal 
ligia guarantees case mentioned process terminate spawning complete registers kernel 
algorithm describes maintenance graph regards creation tuple spaces 
process executes operation message sent 
algorithm general description algorithm creation tuple spaces 
kernel tuple space created necessary updates graph take place 
process tuple monitoring identify process sent message primitive executing 
receiving message request ing tuple space creation kernel assigns unique handle tuple space line handle assigned tuple space node graph rep tuple space created counter field set lines creating updating counter algorithm shown separately 
line nodes representing process tuple space linked indirect arc line unique handle returned process assigned local variable identifier necessary tuple space 
garbage collection scheme say levels race condi tions race mutators collectors macro view problem sort race condition explored previous chapters guaranteed occur ligia due termination property 
level race condition occurs micro level level operations graph 
instance algorithm line performed separately line collector decide collection tuple spaces counter set 
basically reason algorithm seen atomic operation 
storing tuple space handle tuple space creates depen dency tuple spaces needs represented graph 
algorithm describes operation creating bridges result tuple space handle stor ing 
tuple monitoring allows kernel identify handle stored process executing operation operation tuple space 
algorithm general description algorithm storing handles tuple spaces 
stored 
mentioned bridge directed arc direction depends tuple space contains handle 
algorithm assumption stored gorithm test bridge linking step direction line bridge width updated adding line bridge created width set algorithm destructive retrieving handles 
algorithm describes destructive retrieval handles tuple spaces 
gain tuple monitoring kernel extract unique identifier process executing operation handles tuple spaces involved operation 
assume handle extracted process retrieving handle gains access tuple space handle identifies process may access tuple space line 
algorithm behaves differently case linked link created graph line case counter need updated removal handle imply decrement counter process gain ing access tuple space imply increment counter counter increment decrement left algorithm affected bridge exists opposite direction 

algorithm general description case linked line slightly different 
case link need created exists consequently counter field modified increment take place case counter field decremented line 
width bridge updated handle removed bridge width decremented bridge width falls zero bridge removed altogether 
algorithm non destructive retrieving handle 
algorithm shows part responsible updating graph non des read handles 
algorithm tests process retrieving handle knows line 
process link process created line tuple space counter incre mented 
observe know tuple space done bridge narrower new pointer created tuple space question 
algorithm assumes handle stored time 
bulk primitives handles stored 
case algorithm changed replacing line represents number handles stored 
defined ligia bulk primitives cause process get knowledge handles copied moved 
movement occurs kernel process gets know handles involved 
algorithms cope bulk primitives extra test done test line handles removed bridges involved updated link tuple space created 
modifying algorithms storing reading withdrawing algorithm shows specific code bulk primitives 
updates bridges execution bulk primitives 
primitive executed line handles moved tuple space handles 
algorithm general description algorithm update graph bulk primitives moved bridge width decremented 
important increment guarantee unreachable intermediate stage algorithm 
line incre ments bridge exist created width bridge line decrements width bridge width falls zero bridge removed observe counter field need updated cease exist places changed 
case algorithm execution prim itive line case width tuple space modified handles removed new created stored line causes update bridge bridge exist created width exists width incremented additionally counter field incremented new tuple space created line 
algorithm process termination 
algorithm shows case process termination 
process terminates arcs having process ends deleted 
algorithm loops tuple space linked process line updating tuple space counter unlinking process tuple space 
observe operation graph garbage created reasons explained 
final remarks previously report 
final remarks chapter theory solution garbage collection ligia linda systems share properties ligia model 
solution constructing graph information process require tu ple spaces 
construction graph base garbage collection sys tem works information contained graph 
solution centralised idea developed extended distributed case 
garbage collection methods implemented centralised ed cases hybrid implementing listing mark sweep 
done overcome problems method implemented 
chapter coordination input output operations generalisation linda include input output operations con sidered gelernter describing multiple tuple spaces linda gel 
subject neglected researchers concern inclusion new primitives model way tuple spaces imple mented 
linda coordination model proposed location free environment coordination processes users supposed unaware location consid ering data accessible contents address 
forced non linda concepts doing observation identifies gap linda location abstraction significant property object location system 
take instance screen device location defined oper ating system distributed systems users specify explicitly location screen want 
management operations coordination problem see discussion page difficult solve 
ligia coordination model aims widely designing distributed applications suitable designing coordination application includes operations 
ligia approaches problem investigating achieved terms coordi nation operations goal ligia users able coordinate having host language features 
theoretical side management added ligia ty argument identifies coordination problem implies dealt coordination model ligia 
practical side thesis approaches general problems related open systems ligia model open systems 
garbage collection closed controlled environments controlling issue compile time analysis overcome possible difficulties 
open systems scenario different issues interesting problem 
process migration instance brings sub implementation operations assumes system running different operating systems heterogeneous system 
linda proposals far consider heterogeneity specifica tion point noticing problem arise dealing fact effects problem addressed felt greatly homogeneous environments operating systems unix normally cated redirect correct location 
chapter looks problems brought doing advan incorporating ligia 
incorporation carried mini view fewest possible changes model 
chapter divided follows section problem begins called distributed generic term problem tackled thesis definition problem desirable characteristics system aiming solve problem section starts motivate idea including capabilities ligia model 
section shows garbage collection closely related fact early motivations investigating problem ligia context 
section discusses problems motivate existence operations ligia include mobility heterogeneity 
section comprises core chapter opera tion allows files abstracted tuple spaces introduced semantics 
distributed described section consideration management file spaces ligia kernel 
section extensive description potential new primitive 
chapter implements limited version distributed distributed consists providing system ability operations remote locations possibly making user believe resources local 
probably difficult problems distributed systems important 
despite importance world suffers lack accepted distributed model 
unix operating system probably nearest standard model unfortunately particularly suitable distributed systems 
take instance file record locking unix provided command command low level success entirely hands programmer section shown extension proposed provides higher level interface operations provided unix operating system 
desirable characteristics distributed system identify important ones high level interface interface system high level possible 
distributed system life easy programmers ing control system 
location resources aspects addressed case file record locking programmer necessarily need know file stored phys ically know necessary locked 
abstraction location help distributed system provide high level view 
overlap computation operations opening closing files block execution processes implemented standard procedures provided computation languages 
distributed 
garbage collection system provide parallelism system overlapping compu tation possible 
fact orthogonal operations computation interfere 
portability portability desirable architectures similar char completely different environments 
distributed system entire distributed system 
heterogeneous open systems reflect heterogeneity 
lack standard suitable ligia added fact ed coordination problem see discussion page drives investigate system desirable characteristics listed achieved ligia implementation 
reason model ant prepared cope situations particular garbage collection clear garbage collection closely related 
standing fact handled common framework distributed system ligia greatly benefit inclusion distributed capabilities model 
outside world concept garbage collection scheme better controlled done ligia terms 
open distributed heterogeneous system processes coordinate ligia facilities ligia common framework process undoubtedly ligia candidate distributed system imple mented regardless benefits bring needs having done ligia 
clear garbage collection benefits oth er way round benefit existence garbage collector ligia 
benefits exist subtle difficult notice 
explained chapter ligia abstracts files terms tuple spaces con sists creating tuple space contents file processes ligia access tuple space unified framework file 
original 
garbage collection file remains file system world consist solely ligia processes necessary contents file file system ed time time 
importantly file locked abstracted ligia tuple space representing file longer required ligia environment file released 
garbage collection scheme available sub system keep track usage tuple spaces representing files required flush contents tuple space back file ligia processes longer know existence tuple space 
link keyword garbage collection scheme implemented knows links processes tuple spaces system rely garbage collector tell contents tuple space need flushed back file 
important point understand abstraction changes way graph updated 
chapter special tuple space called identify capability process perform operations far chapter tuple space mentioned 
reason simple tuple space exist reality garbage collection graph 
tuple space abstraction capability process doing statement fact says process handle file terms tuple space words tuple space ticket allows processes ligia 
suppose instance scenario depicted 
initial scenario show processes files tuple spaces linked capability 
linked instance create tuple space representing file say tuple space representation file ligia processes accessing fact accessing file abstracts 
process pass handle access directly get retrieving handle terms graph update process gets handle tuple space representing file process linked avoid undesirable side effects 
garbage collection update garbage collection graph operations 
uts ts initial scenario uts ts ts uts ts ts file process creates links file 
ts file process gets handle linked 
internal aspects 
practice process linked handle 
words process pass handle processes files tuple spaces 
argue reality pass handle indirectly pass ing handle emphasised handle enable abstractions link done graph avoid incorrect collection tuple spaces processes 
internal aspects apart aspects far motivates incorporated ligia characteristics inherited ligia linda model contribute show systems necessary 
internal aspects show open implementations linda gap standard specification may apparent 
implementations linda including ligia envisage possibility pro cess migration considered feature implementa tions adfs ns 
despite important issue open imple causes problem implemented carefully 
suppose instance scenario processes running system composed locations configured shown 
suppose due load balancing considerations migrates shown 
programmed perform operation say write screen question arises screen data displayed 
heterogeneous systems different operating systems may able name devices file operating systems 
fact difficult naming problem solved naming ambiguities resolved underlying common operating system 
case heterogeneous systems different operating systems general intrinsic characteristics model realisation 
internal aspects implementation process migration ligia causes problem 
scenario processes executing location process terminates linda forces process migrate location load balancing 
semantics operations ligia solution implemented operating systems level 
doing ligia eliminate naming problem 
ligia provides common platform operations provides unique names tuple spaces tuple space handles kernel able identify uniquely 
terms tuple spaces handles solution naming problem distributed solution report lift operations ligia level eliminate naming problem occur 
process migrate anytime location having operation redirected properly common environment ligia provides 
semantics operations ligia idea lifting operations ligia level dealt careful ly 
minimalist view model modified great extent easily lost 
idea bring ligia time avoid great modifications model guarantee underlying model linda 
common research done modify extend concept result different original proposal completely different concept 
goal desirable people looking ligia agree underlying basic model linda 
having said ligia provide common platform dealing heterogeneous distributed systems maintaining basic characteristics linda model 
noted platform way abstracted differ underlying platforms ligia 
device file abstracted ligia terms users benefit common platform ligia 
thesis shows abstracted unix systems 
semantics operation proposed assumes unix platform ligia model platform independent primitive gateway ligia world platform de pendent 
java implementation see chapter minimises 
semantics operations ligia dependency view devices represented files unix explained section platform dependency fact reason describing operation chapter general ligia model introduced 
operation said necessary gateway ligia domain way bring model 
devices files exist non ligia objects re main way world consists elements ligia objects gateway ligia objects see ligia objects interfering non ligia world 
linda model provide means bringing model introducing new operation 
operation proposed takes view seen unix operating system object viewed file 
ar tuple spaces best candidates files ligia tuples possible option interesting uniquely identifiable system 
ligia abstraction location achieved execution prim itive point execution onwards communication file ligia done tuple space representing 
operation links tuple space may specified define sequential part tion case flag set identify tuples matching template allowed file space name tuple space abstracting general semantics operation contents copied tuple space defined exist created execution defined case assumed hard copy tuple space persistent representation tuple space 

storing tuples understood kernel 

semantics operations ligia chapter shown implementation thesis assumes sequence objects belonging class flag form defined abstraction implemented java 
occurs differently ex supposed contain exclusively tuples matching intended devices ask messages tu file space accept storing tuples matching ples ligia case special format 
case exclusivity flag set 
case contain tuples matching template 
executing kernel adds relative address file tuple matches template 
defines tuples form file space contain tuples matching templates set possible templates set templates different defined primitive 
ways doing abstraction file 
ligia assumed contents file copied tuple space original file locked file server order keep existence visible processes lying non linda system 
example prevent file name created original linked tuple space 
additionally doing copy file guaranteed event failure ligia system initial file restored file system non ligia processes carry normally 
non ligia processes affected locking original file ligia deal concurrency problems outside scope ligia world 
additionally locking original file avoid case single file abstracted twice ligia 
user point view file spaces tuple spaces linked file different tuple spaces 
difference file spaces tuple spaces shows garbage collected 
file spaces need contents flushed back file system collection deletion representations ligia tuple spaces collected operations 
ligia original file locked non ligia processes need periodic flushes 

semantics operations ligia modified creating operation allow users flush contents file space benefits operation felt original file locked 
differences file spaces tuple spaces may clear order better understand differences kernel level consider 
depicts tuple space possible situations file space represents tuple space contain tuples matching tem plate 
contain tuples template matches templates universal set templates multiset tuples matching template fig ure depicts case file space created template specified case file space persistent tuple space file represents hard copy file space template defined file space contain tuples matching template multiset tuples matching template depicts file space template defined exclusivity flag file space may contain tuples matching templates represented tuples lost flushing operation exclusivity flag tells kernel keep file tuples match template defined tuples matching template file space represents file sequentially relative address attached tuple read file 
shows case file space divided sequential part multiset tuples bag part multiset tuples file space created tuple matching template modified contain relative address exclusivity flag having relative address attached 
tuples accepted flushing file space sub bag defined stored sequential file 
tuples address chosen non stored file 
mechanism represents case processes access file crcw concurrent read concurrent write ion policy provided concurrent writing 
exactly case unix process access file concurrently 
unix users edit file environments decide save time 
semantics operations ligia representation file space tuple space terms tuple space standard tuple space file space file space file space 
semantics operations ligia guarantee succeed 
words possi ble different results experiment executed times ligia non deterministic situation unix 
flushing set tuples consists removing relative address added executed 
done file sequentiality achieved existence explicit address 
operation acts multi purpose operation reason parameters optional 
definition template tory instance create persistent tuple spaces problematic 
template defined multiset defined stored sequentially file means tuples address tuple stored lost 
operation create persistent tuple space flush operation triggered garbage collection modify contents tuple space fact invariant file space just garbage collected consequently flushed file system equal file space linked file just maintained 
management file spaces explained section file spaces differ tuple spaces garbage collected 
difference perceptible level ligia kernel 
users freed differences primitives file spaces tuple spaces 
cases file spaces depict ed users files spaces need knowing object fact tuple space file space 
implementation point view argue done tuple spaces kernel severe bottleneck due number mes sages generated operations 
case systems ini kernel prepared separate operations tuple space operations tuple space managers rw deal assuming file modified non linda processes 

semantics operations ligia structure ligia kernel terms fsms 
ligia kernel tsm fsm fsm tsm tsm operations tuple spaces may affected existence ligia 
straightforward solution implementation spe kernel called file space managers fsms deal solely file spaces avoid bottleneck free burden dealing operations 
kernel ligia composed fsms fsms communicate shown 
fact necessary communication fsms tuple space linked file file space kernel needs move fsms 
movement tsm fsm file space tuple space operation unlink file space 
arrangement fsms depicted beneficial garbage collector easily decide flush space stored need flushed stored fsms 
fsm fsm tsm 
ligia generalised ligia generalised consequences having ligia deal char saying ligia generalisation linda broader view problems unrelated affected solutions problems require modifications 
discussion far shown incorporation ligia neces sity raises important issues 
advantages tion described sections seen disadvantages exist 
points described sections implemented prototype described chapter described emphasise inclusion model advantages drawbacks 
general terms ligia seen generalization linda problem tackled linda tackled ligia way round 
ligia complete system coordination prob lems related left dealt computational part sys tem 
important remember chapter intention explaining concept ligia investigating possibilities concerned implementation 
chapter implementation described ideas described left reasons ideas antagonistic implemented single system 
extending abstraction location obvious gain generalisation abstraction location ex tended level objects creation file space representing object file space handle physical address object passed processes 
improves abstraction level processes access object knowledge physical location importantly object attached completely different environ ment ligia maintain illusion homogeneity 

ligia generalised scenario depicting location free abstraction objects 
printer location lp pn uts lp depicts scenario printer located pro cess creates file space representing printer operation pipe created file space printer creation pipe kernel level explained detail chapter 
case consists guaranteeing kernel process spawned location migrate process fact pipe manages low level communication file space printer 
file space handle placed universal tuple space uts making actual printer available process ligia system 
practice form communication set processes ligia process reading retrieving handle realise handle just read represents object structure representing handle ligia stores information 
observe problem finding information retrieved information wanted particular guarantee tu ple retrieved tuple wanted 
find information received tuple space coming right processes 
ligia extending questions context scenario depicted need know location printer processes location abstracted terms assumed location printer name unique example printer address 
ligia generalised file space handle guaranteed unique 
abstraction files assumed unique names guaranteed file system directory structure considered part name 
creation file space ligia primitives ac cess objects 
scenario depicted process access printer location simply referring file space file space instance represent sending queued printer represent deletion element queue printed 
actual meaning primitives depend greatly objects question fact meaning primitive kernel level probably differ depending object 
user point view primitives result operating tuple space 
overlapping computation distributed system aims parallelism possible sequential op erations avoided introduce bottlenecks system 
computation improve parallelism distributed system 
abstraction operations terms ligia provides blocking operations executed parallel computational operations 
compelling examples file access 
normal procedure access files requires blocking operations 
single process file access computation abstracting file access ligia parallelism gained operations carried ligia primitives 
user write file necessary wait completion ligia system guarantees correct completion fault tolerant systems completion guaranteed event system failures 
respect primitives respectively read withdraw 
ligia generalised parts file parallelism added definition blocking primi tives direct access files retrieval information blocking operation 
rowstron wood rw propose decomposition primitives low parallelism bonita retrieval primitives divided request part get part executed separately blocking time operations create idea pipeline system sequence retrieval primitives see section 
context bonita parallelism gained terms abstraction gains parallelism frequent operations opening closing file 
opening file done ligia operation hides blocking time 
actual time taken open file overlapped operations ligia 
closing files operation ceases exist done garbage collection 
noticed programmed system operation hide blocking time instance file space ac cessed just file exist 
file linked handle processes having opening file surely increases concurrency aspect system 
distributed files ligia aimed large scale applications resource management vital con cern 
ligia implements distributed central servers policy tuple dis tribution see chapter applications benefit having tuples tuple spaces distributed system independently tuple space belong store tuples distributed system contents hashing algorithm 
alternative may reasonable speed concern issues fault tolerance considered fault tolerance usually implemented tuple space level important tuples organised tuple spaces stored consideration decisions operation withdrawing parts file creating gaps new concept introduced thesis 
explanation operation semantics section 

ligia generalised physical location 
file abstracted file space contents file space dis tributed distribution policy tuple spaces 
ligia system file linked file space contents file space stored single lo cation generalisation operation file system abstracted tuple spaces consists saying ligia point view file system distributed file spaces distributed 
words intro duction ligia ends giving model distributed view file system file system distributed 
implementation point view important guarantee bottle created addition file systems 
implementation ligia may easily include automatic way balance load network number accesses tuple space file space 
context bringing file system ligia optimisation described mean file system seen ligia distributively balanced 
nature tuple distribution policy ligia ideal file content distribution 
ligia central servers contents tuple space physically stored location 
imply distribu tion policy adjusted distribution file contents important issue open coordination systems 
fault tolerant file system reinforcing observation optimisations carried ligia level applicable case happen ligia fault tolerant 
fault tolerance useful distributed file systems processors crash files lost blink eye 
fault tolerant ligia files fault tolerant abstracted file spaces 
ligia fault tolerant file spaces files abstracted terms file spaces fault tolerant 
event failure file system loss original file ligia file space re create file file system back 
plinda example fault tolerant linda model 
fault tolerance 
ligia generalised achieved tuple space level 
ligia operation implemented model plinda alternatively fault tolerant characteristics plinda adapted ligia case file spaces automatically considered fault tolerant different ordinary tuple spaces 
fault tolerant file system achieved file system ab 
point view ligia meaning different 
ligia processes file system fault tolerant files neces sary ligia environment abstracted terms file spaces 
tuple distribution policy ligia ideal implement fault tolerance 
feature implemented tuple space level contents tuple spaces guaranteed stored location recovering failures feasible 
fact fault tolerance systems tuple space contents location explored feasible solution 
locking records creating gaps abstraction files file spaces gives chance build powerful file system interesting properties 
file system may fully distributed having files distributed contents files way file spaces implemented explained section 
depending way contents file stored file space interesting operations may achieved 
suppose file collection records records represented ligia tuples element contains position record file 
scenario operations files sim unix case file spaces cope processes accessing structure concurrently easy control accesses 
mentioned unix way dealing record locking low level average programmer consider problem concur rent access records file spaces 
ligia provide primitive update tuple way done tuple modify contents modified tuple 
ligia semantics guarantee 
ligia generalised execution primitive john peter michael tomas david richard mary frank string process uses primitive withdraw tuple file space 
file space 
john peter michael tomas richard mary frank tuple retrieved leaving gap instantaneous description file 
process accesses tuple time processes want retrieve tu ple processes chosen non deterministically get tuple blocked 
eventually process read tuple complete update storing modified tuple file space processes get turn 
solution far high level explicit record locking provided unix interesting feature implemented file spaces able allow holes files 
case files unix file spaces ligia need continuous contain gaps 
concept gaps files may stood file gap part file supposed stored missing reason observe different complete files physically stored continuous way physical storage file related concept gap gap exists logical representation file 
depicts scenario process withdraws primitive tuple file space store 
instantaneous description file valid gap position file currently exist filled process 
unix allows holes novelty introduced file spaces 
unix 
ligia generalised lows holes exist creation file called sequential creation holes unix process seek file write information 
space created file seek file writing hole 
ligia generalises concept holes created anytime file see position file removed ligia creating hole position 
file holes primarily save space 
instance utilities create files holes files lots zeros shared library occupy full amount space 
utilities unix transforms consecutive nulls files holes seeking regions consecutive nulls holes take space 
ligia generalizes concepts holes created existing file fore requiring file recreated 
associative access files considering file abstractions access operations prime concern 
literature describes essentially methods file access direct tial 
inclusion concept file linda files accessed contents linda processes associative access files ad dition standard methods access 
sequential case wants element file get access elements 
direct access wants get directly needing access elements 
associative access files different sequential direct methods location information need mentioning position element required wants object position 
surprisingly associative access implemented ligia users freed dealing location appropriate 
ligia concept location possible simulate concept implement direct sequential access methods 

ligia generalised example access methods available ligia user con sider file records containing boolean integer character 
order re introduce sequentiality ordering required thesis suggests representation record location added tuple 
adding element tuple form direct access primitive cess position location record abstraction file provides direct ac sequential access sequential access necessary having direct access simulate loops required 
position associative access new way accessing files achieved due ligia asso matching mechanism 
file space access file records contents atomic operation implementing operation processes level 
associative access files introduces new ways retrieving information file 
instance suppose execution clear ly operation implemented atomically process level standard access methods semantics operation retrieving tuple file space second field tuple element set interesting case execution field set asks tuple position considered second semantics ligia primitives regards tuple spaces maintained context file spaces executions block template satisfied 
case primitive block tuples file space contains second field set second case phenomenon happen tuple position field set 
ligia generalised dependence graph job scheduling problem 
additionally non deterministic characteristic ligia maintained file spaces meaning tuple satisfies template chosen non deterministically 
associative operations files intriguing potentially useful instance create private channels semaphores processes processes non ligia 
private channels file spaces powerful feature proposal lows easy control synchronous problems 
take instance job scheduling problem consists set jobs processes dependent order execution jobs need wait termination order start executing 
depicts scenario composed jobs shown graph arrows rep resent dependency jobs 
implemented elegantly file spaces 
process aware dependence wait private channel message activated 
scenario create file records process boolean field position means processes depending start execute 
code sketches implementation situation depicted special process 
specific case file space replaced tuple space problem 
file spaces persistent tuple spaces definition execution processes code stopped re started necessary 
additionally implementation private channels file spaces possible non ligia processes replace ligia processes 
ligia generalised code sketch processes code part job scheduling problem 
communicate underlying file 
persistent tuple spaces concept persistent tuple spaces survive execution programs known nowadays mainly due plinda proposal 
inclusion file spaces ligia naturally provides concept persistent tuple spaces 
case persistent tuple space file space persistent files survive execution ligia processes 
furthermore users need de fine tuple space persistent creation need link tuple space file time execution process refer 
final remarks tuple space 
original multiple tuple space linda model gel tuple spaces default considered persistent objects point view processes mod el tuple space created outlive processes system 
garbage collection concept changed slightly tuple spaces persistent processes access tuple space 
ligia reintroduce concept persistency tuple spaces outlive processes organised fashion 
done tuple space question persistent garbage collector remove file space care 
garbage collected file space contents stored file representation ligia model removed observe file linked tuple space having contents restored system tuple space persistent 
view persistency thesis differs plinda proposal persistent linda tuple spaces processes fault tolerant user defines type tolerance wants tuple spaces runs plinda application 
proposal tuple spaces level tency tuple spaces achieved consequence provision file spaces 
final remarks chapter identified coordination problem relation garbage collection 
problems sufficient necessary problem tackled coordination model ligia 
solution proposed files tuple spaces ligia processes deal tuple space dealing files directly 
new operation called introduced realise abstraction 
chapter described potential having include ligia model ligia model generalized 
chapter implementation ligia far thesis concepts introduced possibilities dis cussed little consideration aspects related imple mentation 
chapter discusses important issues related im plementation ligia 
implementation java explained way garbage collection brought ligia 
clear described previous chapter implemented 
goal implementation show feasibility important aspects garbage collection distributed ligia implemented java jdk gjs 
particular choice java idea ligia run heterogeneous systems fore java facilitate programming systems 
problems java faces terms performance known performance key issue 
thesis tries show feasibility performance considered due time 
java compilers generate code specific machines avail able cl tec generate code efficient codes generated compilers instance 
chapter divided follows section general ligia architecture pictorial view architecture shown main components described separately 
section implementation server system de 
ligia architecture scribed 
section process side ligia explained agent system part ligia attached processes allows processes coordinate ligia facilities 
section implementation garbage collector explored differences centralised distributed implemen tation highlighted 
section implementation systems described 
ligia architecture general terms architecture ligia follows concept tuple space man introduced previous york rw 
basic model added extra components deal concepts proposed thesis 
ligia architecture reasonably simple garbage col lection distributed model done separate sub systems 
plug ins linda implementation 
de spite fact able adapt guaranteed 
separate sub systems communication protocol defined ligia core ligia system prepared pro vide services required sub systems plug idea necessary components implemented system question 
sub systems idea garbage collection control indepen dently possible tuple space managers rw 
architecture depicted divided main distinct system server system client system sub system garbage collector sub system 
communication servers occurs sockets servers distributed central servers tuple space distribution strategy cg 
server multi threaded new thread created new request done client 
client system design composed multi threaded communication system plus local tuple space manager row 
included imple mentation complicate implementation contribute significant details 
foreseen definition solution improve performance 
client system exist machines ligia 
server system processes running 
provides access primitives enable processes access ligia servers 
inter server communication communica tion processes servers done sockets 
sub system executing machines running client processes 
separate system side effects modifications system minimised 
abstraction system maintains hard links tuple local file system local abstraction system sub system may need communicate servers directly communi cation sockets 
sub system garbage collection operations separated servers garbage collector complete independent pro cess components sub system implemented servers 
fact main reason communication represent ed sockets shown thick pipes 
garbage collection appears picture manner different versions garbage collection im plemented garbage collection structure instance centralised dis tributed servers 
idea intends represent gc structure maintainer updates gc structure turn analysed garbage collector necessary informs tuple space manag er usability tuple spaces 
argued ligia implementation composed black boxes plugged linda implementation 
systems ligia aware existence cooperation systems essential 
ligia tries systems look black boxes possible complete separation achieved garbage collection dis tributed implies modifications model level described chapter 
server system server system composed multiple servers communicate selves server divided specific components 
components shown 
server system pictorial view ligia architecture garbage collector router tuple space manager server server user processes system tuple space manager local agent connection router tuple space manager agent connection gc structure manager maintainer gc structure maintainer gc structure manager file system file system user processes system manager local tuple space client client gc sub system abstraction abstraction sub system 
server system agent connection component responsible dealing communica tion ligia processes 
component uses java threading create new thread control new request process 
class responsible receiving message sep extends class 
messages arriving processes format represents primitives executed oth er operations happen explicit knowledge users process registration instance 
identifies agent sending message important correctness garbage collector needs know processes executing operation 
unique handle tuple space tuples stored defined operation requests parameter 
instance operation generated execution primitive defined equivalent defines tuple space information retrieved likewise certain primitives instance 
part message contains data depending operation multiset tuples important operation implemented agent connection module tuple monitoring 
fact stage complete message sep analysed 
tuple monitoring analyse infor mation separated pass accordingly com ponents 
tuple monitoring extracts instance locations tu ple spaces handles passes router decide servers deal request 
router message arrives components message separated address extracted name tuple space handles involved 
router decides current server supposed deal 
server system message servers supposed involved perform ing operation 
single tuple space primitives dealt server 
servers fully connected worst case message routed message sent process server tuple monitoring find tuple space question stored locally router redirect message correct server deal message 
defined kernel single tuple space message hop servers 
bulk primitives tuple space time 
case router acts redirecting operation server address attached handle locally half operation carried result sent server different second server acknowledges completion operation server sends result original process 
depicts case routing single tuple space primitives bulk primitives 
messages represented numbered arrows numbers indicate order messages sent 
cases worst scenario depicted 
manager message involves manager activated 
identified agent connection related message router decide done terms redirection 
opera tions involves execution operation 
ligia assumes file linked local ligia process executing primitive 
case router informs manager operation manager communicates io abstraction system retrieve information file 
contents received manager pass back router pass tuple space manager passes back router tuple space receiving information single tuple space primitives ligia 
server system number messages generated routing ligia operations 
server server routing single tuple space primitives 
server server server routing multiple tuple space primitives 
local passes data tuple space manager tuple space local 
operation involves manager flushing information tuple space original file 
garbage collection finds tuple space linked file garbage collected contents file space tuple space routed back original file 
way data travels starts tuple space manager file space stored 
file space sends message local manager passes router original file located remotely address file stored extracted stored processes executing operation connected server 
section operations involving better explored 
gc structure manager component charge updating graph need ed 
tuple monitoring able identify tuples involved commu nication contain handle 
case handle modification garbage collection graph necessary 
gc structure manager updates graph done necessary time graph 
server system updated operation taken place tuple space manager 
component invoked processes tuple spaces created need represented graph 
tuple space manager important parts server 
tuple space manager maintains data structure actual tuples stored 
message arrives tuple space manager guaranteed tuple space question stored router chance analyse address attached tuple space handle advance 
manager important core implementation tuple space manager level important characteristics ligia implemented ordering hashing algorithm matching system 
par ticular data structure ligia described detail section 
implementation server system done appears seamless components seamlessly point view ligia processes kernel comprises single server 
argued server system uses distribution strategy dis tributed central servers cg 
strategy consists having tuple space managers storing tuple spaces entirety opposed having contents tuple space distributed various servers 
formally distributed central servers strategy convey idea property 
property distributed central servers distribution strategy physical locations tuples tuple space systems 
tuple spaces tuples 
system uses ed central server strategy informally property implies tuple stored tuple space physically stored location tuples tuple space stored location reasons strategy 
factors justifying choice 
server system central server strategies produce system clean easy main tain internal data structure complex improves main implementation 
implementation scalable operations involved adding deleting server simpler implemented 
inclusion fault tolerance feasible unclear fault tolerance incorporated implementations tuple space contents tuple space distributed servers 
migration tuple spaces may cheaper migration tuples depending number tuples required 
overhead packing un packing tuple responsible big share time taken move set tuples 
packing tuple space sending big chunk data necessarily expensive 
implementations kernel optimisations replication hierarchical kernel easier implemented 
central server strategies bring concerns mainly regards bottlenecks 
generally types bottlenecks appear generative distributed system including ligia server bottleneck happens processes require services server 
bottleneck easily overcome instance server dynamically find load servers move tuple spaces server smaller load 
ligia implements tuple monitoring currently implement load analysis impor tant context thesis 
tuple space bottleneck happens agents require tuple space 
bottleneck solved implementations central servers movement tuple space server move bottleneck 
tuple space bottleneck 
server system flow message server system wait message message arrived 
unpack message related 
communicate system update tuple space structure contain handle 
update garbage collection structure access ts redirect file 
local 
message application may changed order divide load tuple space 
ligia may suffer tuple space bottleneck 
despite reasons distributed strategy tuple spaces ligia current trend linda related field 
latest kernels avail able implement strategy rw rss row 
having described components server system question remains interact 
depicts flow messages server system 

server system shows server system waiting messages 
connection component implemented java class keeps reading socket request 
message arrives new thread control may cre ated deal message generally speaking thread normally created message arriving process communicated server fore 
message received unpacked analysed tuple monitoring system implemented class 
message related sent manager communicates abstraction system implemented java class operation involves reading contents file flushing file space file operation returns control manager subsequently agent connection 
tuple monitoring system continues analyse message tests tu ple space message stored locally 
tuple space stored server message redirected accordingly 
step analyse tuples find handles involved operation handles impor tant garbage collection way processes acquire knowledge tuple space 
handles involved message sent gc structure man ager updates garbage collection structure 
message sent tuple space manager store tuples remove tuples primitive 
said ligia uses multi threading class 
cost luxury 
really luxury 
threads general costly ma chine server running powerful 
threads improve scalability module executed parallel machine instance 
multi threaded systems explore better idle processors idle processor time 
chapter experimental results show scalability module 
terms redirection messages topology server servers communicate directly 
reduces overhead im posed router 
message redirected 
message bulk primitives tested 

server system performed locally local router guarantees message sent server operation local 
method called imple ments different primitives server side 
message gets method operation performed locally 
important point clarified tuple monitoring 
ligia tuple monitoring system analyse tuples agent system flags messages monitored done minimize overhead unpacking irrelevant tuple 
results chapter show single tuple space monitored overhead small shows agent systems bother flagging tuples 
tuple space manager divided parts combined aims maintain structure tuple spaces tuples accessed effi ciently 
structure ligia relatively simple depicted 
structure tuple spaces consists doubly linked list tuple space cells cells tuple spaces respectively head tail list 
list indexed handle tuple space unique implemented class contents inaccessible directly programmer 
means users handle hacking structure virtually impossible 
structure tuple spaces updated new tuple space created garbage collector decides tuple spaces longer required system 
apart primitives update matrix tuples tu ple space tuple spaces primitive 
primitives ligia tuple level modify main data structure tuple spaces exception primitive requires access variables main tuple space structure 
primitive modify linked list 
shown tuples stored matrix 
element matrix list tuples certain sort 
order achieve distribution tuples matrix simple hashing algorithm implemented 
hashing defined 
server system structure tuple spaces tuples tuples 
server system function tuple hashed ordered pair identifies row column matrix tuple stored primitives remove tuples stored primitives store tuples row size tuple number objects random number function range columns specific java class occupy matrix 
instance suppose tuple hashed result result signifies tuple stored nd row matrix 
class object store column number columns taken java class chosen randomly range 
hashing function effective stores tuples matching template matrix data structure 
improves performance bulk primitives need elements matrix 
open implementation ligia try maximize number concurrent accesses tuple space 
case primitive requires element matrix need lock chunk elements chunk lock just elements matrix time 
ligia implemented java object oriented language match ing mechanism ligia implement matching subclasses 
instance suppose classes called structure 
ligia object match object 
reason purpose thesis inherits advantages approach irrelevant lead complex design 
explaining matching mechanism understand format tuple ligia 
ligia implements class called class allows tuples fifteen elements subclasses java class 
tuple created object stored internally sequence pairs understood complete name java gives classes instance class full name fact object 

agent system structure matching mechanism 
fact quite simple 
class object 
template defined ligia method called aware wildcards appear 
java syntax kernel element template pair qual match 
hand element compares method method method loops name java class compared pair tuple elements different means actual elements match full description methods classes appendix agent system elements agent system complex server system 
fact shows composed separate parts implementation ligia local tuple space manager implemented 
agent system composed basically component communication system 
component responsible providing ligia processes coordi nation capabilities basically component seen library containing methods access tuple spaces server system 
ligia provides primi tives methods class represents connection server 
process ligia request connection ligia server prim available methods class 
notice necessary system connections theory stops process requesting con servers 
ideally process create object representing connection 
creation connection useful cas es simulate multi threading connection multi threaded 
fact point view servers agents 
agent system single multi threaded 
ligia processes assumed multi threaded default different threads created primitives main thread control communicate directly servers 
see specific programming language assumed architecture level processes implemented language different java 
due fact ligia servers expect receive java objects sockets processes implemented non java language simulate format serialised object object passing socket sun communicate java translator mount data expected format 
translator receive data format create objects send serialised server sockets see section 
mentioned primitives exist methods class represent connection servers 
class implements connec tion provide primitives methods 
object created servers contacted process request name start primitives 
request accepted unique name assigned process communication channel object established 
normally connection process server second redundant process requesting connection point view server garbage collector connection seen different process 
order garbage collector collect existing garbage anytime connections requested disconnect requests see section 
creation object class connects server 
list servers available processes normally file 
list location process 
simple method uses ip address server chooses location appears nearest process 
instance suppose list servers er process running process requests connection serv server connected 
agent system differs address process 
process choose local server go searching neighbourhood ip address servers 
specific syntax methods representing primitives follows tuple space created server unique object returned 
handles tuple spaces class objects 
actual value handle meaningful programmer 
tuple space handle method takes stores method looks object stored tuple space handle matching template fact object tuple space returned 
blocking method objects appear 
tuple removed object tuple space method waits appears removes 
methods variation process block tuple 
empty tuple re turned matching 
method non destructive version tuple copy tuple returned original kept tuple space 
method variation works sim process block tuple empty tuple returned matching tuple 
class turned bwa 
semantics method moves objects matching number tuples moved re primitive terminates 
implemented ligia guarantees searches tuple space structure 
agent system cell matrix destined receive tuple matching performed 
cell access guaranteed ex sum result smaller internal structure 
executing 
result primitive tuple space method similar tuples copied moved 
primitive proposed row row multiple solve problem rw see section details 
semantics ligia similar tuples copied removed internal execution primitive follows idea implemented defined model level implementation thesis implement method context proving feasibility garbage collection tuple spaces implementation operation irrelevant 
point view garbage collector operation different having users spawning processes 
spawning child process sim ligia users 
observe primary goal ligia prove idea garbage collection tuple spaces 
course goal ligia general purpose implementation implementation left 
justification leaving implementation ture mainly intention implement inal linda model concurrently 
fu defined orig creates active tuple components evaluated context thesis done way evaluating process creating active tuples elements evaluated parallel affecting behaviour garbage collector discussion unnecessary 
examples primitive exe simpler way means way implemented 
represents better idea processes spawned users 
originally called 
garbage collector garbage collector need garbage collection system clear way implemented ligia 
discussed model level existence garbage collection relies kernel aware existence processes able uniquely identify 
far thesis case tuple spaces created left kernel space unnecessarily mentioned concrete exam ples 
reality concrete example program shows case tuple spaces created left kernel consuming memory resources 
program toy program composed processes 
keeps nitely spawning agents create tuple space terminate 
argue sort program happen real world appli cations idea expressed doubt appear hidden thousands lines real world application 
idea tuple spaces created reclaimed sooner memory exhausting ex ception happen 
garbage collection implemented ligia programs cause harm tuple spaces reclaimed 
garbage collector unnecessary system 
registering processes order able create graph linda server ker nel aware agent identity 
generative communication systems considered dissertation kernel knowledge agent identity server receives requests agent fills 
ligia introduces idea kernel able identify processes uniquely achieved introducing new operation implements processes check kernel 
operation implemented 
explicit 
looking program see java object oriented language object created order allow agent access primi tive methods see lines 
class poses best option implementing registration processes check operation 
creation object happens communication tween process ligia kernel means agent creates take place 
communication sets name process object communication process ligia server name guaranteed unique com 
structure requires restriction implementation 
security reasons objects tuple elements 
objects allowed tuple elements agent able retrieve object consequently get access agent unique name communications 
problem garbage collector expect receive request process tion executed explained chapter 
opera noticed restriction due failure garbage collection method due fact object oriented languages methods reside classes making object creation necessary 
garbage collector mey 
imperative implementation link library object creation making restriction disappear object exist passed 
scoping class interesting results 
mally case object created process objects create scopes process 
assume instance case program program example program tuple spaces specific scope 
program toy program interesting presents aspects need clarification help complete understanding proposal 
question scopes bearing mind process program coordination computation parts clear concepts scope exist related computation coordination necessary understand differences 
assume execution line execution line causes creation object class named creation data structure kernel points name structure kernel internal unique name 
static access methods considered new private data structure needed new connection 

garbage collector having said takes execution loop lines phenomenon happens interaction loop objects created structures kernel 
interac tion java garbage collector garbage collect objects structures kernel servers running different java machines 
fact java garbage collector collect objects computation dimension coordination 
loop program created garbage collected 
interactions tuple spaces kernel useful kernel know scopes created com putation side language 
class achieve 
observe new connection tell server new cope created 
program shows modified version program objects created loop interaction 
program modification program introducing scope coordination dimension 
modified version shown program object created step loop line 
situation kernel gets know start new scope unfortunately solve problem completely 
object initiates new scope scope signalled 
garbage collector server 
important point garbage collector know process finishes ligia resources words scope ends 
method implemented class unfortunately execution primitive relies explicitly users sure method invocation 
forgotten garbage collector able collect properly assume process active 
method program modified written program 
program method requires process process shown program 
lines method executed telling server scope garbage collection structure updated accordingly 
point view kernel process program acts processes connection connection ker nel receives message sent method corresponding connection lost 
words kernel knows process connection require objects connection 

garbage collector process checkout notice instance object trigger execution method ideal java object java guarantee methods executed java interpreter exit garbage collector starts called java garbage collector fla 
idea dispense primitive fact closes socket connection corresponding object collected java garbage collector 
interesting java garbage collector collaborating ligia sending message server time object collected similar way 
mentioned java collector guaranteed executed explicit mandatory 
additionally solution sort dependent host language case java ideal host languages may garbage collection 
ask overhead added method 
fact com plexity writing program changed exception user re quired remember primitive 
case executed garbage collection able garbage collection 
conservative view garbage collection taken collected incorrectly objects garbage may left system 
point little overhead included 
overhead size message constant time taken server compute unique name agent added result process registration 
tiny overhead added message due addition process name message slightly longer 
overhead added primitive java case 
primitive responsible solution termination ordering problem mw 
solution consists waiting completion primitives agent terminating 
java main thread terminates child threads terminated ow 
adding primitive existing overhead just moved causing 
garbage collector ligia control terminations 
program shows overhead normally happens whilst program shows case primitive program java charge 
program method waits completion thread implementation waits completion thread java wait having described processes register kernel garbage collection keep track objects kernel understanding tuple monitoring mechanism clear important consider garbage collection ideas described chapter implemented 
different garbage collection schemes implement ed centralised garbage collector graph stored place distributed graph divided servers 

garbage collector centralised garbage collection object class created objects created centralised version graph maintained server 
garbage collection objects mentioned independent threads running kernel full description classes see appendix 
necessarily know existence ligia 
objects independent 
created keep running long kernel runs 
implemented way experiments carried generating results draw way garbage collection ligia consequently linda system important point noticed ligia garbage collection threads running consuming resources execution kernel latent time 
implemented class spirit object orientation methods class method permits stopping current thread determined period time 
ideal case ligia goals get results related granularity garbage collection execution 
execution consists calling methods class represents graph structure 
methods linearly search objects variable empty 
variable contains name objects object 
empty object knows existence object 
identified garbage cell graph removed equivalent tuple space removed tuple space structure 
observe straightforward implementation listing method list maintained 
expected maintenance variable problematic operation generates garbage process termination controlled ligia controlled termination ordering mechanism 
garbage collection thread execution ob 
garbage collector ject complex involves separate steps 
graph structure initialised cells marked white objects garbage marked steps 
initialisation mark ing phases starts 
starting tuple spaces cells marked black explained chapter 
phase consists sweeping structure removing garbage left 
implementation choice method avoid object consuming processor resources 
additionally method control execution object helps draw results 
course implementation simple described nation repeat explained chapter 
explanation important pay attention experimental results shown chapter 
distributed garbage collection distributed version garbage collection centralised version described previous section 
explained section garbage collection graph distributed maintained divided servers 
garbage collection scheme modified version having different phases maintain tuple space structure cleanly possible 
phases algorithm local listing mark sweep plus global phase mark sweep 
basically local listing phase independent es 
idea phase execute frequently collecting garbage created ligia 
phases comprise local mark sweep second phase cooperate global mark sweep third phase 
synchronization global mark sweep local mark sweep server global synchronization involving local mark sweep collectors time process explained chapter 

garbage collector server starts garbage collection processes created 
centralised case objects classes created 
classes extend java class part thread control server 
objects created solely local graph follow remote links power methods limited boundaries server executing 
said execution object completely dependent power terms collection limited garbage cy cles collected 
execution consists keep looking listing tuple space node 
list empty tu ple space collected 
similarly case centralised garbage collection race conditions happen due implementation termination ordering 
basically local mark sweep object differs mark sweep im plemented centralised version limited working local graph cooperates global mark sweep collector implemented class runs mark sweep graph remote arcs bridges 
component local graph garbage elements component local serv er component collected 
nodes components marked remote action performed local mark sweep 
run completely different machine machines servers 
running server waits message 
objects finish local mark sweep collect send snapshot graph aware number servers active ligia graph 
global graph complete objects send part see chapter explanation done 
builds internal global graph collects object clearly global graph represent current situation system takes conservative view collect objects incorrectly 
system need local collectors communicate glob 
system global collector keeps track number servers global collector knows sent version graph 
happens local tor different times 
builds global graph runs algorithm 
objects send sub graphs global collec flags local collectors sent message gets flag server execute 
execution flags reset new cycle algorithm begins 
garbage collected 
collect objects 
inform necessary objects collected 
turn communicate tuple space managers tuple space structure updated accordingly 
system access structure tuple implementation distributed system abstraction files tuple spaces brought inside ligia operation 
ligia implements called server idea consists having server running location ligia process running necessary server location server bottleneck commonest operation ligia system 
ments having server necessary 
note concept location kernel ligia related ip address machine process running 
depicts typical situation ligia 
system works follows 
object class started location 
said happen fact need started process run ning location question intends principle difficult know processes intentions started locations 

system processes running locations server running location location servers 
system 
data structure represents tuple spaces field stores location process time execution operation 
executed message sent process local turn sends message server 
server identifies operation extracts address message came 

data structure tuple space linked updated store ad dress extracted 
idea storing address contents tuple space flushed anytime process executed longer exists 

tuple space identified garbage server tests see tuple space linked address stored tuple space data structure send data back tuple space removed server 
secret implementation identify location process requesting tells server original file stored location flushing contents tuple space sent address previously identified 
observed abstraction heavily dependent op eration 
argued implementation normally platform dependent parameters call access objects lower lev el ligia implemented java weaker java classes 
particular case operation ligia uses method overloading allow different cases operation uses class low level access file 
abstraction file terms tuple space han dle file expected composed sequence tuples 
case standard operation addition template serve mask 
final remarks abstraction character exclusivity flag works explained section 
described chapter abstraction include devices printers screens due nature devices virtually im possible propose single primitive deal possible devices 
new device includes new features difficult generalised 
ligia implement cases files represent devices 
idea similar implementation proper device include process placed devices guarantee format messages arriving device correct 
instance required data converted binary saving file 
idea sketched section proposes new device programmer define sort interface guarantee correct communication ligia processes devices 
fact ligia provide basic processes deal normal devices basic way 
final remarks chapter described implementation ligia 
details ligia mod el characteristics described chapter implemented chapter 
implementation centralised distributed version graph described detail 
details implementation opera tion described 
main point done chapter show parts ligia put interact 
chapter experimental results chapter focuses experimental results 
chapter results described intent explore overhead imposed garbage collection tuple spaces 
additionally general results related implementa tion choices ligia 
results organised sections 
section describes setup running experiments 
section de results related garbage collection 
section results related distributed showing cost flushing operations 
section general results related ligia idea show figures related general operations ligia 
configuration details describing experiments important give details configuration un der experiments done 
chapter experiments shown section consistently performed con figuration machines sgi indy mhz mb memory mips pc processor 
operating system irix 

garbage collection java version java available sgi irix sgi java jdk 
just time jit compiler version true regards native threads appeared sgi java jdk 
experiments performed configuration quality jit compiler virtual machine issue 
quality jit compiler influence performance ligia garbage collec tion equally 
difficult get performance measurements java 
fact reason running experiments configura tion 
regards experiment section configuration machines sgi quad origin mips processors mhz gb mem ory shared processors operating system irix java version java available sgi java jdk 
just time jit compiler version native threads 
execution experiment relation number processors number threads server 
experiment client process generate threads server 
experiment performed processes relation maintained 
garbage collection memory exhaustion main purposes thesis overcome problem memory ex really happen 
answer question obvious 
garbage collection memory exhaustion ligia server due tuple space creation 
sec number tuple spaces increment tuple spaces iteration 
sec sec number tuple spaces increment tuple spaces iteration 
number tuple spaces increment tuple spaces iteration 
happen 
order show problem happens performed ligia processes keep constantly creating tuple spaces server exhausts capacity store data structure related tuple space 
depicts experiment causes memory exhaustion 
process loops creating tuple spaces iteration iteration number 
experiment shown server crashed run memory process create tuple spaces time note mean server take fewer tuple spaces fact crash number tuple spaces server depicts case increment iteration equal 
garbage collection tuple spaces depicts exhaustion increment equal 
main purpose experiment data experiment garbage collection action 
order data experiment useful comparison experiments separate processes iteration loop 
simulated having registration iteration checkout means say iteration tuple spaces created garbage 
process registration checkout glance say process registration operation affected choice distribute garbage collection careful look implemented shows distributed case process choice servers choose suitable time registration list servers closest chosen 
centralised version process report single server storing garbage collection graph 
having said cost choosing server considered small drawn 
overhead added registration checkout operations 
order experiments necessary create processes ligia features registration checkout compare difference terms time 
depicts overhead added process registration 
results collected creating program spawns processes process registration 
processes spawned sequentially possible bottlenecks server affect result experiment aims measure overhead added process registration comparison standard java processes 
standard java process consists empty class con tains operations ligia variation includes registration checkout operations 
difference terms time observed due com munication process ligia server exist stan 
garbage collection overhead added process registration checkout 
sec java process registration checkout number processes dard java process 
average overhead added operations overhead seen high shown insignificant operations considered process registration ex compared process communica tion object creation 
additionally verify overhead added process important overhead added primitives 
avoiding memory exhaustion chapter problem memory exhaustion explored experiment problem happens depicted 
thesis argued garbage collection necessary 
consequent ly possible show implementation garbage ameliorate situation 
garbage collection implemented experiments repeated having garbage collection running 
depicts situation dashed lines plain lines shown garbage collector running 
spawned class process explained considered standard way class 

garbage collection memory exhaustion problem sec gc disabled gc enabled number tuple spaces increment process increments sec sec gc disabled gc enabled number tuple spaces gc disabled gc enabled number tuple spaces increment increment number tuple spaces created incre ment number tuple spaces created increment cases garbage collection active tuple spaces cre ated previous processes left stored kernel adds considerable head system deal bigger structure tuple spaces 
garbage collector active structure cleaner processes bet ter performance 
notwithstanding improvement terms performance garbage collector provides system major advantage terms reliability 
cases system garbage collector crashes sooner garbage collector 
instance system crash es tuple spaces created process creating tuple spaces 
garbage collection executing 
system crashes memory resources consumed tuple spaces consuming resources 
hand system garbage collection active takes longer consume memory resources garbage collector active crash occurs process creating tuple spaces iteration 
full capacity memory resources case size tuple spaces case garbage collector active garbage clearly collected 
happens speed tuple spaces created higher speed tuple spaces collected involves thor analysis tuple spaces situation system 
depicts garbage collector scalability regards larity tuple space creation 
independently granularity tuple space cre ation system garbage collector active crashes point showing system crashes resources con sumed 
course garbage collector completely avoid existence memory exhaustion 
memory finite resource possible re source completely creating garbage 
reason having system crashing garbage collection active 
garbage collection overhead implementing garbage collection algorithm system overhead expected 
chapter part overhead explored description cost process registration checkout depicted 
jones lins jl overhead considered accept able 
noticed jones lins average case overhead identified approach infeasible 
explained overhead worst case analysis average case larger process overhead proportionally registration checkout add 
chapter idea tuple monitoring introduced sight 
garbage collection suggest performance ligia affected great extent single tuple stored retrieved analysed 
results shown contradict idea 
experiment shown performed having single process looping storing tuples single tuple space groups tuples tuples 
process loop store tuples stores experiment done garbage collection activated deactivated 
done single process single tuple space garbage case difference represents raw overhead garbage collector equivalent time consumed server garbage collector plus time taken analyse tuple stored tuple monitoring 
clearly tuples need analysed tuple monitoring systems explained section worst case analysis tuple done 
difference terms number tuples stored step loop influence time taken garbage collector run happens garbage collector analyses structure tuple spaces consider data structure tuples stored 
hand number tuples stored loop influence time taken tuple monitoring system throughput tuples arrive server may ideal tuple monitoring 
shows case process stores tuples incre number tuples loop average overhead measured 
shows case process stores tuples number tuples loop average overhead observed case 
case increment tuples result better overhead stayed nil 
periodicity execution garbage collection caused overhead vary shown 
basically combination granularity tuples created periodicity garbage collection generates results 
experiments periodicity garbage collector executes running seconds 
result shows 
garbage collection overhead added tuple monitoring existence active process representing garbage collector server 
sec gc disabled gc enabled number tuples tuples created iteration sec sec gc disabled gc enabled number tuples tuples created iteration gc disabled gc enabled number tuples tuples created iteration 
garbage collection creating tuples time execution garbage collector influence total running time creation tuples affected execution garbage collection periodicity chosen 
easily note worst case analysis tuple monitored unnecessarily real overhead smaller im portant tuples marked process side mean im garbage collection linda systems necessary implement sophisticated methods tuple monitoring overhead small far figures jones lins 
account average number tuples contain handle making tuple important tuple monitoring general impossible 
shows passing handles commonest operations ligia average case overhead added monitoring cant 
hiding overhead section raw overhead garbage collector shown figures 
said results worst case analysis 
fact practical terms figures overhead en counter implementing program ligia 
better account differences terms execution time expressed experiment follows 
re ligia systems processes start create tuple spaces store retrieve tuples tuple spaces 
process generally leaves garbage collected 
garbage collection improve performance system 
experiments account gains implementation garbage collector brings systems 
process similar implemented section important difference process modified create new tuple space loop process creates tuple space storing tuples incremented depending example 
garbage collection raw garbage collection overhead sec gc disabled gc enabled number tuples increment sec sec gc disabled gc enabled number tuples gc disabled gc enabled number tuples increment increment terminates freeing tuple space collected 
basically idea having processes doing operations creation storing freeing order better comparison previous example single process 
unsurprisingly experiments shown system garbage collection enabled better performance garbage collec tion disabled 
cases explored granularity incre ment shows best improvements version garbage collector improved performance system garbage collection keeps structure tuple spaces small improves performance garbage collec tion structure grows time required insert tuple increases 

input output experiment file operations sec file reading number tuples operation sec file writing number tuples garbage collection flush operation 
examples show improvement granularity increment tuples loop shows improvement case increment tuples shows improvement 
performance improved 
garbage collection supposed degrade performance system 
answer question 
answer garbage exists collected case optimisation data structure normally compensate time taken execution collector 
cases ones depicted answer pruning data structure ligia generally efficient hide cost garbage collection execution 
input output difficult come experimental results file abstractions terms tuple spaces 
experiment shown follows line experiments analyses long takes move file contents tuple space vice versa 
reading files execution primitive done separate thread means process slowed 
fig ure gives idea time taken read file store tuples tuple 
general results table execution primitive compared execution primitive op 
link taken observed space 
adds overhead processes execution time compar considers time taken primitive table shows comparison file reading storage information tuple space execution primitive clear time taken primitive minimal compared execution equivalent number reason retrieval storing tuples file occurs step tuples retrieved stored execution involves steps maintenance ordering incurs overhead 
depicted shown table overhead resulting execution may hidden process shown table observed 
depicts performance flushing operation implemented server level 
times shown directly observed user occurs termination process created operation consists having server send necessary tuples tuple space stores information file 
general results ligia intended beat performance implementations fact implementation java difficult interesting give figures related time taken general operations ligia 

general results creation sec java tuple building objects ligia tuple size tuple size tuple size number tuples interesting point explored time takes build tuple 
experiment serves show time experiments involving tuples spent building tuples 
basically idea find overhead java implementation adding create constructor class depicts sensitivity constructor terms size tuples created terms number tuples created 
object 
illustrates different results terms sen easily seen constructor class scales linearly 
see instance table shows figures creation objects size number tuple fields 
table icr field shows increase factor terms time 
easy see consistent stay basically creation tuples 
take increase factor size 
expected increase approximately number tuple elements doubled 
thing happen increase 
increased factor 
expect observe creation object java involves overhead directly 
general results table creation objects ligia size icr icr linked size object loading class instance 
factor expected extra overhead remain constant dependently size tuple noticeable size tuple tuple bigger overhead significant pro number tuple fields 
scalability terms number tuples created closer expect 
cases time taken create number tuples proportional number tuples created 
instance tuples size time taken create tuples approximately times time taken create tuples 
fact proportionality occurs results verify looking 
creation templates considered involves creation ligia classes experiment performed templates created tuples 
fields object objects class expected results similar creation tuples 
shows implementation ligia class optimised implementation subclasses experiment performed classes 
differences terms execution time insignificant 
separate thread ligia execution primitives controlled separate thread called thread main task maintain ordering property de scribed douglas 
implementing ordering sep 
general results comparison time taken time observed user sequence performed 
sec time taken time observed number outs thread control ligia gains aspects 
primitives affected delay incurred existence ordering 
time taken ordering process perform operations 
aspect described basically states instance exe series primitives code guarantee executed executed 
second aspect described allows programmer time taken execution perform operations 
reality executed separate thread user observe time taken exe cution depicts time taken comparison time observed users 
difference time long takes take place long process waits result execution huge perform operations possible 
experiment depicted demonstrate separate thread produce better results 

general results comparison time taken execute followed sec storing retrieving tuples number tuples long take operations tuples ligia 
experiment shown depicts time taken execute shown legend time taken execute series shown legend time taken execute series followed series shown legend 
time taken equivalent case 
huge difference cases answer simple threads 
way ligia implemented new thread created sequence means case execution consists series new thread created single case threads provide better results 
thread created sequence threads created case series followed series executed amount time observed user depicted taken place hiding cost generated threads 
actual way implemented bit complicated details relevant 

general results tuple movement sec followed collect bulk operations tuples number tuples explained ligia implements bulk primitives bulk primitives efficient way implement movement copy sev eral tuples tuple space 
experiment shown shows comparison movement tuples executed sequence movement done see execution sequence inefficient com pared case 
additionally experiment depicted assuming passive tuple space active tuple space termination sequence guaranteed possible producer storing tuples tuple space indefinitely 
semantics primitive guarantees termination tuple space active 
results concur results rowstron row 
primitive information 
tuple space accessed single process 
avoids unnecessary transferring 
general results scalability ligia server relation number processes 
sec multi thread servers process processes process processes processes number outs argued thesis advantages having multi threaded server server running powerful machine multi processors server able provide better performance 
experiment describes case scalability ligia server 
results depicted achieved executing single ligia serv er multi processor machine running program time taken client process 
experiment repeated having processes running simultaneously connected server 
predicted scalability server system better concurrency 
performance shown case processes executing average time processes 
table depicts values compared values expect concurrency server 
expected values value server takes store tuple 
shown table server scales 
expected values values measured 
take instance case tuples 
messages value calculated tuples 
minimize undesired overhead added java interpreter 

final remarks table values expected measured real showing scalability ligia server 
tuples real real expect real expect real expect real expect arrive order server processes order value measured process 
tuples arriving different processes allowing server process concurrently value measured dropped 
server limit amount data process parallel 
observe time measured tuples arriving processes half value measured tuples arriving processes probably showing server saturated capacity process information concurrently 
final remarks chapter showed results implementation garbage collection distributed ligia 
generally speaking shown raw head garbage collector high reality implementation garbage collection schemes ligia improve performance system de pending amount garbage created 
regards shown cost executing primitive acceptable fact expensive real cost series general results justify implementation choices multi threaded control ordering multi threaded servers 
general experiments re sults observed implementations better performance bulk primitives single tuple primitives 
chapter research chapter issues open linda system raised 
tuples spaces created multiple tuple space linda systems removed system 
lead system memory exhaustion problem memory finite resource 

management coordination problem dealt linda 

solution issue may side effected operations making argument dealt linda implementation stronger 
dissertation addressed problems providing solutions 
step careful study related identify problems common models implementations 
discussed chapter 
observed issues explored 
step propose linda model platform ligia mode introduced chapter 
solution problem development garbage collection scheme ligia 
argued solution implemented ligia solutions individual processes user knowledge ble 
chapter identified main problem implementing garbage collection scheme ligia linda systems lack information garbage collector 
proposed graph constructed ligia store necessary information 
chapter ways creating graph centralised distributed ligia servers 
graph exists hybrid garbage collection scheme listing mark sweep implemented analyse graph identify possible tuple spaces processes necessary system 
centralised distributed version garbage collection proposed 
solution chapter assumed done ligia terms chapter side effects clear understood argument showing coordination problem chapter page 
basically introduces problem second issue showing case 
solution third issue bringing ligia described chap ter 
solution new operation called allows files abstracted tuple spaces 
file represent device unix view primitive provides programmer way completely location 
chapter explores ligia generalized new operation 
chapter implementation ligia including implemen tation centralised distributed garbage collection scheme implementation operation 
operation implement ed restricted files implementation serves mainly get experimental results ideas chapters 
exper results described chapter terms garbage collection shows garbage collection cases improve performance system 
garbage collection expected add overhead ligia garbage exists implementation performance tends better processes cleaner structure tuple spaces tuples 

research research number research problems follow dissertation 
problems fact extensions ideas proposed related necessarily directly dissertation implementation related aspects explored general implementation operation explored fur ther 
idea including devices abstraction need modification primitive include instance pipe process abstraction 
pipe process imple mented programmer ligia provides basic pipes 
tuple space persistent primitive persistency broken may useful introduce way removing persistency tuple space 
simulated ligia 
duced order ligia easier 
mechanism ought intro implementation local tuple space managers introduced row row foreseen ligia specification improve performance system 
fault tolerance huge area needs investigation 
fault tolerant lin da implementation open system developed 
proposal fault tolerant linda include investigation fault tolerant linda automatically cause garbage collection fault tolerant fault tolerant variation garbage collection required 
security big issue open systems 
tuple spaces tuples include access rights 
wood woo describes proposal access rights linda capabilities 
access rights tuple space influenced access rights file abstracted 
inclusion access rights tuple 
contributions spaces surely gives power garbage collection method take consideration 
performance improved 
implementation ligia op 
goal implementation prove concepts garbage collection distributed stand efficient implementation terms performance 
implementation improved lot improved ligia match performance linda system implemented far 
features ligia help process performance improvement tuple monitoring build system manage mi resources implementation 
process registration way kernel identify location processes location resources ing trying put rowstron row proposed layer hierarchical organization tuple spaces tuples move upwards hierarchy going local tuple spaces global tuple spaces 
graph built ligia move tuple spaces downwards hierarchy structure find required find requiring put 
contributions garbage collection centralised distributed scheme doing garbage collection ligia 
scheme adapted linda systems long provide garbage collection information necessary 
basically ligia behaves linda implementation 
closing remarks inclusion process registration tuple monitoring 
implementa tion question deal coordination problem proposal garbage collection 
bringing operations model new operation proposed allows abstraction files tuple spaces called file spaces allowing files operated unified form standard ligia primitives 
time inclusion model extends abstraction location model level 
novel run time system ligia implemented java introducing features important implementation garbage collection distributed optimisations kernel level 
ligia implements garbage collection primitive closing remarks described represents foundation understanding implementing garbage collection linda system coordination problem possibilities benefits brings implementation 
appendix ligia classes definition ligia java classes description implementation ligia java resulted creation series classes methods add ligia capabilities java language 
description far observe important classes garbage collection related classes 
shows ligia classes processes relate java classes 
class allows agents communicate servers 
pro vides agents primitive methods create access tuple spaces see sec tion 
methods method called necessary garbage collector provided 
operation communicates server accept request process communication closed 
server point view agent ed 
classes class classes form set classes necessary java agent coordinate ligia 
needs explanation im object class ligia object garbage collected java garbage collection 

ligia java classes description relationship ligia agent classes java classes interfaces 
object vector tuple java class ligia class interface key thread handle formal implements extends serializable known concepts linda 
douglas identified solved problem named ordering 
problem consists guaranteeing tuples arrive tuple space order leave process 
class separate thread monitors execution order method single agent 
avoids primitives affected ordering instance blocked waiting completion 
distributed processes 
multi threaded class deals requests coming agent thread 
objects representing garbage collection spawned fore object class spawns thread objects class sole job spawn 
ligia java classes description relationship ligia server classes java classes interfaces 
object thread connection serializable garbage collection objects 
class methods deal requests processes 
methods lower level primitives processes 
requests received sockets 
garbage collection objects threads low priority execution minimise overhead 
described section objects independent objects cooperate shows ligia server classes relation java classes 
addition classes described depicts extra classes 
classes represents data structure tuple tuple space object class represents data structure represents processes currently attached ligia process represented kernel object class classes simple 
important executing location ligia process executing maintains information related ligia data struc ture built classes information maintained basically name file abstracted hold 
agent system relationship ligia classes java classes interfaces 
object thread serializable name process associated abstraction case abstraction devices 
java thread responsible retrieving information files storing information files 
basically acts active part creates data structure statically accessed noticed despite name flushes tuple space contents file reads file contents sends tu ple spaces 
analogy class processes agent system acts keeps waiting messages arrive servers 

server system server system 
server system 
system system 
system bibliography acp jean marc andreoli paolo ciancarini pareschi 
interaction machines 
agha wegner yonezawa editors research directions concurrent object oriented programming pages 
mit press 
adfs henning andersen jan due peter flemming rensen 
ariadne development 
technical report university aalborg institute electronic systems department mathematics computer science 
agh gul agha 
actors model concurrent computation distributed systems 
mit press 
ap jean marc andreoli pareschi 
linear objects logic frame open system programming 
voronkov editor proceedings international conference logic programming automated reasoning lpar volume lnai pages st petersburg russia july 
springer verlag 
ar arbab rutten 
manifold programming model massive parallelism 
shriver editors pro ceedings conference programming models massively parallel bibliography computers pages los alamitos ca usa september 
ieee computer society press 
ar 
garbage collecting inter net survey distributed garbage collection 
acm computing surveys september 
anderson shasha 
persistent linda linda transactions query processing 
jean pierre banatre daniel le metayer ed proc 
research directions high level parallel programming languages volume lncs pages berlin germany june 
springer 
bb gerard berry gerard boudol 
chemical machine 
ben acm editor proceedings seventeenth annual acm symposium principles programming languages pages new york ny usa 
acm press 
andrew birrell david greg nelson susan owicki edward wobber 
distributed garbage collection network objects 
technical report digital systems research center december 
david 
distributed garbage collection count ing 
bakker bnt pages 
lecture notes computer science vols 

bl 
ban tre le tayer 
gamma model discipline programming 
science programming 
bnt bakker philip editors 
parallel architectures languages europe 
springer verlag june 
lecture notes computer science vols 

bwa paul butcher alan wood martin atkins 
global synchronisation linda 
concurrency practice experience 
bibliography bz butcher 
polymorphic linda 
jp 
bana tre editors research directions high level paral lel programming languages volume lecture notes computer science pages mont saint michel france june 
springer verlag berlin 
ccr castellani ciancarini rossi 
shape shade coordi cff nation system 
technical report ublcs dipartimento di scienze dell informazione universit di bologna italy 
peter corbett dror feitelson sam hsu bill nitzberg jean pierre marc snir bernard wong 
overview mpi io parallel interface 
proc 
third shop parallel distributed systems santa barbara ca april 
ipps 
cg carriero gelernter 
net linda kernel 
acm transactions computer systems 
nicholas carriero david gelernter david kaminsky jeffery west brook 
adaptive parallelism piranha 
technical report department computer science yale university yale university new haven 
carriero gelernter zuck 
bauhaus linda 
ciancarini nierstrasz yonezawa editors object models lan guages concurrent systems volume lecture notes computer science pages 
springer verlag berlin 
cia paolo ciancarini 
coordination software engineering 
tutorial pre sented coordination berlin germany september 
ciancarini tolksdorf 
pagespace ar chitecture coordinate distributed applications web 
computer networks isdn systems may 
bibliography cl michal cierniak wei li 
flexible java compiler 
technical report tr university rochester computer science department may 
css jo carreira luis silva jo gabriel silva 
design linda library mpi 
ieee editor nd scalable parallel libraries conference october 
ctv paolo ciancarini robert tolksdorf fabio 
coordination dlm world wide web pagespace experience 
technical report bologna technische universit berlin 
dijkstra lamport martin scholten 
fly garbage collection exercise cooperation 
communica tions acm november 
andrew douglas alan wood antony rowstron 
linda implementa tion revisited 
patrick nixon editor proc 
th world occam transputer user group pages 
ios press april 
fla david flanagan 
java nutshell desktop quick java programmers 
reilly associates 
gal 
linda system top pvm 
lecture notes computer science 
gc david gelernter nicholas carriero 
coordination languages significance 
communications acm february 
gel david gelernter 
generative communication linda 
acm transactions programming languages systems 
gel david gelernter 
multiple tuple spaces linda 
proc 
parle pages 
springer verlag 
gjs james gosling bill joy guy steele 
java language specification 
java series 
addison wesley 
bibliography gro object management group 
common object request broker archi tecture specification 
technical report omg july 
gro sun microsystems development group 
personal communication 
hen henning 
binding migration scalability corba 
commu acm october 
hf christopher haynes daniel friedman 
embedding continuation procedural objects 
acm transactions programming languages systems october 
hug john hughes 
distributed garbage collection algorithm 
jean pierre jouannaud editor proc 
acm conference functional programming languages computer architecture pages 
lecture notes computer science vol 

susanne 
linda multiple tuple space 
cal report yale dcs rr yale university february 
ini applications working group scalable initiative 
preliminary survey intensive applications 
technical report concur rent supercomputing consortium caltech pasadena ca january 
scalable initiative working 
jl richard jones rafael lins 
cyclic weighted count ing delay 
bode mike reeve wolf edi tors parle parallel architectures languages europe volume lecture notes computer science 
springer verlag june 
jl richard jones rafael lins 
garbage collection algorithms au dynamic memory management 
wiley 
jeong bin li dennis peter wyckoff 
plinda fortran user guide 
technical report new york university march 
bibliography kie 
designing coordination model open systems 
technical report dept electrical engineering computer science university siegen germany 
lam leslie lamport 
time clocks ordering events distributed system 
communications acm july 
lin lins 
cyclic counting lazy mark scan 
information processing letters 
technical report 
federal university brazil 
bernard lang christian queinnec jos 
garbage collecting world 
conference records th annual acm symposium principles programming languages pages 
acm press january 
men menezes 
ligia incorporating garbage collection java linda run time system 
macedo cal robert burnett editors proc 
nd workshop dis tributed systems pages brazil june 
mey bertrand meyer 
object oriented software construction 
prentice hall nd edition 
menezes iain alan wood 
coordination content addressable web 
autonomous agents multi agent systems 
ms moyer sunderam 
scalable parallel system distributed computing environments 
proc 
conference scal able high performance computing pages 
ieee computer society press may 
mw menezes alan wood 
garbage collection open ed tuple space systems 
proc 
th brazilian computer networks bibliography symposium pages carlos paulo brazil may 
mw menezes alan wood 
coordination distributed tuple space systems 
proc 
st hawaii international conference system sciences volume vii pages big island hawaii usa 
ieee computer society 
mw menezes alan wood 
garbage collection linda tu ple monitoring process registration 
proc 
th internation conference parallel distributed computing systems pages las vegas nevada usa 
acta press 
mw menezes alan wood 
ligia java linda run time system garbage collection tuple spaces 
technical report department computer science university york ber 
mw menezes alan wood 
distributed garbage collection tu ple space open linda coordination systems 
proc 
th inter national symposium computer information sciences turkey 
appear 
ns brian nielsen tom rensen 
implementing linda multiple tu ple spaces 
technical report aalborg university january 
ns brian nielsen tom rensen 
distributed programming multiple tuple space linda 
technical report aalborg university june 
ow scott oaks henry wong 
java threads 
reilly associates second edition 
ps david marc shapiro 
survey distributed garbage collection techniques 
technical report research project inria november 
bibliography row antony rowstron 
bulk primitives linda run time systems 
phd sis department computer science 
university york 
row antony rowstron 
bonita primitives case study 
technical report computer laboratory university cambridge cambridge uk 
row antony rowstron 
ordination language geographically dis tributed agents 
world wide web 
rss antony rowstron li 
system support ing distributed web applications composed collaborating agents 
proc 

rud martin 
correctness distributed garbage collection algo rithms 
technical report tr risc linz johannes kepler uni 
rw antony rowstron alan wood 
efficient distributed tuple space implementation networks workstations 
robert editors euro par volume lecture notes computer science pages 
springer verlag 
rw antony rowstron alan wood 
bonita set tuple space primitives distributed coordination 
el yale patt edi tors proc 
th hawaii international conference system sciences volume pages 
ieee computer society press january 
sdp marc shapiro peter david 
ssp chains robust distributed supporting acyclic garbage collection 
technical report inria november 
sun sun microsystems java object serialization specification february 
revision 
jdk fcs 
sun sun microsystems specification june 
revision 
bibliography sun sun microsystems distributed events specification july 
sion beta 
sun sun microsystems distributed leasing specification july 
re vision beta 
sun sun microsystems transaction specification july 
revision beta 
tan andrew tanenbaum 
distributed operating systems 
prentice hall en cliffs nj usa 
tec tower technology 
tower compiler 
version 
www twr com java java products html 
tol robert tolksdorf 
laura coordination language open distributed systems 
robert werner editor proc 
th international confer ence distributed computing systems pages pittsburgh pa may 
ieee computer society press 
tol robert tolksdorf 
coordination services open distributed systems laura 
paolo ciancarini chris hankin editors proc 
coor number lecture nodes computer science pages 
springer verlag 
tol robert tolksdorf 
laura service coordination language 
sci ence computer programming july 
wyckoff lehman ford 
spaces 
ibm systems journal 
special issue java technology 
woo alan wood 
coordination attributes 
proc 
coordination lecture nodes computer science 
springer verlag 
appear 
ww watson watson 
efficient garbage collection scheme par computer architectures 
bakker bnt 
lecture notes computer science vols 

