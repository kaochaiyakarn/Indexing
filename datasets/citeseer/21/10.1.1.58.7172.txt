conflict directed role model embedded systems brian williams robert space systems artificial intelligence laboratories massachusetts institute technology rm cambridge massachusetts artificial intelligence traditionally constraint satisfaction logic frame wide range problems including planning diagnosis cognitive robotics embedded systems control 
decision making problems re framed optimization problems involving search discrete space best solution satisfies set constraints 
best methods finding optimal solutions explore space solutions state time 
introduces conflict directed method solving optimal constraint satisfaction problems 
conflict directed searches state space best order accelerates search process eliminating subspaces state inconsistent 
elimination process builds concepts conflict kernel diagnosis model diagnosis dependency directed search 
conflict directed fundamental tool building model embedded systems solve range problems including fault isolation diagnosis mode estimation repair model compilation model programming :10.1.1.1.6964
approach focusing search summaries logical inconsistency problem solving method ai 
summaries gone various names nogoods conflicts elimination sets email addresses williams mit edu brian williams mit edu robert :10.1.1.27.4126
supported nasa cross enterprise technology development program contract nag darpa program contract 
preprint submitted journal discrete applied math january exclusion relations term conflict 
past concentrated extensively conflicts find solution consistent set constraints 
consistency says quality solution 
ai shifting increasingly problem formulations involve finding set best solutions utility function measures quality solution 
generalization conflict directed search optimization open research frontier 
demonstrate conflicts combined search provide powerful method finding optimal solutions discrete constraint satisfaction problems 
call method conflict directed 
ai explored paradigm search diagnosis repair fundamental problem solving paradigm strategy solving core ai reasoning tasks planning scheduling diagnosis qualitative reasoning :10.1.1.34.6853:10.1.1.31.8372
paradigm diagnosis incorrect solution summarized conflict guide repair step 
systematic backtrack search methods conflicts select backtrack points 
methods include dependency directed backtracking intelligent backtracking conflict directed backjumping dynamic backtracking :10.1.1.27.4126
local search methods conflicts select local moves remove conflicts 
representative examples include hacker planning min conflict constraint satisfaction gsat walksat propositional satisfiability 
conflict directed builds third approach uses conflicts solve constraint satisfaction problems divide conquer 
approach plays integral role model diagnosis introduced general diagnostic engine gde 
gde frames diagnosis constraint satisfaction problem involves finding assignments modes components consistent device model set observations 
gde begins searching parallel conflicts smallest partial assignments produce inconsistency 
set conflicts combined produce compact descriptions feasible states called kernel diagnoses 
key feature conflict directed divide conquer approach ability reason intensionally collections states states individually 
reduces ective size search space explored 
significant limitation early approach practical applications require best solutions solutions 
case approach generating solutions conflicts parallel waste significant ort 
limitation exacerbated fact set descriptions conflicts kernel diagnoses grows exponential worst case 
model diagnosis community gde approach fell increasingly replaced methods focus small subset diagnoses enumerating state space best order :10.1.1.1.6964
research best enumeration methods key questions conflicts ectively reason classes states interested best solutions solutions 
theories diagnosis conflicts kernel diagnoses rigorously unified theories diagnosis best search 
general purpose conflict directed methods solving constraint satisfaction problems csps unified informed methods best search 
resolve questions addressing family problems called optimal constraint satisfaction problems 
optimal csp multi attribute decision problem decision variables constrained set finite domain constraints 
focus solution optimal csps attributes preferentially independent property shared practical multi attribute decision problems 
introduce conflict directed method solving optimal csps satisfy preferential independence 
approach tests sequence candidate solutions decreasing order utility 
di ers uses sources conflict identified inconsistent candidate jump related candidates sequence 
practice conflict directed lead dramatic decrease number states visited approach exploit conflicts 
demonstrated randomized problems real world application 
variants algorithm demonstrated control variety embedded autonomous systems including tasks repairing dollar deep space probe light minutes earth monitoring health robotic astronaut :10.1.1.1.6964
variants perform tasks model compilation diagnosis mode estimation hardware reconfiguration repair :10.1.1.141.6126
focuses pervasive family discrete constrained optimization problems 
related research demonstrate conflicts extend solution continuous optimization problems 
describes method called activity analysis solves non linear constrained optimization problems ruling portions state space sub optimal 
addition describes method called decompositional model learning uses conflicts decompose solve maximum likelihood problems parameter estimation state estimation model learning 
remainder structured follows 
section introduces conflict directed informally stepping execution simple examples highlighting role creating model systems reason reactive time scales 
section defines optimal constraint satisfaction ocsp introduces property mutual preferential independence 
section provides overview 
demonstrates conflict directed uses conflicts jump leading states proven inconsistent demonstrates optimal csps core embedded systems self diagnosing repairing 
remaining sections develop algorithms detail 
section develops algorithm solving optimal csps called constraint conflicts 
constraint leverages property preferential independence focus search tree expansion promising children 
section introduces core algorithm underlying conflict directed called best kernel uses search quickly find region state space called kernel contains best utility state resolves known conflicts 
section introduces conflict directed algorithms generating single multiple solutions unifying constraint best kernels algorithms introduced preceding sections 
section discuss experimental results compare performance constraint conflict directed applied randomly generated problems representative space application 
optimal csps lay ground development conflict directed define optimal constraint satisfaction problem ocsp introduce pedagogical example 
recall constraint satisfaction problem csp consists set variables range finite domains set constraints rue alse 
solution assignment satisfies rue 
optimal csp csp consists csp set decision variables cost function 
refer remaining variables non decision variables partition domain call elements decision states 
solution ocsp minimum cost decision state consistent csp 
precisely constraint projection decision variables consistent frame ocsp minimizing cost consistent framework search equally valid think terms maximizing utility particularly multi attribute utility decision problems 
consistent 
argmax dy consistent 
natural way encoding ocsp multi attribute cost function associates attribute costs ij individual variable assignments ij uses compose global cost 
practical multi attribute decision problems satisfy property called mutually preferential independent mpi 
means subset problem decision variables preference assignments independent particular assignments remaining decision variables 
key consequence mpi exploited algorithms assignment minimizes cost minimizing attribute cost separately 
fig 

boolean observed values indicated 
simple example ocsp task identifying consistent diagnoses circuit called boolean consisting gates gates 
inputs outputs observed indicated 
component possible modes broken 
component correctly performs boolean function 
precisely cost function ocsp specified attribute cost maps binary function associative commutative identity applied attribute costs defined recursively standard manner 




preference defined better cost definition csp optimal csp sets assignments preferred 
behavior broken component unknown imposes constraint 
decision variables component mode variables domain consists 
candidate mode assignment diagnosis candidate consistent set constraints model boolean set observations 
example model includes constraint iff 
utility candidate probability 
take cost 
keep example simple candidate prior probability assume component failures independent attribute utilities component probabilities combined multiplication satisfies mpi 
assuming gates fail probability gates probability solution ocsp broken 
conflict directed nutshell section provides thumbnail sketch conflict directed starting pictorial view elaborating algorithm boolean driving example 
pictorial view conflict directed method choice finding optimal solutions discrete state space search problems 
generates tests states increasing order heuristic cost depicted 
note equivalently formulated search order decreasing utility 
equivalently formulated terms maximizing utility 
terms cost utility depending ers intuitive explanation topic 
heuristic admissible overestimates cost guaranteed return optimal feasible solution exists 
cient explores search state estimated cost greater optimum 
guarantee solution returns optimal visits state estimated cost true optimum 
impractical inconsistent consistent increasing cost fig 

examines best cost states best consistent state 
real world applications model systems perform best search reactive control loop 
conflict directed accelerates search process leading inconsistent states 
conflict directed guides search conflicts descriptions states inconsistent csp 
intuitively conflict denotes set states proven inconsistent proof 
example deduce model state shorted voltage regulator produce symptom particular voltage low 
say state contained conflict manifests conflict state contained conflict resolves conflict 
inconsistent consistent increasing cost conflict inconsistent consistent increasing cost conflict conflict inconsistent consistent increasing cost conflict conflict conflict inconsistent consistent increasing cost conflict conflict conflict fig 

conflict directed focuses search discovered conflicts 
represent snapshots prototypical search 
circles represent states 
filled circles tested consistency 
regions grey ruled conflicts 
state consistent 
conflict directed selects state proves inconsistent 
inconsistency generalizes conflict eliminates states 
conflict directed tests state best cost state resolves conflict 
tests inconsistent generates conflict eliminating states 
conflict directed tests state best cost state resolves conflicts 
proves inconsistent producing conflict 
search tests state consistent returns optimal solution 
example conflict directed tested inconsistent states jumping inconsistent states 
real world examples savings dramatic 
example consider problem reconfiguring main engine system cassini saturn space probe performed simulation livingstone system 
reconfiguration task consists finding minimum cost set component modes closing valves turning drivers shown thrust engine system maintaining set safety constraints 
state space consists roughly states 
conflict directed dozen candidate states tested order find optimal solution section 
conflict directed generate test function conflict directed ocsp returns leading minimal cost solutions 
conflicts ocsp ocsp initialize best kernels ocsp solutions ocsp loop decision state best state resolving conflicts ocsp decision state returned terminate ocsp return solutions ocsp consistent csp ocsp decision state add decision state solutions ocsp new conflicts extract conflicts csp ocsp decision state conflicts ocsp eliminate redundant conflicts conflicts ocsp new conflicts fig 

top level loop conflict directed 
conflict directed performs interleaved best generate test 
generates candidate best valued decision state resolves discovered conflicts 
tests candidate consistency csp function consistent 
tests inconsistent extract conflicts generalizes inconsistency conflicts denoting states inconsistent manner similar candidate tested suitable csp algorithm extracts conflicts 
conflict directed uses discovered conflicts record known inconsistent states pruning redundancy eliminate redundant conflicts 
conflict directed uses best state resolving conflicts jump best candidate resolves conflicts discovered far 
process repeats desired leading solutions states eliminated 
candidate tested suitable csp algorithm extracts conflicts 
minimal form csp solved csp algorithm applied easy augment range csp solvers solve optimal csp problems 
appendix discusses requirements general implementation issues conflict 
presentation focuses primarily subtle procedure state resolving conflicts 
walk execution top level loop conflict directed boolean demonstrating jumps leading candidates inconsistent guaranteeing optimality 
candidate components okay initially known conflicts states consideration 
generates candidate specifies components working correctly probability 
candidate tested consistency model observations left dpll propositional satisfiability algorithm modified return conflicts 
particular dpll concludes inputs 
conclude output 
prediction inconsistent observation candidate eliminated solution 
inconsistency generalized conflict subset candidate assignments su cient produce inconsistency constraints 
conflict extracted reductio implementation includes termination conditions finding leading solutions finding solutions order magnitude cost leading solution terminating states tested 
ad conjunction imply conflicts conjunction inconsistent 
fig 

tested candidates conflicting components highlighted 
left candidate components okay 
right candidate unknown 
jump second candidate gate broken second iteration conflict directed jumps leading candidates containing conflict subset best candidate resolving conflict 
candidate resolves conflict contain conflict subset 
conflict resolved changing assignments conflict di erent value including change new candidate 
jumps state contains conflict subset 
generates best state candidate probability 
candidate resolves conflict changing candidate tests inconsistent producing conflict 
shown right depicted removing component 
third candidate diagnosis gate broken consecutive state candidate probability resolves conflicts changing assignment candidate tests consistent top best diagnosis 
fig 

candidates diagnoses 
top candidate unknown 
middle candidate unknown 
bottom candidate unknown 
finding remaining diagnoses involves search point conflict directed tested consistency candidates diagnosis jumped candidate 
modest savings traditional 
initial phase search typically invested discovering conflicts reward rest search 
example testing candidates conflict directed discovered conflicts example 
point conflict directed su cient knowledge generate remaining diagnoses generating additional inconsistent candidates 
continuing search leading diagnoses generated jumping inconsistent candidates explicitly considering inconsistent candidates 
measuring search ciency solutions candidates tested traditional ciency conflict directed ciency 
generating best kernel key conflict directed ability ciently generate iteration best candidate resolving known conflicts 
accomplished mapping known conflicts partial assignments called kernels 
best cost state extracted kernels 
kernel describes set states resolve known conflicts 
example conflicts resolved changing kernel 
provide intuitions process section presenting details sections 
constituent kernels kernels conflicts fig 

conflict directed maps conflict set constituent kernels resolve conflict 
kernels generated combining minimal set covering 
mapping conflicts kernels closely related candidate generation algorithm introduced general diagnostic engine gde 
step generates constituent kernels resolve conflict 
second step generates kernels resolve conflicts computing minimal set covering constituent kernels 
particular combined kernel property contains constituent kernel conflict conflicts resolved 
constituent kernels conflict shown top kernels covering conflicts shown bottom 
constituent kernels conflict conflict fig 

search tree created conflict directed identify kernels 
visited nodes kernels check marked crossed 
gde want generate kernel containing best utility state 
key number conflicts worst case exponential number decision variables 
idea view minimal set covering search search find kernel containing concept kernel generalizes kernel diagnosis 
best utility state explicitly enumerating kernels possible 
search tree boolean shown 
leaves kernels intermediate nodes partial coverings 
example bottom left leaf denotes kernel parent denotes 
tree node expanded selecting constituent kernels conflict unresolved node creating child constituent kernel conflict 
example root node resolve conflict 
selecting conflict children root 
nodes eliminated non minimal third leaves bottom left tree 
consider best candidate extracted kernel 
generate best candidate assigning remaining unassigned variables 
accomplish exploit property called mutual preferential independence mpi 
mpi says find best candidate assign variable best utility value independent values assigned variables 
example initially conflicts best kernel root node 
kernel candidate assigns value variable components working 
constituent kernels conflict constituent kernels conflict conflict fig 

left tree expansion kernel producing candidate 
best valued child root expanded children 
right tree expansion kernel producing candidate 
node expanded best child best sibling created 
continuing process candidate generated left conflict discovered kernels correspond constituent kernels conflict 
kernel contains candidate 
estimated probability combines probability optimistic estimate admissible heuristic best probability unassigned variables 
mpi heuristic selects best utility value unassigned variable resulting best candidate 
key property search expands best valued child children 
valid mpi guarantees contains state utility state contained children 
best kernel descendants 
resolves known conflicts kernel 
maximize utility kernel best candidate assigns remaining components candidate broken 
candidate generated right conflict discovered 
node resolve conflict expanded creating best child 
kernel best candidate probability 
point longer valid just expand best child 
conflict pruned states node longer guaranteed contains state sibling sibling may contain best kernel 
achieve completeness expand best sibling probability 
best sibling higher probability best child sibling selected 
kernel produces candidate diagnosis 
important property search strategy distinctive pattern expanding node step creating best child best sibling 
strategy ect growing search queue modest size visiting nodes 
want continue search example find set diagnoses cover probability density space 
accomplish need capability systematically explore states kernels best order 
complicated extracting best state best kernel demonstrated 
develop complete strategy section 
self repairing systems reason reactively conflict directed core approach creating new generation model autonomous embedded systems achieve robustness reasoning extensively reactive time scales 
section outline link conflict directed model embedded systems 
embedded systems automobiles power networks building control systems dramatically increased computation achieve unprecedented levels robustness little human support 
systems operate robustly years minimum attention 
extreme example class embedded systems fleet intelligent space probes autonomously explores nooks solar system 
embedded systems may need radically reconfigure response failures navigate failures remaining operation 
space potential failures embedded system may faced lifespan far large programmer pre enumerate 
current hand coded systems achieve tractability limiting number faults covered 
addition injection undetected software bugs caused significant system loss failure mars polar lander 
embedded system able automatically diagnose plan courses action 
solution paradigm called model programming everyday embedded systems explorers programmed specifying strategic guidance form high level control behaviors called model programs 
behaviors specify system intended state evolution abstracting away detailed problem controlling estimating diagnosing repairing states 
specifications look traditional embedded programs traditional programs read sensed variables write control variables model programs allowed read write hidden variables 
commands configuration goals observations hardware real time control control sequencer state estimate plant model control program deductive controller model control program reactive model programming language titan model executive mode estimation mode reconfiguration fig 

architecture model executive 
model program executed automatically generating control sequence moves physical plant states specified control program 
call specified states configuration goals 
program execution performed model executive consisting control sequencer deductive controller 
control sequencer repeatedly generates configuration goal control program plant state 
deductive controller generates sequence control actions achieve goal knowledge current plant state model 
deductive controller responsible estimating plant current state observations plant mode estimation issuing commands move plant sequence states achieve goals mode reconfiguration 
fire backup engine valve fails stuck closed valve fails stuck closed open valves open valves fig 

diagnosis repair sequence simplified cassini spacecraft 
pyro valves horizontal bars 
valve closed filled open 
faulty valve circled 
example consider problem controlling cassini spacecraft inserts saturn orbit 
configuration goal generated achieve state engine thrusting 
series idealized schematics main engine subsystem cassini shown 
consists tanks main engines left right redundant latch valves pyro valves 
paths main engine open flow engine produce thrust 
pyro valves isolate parts engine 
open close costly latch valves 
system ers wide range configurations achieving goal producing thrust 
configuration goal engine thrust mode estimation determines engines currently shut 
mode reconfiguration deduces goal may accomplished opening latch valves leading engine sends commands open valves 
suppose engine fails provide desired thrust 
mode estimation identifies cause failure example right latch valve going engine stuck closed 
mode reconfiguration searches alternate set component modes achieve goal engine thrust 
engine stuck valve 
mode reconfiguration deduces costly way achieve goal fire pyro valves leading engine open remaining latch valves firing additional pyro valves 
conflict directed forms core mode estimation mode reconfiguration 
refer implementation 
model executive compiles hardware models clauses propositional state logic 
mode estimation mode reconfiguration framed optimal csps form arg min satisfiable unsatisfiable conjunction propositional clauses satisfied solution conjunction propositional clauses satisfied mode estimation selects time step sets component mode transitions consistent plant model current observations 
discussed framed roughly arg min satisfiable set component modes system transition transition probability plant model current set observations :10.1.1.1.6964
time step mode reconfiguration chooses cost set reachable component modes consistent model entails current configuration goals discussed 
mode reconfiguration framed roughly arg maxr satisfiable entails cost transitioning mode conjunction configuration goals constraint entails equivalent unsatisfiable 
having identified reachable set component modes mode reconfiguration generates command sequence move modes 
accomplish mode reconfiguration generates compact encoding universal plan compile time 
step process involves compiling model set automata eliminate intermediate variables 
discussed compile model generating complete set prime implicates model refer control assignments current mode assignments 
summarize conflict directed plays central role creating robust model embedded systems runtime state estimation control design time model compilation 
summary far introduced conflict directed uses discovered conflicts jump sets inconsistent states demonstrated process boolean 
addition demonstrated process generating best kernel consistent subspace containing best cost solution search minimal covering tree 
demonstrated conflict directed core building self systems reason reactive time scales 
remainder presents optimal csps conflict directed formally supporting methods constraint kernels 
constraint ers point comparison method solving optimal csps exploits preferential independence conflicts 
best kernel ers method generating parsimonious descriptions best solutions ering time approach avoiding exponential growth descriptions 
constraint section generalize search method ciently solving optimal csps exploiting added structure imposed csp cost function 
quick review state space search 
review recall generic state space search problem comprised set states initial state set search operators op map states states goal test true false specifies state satisfies problem goals 
solution operator sequence maps initial state goal state 
problem includes cost function returns cost applying operator sequence starting initial state 
optimal solution minimizes cost 
search tree induced tree initial state recursively expanding tree node mapping node state child states applicable operators 
search explores tree expanding tree nodes best order function estimates cost best solution goes node guaranteed find shortest path node avoids expanding sub optimal paths exploiting instance dynamic programming principle 
terminates reaches state satisfies goal test 
node state computes adding estimate minimum cost reach goal state guaranteed return best solution admissible overestimates minimum cost reach goal 
characterized optimally cient sense optimal algorithm expands search paths root guaranteed expand fewer nodes 
intuitively algorithm expand nodes contours root goal contour runs risk missing optimal solution 
leverage point improving fact optimal csp imposes additional structure traditional exploit particular states factored variable assignments constraint factored set constraints 
generalizations preserve ciency explicitly consider state worse optimal solution 
correctness rule state better optimum 
rules states explicitly generalizations rule states implicitly 
generalizing constraint section develop constraint variant solves optimal csps exploiting mpi conflicts 
framing optimal csp state space search problem search state partial assignment decision variables initial state empty assignment 
operator takes partial assignment adds assignment unassigned variables 
goal test returns true search state consistent assignment variables assignment satisfies csp constraints 
cost partial assignment computed combining individual assignment costs defined section 
associativity commutativity cost function search state independent order assignments 
search tree optimal csp called assignment tree similar csps 
examples section 
unassigned variable selected tree node leaf branches node labeled alternative assignments variable 
set assignments path tree root node partial assignment csp represents node search state 
search state leaf node decision state optimal csp 
functions supporting manipulation assignment trees appendix function constraint ocsp returns leading minimal cost solutions ocsp 
problem ocsp problem nodes ocsp queue search tree node ocsp solutions loop terminate ocsp solutions nodes ocsp empty return solutions node remove best nodes ocsp nodes ocsp enqueue nodes ocsp expand variable node ocsp goal test state ocsp applied state node succeeds add state node solutions function goal test state node problem returns true node complete consistent decision state 
state node assigns values decision variables problem return consistent state node csp problem return false fig 

constraint 
constraint variant 
distinguished heuristic cost node expansion function expand variable defined respectively subsections 
admissible heuristic optimal csps admissible cost node lower bound cost states appearing node satisfy goal test 
absence additional information take lower bound cost full extensions partial assignment 
pseudocode functions corresponding appendix cost partial assignment computed applying ocsp assignments 
heuristic cost completion lower bound cost assignments unassigned variables 
define may computed ciently exploit mutual preferential independence mpi 
recall cost function mpi follows 
cost decision state minimized minimizing cost assignment variable separately 
denote set unassigned variables ocsp particular search node 
minimum cost assignment min min min ij dz ij 
example boolean included tree node corresponding kernel 
utility assignments kernel pa po 
cost minimized maximizing probability probability component maximized mode pa po po 
general definition optimistic estimate cost extensions admissible constraint guaranteed come optimal solution 
estimate state exist cost state may inconsistent expanding best child complete development define expand variable 
straight forward implementation perform expansion similar backtrack search 
node expand variable check see state consistent 
select unassigned decision variable variable exists generate child possible value set attribute costs 
denote 

variable domain 
csp solution insensitive order variables assigned variable may chosen expand step variables 
addition expansion systematic search need detect multiple paths search state 
better exploiting mutual preferential independence reduce number branches tree expanded search 
proposition sibling nodes labeled assignment ij labeled ik ij ik 
exists leaf node leaf nodes state state 
fig 

example demonstrating children node child preferred cost contains state preferred cost best state 
example suppose node state 
furthermore suppose expand child child 
leaf leaves 
particular mpi best leaf cost 
better best leaf mpi cost 
note best children di er assignments 
consequence mpi 
consider constraint expands node starts selecting unassigned variable assume values ranked increasing 
cn fig 

due mpi child node best cost assignment needs expanded right children left 
order cost denoting value minimizes denoting second best value forth 
likewise denote child best assignment denote child second best assignment forth 
key consequence proposition function expand variable needs create node child best assignment 
follows leaf exist cost equal leaves siblings 
best cost unexplored state contained node contained siblings 
best child created function expand variable best child 
function expand variable best child node problem returns node child best cost assignment 
variables assigned state node return return expand domain node problem function expand domain node problem returns child best cost assignment unassigned variable 
unassigned variable state node smallest domain 
ij ij problem child assignments node sort better assignment problem true ij best assignment domain return node ij node function better assignment ij ik problem returns true lower bound cost child node adds assignment ij sibling adding ik return problem ij problem ik fig 

expanding best child constraint 
node guaranteed contain best state states eliminated example selecting simplicity presentation expand domain orders cost node created 
ciency implementation performs ordering domains created 
function expand variable node problem returns best nodes expanded node 
consistent state node csp problem nodes expand variable best child node problem leaf node node problem nodes nodes expand best sibling ancestors node problem return nodes return function expand best sibling ancestors node problem returns siblings node ancestors best assignment 
root node return return expand best sibling node problem expand best sibling ancestors parent node problem function expand best sibling node problem returns node sibling best assignment child assignments parent node 
root node return ij assignment node kl assignment child assignments parent node ij assignment kl parent node child kl return return node kl parent node fig 

expanding best sibling constraint 
leaf nodes candidate testing consistency 
point may eliminated best decision state case best leaf node may lesser cost remaining unexplored leaves leaf node eliminated constraint create node best sibling sibling created function expand best sibling shown 
leaf expanded best sibling created ancestor leaf function best sibling ancestors 
approach expansion summarized 
traditionally expands children node producing nodes maximum variable domain size max 
call expand increases size queue nodes producing worst case note constraint expands node partial assignment proves consistent similar backtrack search 
growth iterations 
contrast strategy grows queue node step new nodes added removed producing worst case growth nodes iterations 
practice important reduction queue growth 
strategy preserves key properties optimality completeness expands leaves best order eventually reaches tree leaves variable domains finite 
constraint applied boolean returning boolean constraint begins root node search queue 
root dequeued best child expanded enqueued selecting unassigned variable assigning best assignment similar process generates best state candidate top left 
node leaf node dequeued expand variable generates best sibling node ancestors producing bottom left 
constraint uses goal test state test candidate proves inconsistent 
continuing search nodes front queue cost 
assuming dequeued repeatedly generates best descendants producing top right 
complete assignment returned second candidate 
leaf node dequeued expand variable generates best sibling ancestors bottom right 
best sibling generated domain exhausted 
candidate tests inconsistent 
likewise third round search expands generating best descendants bottom right third candidate 
fig 

constraint search tree boolean best states 
top left expanding best descendants create best state 
bottom left dequeued best sibling ancestors created 
top right expanding descendants produce second best state 
bottom right expanding descendants produce third best state 
proves inconsistent 
process repeats desired set best consistent candidates 
summary constraint concepts 
ocsp may solved performing search tree representing space partial assignments similar traditional backtrack search 
second mpi enables ciently estimate cost go partial assignment 
function simply selects assignment best attribute cost unassigned variable 
queue growth reduced expanding best child node waiting child states removed expanding best sibling 
corresponds second candidate tested conflict directed 
generating best kernel conflict directed uses best state resolving conflicts jump leading set conflicting states demonstrated section 
accomplishes function best kernel generate kernel containing best state 
develop best kernel section 
early diagnostic approaches generated complete description diagnostic space generating kernels conflicts 
worst case complete set kernels may exponential number components 
best kernel allows address problem generating kernels best order stopping generated kernels cover solutions 
approach ers time space algorithm increases coverage solution space additional time memory permits 
diagnosis approach particularly ective common case small collection kernels covers probability density valid diagnoses remaining exponential number kernels collectively cover small portion probability density space 
conflict directed best kernels operates subset complete set conflicts produces approximate kernels contain solutions may include inconsistent decision states 
decision states pruned goal test testing consistency csp solver 
conflicts kernels making terms precise 
partial assignment variables csp denotes subset state space csp 
conflict partial assignment inconsistent 
state superset conflict inconsistent 
conflict denotes inconsistent subset state space 
definition set variables state space constraint conflict constraint partial assignment state extends inconsistent conflict state manifests resolves 
example section candidate boolean state manifests conflicts conflict conflict jump subspaces containing conflicting states conflict directed inverts known conflicts generating descriptions subsets state space resolve conflicts 
subspaces states resolve set conflicts described partial assignments called kernels 
essential property set kernels forms complete description 
state contained kernel resolves known conflict state resolves conflicts state kernel 
complete able generate kernels set known conflicts 
definition set variables partial assignments constraint set conflicts partial assignment resolves conflicts state resolves conflict 
partial assignment kernel resolves proper subset exists resolves 
kernels set kernel 
kernels conflict kernel kernel kernel 
generate kernels conflicts generate kernels conflict separately 
call constituent kernels 
proposition constraint set conflicts constituent kernels set kernels 
set constituent kernels conflict def ik example suppose consists conflict identified earlier 
create complete set constituent kernels conflict replacing note concept kernel similar kernel diagnosis kernel resolves known conflicts kernel diagnosis resolves conflicts 
assignment conflict alternative domain assignments likewise conflict respectively 
procedure constituent kernels follows directly proposition 
proof proposition pseudocode constituent kernels appendix constituent kernels incurs negligible computational cost worst case computational complexity order dx dx 
generate kernels constituent kernels note proposition kernel resolves set conflicts resolves conflict 
resolves contains kernels kernel set selects kernel set constituent kernels takes union 
example combine constituent kernels conflict constituent kernels conflict producing kernel 
kernel minimal exclude union superset union 
consistent kernel assign value variable eliminate union containing distinct assignments variable 
analogous candidate generation algorithm gde system soundness completeness demonstrated corollary 
kernel generation np hard number kernels worst case exponential number conflicts 
search best conflict directed tractable require cient means finding kernel contains best cost state generating kernels possible 
accomplish note process generating kernels may viewed state space search space partial kernels 
search tree example shown earlier 
iteration search partial kernel expanded resolve additional conflict terminating conflicts resolved 
partial kernel pruned proves inconsistent redundant non minimal 
function best kernels variant search 
heuristic cost function best kernels function initialize best kernels returns kernel generation problem search tree initialized 
best kernels nodes queue search tree node visited return function best kernel returns best cost kernel conflicts kernel generation problem 
loop nodes empty return failure node remove best nodes add state node visited new nodes expand conflict node new node new nodes nodes state new node state state new node visited nodes enqueue nodes new node goal test kernel applied state node succeeds best kernel state node best kernels add minimal sets best kernels best kernel best kernel best kernels return best kernel fig 

generating best kernels set conflicts search 
kernel generation problem includes set conflicts initial state 
functions goal test kernel expand conflict shown figures 
functions tree node root state theta constraint appendix min min appendix constraint defined appendix goal test node expansion functions modified discussed 
detecting kernels di erence constraint leaves tree kernel kernels full assignments 
requires modification goal test returns true soon node covers kernels conflicts resolved 
function goal test kernel node problem returns true state node resolves known conflicts 
problem state node contains kernel return true return false fig 

goal test kernels best kernel detect kernels 
expanding partial kernels expand conflict selects sets constituent kernels unresolved conflict creates child kernel constituent 
example root node shown earlier resolve conflict conflict 
expanded selecting conflict constituent kernels generate children labeled multiple possible conflicts choose expand conflict selects conflict fewest number constituent kernels 
corresponds standard constrained variable heuristic csp algorithms 
constraint mutual preferential independence allows reduce number branches tree expanded search 
di erence due conflict directed assignments associated siblings may involve distinct variables 
proposition sibling nodes parent labeled assignment ij labeled kl appear state 
min min denote best attribute costs respectively 
ij min min kl exists leaf node leaf nodes state state 
note doesn restrict value doesn restrict value identify child best state comparison performed assumption children take best cost values sibling variable 
example consider node labeled 
children assignment second child assignment preferred max max 
consider proposition incorporated function best kernel 
node expand conflicts begins identifying unresolved conflict 
conflict unresolved node conflict constituent kernels subset state 
order constituent kernels conflict function better kernel shown 
denote nth kernel ordering denote corresponding child 
follows proposition child needs expanded 
performed function expand conflict best child 
function expand conflict node problem returns best nodes expanded node 
return expand conflict best child node problem expand best sibling node problem function expand conflict best child node problem returns node child best cost extension 
constituent kernels problem state node contains kernel return return expand constituent kernel node problem function expand constituent kernel node problem returns node child containing best cost kernel conflict resolved state node 
smallest set constituent kernels problem kernel set contained state node 
ij ij ij consistent state node sort better kernel problem true child assignments node ij best kernel consistent state node return node ij node function better kernel ij kl problem returns true lower bound cost child node adds kernel ij better sibling adds kernel kl return problem ij problem kl return problem problem ij min problem problem min problem problem kl fig 

expand conflict best kernel cover known conflicts 
expand best sibling constraint shown 
min min appendix likewise tree node root state theta appendix proposition holds states child eliminated 
occurs soon expanded order resolve additional conflict conflict may eliminate states soon child node expanded best sibling expanded 
pattern node expansion repeatedly replace best cost node search queue best child best sibling 
expansion achieved functions expand conflict expand best sibling 
best kernel uses variant dynamic programming principle search avoid extending multiple paths go state 
accomplish best kernel keeps track nodes explored variable visited 
node queued check see node search state exists queue visited list 
node ignored 
substantial impact performance experiments discussed section 
summary section introduced algorithm called best kernel generates kernels set conflicts best order 
best kernel combines search traditional algorithms generating kernel diagnoses 
achieves ciency exploiting mutual preferential independence special case dynamic programming principle order restrict set nodes expanded search 
best kernel extract best state resolves known conflicts see section 
provides time space algorithm generating parsimonious descriptions best solutions 
conflict directed top level procedure conflict directed introduced demonstrated section 
section completes development conflict directed specifying candidate generation procedure state resolving conflicts 
consider case interested single best solution building function section 
case corresponds algorithm demonstrated earlier section 
generalize conflict directed finding number leading solutions 
accomplish develop hybrid version state resolving conflicts unifies constraint kernel sections respectively 
conflict directed solution function terminate ocsp returns true solution ocsp 
return true solutions ocsp non empty 
function best state resolving conflicts ocsp returns best cost state consistent conflicts ocsp 
best kernel best kernel ocsp best kernel failure return failure return kernel best state problem best kernel function kernel best state problem kernel returns best utility state kernel 
unassigned variables assigned kernel return kernel best assignment unassigned function best assignment problem variables returns maximum utility assignment variables 
variables return variables remaining variables return max problem best assignment problem remaining function max problem returns value maximum attribute utility return arg max ij problem problem ij fig 

support functions conflict directed case generating single best solution 
generate single best solution optimal csp iteration best state resolving conflicts simply extracts best kernel extends kernel best complete decision state 
best kernel extracted conflicts best kernel developed preceding section 
extract best state kernel set variables assigned best cost decision state selects unassigned variable best cost value min min arg min ij dz ij corresponds function kernel best state 
version conflict directed demonstrated detail section 
conflict directed multiple solutions function best state resolving conflicts ocsp returns best cost state consistent conflicts ocsp 
problem problem problem loop nodes ocsp empty return failure node remove best nodes ocsp add state node visited ocsp new nodes expand state resolving conflicts node ocsp new new nodes nodes ocsp state new state state new visited ocsp nodes ocsp enqueue nodes ocsp new goal test state resolves conflicts ocsp state node succeeds return node function expand state resolving conflicts node problem returns best nodes expanded node 
forall constituent kernels problem state node contains kernel variables assigned state node return return expand variable node problem return expand conflict node problem function goal test state resolves conflicts node problem returns true node complete decision state resolves known conflicts 
forall constituent kernels problem state node contains kernel variables assigned state node return true return false return false fig 

support functions conflict directed case generating multiple solutions 
combines expansion functions best kernel constraint 
terminate 
application specific supplied 
generate multiple leading solutions introduce variant resolving conflicts able enumerate best order multiple decision states kernels 
contrast preceding section best state resolving conflicts enumerate single best decision state kernel 
augmented best state resolving conflicts defined 
generates kernels similar best kernel enumerates states kernels similar constraint 
ciently focus search interleaves processes generating best kernels best states 
particular iteration selects expansion node search processes looks promising implement best state resolving conflicts uses single search queue contains nodes search types 
function expand state resolving conflicts expands node type expand conflict expand partial kernels expand variable expand kernels states 
goal test function goal test state resolves conflicts returns true search state complete assignment resolves conflicts 
application dynamic programming principle outlined section best kernel 
full conflict directed applied boolean consider trace extended version conflict directed applied boolean 
initially conflicts root node search queue 
iteration conflict directed best conflicts starts dequeuing conflicts resolved best descendants expanded similar constraint section producing nodes top left 
best state returned candidate 
conflict directed finds candidate inconsistent generating conflict 
best state resolving conflicts new conflict current search agenda 
eliminated best sibling ancestors generated 
top right front queue cost 
assuming dequeued resolve conflict best child generated selects best cost constituent kernel conflict 
note kernel adds additional failure broken cost order magnitude worse constituent kernels constituent kernels conflict constituent kernels conflict conflict fig 

search trees generated boolean extended version best state resolving conflicts 
best decision state indicated arrow 
closed open circle indicates expanded unexpanded node 
top left best cost state conflicts 
top right best cost state conflict 
bottom best cost state conflicts 
best node taken search queue cost node resolves conflict node recursively expanded best state repeatedly selecting unassigned variable assigning best cost value top right 
returned best state resolves known conflicts candidate 
conflict directed determines candidate inconsistent generating conflict 
conflict added best state resolving conflicts invoked third round 
removed best siblings ancestors generated producing best node dequeued 
resolves conflict conflict best descendants expanded bottom producing candidate 
conflict directed determines candidate consistent best diagnosis 
point conflicts discovered subsequent invocations best state resolving conflicts generates diagnoses best order visiting additional inconsistent states 
experimental results evaluated performance conflict directed applications real world space systems randomly generated problems 
measure ectiveness conflicts mutual preferential independence ran parallel tests constraint 
starting real world applications employed variants conflict directed range model diagnosis model autonomous systems including livingstone burton titan :10.1.1.1.6964
applied space systems including nasa deep space probe air force cluster nasa messenger mission nasa st concept mission simulated version cassini saturn space probe mit sphere mission 
performance earlier variant cassini scenario reported 
cassini saturn space probe scenarios cassini interesting nasa complex space craft date representative case study complex embedded system 
cassini scenario consists roughly components correspond decision variables average domain size roughly values 
constraints encoded propositional logic approximately propositional variables clauses 
results decision space size approximately state space size approximately compared performance conflict directed constraintbased conflict direction measuring total number nodes expanded largest length search queue 
performed failure recovery scenarios supplied cassini engineers 
scenarios involved selecting set component mode changes re established spacecraft configuration goals failure mode selection 
conflict directed able focus search dramatically test cases 
performance broke categories failures involved simple recoveries inertial unit accelerometer failures best recovery action involved changing mode single component 
cases conflict directed best solution node expansions maximum queue size 
recoveries moderate di culty main engine spacecraft attitude failure required recoveries changed component modes 
solved approximately node expansions maximum queue size 
complex recoveries low acceleration reading needed approximately node expansions maximum queue size 
cases computational cost terms time space usage extremely modest compared complexity search space number mode changes solution 
constraint performed considering ective size search space performance worse comparison 
note performance conflict direction sensitive variable ordering 
comparison conflict directed consider optimistic orderings 
family simplest recoveries constraint required times node expansions conflict directed increase space usage worse 
increase number expanded nodes queue size result considering nodes contribute restoring configuration goal 
recoveries moderate complexity performance constraint varied considerably consuming times space time conflict directed 
variation result large dependence order variables values searched number mode changes final solution 
recoveries greatest complexity di cult discover 
recoveries conflict direction increased number nodes expanded average factor conflict directed increased maximum queue size factor 
randomized experiments problem parameters constraint conflict directed mean cd cb ratio size decision variables constraint clauses clause length nodes expanded queue size nodes expanded queue size conflicts nodes expanded queue size table average performance constraint conflict directed problems 
turning randomized experiments verified performance improvements discussed series experiments randomly generated problems 
experiments randomized data set generated parameters characterizing optimal csp problems number state variables maximum domain size state variable number decision variables number constraints size constraint 
size variable domains constraints selected uniform distribution allowed maximum 
cost variable assignment selected similar manner 
conflict directed constraint applied sets randomly generated problems rated total number nodes expanded maximum search queue length 
results experiments shown 
data shows significant improvement performance conflict directed range problems tested 
degree improvement varied depending constrained problem di culty optimization problem 
data suggests performance benefit conflict direction increases problems constrained maximum domain size increases 
highly constrained problems conflicts tend arise fewer assignments 
allows conflict directed rule larger portions state space explored 
conflict directed performs problems lightly constrained problem contains fewer conflicts 
kernels resolve conflicts tend short discovered shallow point search 
kernel extracting best state involves little search 
note result constrained problems significant simple problems easily solved general 
summary summarize performance constraint scale systems real world complexity 
excellent performance approaches cassini example demonstrates ectiveness approach mutual preferential independence guide search 
addition substantial consistent increase performance conflict directed constraint demonstrates ectiveness conflict directed search focussing mechanism real world applications 
performance results confirmed broad set randomly generated problems 
artificial intelligence decision making problems diagnosis planning embedded systems control translated csps optimization problems involving search discrete space best solution satisfies set constraints 
opened new research frontier boundary optimization automated reasoning research 
described family problems optimal constraint satisfaction problems multi attribute decision problems decision variables set finite domain constraints 
highlighted pervasive family optimal csps mutually preferentially independent 
remainder introduced conflict directed algorithm tackling optimal csps extending search 
traditional search guarantees optimality visiting states cost better optimal feasible solution 
conflict directed able reason subsets infeasible states implicitly exploiting structure csps source conflicts 
conflict directed searches state space best order mutual preferential independence mpi construct admissible heuristic guides search space partial assignments 
search accelerated identifying sources conflict inconsistent candidate information jump related candidates search tree 
elimination process builds concepts conflict kernel generalized model diagnosis dependency directed search 
section saw approach leads order magnitude increase performance conflicts 
core conflict directed ability identify feasible region state space called kernel contains best utility state resolving known conflicts 
computational challenge exponential number kernels may exist worst case 
focus process generating kernels best kernel introducing algorithm called combines minimal set covering search 
best kernel guides search reduces node expansion exploiting mpi similar constraint 
section saw cassini randomized experiments conflict directed best kernel generates set search nodes extremely modest compared total size search space 
best kernel ers powerful algorithm candidate generation generates parsimonious descriptions solutions best order 
results time space algorithm generates useful descriptions terminated point 
focussed interrelationship search constraint satisfaction conflict directed reasoning 
just rich set computationally powerful methods developed decade solving constraint satisfaction problems 
extension methods optimal csps rich area research 
acknowledgments research leverages insights developed collaboration range researchers 
conflict directed generalizes ideas explored jointly johan de kleer assumption dependency directed backtracking focussed diagnostic search algorithms 
ideas extended jointly nayak create model reactive system livingstone demonstrated nasa ds probe 
members mit model embedded robotic systems group particularly seung chung paul elliott michael mitch ingham extensive orts generalizing demonstrating principles conflict directed 
de kleer williams diagnosing multiple faults artificial intelligence 
de kleer mackworth reiter characterizing diagnoses systems artificial intelligence 
stallman sussman forward reasoning dependency directed backtracking system computer aided circuit analysis artificial intelligence 
gaschnig performance measurement analysis certain search algorithms tech 
rep cmu cs university pittsburgh pa 
de kleer williams back backtracking controlling atms proceedings aaai pp 

ginsberg dynamic backtracking journal artificial intelligence research :10.1.1.27.4126
de kleer williams diagnosis behavioral modes proc ijcai pp 

williams nayak model approach reactive self configuring systems proc aaai pp :10.1.1.1.6964

williams nayak reactive planner model executive proceedings ijcai 
ingham williams reactive model programming language robotic space explorers proceedings 
genesereth design descriptions automated diagnosis artificial intelligence 
davis diagnostic reasoning structure behavior artificial intelligence 
blum furst fast planning planning graph analysis artificial intelligence 
selman levesque mitchell new method solving hard satisfiability problems proceedings aaai pp 

sussman computational model skill acquisition north holland 
minton johnston philips laird minimizing conflicts heuristic repair method constraint satisfaction scheduling problems artificial intelligence 
reiter theory diagnosis principles artificial intelligence 
struss dressler physical negation integrating fault models general diagnostic engine proc ijcai pp 

hamscher console de kleer readings model diagnosis morgan kaufmann san mateo ca 
de kleer brown qualitative physics artificial intelligence 
forbus qualitative process theory artificial intelligence 
prosser hybrid algorithms constraint satisfaction problem computational intelligence 
gent walsh understanding hill climbing procedures sat proceedings aaai pp 

selman kautz cohen noise strategies improving local search proceedings aaai pp 

de kleer williams focusing diagnosis engine proceedings dx 
dressler farquhar focusing atms problem solvers tech 
rep report inf arm siemens 
hart nilsson raphael formal basis heuristic determination minimum cost paths ieee transactions systems science cybernetics ssc 
muscettola nayak pell williams new millennium remote agent boldly go ai system gone artificial intelligence 
chung williams improving model mode estimation ine compilation proceedings 
williams chung gupta mode estimation model programs monitoring systems complex behavior proceedings ijcai 
williams activity analysis simplifying optimal design problems qualitative partitioning engineering optimization 
williams millar decompositional model learning analogy model diagnosis proceedings aaai pp 

dechter pearl generalized best search strategies optimality journal association computing machinery 
williams doing time putting qualitative reasoning ground proceedings aaai 
davis logemann loveland machine program theorem proving communications acm 
williams ingham chung elliott model programming intelligent embedded systems robotic explorers appear ieee proceedings special issue embedded software nayak williams fast context switching real time propositional reasoning proceedings aaai pp 

mc valued truth maintenance system tech 
rep thesis dept eecs mit 
doyle truth maintenance system artificial intelligence 
forbus de kleer building problem solvers mit press 
de kleer assumption tms artificial intelligence 
conflict directed requirements implementation conflict directed csp loop defined requirements requirement ocsp csp optimal constraint satisfaction problem decision state ocsp set known conflicts ocsp consistent 
consistent csp true consistent 
extract state conflicts extract state conflicts csp 
empty consistent state conflict eliminate redundant conflicts eliminate redundant conflicts set conflicts 
states states 
best state resolving conflicts best state ocsp 
state exists resolves conflicts solutions 
decision state solutions resolves conflicts state exists resolves 
require consistent 
able determine inconsistency consistency 
inconsistency typically systematic search procedure performs limited inference back track search forward checking dpll propositional satisfiability procedure 
local search methods min conflict gsat cient determining consistency determine inconsistency 
note extract state conflict need return complete set conflicts conflicts required minimal impact correctness algorithm 
course complete set minimal conflicts rules largest set inconsistent states 
traded computational cost extracting conflicts generating complete set minimal conflicts np hard 
extract state conflict return conflict called decision state inconsistent 
performed ciently may returned conflict example conflict extracted ciently 
common way extract conflict mentioned section local constraint propagation 
assignments propagated local inference rule unit propagation maintaining dependency trace deductions performed 
inconsistency derived dependency trace examined extract subset derive inconsistency 
example shows dependency traces generating conflicts respectively 
dependencies show detect symptom implementation discussed uses propositional clauses constraints 
consistent 
implemented variant dpll satisfiability procedure uses boolean constraint propagation bcp perform unit propagation incrementally 
bcp maintains dependencies propagation 
extract state conflict uses dependencies quickly extract single conflict inconsistency 
range alternatives possible 
example prime implicant algorithm atms identify subsets csp constraints entail false 
algorithms exponential worst case 
open question benefit discovering additional conflicts weight added computational cost 
function eliminate redundant conflicts eliminates conflicts redundant sense removal doesn alter set states manifest conflicts 
note exist unique subset irredundant 
note identifying irredundant set conflicts common task studied circuit synthesis literature tractable general case 
conflicts need eliminate redundant conflicts existence redundant conflicts alter solution solution time 
open empirical question redundant con speed slow process 
case including conflict strict superset conflict ers computational benefit implementation eliminate redundant conflicts simply eliminates superset conflicts 
search trees optimal csps functions constructing examining search tree csp called assignment tree introduced section 
functions constraint best kernel state resolving conflicts conflict directed 
function tree node assignment parent return assignment parent function root node returns true node root search tree 
assignment node return true return false function state node returns partial assignments path root node 
root node return return assignment node state parent node function theta problem returns initial state search empty assignment 
return heuristic cost optimal csp function definitions cost heuristic cost optimal csp 
functions constraint kernel best state resolving conflicts 
function problem node returns cost node state 
root node return problem assignment node return problem problem parent node function problem node returns best cost complete node state 
unassigned variables assigned state node return min problem unassigned function min problem variables returns minimum cost assignments variables 
variables return problem variables remaining variables return problem min problem min problem remaining function min problem returns minimum attribute cost return min ij problem problem ij constituent kernels procedure generating constituent kernels set conflicts provided directly follows proposition 
worst case computational cost negligible order dx dx 
functions best kernel resolving conflicts 
function constituent kernels returns set elements sets kernels conflict 
constituent kernels ij ik ik ik ij constituent kernels add minimal sets constituent kernels return constituent kernels function add minimal sets set returns adds set removes element superset element 
set return set set remove set return set 
