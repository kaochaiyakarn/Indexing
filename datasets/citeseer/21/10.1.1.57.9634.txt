journal automated reasoning 
kluwer academic publishers 
printed netherlands 
type system java bytecode language verifier stephen freund john mitchell williams college stanford university 
java virtual machine executes bytecode programs may sent possibly untrusted locations network 
transmitted code may written malicious party corrupted network transmission java virtual machine contains bytecode verifier check code type errors run 
illustrated reported attacks java run time systems verifier essential system security 
formal specification bytecode verifier exists java virtual machine specification published sun 
develop specification form type system subset bytecode language 
subset includes classes interfaces constructors methods exceptions bytecode subroutines 
type checking algorithm prototype bytecode verifier implementation conclude discussing applications 
example show extend formal system check program properties correct object locks 
key words java virtual machine bytecode verification type systems 

java bytecode language refer jvml platform independent representation compiled java programs 
order prevent applets improperly structured code causing security problems java virtual machine bytecode verifier performs number consistency checks bytecode executed 
consistency checks reject code may cause type error executed preventing bytecode programs exploiting type errors circumvent java security architecture 
published attacks various implementations java virtual machine illustrate importance bytecode verifier system security 
cite specific example bug early version sun bytecode verifier allowed applets create certain system objects able create 
problem caused error constructors verified resulted ability potentially compromise security entire system 
previous study identified error sun verifier allowed jvml code object properly initialized :10.1.1.52.8631
number loopholes inconsistencies stephen freund john mitchell reported see example 
problems demonstrate need correct formal specification bytecode verifier 
started existing specification informal english description incomplete incorrect respects 
primary contribution sound type system large fragment jvml 
study subset jvml captures difficult static analysis problems bytecode verification brings light subtle interactions features previously examined isolation 
particular focus jvml features classes interfaces objects constructors object initialization virtual interface method invocation arrays exceptions subroutines integer float primitive types 
earlier study examined object initialization formalized way type system may prevent java bytecode programs objects initialized :10.1.1.52.8631
extend formal system handle bytecode subroutines rest features listed 
subroutines form local call return allow space efficient compilation try structures java language 
bytecode programs subroutines allowed manipulate return addresses certain ways bytecode verifier ensure return addresses appropriately 
addition subroutines introduce limited form polymorphism type system 
treatment subroutines semantics developed stata abadi modifications closer original sun specification include exception handlers 
cover major features jvml omit pieces additional primitive types control structures final static modifiers access levels class initialization concurrency packages 
omitted features contribute complexity system sheer number cases introduce introduce challenging new problems 
example excluded primitive types operations similar cases study missing control structures instruction 
static methods share common normal methods checks proper final access modifiers understood straightforward include 
type checking algorithm type system describe experiences prototype verifier algorithm 
core algorithm employs dataflow analysis construct valid types jvml programs 
unfortunately subroutines complicate matters introducing polymorphism making control flow graph construction difficult 
divide algorithm type system java bytecode language phases compute control flow graph identify uses polymorphism synthesize type information dataflow analysis 
type system checker applications bytecode verification 
example extend system check additional safety properties ensuring object locks acquired released properly method 
augment verifier track information type system determine run time checks pointer array bounds tests may eliminated 
proceeding summarize notational conventions 
function update written dom 
related operation changes way dom 
sequences model stacks lists values types 
empty sequence andv places front sequence appending sequence written substitution replaces occurrences 
jvmlf section informally introduce jvmlf idealized subset jvml encompassing features listed 
java compiler translates source program collection class files declared class interface 
addition containing bytecode instructions methods class file contains symbolic name type information class interface method field mentioned source code 
java virtual machine uses information verify code resolve 
binary format class files easy read manipulate shall represent contents manageable form closer declarations original source program 
illustrate compilation process class file representation showing java program translation jvmlf declarations respectively 
define jvmlf precisely 
collection declarations contains object throwable java library classes referenced classes 
assume library classes jvmlf programs 
jvmlf declaration class contains set instance fields objects class interfaces declared implemented class methods declared class 
method consists array instructions stephen freund john mitchell interface foo int foo int class extends object implements foo int num int num int foo int aa try new catch throwable num return 
declaration java classes 
class extends array int super num foo list exception handlers methods superclass class copied subclass overridden 
copying methods subclasses simplifies bookkeeping method lookup formal semantics impact verifier requirements specification 
special name init constructors 
execution environment jvmlf programs consists stack activation records heap 
activation record contains program counter local operand stack set local variables 
pieces information shared different activation records different activation records may contain objects heap 
jvmlf bytecode instructions operate operand stack store load instructions store load intermediate values local variables 
constructing deleting activation records method invocation return left java virtual machine 
contains full jvmlf instruction set paragraphs briefly describe interesting aspects instructions 
integer real number special value null local variable instruction address class name valid array component type respectively 
refer reader java virtual machine specification detailed discussion bytecode instructions 
bytecode programs method interface method field identify methods interface methods fields java language programs 
contain pieces information method field describe type system java bytecode language class object super fields interfaces methods class throwable super object fields interfaces methods interface foo interfaces methods foo foo int int class super object fields num int interfaces foo methods init int void load invokespecial object init void load load putfield num int return foo int int new store load load invokespecial init int void goto pop load push putfield num int push exception table target type throwable class super fields num int array array interfaces foo methods init int void load load invokespecial init int void load load push invokevirtual foo int int putfield num int return foo int int superclass 
translation code jvmlf stephen freund john mitchell instruction push pop store load add ifeq goto new invokevirtual method ref invokeinterface interface method ref invokespecial method ref getfield field ref putfield field ref newarray throw jsr ret return 
jvmlf instruction set 
class interface declared field method name type 
example bytecode instruction putfield num int refers num instance field type int declared class contrast simple names contain information 
check uses methods fields loading class belong 
dynamically link class files safely 
provide unique symbolic names overloaded methods fields overloading resolved compile time java 
grammar generates method ref class name label method type interface method ref interface name label method type field ref class name label field type field type may int float class interface name array type 
method type type possibly empty sequence field types return type function void 
shows grammar generate types plus additional types type constructors static semantics jvmlf program 
example type top supertype types typing rules mentioned jvmlf program 
may raise exceptions objects ways 
program may throw instruction raise exception 
throw instruction requires top stack contain object class throwable subclass 
jvmlf instructions generate exceptions arguments valid 
example instruction performs operation object generate run time exception applied null 
cases virtual machine creates new type system java bytecode language type ref prim ret top prim float int ref simple ref uninit array null simple ref class name interface name component simple ref prim array array array component uninit uninit class name ret ret type list type type list method type arg list return return simple ref array prim void field type simple ref array prim arg list field type arg list class name interface name 
jvmlf types 
throwable object exception 
real implementations create objects different classes indicate different kinds run time errors jvmlf execution model generates throwable objects cases 
generating single kind exception simplifies jvmlf dynamic semantics fundamentally change program behavior language expressiveness 
program raises exception virtual machine searches appropriate handler list handlers associated currently executing method 
appropriate handler declared protect current instruction handle exceptions class object thrown superclass 
virtual machine finds appropriate handler execution jumps instruction exception handler code 
virtual machine pops top activation record repeats process new topmost activation record 

dynamic semantics section gives overview formal execution model jvmlf programs 
section describes representation programs environments section shows machine states modeled section describes semantics bytecode instructions 

environments jvmlf semantics semantic frameworks models declarations program environment 
shown jvmlf environment stephen freund john mitchell class name method ref interface name super class name interfaces set interface name fields set field ref code instruction handlers handler interfaces set interface name methods set interface method ref 
format jvmlf program environment 
partial map class names interface names method ref respective definitions 
access information method declared write 
similar notation access interface class declarations 
method ref range addresses set addr andp ith instruction exception handler array partial map integer indexes exception handlers 
exception handler catches exceptions type occur program counter range 
control transfers address exception caught handler 
notation indicate dynamic static semantic rules determine properties program looking information environment 
example inference rules conclude type subtype examine declarations environment determine program class hierarchy 
write subtyping judgment indicate subtype specific environment 
subtyping rules match rules model subtyping java language extensions cover jvmlf specific types :10.1.1.35.622
jvmlf dynamic semantics uses subtyping judgment model run time type tests 
summarizes subtyping judgment form major judgments 

machine state jvmlf virtual machine execution state configuration stack activation records memory heap 
activation record stack defined follows exc pc type system java bytecode language refl class name super interfaces class null simple ref array null null array array array object super super prim prim interface top ref prim ret top top map dom dom dom 

jvmlf subtyping rules 
array array refl interface name ref class int interfaces array array ref refl uninit prim ret seq interface name object part activation record pc meaning ref method 
pc address instruction executed method code array 
map var set local variables values 
operand stack 
initialization information object initialized constructor described 
records form exc exception handling 
program throws exception virtual machine places activation record form exc stack throwable object 
stephen freund john mitchell subtype 
program configuration evaluates single step 
wt formed 
ty definition refers names classes interfaces defined 
declaration valid class interface method 
method body conforms method ref ands 
instruction typed ands 
handles handler typed ands 
wt typed heap 
value type environment heap wt configuration typed environment 

summary main jvmlf logical judgments 
heap contains objects arrays allocated program model heap function mapping locations records 
records objects arrays different forms records contain tags support run time type tests method dispatch 
objects class form ln vn object fields indexed field ref abbreviate type record li vi subscript refers ith field record 
arrays stored similar type record vi array definitions program heap partial map locations drawn set loc records loc li vi li vi uninit vi array object uninit 
object array middle form uninitialized objects described section 
shall notation access value field instance location heap create new heap modified value field notation 
function tag returns tag heap record run time value int integer float tag null null loc type system java bytecode language semantics blank function create new records 
function defined separately kinds records blank li zero blank uninit li zero uninit blank array vi zero array fields li function computes default values type int zero float null ref 

operational semantics model behavior jvmlf instructions transitions machine states standard framework operational semantics 
semantic rules capture possible behaviors jvmlf programs rules figures 
row tables describes conditions program represented move configuration configuration 
column indicates instruction form captured rule 
instruction executed matches form conditions second column satisfied step may configuration matching pattern third column configuration matching pattern column 
example contains rule getfield instruction pops object stack pushes value stored specified field object 
rule indicates program represented may move configuration single step pc getfield match patterns table 
rule apply function argument implicit requirement dom 
describe representative rules tables 
rule verifies array valid index bounds type value stored subtype type elements stored array 
check required potential type loophole caused covariant subtyping arrays 
rule invokevirtual uses run time tag receiver construct method ref new activation record method called 
notation vn vn abbreviation vn 
function maps local variables arbitrary values 
contrast java virtual machine specification receiver arguments left stephen freund john mitchell pc cond push pc pc pop pc pc add tag tag pc pc load pc pc store pc pc ifeq pc pc ifeq pc goto pc getfield tag pc pc putfield tag tag pc pc pc newarray dom pc blank array vn array pc pc vn array pc pc vk vn array tag pc pc vk vk vn array jsr pc pc ret pc pc new dom pc blank uninit pc object init void tag uninit pc invokespecial pc null dom blank super object object init void pc invokespecial tag object uninit object pc blank object dom 
operational semantics part 
type system java bytecode language pc cond invokevirtual tag pc pc invokeinterface tag pc pc object invokespecial tag uninit init void dom null pc pc blank uninit super init pc return void pc pc init return pc void init pc void pc pc init void pc return null pc null pc init void return null pc null pc pc throw tag throwable pc exc pc cond tag exc pc exc pc tag pc exc pc exc 
operational semantics part 
stephen freund john mitchell pc cond null exc pc getfield pc dom blank throwable null exc pc putfield pc dom blank throwable exc pc newarray pc dom blank throwable null exc pc pc dom blank throwable null exc pc pc dom blank throwable vn array exc pc pc dom blank throwable null pc dom exc pc blank throwable vn array tag pc dom exc pc blank throwable vn array pc dom exc pc blank throwable invokevirtual null dom exc pc pc blank throwable invokeinterface null dom exc pc pc blank throwable invokespecial null dom exc pc pc blank throwable null exc pc throw pc dom blank throwable 
operational semantics part 
type system java bytecode language ch dom 
pc pc ch pc dom 
pc pc gh pc pc 
judgments identify exception handler exception 
caller stack method invocation simplify aspects formal development 
throw instruction raises exception throwable argument top stack pushing new activation record containing 
second table shows exceptions handled 
valid handler topmost activation record control transferred target handler 
topmost activation record popped stack try activation record 
defines rules determine appropriate handler exception exists 
contains rules generate exceptions run time tests virtual machine fail getfield passed null pointer array accessed bounds 
rules create new throwable object calling constructor enables treat process generating exception run time error atomic operation 
real java virtual machines call constructor exception object deviation allows model instructions small step operational semantics easily impact static semantics way 

object initialization jvmlf new instruction defined allocates memory new class instance initialize object 
object considered initialized successfully completing constructor invocation new object 
constructor invoke constructor class superclass object initialized exiting object way 
requirement satisfied constructors ensures constructor class inheritance chain called stephen freund john mitchell order new object class object object initialization 
program calls constructor invokespecial instruction 
capture rules initialization jvmlf semantics allow program 
object properly initialized 
invoke constructor initialized object 
invoke constructor wrong class object 
return constructor invoking constructor appropriate class object initialized 
simplicity treatment object initialization differs java virtual machine specification ways 
permit assignments instance fields prior superclass constructor invocation 
second semantic rules resolve constructors named method ref way method invocations implied specification 
identify prevent illegal operations listed jvmlf virtual machine stores initialization status object tag 
initialized object class tag may operand instruction expecting initialized object type 
uninitialized object tags form uninit objects tags form valid operands instructions 
shall see format tags easy map dynamic values statically computed type information program 
explain intuition uninitialized object tags relate back operational semantics rules 
new instruction executed tag newly allocated object uninit pc program counter currently executing method 
part tag indicates object originally allocated new instruction 
second half uninit pc indicates program allocated object line pc method call constructor class object 
store specific value pc soundness proof alias tracking uninitialized objects static semantics 
inside constructor class object initialized tag form uninit 
situation step properly initializing object invoke constructor constructor super class operation object defined 
invoking constructor changes tag receiving object reflect operations allowed performed object 
example constructor type called object tag uninit pc thetag uninit 
constructor super class invoked object tag uninit 
invoking object constructor object changes tag constructors may exit object initialized initialized object tag 
type system java bytecode language simplify soundness proofs model object initialization different way demonstrated rules new invokespecial 
order avoid changing tags existing objects constructors complicates proving key monotonicity properties jvmlf heaps create new objects constructor call sites 
specifically calling constructor creates new object new tag returning constructor performs substitution initialized object old uninitialized object caller activation record 
component activation records tracks substitutions 
activation record normal method 
tuple object passed constructor argument properly initialized object take place null initialized superclass constructor 
substitutions similar semantics able leverage proof development little change :10.1.1.52.8631
accuracy model acceptable operations performed intermediate objects standard execution behavior considered optimization semantics 

subroutines bytecode subroutines form local call return provide space efficient compilation try statements java programs 
subroutines code block duplicated exit corresponding try block 
subroutines easy model dynamic semantics rules appear 
difficult analyze static semantics 

static semantics static semantics determine jvmlf program assigned valid type 
program assigned type cause type error executed 
static semantics form core bytecode verifier jvmlf programs 
static semantics place key requirements program modeled environment declarations consistent method body cause type error executed 
describe requirement section 

formed environments formed environments environments satisfying certain constraints including requirements class hierarchy contains cycles stephen freund john mitchell wt env object throwable dom dom 
ty dom 
class interface method 
wt wt meth method wt obj object object class wt throwable throwable object throwable class wt class lj cycles interfaces inherit interfaces fields lj inherit fields fields class ancestor 
methods implement interfaces dom dom 
init inherit override methods dom class wt int mj cycles mj init constructors 
methods mj include methods interface 
rules formed environments 
class implements declared interfaces defining methods listed class inherits field interface declarations superclass inherits overrides methods 
basically environment formed declarations conform properties described sun java virtual machine specification depend bodies methods 
contains inference rule wt env shows jvmlf environment formed 
rule requires object throwable declarations refer classes interfaces defined environment see declaration formed 
statement declaration formed written kind declaration 
presents rules conclude declaration formed interface class method 
wt meth map addr functions type system java bytecode language ty obj object ty ty class lj ok ok lj ok ty ty int mj ok mj ok ty ok base int float ok ok array ok array ok ok ok ok ok ok class dom ok ok ok ok int dom ok ok seq ok ok ok ok ok ok ok void ok ty meth ok ty ok ok ok ok void ok 
rules ensure declarations refer defined types 
mapping local variables types type local variable line function map addr stack types si type operand stack location program 
finding analogous verifier accepting code method shows valid type information method section develops judgment 
rules environments partially syme drossopoulou eisenbach show build formed environment incrementally 
incremental construction necessary handle dynamic class loading java virtual machine problem studied 
building environment complete program straightforward assume environment built way adequate describe type check bytecode methods 

methods contains typing rule check body method 
judgment means environment type information stephen freund john mitchell si fi fi fi new int top store uninit int top load int uninit load invokespecial uninit int uninit init int void int uninit int uninit goto int pop throwable int top load int top push int top putfield num int int int top push int top exception table int int top target type throwable 
type information method foo int int 
meth code init ftop dom 
instructions typed dom 
handles handlers typed dom 
labeled labeling exists instructions dom 
labeled handlers cstr code ftop uninit false dom 
dom 
handles dom 
labeled dom 
labeled dom 
constructs paths call superclass constructor dom 
constructs including exception paths init 
rules typed methods constructors 
executing instruction array handlers cause type error consistent method type expressed method ref rule top maps variables var top 
matches types values stored creation new activation record call method 
type system java bytecode language fourth line requires instruction program typed local judgments described section fifth line requires handler typed 
rules identify dead code require valid type information line including lines calls subroutines return 
final lines ensure subroutines method structured 
elaborate judgments regarding object initialization cstr code 

instructions figures instruction typing rules 
typing rules describe set constraints types variables stack slots different locations program 
horizontal lines judgments break constraints logical groups 
format follows instruction form constraints line constraints successor basic intuition rules type information flows execution paths 
types variables stack locations touched instruction change type information successor instructions types untouched locations general successor instructions 
example consider rule concludes conditions listed box satisfied 
requirements formed environments know long object top stack subclass object record 

object initialization static semantics guarantee typed program uses object initialized 
uninitialized objects may stored local variables duplicated stack allocation initialization simple form alias analysis track uninitialized object 
type variable stack slot containing uninitialized object type form uninit pc represents uninitialized object class allocated line pc method 
uninitialized object type assumed aliases initialized types object changed initialized object type 
analysis sound uninitialized object type assigned different objects program execution 
stephen freund john mitchell push push values type prim null si si dom ifeq simple ref prim array si si dom sl dom load load dom si si dom get field getfield si fields si dom goto goto si sl dom 
instruction typing rules part 
pop pop si si dom add add prim si si dom store store dom si si dom put field putfield si fields si dom throw throw si throwable constraints new eliminate possibility removing old occurrences type uninit type information successor instructions 
requirement similar requirements jsr ret phrased differ type system java bytecode language new array newarray si int array si dom array load si int array si dom inv virt invokevirtual init si dom void si void si dom return return void 
instruction typing rules part 
array len si array int si dom array store si int array si dom inv int invokeinterface si methods void si void si dom return val void si previous 
earlier formulation matches sun verifier specification asserted uninit occur type information new instruction checked 
restriction leads monotonicity problem dataflow algorithm derived rules describe section 
new versions avoid problem checks similar frameworks 
constructor bodies require additional checks ensure apply different constructor class constructor parent class object initialized passed constructor local variable exit 
deviation requirement constructors superclass constructors need call constructor 
stephen freund john mitchell inv spec invokespecial init void dom si uninit super uninit si uninit dom jsr jsr top ret fi top ret si dom dom ret sl dom 
dom dom dom dom dom 
dom new new dom top uninit si uninit si top uninit fi dom 
instruction typing rules part 
inv spec invokespecial init void dom si uninit uninit si uninit fi dom ret ret dom ret fi si gp 
jsr sp var 
treatment constructors uses additional uninitialized object types add type system special types form uninit assigned uninitialized objects passed constructors variant inv spec check usage types set rules examine structure constructor determine paths code call appropriate superclass constructor 
structural rules label line constructor body true superclass constructor called paths line false 
contains rules shows type superclass constructor information zi constructor 
rule matches type system java bytecode language cstr label inv spec invokespecial init void si uninit zi false zi true constructs cstr label inv spec invokespecial init void 
si uninit zi zi constructs cstr label goto goto zl zi constructs cstr label return return zi true constructs cstr label jsr jsr zl zi zi constructs cstr label rest invokespecial ifeq goto jsr ret throw return zi zi constructs cstr label handler 
zi zt constructs cstr label ifeq ifeq zl zi zi constructs 
structural rules determine initialization status constructor 
cstr label ret throw ret throw constructs zi si fi fi load false uninit int load invokespecial false uninit uninit int init int void false int uninit uninit int load true int load true int push invokevirtual true int foo int int true int int putfield num int true int int return true int 
type information constructor init int void 
stephen freund john mitchell valid call superclass constructor rest simply preserve initialization status object constructed 
instructions guarded handler agree target initialization status exception handler may guard call superclass constructor 

subroutines checking programs subroutines difficult reasons 
subroutine calls returns occur stack manner 
cases subroutine return exception branch instruction may cause jump return address called subroutine caller 

specific form local variable polymorphism introduced subroutines correctly 
local variables touched subroutine may contain values conflicting types different calls subroutine 
types variables preserved subroutine call may subroutine exits 
mechanism checking subroutines uses information subroutine call graph particular set valid subroutine call stacks instruction call stack sequence return addresses representing stack subroutines called method returned 
capture set possible call stacks line gi examining structure code array exception handlers 
presents rules specify shows sample jvmlf program subroutines labeling type information 
dominator set dp set subroutines dominate path instruction range 
set defined equations dp dp def gi 

jsr def 
dp 
essence labeling rules ensure instructions considered part subroutine associated set subroutine call stacks 
rule jsr rules cycles subroutine call graph 
subroutines may implicitly popped subroutine call stack exception causes jump handler located outside currently executing subroutine 
able type check situations labeling rules require target exception handler belong subroutine dominating instruction protected handler 
valid labeling may exist method body simplify static semantics shall refer canonical labeling method body gp define gp labeling conforms rules contains extra call stacks 
words extraneous subroutine call stacks incorporated gp subroutine assume type system java bytecode language lab jsr jsr gi 

jsr gi gl gi gi labeled lab ret throw ret return throw labeled lab handler gt labeled 
jvmlf labeling rules 
lab ifeq ifeq gl gi gi labeled lab goto goto gl gi labeled lab normal jsr ifeq goto ret return throw gi gi labeled lab handler gt gl dp labeled gp si fi fi fi jsr top top top return top top top store ret top top top jsr ret top top jsr ret top top ret ret top top store ret top top jsr ret top ret ret top store ret top ret ret 
type information computed method subroutines 
labeling rules exception handlers match called dominator gp assumption prevents small set programs valid labels assigned canonical labeling encountered programs practice 
typing rules subroutine call return appear 
rules domains local variable maps restricted inside subroutines type ret assigned return address generated instruction 
types local variables current instruction polymorphic depends execution history 
auxiliary function defined recovers types pc local variable assigned type line pc program subroutine call stack implicit execution history 
addition hiding function equals top return address type inconsistent return addresses 
type stephen freund john mitchell tt dom pc pc pc ht ret ht jsr tt dom pc pc ht 
jsr ret top ret ret ht ht seq 
auxiliary rules jsr ret 
ht return address appearing type return address type 
prohibit uninitialized object types propagating type information successors jsr ret instructions prevent error original sun verifier :10.1.1.52.8631
compute type information successor instructions stack local variable type information uninitialized object types line converted top 
forany type function defined follows uninit top uninit 
extend definition cover sequence map types obvious way 
discuss typing rules exception handlers section 
soundness rules depends invariants showing implicit subroutine call stack contained sets statically computed call stacks return address type ret assigned valid return address implicit call stack 
labeling strategy labeling technique stata abadi offers improvements system 
stata abadi labeled instruction linearization subroutine calling sequences leading linearization contains little information check multilevel returns exceptions handlers 
type system java bytecode language 
limitations labeling rules limitation labeling technique treatment branch jump statements goto 
instructions may implicitly pop subroutines subroutine call stack executed 
demonstrates program 
goto line implicitly leaves subroutine starting line 
assign valid labeling program labeling rules require goto instruction target belong subroutine 
compilation break statements clauses cause similar situations 
partially address limitation relax labeling rule instruction require target belong subroutine dominating goto instruction labeling rule exception handler targets 
approach lead complex typing rules branch instructions fully explored implications rules checking algorithm 
void int true try 
continue 
push store set 
code try block jsr jump subroutine goto goto top loop store store exception value jsr jump subroutine load load exception value throw re throw exception store store return address load load push push ifeq branch 
ret return subroutine goto jump subroutine goto exception table target type throwable 
java program translation jvml rejected type system 
stephen freund john mitchell approaches bytecode verification handle programs effectively 
forego labeling favor analysis techniques enforce stringent structure code subroutines 
discuss detail section 

exception handler typing rules exception handlers place additional typing requirements exception handler typed valid interval dom andt dom subclass throwable st valid type stack containing single object assigns types local variables general types local variables program points protected handler 
show typing rules capture requirements 
judgment verifies domain local variable map instruction handler jumps rest subroutine 
judgment verifies local variable types target particular subroutine call stack 
employs checks similar rule ret process catching exception may change implicit subroutine call stack way similar multilevel return 
wt handler throwable dom 
gp st handles gt gp dom var gt gp jsr dom dom exc jump gp var 

exception handler typing rules 
type system java bytecode language 
soundness machine model program attempts perform operation causing type error gets stuck operations defined 
proving typed programs get stuck know typed programs attempt perform illegal operations executed 
rest section gives high level overview formal statement proof soundness property 
rules map run time values types 
start rules primitive values lead rule types entire heap typed record heap typed 
function converts tag type erasing extra information kept tag uninitialized objects 
uninit uninit kind tag 
execution steps preserve invariants relating run time state static type information step maintains typed heap 
theorem jvmlf step soundness 
wt wt wt const values type prim null addr addr obj li vi fields li tag vi array vi array tag vi array subsumption ret uninit obj li vi uninit fields li tag vi uninit val wt heap dom 
tag 
typing rules values 
wt seq val stephen freund john mitchell gs gs meth init pc pc invokevirtual pc pc gs cstr init void pc pc invokespecial 
pc pc corresponds pc spc uninit pc pc def pc dom spc var 

pc consistentinit pc spc pc 

gs void init 
pc pc gs int init pc pc invokeinterface pc pc gs exc tag throwable exc judgment defined requires state machine consistent static type information program 
rule possible stack configurations 
stack may empty exactly activation record activation record top created invokevirtual invokeinterface instruction exception activation record top 
rules convenient assume canonical method return record containing code array exception handlers canonical type information method type system java bytecode language basic format rule 
preceding activation record top rules ensure proper relationship activation record topmost met 
example topmost activation record created virtual method invocation rule gs meth ensures method called create properly dispatched 
addition invariant satisfied activation record stack 
conjuncts meaning pc dom program counter code array method 
spc stack values expected types current line execution 
var 

pc local variables contain values expected types current line execution subroutine call history captured 
consistentinit pc spc invariants ensuring correctness alias analysis tracking uninitialized object satisfied current state machine 
judgment defined shows uninitialized object type maps unique run time value 
cons init uninit corresponds si uninit consistentinit si corr dom 
uninit uninit stackcorresponds si uninit corresponds si uninit sc stackcorresponds uninit sc uninit stackcorresponds si uninit stackcorresponds uninit si uninit sc uninit stackcorresponds si uninit stackcorresponds si uninit 
invariants object initialization 
stephen freund john mitchell ret corr var 
pc ret jsr spc pc rsc rsc ret si si wf dom pc var gp pc pc rsc jsr si ret si wf gp pc jsr gp pc gp dom pc dom pc var dom pc 

pc uninit pc 
subroutine call stack invariants 
pc subroutine return address stack consistent program state type information 
predicate defined follows pc def pc pc pc inference rules statements appear 
judgment pc derivable return addresses stored local variables stack correspond return addresses appearing 
judgment ensures local variable map domain set possible subroutine call stacks constant duration subroutine call 
rule enforces requirement uninitialized object types appear local variables visible current subroutine 
constructors require additional execution invariant track object constructed initialized form stored recall constructors type system java bytecode language zp pc false tag uninit tag uninit pc null 
constructor invariants 
zp pc true tag uninit tag uninit tag pc create new objects preserve heap monotonicity property 
judgment captures information meth cstr rule 
prove theorem case analysis operational semantics rule execution step 
proof leverages soundness proofs jvml adding heaps object arrays exceptions introduces additional cases :10.1.1.52.8631
sketch proof store motivate structure invariants refer reader freund thesis thorough treatment 
shall explore key properties execution store 
show execution astore instruction virtual machine configuration wt yields new typed heap 
general prove statement instruction noting heap updates respect properties types records change values written heap records types overwritten values new records introduced allocation typed records 
instruction changes heap heap rules welltyped heap 
store trivial show modified 
related property guaranteed instructions derivable derivable shown induction derivation 
observation important proving second key property instruction execution 
second property executing store instruction preserves invariants listed 
suppose store instruction moves virtual machine configuration pc pc suppose method body comprise type information show pc showing pc holds pc hold 
consider conjunct pc separately pc dom pc derived rule store 
requirement rule pc dom 
stephen freund john mitchell spc requirement rule store know spc spc spc conclude spc subsumption 
spc 
var 
pc variable interest static semantics store require dom fpc dom fpc 
know dom pc dom pc pc subtype pc map subtype map domain 
pc fpc pick spc spc required rule store 
spc know 
instruction executes rule store fpc 
fpc subsumption 
consistentinit pc spc ifv originally assigned uninitialized object type top stack fpc uninitialized object type may show consistentinit pc spc assumption consistentinit pc spc 
hand suppose uninitialized object assigned type uninit assigned type uninit show occurrences uninit pc spc map previously stack consistentinit pc spc guarantee occurrences uninit spc fpc correspond run time value may show property post state 
correspondences uninitialized object types unique run time values held hold store instruction executes 
pc structural labeling rules gpc gpc know dom fpc dom fpc 
facts sufficient prove pc 
statement pc trivial prove pc fpc fpc 
proving ret corresponds pc similar proving alias analysis object initialization works correctly 
essence value originally return address type type ret inthe case occurrences ret static type information pc match occurrences pc 
inference rules know correspondence holds type information pc andf shown executing store instruction preserves invariants routine show preserved 
general proof outline may show instructions affecting type system java bytecode language topmost activation record preserve invariant 
remain instructions invokevirtual throw change activation record design jvmlf semantics ensure invariants preserved 
example initial state newly created activation record matches initial conditions method type information specified rule meth code rules ensure values appropriate type returned caller method 
state multistep soundness progress theorems jvmlf theorem jvmlf multistep soundness 
wt wt wt proof induction number steps taken virtual machine routine theorem established 
theorem jvmlf progress 
wt wt prove theorem showing wt hypotheses rule operational semantics satisfied 
state main soundness theorem jvmlf java virtual machine execution begins invoking static method main class 
included static methods jvmlf programs start different way 
program begins executing method takes arguments returns value object fields 
addition object object heap 
theorem states program begins way halt activation record stack empty 
theorem jvmlf soundness 
wt void fields loc dom stephen freund john mitchell proof direct application theorem theorem 
verifier algorithm java virtual machine check major properties captured static semantics program environment formed code method body typed 
property extensively studied especially presence dynamic class loading name resolution see example 
mechanisms merged framework 
primarily interested bytecode verifier check second property jvmlf type system give overview checking algorithm proven accept typed method bodies 
method body environment program algorithm computes type information consistent rules type system order 
gp function map address set possible subroutine calls stacks line code 

domain local variable type map address 
functions map address local variable type map stack type line code 
separate algorithm steps edges flow graph local variable uses known dataflow analysis compute information precomputed difficult compute efficiently prove dataflow analysis algorithm correct discussed section compare algorithm proposed algorithms 
computing gp iterative algorithm uses transfer function shown 
order sets possible subroutine call stacks lattice subset inclusion 
lattice finite program permit call stacks contain multiple return addresses subroutine 
join operation gi equals gi provided gi consistent 
set consistent call stacks calls subroutine 
words gi consistent pn pi jsr consistent contains call stacks created entering different subroutines gi results special error element lattice 
define join subroutine call stack sets address 
exception handlers find gp setting gp repeatedly computing gp gp gp picking dom iteration quiescence reached error occurs 
errors occur assertion cg fails join operation sets gi error element 
slightly different approach deal exception handlers 
assigning type system java bytecode language cg case ifeq gi gi gl gi jsr gi gi assert gi 

jsr gl gl gi ret return 
transfer function computing label target handler requires finding dominating subroutines set dominators instruction monotonic property lattice described 
fix order algorithm picks instruction visited predecessor calls subroutine visited instruction target exception handler visited instructions protected handler 
ordering ensures full set gl subroutine computed propagating information inside subroutine set dominators target known exactly visiting target 
visiting target cg identify called dominator set gt accordingly 
ordering form exist typed jvmlf program generated reasonable java compiler second third requirements satisfied type system requires subroutine call graph acyclic target exception handler protected handler 
step compute set local variables domain local variable maps instructions subroutine 
domain local variable map instruction subroutine contains variable accessed code plus variables accessed code belonging subroutines transitively called inside simple depth traversal subroutine call graph computes information needed construct sets 
final step constructing uses dataflow analysis find fixed point lattice potential types translate jvmlf instruction typing rules transfer function part 
assume fixed environment method ref rest section 
constraints typing rules assertions transformations function si returns top element stack si rest si returns stack si top element 
verify uses transfer find valid type method exists 
initial values types consistent domains stephen freund john mitchell transfer case store assert dom fi si rest si fi fi si new si uninit top uninit si fi top uninit fi return verify repeat transfer dom dom 
transfer 
verify algorithm 
local variable maps initial conditions method entry 
type information merged join operator 
join types written upper bound type lattice induced jvmlf subtyping relation augmented type bottom 
join operation extended obvious way simplicity transfer function exception handlers constructed typing rules similar fashion processing line transfer apply exception handler transfer function handler protecting line gp domain local variable map verify algorithm accept method bodies rule meth code successfully applied accept method bodies typeable rule 
proof properties straightforward tedious size type system 
state key theorems provide brief sketch proofs 
prove verify sound show fixed point computed transfer consistent instructions code array dom 
demonstrating algorithm satisfies hypotheses rule meth code straightforward property established 
theorem stating transfer returns type consistent typing rule instruction theorem transfer soundness 
code array labeling dom transfer type system java bytecode language consider store instruction 
store rest wherex dom 
addition dom assigned types shall rule store dispatch remaining hypotheses rule 
rest si si rest may show similar fashion 
cases similar 
computation transfer repeatedly applied instructions error occurs quiescence reached 
case additional calls function transfer yields theorem conclude dom 
rely standard proof techniques dataflow analysis problems show verify complete see example 
essence valid type fixed point transfer show algorithm find fixed point type lattice exists 
showing monotonicity property transfer function sufficient 
theorem transfer monotone 
code array labeling dom transfer transfer suppose store derivable rule store domain addition hypothesis implies fi means dom fi dom 
dom fi 
assert succeeds transfer transfer computation results error 
transfer return return transfer function differ index 
show theorem sufficient prove si fi order concluded case si fi definition transfer equations hold si si si implies fi 
fi cases instructions similar 

implementation implemented prototype jvml verifier uses phase type checker preceding section 
verifier translates jvml stephen freund john mitchell method body slightly modified subset jvmlf instruction set order handle jvml 
translation preserves structure original method body utilizes small core verifier perform type synthesis 
approach removes details possible dataflow analysis implementation 
example instruction invokevirtual vector object int replaced pop object pop argument pop vector pop receiver push int push integer return value instruction vector indicates value popped top stack 
capture requirements checked core verifier requirement vector exists correct type translator generates set assertions may checked separately type checking performed 
constraint generated instruction vector object int dom goldberg described form assertions demonstrates may construct typing environment bytecode verification presence dynamic loading 
checker verified large fraction jdk libraries examples java programs common idioms exception handling features jvmlf behavior algorithm differs slightly sun implementation 
notable deviation due issues described section 
idea translating bytecode program micro instruction set explored promising way keep size complexity core verifier small 

applications section explore applications outside current role bytecode verifier 

formally specifying verifier obvious direct application type system formal specification bytecode verifier 
original informal specification insufficient describe correct implementation described type system java bytecode language situations verifiers incorrectly accepted bad programs 
errors caused part verifiers implemented clear specification 

testing existing implementations avenue apply follow direction project 
project built traditional software engineering techniques test bytecode verifiers automatically generating large number faulty class files looking inconsistencies behavior different bytecode verifier implementations checking programs 
automated testing identified flaws inconsistencies existing implementations 
case version sun verifier accepted program uninitialized object 
example set operations allowed differed early commercial implementations 
issues uncovered translating difficult cases soundness proofs sample test programs 

checking additional safety properties check additional safety properties bytecode programs 
example check instructions acquire release object locks correctly 
correct may simply mean lock acquired method released prior exit may entail stronger property requiring locks acquired released specific locking policy 
checks may added type system introducing simple form alias analysis object constructing set locks held line program 
alias information needed track multiple object activation record 
time initially suggested approach checking monitors laneve developed extension type system model lock acquisition release thread synchronization wait notify 
second example checking class initializers called appropriate time 
language specification class initializers called prior direct object class 
determining calls left java virtual machine implementor currently run time tests employed detect necessary initializers called 
modifying verifier slightly specify determine precisely initializers need called method 
example jvm forego class initialization test instruction reachable paths including appropriate test 
stephen freund john mitchell 
eliminating unnecessary run time checks final application type system extend role verifier identify locations run time checks may eliminated 
type analysis identify various unnecessary run time checks may phrased dataflow analysis problem style typing rules fairly straightforward embed dataflow problems system 
extended type system prototype implementation determine locations run time checks succeed null pointer tests array bounds tests type checks dynamic casts tests required covariant subtyping arrays perform analysis incorporate additional type constructors identify known null dependent types represent integer values falling specified range 
array lengths known run time range types alias information refer lengths arrays stored local variables 
shows type information computed program extended system 
type array subtype array assigned array known null 
type range assigned integer values fall range 
terms may numbers expressions indicate length array stored local variable arithmetic expression containing limited uses addition subtraction 
subscript stack element indicates stack slot contain value local variable type information clear run time tests operation succeed 
useful general setting necessary expand expression language dependent types expressive fragment arithmetic possibly similar xi pfenning 
information may applied ways 
verifier may pass interpreter just time compiler omit unnecessary tests 
second compilers take advantage new verifier performing optimizations knowledge unneeded checks performed 
eliminating void int int int length 
simple method array accesses succeed 
type system java bytecode language si fi fi fi load array int top top array int array int top top store range array int top top push array int top range store range array int top range goto array int range range load array int range range load array int array int range range push range array int array int range range int range range array int array int range range load array int range range push range array int range range add range range array int range range store range array int range range load array int range range load range array int range range range range array int range range return array int range range 
extended type information method 
stephen freund john mitchell checks significantly improve performance situations 
example execution speed method running virtual machine improves approximately array bounds check removed 
modest nontrivial performance increase obtained larger programs 
possible avenue explore relationship static dynamic checks 
example may able improve resource management techniques incorporating resource tracking static analysis 
bytecode analysis may allow security checks eliminated moved optimal locations 
current limitation system bytecode verification process designed examine method time 
included interprocedural analysis global information framework 
limits precision analysis additional properties check 
dynamic loading global analysis difficult newly loaded class may invalidate program invariants previously held 

related projects established develop static type system java programming language earliest include drossopoulou eisenbach syme nipkow von oheimb 
definition environments rules describing formed environments body overlap java jvml extend past basic structure declarations 
framework type checking instructions type system originally developed stata abadi study bytecode subroutines 
previous extended system study object initialization semantics subroutines similar original sun virtual machine specification :10.1.1.52.8631
combines previous projects construct feel sufficiently large subset jvml cover interesting analysis problems 
rest section describes related studies bytecode verification focusing primarily attempts formalize sun original verification technique 
hagiya type system subroutines similar technique labeling checking subroutines 
types assigned return addresses dependent subroutine call stack height change entry exit subroutine 
addition special types assigned polymorphic variables removing local variable maps 
provides brief overview dataflow algorithm type check simple bytecode programs subroutines 
contrast steps algorithm computes information phase 
compute variables subroutines starting dataflow analysis type system java bytecode language algorithm guess variable subroutine encountered 
error occurs algorithm back revise guess continuing 
able avoid backtracking precompute variable usage information 
qian presents algorithm verify subroutines type system developed subset jvml similar subset studied 
fixed point computation follows form algorithm qian hagiya incorporates computation control flow local variable usage information iterative algorithm 
result difficult prove properties algorithm special techniques needed show transfer function behaves monotonically 
demonstrated qian system may overestimate set variables accessed subroutine inability identify dead code introduced multilevel returns constructing gp type information 
cases matters issue extend system handle tracking return address types phase checker merging second third phase variable usage discovered dataflow analysis 
believe approach straightforward adopt necessary 
number bytecode verification studies departed drastically original sun specification 
trusted logic verifier java card card verification described uses polyvariant analysis subroutine bodies checked multiple times calling context 
polyvariant analysis eliminates need construct subroutine call graph performing dataflow analysis analyzes subroutine calling context may computationally expensive 
leroy provides thorough comparison polyvariant analyses techniques 
coglio uses simple dataflow analysis algorithm subroutines merge types local variables subroutine entry 
multiple types kept local variable analyzing subroutine 
allows sufficient degree context sensitivity check classes programs accepted verifiers context insensitive analysis subroutines jvmlf verifier 
static semantics st rk schmid rger subroutine call stacks demonstrate primary advantages restrictive approaches subroutines 
relaxed requirements subroutines typing rules enable system accept programs jumps cause implicit returns subroutines 
addition program invariants prove type soundness simpler match subroutine call stack implicit program execution history statically computed call stack 
jones independently developed ways type checking bytecode programs aspects haskell type checker check stephen freund john mitchell ers easily realizable jvm implementation 
type system java bytecode subroutines framework developed study typed assembly language developed 
number studies attempted construct machine verified proofs correctness bytecode verifier specifications implementations 
proves soundness fragment qian automatically bertot validated correctness soundness proofs fragment jvmlf concerned object initialization :10.1.1.52.8631
klein nipkow characterized dataflow type inference algorithms low level languages proved isabelle hol standard iterative implementation algorithms yields correct verifier 
constructed java bytecode verifier subset jvmlf instance general framework 
extended approach cover subroutines 
coglio proposed building complete jvml specification specware system 
specware translate specification directly executable verifier 
pursuing automatic translation typing rules executable verifier useful extension reduce possibility introducing implementation errors 
focused developing verification techniques bytecode programs specific circumstances 
example rose rose discussed bytecode verification java cards limited resources available type checker 
extending class files contain stack variable type information branch targets able eliminate need verifier infer types 
verifier just checks consistency provided type information 
posegga vogt focused attention java cards model checking general framework verification 
precise specifications dynamic behavior jvml programs developed 
cohen system acl specification bytecode instruction set 
detailed dynamic semantics formal properties system shown 
dynamic semantics state machines 
systems cover various subsets jvml identify programs compiled executed immediately produce sound static semantics 
st rk schmid rger extended state machines java java virtual machine model compilation process bytecode verification subset java 
demonstrates potential state machine methodology proving correctness compilation verification process nontrivial languages java jvml 

programs circumvent security checks built run time architectures java virtual machine microsoft net platform type system java bytecode language exploit run time type errors 
ensuring type safe execution low level code necessary security systems 
case java virtual machine component responsible checking code bytecode verifier originally underspecified language designers fully understood virtual machine implementors 
designed static type system relatively complete subset jvml includes classes interfaces methods rich set bytecode instructions capture difficult type checking problems 
shown bytecode verifier type checker rejects unsafe programs 
type system serves foundation complete specification bytecode verifier 
addition formalizing jvml type system provides setting bytecode analysis problems explored including enforcement stronger safety properties identification optimization opportunities 
clear avenue develop richer type system enables interprocedural analysis techniques analyze global properties bytecode programs 
significant challenge model global analysis presence dynamic loading effectively 

bertelsen dynamic semantics java bytecode workshop principles machines 

bertot formalizing jvml verifier initialization theorem prover cav computer aided verification pp 


laneve type system jvm threads workshop types compilation 

rger schulte programmer friendly modular definition semantics java alves foss ed formal syntax semantics java lecture notes comput 
sci 
springer verlag pp 


coglio simple verification technique complex java bytecode subroutines proc 
th ecoop workshop formal techniques java programs 

coglio goldberg type safety jvm problems java sdk proposed solutions concurrency computation practice experience 

coglio goldberg qian provably correct implementation jvm bytecode verifier workshop formal underpinnings java paradigm 

cohen defensive java virtual machine version alpha release available www cli com software index html 

czajkowski von eicken resource accounting interface java proceedings acm conference object oriented languages systems pp 


dean security static typing dynamic linking proceedings fourth acm conference computer communications security pp 


dean felten wallach java security hotjava netscape proceedings ieee computer society symposium research security privacy pp 

stephen freund john mitchell 
dean formal aspects mobile code security ph thesis princeton university 

drossopoulou model java dynamic linking loading verification harper ed workshop types compilation lecture notes comput 
sci 
pp 


drossopoulou eisenbach java type safe probably european conference object oriented programming pp 


freund type systems object oriented intermediate languages ph thesis stanford university 

freund mitchell formal framework java bytecode language verifier proceedings acm conference object oriented programming languages systems applications 

freund mitchell specification verification java bytecode subroutines exceptions stanford computer science technical note stan cs tn 

freund mitchell type system object initialization java bytecode language acm transactions programming languages systems 

ghemawat implementation 
available www research 
digital com src java 

goldberg specification java loading bytecode verification acm conference computer communication security pp 


hagiya new method dataflow analysis java virtual machine subroutines static analysis symposium pp 


jensen metayer thorn security dynamic class loading java formalisation proceedings international conference computer languages pp 


jones functions java bytecode workshop formal underpinnings java paradigm 

kildall unified approach global program optimization proceedings acm symposium principles programming languages pp 


klein nipkow verified bytecode verifiers theoret 
comput 
sci 

appear 

klein verified bytecode subroutines automated reasoning 
appear 

leroy java bytecode verification overview cav computer aided verification pp 


leroy java bytecode verification algorithms formalizations automated reasoning 
appear 

lindholm yellin java virtual machine specification nd edn addison wesley 

morrisett crary glew walker system typed assembly language proceedings acm symposium principles programming languages pp 


nipkow von oheimb type safe definitely proceedings acm symposium principles programming languages pp 


callahan simple comprehensive type system java bytecode subroutines proceedings acm symposium principles programming languages pp 


platt microsoft net microsoft press 

posegga vogt byte code verification java smart cards model checking th european symposium research computer security esorics pp 

type system java bytecode language 
proving soundness java bytecode verifier specification isabelle hol proceedings conference tools algorithms construction analysis systems pp 


qian formal specification java virtual machine instructions objects methods alves foss ed formal syntax semantics java lecture notes comput 
sci 
springer verlag pp 


qian standard fixpoint iteration java bytecode verification acm transactions programming languages systems 

qian goldberg coglio formal specification java class loading proc 
th acm conference object oriented programming systems languages applications pp 


rose rose provably correct implementation jvm bytecode verifier workshop formal underpinnings java paradigm 

sirer bershad java system architecture 
available fromhttp cs washington edu 

st rk schmid rger java java virtual machine definition verification validation springer verlag 

st rk schmid completeness bytecode verifier certifying java jvm compiler automated reasoning 
appear 

stata abadi type system java bytecode subroutines acm transactions programming languages systems 

syme proving java type soundness technical report university cambridge 

tarjan unified approach path problems acm 

hagiya careful analysis type spoofing java informations tage pp 


wallach felten understanding java stack inspection proceedings ieee symposium security privacy pp 


xi pfenning dependent types practical programming proceedings acm symposium principles programming languages pp 


compositional account java virtual machine proceedings acm symposium principles programming languages pp 

