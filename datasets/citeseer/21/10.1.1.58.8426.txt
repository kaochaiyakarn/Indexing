analysis performance impact wrong path memory order runahead execution processors kim david armstrong yale patt high performance systems group department electrical computer engineering university texas austin austin texas tr hps january page intentionally left blank 
analysis performance impact wrong path memory order runahead execution processors kim david armstrong yale patt department electrical computer engineering university texas austin dna patt ece utexas edu high performance order processors spend significant portion execution time incorrect pro gram path employ aggressive branch prediction algorithms 
memory generated wrong path change architectural state processor affect arrangement data memory hierarchy 
examines effects wrong path memory processor performance 
shown significantly affect ipc instructions cycle performance processor 
modeling lead errors ipc estimates spec integer benchmarks benchmarks experience error greater ipc estimates 
general error ipc increases increasing memory latency instruction window size 
find wrong path usually beneficial performance prefetch data correct path 
cache pollution significant negative effect wrong path 
code examples shown provide insights wrong path affect performance 
find crucial model wrong path get accurate estimate performance improvement provided runahead execution avoid errors ipc estimates runahead processor 

high performance processors employ aggressive branch prediction techniques order exploit high levels instruction level parallelism 
unfortunately low branch misprediction rates processors spend sig number cycles fetching instructions mispredicted wrong program path 
leftmost bar extended version workshop memory performance issues 
section examines effects hardware prefetching section analyzes effects wrong path memory runahead processors section gives survey related research speculative execution major extensions 
section extended 
sections edited include explanations data 
shows percentage total cycles spent fetching wrong path instructions spec integer bench marks 
middle rightmost bars show percentage instructions fetched executed wrong path average conditional branch misprediction rate evaluated processor spends total cycles fetching wrong path instructions 
fetched instructions executed instructions wrong path 
executed instructions wrong path data memory access instructions loads stores 
percentage cycles wrong path total cycles fetched wrong path insts fetched insts exec wrong path non mem insts exec insts exec wrong path mem insts exec insts gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
percentage total cycles spent wrong path percentage instructions fetched wrong path percentage instructions memory non memory executed wrong path baseline processor spec integer benchmarks 
wrong path data instruction memory change architectural state machine affect arrangement data memory hierarchy 
examine effect wrong path memory performance processor 
particular seek answers questions 
important correctly model wrong path memory 
error predicted perfor mance wrong path modeled 

wrong path memory affect performance positively negatively 
relative significance performance prefetching bandwidth consumption pollution caused wrong path 

kind code structures lead positive effects wrong path memory 

wrong path memory affect performance runahead execution processor implements aggressive form speculative execution :10.1.1.111.9057
results indicate wrong path memory significantly affect processor performance model ing may lead errors ipc estimates order processor ipc estimates machine configuration simulation methodology described section 
runahead execution processor 
positive effect performance benchmarks due prefetching wrong path negatively impact performance 
analyze causes positive negative performance impact 
identify pollution cache dominant negative effect wrong path code examples illustrate prefetching effects 
find modeling wrong path result significant underestimation performance improvement provided runahead execution 

experimental methodology execution driven simulator capable accurately fetching executing instructions wrong path correctly recovering mispredictions occur wrong path 
baseline processor model wide order processor instruction window hold instructions 
conditional branch predictor hybrid branch predictor composed entry gshare entry pas predictor entry selector entry branch target buffer 
indirect branch predictor entry way target cache 
model deep pipeline cycle branch misprediction latency 
data instruction caches kb way banks cycle hit latency 
unified cache mb way banks cycle hit latency 
caches line size bytes 
model bandwidth port contention bank conflicts queuing effects levels memory hierarchy 
memory system model shown 
cache cache requests may ing 
requests may reside queues memory system 
queues request queue bus request queue priority queues requests generated older instructions higher priority 
prioritization fairly easy implement chip reduces probability full window stall servicing older instructions requests earlier 
bus pipelined split transaction bit wide way latency processor cycles 
requests scheduled bus bus cycle bus re quest queue memory controller 
processor frequency times bus frequency 
memory controller takes memory requests bus schedules accesses dram banks 
requests independent banks serviced parallel 
requests banks serialized serviced fifo order 
model dram banks access latency processor cycles 
round trip latency request minimum processor cycles cycle memory access cycle round trip bus queuing delays bank conflicts 
cache requested cache line brought cache level cache initiated request 
store instruction request misses data cache cache allocates line respective cache 
write back requests cache inserted request queue write back requests cache inserted bus request queue bandwidth available instruction data fetch requests 
experiments run spec integer benchmarks compiled alpha isa fast optimizations profiling feedback enabled 
benchmarks run completion modified test input set reduce simulation time 
number retired instructions branch misprediction cache rates retired instructions benchmark shown table 
cache cache misses cache cache misses write backs request queue misses cache cache fills write backs bus request queue 
wrong path model model cache fills cache hits cache fills bus memory controller dram memory banks fill queue chip chip 
memory system modeled evaluation 
section measure error ipc wrong path memory simulated 
evaluate effect wrong path memory ipc retired instructions cycle performance processor 
investigate effects wrong path change memory latency instruction window size 
order isolate effects wrong path memory ensure wrong path execution affect execution correct path changes memory system 
state updated speculatively wrong path execution restored recovery misprediction 
table 
number retired instructions branch mispredictions cache dc cache ic misses retired instructions baseline processor simulated benchmarks 
baseline ipc performance ipc stream prefetcher see section shown 
inst 
bp dc ic baseline ipc prefetcher benchmark count rate rate rate rate ipc see section gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf shows ipc performance baseline processor different minimum memory latencies cycles wrong path memory correctly modeled 
shows percent error ipc models wrong path memory modeled positive error means ipc obtained wrong path modeled higher ipc obtained modeled positive error implies wrong path detrimental performance instructions cycle cycle memory latency cycle memory latency cycle memory latency gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
ipc baseline processor different memory latencies wrong path accesses correctly modeled 
shows error ipc estimates quite significant benchmarks wrong path memory modeled 
instance ipc obtained mcf wrong path lower ipc obtained wrong path cycle memory latency 
error average ipc cycle memory latency 
error ipc generally increases memory latency increases modeling wrong path memory accomplished stalling fetch stage mispredicted branch resolved machine state recovered 
effect shows difference ipc trace driven simulation baseline execution driven simulation 
rightmost set bars shows error average ipc average error 
suggests modeling wrong path important processors longer latencies memory 
increased memory latencies positive negative effects wrong path memory operations pronounced terms contribution execution cycles 
instance wrong path generates memory request correct path saves cycles affects ipc saves cycles 
mcf error decreases memory latency increases exception 
benchmark long latency cache misses caused wrong path delay servicing correct path misses consuming bandwidth resources 
bandwidth contention significant longer memory latencies performance improvement due wrong path reduces increased memory latency 
percent ipc error cycle memory latency cycle memory latency cycle memory latency gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
error ipc baseline processor different memory latencies wrong path memory simulated 
shows wrong path positive effect processor performance benchmarks especially mcf parser perlbmk 
benchmarks wrong path significant negative affect ipc vpr gcc 
shows percentage number executed wrong path instructions significantly increase increased memory latency 
due limited instruction window size 
processor remains wrong path hundreds cycles due mispredicted branch dependent cache processor incurs full window stall due limited window size 
increasing memory latency increase number executed wrong path instructions 
increasing memory latency increase contribution wrong path memory number execution cycles explained 
determine effect increased number wrong path instructions performance estimates evaluate processors larger instruction windows allow execution instructions wrong path 
number executed correct path instructions constant benchmark 
wrong path insts executed insts cycle memory latency non memory inst cycle memory latency memory inst cycle memory latency non memory inst cycle memory latency memory inst cycle memory latency non memory inst cycle memory latency memory inst gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
percentage executed wrong path instructions executed instructions different memory latencies 

effect wrong path memory larger instruction windows processors larger instruction windows exploit higher levels instruction level parallelism 
larger instruction window change effect wrong path memory performance major ways 
larger window allows wrong path executed decreasing number full window stalls encountered wrong path 
occur wrong path positive effects prefetching larger window increase positive impact wrong path ipc 
hand wrong path negative effects pollution ipc negatively affected 

larger window processor better able tolerate negative effects caused wrong path memory 
shows error ipc estimates processors different instruction window sizes wrong path memory modeled error ipc mcf window size 
aside couple exceptions notably perlbmk gcc error ipc generally increases increasing window size wrong path memory modeled 
larger instruction window processor able execute memory operations wrong path shown changes impact wrong path memory ipc 
memory latency fixed cycles simulations 
percent ipc error entry window entry window entry window gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
error ipc baseline processor different instruction window sizes wrong path memory simulated 
increase number executed wrong path affects ipc depends usefulness extra executed 
perlbmk memory executed wrong path start canceling positive prefetching effects operations executed earlier 
larger instruction window wrong path memory positive effect ipc perlbmk 
hand see opposite effect vpr mcf parser vortex bzip 
wrong path executed wrong path useful correct path operations encountered processor resolves mispredicted branch benchmarks 

effect hardware prefetching far simplify analysis assumed baseline processor employ hardware prefetch ing technique 
aggressive hardware prefetchers commonly implemented modern microprocessors significantly increase processor performance shown ipc data table 
un impact wrong path memory processors employ hardware prefetching 
quantify impact modified baseline processor model include aggressive stream prefetcher similar described 
shows error ipc estimates baseline processor stream prefetching wrong path mem ory modeled 
wrong path general positively impact performance processors stream prefetchers 
performance impact wrong path processors prefetching similar performance impact processors employ prefetching 
partly stream prefetcher able capture prefetches generated wrong path memory stream prefetcher model stream buffers stream buffer stay cache lines ahead processor data access stream 
stream buffer allocated cache stream buffers trained cache accesses 
information stream prefetching algorithm employed see 
wrong path insts executed insts entry inst window non memory inst entry inst window memory inst entry inst window non memory inst entry inst window memory inst entry inst window non memory inst entry inst window memory inst gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
percentage executed wrong path instructions executed instructions different instruction window sizes 
partly wrong path memory significantly affect prefetches generated stream prefetcher 
conclude stream prefetching significantly change performance impact wrong path memory performance impact wrong path performance impact stream prefetcher orthogonal 
supported error ipc wrong path modeled larger instruction window processors employ stream prefetching shown 
percent ipc error cycle memory latency cycle memory latency cycle memory latency gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
error ipc baseline processor stream prefetcher different memory latencies wrong path memory simulated 
percent ipc error entry window entry window entry window gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
error ipc baseline processor stream prefetcher different instruction window sizes wrong path memory simulated 

analysis wrong path memory affect processor performance significantly 
important understand case 
section analyze reasons positive negative impact wrong path performance 

bandwidth resource contention wrong path bandwidth resources get way correct path delaying servicing correct path memory requests 
examine bandwidth resource contention caused wrong path affects ipc simulated idealized unrealistic processor gives lower priority wrong path memory system 
model wrong path get way correct path outstanding 
resource queue entry tied wrong path correct path needs resource model allocates resource correct path 
compared performance idealized model baseline processor 
performance difference models negligible benchmarks mcf ipc improves idealized model 
mcf benchmark high rate generates wrong path cache 
keep memory banks busy delay correct path try access banks 
benchmarks wrong path cause significant bandwidth resource contention correct path 

usefulness wrong path wrong path increase performance prefetching data reduce performance polluting caches 
explain impact effects performance examining accuracy wrong path data instruction 
categorize misses caused wrong path groups 
unused wrong path caused wrong path allocated cache line correct path evicted 

fully wrong path caused wrong path allocated cache line correct path 

partially wrong path initiated wrong path required correct path request flight 
shows number data cache misses processor models 
leftmost stacked bar benchmark shows number data cache misses baseline model executes wrong path memory refer ences 
rightmost bar shows number data cache misses simulator model wrong path 
show raw number misses illustrate impact data cache misses performance 
observe number correct path data cache misses reduced average wrong path modeled correctly hints benchmarks benefit wrong path refer ences 
reduction significant vpr mcf 
mcf reduction affects ipc positively shown wrong path data cache misses fully partially 
wrong path data cache misses cache provide accurate long latency prefetches mcf positively impacts ipc 
vpr unused wrong path data cache misses cause significant pollution cache show section 
vpr performance adversely affected wrong path data 
average wrong path data cache misses fully partially 
shows number instruction cache misses processor models 
observe gcc crafty perlbmk vortex affected wrong path instruction benchmarks incur significant number instruction cache misses 
accuracy wrong path instruction requests lower wrong path data requests 
average wrong path instruction cache misses fully partially 
wrong path instruction cache misses fully partially gcc pollution caused unused reason gcc loses performance due wrong path 
hand wrong path instruction cache misses perlbmk vortex provide significant performance increase 
find gcc unused instruction cache misses cache evict useful cache lines 
cache latency high unused wrong path misses decrease performance significantly 
number data cache misses vpr mcf unused wrong path wrong path partially wrong path correct path correct path sim gzip gcc crafty parser eon perlbmk gap vortex bzip twolf 
number data cache misses baseline leftmost bar benchmark model execute wrong path rightmost bar benchmark 
note axis vpr mcf different scale due large number misses experience 
contrast crafty large number unused wrong path instruction cache misses misses satisfied cache 
misses evict useful lines cause pollution instruction cache 
ipc crafty significantly reduced due unused wrong path shown 
unused wrong path instruction cache misses cause significant pollution perlbmk show section 
prefetching benefit wrong path instruction cache misses outweighs pollution caused unused ones vortex 
performance increase benchmarks 
number instruction cache misses unused wrong path fully wrong path partially wrong path correct path correct path wrong path simulation gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
number instruction cache misses baseline leftmost bars model execute wrong path rightmost bars 

understanding pollution effects order understand performance impact cache pollution caused wrong path eliminate wrong path pollution caches 
hypothesize pollution caused wrong path level instruction data caches detrimental performance pollution cache due high penalty cache 
evaluate different idealized models test hypothesis models wrong path requests cause pollution cache cache cache respectively model wrong path requests cause pollution caches model pollution storing lines fetched wrong path separate buffer respective cache moving lines respective cache correct path request 
models idealized real processor know wrong path mispredicted branch resolved 
shows ipc improvement baseline idealized models 
eliminating pollution caused wrong path level instruction data caches affect performance crafty vortex 
contrast eliminating pollution cache increases performance half benchmarks including gcc vpr wrong path detrimental performance 
gcc eliminating cache pollution increases baseline performance wrong path beneficial performance 
mcf parser eliminating cache pollution increases ipc respectively increasing usefulness wrong path benchmarks 
percent ipc improvement baseline cache pollution cache pollution cache pollution pollution cache gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
ipc improvement baseline processor pollution caused wrong path eliminated caches 
investigate pollution level caches pronounced effect ipc smaller level caches 
shows ipc improvement idealized models kb instruction data caches 
see pollution especially instruction cache significant performance smaller instruction data caches 
data cache pollution significant rela examined model wrong path requests cause pollution cache cache cause pollution cache 
results obtained model negligibly different results obtained model eliminates cache pollution 
tively short latency misses causes tolerated entry instruction window 
instruction cache pollution due wrong path prefetches affects performance significantly gcc crafty perlbmk vortex twolf significant numbers unused wrong path instruction cache misses shown 
smaller level caches removing pollution cache important removing pollution level caches 
percent ipc improvement baseline cache pollution cache pollution cache pollution pollution cache gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
ipc improvement baseline processor kb instruction data caches pollution caused wrong path eliminated caches 
shows normalized number cache misses baseline model model simulate wrong path provides insight cache pollution degrades performance vpr gcc wrong path modeled 
benchmarks number cache misses suffered correct path instructions correct path partially wrong path increases significantly wrong path modeled due pollution caused unused wrong path cache misses 
hand number cache misses suffered correct path instructions decreases stays benchmarks wrong path modeled explains wrong path beneficial performance benchmarks 
conclude pollution cache significant negative effect wrong path memory 
order reduce negative impact wrong path increase positive effects high performance processors adopt policies reduce cache pollution caused wrong path 

understanding prefetching effects previous sections shown general prefetching benefits wrong path outweigh negative effects bandwidth demands cache pollution 
section code examples provide insights wrong path memory beneficial correct path execution 
normalized number cache misses unused wrong path fully wrong path partially wrong path correct path correct path wrong path simulation gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
normalized number cache misses baseline leftmost bars model execute wrong path rightmost bars 

prefetching data loop iterations find wrong path execution loop iteration prefetch data correct path execution iteration 
happen conditional branch side loop mispredicted processor continues execute iteration wrong path 
analysis shows useful wrong path data cache misses mcf bzip generated fashion 
shows code section mcf bea mpp function performs optimization routine 
shown loop traverses array pointers arc structures performs operations single arc structure iteration 
branch line dependent pointer ident mispredicted time 
iterations processor branch execute body statement starts executing iteration wrong path 
wrong path execution iteration initiates load request ident 
mispredicted branch resolved processor recovers executes body statement starts iteration correct path 
back correct path processor generates load request arc ident prefetched data cache previous execution iteration wrong path 
find load ident frequently misses data cache cache 
wrong path execution iterations loop prefetches data correct path execution iterations 
instruction loads arc ident causes wrong path data cache misses mcf fully partially correct path 
example body statement contains lot instructions executing body statement iterations executed wrong path misses caused load arc ident different iterations 
parallelization misses may achieved processor remains correct path correct path requires execution body statement iteration instruction window filled instructions body statement instructions ident 
arc arc array arc structures initialize arc arc 
arc arcs arc size arc ident frequently mispredicted br 
function calls operations structure pointed arc 

example mcf showing wrong path prefetching loop iterations 

loop prefetching common accurate wrong path prefetching iterations loop different loops prefetch data working data structure 
shows code example mcf sorting routine exhibits wrong path prefetching behavior 
loops lines traverse array pointers structures perm compare member structure 
important note traversal begins lower memory address works second traversal begins higher memory address works 
loops branch data dependent condition 
find loop branch terminating condition continues executing loop iterations accesses abs cost continue load data upper part array process serve prefetch data elements loop 
min max cut perm long abs cost perm abs cost cut cut perm abs cost perm perm perm perm 
example mcf showing prefetching different loops 

prefetching control flow hammock branch mispredicted loads executed mispredicted path hammock may provide useful data loads executed correct path hammock 
happens paths hammock need data 
loop mcf benchmark potential function shown demonstrates kind wrong path prefetching 
function traverses linked data structure 
depending visited calculated 
note values calculate potential regardless node 
words instructions block instructions block data 
branch statement mispredicted wrong path load instructions generate requests node basic arc cost node pred potential 
mispredicted branch resolved correct path load instructions generate requests data cache flight 
analysis shows wrong path cache misses caused block block hammock constitute wrong path data cache misses mcf fully partially instructions correct path 
node node initialize node 
node node orientation mispredicted branch node potential node basic arc cost node pred potential node potential node pred potential node basic arc cost 
control flow independent point re convergent point node node child 
example mcf showing prefetching control flow 

prefetching due control flow independence find control flow independence major factors contributing prefetching benefit wrong path 
prefetching data loop itera tions discussed previously results prefetching benefits due control flow independence portion code executed wrong path exactly code needs executed correct path wrong path portion code provide prefetching benefits 
example prefetching benefits due control flow independence seen 
example wrong path execution due mispredicted hammock branch reaches control flow independent point basic block belonging hammock line 
executing wrong path control flow independent point processor gen request node child 
mispredicted hammock branch resolved instructions control flow independent point re executed part correct path execution generate request data cache flight 

effects wrong path runahead execution processors section examines performance impact wrong path memory processor implements runahead execution :10.1.1.111.9057
runahead execution speculation technique utilizes idle cycles due cache misses perform pre execution order generate long latency prefetches 
runahead execution processor initiates speculative processing oldest instruction instruction window pre executes instruction stream complete 
speculative processing mode called runahead mode processor may mispredict branch may remain wrong program path long time mispredicted branch may data dependent completed :10.1.1.111.9057
due existence unresolvable mispredicted branches called divergence points possible runahead processor spends time wrong path traditional order processor :10.1.1.111.9057
performance impact wrong path memory may larger runahead processor traditional processor 
runahead execution shown effective prefetching mechanism approximate memory latency tolerance large instruction window examine understand effects wrong path memory performance runahead processor 
model runahead execution described baseline processor described section :10.1.1.111.9057

wrong path modeling performance improvement runahead execution runahead execution aggressive form speculative execution modeling wrong path memory may affect performance improvement estimates implementing runahead execution 
shows ipc improvement obtained adding runahead execution baseline processor 
left bar benchmark shows improvement simulator correctly models wrong path memory right bar shows improvement simulator model wrong path memory 
ipc improvement runahead execution significantly higher wrong path correctly modeled especially vpr mcf parser vortex bzip 
mcf significant benefit runahead execution comes prefetches generated wrong path 
modeling prefetches significantly underestimates ipc improvement achievable runahead execution 
wrong path modeled average ipc improvement runahead execution estimated correct average ipc improvement 
shows benchmarks show significant difference performance improvement head vpr mcf parser vortex bzip wrong path memory modeled spend significant portion fetch cycles wrong path fetch execute significant percentage instructions wrong path 
mcf executed instructions wrong path instructions 
baseline processor runahead execution executed instructions wrong path instructions shown 
runahead execution significantly increases number wrong path executed mcf 
true ipc improvement due runahead execution wrong path correctly modeled wrong path modeled gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
ipc improvement adding runahead execution baseline processor wrong path memory modeled 
vpr parser vortex bzip 
modeling provide useful prefetching benefits results underestimation performance improvement runahead execution 
percentage cycles wrong path execution cycles fetched wrong path insts fetched insts exec wrong path non mem insts exec insts exec wrong path mem insts exec insts gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
percentage total cycles spent wrong path percentage instructions fetched wrong path percentage instructions memory non memory executed wrong path runahead processor 

effect memory latency runahead processors shows percent error ipc runahead execution processor wrong path memory modeled main memory latencies 
similar findings traditional order processors section modeling wrong path result significant error error increases memory latency increases 
observe wrong path memory larger impact ipc estimates runahead execution processor 
example wrong path modeled error ipc estimate mcf benchmark cycle memory latency 
error ipc benchmarks vpr mcf parser vortex bzip 
wrong path important model order get accurate ipc estimates runahead execution processor traditional order processor 
percent ipc error cycle memory latency cycle memory latency cycle memory latency gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
error ipc runahead execution processor different memory latencies memory simulated 
shows wrong path positive effect performance runahead processor evaluated benchmarks 
benchmark wrong path significant negative effect performance gcc 
compared traditional processor examined wrong path positive effect runahead processor 
find major reasons 
runahead processor executes instructions wrong path traditional processor number instructions executed runahead mode limited processor instruction window size 
higher number wrong path instructions executed provide prefetching benefits correct path analyzed section higher positive performance impact wrong path memory 

runahead processor better able tolerate negative effects wrong path cache pollution traditional processor 
shows percentage number executed wrong path instructions significantly increases increased memory latency runahead processor average 
note behavior different observations traditional processor section 
runahead execution enables processor execute instructions processor instruction window allows wrong path instructions executed runahead processor increased memory latency 
increase number executed wrong path memory increases impact performance 
wrong path insts executed insts cycle mem latency non mem inst cycle mem latency mem inst cycle mem latency non mem inst cycle mem latency mem inst cycle mem latency non mem inst cycle mem latency mem inst gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
percentage executed wrong path instructions executed instructions different memory latencies runahead processor 

effect instruction window size runahead processors runahead execution effectively enlarges instruction window size order processor capturing prefetching benefits larger instruction window :10.1.1.111.9057
number instructions executed runahead execution limited size instruction window expect error ipc change significantly wrong path modeled runahead processors larger instruction windows 
test hypothesis evaluate performance impact modeling wrong path memory runahead processors different instruction window sizes 
shows error ipc estimates runahead processors different instruction window sizes wrong path memory modeled 
anticipated error ipc change significantly increased window size 
results traditional processor section instruction window size runahead execution processor significantly affect performance impact wrong path memory 

effect hardware prefetching runahead processors evaluate performance impact wrong path memory runahead execution processors employ aggressive stream prefetcher described section 
shows ipc improvement obtained adding runahead execution baseline processor stream prefetcher wrong path correctly modeled left bars modeled right bars 
similar observation processor stream prefetcher ipc improvement provided runahead execution significantly percent ipc error entry window entry window entry window gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
error ipc runahead execution processor different instruction window sizes wrong path memory simulated 
higher wrong path correctly modeled 
important model wrong path memory get accurate estimate performance improvement due runahead execution processors employ stream prefetching processors 
ipc improvement due runahead execution wrong path correctly modeled wrong path modeled gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
ipc improvement adding runahead execution baseline processor stream prefetcher wrong path memory modeled 
figures show performance impact modeling wrong path memory runahead processors employ stream prefetching variety memory latencies instruction window sizes 
comparing performance impact shown figures shown figures see performance impact wrong path similar runahead processors stream prefetching 
stream prefetching significantly affect performance impact wrong path memory percent ipc error cycle memory latency cycle memory latency cycle memory latency gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
error ipc runahead execution processor stream prefetcher different memory latencies wrong path memory simulated 
runahead execution processors shown hold true non runahead order processors section 
percent ipc error entry window entry window entry window gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
error ipc runahead execution processor stream prefetcher different instruction window sizes wrong path memory simulated 

analysis effects runahead processors examine performance impact negative effects wrong path memory runahead exe cution processor individually ideally eliminating causes negative performance impact 
shows performance improvement obtained bandwidth resource contention cache pollution cache pollution cache pollution pollution caches caused wrong path memory eliminated 
similar results obtained traditional processor sections eliminating bandwidth resource contention cache pollution cache pollution caused wrong path significantly improve perfor mance runahead execution processor 
hand eliminating cache pollution caused wrong path significantly increases ipc runahead execution processor 
conclude cache pollution significant negative effect wrong path memory runahead processors traditional high performance processors 
percent ipc improvement runahead base bandwidth resource contention cache pollution cache pollution cache pollution pollution cache gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
ipc improvement runahead processor negative effects caused wrong path eliminated 
shows normalized number cache misses runahead model correctly models wrong path memory runahead model execute wrong path memory 
gcc number cache misses suffered correct path instructions correct path partially wrong path increases significantly wrong path modeled due pollution caused unused wrong path cache misses 
reason ipc degradation gcc wrong path correctly modeled 
benchmarks crafty correctly modeling wrong path reduces number cache misses suffered correct path instructions 
reduction mcf performance significantly underestimated wrong path modeled 
analyzed code structures cause prefetching benefits wrong path memory runahead execution processor 
code structures identified section traditional processor major causes prefetching benefits runahead processor 

related previous area analyzing effects wrong path memory processor performance generally focused evaluating performance impact terms cache hit rates 
researchers studied impact wrong path processor performance usually processor models main memory normalized number cache misses unused wrong path wrong path partially wrong path correct path correct path wrong path simulation gzip vpr gcc mcf crafty parser eon perlbmk gap vortex bzip twolf 
normalized number cache misses runahead model correctly models wrong path memory leftmost bars runahead model execute wrong path memory rightmost bars 
latencies unrealistic today standards 
previous studies identify exact reasons wrong path reduce performance kind program constructs lead prefetching effects 
previous aware examined effect wrong path runahead execution processor implements aggressive speculative execution 
major contributions speculative execution research 
analyzes performance impact wrong path memory realistic main memory cies instruction window sizes current near processors 

identifies major reason cache pollution wrong path memory reduce performance 

provides insights wrong path memory increase performance providing code examples real programs show wrong path memory provide prefetching benefits 

examines performance impact wrong path memory runahead execution processor shows modeling wrong path memory crucial get accurate estimate performance improvement provided runahead execution 
papers examined effect speculative execution cache processor performance 
provide brief survey related research discuss relation 
butler compared performance trace driven versus execution driven simulation spec integer bench marks machine cycle memory latency 
butler showed general execution driven simulation performs worse trace driven simulation main reason pollution branch prediction struc tures 
performance improvement observed benchmark gcc instruction data caches speculatively updated branch prediction structures speculatively updated 
confirm result speculative memory improve performance find beneficial effects pronounced longer memory latencies 
pierce mudge studied effect wrong path memory cache hit rates 
developed tool simulate wrong path memory accesses tool show wrong path memory accesses allocate useful data instruction cache blocks time spec benchmarks 
study trace driven simulation leads inaccuracies modeling wrong path effects 
trace driven simulators execute wrong path instructions pierce mudge injected fixed number instructions emulate wrong path 
realistic pointed number instructions executed wrong path fixed real processor 
execution driven simulator faithfully models wrong path execution happen real processor 
combs studied effects wrong path memory cache behavior processor perfor mance 
similar results wrong path beneficial performance bench marks detrimental performance 
average reported wrong path beneficial performance increasing average ipc slightly spec integer benchmarks 
combs examine wrong path effects processors main memory latencies longer cycles 
show longer memory latencies seen state art processors wrong path memory significant impact processor performance 
analyze detail causes positive impact wrong path providing code examples benchmarks causes negative impact wrong path 
pierce mudge introduced instruction cache prefetching mechanism leverages usefulness wrong path memory instruction cache 
mechanism fetches fall target addresses conditional branch instructions prefetch correct path wrong path instructions 
wrong path prefetching improves performance line prefetching mechanism 
pierce mudge observed effectiveness wrong path prefetching increases memory latency increased 
lee studied instruction cache fetch policies processor speculative execution cache simu 
prefetching benefit wrong path instruction cache misses outweighs pollution effect measured terms instruction cache hit rate 
examine impact wrong path instruction cache ipc performance 
investigated method capturing beneficial aspects speculative memory avoiding pollution effects wrong path memory accesses 
assumed priori wrong path degrade performance 
mechanism uses branch confidence predictor indicate processor wrong path case results memory accesses placed separate fully associative entry buffer 
maximum performance improvement observed results wrong path stored separate buffer 
performance improvement due primarily additional associativity provided separate buffer 
refute assumption wrong path degrade performance show wrong path benefit performance cases 
investigated effect wrong path memory accesses ipc data cache rates 
objective determine light speculative execution trace driven simulators accurately inform design decisions processor development 
compared ipc processor running spec integer benchmarks wrong path memory accesses memory latency cycles 
ipc difference negligible case unexplained outlier difference ipc occurs benchmark compress 
show processor performance sensitive wrong path memory accesses low memory latencies negligible differences ipc reported proposed fully associative wrong path cache eliminate cache pollution caused wrong path load 
similar proposal cache accessed parallel data cache 
data brought processor wrong path load instructions evicted cache stored wrong path cache 
wrong path cache serves victim cache buffer store data fetched wrong path load 
approach eliminates pollution caused wrong path load cache eliminate pollution caused cache bigger problem described 
proposed level caches filters reduce second level cache pollution caused speculative memory including wrong path hardware prefetcher 
mechanism takes advantage observation level cache pollution caused speculative detrimental performance second level cache pollution 
approach reduces cache pollution caused speculative order runahead processors requiring extra storage data fetched speculative 
jourdan analyzed effects wrong path execution branch prediction structures 
control flow instructions executed wrong path cause pollution return address stack global branch history register results performance degradation 
alleviate problem proposed mechanisms recover state return address stack global branch history register branch misprediction recovery 
manne observed execution wrong program path results significant number increase executed instructions called extra 
observation similar observations regard number instructions executed wrong path 
manne proposed pipeline gating reduce extra performed processor pipeline due branch mispredictions 
showed pipeline gating reduces number extra executed instructions reducing energy consumed processor 
lastly bhargava observed major disadvantage trace driven simulation inability model fetch execution speculative instructions 
proposed method augmenting trace driven simulator model effects speculative execution including memory wrong path 
method provides correctness benefit modeling wrong path memory preserving speed fast trace driven simulation 

evaluate effects wrong path performance order runahead execution processors 
evaluation reveals 
modeling wrong path memory important modeling leads errors ipc estimates order processor ipc estimates runahead execution processor 

modeling wrong path memory important processors longer memory cies larger instruction windows 

general wrong path memory beneficial processor performance prefetch data processor caches 

dominant negative effect wrong path memory pollution cause cache 
pollution level caches bandwidth resource usage wrong path significantly impact performance 

prefetching benefit wrong path caused different code structures 
benchmarks examined main benefit comes wrong path prefetching data loop iteration iteration executed correct path 

modeling wrong path significantly underestimates performance improvement provided runahead execution 
wrong path generally beneficial performance runahead execution processor 

stream prefetching significantly affect performance impact wrong path memory 
light results increase performance processors designers focus eliminating cache pollution caused wrong path memory 
compilers structure code wrong path execution provides prefetching benefits correct path execution especially high probability cache branches frequently mispredicted 
designers runahead execution processors correctly model wrong path memory order get accurate estimates ipc performance runahead processor performance improvement provided runahead execution 


performance analysis wrong path data cache accesses 
workshop performance analysis impact design th annual intl 
symposium computer architecture 
bhargava john 
accurately modeling speculative instruction fetching trace driven simulation 
proceedings ieee performance computers communications conference pages 
butler 
aggressive execution engines surpassing single basic block execution 
phd thesis university michigan 

chang hao patt 
predicting indirect jumps target cache 
proceedings th annual international symposium computer architecture pages 
chou abraham 
microarchitecture optimizations exploiting memory level parallelism 
pages june 
combs combs shen 
mispredicted path cache effects 
proceedings th international euro par conference parallel processing pages 
mudge 
improving data cache performance pre executing instructions cache proceedings international conference supercomputing pages 
chou abraham 
effective stream execution data prefetching 
proceedings th international conference supercomputing 
jouppi 
improving direct mapped cache performance addition small fully associative cache prefetch buffers 
proceedings th annual international symposium computer architecture pages 
jourdan 
stark patt 
effects mispredicted path execution branch predic tion structures 
proceedings acm ieee conference parallel architectures compilation techniques pages 
lee 
baer calder grunwald 
instruction cache fetch policies speculative execution 
proceedings nd annual international symposium computer architecture pages 
manne grunwald 
pipeline gating speculation control energy reduction 
proceed ings th annual international symposium computer architecture pages 
mcfarling 
combining branch predictors 
technical report tn digital western research laboratory june 

wellman moreno 
approach quantifying impact simulating mis predicted paths 
workshop performance analysis impact design workshop th annual intl 
symposium computer architecture june 
kim armstrong patt 
cache filtering techniques reduce negative impact useless speculative memory processor performance 
th symposium computer architecture high performance computing oct 
kim armstrong patt 
understanding effects wrong path memory processor performance 
third workshop memory performance issues june 
stark wilkerson patt :10.1.1.111.9057
runahead execution alternative large instruc tion windows order processors 
proceedings ninth ieee international symposium high performance computer architecture pages feb 
pierce mudge 
effect speculative execution cache performance 
proceedings intl 
parallel processing symposium pages 
pierce mudge 
wrong path instruction prefetching 
proceedings th annual acm ieee international symposium microarchitecture pages 
rotenberg jacobson smith 
study control independence superscalar processors 
proceedings fifth ieee international symposium high performance computer architecture pages 
lilja 
exploiting prefetching effect provided executing mispredicted load instructions 
proceedings th international euro par conference parallel processing 
fields le 
power system microarchitecture 
ibm technical white oct 
wilkes 
memory gap high performance memories 
acm computer architecture news mar 

yeh patt 
alternative implementations level adaptive branch prediction 
proceedings th annual international symposium computer architecture pages 

