obtain powerful parsers elegant practical pepper technische universit berlin pepper cs tu berlin de issn march obtain powerful parsers elegant practical pepper march functional parsers published today focus elegance 
pay elegance neglecting practical requirements eciency decent error handling 
contrast traditional parser generator ll lr principles focuses eciency neglects issues elegance understandability entirely 
combine pragmatic issues desire elegance techniques realms functional programming program transformation 
parsing best studied elds computer science resulting areas sound theoretical combined equally rigorous software engineering principles 
light new developments programming observe emergence quite di erent viewpoints subject re ecting diverging interests classical ll lr style parser programming parser generation focuses solely eciency 
primary goal loss expressive power accepted issues understandability exibility adaptability totally neglected 
functional programming parsers mainly strive elegance 
unconstrained expressive power achieved backtracking 
goals certain loss practicality accepted particular loss eciency 
correctness parser necessitates inclusion modern programming principles typing inheritance 
usually neglected particular connection generated parsers 
hidden assumption approaches presupposed ample time generating parser produced applied lots programs 
picture changed dramatically emergence new paradigms 
example xml leads situation grammar needs fakult ur und informatik technische universit berlin 
email pepper cs tu berlin de turned parser applied immediately exactly program 
similarly mix operators including overloading shall de nable user signature module class turned parser 
result requirements need tools parser generation 
tools available programming community quite resulting early partial evaluation strength reduction formal di erentiation xpoint computation great part pioneered bob paige 
question techniques utilized parsing parser generation 
study concepts combine functional programming paradigm quest 
envisage situation sketched basic grammar problem oriented pseudo grammar lr style transform parser elegant slow parser lr style transform transformation paradigms principle functional parsers grammar trivially parser 
paradigm applied original problem oriented grammar generally obtain quite inecient parser 
overcome de ciency may apply transformations 
due direct correspondence grammars functional parsers transformations may applied grammar parser 
case obtain elegant readable ecient parsers 
right column picture hints property want show 
functional parsers top recursive descent fashion 
entail best achieve respect power eciency behaviour ll parsing 
show transformation process bring lr style behaviour 
longer represented directly formalism context free grammars expected light known theorems language theory expressed easily realm functional programming 
organized follows 
rst introduce version functional parsers sections 
consider transformations need grammars parsers section 
assess potential approach light classical principles lr parsing section 
augmented grammars augmented grammars example 
running example reasonably short exhibits complex issues 
grammar table nonterminal generates odd number stars followed identi er nonterminal generates number stars identi er 
grammar augmented grammar table running example right hand side table added production semantic action denoted fancy symbols grammatically viewed called null nonterminals 
results augmented grammar semantic actions tree generating functions nonterminals grammar types subtrees 
immediately seen shows syntax tree small sample program 
tree types annotated colons simplicity type terminal symbols 
parse tree lemma postorder traversal parse tree identical derivation augmented grammar 
corollary apply language preserving transformations augmented grammar tree preserving respect original grammar 
lemma shown straightforward induction adds minor observation fundamental relationship grammars signatures parse trees elaborated 
allows stay framework languages sentences parsing process need trees 
note literature semantic actions tree generation added point process writing parsers irrespective chosen approach 
functional programming functional parsers usually done parsers 
feel addition grammars clarifying 
approaches introduce tree generating functions front parsers see corresponds preorder traversal trees 
seen course putting opens opportunity ecient lr parsing 
functional parsers paradigm functional programming provides elegant framework writing parsers 
crucial point paradigm grammar parser 
achieved extensive higher order functions called parser combinators usually expressed continuation monadic programming style 
parser combinators prede ned library expressed 
library contains library token combinator library modules provide pertinent combinators 
help user program individual parsers languages consideration 
design scanners special parsers modules quite similar consider viz 

library elaborate actual topic section realization parser combinators demonstrate usage help running example 
give better feeling subsequent discussions 
note program notation oriented functional language opal extended new features shall go version language 
pertains particular overloaded mix operators possibility allowing invisible operators 
functional parsers syntax trees parsing produces trees 
true gist functional programming requires distinguish nodes parse tree types 
typed syntax trees multicolored trees bauer 
simply achieved interpreting nonterminal grammar type see 
running example grammar table obtain type system types syntax trees structure import token type type type type terminal symbols structure token consider import type terminal symbols 
nonterminals grammar types structure directly induced corresponding productions 
names constructor functions 
individual parsers augmented grammar table parsing program polymorphic type parser combinators 
ease reading presuppose precedence invisible sequential composition choice bracketing sequential composition implicitly determined type overload resolution 
parser sample grammar structure import star ide import completely import parser see explanation text fun parser fun parser fun parser def def star def star ide scanners terminal symbols need parser returning tree type parser returning tree type parser returning tree type de nition parser de nition parser de nition parser program little syntactic sugar true copy grammar nonterminal re interpreted function 
directly re ects left vertical arrow 
emphasize ect invisible sequential composition operator traditional see 
details setting elaborated remainder section 
ample literature topic keep presentation relatively short 
functional parsers parser combinators module core approach characteristic papers functional parsing module 
rst give overview module discuss parts detail 
parser combinators structure type parser fun parser parser parser fun parser parser parser fun parser parser parser fun parser parser parser fun parser choice composition composition composition casting module introduces polymorphic type parser number parser combinators 
rst combinator ects choice parsers 
cases special feature need generalized form shown 
overloaded variants sequential composition invisible operator 
invisible casting trees constant parsers completes collection 
type parser rst consider principal type parser 
de nition shows aim full backtrack parsing 
intuitively speaking element type parse function takes input type parser full backtrack parsing structure realizes type parser string set string 
string argument returns multi set possible parsings 
context parsing consists values tree type resulting parsing input far necessary remaining unparsed string 
tree tree generating function rst value pair 
section brie comment aspects design 
parser combinators consider various operators module turn 
section comment relations operators variants literature 
choice 
full backtrack setting choice simply realized multi set union 
functional parsers choice operator def input input input failing variant computed rst problematic obtain empty set need store backtrack information 
successful variant computed rst information kept usually failing computation second 
decisive optimization task detect utilize failures early possible 
sequential composition 
invisible combinators relatively complex 
combine possible parsings rst parser possible subsequent parsings second parser essentially cartesian product parses depend remaining inputs left parsings rst variant application sequential parsers input rst computes set input rest rest parses tree rest remaining unparsed input 
remaining input rest apply parser auxiliary function 
yields set rest rest rest pairs consisting tree generating function remainder input function applied tree yields tree tree generating function type realized program wellknown apply operator reduce operator 
sequential composition fun parser parser parser def input input rest rest rest rest union set sets second variant sequential composition analogous 
di erence rst parser returns tree generating function tree function application combinator replaced function composition variant needed operator left recursion elimination 
sequential composition fun parser parser parser def input analogous third variant classical monad style parser combinator 
cases rst compute set input rest rest parses apply continuation function pair rest rest 
functional parsers sequential composition fun parser parser parser def input input rest rest union set sets casting constant parser 
need means turning tree tree generating function parser 
simply returns singleton set consisting pair input value complete input 
operator yield prefer keep invisible yield input simply reads input 
casting constant parser fun parser def input input casting invisible derived parser combinators 
primitives easily build parser combinators 
example empty parser casting identity function 
ebnf operator aa known 
helpful context 
evidently may connection parsers type parser 
empty iterated parsers fun parser def id fun parser parser def semantic actions 
see semantic actions tree generating functions handled brie review functions running example 
fully parenthesized form reads fun parser def star scheme semantic action type parser 

curried version type constructor reversed arguments 
reversing arguments course closely related classical stack automata 
tokens 
setting scanners special parsers type parser 
need special treatment 
particular failure scanner results empty set 
may ambiguous scanners er choices token 
increasing efficiency transformation semantic actions example fun parser def notes literature principal variants functional parsers vastly di er respect power eciency 
full backtrack parsers 
variant parses context free languages price extreme ineciency 

partial backtrack parsers 
variant parse restricted class context free languages essentially ll languages ecient 
koopman show measurements rst variant times slower space consuming second variant 
concentrate rst variant complete context free power 
exhibits touch context sensitive power 
see transformations allow parsers ecient 
de nition type parser full backtrack variant illustration show partial backtrack variant type parser string 
string partial backtrack parser parse functions return set values tree rest string 
tree type embedded type basically union error indicator 
respect coding technicalities functional parsers nd subtly di erent variants literature 
traditional form uses monad style de nitions swierstra duponcheel referred arrow style programming 
typing discipline requires mainly employ second form di ers slightly add semantic actions rules 
transformations need classical monad style variant 
increasing eciency transformation far straightforward problem oriented grammar directly equally elegant parser shown section 
recall intricate combinators section written away library 
want improve eciency invest transform parser faster form 
pros cons resulting parser ecient 
increasing efficiency transformation parser elegant readable 
apply preprocessing desired program 
particular aspect brings closer paradigm traditional parser generators feature want avoid 
comment section possibilities avoiding ect 
time willing live drawback 
gain eciency utilize paradigm program transformation 
elaborate concept stages 
transformation rules discuss correctness applicability 

simple strategy utilizes transformations gain eciency 
transformation rules rules programming framework 
pointed rules known realm languages grammars 

unfolding 
standard transformation replacement function call body function inlining 
inverse transformation called folding 

associativity commutativity combinator 

pseudo associativity 
rules kind heavily rely overloading invisible sequential composition operator 
rules valid sides type correct 

left recursion elimination 
left recursive de nition eliminated help operator def def solution suited pragmatic transformations 
theoretical treatment section transformation right recursive form appropriate fun parser fun parser fun parser def def def 
left factoring right factoring 
choice expressions start parser factored rule known realm grammars form common subexpression elimination realm programming 
increasing efficiency transformation 
splitting 
unusual transformation rule need 
provide terminating strategy generating lr style parsers 
parsers disjoint types equivalence 
idea choose rst parsers reconstruct decision disjoint result types 
readability shorthand notation expressions type check type casting respectively 
def fi parsers types parser parser type guarded choice 
type parser 
operator goes realm context free languages 
adds touch context sensitivity grammar 
see replace term new nonterminal de ned contextsensitive rules slight context sensitivity trivial type check programming pragmatically reasonable 
operator allow constructively produce ll style parsers lr grammars violating known expressive power results language theory 
lemma transformations correct sense yield semantically equivalent functions 
proof lemma trivial follows directly de nitions various combinators basic facts functional languages 
transformation strategy correctness transformations ensures application harm 
leaves issue nding strategies application achieves useful 
turns simple strategy achieves desired ects 
principal idea follows strategy apply unfolding left factoring choices branches start terminal symbols semantic actions 
illustration strategy example 
running example demonstrate ects strategy 
ease reading repeat original form section 
def def star def star ide increasing efficiency transformation choice 
choice branches start di erent terminal symbols ecient 
remains consider contains branches start nonterminals 
unfold nonterminals def star star ide point encounter need chance left factoring star 
rst extract corresponding subterms way splitting 
reason explained section 
def star star 
ide apply left factoring 
def star 
ide extract resulting choice term newly introduced nonterminal def star 
ide def unfold def star ide star allows left factoring star 
need introduce auxiliary nonterminal choice exists form obtain def star 
ide summing obtain transformed system due unfolding de nitions super uous def star 
ide def star 
ide def star def star ide results ecient ll parser choices start disjoint terminal symbols 
speci cation assessment strategy order assess strategy specify greater detail 
consists normalizing preparation transformation process proper 
preparatory step 
order run pathological situations clean grammar initially original production allows left factoring applied 
increase readability extract choice terms new auxiliary nonterminals 
result productions standard form increasing efficiency transformation def simple sequential compositions 
branches start symbol 
note step may eliminate pathological stu unreachable nonterminals useless productions transformation process 
repeat process long necessary critical choice production starts nonterminal unfold necessary repeatedly leading nonterminals 
starts terminal symbol semantic action left factoring possible subset transformed right hand side apply splitting rule subset apply left factoring splitted term introduce new nonterminal generated choice 
note due new nonterminals standard form retained productions transformation process 
may type dependent switch rst symbol switch deterministic construction 
theorem equivalence grammars directly indirectly left recursive productions transformation process yields equivalent parser 
proof apply equivalence preserving transformation rules transformation process equivalence preserving 
process terminates left factoring preceding splitting yields new nonterminals form trailer right hand side original grammar 
set nite nitely combinations possible 
process necessarily comes 
left recursive grammars considered section 
corollary usefulness construction transformation process yields system essentially ll 
choices start di erent terminal symbols semantic actions case look issue lookahead symbols defer section 
section show method produces ll parsers lr grammars 
note overlapping left possible rst choose longest 
transformation shorter applies 
takes care pathological cases shown example def def def increasing efficiency transformation repeated unfolding form def longest match corresponds common unfolded transformation process turns def 
def step common extracted def 

def def note transformations may generate parser 
ecient strategy dangers parser slightly ecient apply left factoring splitting omit additional type guarded choice 
running example lead situation def star star ide left factoring produce def star ide def need unfolding left factoring def star ide def shows loose termination choice repeats longer longer trailers 
running example quite pathological practical cases termination issue arise 
modi cation basic strategy order obtain ecient parsers apply straightforward unfolding left factoring process original productions 
results group fz new nonterminals 
apply process new productions necessary 
results nonterminals fz forth 
increasing efficiency transformation practical cases groups newly introduced nonterminals smaller smaller left factoring possible new nonterminals created 
cases pathological running example size new group decrease taken sign potential nontermination 
case switch safe basic strategy splitting 
result usually obtain parser minimal small number type guarded choices 
dealing left recursion known left recursive grammars intractable recursive descent parsers lead nite series recursive function calls 
shows approach applying transformation process naively obtain nonterminating series unfoldings 
transformation rule left recursion elimination solve problem 
remains diculty identifying left recursive nonterminals particular recursion indirect 
classical solution problem known algorithm nding maximal strongly connected components directed graph 
lack space go details want sketch example algorithm integrated transformation process 
example consider grammar parser indirect left recursion 
def def def start unfolding process hint origins various subterms gray terms replaced unfolded ones def def def point recognize left recursion matter fact term structure immediately see unfolded de nition def apply left recursion elimination leads right recursive form def def increasing efficiency transformation applied transformation system looked follows def def def def evident de nitions extracted program variant left recursion detected 
transformations standard process apply program facts hold 
corollary left recursion transformation process works grammars left productions context free grammars 
note look traditional lr parsing approach encounter shift reduce reduce reduce con icts 
appear situations kinds shift reduce con ict reduce reduce con ict 

practical cases sequence symbols action determine lookahead symbols directly 
cases sequence empty forcing follow sets 
lack space indulge issue lookahead symbols full detail 
give brief sketch paradigm 
example 
illustrating integration lookahead approach need suitable example import lists occur language opal 
example import import ole structure imported determined subsequent symbol encountered 
identi er list 
language lr lr 
slightly simpli ed grammar table nonterminal start symbol stands nonempty list imports stands import list selected names lexical class names 
denote symbol semantic action stands set tokens token lists 
sequential composition operator extended treats actions assertions input symbol symbols set tentative idea system functions rewritten form increasing efficiency transformation table example lookaheads def def def def def def production added corresponding follow symbol assertion front semantic action de nitions simply terms follow pertinent symbol ignoring semantic actions 
ect describing follow languages 
follow set start symbol knuth original symbol input sign 
useless equations eliminated 
depending grammar hand extract languages symbol lookaheads symbol lookaheads forth 
essentially achieved unfolding 
def def def def def def combining previous transformations obtain system keep follow assertions necessary positions order increase readability def def def def def note production form eliminate lookahead assertion term provides narrower constraint assertion provided long 
approach determines look ahead symbols precisely just lr parsers 
strictly better slr lalr parsers 
experiments show see resulting table sizes equivalent thereof smaller classical lr parsers 
plausible copy productions possible follow symbol denser description follow theoretical result lr ll transformations languages 
unfortunately possess theoretic assessment large gain compared lr tables 
open research issue 
theoretical result lr ll transformations results previous sections partly satisfying 
elegant powerful functional parser constructive automatic transformation strategy improves eciency parser 
clear assessment expressive power degree eciency 
goal necessitates brief look theory grammars parsing 
essence demonstrate transformations yield lr expressiveness ll style parser 
brief comparison ll lr behavior remainder section helpful better understanding principal di erences ll lr style parsers 
abstracting technical details big picture follows 
consider sentential form stage parsing process terminals nonterminals 
box indicates redex production applied 
context particularly nice feature augmented grammars see section need discuss technical di erences tree building top bottom parsers 
point decision 
main di erence approaches point time decisions choice productions particular concerning redex ll parser decision variant shall taken redex read seeing rst symbol lr parser decision proper variant redex read seeing rst follow element lr parser information available pertinent decisions 
reason lr parsing strictly powerful 
history versus 
important di erence concerns organization computation particular kind information kept computation 
consider snapshot lr parser remembers history uses deciding action taken symbol way moves viable pre xes theoretical result lr ll transformations term ends redex 
memoization style optimization parser stores information successive runs 
contrast ll parsers carry continuation parsing function needs applied trailer remember 
power lr parsing fact step function applied trailer determined re analyzing past eciently memoized past 
result proved shows symbol past equally expressive history 
main theorem standard literature nd quite di erent ways characterizing lr parsing class books papers treats problem point view practical compiler construction famous example probably dragon book 
way proceeding embodied called sets items construction 
class takes viewpoint formal language theory example 
embodied concepts handle viable pre telling donald knuth original addresses variants 
disappointing papers books attempt prove equivalence versions 
theorem construction yields ll parser grammar lr 
note deviating traditional techniques parser may employ type guarded choices 
kinds proofs theorem 
rst sketched second elaborated greater detail 
proof formal language view sketch proof 
shown earlier variant approach principal proof formal language view 
sketch 
grammar said lr condition holds reductions uniquely determined viable pre xes 
formally productions rightmost derivations av vw jvj bv property hold initial parts symbols handle terms identical productions formally theoretical result lr ll transformations consider term vw rst derivation 
rightmost derivation leftmost handle words rst semantic action 
de nition lr grammars theorem follows easily 
construction generates productions right hand sides start semantic action disjoint terminal symbols unique chain function calls leading 
vw 
continuation parser 
parse function choice starting transformed grammar ll symbols uniquely determine corresponding branch 
lr criterion ful lled 
converse true 
property ful lled symbol lookahead determines branch uniquely grammar ll 
qed sketch proof shall suce formal language style proceeding 
style sets items construction considered section 
note proof happens apply construction non lr grammar 
corollary construction applied non lr grammar leave ambiguous choices exhibiting shift reduce reduce reduce con icts productions 
produce ecient lr style parsing productions 
words construction produce parser ecient possible retains full backtrack power needed 
proof traditional method sets items construction want show approach allows mimic classical sets items construction 
example 
order discussion readable running example 
ease reading repeat table 
grammar table running example traditional approach deriving lr parsers called sets items construction see table uses dotted rules dot indicates current focus production 
start new production combines original start symbol semantic action rst called kernel item 
form closure recursively add productions nonterminals preceded dot 
newly added rule prepend dot 
closure operation yields non kernel items initial set theoretical result lr ll transformations goto goto goto goto goto goto goto table sets items grammar symbol preceded dot apply function goto shifts dot symbol produces kernel items sets sets apply closure operation example ects goto closure forming recursively applied newly created sets 
process terminates create duplicate sets 
example goto goto refrain discussing extension basic mechanism lookahead forms slr lalr lr 
transformations 
show process mimicked transformations section 
simulation sets items construction requires re ned strategy produces considerably auxiliary nonterminals 
normal form 
dotted rules mimicked auxiliary nonterminals trailers right hand side 
applied sample grammar table leads new grammar table 
easier comparison names parser table normal form auxiliary nonterminals chosen numbering corresponds sets items table 
kernel items nonterminals result transformation particular normal form essence slight adaption known chomsky normal form incidentally basis cocke algorithm 
normal form short nf right hand side semantic action consists symbols terminal nonterminal original grammar newly introduced auxiliary nonterminal 
theoretical result lr ll transformations details normalization process described 
construction immediately entails property lemma auxiliary nonterminals transformed grammar correspondence kernel items sets items construction 
note original grammar contains productions right hand sides start symbol combine construction left factorization order avoid pathological situations 
lemma help prove correctness 
lemma terminal nf right hand sides start di erent symbols 
second normal form 
look closure forming sets items construction 
mimicked unfolding leading nonterminals come original grammar due nf property 
result shown table 
note due unfolding original nonterminals longer needed 
ease understanding transformation process kept pertinent productions gray coloring 
second normal form short nf right hand side semantic grammar table second normal form action form symbol original grammar followed sequence auxiliary nonterminals 
form called greibach normal form 
property evident construction lemma restrict right hand side grammar rst symbols essentially obtain regular grammar describes goto function sets items construction 
grammar speci es language viable pre xes 
essentially due occurrences symbol prohibit immediate backtrack free decision 
call situations nonterminal productions start symbol con icting productions 
note elaborated section construction needs slightly adapted productions shall allowed 
third normal form 
step requires elimination con icting productions done left factoring 
know section need splitting 
result new nonterminal represents continuations symbol 
avoid preprocessing 
unfold lead con icting productions need apply splitting 
choice replaced existing brings transformation process 
result shown grammar table 
resulting third normal form short nf nf grammar 

table third normal form modi cations 
con icting productions 
may type guarded choices 
mimicking sets items construction yields proof transformations provide constructive means turning lr grammars ll parsers extended choices 
strategy leads auxiliary functions original strategy section 
avoid preprocessing concluding presentation want show unpleasant need preprocessing transformation system avoided 
done sacri cing functional programming view 
trick simple application input parsing function token list explicit writing input 
allows consider parser data type turn combinators constructors data type 
longer true spirit functional programming advantages signi cant 
marginal ects look feel parsers 

parser achieves lr style eciency 

need preprocessing 

transformation process may merged lazily parsing process 
aspects evident 
simply means transformation process applied grammar data structure call parser 
topic deserves elaboration 
parser needs rule starts nonterminal unfolding left factoring transformation applied rule 
way potentially costly transformation process applied rules employed parsing process 
principle analogous idea just time compilers example helpful concepts applied parsing user de ned mix operators 
popper new scienti theory better existing explains facts old explains facts ort 
feel approach clearly meets second requirement correctness trivial speedup left factoring backtracking obvious 
belief justi ed experiences students 
traditional sets items construction lr parsing true challenge particularly feared examination topic new style derivation turned topic easily comprehensible exercise 
evidence meet rst requirement 
hand shown approach yields lr parser theorem 
concrete examples see technique goes lalr parsing 
hand evidence lr parsers generated approach smaller space requirements traditional lr parsers repair major de ciency 
unfortunately possess theoretical analysis potential gains depends grammar hand 
strong indications backing optimism concrete examples approach generates lr parsers size corresponding lalr parsers 
measured technique actual grammars pascal obtained results considerably smaller classical lr parsers somewhat larger lalr parsers 
meta argument discussed section follow languages traditional follow sets need generate critical points 
considerable reduction size observe measurements plausible 
remains open issue prove method space ecient classical lr parsing give assessment size potential gains 

approach parsing evolved years motivated desire concepts easier teach student courses 
time people group tu berlin contributed constructive criticism particular stefan weber 
members ifip wg gave valuable hints ideas meetings 
particular go referees numerous helpful essential suggestions improvement 
goguen thatcher wright initial algebra semantics continuous algebras 
journal acm 
alfred aho ravi sethi je rey 
compilers principles techniques tools 
addison wesley 
cai paige 
program derivation xed point computation 
science computer programming 
hill 
combinators parsing expressions 
functional programming may 
hughes 
generalizing monads 
science computer programming 
hutton 
higher order functions parsing 
functional programming july 
hutton meijer 
monadic parser combinators 
functional programming may 
kasami 
ecient recognition syntax analysis algorithm context free languages 
technical report air force cambridge research laboratory 
knuth 
translation languages left right 
information control 
koopman plasmeijer 
ecient combinator parsers 
hammond davie clack editors ifl implementation functional languages number lecture notes computer science pages 
springer verlag 
leijen meijer 
parsec direct style monadic parser combinators real world 
technical report uu cs dept computer science university utrecht 
paige schwartz 
expression continuity formal di erentiation algorithms 
proc 
th acm popl pages jan 
partridge wright 
predictive parser combinators need values report errors 
functional programming march 
pepper 
funktionale programmierung opal ml haskell und gofer 
springer verlag 
pepper 
lr parsing grammar transformation ll parsing 
technical report fachbereich informatik technische universit berlin april 
popper 
logic scienti discovery 
hutchinson 
salomaa 
formal languages 
academic press 
swierstra 
fast error correcting parser combinators short tutorial 
tel barto sek editors theory practice informatics number lecture notes computer science pages 
springer verlag 
swierstra duponcheel 
deterministic error correcting combinator parsers 
launchbury meijer sheard editors advanced functional programming number lecture notes computer science pages 
springer verlag 
tillmann 
new parsing technique yielding functional parser generator power lr grammars 
master thesis technische universit berlin fachbereich informatik sept 
younger 
recognition context free languages time information control 
