self stabilizing universal algorithms paolo boldi sebastiano vigna dipartimento di scienze dell informazione universit degli studi di milano italy 
prove existence universal self stabilizing algorithm algorithm allows stabilize distributed system desired behaviour long algorithm stabilizing behaviour exists 
previous proposals required drastic increases asymmetry knowledge order algorithm additional knowledge require symmetry breaking conditions available stabilizing respect changes topology identifiers assigned processor 
prove tight quiescence time synchronous network processors diameter 
algorithm finite state negligible multiplicative loss 
activation asynchronous propose algorithm quiescence time 
results true wide variety sharedmemory models including unidirectional wireless uniform networks 
system self stabilizing finite number steps deviate specified behaviour 
self stabilization introduced dijkstra celebrated important framework study fault tolerant computations 
ample possibility adversary choosing initial state extremely difficult devise self stabilizing algorithms 
order overcome problem attempts literature build general programs called extensions superimposed distributed protocols underlying behaviour self stabilizing solve classical problems election spanning tree construction 
self stabilizing way 
instance proposes combination self stabilizing global snapshots resets purpose local conditions order initiate global local correction respectively 
previously mentioned methods require additional asymmetry knowledge self stabilizing extension requires distinct process knowledge number nodes network may available 
algorithm described needs unique identifiers requires ability distinguish incident links 
major open problem theoretical importance establish prove impossible existence universal self stabilizing algorithm universal mean algorithm able self stabilize behaviour specified input instance temporal logic self stabilizing algorithm exists conditions asymmetry knowledge 
prove surprising apparently unnatural result viz algorithm exists tight synchronous quiescence time number processors system diameter 
program behaviours calls oracle depending desired behaviour 
algorithm finite state negligible multiplicative loss quiescence time 
asynchronous activation assumed prove quiescence time prove algorithm universal 
conjecture algorithm really quiescence time 
negligible multiplicative loss case state finiteness required 
widely accepted tenet self stabilization difficult coordination problem independently resources available 
show contrary strong bounds imposed resources quiescence time coordination part problem trivial sense completely solved impossible universal algorithm 
order prove results exploit mix classical techniques series results theory anonymous networks 
network anonymous uniform processors identical start initial state indistinguishable 
systematic study networks initiated angluin complete characterization computable networks problems election function computation 
fact theory processors identifiers long initial states observation key proofs 
clearly link anonymous networks self stabilizing systems possible choices adversary start processors state 
sense precise way network self stabilize compute anonymously 
main result obtained steps give result independent interest characterizing predicates computable anonymously class networks 
show universal self stabilizing program converges predicates turning classical algorithms anonymous networks theory self stabilizing ones 
main mathematical ingredient proofs theory graph fibrations allows easy characterization behaviour anonymous networks wide variety assumptions 
results true level knowledge network class networks structural requirement bidirectionality maximum number distinct identifiers 
note upper bounds tight classes instance presence sense direction special case distinct identifiers reduces quiescence time 
note algorithms tolerate dynamic changes network structure time adversary change topology network corrupt identifiers processors long resulting network fits knowledge assumed characteristic particular far know achieved algorithm 
quiescence time desired behaviour restart 
clarity extended restrict simple behaviours specified set safe global states reached 
full show extend techniques general behaviours described fragment temporal logic 
definitions self stabilization adopted corresponds eventually 
restricts heavily kind behaviours considered results synchronous case extend immediately arbitrary behaviours including instance election mutual exclusion topology reconstruction hope able apply methods asynchronous case 
order give idea techniques give detailed proof infinite state synchronous algorithm remaining cases just give sketch proofs 
results mainly theoretical interest large amount information exchanged processors 
provide time general upper lower bounds self stabilization 
obtain characterization behaviours self stabilization possible 
graph theoretical definitions directed multi graph defined nonempty set vg 
vertices set ag arcs functions ag vg specify source target arc shall drop subscript confusion possible 
self loop arc source target 
write arc denote diameter graph dropping subscript confusion possible 
global state graph nodes vector 
shall write graph global state directed tree graph selected node root node exactly directed path root 
tree write height length longest directed path 
trees consider maximal paths length equal height 
write tree truncated height eliminate nodes distance greater root 
model underlying structure network strongly connected graph arc corresponds link processors parallel links self loops allowed 
processor executes step computation changes state certain disagreement literature exact definition 
instance propose different increasingly stronger definitions self stabilization 
standard vertex colouring shall deal arc vertex colouring really global state assignment prefer distinctive name 
way dependent state state neighbours processors link going 
network synchronous processors execute step computation time 
network asynchronous step arbitrary set enabled processors execute step processor enabled fixed point equivalent distributed daemon assumption 
processors take step chosen adversarially algorithm possible activation 
arcs graph representing network local output labelling processor outdegree uses numbers 
labelling arcs 
analogously arcs graph local input labelling kind 
think processors partially aware output input port associated link 
general shall assumption level processor networks cases possible 
describe compactly uniformly arc labelling follows local labellings induce standard arc colouring set vertices adjacent arc contributes colouring number arc labelled source processor target processor get colour 
processor identifier positive natural number smaller equal number nodes network 
identifiers arbitrary need distinct 
formally network strongly connected graph colouring induced local labelling assignment identifiers processors 
program state space transition function set multisets processor takes step computes new state basis coloured neighbourhood relation 
processor identifier state incoming arcs colours 
necessarily distinct sources processors 
need distinct different state 
state 

orbit processor sequence states processor passes computation network 
predicates classes networks predicate set set intuitively predicate specifies subset legal global states networks nodes part local state space 
instance predicate tuples elements equal exactly predicate describing selected processor 
say computed anonymously class networks iff algorithm state space set initial state network terminates computation global state satisfying sense projection belongs processors started 
say self stabilize iff program local state space set network choice initial state global states computation induced ultimately satisfy global state th step satisfies computations 
smallest called quiescence time 
note processor may possess information network belongs 
knowledge represented class greater class smaller knowledge 
common situations studied literature include knowledge network underlying graph number nodes graph theoretical property 
instance case number processors known shall specify algorithm computing program self stabilizing certain predicate networks nodes 
graph fibrations exploit notion graph fibration 
fibration formalizes idea processors connected colours processors behaving way respect colours behave alike 
recall graph morphism pair functions vg vh ag commute source target functions words morphism maps nodes nodes arcs arcs way preserve incidence relation 
colours arcs nodes preserved 
definition 
fibration coloured graphs morphism arc vg unique ea ag ea ea recall topological terminology 
fibration called fibre bundle base fibration 
shall say fibred 
fibre vertex set vertices mapped denoted 
intuitive characterization fibrations concept local isomorphism 
fibration induces equivalence relation vertices classes precisely fibres 
vertices equivalent fibre correspondence arcs arcs preserves colours sources related arcs equivalent 
graph vertex define possibly infinite directed rooted arc coloured possibly node coloured tree follows nodes finite paths root empty path arc node node obtained adding arc arc colour 
tree called universal bundle define graph morphism mapping node path starting vertex arc corresponding arc important property holds lemma 
vertex graph morphism fibration called universal fibration universal bundle tree representing intuitively processor learn interaction neighbours plays le universal covering called view undirected case 
define graph obtained identifying isomorphic subtrees easy verify construction depend choice clearly construct morphism mapping vertex vg equivalence class containing arc corresponding arc note uniquely defined nodes arcs different definitions possible fact irrelevant purposes 
lemma 
graph morphism fibration called minimal fibration called minimum base 
illustrate notions showing graph fig 

graph minimum base universal bundle building universal bundle face problem processor build effective distributed way result step direction lemma 
nodes processors iff isomorphism levels trees 
lemma need trivial bundle graph fibred nontrivially fibration trivial iff isomorphism 
lemma 
graph nodes diameter trivial bundle nodes suppose vg isomorphic level results obtain sufficient conditions processor build minimum base lemma 
processors knowledge upper bound number nodes compute universal bundle minimum base node minimum base mapped minimal fibrations 
proof 
processor starts build computation empty tree 
knowing truncated height neighbours processor build truncated height 
lemma iterations truncated tree far obtained isomorphism classes subtrees height built 
processor knows fibre belongs construction universal bundles coincide sense vg vb universal bundle iff 
lemma 
processor knows build proof 
consider class trivial bundles arcs identifiers appearing class finite definition 
lemma minimum base minimum graph 
note bound tight proved trivial bundles number nodes diameter isomorphic level level 
proved section true asynchronous model case suitable catch clock keeping processors synchronized 
computable predicates order state fundamental theorem characterizing predicates computable class networks need notation lemma 
fibration global state obtain global state lifting global state fibre note computability coincides synchronous asynchronous case 
lemma generalization analogous result proved 
fig 

graphs similar bundles lemma 
fibration 
algorithm computing predicate computes predicate 
proof 
valued graph fibred processors fibre behave identically 
happens local isomorphism property says processors fibre coloured arc terminating starting coloured arc terminating starting processor fibre association colour preserving bijection arcs entering orbits processors fibre exactly equal orbit processor lie 
implies computation global state satisfy condition statement 
theorem 
class networks bounded number nodes predicate anonymously computable iff graphs global state fibrations note global state plays fundamental le follows 
assume oracle subroutine available input returns computability complexity bounds subroutine considered separately 
unlimited computation capabilities assumed processors computable iff follows happens finite 
proof 
condition necessary 
suppose algorithm computing notation lemma note graph empty predicate computed satisfy claim 
hand describe algorithm compute predicate satisfying condition networks firstly processors build universal bundles minimum base lemma 
processor assumes state conditions guarantee self stabilization synchronous case armed results anonymous computability move self stabilization 
order prove theorem introduce notation class networks subclass networks arcs 
theorem 
class synchronous networks predicate anonymously computable finite subclass program self stabilizes steps network nodes diameter 
proof 
algorithm simple step processor builds candidate universal bundle combining neighbours candidates new tree finding maximum setting 
processor finds tentative minimum base trivial bundle see lemma 
tuple theorem processor changes state index stabilization processors upper bound number arcs network going prove 
network running program number nodes diameter 
show steps additional steps nodes know correctly minimum base know universal bundles height see lemma 
minimum level correctness initial state min max 
firstly note steps 
easily shown induction height tree bounded th computation step 
call perfect level node th computation step 
note perfection stable property perfect node remains perfect 
node minimizes level correctness initial state 
computation step perfect 
happens certainly maximum exactly implies note choice neighbours correct levels 
show node perfect neighbour perfect computation step 
happens certainly new tree truncated level perfect neighbour height 
number lower bound correct height step 
immediate computation step finite number nodes perfect perfection propagate network steps 
sake completeness give high level description algorithm algorithm synchronous stabilization predicate class subroutine tree integer graph returns th element enumeration trivial bundles arcs nodes labelled identifiers appearing graphs enumerated way number nodes decreasing subroutine integer tree returns new tree multiset states read neighbours local identifier 
tree root coloured element multiset coloured incoming arc corresponding value extracted appended 
tree truncated length shortest maximal path complete subroutine oracle graph integer vector implements oracle theorem returns const id integer var element tree graph integer vector forever id max repeat oracle loop state characterization theorem 
class synchronous networks predicate self stabilize iff anonymously computable finite subclasses proof 
program self stabilizing finite subclass maximum stabilization time networks processors started fixed arbitrary state define algorithm computing anonymously follows processors start state apply program steps 
clearly resulting global state belong side implication follows theorem 
note asymmetry requirements networks trivial bundles 
reason prove self stabilization desired behaviour 
previous theorem instance allows apply results order establish functions computed self stabilizing way results order establish classes networks admit self stabilizing election protocols 
show bound quiescence time tight 
class networks distinct output labels underlying graphs described section 
class networks nodes 
shall important property lemma 
processor network processor network state steps anonymous computation 
theory anonymous networks know true universal bundles truncated height isomorphic 
going define predicate essentially forces processor discover number 
theorem 
quiescence time predicate 
networks 
proof 
network underlying graph stabilizes steps lemma network stabilize steps 
corollary 
quiescence time predicate 
infinite number networks 
finite state synchronous algorithm algorithm discussed uses unbounded number states 
avoided general possible build predicates finite state algorithm self stabilize 
characterize predicates give universal algorithms finite state case done multiplicative quiescence time loss grows slowly fact slowly log 
formally inverse 
predicate uniform respect iff nonempty clearly uniform predicate anonymously computable finite subclass note case oracle depend theorem 
class synchronous networks predicate computable finite subclass finite state program stabilizes exists iff uniform 
case finite state program self stabilizes steps network nodes arcs diameter 
proof 
sketch second part processor keeps guess levels universal bundle sufficient order build minimum base 
processor builds trees taller 
step update guess setting sup worst case steps processor guess smaller maximum guess initial state steps processor possess correct levels 
processor detect locally correct guess update guess steps processor possess new guess 
number required rounds longer increased 
clearly algorithm finite state network due conditions call oracle depends 
note precise space bound required loss reduced arbitrarily instance updating guess ackermann function smaller loss gap lower bound arbitrarily small 
conjecture universal finite state self stabilizing algorithm quiescence time 

infinite state case processors clock height tree synchronized 
feature allows generalize results predicates temporal logic generally behaviour specified sequence tuples states 
case theorem true 
give finite state algorithm provides processors synchronized clock values constant 
sufficient order self stabilize finite state behaviour network self stabilize ultimately cyclic 
description algorithm full main idea exploit differences values clocks order estimate size network stabilization clocks updated standard catch technique execute algorithm described theorem obtain candidate minimum base local identifiers induced clocks equal increase guess consequently number clock values km stabilize minimum base local identifiers induced clocks certainly minimum base network clocks play le clocks synchronized 
self stabilization asynchronous case section briefly sketch ideas results asynchronous case 
step set enabled processors activated time 
computation initial state sequence 
activated processors course enabled 
convention state network time state just processors activated 
state time initial state network 
denote number times processor activated time 
theorem 
class asynchronous networks uniform predicate program self stabilizes steps network nodes diameter 
associate synchronizing catch clock processor stipulate processor enabled neighbours activation set max 
property clock shall lemma 
time neighbours enabled time 
proof 
note consecutive activations processor neighbours activated 
implies part statement 
second part consider activation 
synchronous case correctness level processor increases time exact number correct levels depends number activations letting max min lemma 

proof 
induction base case trivial 
claim true induction lemma min min 
proves number correct levels ultimately increases 
order prove convergence algorithm introduce net correctness level 
correspondingly minimized version min 
note 
say processor perfect time iff 
lemma 
properties hold 
nondecreasing function 

neighbours enabled time 



constant function 

perfect time 
proof 


lemma min min min min 
obtain 

case lemma implies 



increase processor minimizing activated 
case 

just note 
position prove lemma 
perfect processor correct tree perfection stable 
proof 
lemma 
note equation activated left side lemma right side grow 
activated sides maintain value 
correctness convergence proof follows noting processor minimizing retains property activated perfect 
scheduling statement hold lemma 
steps processors activated times 
steps processors activated steps processors activated possible order 
implies perfect uniform knowledge minimum base sufficient stabilization section 
conjecture algorithm really requires steps quiescence 
full lower bound proved considering predicates fragment temporal logic 
exhibited series preliminary results theory universal algorithms 
aim factor self stabilization problem coordination part showing reduced single algorithm universal turing machine factors computational power recursive functions 
results complete highlight important open problems sketch additional results omitted lack space 
asynchronous algorithm described section self stabilize uniform predicates easy see predicates asynchronous network self stabilize 
conjecture algorithm universal firstly characterize asynchronously computable predicates 
algorithm course finite state techniques section universal predicates characterization problem rises behaviours depending time considered 
theory applied interleaved networks central daemon chooses single processor activated enabled ones 
essentially just considers discrete fibrations characterization theorems fibration discrete iff fibres singletons strongly connected components 
self stabilizing algorithms extended ideas 

yehuda afek kutten moti yung 
memory efficient self stabilizing protocols general networks 
proc 
international workshop distributed algorithms number lncs pages 
springer verlag 

dana angluin 
global local properties networks processors 
proc 
th symposium theory computing pages 

awerbuch patt shamir george varghese 
self stabilization local checking correction 
proc 
nd symposium foundations computer science pages 

paolo boldi bruno peter gemmell janos simon sebastiano vigna 
symmetry breaking anonymous networks characterizations 
proc 
th israeli symposium theory computing systems 
ieee press 

paolo boldi sebastiano vigna 
graph fibrations 
preprint 

paolo boldi sebastiano vigna 
computing vector functions anonymous networks 
structure information communication complexity 
proc 
th colloquium international informatics series 
carleton university press 
appear 
appeared brief announcement proc 
podc 

james burns mohamed gouda raymond miller 
stabilization 
distributed computing 

dijkstra 
self stabilizing systems spite distributed control 
cacm 

shmuel katz kenneth perry 
self stabilizing extensions message passing systems 
distributed computing 

nancy norris 
universal covers graphs isomorphism depth implies isomorphism depths 
discrete applied mathematics 

yamashita kameda 
computing anonymous networks 
proc 
th podc pages 

yamashita kameda 
computing functions asynchronous anonymous networks 
math 
systems theory 
article processed macro package class 
