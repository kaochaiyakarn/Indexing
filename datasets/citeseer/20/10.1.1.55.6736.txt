technical report generating software test data evolution gary mcgraw christoph michael michael schatz rst suite circle sterling va february discusses genetic algorithms gas automatic software test data generation 
research extends previous dynamic test data generation problem test data generation reduced minimizing function miller korel 
function minimized genetic algorithms place local minimization techniques earlier research 
describe implementation ga system examine effectiveness approach number programs significantly larger results previously reported literature 
examine effect program complexity test data generation problem executing system number synthetic programs varying complexities 
important aspect software testing involves judging series test inputs tests piece code 
usually goal uncover faults possible potent set tests test series potential uncover faults obviously better uncover 
unfortunately impossible predict faults uncovered test set 
diversity faults concept fault vaguely defined 
test adequacy criteria meant distinguish test sets bad ones developed address problem 
test adequacy criterion selected question arises go creating test set respect criterion 
difficult hand need automatic test data generation 
introduce gadget genetic algorithm data generation tool uses test data generation paradigm commonly known dynamic test data generation 
dynamic test data generation originally proposed miller investigated korel ferguson korel gallagher narasimhan 
paradigm treats parts program functions evaluated executing program value minimal inputs satisfy adequacy criterion 
way problem generating test data reduces understood problem function minimization 
approach usually proposed performing minimization gradient descent gradient descent suffers understood weaknesses 
appealing sophisticated techniques function minimization genetic search holland simulated annealing kirkpatrick tabu search glover 
investigate genetic search generate test cases function minimization 
past automatic test data generation schemes usually applied simple programs mathematical functions simple test adequacy criteria branch coverage 
random test generation performs adequately problems 
random approach perform realistic test generation problems require intensive manual effort 
results suggest random test generation performs poorly realistic programs 
broader implication due simplicity toy programs fail expose limitations test data generation techniques 
programs provide limited utility comparing different test generation methods 
gadget designed large programs written possible examine affects program complexity difficulty test data generation 
larger programs uncover potentially important difference dynamic test data generation function minimization problems 
larger programs tested coincidental discovery test inputs satisfying new criteria common deliberate detection 
fact ability test data generators satisfy coverage criteria coincidentally play important role determining effectiveness 
random test generation perform experiments expect discovering things coincidence 
guided search performed genetic algorithms appears setting coincidental discovery tests satisfying new criteria 
due fact depending fitness function genetic search concentrate effort fruitful areas input space 
test adequacy criteria test data generation empirical results indicate tests selected basis test adequacy criteria uncovering faults horgan miller demillo mathur 
furthermore test adequacy criteria objective measures quality software tests judged 
benefits realized adequate test data test data satisfy adequacy criteria 
manual generation tests quite time consuming appealing algorithms examine program structure generate adequate tests automatically 
unfortunately test data generation leads undecidable problem possible take test adequacy criterion determine input exists satisfies 
circumvent dilemma practical test data generation algorithms usually resource limitations limitations amount computation time algorithm may expend 
solution resources exhausted algorithm considered failed 
short test generation algorithms succeed finding adequate test input 
comparisons different test data generation schemes usually aimed determining method provide benefit fixed resources 
clearly desirable test data generation algorithms powerful sense capable finding adequate tests 
research specifically addresses need 
code coverage test adequacy criteria test adequacy criteria require certain features program source code exercised 
simple example criterion says statement program executed program tested 
test methodologies criteria usually called coverage analyses certain features source code covered tests 
example describes statement coverage 
slightly refined approach branch coverage 
criterion requires conditional branch program taken 
example obtain branch coverage code fragment thing requires program input causes value variable greater equal value causes value effect requirement ensure thing sections program executed 
hierarchy increasingly complex coverage criteria having conditional statements program 
shall refer hierarchy defining levels coverage 
top hierarchy multiple condition coverage requires tester ensure permutation values boolean variables condition occurs 
bottom hierarchy function coverage requires function called testing saying code inside function 
extremes condition decision coverage criterion test data generation experiments 
condition expression evaluates true false contain true false valued expressions decision expression influences program flow control 
obtain condition decision coverage test set condition evaluate true tests condition evaluate false tests 
furthermore true false branches decision exercised 
put way condition decision coverage requires branch code taken condition code true false 
coverage criteria ask test set fails meet chosen criterion 
cases step try find test set satisfy criterion 
quite difficult manually search test inputs satisfying certain criteria test data generation algorithms automate process 
previous test data generation existing paradigms automatic test data generation 
commonly encountered random test data generation symbolic path oriented test data generation dynamic test data generation 
subsections describe techniques turn 
gadget system describe dynamic test generator 
experiments random data generation baseline comparison 
random test data generation random test data generation simply consists generating inputs random useful input 
problem approach clear complex programs complex adequacy criteria adequate test input may satisfy specific requirements 
case number adequate inputs may small compared total number inputs probability selecting adequate input chance low 
intuition confirmed empirical results including reported section 
example korel random test generation outperformed methods small programs goal obtain statement coverage 
complex programs complex coverages greater problems random test data generators 
random test data generation baseline comparison easy implement commonly reported literature 
symbolic test data generation test data generation methods symbolic execution find inputs satisfy adequacy criterion clarke offutt 
symbolic execution program consists assigning symbolic values variables order come mathematical characterization program 
ideal case test case generation reduced problem solving algebraic expression 
number problems encountered practice symbolic execution 
problem arises indefinite loops number iterations depends non constant expression 
obtain complete picture program may necessary characterize happens loop entered iterates iterates twice ad infinitum 
words symbolic execution program may require infinite amount time 
test data generation algorithms solve problem straightforward way program executed symbolically control path time 
paths may selected user algorithm may generated search procedure 
path fails result expression yields adequate test input path tried 
loops programming constructs easily evaluated symbolically obstacles practical test data generation algorithm symbolic execution 
problems arise data referenced indirectly statement unknown element array referred variables bound specific values 
pointer problem potential aliasing 
consider code fragment results value pointers refer location case assigned value 
bound numeric values symbolic execution final value determined 
technically computable function computed pointers arrays normal practice avoid constructs writing program 
array pointer theoretical impediment symbolic execution complicate problem symbolically executing real programs 
dynamic test data generation third class test data generation paradigms dynamic test data generation introduced miller exemplified system korel korel system gallagher narasimhan 
paradigm idea parts program treated functions 
execute program certain location code reached record values variables location treat values value function 
example suppose hypothetical program contains condition pos line goal ensure true branch condition taken 
find input cause variable pos value greater equal line reached 
simple way determine value pos line execute program line record value pos 
pos denote value pos recorded line program executed input function ae gamma pos pos minimal true branch taken line 
problem test data generation reduced function minimization find desired input find value minimizes 
unfortunately oversimplification line may reached inputs 
common solutions problem 
amend definition large value desired condition reached 
second treat problem reaching desired location subproblem solved minimization commence 
system korel minimization begins establishing goal simply satisfaction test adequacy criterion 
program executed seed input behavior input basis search satisfactory input seed input satisfactory 
subsequent action depends execution reaches section code adequacy criterion supposed hold example reaches line example 
function minimization methods find adequate input value 
code reached subgoal created bring conditions necessary function minimization 
subgoal consists redirecting flow control desired section code reached 
algorithm finds branch responsible wholly part directing flow control away desired location attempts modify seed input way force control execution desired direction 
new subgoal treated way test adequacy criteria 
search input satisfying subgoal proceeds way search input satisfying goal 
likewise subgoals may created satisfy subgoal 
recursive creation subgoals called chaining korel ferguson korel 
korel approach advantageous path reaches desired location code 
test data generation algorithm free choose whichever path wants long force path executed paths may better 
example suppose want take true branch condition suppose default value 
may execution path gives new value different path simply leaves value 
long take path leaves default value able condition true choice inputs default value 
test generation algorithm know select execution path assigns new value system heuristics select path impact target condition 
system gallagher narasimhan entire path specified advance goal test data generation find input executes desired path 
known branch taken condition path conditions combined single function minimization leads adequate test input 
example desired path requires true branch condition line false branch condition line find adequate test input minimizing function ae gamma line ae gamma line unfortunately function evaluated line line reached 
system begins trying satisfy condition path adding second condition condition satisfied 
conditions reached incorporated function algorithm seeks minimize 
test generation system relevant quest ada system chang 
hybrid system combining random testing dynamic testing ada code 
system requires instrumentation ada program hand 
code instrumented ranges types input variables provided system creates test data rule heuristics 
example values parameters adjusted rule increase decrease fixed constant percentage 
test adequacy criterion chosen chang branch coverage 
system creates coverage table branch marks successfully covered 
table provides example branch table 
table consulted analysis determine branches target testing 
partially covered branches chosen completely non covered branches 
strategy explained detail section branch decision true false table sample coverage table chang 
table generated program flow chart 
table provides information regarding covered branches directs test case generation 
adapt approach generator 
coverage table chang relevant research provides strategy dealing situation desired condition reached 
picking particular condition picking particular path strategy opportunistic seeks cover conditions reach 
inefficient wants exercise certain feature code test save quite bit unnecessary wants obtain complete coverage criterion 
independently developed coverage table strategy test generation system 
contributions research described addresses limitations commonly dynamic test data generation systems 
systems difficult generate tests large programs program instrumented hand simplified programming languages 
second systems gradient descent techniques perform function minimization stall encounter local minima problem described greater detail 
limited program complexity drawback quest ada systems 
quest ada requires program test instrumented hand 
allows programs written subset pascal language 
problem limitations prevent studying complexity program affects difficulty generating test data 
demands simple programs naive schemes random test generation appear better 
report gadget test generation system designed programs written 
gadget automatically generates test data arbitrary programs limitations permissible language constructs requirement hand instrumentation 
report test results program containing lines source code excluding comments 
knowledge largest program results reported 
gallagher narasimhan reported system run programs large lines source code results 
ability generate tests programs constructs added benefit allowing study effects program complexity difficulty test data generation 
gadget system uses genetic algorithms perform function minimization needed dynamic test data generation 
respect differs systems gradient descent 
advantage genetic algorithms susceptible local minima cause test generation algorithm halt finding adequate input 
genetic algorithms test generation previously schultz goal achieve certain level coverage 
system sought induce behavior considered software fail 
frequently cited advantage genetic algorithms compared gradient descent methods genetic algorithms stall local minimum portion input space appears minimal 
second advantage paths desired node available 
gradient descent methods concentrate single path implicit parallelism genetic algorithms allows examine paths 
presents simple solution path selection problem described section 
certain limitations common dynamic test generation systems including 
existing systems limited programs inputs scalar types 
furthermore aware dynamic test data generation system intelligently handle true false valued variables enumerated types 
programs variables conditional statements past research 
problem variables examined section spite limitations dynamic test data generation system know run large programs time uses optimization method powerful gradient descent 
take advantage capability examining impact program complexity problem dynamic test data generation 
examine feature dynamic test generation problem analog function minimization problems 
trying satisfy adequacy criteria software perform function minimizations functions minimized correlate program semantics quite similar 
possible solve problem coincidence trying solve 
words test generator find inputs satisfy criterion searching inputs satisfy different 
results suggest serendipitous discovery inputs satisfying new criteria may greatly influence dynamic test data generation 
ability find tests coincidence plays crucial role success dynamic test data generation technique 
examine behavior detail section see serendipity sort observe far arbitrary 
explains fact random test generation ought finding inputs coincidentally performs poorly experiments 
ability genetic algorithms concentrate semantically relevant parts input space evolutionary pressures give advantage comes discovering new inputs accidentally 
similar emergent behavior gas documented kinds problems 
genetic algorithms test data generation gadget draws past dynamic test data generation 
combines function minimization approach miller korel gas avoid problem local minima coverage table chang 
marriage coverage table strategy genetic algorithms particularly advantageous coverage table cheap alternative korel path selection strategy ga examine paths 
combined parallel search strategy may retain advantages explicit path selection computational cost 
function minimization ability numerically minimize function value key dynamic test data generation 
various numeric computation algorithms intended purpose newton method require function relatively smooth 
may case function computed arbitrary section program 
generic methods making stringent assumptions desirable 
simplest methods gradient descent modifies input values way function value decreases 
process stops decrease function value obtained modifications tried 
minimization method suggested korel form gradient descent 
small changes input value initially determine direction making larger moves 
appropriate direction increasingly large steps taken direction improvement obtained case search begins anew small input modifications input longer reaches desired location case move tried smaller step size 
progress different input value modified process terminates progress input value 
global minimum current input value region inputs sought decrease 
illustration local minimum 
algorithm tries find value decrease values immediate neighborhood current algorithm may falsely conclude global minimum gradient descent fail local minimum encountered 
local minimum occurs changes input values considered lead decrease function value value globally minimized 
problem arises possible consider limited number input values small section search space due resource limitations 
input values considered may suggest change values cause function value increase current value truly minimal 
situation illustrated 
problem local minima led development function minimization methods blindly pursue steepest gradient 
notable simulated annealing kirkpatrick tabu search glover genetic algorithms holland goldberg mitchell 
apply genetic algorithm problem test data generation 
genetic algorithms genetic algorithm ga randomized parallel search method evolution 
gas applied variety problems important tool machine learning function optimization 
goldberg mitchell give thorough introductions gas provide lists possible application areas 
motivation genetic algorithms model robustness flexibility natural selection 
classical ga problem parameters represented binary string 
borrowing biology encoded parameter thought gene parameter values gene alleles 
string produced concatenation encoded parameters forms genotype 
genotype specifies individual turn member population 
ga starts creating initial population individuals represented randomly generated genotype 
fitness individuals evaluated problem dependent way case individuals fit closer satisfying new criterion ga tries evolve highly fit individuals initial population 
basic genetic operators selection crossover mutation carry search 
genetic search process iterative evaluating selecting recombining strings population iteration generation reaching termination condition 
basic algorithm population strings generation initialize evaluate termination condition satisfied select recombine evaluate step evaluation fitness individual determined 
evaluation string individual fitness function problem dependent 
determining fitness corresponds environmental determination survivability natural selection case determined fitness function described section 
step selection find individuals mated contribute generation 
selection string depends fitness relative strings population 
individuals selected random individual probability chosen proportional fitness 
known roulette wheel selection 
selection done basis relative fitness 
probabilistically population individuals having relatively low fitness 
third step crossover recombination fills role played sexual reproduction nature 
type simple crossover implemented choosing random point selected pair strings encoding pair solutions exchanging substrings defined point shown 
addition evaluation selection recombination genetic algorithms mutation guard permanent loss alleles 
mutation simply results flipping bits genome flipping bits occurs infrequently 
crossover point parents children single point crossover parents produces children child consists parts parents leading information exchange 
individuals population act primitive memory ga genetic operators manipulate population usually leading ga away unpromising areas search space promising ones ga having explicitly remember trail search space rawlins 
easiest understand gas terms function optimization 
cases mapping genotype string phenotype point search space usually trivial 
example order optimize function individuals represented binary numbers encoded normal fashion 
case fitness values assigned decoding binary numbers 
crossover mutation manipulate strings population exploring space selection probabilistically filters strings low fitness exploiting areas defined strings high fitness 
note search technique subject problems associated local minima described 
gadget genetic algorithm data generation tool section describe approach test data generation genetic search 
recall section approach conversion test data generation problem function minimization problem allows genetic algorithm applied 
details addressed described section find way reach code location want test adequacy criterion satisfied convert criterion function minimized 
reaching target condition 
recall dynamic test generation function minimization performed flow control reaches certain point code 
example seeking input exercises true branch condition line program need inputs reach line function minimization 
approach slightly different korel gallagher narasimhan concentrate finding specific path desired location 
goal things cover branches program 
means simply delay attempts satisfy certain condition tests reach condition 
illustrated code fragment area rule rule order reach condition line test case cause condition line false 
condition line reached condition line condition line false 
goal test generation exercise branches code test cases cause condition true cause false 
achieved branch coverage line test case reaches condition line 
ready looking test cases cover branches decision line 
likewise covered condition line test cases reach line ready looking test cases exercise branches condition line 
leads test generation approach similar employed chang 
table generated keep track conditional branches covered existing test cases 
branch condition taken decision reached ready apply function minimization condition 
branches taken coverage satisfied condition need examine 
branch condition exercised condition reached appropriate apply function minimization search input exercise branch 
code fragment shown situation illustrated table 
table condition line covered true false branches exercised 
false branch condition exercised condition line reached branches decision necessarily exercised 
table shows situation condition line false meaning condition line reached branches condition exercised 
decision true false table sample coverage table chang 
table automatically generated code fragment shown 
tables decide apply function minimization automatic test data generation 
decision true false table similar table showing situation tests taken different combination branches 
table may looking test case exercises true branch condition line exercises true branch line 
conditions reached candidates function minimization 
table shows different situation line reached true branch taken line 
case apply function minimization line test cases reach 
apply function minimization line 
successfully find test exercises false branch condition test reach line 
obtained tests condition line reachable ready function minimization point 
stated gadget performs function minimization genetic algorithm 
ga perform new function minimization condition reach 
example case illustrated table ga cover false branch line 
luck may find tests cover branch may tests cover branches condition line 
happens finished 
hand test cases cover branches line run ga cover remaining branch 
ga works creating population individuals correspond individual test cases 
example input autopilot component test gadget system see section contains input values individual specific list variables ga generating tests problem 
individuals compete natural selection rules 
best individuals retained bred useless individuals culled population 
goodness fitness individual computed function source code dynamic test data generation methods see section 
ga stops situations successful forward progress specified period time 
useful situation ga stops valid test case meeting minimization criteria discovered ga stops condition trying hit false 
may improvement fitness specified number generations 
case ga failed new run tried new random number seed goal changed 
run genetic algorithm condition initial population test cases contains tests reaching condition 
initial population may contain random test cases condition reached sufficiently 
calculation fitness functions 
recall section dynamic test generation involves reducing test generation problem minimizing fitness function step define dynamic test generation techniques begins instrumenting code test 
purpose instrumentation allow calculate fitness function executing instrumented code 
condition add instrumentation report execution reaches condition 
table shows calculated typical relational operators seeking take true branch condition functions false branch analogous 
decision type example fitness function inequality 
ae equality 
jd gamma cj true false value 
ae false program execution fails reach desired location terminates times having executed statement fitness function takes worst possible value 
system seeks generate condition decision adequate test sets conjunctions disjunctions handled exploiting short circuit evaluation 
example second clause condition reached clause evaluates true criterion states second clause true replaced criterion stating second clause reached evaluate true 
clauses reached clauses take value true value false required condition decision coverage branches conditional branch necessarily taken 
execution control gadget system execution controller charge running instrumented code coordinating ga searches collecting coverage results new test cases 
begins executing preliminary test cases 
preliminary cases supplied user generated randomly execution controller 
running initial test cases execution controller uses coverage table find condition reached covered input condition true input false 
genetic algorithm invoked condition take value observed 
ga seeded test cases successfully reach condition give condition desired value condition covered 
ga terminates finding successful test case reaching termination condition execution controller uses coverage table find new condition covered completely 
ga called task finding input covers condition 
process continues conditions value true false subjected ga search 
execution controller keeps track ga runs cover new program code regardless satisfy criterion ga currently working 
words gadget takes advantage serendipitous coverages 
test cases stored 
function minimization modules gadget system currently contains ga implementations 
standard ga crossover low mutation value roulette wheel selection operator 
kind ga described section 
second ga differential ga storn specifically tailored numerical minimization problems standard ga standard ga input represented bit string 
example bit integers represented theta bits 
reproduction proceeds algorithm 
individual receives fitness value obtained section want inputs high fitness fitness value truncating large 

individuals chosen random fitness 
individual probability chosen fitness divided sum individuals fitnesses 
individual chosen times 

crossover point bit string chosen uniformly random 

new individuals created point crossover starting parents selected step 
mutation applied bit new individuals small chance flipped 

highly fit individuals parents children selected 

new individuals added generation identical 
identical randomly generated individual added 

steps repeated new generation number individuals previous generation 
number population size provided parameter genetic algorithm 

steps repeated termination condition satisfied target location hit true false generations produced improvement fitness 
second type ga incorporated gadget differential ga reported storn 
reproduction follows algorithm 
individual population select parent different distinct individuals potential mates 
call 
create new individual plan input variable value copy variable value time 
remaining time create new variable value formula gamma copy 
variables copied verbatim step force variable value chosen random created gamma rule 

better add new generation add new generation 

repeat new generation number individuals previous generation 
number population size 

repeat termination condition satisfied target location hit true false generations executed fitness improvement 
addition gas implemented random test case generation module 
random test case generator plays fundamentally role ga creates new input values entirely random 
values tested see satisfy adequacy criteria simply inputs program recording coverage obtained fitness calculation course 
successful guesses stored increase coverage 
repeated coverage criteria met allocated resources exhausted 
experimental results section report sets test data generation experiments 
set experiments involves programs calculate simple numeric functions 
second experiment investigates gas random test generation perform increasingly complex synthetic programs 
third experiment shows impact coverage level empirical results 
results obtained analyzing real world autopilot control program called 
simple programs began experimentation set simple functions reported literature demillo offutt chang ferguson korel 
programs analyzed ffl binary search ffl bubble sort ffl number days dates ffl euclidean greatest common denominator ffl insertion sort ffl computing median ffl quadratic formula ffl warshall algorithm ffl triangle classification programs roughly complexity averaging lines code having relatively simple decisions 
programs random test data generation outperforms genetic search approaches effectiveness 
results resemble reported chang ferguson korel papers random test generation performed nearly sophisticated techniques simple programs 
random test case generation upper hand experiments involves significantly computation 
case gas performs best 
table shows results 
numbers reported table represent highest coverage obtained series runs 
useful analyze sample program understand gas doing 
code triangle classification shown 
comments right margin show inputs satisfied conditions 
note decisions contain single condition 
program random ga differential ga binary search bubble sort bubble sort number days dates euclidean greatest common denominator insertion sort computing median quadratic formula warshall algorithm triangle classification table comparison test data generation approaches simple programs 
differential ga exhibits best performance significant amount 
data represent highest coverage obtained method series runs 
include stdio int int int int returns triangle scalene triangle isosceles triangle equilateral triangle return acd int tri tri tri tri tri bef tri tri return tri tri tri tri tri tri tri tri tri tri return tri void main printf enter integers sides triangles int scanf int printf triangle scalene printf triangle isosceles printf triangle equilateral printf triangle shows different systems standard ga differential ga random test generation perform triangle program shown 
interesting result experiments gas satisfied test criterion coincidence trying satisfy different criterion 
fact shorter execution time standard ga results largely phenomenon required ga criteria covered 
find recurring phenomenon experiments triangle covered runs ga differential random convergence graph comparing performance gas random test generation triangle program 
graph shows performance terms percentage criteria satisfied improves number runs increases 
random test generation hits peak early fails improve 
differential ga better performance executes longer amount time standard ga best performance covering code average runs 
curves represent pointwise mean performance runs system 
say section 
run number key integer integer integer table table sample input cases generated standard ga triangle 
data mapped conditional expressions code shown key field 
sample results obtained ga test data generation algorithm shown table 
data mapped source code shown letters shown comments 
results random test case generation resemble reported cases code analyzed relatively simple 
chang random test data generation reported cover conditions average 
worst performance program containing decision points outperformed test generation schemes tried 
symbolic execution better performance programs 
ferguson korel reports eleven programs averaging just lines code 
random test data generation fairly successful achieving statement coverage programs averaging coverage 
interesting compare results obtained korel slightly larger programs 
simple branch coverage goal 
random test generation achieved coverage respectively programs analyzed 
symbolic test generation achieved coverage dynamic test generation achieved coverage 
results show common trend random test generation adequate performance programs larger programs demanding coverage criteria performance deteriorates 
programs korel larger chang random test generation poorer performance larger programs 
results reported section small programs test adequacy criterion stringent 
cases triangle program random test generation far adequate resource limitations telling factor final randomly generated tests failed satisfy new coverage criteria 
subsequent experiments larger programs find continuing trend program size program complexity coverage level decrease percentage adequacy criteria satisfied random test generation 
percentage adequacy criteria satisfied random test generation goes programs complex suggestion large programs sheer number conditions covered difficult generate test data 
confirmed experiments examining effects program complexity section investigate role coverage level plays result section 
section examine performance test data generation techniques medium sized real world program 
role complexity second set experiments created synthetic programs conditions decisions characteristics controlled 
characteristics interested controlling deeply conditional clauses nested call nesting factor number boolean conditions decision call condition factor 
example program nested conditional clauses look part triangle program statements nested inside statements 
nature conditional expressions conditional clause controlled second parameter 
decision triangle program ranks scale contains conditions 
classify programs complexity function compl nest cond nest nesting factor cond condition factor 
experiments programs generated complexities compl nest cond nest cond 
experiment reports results differential ga results show conditions account random ga test generation 
fact techniques performed similarly sets compl delta compl delta 
interesting behavior observed increasing nesting complexity time condition complexity complexities compl compl compl 
figures show graphs representing convergence behavior types systems 
ga shows remarkably better performance random test data generation complex cases 
complex programs better ga performs respect random test data generation 
impact coverage level affect coverage level difficulty satisfying adequacy criterion difficulty automatically generating test data demonstrated experiment 
shows coverage levels affect success different test data generation methods 
shows results program see section behavior observed experiments 
general test data generation techniques performed best function coverage demanding criterion 
performance deteriorated techniques demanding coverage criteria 
additionally experiments difficult coverage criteria better able discriminate test generation techniques 
note amount discrimination shown function coverage condition condition decision coverage condition 
clearly deeper levels coverage analysis harder achieve 
nesting complexity covered runs ga random random ga perform relatively equally non complex program 
compl 
nesting complexity covered runs ga random complexity increases ga begins better 
compl 
nesting complexity covered runs ga random high complexity programs hard generators ga outperforms random 
compl 
coverage level covered runs differential function coverage differential branch coverage differential coverage random function coverage random branch coverage random coverage convergence graph comparing performance ga random test data generation different test adequacy criteria 
higher coverage levels cdc increase discriminability approaches provide better analysis data 
real world control software study gadget system program part autopilot system 
code decision points source lines code excluding comments 
generated case tool 
generated tests standard ga differential ga random test data generation 
runs method 
genetic algorithms attempt tune performance adjusting number individuals population number generations elapse improvement gas give 
goal fine tuning maximize percentage conditions covered keeping execution time low 
standard genetic algorithm populations individuals allowed generations elapse improvement fitness seen 
differential ga populations individuals allowed generations elapse improvement fitness smaller number individuals allows generations evaluated number program executions differential ga typically needed generations converges slowly standard ga 
attempted generate test cases satisfy coverage 
note conditional statement may contain conditions condition decision coverage requires conditions take possible values 
stronger criterion branch adequacy requires true false branches conditional statement executed 
tried achieve condition decision coverage gadget 
applied random test data generation program 
program test data generated executed time fitness function evaluated test case 
case random test generation permitted number program executions genetic search 
amounts thousands random tests time fitness function evaluated genetic search 
note random test generation stops making progress quickly 
shows convergence graph comparing genetic random test data generation 
graphs show best worst pointwise mean performance separate runs system 
best performance seen standard ga runs 
run genetic search able ga differential random covered runs ga best worst mean diff 
ga best diff 
ga worst diff 
ga mean random best worst mean convergence graph comparing performance systems code 
curves shown system 
represent best performance pointwise mean runs worse performance 
gas show better performance random test data generation standard ga generally outperforming differential ga achieve cdc code coverage significantly better random test generation achieved coverage 
standard ga performs best mean performance noticeably higher differential ga far random test generation 
little variability performance standard ga performance random test generator differential ga exhibited surprising variability runs 
may caused smaller population differential ga 
fewer individuals population statistical fluctuations fitness cancel 
detailed analysis model runs experiments inputs discovered 
note test criterion satisfied happens genetic algorithm concerted attempt satisfy criterion 
fact criteria satisfied chance imply ga failed satisfy 
fact inputs discovered luck means criteria satisfied chance satisfied 
respect experiments shed light true behavior different ga implementations 
quick look parts source code elucidates behavior 
explain typical individual run standard ga discuss differential ga execution standard ga examine model selected coverage results close mean value coverage results produced standard ga 
executions run sought satisfy adequacy criteria twelve different conditions code 
twelve attempts successful 
remaining eleven attempts showed little forward progress generations evolution 
making attempts ga coincidentally discovered fourteen tests satisfied criteria ones working time 
high coverage level attained due fourteen inputs 
successful executions shortest run times precisely inputs conditions covered chance ga ready working 
stated mean gas failed find inputs concerted attempt 
criteria satisfied chance satisfied ga attempted 
consider typical run differential ga model run differential ga executions involve different attempts satisfy specific criteria 
number attempts depends criteria satisfied order 
executions test data generator 
objective obtained evolution additional input cases necessarily prime objectives ga 
gas failed interesting consider conditions gas successfully covered 
standard ga failed cover conditions index index termination index gain flare flare differential ga failed cover conditions index index termination index op op flare reset decisions covered contain single boolean variable signifying condition true false 
technique define fitness function inadequate condition contains boolean variables enumerated types 
example trying exercise true branch condition simply equal absolute value 
zero condition false positive 
takes values say fitness function values 
valued fitness function allow genetic algorithm distinguish different inputs fail satisfy criterion 
genetic search relies ability prefer inputs valued variables cause problems appear conditions 
experimental results suggest problem real 
improved strategy dealing conditionals ga behavior improve 
gas failed cover conditions containing boolean variables spite fact conditions provide gas useful fitness functions 
conditions covered gas occured decisions containing condition may account gas difficulties 
important bear mind conditions tell story variables appearing condition may complicated functions input parameters 
serendipitous coverage interesting question raised experiment gas success inputs happened chance didn random test generation ought finding things chance perform equally 
believe evolutionary pressures driving ga satisfy criterion strong force system delve deeper semantics code 
means ga necessarily optimal algorithm grinding conditional meet objectives lock step manner finding input cases 
flow control hypothetical program 
nodes represent decisions goal find input takes true branch decision see consider diagram represents flow control hypothetical program 
nodes represent decisions 
suppose input takes true branch condition labeled coverage table strategy gadget attempt find input decision reached input take true branches conditions 
ga starts trying find input takes true branch inputs reach seeds 
reproduction newly generated inputs reach poor fitness values usually reproduce 
reproduction ga tends generate inputs reach ga goal satisfied newly generated inputs definition take false branch reach condition time new input generated reaches possibility exercise new branch contrast inputs generated completely random may reach take false branches conditions random inputs exercise new branches final analysis gas clearly outperform random test data generation real program thousands lines 
encouraging result 
open research issues experimental results open considerable number research issues 
issues heart question test data generation system improved 
specifically system find tests satisfy larger proportion adequacy criteria 
handful issues addressed section potential improve system behavior 
ffl improved handling binary valued variables 
fitness function deal intelligently conditions contain valued variables see section ffl improved handling inputs fail reach target condition 
genetic search generates input fails reach condition currently trying satisfy input simply low fitness value 
input reaches condition way algorithm defined 
assign higher fitnesses inputs closer reaching condition possible breed inputs reach 
ffl special purpose gas 
ga literature concerned investigating special purpose gas parameters mechanisms tailored specific tasks mitchell 
results garnered differential ga versus standard ga comparison suggest investigation designer gas profitable 
research focus ga failure investigate ways avoid running convergence steam test data generation 
done determining exactly differential ga outperforms generic ga ffl path selection 
path selection heuristics choose execution path simplifies test data generation see section 
path selection vital test generation approach may case execution paths better satisfying particular test adequacy criterion 
static dynamic analysis provide clues paths best difficult bias genetic search algorithm solutions paths 
fact korel ferguson korel suggests approach lead noticeable improvement performance 
ffl higher levels coverage 
reported generation condition decision adequate test data 
higher levels coverage may discriminate different techniques 
interesting apply technique multiple condition coverage dataflow mutation coverage measures 
applications test data generators long term number interesting potential applications test data generation related satisfaction test adequacy criteria 
know program capable performing certain action meant 
example safety critical system want know system enter unsafe state 
security concern know program perform undesirable actions constitute security breaches 
standard software testing conceivably perform search inputs cause program fail simply trying exercise features program 
genetic search techniques developing applied areas expect area challenges pitfalls 
knowledge test data generation systems real programs gallagher narasimhan developments possible explore obvious applications test data generators 
ability automatically satisfy test criteria open enormous number new avenues investigation 
reported results sets experiments dynamic test data generation 
test data generated programs various sizes including large compared usually subjected test data generation 
knowledge results largest program reported test generation literature 
salient study ffl performance random test generation deteriorates larger programs 
fact deteriorates faster accounted simply increased number conditions covered 
suggests satisfying individual test criteria harder large programs small ones 
ffl standard genetic algorithm performed best programs differential ga performed better 
programs fairly high degree coverage achieved techniques 
standpoint combinatorial optimization hardly surprising single technique excels problems standpoint test data generation suggests comparatively test adequacy criteria intrinsically hard cover condition decision coverage goal 
criterion difficult cover technique may easier 
ffl serendipitous satisfaction new test criteria play important role 
general successful attempts generate test data satisfying criteria coincidentally 
coincidental discovery solutions facilitated fact test generator solve number similar problems may lead considerable differences dynamic test data generation optimization problems 
results show generating test data successfully accomplished genetic algorithms 
remaining research avenues explore technology fully mature initial experiments working prototype promising 
acknowledgments authors wish curtis walton deborah helpful contributions 
tom connor brian contributed gadget acronym 
research possible national science foundation award number dmi 
opinions findings recommendations expressed publication authors necessarily reflect national science foundation 
chang chang cross carlisle liao 

performance evaluation heuristics test case generation methods software branch coverage 
international journal software engineering knowledge engineering 
miller miller 

applicability modified condition decision coverage software testing 
software engineering journal pages 
clarke clarke 

system generate test data symbolically execute programs 
ieee tse se 
brown chang ii 

rule software test data generator 
ieee trans 
knowledge engineering 
demillo mathur demillo mathur 

uses software artifacts evaluate effectiveness mutation analysis detecting errors production software 
technical report purdue university 
demillo offutt demillo offutt 

experimental results automatic test case generator 
acm transactions software engineering methodology 
ferguson korel ferguson korel 

approach software test data generation 
acm transactions software engineering methodology 
gallagher narasimhan gallagher narasimhan 

test data generation suite ada software systems 
ieee tse 
glover glover 

tabu search part ii 
orsa journal computing 
goldberg goldberg 

genetic algorithms search optimization machine learning 
addison wesley reading ma 
holland holland 

adaption natural artificial systems 
university michigan press ann arbor mi 
reissued mit press 
horgan horgan london lyu 

achieving software quality testing coverage measures 
ieee computer 
kirkpatrick kirkpatrick vecchi 

optimization simulated annealing 
science 
korel korel 

automated software test data generation 
ieee transactions software engineering 
korel korel 

automated test data generation programs procedures 
proceedings international symposium software testing analysis pages 
acm press 
miller miller 

automatic generation floating point test data 
ieee tse se 
mitchell mitchell 

genetic algorithms 
mit press cambridge mass offutt offutt 

integrated automatic test data generation system 
journal systems integration 
ho chen 

automated generation program test data 
ieee tse se 
rawlins rawlins editor 
foundations genetic algorithms 
morgan kaufmann san mateo ca 
schultz schultz grefenstette jong 

test evaluation genetic algorithms 
ieee expert pages 


tabu search applied quadratic assignment problem 
orsa journal computing 
storn storn 

usage differential evolution function optimization 
proc 
pages 

