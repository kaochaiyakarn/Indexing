symmetry model checking allen emerson prasad sistla november structure endowed entity sigma try determine group automorphisms hermann weyl symmetry show exploit symmetry model checking concurrent systems containing identical isomorphic components 
focus particular composed isomorphic processes 
cases able obtain significant exponential savings complexity model checking 
show exploit symmetry model checking 
focus systems composed identical isomorphic processes 
global state transition graph system exhibits great deal symmetry characterized group graph automorphisms basic idea underlying method reduce model checking original structure model checking smaller quotient structure symmetric states identified 
paragraphs give detailed informal account group theoretic approach exploiting symmetry 
precisely symmetry reflected group aut permutations process indices defining graph automorphisms similarly specification formula intended capture correctness particular temporal logic say ctl exhibits certain degree internal symmetry reflected group auto permutations process indices leave significant subformulas invariant 
show group contained aut define quotient structure obtained identifying states orbit equivalence class state space induced usual way exists permutation words permutation indices 
example 
department computer sciences university texas austin usa 
author supported part onr contract semiconductor research contract dp texas advanced technology program 
department electrical engineering computer science university illinois chicago usa 
author supported part nsf ccr 
show quotient structure corresponds coarse sense original structure path analogous path conversely 
correspondence may sufficiently precise directly model check specification stipulate contained aut auto get precise correspondence enabling establish iff formula ctl mu calculus indicates equivalence class emphasize subgroup aut auto sufficient 
take aut auto get maximal compression 
determination potentially difficult problem 
due fact problem computing aut polynomial time equivalent graph isomorphism cf 
ho 
fortunately derived concurrent system consisting isomorphic processes able show aut cr aut cr process communication graph cr follows simple standard pattern aut cr known advance aut cr auto massively parallel architectures aut cr large group reflecting high degree symmetry 
determination auto automatically difficult problem 
auto determined manually examination formula 
automorphism groups determined practice efficiently incrementally compute circumventing construction course accrue advantage model checking smaller structure common advantageous case occurs sym set permutations indices 
system processes local states original structure order states order states 
fixed relatively small large realize exponential savings 
complication occur complex formula little symmetry 
auto may small resulting little compression 
argue frequently beneficial decompose smaller constituent subformulae check individually 
show symmetry individual states exploited gains efficiency 
give alternative automata theoretic approach provides uniform method permitting single quotient aut model checking specifications computing intersecting auto idea annotate quotient guides indicating coordinates permuted state quotient 
automaton designed run paths modified automaton run guides keep track shifting coordinates 
remainder organized follows section give preliminary definitions terminology 
section describe group theoretic approach showing ctl mu calculus model checking original structure reduced model checking quotient structure subgroup aut auto section discuss method applied practice 
includes showing helpful way approximate aut network topology cr establishing aut cr aut discuss optimizations formula decomposition state symmetry 
alternative automata theoretic approach annotated quotient structures described section 
examples section 
section discuss related give concluding remarks section 
preliminaries model computation deal structures form ffl theta finite set states finite set individual process locations set process indices finite set shared variables finite data domain ffl theta represents moves system 
notation convenience state written form indicating processes locations respectively shared variables assigned data values respectively 
usual path finite infinite sequence states consecutive pair states convenient abuse notation denote path gamma 
gamma 
bothering explicitly indicate state finite paths 
fullpath maximal path infinite path finite state lacks successor 
practice ordinary model checking global state transition graph finite state concurrent program form consisting processes running parallel 
may viewed finite state transition graph node set arc node node may labelled guarded command gamma 
guard predicate inspect shared variables local states accessible processes 
action set simultaneous assignments shared variables delta delta delta process local state guard evaluates true current global state global system nondeterministically choose advance firing transition changes local state shared variables arc represents local transition denote gamma 
structure corresponding defined obvious formal operational semantics 
set possible states determined provides set local individual process locations process indices variables data domain states define gamma 
iff process cause move denoted gamma 
iff local transition gamma 
drives means th component equals th component equals components equal corresponding component predicate true 
interested just set states reachable executing starting particular start state natural consider execution program appropriately initialized 
set states reachable smaller set possible states 
important note incrementally generate initialized structure corresponding starting state notation denote set optional case define additional internal organization 
particular depend stipulate guarded command index independent means value guard effect action depend specific values chosen index set particular permuting names indices alter values 
excludes example guards truth value change transposition 
states reachable state single step process propagate adding members various propagate members closing 
see section helpful important generalization idea 
logics programs assume familiarity basic aspects temporal modal logics programs cf 
em mp st 
logic ctl mu calculus 
ctl 
logic ctl uses temporal operators nexttime existential full path quantifier set ctl path formulas generated rules ffl atomic proposition ctl formula ffl ctl formulas xg ctl formulas 
write denote structure fullpath formula true definition specified inductively ffl iff denotes suffix starting ffl iff exists maximal path starting may different ffl xg iff ffl iff ffl iff case ffl iff true state atomic proposition convention indexed atomic propositions cf 
cg atomic formulas treated follows 
local process state process local state state global state form say indexed proposition true global state variable value global state form say atomic formula treat atomic proposition true global state ctl formula boolean combination atomic propositions formulas form called state formula 
note structure starting state satisfy set state formulas 
write say structure state formula true provided starting find convenient standard temporal operators propositional connectives implies universal path quantifier 
operators connectives defined terms basic symbols usual way af abbreviates abbreviates 
logic ctl see ces strict subset ctl restricts temporal operators path quantifiers 
mu calculus 
define syntax semantics propositional cf 
ko ec 
assume set variables members denoted 
formulas mu calculus formed indexed atomic propositions variables propositional connectives modal operator fixpoint operator formally analogous quantifier 
set formulas mu calculus smallest set satisfying properties ffl atomic proposition variable formula ffl formulas formulas ffl formula formula provided occurrences variable scope number negations define semantics need terminology 
variable free formula occurrence scope set variables free denoted free var 
formula free variables called closed formula sentence 
structure 
valuation ae mapping associates subset variable structure formula define function set valuations subsets induction structure follows ffl ae fs pg atomic proposition ffl ae ae ffl fg ae ae ae ffl ae gamma ae ffl ae fs ae rg ffl ae fs ae ae ae ae note value ae fixed point 
finite kripke structures fixed point computed starting empty set iterating jsj times fixed point reached known tarski knaster theorem 
connectives introduced abbreviations abbreviates represents greatest fixpoint abbreviates propositional connectives defined abbreviations usual way 
applicable group theory summarize essential notions group theory needed 
refer reader standard texts discussing topic cf 
additional information 
group set binary operation called group multiplication associative identity inverse group element 
practice write just multiplication may indicated concatenation 
denotes subgroup permutation finite set objects mapping gamma 
set permutations denoted sym forms group functional composition permutations sym ffi sym order functional composition ffi apply apply denotes jg pointwise stabilizer id identity permutation relation indexed object description depends define notion permutation applied denoted 
general obtained simultaneously replacing occurrence index 
example state turn fn cg turn shared variable 


turn turn turn 
roughly speaking define aut set fact group permutations sym equivalent notion equivalence depends type object intended application 
automorphisms states define aut sym sg state similarly define aut sym automorphisms structure define notion automorphism structure 
analogy usual definition graph automorphism labeled directed graphs say automorphism structure mapping gamma 


preserves edge structure gamma 
implies gamma 

preserves labeling states permutation sym initialized require 
observe particular permutation viewed mapping gamma 
vacuously satisfies st rd criteria 
fulfills nd criterion automorphism define aut sym defines automorphism mg 
simply aut sym mg 
automorphisms formulas ctl formula aut sym fg denotes logical equivalence propositional interpretations 
example lip permutation transposing aut fid 
general aut intended capture top level symmetry subset subgroup aut denoted auto capture internal symmetry certain significant subformulas thereof 
internal symmetry subsequently turn vital formulating inductive arguments formula structure proving compression theorem 
auto defined follows ffl propositional formula define auto aut ffl general ctl formula define auto inductively cases 
xg case auto auto case auto auto auto cases conditions hold boolean combination atomic propositions subformulas form xg 
boolean formula atomic propositions subformulas form xg 
replace new unindexed proposition define auto auto auto auto noted propositional formula 
difficult see auto defined ctl formula 
example letting consider ex ex 
definitions get auto auto auto ex considered unindexed proposition considered indexed propositions 
auto bp sym see auto ex sym auto sym alternate way capturing internal symmetry maximal propositional subformulae respect subformula relation define auto aut aut auto consists permutations respecting symmetry major constituent propositional subformulae shown definition auto general auto auto addition formulas containment strict 
formula previous paragraph example 
rest auto mu calculus formula auto defined inductively cases ffl case auto auto ffl case auto sym ffl cases cases written boolean combination indexed atomic propositions subformulas variables form indexed atomic proposition variable subformula form form case define auto auto auto auto unindexed atomic propositions 
note simply propositional formula 
example auto sym quotient construction subgroup sym define equivalence relation jg states jg iff 
equivalence class denoted definition auto es amounts auto defined 
compression theorems new general definition auto true auto replaced old auto es 
advantage new auto general superset old may provide greater compression 
noted auto phi auto phi phi fairness constraint cf 
es 
referred orbit sequel task find subgroup sym subgroup aut respecting symmetry subgroup auto respecting symmetry collapse equivalent states get quotient structure defined 
emphasize subgroup aut auto sufficient application 
largest possible desirable maximal compression 
structure equivalence relation set representatives partition equivalence classes induced exists unique representative quotient modulo specified set representatives gamma 
iff exists exists gamma 
jg denote jg simply group theoretic approach model checking ctl section correspondence lemma results showing model checking ctl formulas original structure reduced quotient structure 
defined 
sequence states denote sequence corresponding representatives 
lemma correspondence lemma bidirectional correspondence paths original structure quotient structure aut path path 
ii path state jg exists corresponding path states jg proof part immediate definition quotient structure 
prove ii path choose arbitrary jg definition quotient structure gamma 
exists jg exists jg gamma 
transitivity jg permutation 
gamma 
gamma 
gamma 
aut jg desired 
edge defined gamma 
continuing argument applied exhibit gamma 
jg proceeding fashion see gamma 
corresponding gamma 
process continues natural numbers terminal finite 
gamma 
gamma 
gamma 
resulting path construction corresponds desired way 
correspondence lemma restricted paths consisting single transition amounts saying bisimulation defined jg ctl formula 
define subset subformulas called significant subformulas follows 
ffl significant subformula 
ffl subformula form xg significant subformulas similarly subformula form significant subformulas intuitively significant subformula outer connective temporal operator path quantifier appears immediate argument subformula outer connective temporal operator path quantifier 
example formula subformulas significant subformulas 
note case atomic propositions significant subformula 
lemma significant subformula auto auto proof significant subformula define immediate significant subformulas follows 
form xg immediate significant subformula form immediate significant subformulas conditions holds boolean expression atomic propositions significant subformula form xg case immediate significant subformulas definition auto condition holds immediate subformula auto auto applying inductively get significant subformula auto auto lemma follows place respectively observation 
correspondence lemma previous lemma easy prove fundamental result showing model checking reduced model checking theorem compression theorem ctl structures ctl formulas subgroups aut auto iff proof argue induction formula structure significant subformula fullpath iff formally count denote number occurrences symbols fu 
proceed induction count letting 
base case count 
case propositional formula 
iff satisfies iff satisfies clearly exists permutation 
lemma fact maximal subformula auto see auto deduce equivalent 
clearly satisfies iff satisfies iff satisfies iff induction step assume lemma holds maximal subformulas count maximal paths maximal subformula count 
cases 
iff exists maximal path starting induction hypothesis fact count follows iff start state case iff induction step follows observations 
xg iff iff iff second step follows induction hypothesis step follows fact definition nexttime 
count count iff induction hypothesis condition holds iff condition holds iff induction step follows observations 
cases case easy see boolean combination atomic propositions maximal subformulas outer connective fx 
boolean expression indexed atomic propositions maximal subformulas outer connective belongs fx count 
induction hypothesis previous cases see iff distinct unindexed atomic propositions 
lemma get auto auto definition auto get auto auto 
auto 
boolean constant defined follows true false 
easy see iff state satisfies iff state satisfies 

clearly satisfies iff satisfies 
auto case auto 
see equivalent 
satisfies iff satisfies 
putting observations get induction step 
model checking mu calculus prove result analogous theorem showing model checking original structure reduced model checking quotient structure define significant subformulas formula follows ffl significant subformula 
ffl variable appearing significant subformula 
ffl subformula form significant subformulas 
technical lemma similar lemma proof left reader 
lemma significant subformula auto auto theorem structure closed mu calculus formula subgroup auto auto state iff statement theorem 
order prove theorem need definitions 
subsets respectively 
say correspond fs jg tg union equivalence classes representative ae ae evaluations having domains ranges power sets respectively 
say ae ae correspond variable ae ae correspond 
proof theorem argue induction formula structure significant subformula evaluations ae ae correspond ae ae correspond 
intuitively asserts significant subformula state structure satisfies respect evaluation ae iff representative satisfies respect corresponding evaluation ae formally significant subformula count denote number occurrences symbols set proceed induction count 
base case count 
case simply propositional formula atomic propositions variables 
lemma case auto auto auto observations easy see lm ae ae correspond 
induction step assume theorem holds significant subformulas count significant subformula count 
cases 
case straightforward induction hypothesis 
ae ae ae ae ae ae sequences evaluations obtained iteratively computing fixed points structures respectively 
formally sequences evaluations defined follows 
ae ae ae ae 
ae ae 
ae lm ae gamma ae ae gamma ae ae gamma ae ae gamma main induction hypothesis induction easily shown ae ae correspond tarski knaster theorem case lm ae ae ae ae 
lm ae ae correspond 
cases case boolean combination atomic propositions variables significant subformulas form atomic proposition variable formula form count 
induction step previous cases show lm ae ae correspond 
observation fact auto auto fm fm unindexed atomic propositions easy show lm ae ae correspond 
theorem follows empty evaluation assigning false variable ae ae applications wish determine global state transition graph arbitrary ctl mu calculus formula incurring potentially enormous cost constructing theorem suffices construct subgroup aut auto check large reflecting deal symmetry common realize significant savings 
determination suitable group take auto subgroup aut calculate determine auto ii largest possible iii intersection ii 
appears difficult problem 
fortunately certain reasonable restrictions computations iii easier 
noted algorithm computing aut propositional formula inductively compute auto arbitrary ctl formula automatic computation aut propositional formula computationally hard problem 
example proposition shows important problems associated aut universality membership non triviality computationally hard problems 
universality problem determine aut sym propositional formula membership problem check permutation aut propositional formula non triviality problem check exists non identity permutation aut proposition problems universality membership non triviality np hard 
proof 
reduce validity problem propositional formulas universality problem 
propositional formula 
number atomic propositions may assume loss generality indexed viz 
may assume exists alphabet distinct propositions indexed appears claim valid iff aut sym valid formula resulting permutation indices propositions valid similarly validity aut sym conversely assume aut sym permutation 
assumption simplifying consider assignment truth values propositions extend assignment propositions set false true respectively assignment evaluate true 
appears conclude valid 
slight modifications exhibit similar reductions problems obvious universality membership problem np np complete 
practice ctl formula auto determined inspection heuristics 
example af easy see auto sym systems determine aut inspection program cases take aut auto take aut auto aut set automorphisms program defined follows 
order define aut define notion equivalences transitions equivalence processes 
recall process comprised set transitions 
say transition equivalent transition boolean expressions semantically equivalent semantically equivalent update variables assign equivalent expressions identical variables 
say processes equivalent exists bijection mapping transition equivalent transition program start state 
permutation process indices 
extend processes follows 
process obtained replacing occurrence index say permutation process indices automorphism equivalent 
aut denote set automorphisms clearly aut forms group 
lemma aut aut global transition graph program start state 
proof permutation aut assume gamma 
gamma 
process local transition driving clearly transition drives 
processes equivalent transition program generating semantically equivalent drives gamma 
gamma 
property holds transition gamma 
conclude aut noting start state may easy determine automorphism group processes normal isomorphic automorphism group underlying communication graph determine appropriate formalize 
concurrent program 
assume shared variable shared exactly processes 
corresponding define undirected graph cr follows 
nodes cr process indices edge connecting iff share variable ij 
shared variable ij equivalently denoted ji node cr denote neighbors say processes normal transition process form cr cr boolean expression atomic formulas atomic propositions equality tests shared variables form ij ij ij variable names name domain element concurrent assignment variables shared form ij ij ij say processes aut cr isomorphic exists bijection mapping transition transition cr cr cr cr noted subscript replaced theorem global state transition graph normal isomorphic aut cr aut proof show aut cr aut lemma follow aut cr aut aut cr 
consider processes processes normal isomorphic exists bijection maps transition form cr cr transition form cr cr aut cr transition equivalent processes equivalent aut designing program choice cr hopes 
explicitly carefully considered chosen standard pattern determination aut cr easy practice frequently just known fact graph theory 
example ffl cr theta id communication topology complete graph aut cr sym ffl processes arranged ring cr phi ig phi denotes wrap addition phi analogously subtraction 
indicates process communicate neighbors ring 
aut cr dihedral group order 
determine intersection auto aut cr proceed inspection 
practice turn auto aut cr large example sym sym fig known permutation group simplifies task 
constructing quotient structure construct start state incrementally building shown cf 
id ly 
important part procedure test jg may worst case aut conceivably intractable cf 
ho 
practice special structure derived simplify matters 
cases test particularly simple 
example sym jg iff number processes local state global states decomposing formulae instances may small essentially large composite formula 
consider example ag afc 
see auto id auto case id compression possible forming quotient possible overcome problem breaking composite formula basic modalities appropriate subformulae checking individually 
may entail computing multiple quotients efficient 
formula specified check conjunct ag afc turn 
auto sym fig exponential size obtained auto large 
computing different exponentially smaller quotients efficient computing large quotient equal full original structure 
state symmetry take advantage symmetry initial states achieve faster model checking 
suppose state fully symmetric fully symmetric structure viz 
aut aut sym example start state solution add unprocessed remove unprocessed ensure ends jg note add unprocessed add gamma 
mark processed incremental construction quotient mutual exclusion problem process noncritical region cf 
ae ec section 
consider formula temporal formula atomic propositions index denotes conjunction process indices shown iff direction obvious 
see direction choose arbitrary pick aut sym right implies permutations due fact permutation aut simplifies desired property previous section checking formula ag afc evaluation multiple conjuncts multiple quotients required initial state structure fully symmetric 
idea generalized states systems somewhat symmetry 
state aut aut induces equivalence relation iff aut aut part partition induced equivalence relation 
rep set representatives equivalence class part 
theorem iff rep proof direction obvious 
see direction assume left hand side holds 
choose arbitrary representative equivalent aut aut 
aut simplifies checking ji conjuncts suffices check conjuncts may significantly smaller 
extreme case conjunct need checked 
aut sym matters simplify jlj number distinct local states need checked 
typically jlj ji aut sym start state process local state aut cr nontrivial equivalence class members savings obtained 
practical cases aut cr may yield small 
vertex transitive connectivity graphs includes sparse graphs rings yields single equivalence class 
automata theoretic approach give alternative uniform method automata model checking temporal properties systems processes exhibit symmetry 
main feature approach single annotated quotient structure subgroup aut model check respect variety different specifications transition annotated quotient structure labelled additional information denoting coordinates permuted state state 
annotated quotient structure succinct representation original structure 
order verify computations satisfy linear temporal specification construct automaton accepts exactly strings satisfy formula construct cross product check product automaton accept input strings 
annotated quotient structure structure ease exposition assumed total 
fix subgroup aut define annotated quotient structure respect denoted ar set representative states ar annotated relation consisting elements 
corresponding transition triple contained ar 
transitions original structure representative state representative state included ar triples permutation identity permutation 
transitions original structure representative state non representative state encoded ar identity 
transitions non representative state non representative state original structure included due times size structure smaller difficult see obtain original structure annotated quotient structure prove simple properties annotated quotient structure annotated path alternating infinite sequence states permutations ar 
define function mapping annotated paths paths follows 
annotated path ffi ffi ffi 
lemma properties satisfied ffl annotated path path ffl path starting representative state exists annotated path 
proof prove part lemma assume annotated path definition easy see properties satisfied transition group automorphisms follows ffi ffi ffi ffi ffi ffi transition path prove second part note write path starting representative state form oe oe oe permutation oe argue induction take oe permutation form ffi ffi ar 
oe definition ar oe 
take oe inductively take oe ffi ffi oe oe ffi ffi gamma ffi oe induction hypothesis oe gamma automorphism ar ffi ffi gamma ffi oe 
take oe ffi ffi ffi completing induction step 
annotated path model checking indexed ctl lemma allows model check properties specified indexed ctl ictl efficiently 
set ictl formulas defined inductively 
assume set ap atomic propositions partitioned sets ap ap ap set global propositions ap set local propositions 
assume set ap indexed set ap indexed set 
global propositions denote global properties state local propositions denote properties individual processes 
element ap indicates property process satisfaction global state depends state process assume states equivalence class satisfy set global propositions invariant propositions 
set ictl formulas defined inductively propositional connectives atomic propositions quantified formulas form ef ef propositional linear temporal logic pltl formula uses global propositions local propositions process symbol acts existential quantifier ranging processes indices 
similarly acts universal process quantifier 
acts existential path quantifier 
stipulate local propositions appear scope process quantifier 
lemma equivalent states satisfy set ictl formulas 
proof states ictl formula satisfies iff satisfies 
roughly speaking property satisfied due fact tree rooted state obtained tree rooted replacing state tree state 
addition ictl formula case equivalent 
satisfies iff satisfies lemma give procedure check representative state satisfies ictl formula 
furthermore give procedure ictl formulas form ef ef show model check type formulas annotated quotient structure 
indicated previously automata model checking temporal properties 
buchi automaton infinite strings quintuple sigma ffi finite set automaton states sigma input alphabet ffi theta sigma transition function set initial states set recurrent states 
run automaton input sigma infinite sequence automaton states ffi 
say run accepting iff recurrent state occurs infinitely run 
say input sigma accepted iff accepting run construct buchi automaton corresponding pltl formula check path accepted 
input alphabet set subsets local propositions global propositions 
construct directed graph product annotated structure automaton nodes triples form state automaton process index 
edges transitions defined follows 
transition form ar automaton state process index going edge node node gamma state transition state input set global propositions satisfied local propositions satisfied process component say node recurrent node iff recurrent state initial state lemma properties hold ffl formula ef satisfied state structure iff exists infinite path starting node containing infinitely recurrent nodes 
ffl formula ef satisfied state structure iff exists infinite path starting state containing infinitely recurrent nodes 
proof prove part lemma 
second part proved analogously 
assume formula ef satisfied state path process index satisfies formula accepting run path 
lemma know exists annotated path define sequence process indices gamma ffi gamma gamma ffi ffi gamma 
definition shown sequence path path contains infinitely recurrent nodes addition prove direction part path contains infinitely recurrent nodes construction see exists annotated path gamma gamma transition state gamma input set global propositions local propositions satisfied process gamma state gamma ffi ffi 
lemma see path difficult see run sequence sets local propositions satisfied process path addition run accepting run 
path satisfies consequence see satisfies ef checking exists infinite path starting particular node containing infinitely recurrent nodes accomplished checking exists finite path strongly connected component containing recurrent node 
property checked standard graph algorithms linear time complexity size graph 
number nodes graph number states automaton number processes 
obtain standard tableau construction pltl case going order jf 
model checking indexed pltl previous construction buchi automata check properties involving local propositions single process global propositions 
buchi automata checking properties may involve local propositions process global propositions 
input alphabet automata subsets set atomic propositions ap 
define particular type automata called symmetric automata 
need definitions 
ap permutation define set ap fp 
essentially obtained changing indices local propositions permutation 
say automaton ap ffi symmetric respect group permutations exists group action theta satisfying properties ffl ap ffi iff ffi 
ffl iff iff procedure checking exists path original structure accepted symmetric automaton procedure model checking powerful linear temporal logic called indexed pltl short 
structure automaton symmetric respect group permutations function defined 
construct annotated quotient structure ar respect group permutations aut define graph follows 
nodes pairs form set edges defined 
transition ar ffi subset atomic propositions satisfied state structure edge node node gamma 
recurrent node node form recurrent state lemma easily proved symmetry property automaton 
lemma exists path starting representative state accepted iff exists infinite path starting node initial state containing infinitely recurrent nodes 
show lemma model checking powerful indexed temporal logic called 
order define syntax assume sets propositions ap ap denoting global local propositions 
local propositions indexed 
ap denote ap ap define set pltl formulas set atomic propositions ap set pltl formulas subset ctl consisting ctl formulas ap path quantifier pltl standard linear propositional temporal logic 
extension pltl allows process quantifiers form symbols include pltl index variables types process quantifiers 
say index variable free formula occurs index local proposition occurrence scope process quantifier form form set formulas smallest set satisfying conditions 
global proposition formula local proposition symbol index variable formula formula xf formulas formula free index variable formula 
closed formula free index variables 
fix set process indices ng 
semantics formulas defined translation pltl 
translation maps formula pltl formula inductively 
translation achieved expanding process quantifier obvious way 
noted resulting formula indices local propositions constants 
shown closed formula aut going full symmetry set sym formula annotated structure method checking paths original structure starting state satisfy formulas 
construct automaton corresponding pltl formula automaton obtained directly tableau associated see es 
automaton shown symmetric respect full symmetry group sym construct product graph obtained product automaton check infinite path starting node form contains infinitely recurrent nodes initial state automaton clearly annotated quotient structure constructed complexity remainder procedure simply proportional product size quotient structure size automaton size exponential length length exponential length complexity procedure going proportional size annotated structure smaller size original structure 
example consider simple example 
solution mutual exclusion problem 
process noncritical section corresponding location critical section represented location transition guarded predicate process cycles sections preserving property mutual exclusion processes critical section time 
expressed ctl formula form ag 
solution safe 
starting condition captured verify mutual exclusion system processes fixed build global state transition graph states 
communication relation complete graph nodes aut sym 
rules tell aut sym take sym 
representatives obtain quotient shown 
model check quotient theorem 
related done various bisimulation equivalences relationship program logics 
considers automorphisms formula theorem established existing works 
contains results including formula decomposition state symmetry alternate automata theoretic approach 
telling quote hermann weyl shows basic idea exploiting group automorphisms structure order understand basic properties symmetry old mathematics 
application temporal logic model checking quite new 
realm program verification symmetry utilized varying degrees formality realm reachability analysis petri nets cf 
jr 
centered simple reachability agp full range temporal correctness properties 
ip dill id consider problem verifying reachability arbitrary correctness specification note auto may sym temporal logic formula 
system provides new somewhat usual programming language facilitate identifications 
implemented mur phi system applied examples 
ags ku algebraic approach reducing cost protocol analysis quotient structures induced automorphisms proposed 
example symmetry alternating bit protocol factored reduce size state space half 
directly related clarke jha independently reported correspondence results similar section follow somewhat similar strategy cf 
bcg st 
implemented ideas bdd provided analysis complexity bdd manipulations permutation groups showing testing jg graph isomorphism hard bdd representations done practical examples 
formula decomposition state symmetry alternative automata theoretic approach 
done symmetries petri nets st computing reachability graphs nets 
consider checking temporal properties reduced graph 
elegantly combines symmetry method techniques stubborn sets achieve state space reduction petri net analysis deadlocks ada tasks 
may distinguished general explicit correspondence results including ctl mu calculus focusing symmetry induced having identical processes allows reduce difficult problem computing aut aut cr 
permit auxiliary variables exploit formula decomposition state symmetry provide alternative automata theoretic approach 
described framework model checking forming quotient structure modulo subgroup group automorphisms original structure specification 
resulting reduction size dramatic degree symmetry high 
group automorphisms structure depends process network topology possibly crucial factor 
massively parallel systems high connectivity high symmetry hypercubes get savings 
rings get 
shown improve efficiency decomposing large formulae smaller subformulae 
shown possible exploit symmetry individual states avoid redundant computation 
alternative approach automata track shifting indices 
noted focused systems isomorphic processes nature restriction systems terminology 
excepting example theorem showing aut cr aut basic mathematical machinery applicable systems containing multiple isomorphic components 
really essential symmetry state space physical systems source 
method fully automated 
obviously naive algorithms compute automorphism groups general efficient 
important open problems identify useful special cases aut various objects provably calculated efficiently related problem testing jg efficiently cf 

course largely group theoretic nature 
vast literature computational group theory helpful cf 
ho 
interim compiling catalog helpful special cases 
acknowledgments historical thinking problem time 
correspondence lemma encountered difficulties 
event paul attie steve kaufman valuable suggestions 
earlier version es international conference computer aided verification held crete greece june 
programme committee chair permitting submit officially announced deadline fact submissions including 
ed clarke hoare jha bob kurshan valuable comments earlier versions 
ae attie emerson synthesis concurrent systems similar sequential processes proc 
th annual acm symp 
principles programming languages austin pp 

aps aggarwal kurshan calculus protocol specification validation protocol specification testing verification iii west ed pp 
north holland 
bcg browne clarke grumberg characterizing kripke structures temporal logic theoretical computer science vol 
pp 

bcg browne clarke grumberg reasoning identical processes inform 
comp vol 
pp 
april 
ce clarke emerson clarke emerson design synthesis synchronization skeletons branching time temporal logic proc 
workshop logics programs yorktown heights kozen editor lncs springer verlag pp 
may 
ces clarke emerson sistla automatic verification finite state concurrent systems temporal logic specifications practical approach proc 
th annual acm symp 
principles programming languages austin pp 
appeared acm transactions programming languages systems vol 
pp 

clarke jha exploiting symmetry temporal logic model checking proc 
th international conference computer aided verification greece pp 
june 
buy 
state space methods deadlock analysis ada tasking proceedings international symposium software testing analysis pp 
acm june 
ec emerson clarke branching time temporal logic synthesize synchronization skeletons science computer programming vol 
pp 
dec 
em emerson temporal modal logic handbook theoretical computer science vol 
formal models semantics van leeuwen editor elsevier science publishers pp 

es emerson sistla deciding full branching time logic information control vol 
pp 
june 
es emerson sistla symmetry model checking proc 
th international conference computer aided verification greece pp 
june 
es emerson sistla utilizing symmetry model checking fairness assumptions university texas austin computer sciences tech 
report tr april 
topics algebra xerox ho hoffmann graph isomorphism permutation groups springer lncs 
id ip 
dill better verification symmetry proc 
th symposium computer hardware description languages april 
jr jensen rozenberg 
eds high level petri nets theory application springerverlag 
ko kohavi switching finite automata theory mcgraw hill 
ku kurshan testing containment omega regular languages bell labs tech 
report conference version kurshan reducibility analysis coordination springer verlag 
ly lee yannakakis online minimization transition systems th acm symposium theory computing victoria canada pp 

mp manna pnueli temporal logic reactive concurrent systems specification springer verlag 
st reachability analysis petri nets symmetries syst 
anal 
model 
simul 
verlag 
st stirling modal temporal logics 
handbook logic computer science gabbay ed pp 
oxford weyl symmetry princeton univ press skeleton state process mutual exclusion gamma gamma gamma gamma gamma gamma psi gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma psi 
gamma gamma gamma gamma gamma model state process mutual exclusion gamma gamma quotient model state process mutual exclusion 
