proceedings conference logic computer science 
ieee computer society press type effect discipline jean pierre talpin pierre jouvelot centre de recherche en informatique ecole nationale sup erieure des mines de paris rue saint honor cedex france talpin fr jouvelot fr type effect discipline new framework reconstructing principal type minimal effect expressions implicitly typed polymorphic functional languages support imperative constructs 
type effect discipline outperforms polymorphic type systems 
just types collections concrete values effects denote imperative operations regions 
regions sets possibly aliased memory locations 
effects control type generalization presence imperative constructs regions delimit observable side effects 
observable effects expression range regions free type environment type effects related local data structures discarded type reconstruction 
type expression generalized respect variables free type environment observable effect 
type inference process automatically reconstructs type expressions programming languages 
polymorphic type inference functional languages problematic presence imperative constructs investigations devoted issue :10.1.1.12.9871
polymorphic effect systems allow safe integration imperative programming features functional languages 
just types describe expressions compute effects describe expressions compute statically reconstructed 
introduce type effect discipline new framework reconstructing principal type minimal effect expressions implicitly typed polymorphic functional languages support imperative constructs 
just types structurally collections concrete values regions sets possibly aliased memory locations effects denote imperative operations regions 
effects control type generalization presence imperative constructs regions report observable side effects 
observable effects expression range regions free type environment type 
effects related local data structures discarded type reconstruction 
type expression generalized respect variables free type environment observable effect 
introducing type effect discipline define dynamic static semantics ml language prove consistently related 
reconstruction algorithm computes principal type minimal observable effect expressions 
prove correctness respect static semantics 
section presents related 
describe dynamic section static section semantics language 
state static dynamic semantics consistent section 
reconstruction algorithm section 
algorithm shown correct respect static semantics section 
concluding give examples section show approach surpasses previous techniques 
extended version contains detailed proofs skipped space reasons 
related short ad hoc techniques type inference systems imperative type discipline classical way deal problem type generalization polymorphic functional languages presence non referentially transparent constructs 
extension weak type variables implementation standard ml 
different approach suggested consists labeling type function set types value identifiers occur body track dangerous type variables side effecting operations performed 
approaches build conservative approximations value types may accessible global store 
inferring keeping track types values store long subject investigations 
effect inference allows approximate store regions types decide perform type generalization 
fx system suggests static semantics polymorphic type effect checking 
authors show effect reconstruction seen constraint satisfaction problem 
exact matching effects required static semantics explicit polymorphism imply non existence syntactic principal types somewhat limits kind accepted programs 
algorithm computes maximal type minimal effect expressions subsumption effects overcome previous problems 
contrarily integrated approach resort criterium perform type generalization 
type effect discipline determine principal type minimal observable effects expressions 
effect information perform type generalization 
effect information alleviates need syntactic criteria decide type generalization performed 
specifically effect information observation criterium type system able precisely delimit scope operations allowing type generalization performed expressions efficient uniform way previous systems 
shown simple examples section system improves earlier type generalization policies ml languages 
dynamic semantics syntax exp language expressions consist identifiers defined id lexical bindings class functions lambda applications 
computable values unit value values closures hx ei 
closures composed identifier expression body environment environments bind identifiers values 
initial environment binds identifiers new get set imperative functions new get set respectively initialize dereference assign values 
ref store action env id fin value closure id theta exp theta env value fug closure fnew get ref action init ref value read ref write ref dynamic semantics language similar core ml extended imperative constructs 
set rules inductively defines relation evaluation structure expressions 
store environment associate expression value new store note ex excluding binding fx 
vg lambda hx ex ex fx 
vg hx fx 
store represented set memory allocation side effect events 
records initialization location value init read write side effects performed execution 
note dom fr init sg domain store store excluding init 
say store extends noted iff dom dom 
new dom get init fread set fwrite init static semantics presentation static semantics requires formal definitions regions effects types 
ffl domain regions ae consists disjoint union countable set constants variables fl 
data structure corresponds region static semantics region abstracts memory locations allocated run time 
values region may share memory locations 
ffl basic effects oe constant represents absence effects effect variables store effects init ae read ae write ae approximate memory side effects region argument ae 
init ae denotes allocation initialization mutable location region ae value type effect read ae describes accesses region ae write ae represents assignments values region ae 
effects gathered infix operator denotes union effects effects define set algebra 
oe init ae read ae write ae oe oe equality effects defined modulo associativity commutativity idempotence neutral element 
define relation subsumption effects oe oe exists effect oe oe oe oe expression effect 
represents abstraction store transformations evaluation expression may perform run time 
effects specific region range allocation 
allocation effect init ae instance incurred new called records region ae allocated initialized type referenced value 
ffl domain types composed finite terms constant unit describing type commands type variables ff types ref ae region ae values type function types oe latent effect oe 
latent effect function effect incurred function applied encapsulates side effects body 
unit ff ref ae oe ffl type schemes ae defined types quantified set type region effect variables ae type instance ae noted oe ae exists substitution defined ae substitutions map variables types regions effects 
note composition substitution id identity 
type environments map identifiers type schemes 
rules oe static semantics associate expression possible types effects oe var oe oe ex fx 
gen oe oe oe oe abs ex fx 
oe lambda oe app oe oe oe oe oe oe sub oe oe observe oe oe syntax directed inference system obtained performing subsumption effect abs rule applying observe function rules app 
generalization generalization type performed boundaries type region effect variables ae occur free variable generalized free type environment observed effect oe 
condition standard pure functional languages 
second just types bound identifiers environment types bound regions reconstructed allocation effects 
regions observable context environment returned value type types generalized 
gen oe fae fv fv fv oe ae function fv returns set free variables type effect environment terms 
define function fr returns set region constants variables occur type effect terms 
observation type generalization side effects affect context expression worth reporting observe oe set observable effects oe 
consists side effects occur free side effects form init ae read ae write ae ae occur free observe oe oe fv fv ae read ae write ae oe ae fr fr effects oe non observable enclosing context 
reported local associated freshly created exported expression 
criterium similar notion effect masking 
initial environment static semantics initial environment binds appropriate type schemes imperative constructs new get set 

ref ae ff ff write ae unit get 
ref ae ff read ae ff new 
ff init ae ff ref ae ff consistency theorem section state static semantics consistent respect dynamic semantics 
define store models relate dynamic stores static effects memory location associated unique static region 
definition store models store model function maps dynamic values static regions 
say extends noted dom 
define recursive structural relation relates dynamic values types 
recursive definition defines collection relations 
shown definition regarded fixed point equation relation values types interested greatest fixed point definition consistent types consistency relation oe values types respect store model store effect oe recursively satisfies ffl oe unit ffl oe ref iff init oe exists init oe ffl oe hx ei iff exists lambda oe note oe dom dom oe dom type oe 
set tuples oe consider complete lattice 
relation oe values types maximal fixed point operator defined property defined 
say set consistent types values effects memory stores 
counterpart previous relation types values relates effects stores store model definition consistent effects store effect oe consistent respect store model noted oe iff read read oe write write oe init init oe oe order induction consistency proof need check relation type value correct pair preserved store properly expanded 
lemma side effects suppose oe oe oe oe oe oe substitution lemma states proof oe static semantics stable substitution 
lemma substitution oe oe substitution 
lemmas properties typing judgments form oe substitution 
lemma semantics substitution oe oe substitution 
lemma states judgment oe stable substitutions range variables observable 
note observe oe observe fg oe 
lemma observable substitutions oe substitution dom fv fv observe oe oe consistency theorem dynamic static semantics ensures expression value evaluates type 
similarly expression store modifications performs observable effects 
theorem consistency assume oe oe oe exist store model extending unobservable effect oe satisfying observe oe oe oe oe oe oe oe proof sketch proof induction length dynamic evaluation constructive inductively determines oe outline case construct 
assume oe oe rules state oe definition rule dynamic semantics ex fx 
vg rule static semantics exist type effects oe oe oe oe oe verifying oe ex fx 
gen oe oe note gen oe ae definition gen know ae fv fv oe fv lemma observable substitutions value want ensure ae observable initial store effect oe order get fv fv observe oe fv fv oe fv rename variables ae occuring observe oe substitution fae 
ae ng ae ae ae fv observe oe ae new fv oe oe oe fv 
note substitution lemma get oe induction hypothesis exist extending unobservable effect oe observe oe verifying oe oe oe oe oe oe fv fv observe oe fv fv observe oe subsets fv fv oe fv substitution defined ae get dom fv fv observe oe oe oe lemma observable substitutions get oe oe oe lemma sideeffects oe oe oe definition oe oe oe ex fx 
vg ex fx 
ae induction hypothesis exist extending unobservable effect oe observe ex fx 
ae oe verifying oe oe oe oe oe oe oe oe oe oe note oe oe oe oe oe oe oe oe oe observe oe 
proved exist extending oe observe oe verifying oe oe oe oe oe oe inference algorithm inference algorithm reconstructs type effect expression respect static semantics 
result inference algorithm satisfies criteria type respect substitution variables effect minimality respect subsumption rule effects 
algorithm uses double recursion scheme separate syntax directed reconstruction types effects process restricting effects regard observation criterium 
constraint satisfaction view inference types effects expression constraint satisfaction problem 
algorithm builds equations types inequations effects 
important invariant method latent effect function represented algorithm effect variable 
problem solving equations amenable robinson unification algorithm type region effect variables 
effect inequation oe represents constraint observed lower bound oe inferred effect variable 
inequations gathered constraint systems built processing lambda expressions place effects introduced types 
constraint sets satisfiable section defines notion formed constraint sets solutions substitutions verify oe inequation oe noted substitution satisfying constraint set exists substitution inductively defined fg id oeg 
oe note definition substitution defined satisfiable 
minimal substitution respect subsumption relation effects derived binding free effect variables satisfiable 
unification equations types built reconstruction algorithm solved straightforward robinson unification algorithm 
fails returns substitution general unifier type terms 
case unit unit id ff ff fff 
ff ff ff ff fv fail fff 
ref fl ref fl ffl 
fl 
syntax directed reconstruction phase reconstruction algorithm returns expression environment type effect oe substitution ranges free variables environment constraint system 
ae fail fae 
ae fae new hid lambda ff new oe ex fx 
ffg ff oe ex fx 
gen oe oe oe oe oe oe ff ff new ff oe oe type environment binds value identifiers constrained type schemes 
constrained type scheme ae defined type constraint set quantified set type region effect variables ae static semantics type schemes consisted type quantified set variables 
algorithm effect variables occur function types constraint sets relate effect variables reconstructed lower bounds kept constrained type schemes 
generalization constraint set function gen generalizes type expression variables free environment observed effects oe 
gen oe fae fv fv fv oe ae constraint set function fv defined fv fv computes set free type region effect variables argument 
similar definition fv static semantics add effect variable set free variables occur lower bounds extended constrained type schemes fv ae fv fae function fr structurally equivalent fv collects free regions 
observation second phase algorithm takes account observation criteria restrict effect oe computed algorithm oe observe oe oe effect variables context observable lower bounds reconstructed may 
observation function observe defined observe oe observe oe determines effects observed surrounding context 
initial environment type effect reconstruction algorithm uses initial environment bind appropriate constrained type schemes imperative constructs new get set 
new ff ref ae ff init ae ff get ref ae ff ff read ae set ref ae ff ff unit write ae solving constraint sets type system effects oe occur types oe types occur effects init ae 
consequence static semantics expressions may rejected require recursively defined types effects effect oe expression may required rule static semantics contain init ae oe 
reconstruction algorithm requirements result constraints oeg init ae occurs oe 
model defined fixed point inequation requiring infinite term substituted init ae 
simplest known example producing ill formed constraint set new new lambda lambda true lambda set new algorithm returns ff ff ff ff write ae init ae ff ff expression typed static semantics 
note effect init ae ff ff observable situation appear 
formulation static semantics authors type system introduces relation function types sets types 
overcome problem specify static semantics closely parallels reconstruction algorithm indirections notion labels function types sets dangerous types representation seriously impedes intuitive understanding type system normally profitable users system 
instance typing new lambda ref int int fintg requires free effect variables 
representation expressions associated closed type term 
limitation serious integrating language module system expressions having closed type accepted module 
function types associated sets type variables order break similar kind cycles occur 
putting free variables type terms arrow function types leads complicated notion substitution impedes easy understanding type system 
previous example get new lambda ref int int system replace effect variable produce correct type ref int int 
resulting effect reflect proper inferred effect 
formulation static semantics advantage allow expression closed type effect 
easily integrated existing module systems 
example get new lambda ref ae int int init ae int int effect inference provides easy understand intuitions semantics programs 
effectively implemented proviso sets checked formedness indirect cycles introduced init effects 
formed constraint sets specify set formed constraint sets acceptable algorithm correspond sound assignments effect variables static semantics 
definition formed constraint set constraint set formed noted wf oe oeg init ae oe fv notation wf extended type schemes wf ae iff wf type environments wf iff wf dom 
reconstruction algorithm course checking formedness constructed constraint set expression typechecked implement extended occurence check test reporting construction ill formed constraints point unifying effect variables 
wf 

fail solution ensure formed oe returned algorithm 
definition formed constraint sets comes lemmas state wellformed constraint sets solvable finite substitutions ill formed constraint sets admit finite substitutions models 
lemma constraint sets constraint set wf wellformed exist finite substitution modeling correctness theorem section prove correctness algorithm respect static semantics 
soundness theorem states type effect computed provable static semantics assuming solution inferred constraints 
note ae ae define extension 
theorem soundness formed type environment 
oe wf oe proof sketch assume oe wf 
substitution modeling oe oe follows substitution lemma 
sufficient prove formed oe wf imply oe 
describe proof case abstraction 
formed assume lambda ff wf oeg 
definition algorithm ex fx 
ffg oe wf fx 
ffg wf induction hypothesis get fx 
ffg oe 
new oe oe oe rule sub fx 
ffg oe oeg 
oe oe fx 
ffg 
definition rule abs get lambda ff subsequent completeness theorem states inferred type principal respect substitution variables reconstructed effect minimal respect subsumption effects 
theorem completeness wellformed type environment 
oe oe exists oe oe 
proof sketch proof induction structure expressions 
fact outline proof case application 
hypothesis oe definition rule app exist oe oe oe oe oe verifying oe oe oe induction hypothesis returns oe exists modeling oe oe oe formed induction hypothesis get oe exists modeling oe oe set free variables oe take ff new define follows ae ae ae ae ff oe ae ae definition models get oe ff ae oe ae fv fv ae new definition ae fv ae ae ae 
ae new ae dom ae ae ae 
get oe oe oe ff correctness unification exists substitution ff verifying ff 
definition algorithm get oe ff oe oe oe general unifier ff exists substitution get oe oe oe oe returns oe oe observe oe 
observe oe observe oe conclude oe oe oe examples demonstrate effectiveness algorithm generalizing types capability assigning similar typings purely functional expressions related variants locally defined mutable data structures consider known examples list processing functions 
introduce type constructor list immutable lists value functions nil ff list ff cons ff ff theta list ff list ff null 
ff list ff boolean car ff list ff ff cdr ff list ff list ff example shows defining function fold temporary affect typing 
extended language syntax multiple binding looping construct 
define fold lambda lambda data new result new null 
get data set result car get data get result set data cdr get data get result ffff ff theta ff ff theta ff 
list ff ff nice consequence function reverse defined terms fold regardless details implementation define reverse fold cons nil ff list ff list ff similar manner define function map reverse imperative constructs 
type usual functional defi nition ml define map lambda argument new result new nil null 
get argument set result cons car get argument get result set argument cdr get argument reverse get result ffff ff ff theta list ff list ff instance application map identity function empty list polymorphic type nil bindings 
map lambda nil ff list ff contrary application map new nil monomorphic type accounting function new region ae observable effect 
map new nil list ref ae ff init ae ff comparison related example quoted shows observation effects useful removing type dependencies introduced dead code 
inference system generalizes type id contrarily ones defined able deal spurious new 
lambda id lambda true lambda new id id table gives comparison series examples adapted survey subject 
figures programs explicit polymorphic types 
define id id rid define id lambda rid id define id nop rid id note rid imperative identity id usual functional identity define tricky function nop 
define id lambda define rid lambda get new define nop lambda lambda lambda benchmark suggests type effect discipline giving type ff ff ff examples favorably competes earlier polymorphic type generalization policies 
example id id id id id id id id id id id id extensions approach easily extended deal recursive function definitions way similar 
amenable integration existing module systems 
continuations appealing direction extensions treatment exceptions continuations shares similar typing requirements values 
define type cont ae continuation values effects ae goto ae allocating invoking continuation 
typing continuations handled manner similar values appropriate types related primitive functions callcc cont ae ff ff ae ff ff throw ffff ae cont ae ff ff goto ae ff observation criterium helps delimit scope captured continuations 
similar way semantics language extended treatment exceptions standard ml 
related features represented functions extension results updating syntax static semantics language 
recursive effects example section handled current type effect system require recursively defined effects static semantics typecheck 
approach recursive types allow recursively defined effects oe added equivalence rule equiv oe oe oe oe addition rule equiv static semantics allow equivalent types effects expression relation 
relation structurally defined type effect terms additional unrolling axiom oe 
oeg oe model mapping init ae ff ff write ae correct assignment example section 
introduced type effect discipline new framework reconstructing principal type minimal observable effect expressions implicitly typed polymorphic functional languages support imperative operations 
initial design goal polymorphic effect systems safely integrate functional imperative constructs 
effect masking showed effect systems put solving type reconstruction problem presence sideeffects 
specifically effect information observation criterium type system able precisely delimit scope side effecting operations allowing type generalization performed expressions efficient uniform way previous systems 
proved language static semantics consistent respect dynamic semantics reconstruction algorithm computes principal type minimal observable effects expressions 
grateful fritz henglein mads tofte diku xavier leroy didier remy inria david gifford mit andrew wright rice university insightful comments valuable feedback 
appel mac queen standard ml manual preliminary 
bell laboratories princeton university october 
coppo type inference recursive types syntax semantics 
information computation vol 
pages 
academic press 
damas type assignment programming languages 
ph 
thesis university edinburgh april 
duba harper macqueen typing class continuations ml 
proceedings acm conference principles programming languages 
acm newyork 
gifford jouvelot lucassen sheldon fx manual 
mit lcs tr mit laboratory computer science september 
jouvelot gifford reasoning continuations control effects 
proceedings acm conference programming language design implementation 
acm new york 
jouvelot gifford algebraic reconstruction types effects 
proceedings acm conference principles programming languages 
acm new york 
leroy weis polymorphic type inference assignment 
proceedings acm conference principles programming languages 
acm new york 
leroy private communication 
december 
lucassen types effects integration functional imperative programming 
mit lcs tr ph 
thesis 
mit laboratory computer science august 
lucassen gifford polymorphic effect systems 
proceedings acm conference principles programming languages 
acm new york 
milner theory type polymorphism programming 
journal computer systems sciences vol 
pages 
milner tofte harper definition standard ml 
mit press cambridge 
mitchell harper essence ml 
proceedings acm conference principles programming languages 
acm new york 
toole type abstraction rules comparison achieved 
technical note group mit laboratory computer science april 
robinson machine oriented logic resolution principle 
journal acm vol 
pages 
acm new york 
sheldon gifford static dependent types class modules 
proceedings acm conference lisp functional programming 
acm new york 
talpin jouvelot polymorphic type region effect inference 
appear journal functional programming vol 
cambridge university press 
technical report emp cri ecole nationale sup erieure des mines de paris february revised december 
talpin jouvelot type effect discipline 
technical report emp ecole nationale sup erieure des mines de paris march 
tofte operational semantics polymorphic type inference 
phd thesis university edinburgh 
wright polymorphic mere 
proceedings european symposium programming 
springer verlag 
