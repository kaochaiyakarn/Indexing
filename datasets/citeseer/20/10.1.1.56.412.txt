formal refinement patterns goal driven requirements elaboration robert darimont axel van lamsweerde universit catholique de louvain partement ing informatique louvain la neuve belgium rd avl info ucl ac 
requirements engineering concerned identification high level goals achieved system envisioned refinement goals operationalization goals services constraints assignment responsibilities resulting requirements agents humans devices programs 
goal refinement operationalization complex process supported current requirements engineering technology 
ideally form formal support provided formal methods difficult costly apply stage 
presents approach goal refinement operationalization aimed providing constructive formal support hiding underlying mathematics 
principle reuse generic refinement patterns library structured strengthening weakening relationships patterns 
patterns proved correct complete 
guiding refinement process pointing missing elements refinement 
cost inherent formal method reduced significantly 
tactics proposed requirements engineer grounding pattern selection semantic criteria 
approach discussed context multi paradigm language kaos method language external semantic net layer capturing goals constraints agents objects actions links inner formal assertion layer includes real time temporal logic specification goals constraints 
frequent refinement patterns highlighted illustrated variety examples 
general principle somewhat similar spirit increasingly popular idea design patterns grounded formal framework keywords goal driven requirements engineering refinement reuse specifications proofs design patterns formal methods 

requirements engineering branch software engineering concerned real world goals functions constraints software systems 
concerned relationship factors precise specifications software behavior evolution time software families 
general definition borrowed stresses leading part played goals requirements elaboration 
multiple reasons goals explicit requirements engineering process 
goals drive identification requirements support provide explanation clients rationale underpinning requirements represent roots detecting conflicts requirements resolving eventually rob provide completeness criterion requirements specification specification complete stated goals met specification generally represent stable information requirements product 
sum requirements implement goals way programs implement design specifications 
surprisingly explicit modelling goals integration goal specifications requirements specifications considered literature 
goals generally modelled intrinsic features type attributes links goals requirements 
various goal taxonomies proposed type goals dar nix ant 
instance information goals functional goals concerned keeping agents informed object states accuracy goals non functional goals concerned maintaining consistency objects environment software image 
useful attributes goal may include priority dar utility rob 
information goal types attributes define heuristics goal acquisition goal refinement requirements elaboration 
links goals aimed capturing situations goals positively negatively support goals 
directly borrowed problem reduction methods artificial intelligence nil graphs may capture goal refinements dar dar 
reduction links relate goal set subgoals called reduction means satisfying subgoals reduction sufficient condition satisfying goal 
reduction links relate goal alter proceedings th acm symposium foundations software engineering fse san francisco oct 
native set reductions means satisfying reductions sufficient condition satisfying goal 
framework conflict link goals introduced satisfaction may preclude satisfaction 
operationalization links introduced goal models relate goals requirements 
weaker versions link types proposed relate high level goals rob idea goals rarely said satisfied clear cut sense 
goal satisfaction goal satisficing introduced express lower level goals requirements expected achieve goal acceptable limits absolutely 
subgoal said contribute partially goal regardless subgoals may contribute positively negatively 
purpose goal modelling support form reasoning goals requirements elaboration 
kinds reasoning distinguished qualitative reasoning formal reasoning 
qualitative reasoning appropriate high level goals 
labelling procedure described typical example done procedure determines degree goal satisficed denied lower level requirements propagating information positive negative support links goal graph 
goal models root requirements engineering processes example boe proposes iterative process model goal negotiation requirements multiple stakeholders 
goal formulations formalized formal reasoning techniques expected qualitative reasoning 
example planning techniques generate admissible system behaviors showing desired goal achieved propose recovery actions fic 
specification exploration debugging expect formal goal models ultimately enable specifiers formally verify goals achieved constructively formally derive requirements specifications satisfy goals specified 
preliminary attempts direction encouraging dar fea lam :10.1.1.56.8810
formal methods increasingly popular stages specification process boundary software environment established set software objects operations precise 
languages proposed capture lower level specifications differ mainly particular specification paradigm 
example languages pot vdm jon object oriented variants lan support state specifications system described logical predicates restrict set admissible states languages dub trio mor support history specifications system described predicates restrict set admissible histories formalisms statecharts har scr sch support transition specifications finite state machine tradition languages larch gut asl ast gau support algebraic specifications system data types specified universal algebras languages paisley gist bal support operational specifications may seen high level programs 
benefit full formalization specifications manipulated formally logical consequences inconsistencies refinements derived theorem proving techniques jon pot geo prototypes produced bal doug test data generated bgm counterexamples claims generated model checking jac partial specifications matched reusable specifications domain libraries reu zar forth 
formal specification techniques date limited respects 
limited scope addressing questions address questions real requirements documents captured goals agents causing events respectively 
poor separation concerns languages allow specifiers introduce strict separation descriptions domain objects operations actual requirements need separation convincingly argued jac 
poor guidance techniques provide welldefined notations support posteriori analysis equipped constructive techniques guiding modelling specification process 
difficulty cost applying methods requires high expertise mathematical logic formal systems due scarcity expertise formal methods industrial projects nowadays limited core parts critical systems 
purpose explore formal technique requirements elaboration upstream specification process supports formal reasoning goals ii constructively suggests ways refining goals operationalizing iii reasonable cost hides proofs underlying mathematics 
general principle reuse generic refinement patterns 
organized rich library various strengthening weakening relationships goal formulations 
patterns proved correct complete reusing pattern entails reusing proof 
tactics proposed requirements engineer grounding pattern selection semantic criteria 
general principle somewhat similar spirit increasingly popular idea design patterns gam grounded solid formal framework 
reuse generic refinement patterns detailed context kaos requirements elaboration methodology dar lam :10.1.1.56.8810
kaos provides multiparadigm specification language goal directed elaboration method 
language combines semantic nets bra conceptual modelling goals agents objects operations system temporal logic man koy specification goals constraints objects state specifications pot specification operations 
supports separation requirements domain descriptions 
method roughly consists identifying refining goals progressively constraints assignable individual agents obtained ii identifying objects operations progressively goals iii deriving requirements objects operations meet constraints iv assigning constraints objects operations agents 
organized follows 
section provides background material kaos methodology 
section introduces refinement patterns framework discusses patterns refining goals subgoals 
section applies principle operationalizing goals requirements stimulus response heuristics 

goal driven requirements elaboration kaos kaos methodology aimed supporting process requirements elaboration high level goals achieved composite system operations objects constraints implemented software part 
term composite system denote intended software environment fea 
methodology comprises specification language elaboration method meta level knowledge local guidance method enactment 
introduce features see dar details various simplifications extensive experience industrial projects 
kaos language specification language provides constructs capturing various kinds concepts appear requirements elaboration goals constraints agents entities relationships events actions views scenarios 
construct type concept 
define types constructs specifying instances introduced 
underlying ontology types concepts sequel 
object object thing interest domain instances may evolve state state 
general specified specialized way entity relationship event object autonomous subordinate instantaneous object respectively 
objects described invariant assertions 
action action input output relation objects action applications define state transitions 
actions may caused stopped events 
characterized pre post trigger conditions 
agent agent kind object acts processor actions 
agent performs action effectively allocated agent knows object states object observable 
agents humans devices programs goal goal objective composite system meet 
refinement links relate goal set subgoals called refinement means satisfying subgoals refinement sufficient condition satisfying goal 
refinement links relate goal alternative set refinements means satisfying refinements sufficient condition satisfying goal 
goal refinement structure system represented directed acyclic graph 
goals conflict 
goals concern objects refer 
constraint constraint implementable goal goal formulated terms states controllable individual agent 
goals eventually refined constraints 
constraints turn operationalized actions objects strengthenings pre post trigger conditions invariants respectively 
alternative ways assigning responsible agents constraint captured responsibility links actual assignment agents actions operationalize constraint captured corresponding performance links 
language constructs construct kaos language level generic structure outer semantic net layer declaring concept attributes various links concepts inner formal assertion layer formally defining concept 
generic structure instantiated specific types links assertion languages specific type concept instance 
example goal appears stage elaboration meeting scheduler system get participants constraints known scheduler 
concept type goal partially declared formally defined follows goal achieve instanceof concerns meeting participant scheduler 
informaldef meeting scheduler know constraints various participants invited meeting days appointment formaldef meeting participant scheduler invited scheduling cd knows constraints declaration part specification states goal concerned keeping agents informed object states ii refers objects participant scheduler iii refined subgoals 
turn constraints assignable single agents fact constraint assignable scheduler agent stated declaration constraint 
formal assertion defining goal written realtime temporal logic borrowed koy 
classical operators temporal referencing state 
previous state eventually time past past 
real time restrictions indicated subscripts cd denotes day time unit 
restrictions considered refinement patterns discussed stick classical temporal logic man 
formal assertion predicate invited means current state instance invited relationship links variables sort participant meeting respectively 
invited relationship participant agent meeting entity declared sections specification agent participant 
constraints tuple timeinterval timeinterval 
relationship invited links participants card meeting card participant meeting invited requesting declarations constraints declared attribute participant attribute formal definition 
note invariant defining invited requirement domain description 
object inheritance course supported agent type introduced specialization participant extra attributes invariants 
mentioned earlier operations specified formally pre postconditions example action input requesting meeting arg output meeting res dompre requesting scheduled feasible scheduled feasible deadend kaos specification outer declaration layer useful requirements traceability semantic net navigation specification reuse queries inner assertion level introduced formal reasoning 
note specifier necessarily need full power button language fact industrial users tend semantic net level concrete graphical syntax available pressing formal button 
elaboration method steps may followed systematically elaborate kaos specifications high level goals 
elaborate goal structure defining goals refinement conflict links implementable constraints reached offspring goals identified asking questions parent goals identified asking questions 
identify objects concerned goals describe domain properties 
identify object state transitions meaningful goals specify domain pre postconditions actions identify agents actions capabilities 
derive additional pre postconditions actions invariants objects ensure constraints met requirements operationalize goals obtained 
identify alternative responsibilities constraints decisions refinement operationalization responsibility alternatives process level objectives resolving conflicts reducing costs increasing reliability avoiding overloading agents assign actions agents commit guaranteeing requirements alternatives selected 
steps ordered data dependencies may running concurrently possible backtracking step 
refinement patterns discussed step 
meta level knowledge step goal driven method domain independent knowledge local guidance validation elaboration process 
rich taxonomy goals constraints objects actions provided rules observed specifying concepts corresponding subtype 
give examples taxonomies 
goals classified pattern temporal behavior require achieve cease maintain avoid goals classified type requirements drive respect agents concerned constraints category may violated category temporarily violated 
actions modify inspect actions modify object states 
taxonomies constrained rules refined knows predicates associated restore 
meta level rules ensure consistency completeness requirements model elaborated 
example declaring constraint appeared refinement goal ditions hold gn entailment 
ji gj minimality 
gn false consistency avoid trivial refinements consisting rewriting logically equivalent forms rule added 
refinement relies domain knowledge 
definition 
refinement pattern level tree goal assertions set leaf assertions complete refinement root assertion 
example refinement pattern proposes way decompose achieve goals subgoals 
pattern generic instantiated completely different situations 
simple instantiation instantiations 
consider train control system studied fea 
functional goal ensure trains move consecutive blocks goal achieve formaldef train block particular case comes directly mind blockb signal set go 
may instantiate meta variable subgoal pattern predicate go formalizing situation refinement subgoals goal achieve formaldef train block go goal achieve formaldef train block go goal maintain formaldef train block subgoal obtained pattern states train stay block block backward moves discarded 
refinement patterns useful reasons 
allow formal reasoning hidden requirements engineer may help detecting incomplete refinements requirements allow choices underlying refinements explicit 
point illustrated turn 
rp prompt question restoration action foreseen case violation result actions reminder giving phone call participants introduced 
tactics capture heuristics drive elaboration select alternatives refine goals reduce number agents involved achievement subgoal favor goal refinements introduce conflicts 
constructive formal support formal derivation rules derive requirements goals 
consider example inference rule 
constraint dompre simple example inference rule consider lift system maintain refines formaldef lift doors floor partof state closed state closed required pre postconditions formally derived rule action input lift arg floor arg passenger arg output dompre requesting state closed state closed 
refining goals subgoals basic idea experience kaos revealed correct goal refinements hard find goal decompositions hand usually incomplete inconsistent lam :10.1.1.56.8810
goal graph usually branches contain implicit choices interesting alternatives may overlooked 
idea provide formal support building goal refinement graphs complete proved correct integrate alternatives 
section introduces domain independent refinement patterns way achieve objective 
patterns proved correct complete pattern designer reusing pattern entails reusing proof mathematics hidden user patterns 
concept refinement refinement patterns carefully defined 
example frequent refinement pattern shown proved 
benefits refinement patterns discussed 
detail contents structure library patterns 
definition 
set goal assertions gn complete refinement goal assertion iff con hiding mathematics patterns proved correct reused times instantiation 
pattern instance proved proof theory temporal logic man follows 
proof 
hyp 
hyp 
hyp 
def 
def 
strengthen consequent 
distribution 
trivial lemma 
strengthen consequent 
idempotence 
absorption temporal logic proofs tend complex simple refinements 
proofs built pattern inclusion library 
pattern may reused requirements engineers need prove instantiations produce correct refinements proofs instantiated accordingly 
checking refinements completeness refinement patterns check decompositions complete refinements 
way patterns important experience intuitive refinements hand tend incomplete lam :10.1.1.56.8810
incomplete goal refinements result incomplete requirements 
consider specification general resource management system 
root goal refinement graph states relevant request resource eventually satisfied providing resource unit repository requestor 
goal achieve formaldef user res resource rep repository requesting res rep registered res rep ru unit ru res ru goal trivially satisfied particular case resource unit available 
suggests decomposition goal achieve formaldef user res resource rep repository requesting res rep ru unit ru res available ru rep ru unit ru res ru goal achieve formaldef user res resource rep repository requesting res rep registered res rep ru unit ru res available ru rep subgoal conjunct registered res rep kept implicit antecedent due domain invariant attached available relationship ru unit ru res available ru rep registered res rep pattern rp introduced tells specifier refinement incomplete 
missing maintain subgoal derived systematically goal maintain 
formaldef user res resource rep repository requesting res rep registered res rep requesting res rep registered res rep ru unit ru res ru missing subgoal turn refined application frequently pattern called maximize cohesion pattern resulting refinement missing subgoal goal maintain formaldef user res resource rep repository requesting res rep requesting res rep ru unit ru res ru goal maintain formaldef res resource rep repository registered res rep registered res rep stronger version second subgoal eventually selected 
asking meant requests maintained resource registration maintained resource kept registered triggers discovery new concrete requirements reservation fines subgoal policies avoid lost stolen resource units second subgoal 
example refinement debugging patterns quite different real system lam :10.1.1.56.8810
constructive refinement alternatives refinement patterns help completing partial refinements 
requirements engineer instance interested retrieving complete patterns match partial pattern suggested partial pattern corresponds frequent situation easy limit case comes directly mind define trivial subgoal 
formal query pattern library allows retrieve candidate patterns complete refinement subgoals subgoals subgoals 
rp illustrate point consider train control system 
candidate pattern instantiated 
instantiation second candidate pattern produce alternative subgoal goal achieve formaldef train block go go third retrieved pattern produce third alternative goal achieve formaldef train block go go alternative subgoals generated result different policies 
alternatives signal changes triggered train arrivals 
third alternative signal changes occur circumstance regardless train arrivals 
requirements implementing subgoal issued patterns need introduce new agent train detection device near signal 
making choices explicit pattern directed refinement may allow requirements engineers explicit design choices hidden informal elaborations past designs 
experienced reengineering requirements cable phone system major telecommunication 
system built top existing technology imposed pre existing choices 
example abstracted system consider specification point point communication agents goal achieve formaldef point message way taken satisfy goal require channel allocated communication ii communication allocated channel 
consider subgoal 
weakest refinement pattern led formalization goal achieve formaldef point channel allocation stronger refinement pattern produced requirement channels allocated just calls issued soon pairs plugged network goal achieve formaldef point connection channel allocation refinement domain invariant attached relationship point connection version allows channel vary time 
stronger refinement pattern produced requirement channel forever goal achieve formaldef point connection channel allocation note difference just operator jumping existential quantifier 
patterns explicitly structured weakening strengthening hierarchy may help selecting refinements design choices explicit dynamic vs static allocation channels better fit actual needs view parent goals graph need achieved 
example suggests pattern library structured weakening strengthening hierarchy 
section investigates structure precisely 
sections provide typical examples propositional order refinement patterns respectively 
propositional refinement patterns propositional patterns worth considered global refinements quantifiers interfere refinement 
sample frequently propositional patterns achieve goals shown table 
row table gives possible refinement parent goal pattern rp defines milestone driven refinement intermediate state satisfying reached final state satisfying reached 
pattern rp advocates decomposition cases 
pattern rp identifies condition set order reach pattern rp strengthens rp requiring condition hold independently truth value rp strengthens rp requiring continuously hold holds 
suggested pattern may lead completely different systems 
example rp rp library system lead completely different policies book loan 
suppose stands member requests book stands member borrow copy book 
suppose stands copy book available 
patterns rp rp require request book copy available eventually satisfied 
disagree happens copy available 
rp requires book requested copy available copy eventually available rp requires copy book requested eventually available 
case allowed subgoal subgoal subgoal rp rp rp rp rp table 
propositional patterns achieve goals keep copies long member requesting copy corresponding book case return copies request 
extensive set patterns achieve maintain goals dar proofs correctness completeness 
order refinement patterns order goal assertions classified categories respect refinement 
assertion consists composition logical temporal connectives closed formulas decomposed refinement 
consequent assertion closed formula form conjunction disjunction subformulas decomposed refinement rewritten match case 
antecedent assertion closed formula form conjunction disjunction subformulas decomposed refinement rewritten match case 
antecedent consequent instantiated assertion closed formulas sharing variables 
formulas category treated propositional formulas closed subformulas abstracted propositional symbols 
third category just dual second 
concentrate cases successively 
notations 
ambiguity arises free variables formulas assumed universally quantified instance stands predicate arguments dropped instance stands decomposing consequents frequent generic assertion category 
possible refinements shown table 
row contains refinement proved correct complete 
patterns dar 
instance patterns derived dropping term second subgoal subgoal subgoal subgoal fo fo fo table 
order patterns achieve goals propositional patterns replacing eventually operator operator 
illustrate patterns consider meeting scheduler system 
meeting planned date participants agree venue meeting 
refinements table propose problem finding date venue 
date 
fo fo state venue date 
pattern fo weaker provided date requires find date necessarily initially foreseen venue date 
variables common antecedents consequents universally quantified variables common antecedent consequent parent goal interfere refinements may rule classical logic universally quantified variables ii apply refinement pattern resulting formula iii inverse generalization rule subgoal reintroduce quantifiers variables frozen 
existentially quantified variable common antecedent consequent parent goal refinements guarantee consequent parent formula holds value antecedent 
explains subgoals generally introduce universal quantifiers existential ones 
instance possible refinement pattern patterns dar 
exploring pattern space effective practice pattern library properties 
relevance library provide patterns needed requirements engineers relevant patterns retrieved easily 
relevance step process followed identify relevant refinement patterns 
inductive step candidate patterns identified abstracting goal refinements wide variety case studies resource management systems multiple specializations sharable resources resources resources resources convertible resources transportation systems communication systems process monitoring meeting scheduling conference organization 
candidate refinement patterns emerged case studies proved correct proof theory temporal logic man 
proofs bottom conjunction subgoals shown minimally entail parent goal 
result step preliminary library complete refinements reusable instantiation 
library weaknesses patterns unrelated explore alternatives contained implicit choices 
deductive step library refinements obtained inductive step reorganized deriving refinement patterns top basic patterns 
refinement choices explicit opened way systematic investigation refinement alternatives 
result library refinement patterns seen directed graph patterns linked weakening strengthening relationships 
fig 
shows piece graph 
higher goal weaker refinement graph structures pattern space library designer 
structure help library users select appropriate refinements situation 
patterns selected retrieving subtrees graph root matches goal assertion refined leaves retrieved subtrees provide subgoals instantiated substitutions revealed match 
suggested frequent cases user looking ways complete partial refinements identified match constrained subgoals 
retrieval patterns supported query system implemented terms standard tree matching primitives syntax trees 
facility implemented see difficulty kaos environment kernel currently building uses csg syntax directed environment generator rep 
refinement pattern meet needs exactly user designer may define new patterns top existing ones 
frequently patterns library clearly incorporated 
retrieval mechanism matching concrete patterns syntactically 
assistance decomposition portion refinement graph decomposition provided help selecting appropriate patterns semantic criteria 
meta level refinement tactics structure pattern space nature decomposition proposed 
patterns indexed tactics context described tactics 
fig 
shows domain independent tactics identified far 
milestone driven tactics 
tactics suggests identifying milestone states states reached sooner achieve target predicate appearing parent goal tactics corresponds wellknown heuristics planning problem reduction nil 
case driven tactics 
tactics suggest identifying different cases satisfy goal 
cases may concern current state satisfying target predicate reached antecedent decomposition target state satisfying cases may completely independent may dependent 
example dependent antecedent decomposition case driven tactics tactics suggests identifying particular cases target predicate reached trivially general cases reduce cases eventually 
distinction normal exceptional cases antecedent target predicate yields case driven tactics 
agent driven tactics 
tactics suggest identifying group agents involved achievement parent goal splitting group smaller subgroups agents achieve corresponding subgoals abilities known schedule 
patterns rp rp fo fo indexed milestone driven tactics 
patterns rp rp rp indexed case driven tactics 

operationalizing goals goal refinement eventually result identification specification requirements responsibility assigned individual agents programs domain independent tactics goal refinement milestone driven multiple milestones agent driven scheduled cooperation agent abilities case driven antecedent decomposition consequent decomposition independent dependent independent dependent software developed devices humans existing programs environment 
boundary new software environment obtained 
suggested previous sections refinement process supported stage reuse patterns patterns refer operational notions agents events actions second stage operational patterns considered 
studied family patterns date 
stimulus response patterns apply cooperation agents required achieve goal modelled exchange stimuli responses agents 
stimulus response patterns stimulus event perceived agent requires action performed agent 
response agent reaction stimulus 
examples 
phone network system user picking phone defines stimulus sent exchange system reacts sending dial tone 
patient monitoring system stimuli events occur monitored values greater lower accepted 
responses provided raising alarms turn stimuli nurses duty 
stimulus response family patterns suggests ways operationalizing goals classification case satisfaction goals stimuli represent requests services responses indicate requested services provided case safety robustness privacy goals stimuli represent alarms detect situations leading goal violations responses indicate alarm causes resolved case information goals stimuli represent object state changes interest agents responses represent notifications agents state change 
fig 
shows trees goals constraints proposed stimulus response patterns satisfaction safety goals 
fig 
stimulus produced satisfy constraint 
responsibility agent requests service 
response modelled right part tree service request satisfied soon response request appointed server addresses request appropriately 
fig 
violation safety robustness privacy goals prevented undesirable situations detected advance raise alarms stimuli 
responses alarms provided appointed guard way clears alarm causes 
note necessarily constraint may need cooperation agents achieved 
instance response stimulus sent agents stimuli chained forwarded broadcasted acknowledged 
worth noticing goal constraint appearing fig 
formal definition refinement patterns proved correct dar 
show derivation leading fig 

safety requirements safety robustness privacy goals formalized terms avoid patterns goal avoid instanceof formaldef alarms introduced warn environment possible accidental violation goals intrusion detected monitored values exceed threshold 
alarm effective violation achieve achieve achieve achieve achieve constraint goal goal operationalization stimuli responses achieve achieve maintain appointment cease achieve achieve achieve achieve achieve maintain avoid safety robustness privacy goals satisfaction goals anticipated response alarm allows violation avoided 
suppose effectiveness condition holds effectiveness condition states contextual condition persistent property holding continuously period altogether result subsequent goal violation 
instance house alarm system instantiated intrusion instantiated alarm system instantiated intrusion detection 
patient monitoring system instantiated patient death monitoring working monitored value exceeding respectively 
effectiveness condition goal rewritten goal avoid formaldef turn rewritten goal cease formaldef introduce alarm event type event alarm source target alarm occurs 
goal cease partially refined achieve formaldef alarm occurs 
goal achieve formaldef alarm occurs pattern directed refinement goal introduces guard appointed react alarms 
refinement results subgoals constraints achieve formaldef alarm occurs guard appointed goal achieve formal def alarm guard appointed response maintain formal def alarm guard appointed appointed goal achieve formal def guard alarm response depending nature response provided goals converted constraints assignable single agents 

constructive approach goal refinement operationalization 
principle reuse generic refinement patterns library structured weakening strengthening relationships patterns 
retrieval relevant patterns matching partial goal formulations trees library complementary tactics allow patterns selected semantic criteria 
distinction refinement patterns operational patterns constraints agents events actions 
patterns proved correct complete 
allows tedious mathematics involved proofs hidden ii refinements checked completeness consistency iii partial refinements completed iv design choices explicit alternative patterns goal explored requirements 
pattern library set tactics means complete 
suggested sections constructed inductively experience past years kaos elaborate requirements wide variety systems ranging research case studies industrial projects 
examples aimed reflect variety 
experience certainly suggest relevant patterns tactics 
current experience convinced approach effective real systems 
patterns illustrated occurred recurrently 
especially helpful debugging specifications notably pointing subgoals overlooked 
problems detailed formal pattern matching 
goal refinement patterns started investigating patterns operationalizing constraints specifications actions 
experience real telecommunication project allowed exhibit patterns 
refinement patterns discussed domainindependent 
complement domain dependent patterns frameworks considered 
initial reported mas 
approach supported tool browsing library updating refinement graph retrieving appropriate patterns syntactic matching tactics 
gave hints tool way current kaos environment 
plan integrate tool top syntax tree engine near 
needed refine patterns account real time temporal constructs koy 
hand provide light version library industrial partners want take benefit approach having acquainted temporal logic 
light version provide textual structured patterns temporal formulas hidden 

reported partially supported esprit project nr 
fran de project actions de recherche concert es nr 
direction rale de la recherche 
martin feather steve fickas critical remarks fse reviewers helpful comments suggestions 
anderson fickas proposed perspective shift viewing specification design planning problem proc 
th intl 
workshop software specification design ieee 
ant anton mccracken potts goal decomposition scenario analysis business process engineering caise lncs springer verlag pp 

ast astesiano wirsing asl proc 
ifip wg conf 
program specifications transformations north holland 
bal balzer goldman operational specification basis rapid prototyping acm sigsoft softw 
eng 
notes vol 
dec 
bgm gaudel ad software testing formal specifications theory tool software engineering journal 
boe boehm bose horowitz ming june lee software requirements negotiation renegotiation aids theory spiral approach proc 
icse th intl 
conf 
software engineering seattle pp 

bra brachman levesque eds readings knowledge representation morgan kaufmann 
dar dardenne fickas van lamsweerde goaldirected concept acquisition requirements elicitation proc 
th intl 
workshop software specification design como 
dar dardenne van lamsweerde fickas goaldirected requirements acquisition science computer programming vol 

dar darimont process support requirements elaboration phd thesis universit catholique de louvain pt 
ing informatique louvain la neuve belgium 
doug douglas kemmerer symbolic execution tool testing formal specifications proc 
intl 
symp 
software testing analysis acm softw 
eng 
notes 
dub dubois formal language requirements engineering computer systems introducing logic approach artificial intelligence ed vol 
wiley 
fea feather language support specification development composite systems acm trans 
programming languages systems apr 
fea feather derivational style distributed system design automated software engineering 
fic fickas helm knowledge representation reasoning design composite systems ieee trans 
software engineering june 
gam gamma helm johnson vlissides design patterns elements reusable object oriented software addison wesley 
gau gaudel structuring algebraic specifications specification language evolutions perspectives proc 
stas lncs 
geo george hughes milne pedersen raise development method 
prentice hall 
gut guttag horning larch languages tools formal specification springer verlag 
har harel statecharts visual formalism complex systems science computer programming vol 

software prototyping formal methods vdm 
addison wesley 
jac jackson zave domain descriptions proc 
re st intl 
ieee symp 
requirements engineering jan 
jac jackson damon elements style analyzing software design feature counterexample detector proc 
intl 
symp 
software testing analysis acm softw 
eng 
notes vol 

jon jones systematic software vdm nd ed prentice hall 
koy specifying message passing time critical systems temporal logic lncs springer verlag 
lam van lamsweerde darimont massonet goaldirected elaboration requirements meeting scheduler problems lessons learned proc :10.1.1.56.8810
re nd int 
symp 
requirements engineering york ieee 
lan lano formal object oriented development springer verlag 
man manna pnueli temporal logic reactive concurrent systems springer verlag 
mas massonet van lamsweerde analogical reuse requirements frameworks appear proc 
re rd int 
symp 
requirements engineering 
mor mandrioli ghezzi model parametric real time logic acm transactions programming languages systems vol 
october 
mylopoulos chung nixon representing nonfunctional requirements process oriented approach ieee trans 
sofware 
engineering vol 
june pp 

nil nilsson problem solving methods artificial intelligence 
mcgraw hill 
nix nixon dealing performance requirements development information systems proc 
re st intl 
ieee symp 
requirements engineering jan 
pot potter sinclair till formal specification prentice hall 
rep reps teitelbaum 
synthesizer generator system constructing language editors 
springer verlag 
reu waters requirements apprentice automated assistance requirements acquisition ieee transactions software engineering vol 
march 
rob robinson integrating multiple specifications domain goals proc 
th intl 
workshop software specification design ieee 
sch van parnas madey documentation requirements computer systems proc 
re st intl symp 
requirements engineering ieee 
zar wing signature matching tool software libraries acm trans 
software engineering methodology april 
zave operational approach requirements specification embedded systems ieee transactions software engineering vol 
may 
zave zave classification research efforts requirements engineering proc 
re nd ieee int 
symposium requirements engineering march 
