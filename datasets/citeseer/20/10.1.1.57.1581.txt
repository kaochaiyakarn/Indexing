department computing science compilation transformation non strict functional languages andr lu de medeiros santos submitted doctor philosophy degree computing science university glasgow july fl andre de santos thesis analyse set automatic source source program transformations suitable incorporation optimising compilers lazy functional languages 
transformations improve quality code different respects execution time memory usage 
transformations divided sets global transformations performed twice compilation process set local transformations performed global transformations simplify code applying global transformations take advantage 
local transformations simple known major effects 
important interact global transformations non obvious ways 
improve code perform extensive experiments real application programs 
describe global transformations lazy functional compiler know static argument transformation floating transformations 
known transformations lazy functional languages major studies effects performed full laziness lambda lifting 
study measure effects different inlining strategies 
cost semantics way reasoning effects program transformations lazy functional languages 
wife ana supervisor professor simon peyton jones guidance support research friendly informal person 
certainly weekly meetings 
members examination committee lennart augustsson singh david watt providing interesting corrections suggestions improve thesis 
grasp aqua team producing supporting glasgow haskell compiler essential part 
special partain friendship patience answering endless stream questions providing helpful comments draft thesis 
andy gill david king simon marlow provided friendly relaxed atmosphere available discuss provide feedback 
computing science department university glasgow provided nice informal working environment 
functional programming group annual workshops weekly seminars provided important feedback 
john launchbury andy gordon helping cost semantics 
special friend moura guest home arrived glasgow helping sorts things 
friends glasgow support friendship specially felix family martins barnett family 
acknowledge financial support received capes brazilian federal agency postgraduate education allowed carry research described thesis 
professor silvio introduced functional programming supervised undergraduate msc 
student 
family specially parents love support 
gratitude love wife ana support patience love 
andr santos iii contents contributions thesis 
structure thesis 
framework overview compiler 
core language 
preserving type information 
optimisation 
performed measurements 
benchmark programs 
local transformations beta reduction 
elimination 
dead code removal 
inlining 
constructor reuse 
case elimination 
case reduction 
iv contents case elimination 
case merging 
case error 
default binding elimination 
dead alternative elimination 
floating lets outwards 
floating application 
floating right hand side 
floating case scrutinee 
floating transformations 
floating cases outwards 
case floating application 
case case case floating case scrutinee 
case floating right hand side 
strictness transformations 
case 
unboxing case 
transformations 
constant folding 
eta expansion 
transformations interacting 
repeated evaluations 
lazy pattern matching 
error tests eliminated 
compiling factorial program 
confluence termination 

contents vi local transformations implementation results implementation 
renaming 
simplifier function 
results 
transformation 
effect transformations 

floating floating lets inwards 
benefits floating inwards 
risks floating inwards 
implementing floating inwards 
relation local floating 
improvements algorithm 
results 
related 

full laziness 
benefits full laziness 
risks full laziness 
reducing risk space leaks 
implementing full laziness transformation 
floating inwards full laziness 
results 

floating cases lambdas 
contents vii ordering floating transformations 
float inwards strictness analysis 
full laziness strictness analysis 
simplify floating inwards 
float inwards strictness analysis 
full laziness inlining 
ordering 

inlining inlining lazy functional languages 
basic inlining 
inlining strategy 
inlining recursive lets 
interaction transformations 
results 

static argument transformation lambda lifting static argument transformation 
algorithm 
results 
related 
lambda lifting 
results 
combining static argument transformation lambda lifting 

contents viii related programmer assisted program transformation 
automatic program transformations 
program transformations functional languages compilers 
lazy functional languages compilers 
chalmers lml hbc compiler 
fast compiler 
compiler 
strict functional languages compilers 
continuation passing style 
fi contraction 
case reduction 
dead variable elimination 
argument flattening 
dropping unused arguments 
fi expansion 
reduction 
uncurrying 
hoisting 
common subexpression elimination 
closure conversion 
effect transformations 
imperative languages compilers 
common subexpression elimination 
copy propagation 
dead code elimination 
algebraic transformations 
code motion 
contents ix loop unrolling 
procedure inlining 
procedure cloning 
redundant instruction elimination 
flow control optimisation 
cost semantics cost semantics 
cost relation 
observational cost relation 
direct cost relation 
observational cost relation revisited 
examples 
floating application 
case floating application 
floating case scrutinee 
unboxing case 
floating 
case floating 

general 

function definitions arithmetic 
comparison 
boolean operators 
bibliography chapter due semantic properties functional languages suitable program transformations imperative counterparts 
high level abstraction absence side effects clear simple semantics just characteristics relatively easy establish properties functional programs hug tur 
program transformation broadly classified groups ffl non automatic program transformations performed manually assisted computer need human intervention select transformations provide new transformations needed 
program development technique 
ffl automatic program transformations entirely automated incorporated compiler practical due performance issues 
thesis describe automatic program transformations suitable incorporated optimising compiler 
traditional compilers original language translated different intermediate representations generating object code 
optimisations performed compilers regarded program transformations implemented intermediate representations quite different original source language 
approach compilation program transformation kel uses single intermediate representation lambda calculus chu bar compilation process 
approach important advantages 
contributions thesis ffl source source transformations easier proven correct implemented correctly 
ffl allows optimisations performed obscure way code generation implemented high level program transformations 
thesis analyse effects large set optimisations expressed program transformations functional language 
contributions thesis thesis presents detailed study large set automatic program transformations 
study distinctive features ffl large set transformations discussed single framework 
simple obvious new transformations suggested inspecting intermediate code compiler 
transformations presenting large benefits combined achieve major improvements program performance 
virtually compiler form seldom systematically described analysed importance effectiveness real programs known 
ffl transformations embedded real production quality compiler hidden costs paid due aspects code generation 
ffl measurements performed large set applications sources 
real applications hundreds thousands lines small toy benchmark programs 
ffl measure effect new transformations floating static argument transformations suggested code inspection 
shown important transformations floating improving programs performance static argument transformation 

structure thesis ffl discuss evaluate suggest improvements known transformations full laziness lambda lifting 
show risks creating space leaks due full laziness smaller practice suggested literature ways reducing 
achieve average performance improvement full laziness peak improvement space leaks created 
lambda lifting shown heavy penalty cost done implementations functional languages worsening performance average 
show selective approach lambda lifting produce modest performance improvements 
ffl measure effect different inlining strategies glasgow haskell compiler showing point improvements inlining start small worthwhile quickly reached experimental framework 
inlining shown important improving programs average 
ffl cost semantics way reason cost expressions transformation 
allows rigorous definition code improvement reason effects program transformation formal framework 
parts previously sp ps 
structure thesis start describing framework measure effectiveness transformations introducing core language measured effect transformations benchmark programs chapter 
set small local transformations chapter 
describe transformations presenting improve code risks involved performing transformations 
measurements effect transformations different options performing compare results 
chapter describe details local transformations implemented measure effect 
chapter introduce evaluate floating inwards transformation discuss full laziness transformation effects 
ways reduce 
structure thesis risk creating space leaks performing full laziness transformation 
discuss constraints ordering transformations ordered 
chapter presents different inlining strategies effect 
measure effect increasing amount functions inlined aspects code size compilation time heap allocated instructions executed 
chapter introduce evaluate static argument transformation discuss lambda lifting transformation effects 
show static argument transformation positive effect programs 
proceed discuss lambda lifting showing problems performing try restrict cases beneficial 
try combine transformations 
chapter discuss different approaches program transformations literature compare transformations ones functional imperative languages compilers 
chapter introduce cost semantics reason cost expressions program transformations 
chapter 
chapter framework chapter describe experimental framework measurements language describe transformations explain measure effect transformations benchmark programs 
initially overview glasgow haskell compiler section system transformations implemented experimented 
characteristics intermediate language compiler core language section 
discuss measure claimed improvements performed transformations sections introduce benchmark programs substantiate claims program improvement section 
overview compiler glasgow haskell compiler modular design making relatively easy modify introduce extra passes 
furthermore production quality compiler capable dealing substantial real haskell programs ensures meaningful results 
ideal tool implement measure effectiveness program transformations 
compiler structured series passes 
main passes ffl parser written lex yacc 
overview compiler haskell source lex yacc parser syntax renamer syntax typechecker syntax core syntax core stg stg syntax code generator compiler executable core core stg stg glasgow haskell compiler ffl renamer resolves scoping naming issues especially concerned module imports exports ffl type inference pass annotates program type information transforms overloading wb ffl transforms high level constructs haskell pattern matching list comprehensions simpler functional language called core language describe section ffl series transformation passes core language describe thesis aim improving efficiency code ffl translator core language shared term graph stg language pey purely functional language simpler core language ffl transformation passes stg language described thesis stg language originally short spineless tagless machine language fact language entirely independent machine model implement 

core language ffl code generator converts stg language internal data type easily printed syntax ffl pass flattens prints code compiled compiler 
optionally compiler generate assembly code directly architectures 
see compilation process expressed correctness preserving transformations purely functional program intermediate languages compiler code generation pure functional languages 
core language core language intended simplest language haskell translated desugared loss efficiency 
list comprehensions pattern matching guarded equations conditionals translated simple case expressions rec expressions constructors remain 
syntax core language 
core language essentially second order lambda calculus augmented case constants constructors primitive operators 
concrete syntax conventional allow conventions liberties ffl parentheses disambiguate ffl application associates left binds tightly operator ffl body lambda abstraction extends far right possible ffl usual infix arithmetic operators permitted ffl usual syntax lists allowed infix constructor empty list ffl layout meaning clear omit semicolons bindings case alternatives 
ffl denote denote 
core language program prog binding binding bindings binding bind rec bind bind bind var expr expression expr expr atom application expr ty type application var var 
expr lambda abstraction ty 
expr type abstraction case expr alts case expression binding expr local definition con atom atom constructor prim atom atom primitive atom atoms atom var variable literal unboxed object literal values literal integer float alternatives alts default default constr 
alt con var var 
expr literal alt literal 
expr default alt default var 
expr syntax core language 
core language ffl function bindings expressed binding variable lambda abstraction write arguments function bindings left sign 
main points noted core language ffl bindings expressions simple 
left hand side binding variable 
similarly patterns case expressions simple nested pattern matching compiled nested case expressions 
ffl explicit type abstraction application 
type information preserved core language program transformations done core language preserve type correctness program 
easier explicit type abstractions applications describe section 
type information desirable essential stages compilation example higher order strictness analyser may need accurate type information order construct correct fixed points 
ffl atomic arguments 
arguments application constructor restricted atoms variables literals 
restriction allows smaller simpler sets transformations arguments arbitrary expressions 
example benefits design decision section 
ffl applications constructors primitive operators saturated 
partial applications constructors primitive operators obtained lambda abstractions 


ffl unboxed values 
core language allows express boxed unboxed values allowing transformations usually left code generator handled completely ad hoc way expressed core language program transformations pl 
definition operation example 

case mkint 
case mkint 
case 
mkint 
core language definition function receives boxed arguments mkint constructor boxed integer second applies unboxed operator unboxed values returns boxed result constructor mkint 
append character primitive operators unboxed variables 
ffl core language programs direct operational interpretation heap allocation represented lets evaluation denoted cases 
notice cases core language strict 
means identical cases haskell 
specifically expressions case 
haskell equivalent core 
core denotes evaluated value bound means closure built unevaluated bound preserving type information illustrate importance second order lambda calculus preserve type information transformations consider example consider function compose type compose fi fl 
ff fi ff fl function defined untyped core language compose 


suppose want inline particular call compose function 
compose show double int double doubles show converts result string 
result inlining call compose instance body compose 
core language double show want able identify type variable sub expression able calculate type case type int application compose may different type 
type body compose just type variable fi 
clear polymorphic world insufficient merely tag variable original program type information survive program transformations 
compiler known polymorphically typed language preserves type information arbitrary transformations 
clearly program decorated type information way program transformation sure preserve 
second order lambda calculus idea polymorphic function compose receives type argument universally quantified polymorphic variable type ff fi fl case compose 
polymorphic function called passed extra type arguments indicate types polymorphic type variables instantiated 
definition compose compose 



function takes type arguments value arguments types explicitly type local variable call compose extra type arguments instantiate just normal arguments instantiate example call compose looked earlier written compose int int string show double simple inline call instantiating body compose supplied arguments give expression int double show take liberty presenting types explicitly 

optimisation 
bound variable automatically attributed correct type 
short second order lambda calculus provides founded notation express transform polymorphically typed programs 
type inference pass produces translated program extra type abstractions applications explicit 
propagation type information scope thesis discuss 
subsequent example programs type abstractions applications omitted relevant 
optimisation 
aim optimisation technique reduce time space needs executing program 
functional language context time space costs program measured ways ffl execution time 
certainly major goals optimisation program run time 
execution time unfortunately easy number measure modern multi tasking multi user computers 
due number factors computer running various processes user machine running operating system tasks dealing network traffic 
single user mode network connection repeatedly perform measurements average reliable data execution time 
factors affect wall clock time elapsed time called user time performing measurements 
due large number experiments perform thesis practical dedicated powerful non networked machine perform 
necessity run experiments times task time consuming 
ideal circumstances just behaviour computer cache generate different results time program run hbh 
looking considerable changes performance reasonable accept small error margin measurements 
case 
optimisation 
looking small improvements caused small transformation easily get acceptable error margin 
due reasons decided measure instructions executed program time 
item 
ffl total instructions executed 
measure total instructions executed program execution time advantages repeatable number 
affected programs cache behaviour paging behaviour 
need standalone machine measured 
predictor run time improvements 
instructions execution time program uses different mix program different transformations performed observed run time improvement close improvement total number instructions executed 
approach example app similar reasons 
ffl memory traffic 
way measuring amount memory traffic counting number instructions access memory 
risc machine usually explicit load store instructions basically amounts counting instructions 
performing measurements measured improvement memory traffic close improvements get total instructions executed decided 
ffl amount heap allocation 
amount heap allocated measured bytes indicates amount memory closures built heap 
costs involved allocating closure heap check verify space available closure heap garbage collector called 
initialising fields closure heap 
possibly evaluating closure demanded 
closure updatable cost update 

optimisation 
amount heap allocated program directly related number garbage collections performed 
heap allocated garbage collections performed 
performing measurements observed amount heap allocated directly correlated run time behaviour program seen major variations heap allocation minor effects execution time 
allocation rate programs benchmarks number bytes allocated second varied lot little mb mb ffl number updates 
updatable closure expensive due cost memory accesses written memory created entered read memory updated result write operation memory 
usually high proportion updated closures entered sp unnecessary 
glasgow haskell compiler measured updates performed unnecessary sp 
optimisation techniques try reduce number updates performed 
achieved early evaluation strict demanded closures strictness analysis transformations achieve result section 
exposing weak head normal form closures done floating section 
finding closures entered update analysis mar 
ffl heap residency 
heap residency amount heap considered live garbage time 
peak maximum heap residency program run defines approximately minimum amount heap program available execute 
heap residency affects number garbage collections defining garbage collection amount live data amount free space 
free space small soon occur garbage collection 
reducing peak heap residency reduces actual minimum amount heap program runs 
ffl code size 
transformations may affect code size duplicating code inlining chapter 
ffl stack depth vs heap allocation 
depending way function defined heap stack 
take function definition 
performed measurements takes sum list sum case 
xs 
sum xs sum consumes little heap list built consumed sum garbage collected 
uses stack proportional length list compute calls sum proceeding additions 
possible definition uses accumulating parameter sum case 
xs 
sum xs sum case implementation graph reduction performs evaluation constant stack space due fact tail recursion usually cost increasing heap usage 
strictness analysis perform evaluation constant heap stack 
performed measurements measurements performed sparcstation mb memory 
tool count number instructions executed sun microsystems sun 
programs stated run mb heap minimise effects garbage collection instruction counting 
glasgow haskell compiler version measurements 
exclude effects garbage collection measurements large heap running programs effect garbage collection minimised programs performing garbage collection may concerned minor change amount allocation program may major effect instructions executed due triggering eliminating garbage collections 
real risk cases 
improvements incorporated versions 
number garbage collections typically performed program table chapter percentage run time program spent garbage collection 

performed measurements perform measurements haskell prelude compiled compiler options measuring 
advantage extending testing measurements include effects parts prelude programs 
try precise measurements showing exactly time space saved 
done profiling tools available glasgow haskell compiler provide finegrain measures number updates number heap allocations heap checks example information tool 
heap residency particularly hard measure looking maximum amount live data data garbage collected time 
practical perform garbage collection heap object allocated rely performing garbage collections bytes allocated rely having samples data reliable 
benchmark programs due amount heap allocate decided measuring residency different values measuring residency mbytes allocated compromise 
course risking residency peak occurs mbytes allocated possibly go unnoticed 
presenting results tables look transformation name residency option option option program queens hidden 
programs minimum maximum geometric mean specify transformation measuring measuring residency total instructions executed total heap allocated 
list options tried start listing programs 
columns baseline columns normalised respect column measuring execution time program took seconds run option taken seconds option seconds 
performed measurements rts allocations words total admin goods total words function values thunks data values big tuples black holes prim things partial applications total storage manager allocations words words lost speculative heap checks stack usage stack slots stack max 
depth words stack max 
depth words enters direct entry code rest indirected node info ptr thunks data values function values bypassed arg satisfaction chk partial applications indirections returns registers rest heap entering new constructor rest entering existing constructor vectored rest update frames omitted thunks standard frames constructor frames black holes updates data values place allocated new space node partial applications place allocated new space updates existing heap objects place updates copied profiling output 
benchmark programs option 
programs usually sorted respect columns 
programs show variation greater numbers rounded grouped separate row stating programs omitted 
summarise best worst results geometric mean column normalised results fw 
benchmark programs papers performance measurements small programs measure effect optimisations 
programs specially designed demonstrate effect particular optimisation 
relevant measurements upper bound effect optimisation giving insight effect real programs 
order realistic results measure effect transformations medium large size programs real application programs written different people 
programs grouped publically available nofib benchmark suite par 
programs divided subsets describe short description programs table ffl real subset programs perform useful task written demonstration tutorial purposes ffl imaginary subset small toy benchmarks ffl spectral subset programs don meet criteria real imaginary subset 
pieter hartel benchmark suite programs hl har part spectral subset short description programs table 
table summary characteristics programs compiling full optimisation glasgow haskell compiler ghc 
distinctions presenting results 

benchmark programs program subset description origin exp imaginary peano arithmetic imaginary expands regular expressions primes imaginary calculate prime numbers queens imaginary queens boyer spectral gabriel suite boyer benchmark boyer spectral gabriel suite boyer benchmark denis howe imperial cichelli spectral perfect hashing function iain york clausify spectral propositions clausal form colin runciman york fft spectral fourier transformation rex page amoco knights spectral knight tour jon hill qmw mandel spectral mandelbrot sets david hanley mandel spectral mandelbrot sets jon hill qmw minimax spectral tic tac toe xs iain york multiplier spectral binary multiplier simulator john donnell glasgow pretty spectral pretty printer john hughes chalmers spectral primality testing david lester manchester rewrite spectral rewriting system mike spivey oxford sorting spectral sorting algorithms partain glasgow treejoin spectral tree joining kevin hammond glasgow compress real text compression paul sanders bt fluid real fluid dynamics program xiaoming zhang swansea gg real graphs grip statistics iain york hidden real hidden line removal mark hpg real haskell program generator nick north npl infer real hindley milner type inference phil wadler glasgow lift real fully lazy lambda david lester manchester simon peyton jones glasgow maillist real mailing list generator paul hudak yale parser real partial haskell parser julian seward manchester prolog real mini prolog interpreter mark jones oxford reptile real escher tiling program sandra york rsa real rsa encryption john launchbury glasgow veritas real theorem prover gareth kent table nofib benchmark programs 
benchmark programs program description image processing application event event driven simulation set reset flipflop fft fast fourier transforms genfft generation synthetic fft programs ida solution particular configuration puzzle compilation list comprehensions compilation list comprehensions extra list copying function output parstof lexing parsing wadler parsing method sched calculation optimum schedule parallel jobs branch bound algorithm solid point membership classification algorithm solid modeling library computational geometry transform transformation number programs represented synchronous process networks master slave style parallel programs typecheck polymorphic type checking set function definitions wang wang algorithm solving system linear equations wave main calculation water heights square area theta grid points north sea long time period table nofib benchmark hartel benchmark programs 
benchmark programs program files lines object bytes exec 
total total time alloc rate size allocated time instructions gc gc mb exp primes queens boyer boyer cichelli clausify fft knights mandel mandel minimax multiplier pretty rewrite sorting treejoin compress fluid gg hidden hpg infer lift maillist parser prolog reptile rsa veritas event fft genfft ida parstof sched solid transform typecheck wang wave main table nofib benchmark programs compiled ghc chapter local transformations chapter describe large set local program transformations implemented glasgow haskell compiler 
transformations source source transformations simple functional language 
idea composing simple small high level transformations achieve benefits complicated specialised transformations implemented code generation optimisations 
transformations manipulate expressions programmer write generated desugaring haskell core language transformations 
transformations suggested inspection actual intermediate code glasgow haskell compiler 
offer small improvements purpose enabling transformations transformations interact results achieved quite impressive show section 
classify transformations groups ffl transformations remove core language constructs fi reduction removes lambdas elimination case elimination transformations sections ffl transformations move core language constructs floating case floating sections ffl transformations exploit strictness section transformations sections strictness information 

beta reduction ffl transformations fit categories section 
examples transformations interact section briefly discuss confluence termination transformation system section 
chapter discuss implementation transformations section results transformations section 
ignore issue name capture presentation transformations discussed chapter 
table summarise transformations discussed chapter 
transformations applied side conditions met 
side conditions discussed respective sections 
results effect transformations chapter highlight importance transformation compare effect different strategies adopted transformation 
beta reduction application lambda abstraction reduced 
body body applies equally ordinary lambda abstractions type abstractions 
body ty body ty beta reduction transformation doing evaluation compile time 
core language syntactic restriction arguments atoms allows replace occurrences risk duplicating 
allowed arbitrary expressions arguments transformation done stages occurred body bind argument expression avoid duplicating possibly evaluating times 
case transformation changed 
body body 
beta reduction section transformation beta reduction dead code removal inlining constructor reuse case reduction case 
case elimination case 
case merging case alt 

case alt 
case alt 
alt 
default binding elimination case 
case 
float app float float case scrutinee case case case float app case alt 
alt 
case alt 
alt 
case float case case case case case alt 
alt cm 
cm alt 
alt 
case alt 
case alt 
alt 
alt cm case cm alt 
alt 
case float case alt 
alt cm 
cm case alt 
alt cm 
cm case case 
unboxing case case 
eta expansion table local transformations 
elimination beta reduction transformation moves execution beta reduction run time compile time 
reduce heap allocation execution time lambda expression allocated evaluated particularly effective exposing transformations turns lambda bound variable information bound variable may obtain information right hand side 
example argument variable bound constructor may enable case reduction transformation section 
elimination dead code removal binding referred body removed program body body body happens recs bindings occur body bindings body body binders bindings body dead code removal transformation saves allocation closure reducing heap allocation 
reduces code size 
notice performing transformation side effect free language danger accidentally discarding right hand side performs side effect 
side effects sml 
advantages marked disadvantages theta 
indicates effect may bad 

elimination inlining inlining occurs replace occurrences bound variable right hand side due core syntax inlining performed occurs function position performed occurs argument position 
main advantages come inlining enables dead code elimination occurrences inlined 
definition available place allowing transformations fi reduction section occur 
better local context information things may known evaluated place allowing transformations case reduction section occur 
example expression case 
case 
inlined able know new local context evaluated avoid evaluating identical cases twice 
inlining risks theta code duplication expressions inlined occur multiple times 
theta duplication inlining done carefully redex copying 
points including key issue choosing expressions inline discussed detail chapter 

elimination constructor reuse constructor reuse transformation avoids allocating new object constructor identical object scope 
may occur circumstances 
identical constructor expression bound 
identical constructor expression bound variable case scrutinee case 
case 
main characteristics transformation avoids heap allocation object existing object 
increases lifetime objects possibly affecting heap residency 
glasgow haskell compiler keep type information compilation implement transformation preserves type correctness 
particular able reuse constructors cases data left right string string 
string int case left 
left 
right value resulting expression left form code generated different types type string string left right hand side case alternative type string int 

elimination depending position eliminated constructor issues involved ffl right hand side biggest benefit reusing constructors comes experiments eliminating 
ffl case scrutinee transformations section eliminate case constructor variable known bound constructor case relevant 
ffl case alternative body lambda body cases cost reusing constructor may worthwhile 
arity constructor example space saved arity constructors allocated statically introducing extra indirection efficient execute case case true 
true 
true 
false 
false false 
consider 
case ys 
ys 
idea replace right hand side ys 
depends specific compiler technology 
stg machine believe 
reason occurs code fragment real program max 

case lt 

eq 
gt 
allocated regardless branch case taken 
better inlining see chapter particular compiled efficiently jump code isn bad looks 

elimination current strategy glasgow haskell compiler inline known form constructors reverse turn constructor application back variable know right hand side 
decision supported experiments reuse constructors aggressively results effects heap usage small number instructions executed increased aggressive strategy seen table 
constructor reuse total instructions executed program rhs parser solid wang event knights prolog sched boyer clausify fluid multiplier rewrite transform treejoin compress progs 
minimum maximum geometric mean constructor reuse total heap allocated program rhs compress knights parser solid event sched wang boyer pretty lift transform treejoin fluid gg hpg infer maillist minimax prolog rewrite typecheck progs 
minimum maximum geometric mean table constructor reuse instructions executed bytes allocated effect constructor reuse transformation right hand sides residency table 
forced garbage collection mbytes allocated restricted sample programs performed garbage collections programs samples 

case elimination results showed residency reduced 
explained fact identical constructor expressions lifetime overlap better copy 
constructor reuse residency program ratio gcs residency gcs residency hidden parser sched gg solid event genfft rewrite clausify multiplier infer typecheck progs 
minimum maximum geometric mean table constructor reuse residency code transformation applied comes directly source code places programmer patterns achieve effect example 
written 
case elimination case reduction instances case reduction transformation 
case elimination 
case expression constructor application eliminated case 

case expression variable case 
case 
case 

variable bound constructor application case 
third transformation useful occurs times scope expression inlined arguments constructors atoms loss sharing occurs 
function arguments allowed arbitrary expressions constructor arguments need bindings substitution preserve sharing properties 
case reduction transformations eliminate redundant evaluations done run time glasgow haskell compiler inline constructors version needed 

case elimination expose opportunities transformations 
see occurs sections 
related transformation case scrutinee matches default alternative eliminate case binding default variable constructor case 
efficient evaluation done case case scrutinee weak head normal form 
saving cost entering expression weak head normal form may eliminated constructor reuse transformation 
case elimination primitive case variable variable guaranteed evaluated unboxed value 
valid transformation case 
transformation eliminating redundant evaluation 
transformation valid know variable evaluated know strictly example transformation done obscure way code generators pey pp 

applied transformation regardless conditions improve termination possibly transform failing program non failing transformation applied default binding elimination transformation section may applied 
glasgow haskell compiler provides flag enable transformation 

case elimination case merging case merging transformation combines cases variable single case expression case 


case 

case 



consider code fragment int 
int 
int type haskell compiler assume overloaded function code generated standard compilation overloading wb aug dict 

case eq dict true 
false 
case eq dict true 
false 
case eq dict true 
false 
fail knew type int 
int code generated 
case 



fail 
case elimination efficient 
transform version second directly inline call decide generate specialised version type int 
int get 
case eqint true 
false 
case eqint true 
false 
case eqint true 
false 
fail uses eqint function compares inefficiently 


constant folder section recognise identity case eqint 

true 
false variable explicit constant 
get instances case case transformation section eventually give code 
case 

case 

case 

fail 
apply case merging transformation twice 
give efficient version wanted 
case 



fail 
case elimination case error error predefined function haskell usually associated pattern matching failures run time errors 
semantic value 
may error case scrutinee apply transformation case error error case error transformation exposed case case transformation section 
consider case hd xs true 
false 
inlining hd get case case xs 
error hd 
true 
false 
doing case case get case xs 
case error hd true 
false 

case true 
false 
case error transformation springs life inline get efficient result case xs 
error hd 
case true 
false 
type error expressions different replacing case 
transformation reduces code size may enable transformations inlining 
glasgow haskell compiler clever notice disguised forms error expressions handle way bound error expressions functions return errors cases alternatives returning errors 

case elimination default binding elimination case 
case 
code generator generate better code default variable right hand side need bind result case evaluation default variable 
possible disadvantage transformation increases number occurrences may avoid inlining place 
inline variables bound constructors risk may case reduction due transformation 
dead alternative elimination dead alternative elimination similar case reduction transformation deals case know variable bound constructors 
assuming bound constructor case 

case 
gamma 
gamma 

know bound particular constructor enclosing case case 

inside know bound inside know bound applies unboxed cases obvious way 
importance transformation 
floating lets outwards reduces code size may enable inlining reduces number occurrences variables may enable case elimination transformations 
third possibility obvious usually occurs relation operations check invalid arguments range arguments 
suppose expression mod div mod div operations accept second argument value 
supposing check performed actual operation takes place code fragment similar case 
error mod 
case 
error div 
clearly know inner case value eventually eliminate inner case completely 
example transformation section 
floating lets outwards transformations section increase scope bindings order turn expression efficient form increase possibility transformations applicable 
floating application binding floated application facilitate transformations introducing removing extra 
floating lets outwards rec rec example transformation exposes transformations occurs body lambda expression 
body case opportunity fi reduction occurs transformation applied 
body floating right hand side floating right hand side transformation moves bindings defined right hand side outside rec bind rec bind rec rec binds rec ae binds oe illustrate goal floating lets right hand sides consider simple expression possible translation core language explicit closures translation 
floating lets outwards ffl weak head normal form updated evaluated weak head normal form requires update ffl closure entered evaluated closure allocated entered allocated 
strategy saves heap space allocates fewer closures entered allocated cost allocating closure separately implies heap check allocation 
alternative translation strategy floating internal lets outer level advantages single heap check done allocations 
weak head normal forms exposed 
closures weak head normal forms updates required 
may expose transformations case reduction case 
case 




unfortunately float lets may allocate closures really needed 
example need value evaluation expression 
floating lets outwards allocate closure allocating closures 
value demanded better second translation 
predict precisely closures evaluated decide take advantage floating minimising risks extra heap allocation 
possible strategies floating lets lets discuss 
float strict lets floating lets strict lets consists strictness information decide want float particular 
strict context know evaluated lets defined immediately guaranteed allocated 
floating lets reduce number heap checks closures allocated time increase heap allocation guaranteed evaluated possibly expose weak head normal forms reducing number updates possibly expose opportunities transformations modify number free variables 
stg machine free variable saved stack entering closure see pey 
free variables means stack saves 
example free variable floated free variables 
free variables floated free variable 
number free variables closure affects size closure heap 



floating lets outwards theta may increase heap residency due early allocation closures allocated due change number free variables 
binding guaranteed demanded strict better result achieved strictness information implement case transformation section useful option 
float lets expose weak head normal forms floating lets lets expose weak head normal forms takes advantage fact weak head normal form lets closures cheaper sense require updates expensive 
strategy risk building unnecessary closures demanded benefit creating weak head normal form closures updatable ones 
example risks strategy seen looking example 
standard translation head function returns element list get head allocate enter allocate update get result 
floated version allocate closures heap check need updates weak head normal form 
computing head list need allocate 
floated version cost update heap check greater cost allocating 
happens function returns element list need enter closures floated version certainly better 
strategy reduce number heap checks closures allocated time expose weak head normal forms reducing number updates possibly expose opportunities transformations case reduction constructor reuse 
floating lets outwards modify number free variables theta may increase heap allocation depending closures demanded theta may increase heap residency due early allocation closures allocated due change number free variables 
float lets lets floating lets lets increase risk allocating unnecessary closures expect closures entered minimising heap checks having advantages disadvantages previous strategy possibly reduce number heap checks closures allocated time theta may increase heap allocation depending closures demanded possibly expose weak head normal forms reducing number updates possibly expose opportunities transformations case reduction constructor reuse inlining modify number free variables theta may increase heap residency due early allocation closures allocated due change number free variables 
try exploit previously described cases sure enter closure trying avoid building updatable closures simple fact closures entered cheaper allocate groups doing single heap check time 

floating lets outwards comparing different strategies course get optimal decision result depend case transformation win case transformation worsen code 
know benefits bigger exposing weak head normal form avoiding updates modest saving heap checks 
experimented different strategies floating lets right hand sides float float expose weak head normal form float mentioned binding strict better result achieved case transformation section experiment option 
results include effect floating inwards transformation chapter increases number lets occurring right hand sides 
obtained similar effects transformation turned 
discuss interaction seemingly incompatible transformations chapter 
expected exposing weak head normal forms worthwhile improvement doing floating 
floating hand mixed results higher risk making programs worse 
lead adopt option floating expose weak head normal forms worthwhile optimisation compiler 
average closure size measured execution programs average smaller floating expose weak head normal forms floating 
programs increased average closure size 
effect updates dramatic programs reducing number updates average performing fewer updates floating expose weak head normal forms compared floating 
floating case scrutinee benefit floating case scrutinee comes exposing transformations directly transformation case rec alts rec case alts 
floating lets outwards floating total instructions executed expose program float whnf float sched hidden infer prolog queens solid wang knights sorting pretty rewrite boyer cichelli lift boyer compress fluid gg reptile genfft ida maillist fft hpg mandel parser transform event typecheck veritas clausify minimax parstof wave main treejoin progs 
minimum maximum geometric mean floating total heap allocated expose program float whnf float wang compress infer prolog solid cichelli queens rewrite boyer hidden fluid lift parstof pretty hpg mandel parser clausify gg ida knights maillist minimax multiplier wave main genfft reptile sched boyer event typecheck fft transform treejoin progs 
minimum maximum geometric mean table floating instructions executed bytes allocated 
floating lets outwards example transformation exposed floating case scrutinee occurs body explicit constructor case 
body case 
body body case exposed case reduction transformation section 
floating transformations constructors floated ffl lambdas better done global transformation full laziness discuss section 
ffl case alternatives multiple alternatives major problem doing allocating regardless alternative taken particular taken 
increase heap allocation idea 
single case alternative gain going join lets allocated single heap check 
hand may lose opportunities transformations case reduction right hand side happens variable case floated 
details issue see section opposite transformation 
ffl body amounts swapping order allocation lets involved usually brings benefits 
possible inner right hand side mention binders introduced outer 
instance ordering lets may relevant occurs example case 
case 

floating cases outwards strictly able case transformation section improve code get benefit case 
case 
hand strictly transformation allow eliminate inner case resulting efficient code case 
floating inwards transformation described chapter eventually lead improved program 
floating cases outwards cases similar properties lets strict 
forbid doing similar transformations cases 
case floating application case expression floated past application case 

case 

main points case floating application try expose transformations fi reduction expression 
theta small amount code duplication atom 

floating cases outwards case case case floating case scrutinee case case transformation simplifies expressions case scrutinee case expression case case alt 
alt cm 
cm alt 
alt 
case alt 
case alt 
alt 
alt cm 
case cm alt 
alt 
particular instance case case transformation described aug kel ifs 
concerned things short circuiting boolean conditionals 
example consider expression boolean expressions boolean conjunction 
turns false point testing result case 
definition encapsulates property case true 
false 
false try transformations 
start construct just syntactic sugar case expression original expression really just case true 
false 
inlining definition gives case case true 
false 
false true 
false 

floating cases outwards applying case case transformation get case true 
case true 
false 
false 
case false true 
false 
second inner case expressions known constructor simplified case true 
case true 
false 
false 
operationally read expression evaluate result false return evaluate return result true 
short circuiting conditional expressed directly 
example shows problem case case transformation appears twice transformed expression 
evaluated occurrences different branches case expression danger code explosion careful 
code duplication major risk code duplication due case case transformation particular instances problem ffl inner case single alternative ffl inner case non error alternative 
instance deals cases branches case error branches branches introduced compiler handle pattern matching failures semantically equivalent bottom 
haskell code fragment case 
eas pattern match failure evaluation results empty list case 
eas 
error error pattern match failure 
floating cases outwards error function print error message abort execution 
instances case case transformation inner case non error branch situation similar described single branch case case 
eas 
error error pattern match failure 

case 
case eas 


case error error pattern match failure 

case 
case eas 


error error pattern match failure case error transformation section step 
join points recall result transforming boolean short circuiting example case true 
case true 
false 
false 
duplicated 
compiler short circuiting boolean expressions 
inserts jumps share code 
looks hard express universe discourse 
aug case case transformation implemented program transformation implemented code generator compiled jump 
avoid 

floating cases outwards eliminate code generator involvement altogether need compile jump reduce complexity involvement 
need bind common variable cont cont case true 
case true 
false 
cont false 
cont naive compiler non strict language build heap allocated closure cont 
evaluated returned certainly isn safe evaluate performing case analysis 
perfectly correct implementation inefficient compared compiling jump 
cont compiled jump 
cont special way continuation branches current execution path 
solution ffl perform simple analysis discover bindings escape current dynamic environment 
escape analysis common lisp compilers orbit example kkr successful non strict language expressions escape 
rare find non escaping continuations untransformed code written programmer 
ffl identify sort annotation sign purpose 
ffl compile jump adjustment stack pointer occurrences continuation 
advantage approach allows decision duplicate continuation example substituting cont share retaining expression binding cont taken subsequently quite independently case case transformation 
question eliminate bindings substitution applies expressions just binding continuations 
second advantage approach shared continuations copes commonly occurring situations 
example situation tag lets continuations normal lets 

floating cases outwards handled ad hoc manner pattern matching failure 
consider haskell function definition xs ys point example pattern matching equation fail match points empty list second 
case returned 
pey solved extending language special fail value treated special case code generator 
contrast translation core language avoids inventing special constructs xs ys fail case xs 
case ys 
ys 
fail xs 
fail cont fail variable detected non escaping continuation compiled jump 
question duplicate continuation share handled general elimination transformation inlining 
concluding note complication general case shown far 
consider expression case case true 
false 

xs 
case case transformation duplicate bind simple variable free variables xs 
solution lambda abstraction turn free variables arguments cont cont 
xs 
case true 
case 
cont xs 
cont xs false 
case 
cont xs 
cont xs 
floating cases outwards effects case case transformation table see effects case case transformation programs 
column presents results case case second effect performing case case duplicate code join points third column presents case case join points lets perform case case transformation 
effect case case transformation number instructions executed quite significant reducing number instructions executed average join points gives extra 
effects heap usage mixed programs allocating heap allocating 
expected case case transformation expose opportunities transformations specially case reduction transformation 
simple version transformation increases number case reductions average version join points major extra effect average 
join points allowed perform average case case transformations 
said join points essential compiler optimise special lets jumps 
join points negative effect see table compare effect turning special compilation non escaping lets 
believe approach case case transformation elegant generalises previous descriptions transformations allowing performed code duplication 
case floating right hand side cases may floated strict demanded lets case fc ik 
case fc ik 
strict fv fv ik fv transformation increases scope case expose transformations case reduction weak head 
floating cases outwards case case total instructions executed program join pts 
join pts 
queens mandel sched parstof sorting solid infer boyer fluid primes wave main reptile prolog cichelli clausify compress event genfft hidden parser pretty treejoin typecheck wang gg hpg lift transform ida mandel rewrite maillist veritas fft fft minimax multiplier knights progs 
minimum maximum geom 
mean case case total heap allocated program join pts 
join pts 
sorting queens sched parser compress pretty gg reptile fluid lift veritas prolog hpg ida infer multiplier rewrite cichelli solid treejoin knights event genfft fft mandel typecheck boyer rsa transform parstof clausify progs 
minimum maximum geom 
mean table case case instructions executed bytes allocated 
floating cases outwards detect non escaping lets total instructions executed program primes wave main parser clausify maillist mandel boyer fft fluid hpg mandel prolog reptile rewrite wang treejoin progs 
minimum maximum geometric mean detect non escaping lets total heap allocated program primes wave main parser clausify treejoin maillist mandel hpg boyer fluid parstof mandel prolog event fft gg knights reptile typecheck wang genfft multiplier rewrite compress hidden transform veritas progs 
minimum maximum geometric mean table non escaping lets instructions executed bytes allocated 
floating cases outwards normal form expression longer updatable closure thunk updates performed 
case multiple branches transformation code duplication occur branches 
avoided technique case case transformation section create new binding join point code duplicated case 

case 


avoids duplicating branches 
newly created implemented efficiently discussed section introduce major efficiency allocation costs 
lose benefit increasing scope case include benefit cases weak head normal form expressions updates 
case transformation remove opportunities transformation transformation useful cases case transformation applied right hand side functional type 
transformations obtain result see example case 


case case case case 
case 

case 

case floating case 


floating cases outwards change strictness information get transformed 
priority case transformation subtle reason single constructor type pair unboxing case transformation leading sequence 
unboxing case case case 



case case knows shape case 
case 

case 
reason case case join point respect outer case alternatives binders 
free variables 
advantage may simplified may case strict 
cheap eagerness interesting optimisation uses case floating transformation restriction strict 
keep semantic meaning transformation strict 
see strict see circumstances restriction relaxed 
restriction needed avoid problems case 
get evaluated evaluated 
float case get evaluated 
evaluation fails diverges program fail diverge 
floating cases outwards transformation applied 
problems doing transformation lazy lets ffl unbounded extra evaluation may occur ffl program may fail diverge changing semantics program 
change semantics program going transformation lazy lets guarantee expression case fail 
cost extra evaluation problem 
cost small willing pay expression evaluated anyway benefiting increasing scope case expression exposing transformations 
transformation specific cases cheap non failing cases 
cases primitive operations unboxed values primitive int addition subtraction multiplication similar operations floats doubles 
case doing optimisation called cheap eagerness myc aug perform possibly unnecessary small amount take advantage exposing optimisations 
transformation implemented code generator compilers source transformation 
example transformation 
case 
mkint 
case 
mkint 
cost creating closure possibly updating certainly greater evaluating 
may exposing transformations directly bound constructor 

strictness transformations aggressive version transformation analysis select possibly bigger cheap non failing expressions eagerly evaluated 
case floating transformations possible case floating transformations ffl floating case body 
precisely transformation pushing case branches discuss section 
just different ways looking transformation pushing case branch floating case body 
ffl floating case case alternatives 
similar swapping order lets achieve true swapping inner case branch outer 
possible cases single branch correct 
ffl floating cases lambdas 
achieves similar effect full laziness section allowing possibility sharing evaluation scrutinee 
discuss transformation section 
strictness transformations local transformations rely strictness information 
strictness analysis myc analysis widely lazy functional languages give information function argument guaranteed evaluated function body 
known going evaluated safely transform callby need call value evaluate arguments call implemented efficiently 
analysis identify bindings sure evaluated demanded body 
lets transformed evaluated earlier change semantics expression 
transformations describe section described pp transformations strictness information worker wrapper transformation 
pp experimental results results effectiveness transformations particular 

strictness transformations case case transformation done strict bound variable guaranteed demanded evaluation body right hand side weak head normal form case 
constructor type strict weak head normal form original expression allocating closure heap evaluated strict possibly updated closure updatable 
transformation evaluate bind saving cost update heap allocation update done originally place 
closure updatable avoid allocating closure entered evaluating advance 
weak head normal form perform transformation evaluation done case prefer bound form opposite transformation section 
compiler introduce extra restriction doing transformation type function type type variable instantiated function type 
restriction due implementation details stg machine cases objects function type 
unboxing case unboxing case transformation similar previous advantage exposing structure expression explicitly exposing constructor 
avoid code duplication type binding single constructor data type tuples boxed integers case kl 
kl single constructor type strict weak head normal form extra advantage compared previous transformation structure exposed transformations case reduction may exposed 

transformations binding introduced transformation eliminated example case 
case 
case 
case 
transformations constant folding constant folding exclusively primitive operations basic literals 
means transformation simplification done overloaded expressions num dict correct possible define instance num result expression 
problems arise doing constant folding phase compiler expressions simplified easy spot 
expression type int example easily spotted second addition translated case case 
case 

case 


transformations simplified 
doing addition gives case 
case 
obvious simplify 
unfortunately easy spot associativity level associativity may hold 
maxint may differ different maxint machine checks int overflow 
try exploit associativity commutativity increase opportunities constant folding 
constant folding basic predefined operations ints chars floats doubles ffl negation addition subtraction multiplication remainder division ints floats doubles ffl type conversion functions ints chars floats doubles ffl comparison operators ints chars floats doubles check overflows invalid operations constant folding 
check division zero currently check example addition ints greater maxint defined haskell 
compiler represents ints internally infinite precision integers easy check result operation maxint 
transform expression similar roughly cost exposes possibilities transformations occur 
example section case merging transform case eqint 

true 
false variable explicit constant 
assuming inline constant maxint 

transformations eta expansion perform general expansion expression functional type arity greater number lambdas enclosing 


assuming arity 
improves efficiency creating partial application entered called arguments called directly 
saves argument satisfaction check check arguments available implementations 
notion arity case bit different usual notion intend lose laziness adding extra arguments function 
example perform transformation 


receive arguments assume receives arguments partially applied arguments different behaviour expressions ffl closure allocated shared partial application partial application applied times ffl second receiving arguments closure allocated evaluated times partial application applied losing laziness 
concept arity directly related arguments function may receive number lambdas definition number arguments passed function performs actual evaluate case expression 
case expansion expansion case expression 
analyse case detail 
assuming functional type 
transformations case 

case 

ffl bad idea simple variable pushes redex inside lambda 
variable doing transformation moves evaluation inside lambda loses small amount call lambda 
ffl redexes probably bad idea reason 
problems occur particular scrutinee variable possible duplication basically restricted entering variable useful transformation putchar putc inlined giving putchar 
case 

arity exposed explicit lambda better saturated call existing 
prefer function form putchar 

case 
may closure multiple times putchar partially applied 
strategy ffl right hand sides functional type ffl variable ffl right hand sides manifestly weak head normal forms 

transformations interacting effects expansion table see effect expansion benchmark programs 
effects clearly positive average improvement total instructions executed total heap allocated 
transformations interacting section follow examples big effects achieved transformations described previous sections 
motivating examples shown real application programs 
effects usually involve combination transformations give idea transformations interact improve code generated 
interesting examples transformations interacting previous sections case case case reduction transformations achieve effect short circuiting boolean expressions 
repeated evaluations expression type int source code generates code compiler case mkint 
case mkint 
case 
mkint due inlining boxed operator arguments applies primitive unboxed operator boxes resulting value 
case twice case reduction transformation eliminate second evaluation generate code expect case mkint 
case 
mkint transformations unboxed data types pl 

transformations interacting expansion total instructions executed program prolog parser pretty reptile maillist treejoin rewrite sorting fft knights lift mandel typecheck veritas gg hpg multiplier minimax mandel fluid parstof genfft boyer compress fft hidden infer solid wave main progs 
minimum maximum geometric mean expansion total heap allocated program treejoin pretty sorting maillist reptile parser lift prolog veritas hpg gg mandel typecheck fluid multiplier knights rewrite compress fft rsa boyer mandel minimax boyer wave main parstof progs 
minimum maximum geometric mean table expansion instructions executed bytes allocated 
transformations interacting lazy pattern matching lazy pattern matching inefficient 
consider case 
case 
allocates thunks updatable closures 
strict strictness analyser easily spot binding strict unboxing case transformation case 
case 
case 
case reduction transformation eliminates case expressions right hand side spotted dead code get case 
efficient original version 
error tests eliminated elimination redundant alternatives redundant cases arises inline functions error checking 
typical example rem div rem div error check zero 
second check eliminated transformations 
transformation code case 
error rem zero divisor 
case rem 
case div 
mkint 

transformations interacting compiling factorial program section show transformations interact generating efficient version factorial program 
definition factorial function core language fact int 
int fact 
case 
mkint true 
mkint false 
fact mkint initially inline definition explicit unboxing boxing operations arguments results 
lead cases unboxing value previously unboxed just boxed redundant operations 
time simplifier applied transforms code ffl inlining basic operations ffl applying fi reductions appropriate ffl avoiding redundant boxing unboxing values ffl doing case case transformations appropriate 
doing code transformed fact 
case mkint 
case 
case fact case 
mkint mkint 
case 
mkint 
mkint avoiding unnecessary boxing unboxing operations improvement 
better job strictness analyser worker wrapper transformation pp split function worker wrapper pair functions 
transformation tries split functions strict arguments functions 
transformations interacting ffl wrapper function strict arguments single constructor data types calls ffl worker function original function receives strict arguments unboxed 
see code fact transformation split fact wrapper fact worker fact int 
int fact 
case mkint 
fact fact int 
int fact 
mkint needed body case 
case fact case 
mkint mkint 
case 
mkint 
mkint idea worker wrapper transformation done glasgow haskell compiler minimal changes original functions splitting simplifier rest job 
get inefficient worker wrapper pair efficient transformations 
simplifier called inline wrapper fact worker fact get worker call 
doing get opportunities removing extra boxing unboxing operations case case transformations fi reductions fact 
case 
case 
case fact mkint 
case 
mkint 
mkint definition huge improvement initial keeping values unboxed computation 

confluence termination confluence termination set transformations seen set term rewriting rules 
set transformations ffl correct transformed code semantics original code 
prove correctness transformations chapter 
ffl efficiency improving transformed code costs execute original 
return topic chapter 
addition considerable practical advantage set transformations ffl confluent apply transformations order applicable get result 
important sure losing transformations generating worse code choosing apply transformation applicable 
ffl terminating process simplification terminates meaning get point transformation applicable 
particularly careful transformation generate code transformed back original code transformations transformations undo transformations 
transformations simple left right form side conditions candidates treated rewrite rules term rewriting system 
mat proof confluence termination subset rules obtained order sorted equational theorem proving system mat developed glasgow university 
initially system prove confluence termination subset rules containing case floating rules 
set extended include constructor reuse beta reduction inlining retaining properties 
full set transformations clearly non confluent instances choice rules applied point result different code confluent case vs case float section 

complete set local transformations performed simplifier pass glasgow haskell compiler 
set transformations design simplifier core language allows complex transformations performed composing simple transformations 
combined effect transformations discussed chapter 
chapter local transformations implementation results chapter details implementation transformations previous chapter section effect real programs section 
implementation transformations previous chapter implemented simplifier pass compiler consists sub passes 
analyse perform occurrence analysis dependency analysis 

simplify apply transformations possible 

iterate repeat steps transformations take place optionally predefined maximum number iterations reached 
occurrence analyser collects information binders occurrences particular number occurrences location ffl occurs inside lambda abstraction ffl times occurs ffl occurs argument function constructor 

implementation information inlining decisions discussed chapter 
global information gathered simplifier pass run 
dependency analysis needed floating lets lets section may leave recursive bindings necessarily recursive 
knowing precisely lets recursive useful transformations lets generate efficient code 
information needed dependency analysis gathered occurrence analysis 
step apply transformations possible traversal input program 
see importance performing transformations possible pass consider sequence transformations transformation enables 
iteration step performed transformation entire program re analysed step re traversed step transformation 
multiple iterations unavoidable possible sequence transformations single pass 
compiler repeats steps fixed point reached optionally supplied maximum number iterations reached 
reduce number iterations algorithm recursively simplifies components language constructs subexpressions checks transformations constructor applied see section 
benchmark programs simplifier iterate times typically needing iterations traversals code second perform simplification reach point transformations applied 
compiler applies simplifier global transformations 
simplifying global transformation global transformation effective simplifying global transformation allows simplifier take advantage changes global transformation 
renaming program transformation system worry name capture 
example erroneous transformation 




implementation transformation fails originally free occurrence argument captured abstraction 
various sophisticated solutions problem adopted simple uniquely rename locally bound identifier pass simplifier 
producing entirely new program anyway side effecting existing costs little extra rename identifiers go 
example 



simplifier accepts input program bound variable names including shadowing binding hides outer binding identifier produces program bound identifier distinct name 
useful passes compiler essential keep simplification process simple possible worry name clash problems 
course simplifier implemented renaming introduce extra avoid name clashes 
renaming needed circumstances performing fi reduction 
simplifier function key function simplify expressions type 


type signature understood ffl environment type provides kinds information mapping old identifiers new identifiers renaming information bound identifier enclosing context variable bound constructor information right hand side inlining decisions chapter 
ffl second third arguments specify expression simplified expression list arguments applied 

implementation ffl result simplified expression wrapped monad 
monad purposes supply unique names simplifier easily invent new names binders renaming 
gathers counts kind transformation applied statistical purposes 
counts step decide simplification process reached fix point 
simplifier invariant env expr expr env expression returned env expr semantically equal hopefully efficient expr renamings env applied applied arguments arguments carried inwards accumulating parameter 
convenient way implementing transformations float lets cases applications 
order language constructs simplified ffl applications simplified argument list 
simplification turns lambda expression apply beta reduction 
turns case float case application simplify argument list 
ffl lambda expression body simplified 
ffl expression right hand side simplified may turn case exposing floating transformations 
turns constructor record information environment 
may apply case transformation strict 
body simplified environment possibly augmented information right hand side 
ffl case alts case expressions expression simplified possibly exposing case scrutinee transformations 
may expose variable constructor case scrutinee leading case reduction transformation example 
case alternatives simplified 

results results verify effectiveness set transformations performed series experiments transformations enabled disabled 
measurements nofib benchmark suite described chapter 
discuss transformation occurs compilation nofib programs effect simplifier performance programs 
transformation 
passes glasgow haskell compiler aware existence simplifier produce inefficient code knowing code improved simplifier 
unfair compare directly simplified program simplification 
minimise effect give idea benefit simplifier sets results section completely program 
leaves trivial bindings code lets binding variables variables minimally simplified version set 
minimal simplification consisting single non iterative run simplifier transformations turned case floating application beta reduction inlining trivial right hand sides variables literals 
full run simplifier iterations limit reached 
excludes effects strictness analysis information excludes strictness transformations 
full run simplifier followed strictness analysis includes transformation see pp followed second full run simplifier 
fully optimised run compiler 
includes optimisations compiler including ones describe chapters thesis 

results tables raw count number times transformation applied programs nofib benchmark suite 
transformation disabled occurred particular run omitted column 
second column presents number tokens counted lexer programs giving rough idea size 
measured transformations numbers meaningful instances explicitly created transformations purely practical reasons 
ffl dead code elimination ffl dead alternative elimination ffl default binding elimination ffl constant folding 
measure effect cheap eagerness mixed forms case floating lets 
opportunities transformations case reduction rarely occur explicitly source code 
true transformations generated compilation process desugaring inlining expressions take place 
due way transformations interact transformation turned numbers transformations affected 
programs perform iterations simplifier fourth iteration perform transformation showing system benchmark programs reaches fixed point iterations 
maximum number iterations runs simplifier runs fully optimised version 
effect transformations table see effect transformations instructions executed heap allocation benchmark programs 
compiler relies transformations process desugaring decided results relation 

results constructor case case case case max 
program tokens fi reduction reuse reduction elim 
merge error iter 
boyer boyer cichelli clausify compress event exp fft fft fluid genfft gg hidden hpg ida infer knights lift maillist mandel mandel minimax multiplier parser parstof pretty primes prolog queens reptile rewrite rsa sched solid sorting transform treejoin typecheck veritas wang wave main transformation count 
results float case float program app 
case app 
case case exp boyer boyer cichelli clausify compress event exp fft fft fluid genfft gg hidden hpg ida infer knights lift maillist mandel mandel minimax multiplier parser parstof pretty primes prolog queens reptile rewrite rsa sched solid sorting transform treejoin typecheck veritas wang wave main transformation count 
results simplifier total instructions executed program compress reptile sorting treejoin pretty solid ida hpg maillist gg parser parstof prolog genfft lift primes sched veritas fluid boyer fft rewrite boyer event hidden multiplier typecheck fft mandel infer transform wave main mandel minimax cichelli knights wang clausify queens rsa exp minimum maximum geom 
mean simplifier total bytes allocated program compress sorting event solid sched pretty parser maillist minimax reptile treejoin gg prolog fluid hpg transform rsa wang lift veritas clausify ida parstof boyer multiplier rewrite wave main boyer cichelli hidden knights fft infer mandel fft exp genfft mandel primes queens typecheck minimum maximum geom 
mean table simplifier instructions executed bytes allocated 
poor results programs strictness analysis column due absence floating inwards transformation chapter 
see poor results disappear column 
clear transformations account improvement instructions executed heap allocated 
mentioned interact quite heavily transformations compiler believe actual effect greater 
details implementation simplifier pass glasgow haskell compiler measured effects set local transformations nofib benchmark suite 
results show transformations small simple major effects performance real programs due way interact achieve effect complicated transformations 
chapter floating chapter presents collection transformations call floating transformations concern exact placement 
big surprise floating substantial difference program performance 
distinguish forms floating long distance transformations may move bindings far original positions third local ffl floating inwards moves bindings far inwards possible section 
ffl full laziness transformation floats selected bindings enclosing lambda abstractions section ffl local floating fine tunes location bindings 
issues concerning local transformations local floating lets discussed section chapter discuss local floating conflict transformations floating inwards transformation 
briefly discuss floating cases outside enclosing lambda abstractions section related full laziness transformation 
floating lets inwards floating inward transformation observation things equal inward binding moved better 
example consider expression 
floating lets inwards case 
ps 
binding branch case moved branch case 
ps 
code better original reasons ffl turns form ps closure allocated 
transformation thunk updatable closure allocated regardless value ffl new position binding guaranteed demanded evaluated body strictly body 
enables transformed case case transformation section allocating thunks 
suggested binding floated inward far possible point floated keeping occurrences bound variable scope 
important exception rule highly dangerous float binding lambda abstraction 
problem moved lambda allocated time lambda entered 
usually anticipate times lambda entered execution program take risk increasing allocation unknown factor 
consequence fact evaluation strategy fully lazy case implementations functional languages 
evaluation strategy sk combinators tur example fully lazy need restriction 
aware suggests transformation context lazy functional languages especially improving strictness analysis 
transformations thesis suggested inspecting actual code generated glasgow haskell compiler 

floating lets inwards benefits floating inwards see benefits transformation trying achieve 
closures may initially defined scope larger needed 
particularly harmful cases defined localised context reduce allocation moving bindings single case branch case case alt 
alt 

alt 
alt 
transformation closure allocated regardless branch taken needed alt branch taken 
transformation allocated alt branch taken 
happen floating inwards right hand side 
details advantages disadvantages forms lets discussed section exactly opposite transformation discussed 
discuss apparent incompatibility transformation section 
increase opportunities case transformation section moving closure local context closure may strictly demanded 
example regarding cases floated branch guaranteed demanded new context strict arguments 
demanded alt branch taken 
guaranteed demanded case transformation case case alt 

alt 
case 
alt 
alt 

floating lets inwards happen floating inwards right hand side case 

increase opportunities case reduction transformation 
example optimisations happen floating lets inwards case reduction transformation section case 
case 
binding moved case branch get case 
case 
compiler spot inner case branch enclosing case eliminate inner case inline case 
case 

risks floating inwards possible disadvantages floating inwards may increase decrease closure sizes due change number free variables closures floating consequently increase decrease total heap allocation 
moving unaffected moving free variables moving new free variables weren free variables variable bound moving 
expect increase number free variables reduce number free variables moving free variables free variables free variables right hand side moved 

floating lets inwards may increase decrease number heap checks lets originally allocated perform single heap check may split separate groups demanding extra heap checks 
possible due floating joins group lets number heap checks reduced 
may hide opportunities transformations 
issues related discussed section 
implementing floating inwards algorithm floating lets inwards 
floating inward function fi takes arguments expression list bindings pushed expression returns new expression bindings pushed subexpressions far possible 
algorithm keeps invariant fi ae ae algorithm works collecting bindings environment expression ffl drop bindings just outside expression expression contain subexpressions lambda expression 
ffl try push bindings subexpressions call branches drop points expression 
done function checks binders branches 
know bindings branches fv function returns free variables expression 
cases possible drop points bindings case scrutinee case alternatives 
lets possible drop points bindings body 
floating lets inwards fi expr binding expr fi ae ae fi ae ae fi ae ae fi op ae ae op fi ae ae fi fi ae fi ae fi ae fi ae fi ae ae ae ae fi ae ae ae ae fv fv fv ae fi case 
ae ae case fi ae 
fi ae ae ae ae fv fv ae fi ae fi ae fi ae ae ae ae ae fv fv ae fi fv ae fi ae fi ae fi ae ae ae ae ae fv fv ae algorithm floating inwards 
floating lets inwards right hand side non recursive binding right hand sides ffl drop bindings branch just outside expression 
notice bindings consider 
look inner 
right hand side body inner panic leave binding body body 
drop binding add list things drop decision drop 
important keep list bindings dropped specific order help partitioning list drop points 
earlier bindings list may refer bindings list reverse 
improving rec rule possible improvement rule recursive lets break recursive groups introducing local recursion binders bindings 
example rec rec rec 
right hand side 
perform optimisation believe rare case introduces extra complexity algorithm 

floating lets inwards separating bindings drop points function separates bindings drop points crucial function 
idea list bindings distribute inside collection drop points inside alternatives case example drop points right hand sides body binding example 
algorithm proceeds follows list sets free variables drop point list floating inwards bindings 
possibilities binding drop points dead code remove list 
binding go drop point goes 
free variables free variables drop point new version list sets free variables looking drop point bindings updated take fact account 
binding inside multiple drop points go drop drop points point 
means free variables go single drop point update list sets free variables take fact account 
simple way doing making free variables part sets contain binding part sets maintaining order bindings lists ones occurring having ones occurring list allows process list traversal 
relation local floating transformation ones float lets outwards floating section floating application section floating case scrutinee section opposite things see 
initially transformation undo ones fact objectives trying achieve floating inwards affected 
floating lets inwards var binding binding bind binds bind binds bind bind fvs bind binds bind fvs bind fvs bind binds function floating outwards transformations see 
float inwards float outwards usually performing transformations take advantage new contexts exposed floating inwards strictness analysis case transformation 
allow local floating decide place remaining lets lets right hand sides 
see losing benefits floating inwards transformation floating outwards ffl lets pushed lets right hand sides trying local strictness information increase chances pushed transformed case case transformation 
assuming strictness analyser transformations related applied floating outwards 
case transformation happen leave decision place transformations float lets discussed section 
ffl lets pushed case branches expect 
increase chances pushed transformed case case transformation just discussed 

floating lets inwards fi ae ae fi fi case 
ae ae ae case fi 
fi ae ae ae ae fv fv fv ae algorithm floating inwards modified rules transformation takes place longer binding possibly float 

avoid closures allocated regardless branch taken saving allocations 
performing local floating outwards float lets multi branch cases exactly avoid creating problem transformation undone 
full laziness transformation section may decide float lets multi branch cases going floated past lambda 
case lets may floated outwards hoping increased possibility shared important avoiding allocation branches taken prioritise full laziness floating inwards 
return point section 
expose opportunities case reduction transformation 
happens able move case branch anymore 
transformations algorithm floating inwards applications case effects leads floating lets case branches 
particular floating lets case section floating lets applications section floating case applications section case case section transformations applied code cases lets case function position applications 
rules simplified drop bindings immediately finding application drop bindings floated case scrutinee outside case 
lead rules modified 

floating lets inwards improvements algorithm improvements algorithm obvious implemented algorithm 
suggested looking programs getting worse performing transformation 
improvements described 
dropping lets outside type lambdas dropping lets outside type lambdas normal lambdas dropped just type lambdas normal lambdas 






resulting expressions identical performance type lambdas eventually removed offer opportunities transformations floated right hand side 
reason preferring second form occurs happens floated case want move back original position local floating turning back weak head normal form non updatable closure 
easy move binding due type lambda floating lets type lambdas lambdas see section complicated global transformation need check type variable right hand side allow float type lambda 
certainly true case avoid complication relying global transformation fix problem dropping outside type lambdas 
achieved introducing extra rule 
problem caused programs cichelli execute instructions floating inwards enabled 
duplicating lets case branches may want duplicate lets branch case may generate code duplication 
doing risk 
floating lets inwards fi ae ae fi algorithm floating inwards extra rule type lambdas duplicating may saving allocation case branches branches allocating third branch taken 
perform aggressive version floating specific circumstance binding constructor 
minor effects usual optimisation setup seen table effect programs object instructions program size executed allocation parser boyer treejoin ida prolog fluid gg veritas rewrite tried aggressive inlining strategies chapter constructors created worker wrapper transformation pp causing lot allocation opportunities floated inwards due amount code duplication caused inlining 
look simple example pair pair case 




floating lets inwards suppose join point cost terms allocation mentioned third case alternative 
inlined push pair right hand side 
inlined pair left case alternatives allocate 
caused increase instructions executed heap allocated 
improvement aggressive floating inwards strategy programs compiled aggressive inlining strategy shown table 
normal aggressive floating floating object instr 
obj 
instr 
program size exec 
alloc 
size exec 
alloc 
treejoin wave main maillist fft fluid hpg prolog veritas ida rsa progs 
minimum maximum geometric mean change strategy floating lets case branches bound constructors certainly worthwhile major impact program size 
possible solution push lets occur branches 
tried option branches outer level branches inner case outer case branches 
case worst performing examples 
shown overhead floating lets small decided float 

floating lets inwards results section effect floating inwards transformation including modifications previous section programs nofib benchmark suite 
looking transformation achieves effects section affected possible drawbacks section 
questions answered allocation saved result floating inwards 
moving bindings inwards may increase decrease closure size due change free variables closure possible example reduce number objects allocated increase heap allocation 
compare total heap allocated programs run floating inwards enabled 
runs strictness analysis turned measure benefits floating inwards additional benefits case transformations exposed floating inwards 
improvement total heap allocated high programs average 
programs allocation increased probably due closures having size increased program benefits floating inwards 
measurements comparing setups gave results ffl effect average average closure size maximum effects increase decrease 
ffl heap checks unaffected average extremes heap checks 
ffl instructions executed maximum improvement average improvement 
ffl average instances case reduction transformation 
benefit trying get floating inwards 
question strictness analyser helped floating inwards 
time start comparing number case case floating transformations occurred compilation main transformations enable strictness analysis 
got average ffl cases 
floating lets inwards float strictness analysis total instructions executed float program sched boyer boyer primes hpg maillist mandel parser parstof cichelli typecheck mandel rewrite treejoin programs minimum maximum geometric mean float strictness total heap allocated float program sched boyer parstof boyer parser cichelli mandel maillist ida rewrite sorting treejoin solid wang programs minimum maximum geometric mean table float strictness instructions executed bytes allocated ffl case floating lets ffl case reductions ffl heap checks 
effect time including strictness analysis heap allocated instructions executed due floating inwards 
programs affected get better results peak reduction heap allocation average improvement 
programs get slightly higher allocation 
average effect instructions executed relatively small programs improved 
important effects transformation ffl reduction total number updates performed reduced program mandel average 
ffl average change average closure size increased reduced 

floating lets inwards float total instructions executed float program sched mandel wave main ida treejoin maillist boyer cichelli compress event fft fluid parser parstof solid wang programs minimum maximum geometric mean float total heap allocated float program sched wave main mandel parstof treejoin maillist cichelli parser boyer ida fft knights boyer clausify event fluid hpg prolog compress gg lift rewrite solid wang programs minimum maximum geometric mean table float instructions executed bytes allocated 
floating lets inwards related idea pushing lets equivalent case branches appel sml compiler app called hoisting 
sml strict language saves evaluation branches taken guaranteed save closure allocation may benefit new local context exposing transformations 
push lets lets benefit doing sml strict language evaluated anyway 
presence side effects language restrict class lets suitable transformation purely functional ones side effect free 
uses hoisting group lets order possibly share closures reduce allocation code size 
optimisation possible benefit grouping lets reduce heap checks discussed section 
implemented transformation local transformation suitable case push lets lets done best way single pass accounts complex algorithm 
get results transformation best results improvements experiments app programs 
majority programs unaffected transformation reflected low average improvement 
hand effect reasonably big programs hits 
little overhead compilation process perform transformation major negative effects believe useful optimising transformation compiler 
interesting fact opportunities applying transformation introduced desugaring transformations original program programmers tend group local definitions single clause defining nested way closer place case branch 

full laziness knowing transformation performed programmer may write code readable style worrying doing sort transformation hand 
full laziness previous section concluded floating binding inwards generally thing 
binding floated enclosing lambda abstraction evaluation shared applications abstraction larger gains may accrue 
example consider xs 
rec 
length xs 
length xs allocated recomputed recursive call recomputation avoided floating binding outside abstraction xs 
length xs rec 

transformation called full laziness 
originally invented hughes hug pey variant lambda lifting algorithm 
pl subsequently showed decouple full laziness lambda lifting regarding exercise floating rec bindings outwards 
tak presents full laziness separate transformation 
need full laziness transformation due evaluation strategy fully lazy 
possible implement fully lazy evaluation strategies tur combinators implementations efficient current implementations graph reduction pey 
despite long full laziness transformation functional language compiler know 
possible reason risk introducing space leaks sharing big data structure rebuilt original code 
return point sections 
contribution results actual full laziness transformation showing may improve program performance 
full laziness quite substantially risk creating space leaks may happen real programs 
ways reducing risk space leaks retaining benefits full laziness improve algorithm pl preventing unnecessary floating place performance implications 
benefits full laziness full laziness transformation see section regarded floating lets lambdas algorithm bind expressions floated shared 
discussing regard just floating lets lambdas 
full laziness benefits full laziness transformation save great deal repeated 
object practice programmers don write programs applies non obvious situations 
example came practice part program performed fast fourier transform fft 
programmer wrote list comprehension similar map thetas 
realise expression thetas recomputed value 
list comprehension syntactic sugar translated core language thetas appeared inside function body 
full laziness transformation lifted thetas past lambda allocated computed example discovered programmer trying find reason widely differing performance program different haskell compilers 
clear remarked previous sections beware floating binding inside lambda abstraction doing exact reverse full laziness transformation duplicate arbitrary amount 
lifting things inside lambda particularly significant loops recursive functions 
consider 
fib case 
full laziness 

floating mean allocated computed call saving unbounded number recomputations allocations 
consider recursive functions nonrecursive called recursive function passed argument higher order function non recursive functions may called unbounded number times 
notice objective achieved generalisation idea removing invariant loop imperative language asu 
right hand side floated weak head normal form recomputation saved sharing invocations function allocation may saved avoiding reallocation object multiple times 
full laziness transformation interacts transformations exposing opportunities 
examples inlining 
right hand side simple allows inlined 
eta expansion example supposing inline arity floated eta abstracted laziness lost 
expression risks full laziness risks performing full laziness 
full laziness theta lambda floated entered risk allocating object allocated original program 
full laziness gives gain lambda abstraction applied 
program analyses detect lambda abstraction applied analyses just available mar mtw 
full laziness transformation may modify number free variables closures increasing decreasing size 
floated modified bindings free variables may decreased due floating floating binding free variables may longer free variables binding moved variable bound binding free variable increased effect free variables extra free variable binding floated 
effect increasing decreasing closure sizes increasing decreasing heap allocation 
theta final disadvantage full laziness difficult quantify may cause space leak 
consider expression 
body 
returns list integers idea float binding outside abstraction 
doing avoid recomputing call hand reasonably cheap recompute large list take lot heap alive long alive 
turn constant space algorithm linear space worse 
discuss deal problem section 
full laziness parallelism compiling parallel code full laziness undesirable transformation due fact increases sharing code 
fragment code run times slower processor grip parallel machine code full laziness performed 
full laziness gen board gen board gen int 
board 
board gen board gen board new par rest seq new rest new row rest gen row int 
row row row shift copy board 
problem case expression shift copy board floated row function depend shared calls row 
parallelism fully exploited call row thread create private copy data generated shift copy board 
sharing expression bottleneck created processes depend single copy 
reducing risk space leaks discussed floating uniformly distinguishing top level local lets 
important distinction major sources space leaks floating lets precisely float top level specifically float constant expressions top level 
top level constants called constant applicative forms cafs 
depending strategy garbage collector cafs may garbage 
garbage chalmers lml hbc compiler greater risk floating top level local floating 
garbage collector collect cafs case glasgow haskell compiler want float expressions top level may create large data structures kept heap entire execution program needed anymore 
possible solutions garbage collect cafs properly just normal local closures 
ideal solution 
theta garbage collector reverse cafs 
allow garbage collector revert cafs unevaluated form start 
full laziness space 
raises problems cafs revert unevaluated form cafs expensive recompute reverted 
theta cafs floated top level set non updatable 
extreme version previous solution cost recomputing caf large discarding reasonable approach 
theta float top level 
floating just letting potential cafs float top level 
conservative keep trivial closures constants reallocated reevaluated multiple times allocated shared 
discuss option chapter 
float top level cafs generate space leak 
similar previous selects static information closures safe floated 
includes example expression types small bounded amount heap data types recursive contain recursive data types subcomponents including example fixed size arrays basic types int float char 
literal constants 
small constant lists strings arity constructors nil 
approach currently glasgow haskell compiler 
solution select lets floated general avoid risk space leaks floating top level 
currently strategy lets floated top level 
implementation reasons clear perform decision full laziness pass may argue issue related local floating 
important notice problems generating cafs restricted floats past lambdas full laziness simple floating problems may arise float caf 

full laziness implementing full laziness transformation algorithm section extended version algorithm pl 
extensions deal essentially issues floating top level selection maximal free expressions worth floating 
version handles type abstraction application 
full laziness transformation done passes 
pass annotates rec binder level number 
general level number number lambdas enclose expression floated 

second pass uses level numbers rec float binding outward just outside lambda level number greater binding 
fact don leave just outside lambda floated top level go past type lambdas just outside lambda similar reasons ones lead floating lets inwards hit type lambda discussed section 
set level algorithm basic algorithm tagging lets level numbers sl set level 
function sl expression current level tuple containing lambda level type lambda case level initially set environment mapping variables including type variables level number 
need minor level numbers clear section essentially related issues 
floating lets top level case alternatives introduce binders expressions form case ws 

refer lambda level major level number type lambda case level minor level number 

full laziness sl expr level env expr sl ae sl ae sl ae sl op ae op sl ae sl ae ae ae phi fv 
sl ae sl ae ae ae phi ft 
sl ae sl ae sl ae sl ae sl case 
ae case sl ae 
sl ae ae ae phi fv 
jv vars alt sl fv ae fv sl ae sl ae ae fv ae ae phi fv 
sl ae ae sl ae sl ae ae fvars algorithm setting levels full laziness 
full laziness want lets coming floated top level 
need way knowing lets float past binders introduced case alternative ones 

floating past type abstractions type abstractions type applications removed stages compilation process just keep type information correct transformations 
want lets floated due type abstractions way knowing happen keeping level numbers lambda variables type variables separate 
single minor number purposes separate level numbers type variables case alternative binders 
important rules set level algorithm ffl lambda level number incremented set lambdas level lambda variables 
ffl type lambda case level number incremented set type lambdas level type lambda variables 
ffl try bind partial applications floated full application avoid sharing partial applications worthwhile 
discuss issue section 
ffl type lambda case level number incremented case level variables bound case alternatives 
ffl level number maximum level number free variables including type variables excluding variables bound 
level right hand side analysed level assigned 
differs algorithm pl current level analyse right hand side 
cause unnecessary floating occur levels binders right hand side bigger needed simplicity assume assign different level numbers variable lambda 

full laziness case 
question level numbers variables case alternative 
analyse right hand side level number assign level 
try float binding leave know go past lambdas float case alternative major level number case alternative binder major level number 
analysed right hand side current level number assigned level numbers think floated case alternative fact eventually go past lambda doing 
ordering compute follows maj min maj min maj maj maj maj min min sl function needed expressions floated lambda bound floated 
look example 
case 
ps 
subexpression free abstraction expensive computation potentially shared applications simple principle address shortcoming simply binding 
case 
ps 
binding floated binding 
sl function checks expression lambda level number indicates floated 
full laziness binds expression 
avoid binding right hand side weak head normal form expression 
sl able float expressions bound original program 
possible alternative bind expressions cases bodies case alternative right hand sides potentially expression bound 
sl function useful discuss possible variations algorithm 
variations algorithm things improved algorithm ffl abstracting type variables 
type variables get way prevent floating place 
example suppose bound outside abstraction 


float type variable scope 
rules give major level number ensure binding isn floated scope 
particularly painful cases notably patternmatching failure bindings fail error ty pattern fail 
really get lifted top level despite free type variable ty 
approaches ignore problem scope type variables fix 
take approach procedure 
binding free type variables maximum level number strictly greater get ordinary variables type variables offending type variables keeping floating tn tn 
tn usual level number type variables account maximum level number ordinary free variables 
full laziness type variables tn free 
floated leaving type application place 
modification achieved modifying sl rule detect conditions type variables necessary 
reason strategy perfect subsequent binding mention theory floated get pinned inside binding binding floats 
believe strategy catches common cases 
ffl split lambdas 
possible variation algorithm assign different level numbers lambda 
allow lets floated places lambdas originally 



helpful cases partially applied argument partial application shared applications second argument 
case allocated evaluated shared applications 
case second form efficient trigger multiple argument satisfaction checks reasons 
modification done simple modification rule 
measured effect splitting lambdas benchmark programs major negative effect performance compared non splitting version shown table split lambdas 
ffl bind partial applications floated 
allow partial applications bound floated 




full laziness full laziness total instructions executed split program normal multiplier gg boyer clausify event veritas ida transform fluid mandel lift maillist mandel treejoin fft prolog rewrite hpg solid genfft hidden typecheck parser reptile primes sched boyer wave main programs minimum maximum geometric mean full laziness total heap allocated split program normal multiplier minimax boyer fft gg veritas clausify infer pretty event mandel parstof ida transform knights rsa fft mandel prolog rewrite fluid maillist genfft lift hpg reptile hidden solid treejoin sched typecheck primes boyer parser wave main programs minimum maximum geometric mean table full laziness splitting instructions executed bytes allocated 
full laziness useful perform argument partially applied partial application shared applications second argument 
second form efficient conditions met 
believe case implement modification 
implemented modifying rule sl partial applications expression arguments 
ffl careful giving bindings level number mean floated enclosing lambdas possibly create space leak don get top level 

map 
map just bad floating top level assuming top level function garbage collected 
options lets normally get level number directly related problems solutions discussed section 
proceed algorithm lets create space leak criteria section give level number allowing floated past lambdas greater due case alternative variables example 
level allow floated top level 
achieved algorithm giving level top defined lower 
allow binding go past top level lets 
may create space leak choose options ordered safest risky give level number won go past outermost lambda course current major level case leave 
leave level 
treat just non leaky lets allow floated top level level 
performed measurements options shown tables 
option caused major space leak currently option glasgow haskell compiler 

full laziness full laziness strategy total instructions executed program solid minimax cichelli lift boyer parstof rewrite parser programs minimum maximum geometric mean full laziness strategy total heap allocated program cichelli solid minimax knights lift rewrite gg veritas parser programs minimum maximum geometric mean table full laziness strategy instructions executed bytes allocated notice numbers relative program full laziness applied column far worse setups shows improvement version full laziness see chapter 
reason odd behaviour due binding left just inside function definition avoiding transformations worker wrapper transformations occurring 



float algorithm float algorithm 
receives annotated expression level number returns expression paired list bindings floated outwards 
drop just outside lambda level number go past enclosing type lambdas just outside lambda case allow float past 

full laziness full laziness strategy residency program gcs bytes ratio gcs bytes ratio gcs bytes ratio cichelli clausify event exp fft mandel parstof sched typecheck genfft mandel parser boyer infer ida rewrite gg hpg multiplier rsa progs 
minimum maximum geom 
mean table full laziness strategy residency 
full laziness fl expr level 
expr binding fl fl fl fl op op fl ae ae ae fl ae ae ae fl ae ae ae fl ae ae ae fl ae ae fl fl ae ae fl fl case 
case 
ae ae ae fl ae fl ae ae ae ae ae fae algorithm floating lets full laziness 
full laziness fl fv ae ae fv 
ae fae fv ae ae fae ae fl ae fl ae ae ae algorithm floating lets full laziness function splits list bindings sets bindings dropped immediately go bindings floated 
binding floated just far escape lambdas escape 
consistent idea bindings far possible floating inwards section 
actual implementation exception bindings level top floated right top level 
difference algorithm pl implicitly floats lets lets partitioning reached 
binding moved definitely escape lambda 
floating inwards full laziness think know perform full laziness transformation floating inwards relax restriction floating inwards past lambda expression floated outwards full laziness transformation 
true risky 
expression inside lambda may simplified impossible pulled 
follow example show happens case 
fib 
case 
case 
full laziness 
case 
floated lambda strictly case transformations take place 
code 
case 
case fib 
case 
case 
case 
expression fib floated lambda bound inside lambda 
fib computed time lambda expression entered 
see section case floated lambda cases possible multi branch case lambda case want float 
discussion applies inlining inside lambdas inline arbitrary expressions inside lambdas discussed chapter relying full laziness undo necessary expressions due transformations impossible taken back lambda 
results measure effect full laziness different ways concentrate effect total heap allocated number updates residency number instructions executed 
expect heap allocated instructions executed number updates show improvements due increase sharing hope residency increased significantly 
effect total heap allocated instructions executed 
column full laziness turned second floats bindings select non leaky top level local 
full laziness context third column presents normal full laziness setup floats top level non leaky bindings 
see programs significantly affected full laziness allocating times heap running twice time full laziness turned 
average improvement heap allocation instructions executed surprisingly result 
effect heap residency mixed results significant increase programs programs small residency easily affected transformation 
quite surprising find residency reduced full laziness transformation 
explained example 
length full laziness length 

expression alive garbage collected second garbage collected evaluated time evaluated 
programs unaffected transformation affected show significant improvement 
impact compile time negligible 
believe results justify presence full laziness optimising compilers forms ffl performed lets create space leak 
full laziness full laziness total instructions executed program safe mandel fft queens hidden sched solid minimax boyer cichelli fft parser mandel clausify genfft maillist reptile hpg lift typecheck fluid gg infer knights rewrite wang wave main event pretty programs minimum maximum geometric mean full laziness total heap allocated program safe fft mandel queens hidden boyer sched cichelli solid knights minimax fft gg maillist lift rewrite hpg parser fluid typecheck reptile boyer clausify genfft wave main mandel parstof multiplier pretty prolog veritas transform programs minimum maximum geometric mean table full laziness instructions executed bytes allocated 
full laziness full laziness residency safe program gcs bytes ratio gcs bytes ratio gcs bytes ratio clausify boyer sched mandel queens typecheck fft fft parser transform compress cichelli genfft parstof ida infer hpg rewrite gg multiplier rsa mandel progs 
minimum maximum geom 
mean table full laziness residency 
floating cases lambdas ffl optional compiler optimisation possibly leaky lets 
second option reasonably safe specially floating lets local context top level 
floating cases lambdas suppose function definition 

case 

case 

free variable 
case variable bound enclosing lambdas possibly floated past lambdas get definition case 





case 

particular change effect theta updatable closure previously weak head normal form 
theta lambdas expression optimisations arity information worker wrapper transformations 
original definition evaluated time entered 
interested benefit transformation 
entered times save quite lot account disadvantages 

floating cases lambdas floating cases lambdas achieves similar effect full laziness allowing possibility sharing evaluation scrutinee 
notice expression slightly different semantics transformation 
value scrutinee bottom transformation expression isomorphic 
isomorphic 
difference relevant practical theoretical purposes affect semantic value program fails 
language distinguishes 

disadvantage performing transformation local definition strictly demanded able float case case floating transformation section eliminate disadvantages 
example resulting expression certainly better original 
rec 
case 

case 
rec 
idea floating cases past lambda similar sharing evaluation control constructs hol believe expressing floating control construct case case constructor simpler elegant 
hol presents examples transformation provide substantial improvements experiments transformation substantially improve benchmark programs shown table 
currently perform transformation glasgow haskell compiler 

ordering floating transformations case floating total instructions executed program parser programs minimum maximum geometric mean case floating total heap allocated program boyer prolog programs minimum maximum geometric mean table case floating instructions executed bytes allocated ordering floating transformations think ordering transformations applied irrelevant achieving different objectives 
true transformations may expose opportunities transformations done 
cases may hide opportunities done 
section issues lead choose specific sequence performing floating transformations 
sure best possible order obtained close inspection code benchmark programs 
basically ordering transformations follow set constraints described sections 
float inwards strictness analysis floating inwards moves definitions inwards site binding strict section 
full laziness strictness analysis generating worker wrapper pairs may case argument worker 


ordering floating transformations case needs worker wrapper pair generated get 
absence analysis inline wrapper 

full laziness 
see floated past enclosing lambda 
strictness analysis absence analysis may allow floated 
possibility inlining exposes extra opportunities full laziness transformation example 


fib fib 
inlining 
fib fib 
point float fib top level 
see reasons perform full laziness early compilation process 
performed experiments run full laziness twice early compilation process 
experimental evidence suggests cases described happen running full laziness twice improve code great majority programs shown table 
glasgow haskell compiler currently run full laziness twice 
simplify floating inwards due happens dictionaries case 

case 
case 


case 
case cc 
cc cc cc 
ordering floating transformations full laziness total instructions executed program twice genfft lift mandel parstof sorting hpg mandel programs minimum maximum geometric mean full laziness total heap allocated program twice genfft boyer lift fluid gg hpg parser mandel programs minimum maximum geometric mean table full laziness twice instructions executed bytes allocated floating inwards push definition supposing case 

case 
case 


case 
case cc 
cc cc cc strictness analysis get worker wrapper 
having worker wrapper bad mean arguments unboxed generating extra allocations occurs called cc 
solve problem run simplifier floating inwards lets body weak head normal form floated undoing floating inwards transformation cases 
back original code worker wrapper strictness analysis avoid extra 
lose case opportunities case case floating example demanded strict floating inwards 

ordering floating transformations way having best worker wrapper pass explicit float strictness analysis simplify strictness analysis worker wrapper generation ffl able detect strictness call strictness analyser exploit simplifier case strict ffl call simplifier demanded floated just currently strictness analysis ii worker 
currently simplify floating inwards 
float inwards strictness analysis workers generated strictness analysis worker wrapper generate lets simply unboxed arguments may case worker need original boxed value case 
case 
case true 
false 

worker wrapper case 
case 
case 
ordering floating transformations true 
false 
case simplifier remove binding expected happen know eventually removed kept keep binding branches case allocated 
floating inwards pass push definition true branch 
similar benefit occurs inside definition 
basically advantages floating inwards exposed strictness analysis code 
reasons float inwards strictness analysis run twice 
compelling example need float inwards strictness analysis 
case 
case 
case 


case 
case 
case 

demanded float case simplifications 
left closure order definition swapped problem 
float definition case simplified case reduction transformation expect 
table see effect floating inwards twice opposed floating inwards early benchmark programs 

ordering floating transformations float twice total instructions executed float program twice wave main mandel treejoin fft fluid maillist programs minimum maximum geometric mean float twice total heap allocated float program twice wave main treejoin maillist fft knights clausify fluid hpg compress prolog minimum maximum geometric mean table float twice instructions executed bytes allocated full laziness inlining experimenting aggressive inlining strategies chapter inlining performed full laziness opportunities full laziness may lost 
related issues discussed section explain rely full laziness float lets allow lets floated lambdas 
may happen due inlining expressions may unboxed types bind float case int float dict dict 
inlining happens eventually float case scrutinee top level 
inlined eventually get case int integer 
case 


returns unboxed float bind float top level 
thing get float int integer evaluating 
caused program run slower aggressive inlining 

reason full laziness transformation early compilation avoids possible bad interactions join points case case case floating transformations sections 
know join points special kind compiler optimise jump incurring cost allocation 
problem variables creation join point expressions spotted suitable full laziness 
join points linear sense entered multiple times advantage moving expressions 
may introduce extra lets allocated unnecessarily 
look example case 


case 


case full laziness transformation may float subexpression depend right hand side creating new binding unnecessarily 
ordering ordering obeys constraints 
full laziness float simplify strictness worker wrapper generation simplify float simplify floating inwards transformation produced results programs 
transformation suggested inspecting intermediate code generated compiler 

code inspection suggested full laziness transformation regarded dangerous due risks space leaks integrated compilers 
suggested improvements reduce eliminate risk space leaks advocate transformation available option optimising compilers actual creation space leak transformation real programs occur far generally believed 
chapter inlining procedure inlining optimisation imperative languages compilers asu 
consists heuristically selecting usually small procedures inlined call procedure replaced actual code procedure 
inlining aims save time eliminating overhead procedure calls increasing opportunity optimisations procedure code exposed local context information optimisations 
inlining done carefully excessive inlining easily lead large increase code size fact duplicating code 
imperative languages compilers inlining reported improve programs execution time rg dh cho 
dh presents comprehensive analysis effect inlining imperative languages 
functional framework function definitions inlined call sites 
risk code explosion due excessive code duplication done controlled way similar benefits obtained opportunities local optimisation appear 
inlining lazy functional languages lazy functional languages safe substitute equals equals change semantics program inlining 
process inlining functional language described body body 
inlining lazy functional languages means replacing occurrences expression eventually occurrences inlined apply dead code removal transformation eliminate binding 
notice binding inlining may binding function simply expression issues involved deciding lets inline apply equally functions non functions distinction point 
way separate inlining functions beta reduction usually immediately follows transformations conjunction closer concept inlining imperative languages 
main advantages come inlining definition available place allowing transformations fi reduction section occur things may evaluated call site allowing transformations case reduction section occur 
risks theta code duplication expressions inlined occur multiple times theta duplication inlining carefully done redex copying 
example duplication due bad inlining decision occur decide inline variable expression fib 
fib fib expressions semantically equivalent give result expensive evaluate fib evaluated twice 
semantics lazy functional languages allows inline major concerns efficiency issues impose restrictions inline increasing costs evaluation 
basic restrictions related updatable closures evaluation shared restrictions apply non updatable closures notably functions constructors 
restrictions 
inlining lazy functional languages ffl inline updatable closures occur 
case example 
closure non updatable function risk duplication inlining multiple times 
fib 

fib 
fib 
fib fib restriction relaxed bit multiple occurrences single occurrences different case branches 
branches taken particular time expression evaluated code duplicated fib case case 
true 
fib true 
false 
fib false 
ffl inline updatable closures past lambda abstractions 
problem expression inlined past lambda abstraction evaluated times lambda abstraction entered fib 
fib 

evaluation fib shared expression occurs second occurs twice call notice tagging closures update supplying information closures inlined indiscriminately may cause duplication updatable closures won non updatable closures 
compiler regarded performing extremely simple form update analysis tagging functions weak head normal forms non updatable closures closures updatable 
elaborate update analysis techniques improve finding updatable closures need updated mar mtw 
analyses detect lambda abstractions guaranteed entered inlining non 
basic inlining weak head normal forms duplicate allowing closures tagged non updatable 
analyses available mtw thesis 
summary major advantage inlining comes increasing possibility transformations applied 
due possible code duplication expression inlined occurs decision inline done chance transformations occur 
sections discuss methods decision 
basic inlining restrictions inlining discussed previous section see basic cases inlining done safely depending form right hand sides bindings ffl variables body body transformation basically removes level indirection variable case saves allocation closure keep original definition 
saves update entered 
saves enter entered enter variable inlining variable entered directly 
may refer form inlining copy propagation 
ffl constructors mkint body mkint body mkint transformation basically removes level indirection constructor mkint case 
saves allocation closure occurrences inlined 

basic inlining ffl expressions occur inside lambda functions occur fib fib fib saves allocation closure saves update entered may expose transformations due new local context 
due syntax core language inline lets occur position expression allowed inline variable occurs argument function constructor primitive operator fib inlined core language allow expression occur argument 
cause problems possible advantage inlining avoid allocating closure early branch case allocated outside case fib case 

allocated regardless branch taken possibly needed branch taken 
deal possibility floating inwards transformation chapter disadvantage losing possible inlining opportunities 
compilers perform simple forms inlining kkr aug app 

inlining strategy inlining strategy inlining function definitions multiple occurrences risk duplicating risk duplicating code 
inlining functions exposes beta reductions transformations especially case reduction section 
hand want inline big functions times just find beta reductions saving costs function call 
compiler uses method assess functions worth inlining app notion size function inlined amounts way counting language constructs function 
notion discount introduced gives discounts size function occurrence occurrence basis app relation size number occurrences bee criteria 
discounted size smaller threshold function inlined 
glasgow haskell compiler occurrence analysis records information right hand side functions regarding size function arguments case right hand side ones 
supplies rough estimate case reductions get place function constructor variable known bound constructor argument case 
case 
vs 
vs case record get case reductions inlined know constructor form third argument 
supplied information compiler chooses occurrence function program inlining function place worthwhile 
done size function discounting size argument constructor known bound constructor function 
decide inline site discounted size smaller threshold 
cost particular inlining calculated formula cost size function body gamma discounts call site 
inlining strategy describe calculate cost function 
unusual definitions ones cases ffl case variable charge variable allows keep low cost cases particularly benefit information may get variable inline expression 
ffl primitive cases add extra costs just add cost subexpressions ffl algebraic cases add cost subexpressions cost equal number constructors data type add tuples lists 
decision clear describe discounting system 
call site apply discounts ffl number arguments discount argument function applied accounts beta reductions get due inlining 
ffl discount argument know bound constructor know accounts case reductions know going get inlining function case alternatives eliminate reduction better 
proceed compare discounted size inlining threshold set command line flag 
discounted size smaller threshold inline function 
dealing cases allows sort distinction case 
case alt 
alt 

inlining strategy expr int op case 
case 
case 
case 
fv inlining cost expression 
inlining recursive lets call site give bigger discount information constructor third argument know information argument 
fact calculating cost case expression add allows sure inlining threshold get inlining happening due inlining strategy notions size discounts arbitrary varying inlining threshold effectively increase aggressiveness inlining strategy 
main advantage criteria opposed usual strategy deciding inline functions size sort criteria take account possible increase opportunities transformations ends save function call overhead 
decision occurrence having decision occurrences 
approach similar app uses notions cost function discounts occurrence 
costs discount functions elaborate 
glasgow haskell compiler allows exported modules including pre processed function definitions interface files 
means limited inlining module boundary 
avoid gratuitous exporting exported functions module impose limit discounted size function exported supposing gets discounts applied arguments expects know constructors arguments size greater export 
limit set default inlining threshold glasgow haskell compiler probably vary supplied inlining threshold experimented varying 
inlining recursive lets selecting recursive lets inlining done carefully may risk non termination inlining 
reason implementations know inline recursive lets 
optimisation try get recursive lets reduce number bindings combining mutually recursive functions basic forms inlining described section may happen decision inlining dependent notion costs described section 

inlining recursive lets possible 
idea particular binding occur right hand side self recursive safely inlined rec odd case 
true 
case 
false 
odd odd rec odd case 
true 
case 
false 
odd odd 
criteria selecting particular function inlined knowing self recursive may similar adopted non recursive bindings previous sections 
notice explicit recursion possible obtain infinite sequence possible 
look example data 
case 
recursive inlined inlining beta reduction case reduction give back original expression 
example causes simplifier keep iterating performing simplifications way guaranteeing termination having fixed maximum number iterations 

interaction transformations interaction transformations expect initially increasing inlining threshold negative effect program increasing code size 
increasing threshold surprised twice inlining interacting transformations ffl floating inwards 
interaction described chapter section 
due code duplication occurs inlining lets originally floated lets left outer context occur places 
ffl full laziness 
interaction described chapter section 
inlining simplifications meant expressions computed shared left inside lambdas due simplified unboxed expressions 
results tables measured effects increasing inlining threshold compiling benchmark programs 
table shows effect instructions executed inlining threshold varied 
column labelled inlining functions turned inlining variables constructors happens expressions functions occur 
column labelled occ results inlining expressions functions occur 
clear start having diminishing returns thresholds greater inlining expressions functions occur important 
true total heap allocation table 
threshold aggressive floating inwards strategy threshold major increase heap allocation described chapter section 
table presents effect inlining object code sizes quite surprisingly go significantly larger inlining thresholds 
compilation time table hand heavily affect increasing inlining threshold 
number functions inlined table number case reductions table 
comparing number functions inlined 
number case reductions base column ones relative shown actual number occurrences transformation 
notice inlining constructors variables included numbers 
results obtained app programs improvement call basic inlining major increase object code size 
gets improvement increase object code size 
mention effect compilation time 
results quite similar basic inlining get improvement get inlining strategy major effects object code size 
surprise get code explosion incremented inlining threshold 
hand gained inlining large functions seen increase number functions inlined larger thresholds reflected reduction number instructions executed 
clear improvement looking number case reductions occur cause major effect number instructions executed 
increase compilation time high worthwhile increase threshold 
currently inlining threshold glasgow haskell compiler compromise compilation time reduction instructions executed 
interesting investigate effect having intermodule inlining limit set level inlining threshold 
allow inter module inlining possible increase interface files size possibly major effects compilation time 

inlining total instructions executed threshold program occ 
mandel queens primes wave main treejoin ida parstof sched maillist solid hpg mandel event fluid reptile rewrite hidden sorting genfft prolog compress fft wang infer lift cichelli gg knights transform pretty boyer typecheck parser multiplier clausify fft minimax veritas boyer rsa exp minimum maximum geometric mean table inlining instructions executed 
inlining total heap allocated threshold program occ 
queens wave main primes knights mandel treejoin solid ida infer maillist cichelli parstof compress hpg event fluid sorting boyer gg reptile rewrite wang parser hidden prolog lift typecheck fft genfft sched mandel pretty clausify minimax multiplier fft transform rsa veritas boyer exp minimum maximum geometric mean table inlining heap allocated 
inlining binary size threshold program occ 
compress fluid wave main mandel pretty wang boyer fft fft knights mandel rewrite clausify event exp gg hidden ida minimax primes queens sched solid treejoin cichelli genfft infer maillist multiplier prolog typecheck reptile sorting boyer hpg lift rsa transform parser parstof veritas minimum maximum geometric mean table inlining binary size 
inlining total functions inlined threshold program occ 
boyer prolog boyer parstof hidden clausify infer minimax sorting hpg veritas fft lift ida event genfft typecheck cichelli treejoin queens rewrite mandel multiplier fft gg transform parser knights reptile rsa primes mandel fluid wave main sched pretty exp wang solid maillist compress minimum maximum geometric mean table inlining total functions inlined 
inlining case reductions threshold program occ 
boyer sorting clausify hidden lift minimax infer typecheck boyer rewrite ida cichelli prolog parstof veritas primes event fft fluid treejoin multiplier gg mandel hpg knights wave main fft parser pretty sched wang exp mandel transform solid reptile compress queens genfft rsa maillist minimum maximum geometric mean table inlining case reductions 
inlining compilation time threshold program occ 
sched ida wave main compress solid maillist fft genfft clausify mandel event multiplier typecheck infer rewrite fluid sorting treejoin gg reptile wang hidden hpg lift mandel knights prolog boyer boyer cichelli pretty minimax exp fft queens primes veritas parstof rsa parser transform minimum maximum geometric mean table inlining compilation time chapter static argument transformation lambda lifting chapter transformations inverse ffl static argument transformation tries remove redundant arguments recursive function calls turning free variables calls ffl lambda lifting transformation adds extra arguments function definitions turns free variables extra arguments function lifted top level 
see advantages disadvantages try get benefits allowing seemingly incompatible transformations 
static argument transformation recursive functions receive arguments passed unchanged recursive calls 
example function foldr foldr case 

foldr 
static argument transformation arguments recursive call unmodified position 
call static arguments 
simple transformation modify definition avoid passing static arguments recursive call defining local function recursion static arguments free variables foldr foldr case 

foldr foldr version properties reduces number arguments passed recursive calls 
means arguments pushed stack recursive function call 
exposes possibility inlining function recursive anymore contains recursive function body 
decreases number free variables closure foldr 
implementations stg machine decreases closure size related number free variables 
transformation closure recursive call static arguments free variables 
transformation static arguments free variables closure anymore new local recursive function new free variable 
static argument number free variables reduced static argument increased new recursive function number free variables unchanged 
static arguments number free variables removed static arguments greater number free variables introduced new recursive function 
applies recursive call occurs closure occurs tail call 
subexpressions referred full laziness transformation lift subexpressions recursive loop avoiding recalculating value iteration 
theta introduces extra closure local recursive function 

static argument transformation machines implementation functional languages need lambda lifting section undo static argument transformation advantage increasing inlining opportunities apply 
machine joh example needs lambda lifting handle local function definitions 
return point chapter moment assume case stg machine 
reduction number free variables closures inside function definition may greater impact heap usage may initially suspect implementations size closure related number free variables stg 
analyse example detail 
closure example free variables transformation foldr 
extra closure transformation foldr allocated call foldr foldr foldr free variables 
recursive calls heap closure smaller 
compare different patterns calls foldr function ffl called foldr times list elements think heap local definition closure definition foldr 
performs heap allocations 
size closure bytes bigger glasgow haskell compiler due extra free variable original version allocates mb extra heap calls theta elements theta bytes doing smaller number allocations 
ffl suppose calls foldr list happens empty calls 
case paying cost allocation foldr times gives heap allocations increasing heap consumed theta size foldr closure 
recursive calls occur due lists empty paying cost saving 
cost extra call foldr 
advantages transformation notice example dubious vary program program 
discuss measurements transformations effect section 
important observations ffl heap usage change happen static argument map closures number free variables assuming transformation occurs top level 
static argument transformation map bs case bs 
map map bs map bs case bs 
map map bs closure free variables top level definitions map counted free variables transformation closure contains map free variables 
definition map local definition map counted free variable reducing number free variables 
ffl change number free variables occurs recursive call done inside closure 
tail calls change case 

case 

static change free variables closures built recursive call 
algorithm algorithm case single recursive binding proceeds follows ffl record name bound variables function right hand side 

static argument transformation ffl recursive call binder record call repeats arguments place function definition 
ffl arguments static position recursive calls may define local recursive function uses arguments free variables 
definition right hand side original right hand side calls original definition replaced calls new definition static arguments removed body newly introduced letrec call new recursive function arguments received static ones 
point original definition recursive anymore 
example am gamma gamma am gamma partial applications applied far static argument passed argument 
definition recursive decide inline non recursive definition applied 
mutually recursive functions individually applied binding functions mutually recursive 
advantage taken fact definitions transformed self recursive anymore may inlined 
transformation applied binding binding possibly inlined bindings transformation applied 
inlining functions may self recursive 
best way perform transformation sets mutually recursive functions probably doing interpretation keep track arguments static 
example arguments static find keep track names arguments recursive calls self recursive mean binder occurs right hand side 
function obviously recursive functions mutually recursive set call 

static argument transformation definition introduces lot code duplication 
purposes believe risk code explosion worth gains doing transformation sets mutually recursive functions 
purposes improving strictness analysis discussed section worthwhile 
results nofib programs tried perform static argument transformation number static arguments column table 
results promising opportunities transformation functions static argument see table cases gain reducing number arguments recursive call probably compensate extra closure allocated extra call 
decided restrict static argument transformation cases static arguments cases potential gains bigger 
results shown column labelled table improvements instructions executed results heap allocated mixed 
knew case creating extra closure 
restricting static argument transformation doing static arguments reduces improvement restrictive shown column labelled table 
unfortunately transformation improve programs 
quite surprise significant effect benchmark programs expected instances programs 
simple cheap transformation perform idea available optimising compiler 

static argument transformation static argument transformation total instructions executed static argument transf 
program treejoin genfft mandel wang boyer cichelli clausify compress event exp fft fluid hidden ida infer knights maillist minimax multiplier parstof primes prolog queens reptile rewrite sched transform typecheck veritas wave main solid progs 
minimum maximum geom 
mean static argument transformation total heap allocated static argument transf 
program multiplier treejoin genfft wang boyer boyer cichelli clausify compress event fft fluid hidden hpg ida infer knights lift maillist minimax parser pretty prolog queens reptile rewrite sched sorting transform typecheck veritas wave main parstof solid progs 
minimum maximum geom 
mean table static argument transformation instructions executed bytes allocated 
static argument transformation programs static arguments exp queens event fft genfft ida parstof sched solid typecheck wang transform wave main boyer cichelli clausify knights static arguments mandel mandel minimax multiplier pretty rewrite sorting treejoin compress fluid gg hidden hpg infer lift parser prolog reptile rsa veritas programs table static argument count related static argument transformation similar analysis transformation described cd deciding high order arguments effectively removed transforming function definitions specialising functions 
fact describes consists conditions decide recursive high order argument eliminated inlining unfolding definition folding 
rely inlining folding complicate expensive process automate initially apply transformation original function possibly expose opportunities inlining specialisation 
achieves similar results slightly restricted applications 
way static argument transformation remove high order arguments functions possible transforming functions high order arguments static argument transformation high order arguments kept non recursive part inlining non recursive functions high order arguments 
strictness analyser reduce high code analysed get better analysis results 

lambda lifting compiler seen remove recursion benefit transformation sets mutually recursive function strictness analyser benefit 
procedure sew increase scope order analyses number programs order analysis gives useful results 
transformation sight similar static argument transformation lambda dropping dan closer look shows major differences dan 
dan starts lambda lifted program concerned restoring block structure programs introduce definitions original program place restores original structure 
appel independently suggested transformation sml nj compiler app aim helping inlining recursive functions 
points advantages purpose removing invariants loop similar effect achieve full laziness presents benefits related closure representations register allocation compiler 
achieves average improvement programs maximum 
lambda lifting lambda lifting transformation eliminates free variables function definitions passing arguments 
done functions free variables anymore lifted top level joh hug 
lambda lifting function definitions top level form supercombinators hug 
essential transformation implementations functional languages function definitions top level machine joh 
stg machine lambda lifting needed advantage performing lambda lifting context stg machine 
answer question see save closure allocation 
simple example case 

lambda lifting 
example closure function allocated iteration lambda lifted version case 

free variables function case abstracted argument remaining free variables moved top level 
calls needs extra argument abstracted variable 
case allocate possible disadvantages take consideration free variables closures mention lifted function modified 
get extra free variable abstracted variable free variables closure lifted function due fact top level declaration counted free variable anymore 
particular example closure free variables opposed 
theta extra argument passed call cases disadvantages far advantages transformation theta may variables number extra arguments possible increase size closures costly savings form allocating function closure 
theta variable occurs argument position gain create closure partial application 
lambda lifting case 
case 



create new binding left place save closure allocation 
partial application updatable closure worse performance 
theta similar problem partial applications occurs function occurs case stg machine bind lambda expressions 

eliminate local definition creating new partial application may cause function execute slower 
experimenting lambda lifting noticed restrict lambda lifting aspects getting worse results lambda lifted code non lambda lifted code 
leads conjecture implementations perform lambda lifting selective may pay heavy penalty performance 
difficulty performing lambda lifting implementation opposite static argument transformation discussed previous section useful transformation 
may think lambda lifting performed advantages static argument transformation apply lambda lifting undo transformation 
discuss section selective functions lambda lift keep benefits static argument transformation lambda lifting non recursive functions 
rest section ignore interaction static argument transformation lambda lifting analyse effect performing lambda lifting 

lambda lifting summary selective lambda effect theta increases number arguments passed recursive calls 
means arguments pushed stack function call 
increases possibility inlining function non recursive size body reduced removing local function definitions 
may increase number free variables closures contain calls functions lifted 
increase occurs function lifted free variable compensated fact lifting function top level variable free variable anymore 
effect occur calls tail calls closure containing call 
removes closures local functions moved top level 
means closures created top level shared 
function definition occurred inside function called times save allocations function closure 
just transformations easily get examples behave better worse lambda lifting 
measurements get average idea perform lambda lifting 
algorithms performing lambda lifting known example joh pey pl algorithm 
results measured effect lambda lifting nofib benchmark programs criteria abstracting variables 
number instances lambda lifting opportunities variables small show table start getting diminishing returns point 
table presents effects lambda lifting including lambda lift option showing importance having selective lambda 
columns show effects selective lambda varying maximum number abstracted variables allowed 

combining static argument transformation lambda lifting selective lambda lifting abstracted arguments non recursive functions recursive functions table selective lambda count distribution see disadvantage lambda lifting expected 
effect selective lambda lifting quite disappointing 
combining static argument transformation lambda lifting static argument transformation lambda lifting seemingly incompatible transformations seen programs improved applying transformations 
know applying undo effect selective avoid interference lambda lifting definitions performance improved doing 
presumably definitions created static argument transformation transformation things worse 
performed various experiments perform static argument transformation tried lambda selective avoid undoing effects static argument transformation 
initially selective disallowing lambda lifting recursive functions example removed virtually benefits lambda lifting programs nofib benchmark keeping benefits static argument transformation 
eventually decided selective lambda extra restriction lambda lift recursive functions going argument 
way interfering recursive functions introduced static argument transformation know improving code 
effect quite small managed get extra benefit selectively lambda lifting static argument transformation show table 

combining static argument transformation lambda lifting lambda lifting total instructions executed lambda lifting selective program lift prolog hidden infer parser queens typecheck boyer compress fft fft fluid genfft gg hpg ida knights maillist mandel minimax parstof primes reptile rewrite solid sorting veritas wave main cichelli progs 
minimum maximum geom 
mean lambda lifting total heap allocated lambda lifting selective program cichelli prolog typecheck hidden lift queens boyer fluid infer clausify event knights reptile rewrite transform wave main boyer compress fft gg hpg ida mandel minimax parser parstof solid veritas fft maillist sorting progs 
minimum maximum geom 
mean table lambda lifting instructions executed bytes allocated 
combining static argument transformation lambda lifting static argument transformation lambda lifting total instructions executed sat sat sat program ll ll ll treejoin genfft mandel lift parser prolog typecheck wang cichelli solid progs 
minimum maximum geom 
mean static argument transformation lambda lifting total heap allocated sat sat sat program ll ll ll cichelli multiplier prolog typecheck treejoin boyer genfft lift clausify fluid hidden infer knights reptile rewrite transform wang wave main parstof solid progs 
minimum maximum geom 
mean table static argument transformation lambda lifting instructions executed bytes allocated 
effects transformations chapter quite surprising exactly opposite expecting started experimenting ffl static argument transformation initially expect impact performance programs turned quite important programs benchmarks 
ffl lambda lifting expected get benefits need selectively 
eventually got unexpected results negative impact un selective lambda lifting bigger suspected second effect selective lambda quite disappointing 
leads conclude implementations techniques depend lambda lifting probably paying heavy penalty furthermore take benefit performing static argument transformation 
hand implementations need lambda lifting probably benefit lambda lifting selectively 
benefit having static argument transformation optimising transformation 
chapter related chapter describe program transformations typically functional languages 
compare transformations thesis program transformations compilers including lazy strict functional languages compilers imperative languages compilers 
programmer assisted program transformation term program transformation describe program development technique starts clear inefficient specification program semantics preserving source source program transformation gets obscure fast program 
intermediate step process program may efficient 
gains obtained techniques usually big changing time space complexity program 
program transformation functional languages fold unfold transformations burstall darlington db bd 
usually semi automatic systems quite dependent programmer assistance need eureka step dependent specific program trying transform 
tools techniques developed fea fir intended assisted programmer regarded automatic program transformation tools 

automatic program transformations concerned automatic program transformations thesis discuss non automatic methods 
automatic program transformations automatic program transformations ones interested fully automated possibly incorporated compilers 
gains usually big ones non automatic methods usually improving programs small constant factors 
code optimisation techniques imperative languages compilers seen automatic program transformations asu 
characteristics distinguish approach non automatic ffl transformation process creative system transformation rules knows ffl sequence transformations applied predefined ffl improvements small sense transformation rarely changes complexity program improves small constant factor tries describe entire process compilation successive program transformations kel kra flm app 
source language translated intermediate language lambda calculus transformed point run target machine 
advantages process correctness compiler comes simple source source transformations shown correct 
efficient output comes transformations simplify program compilation process 
area uses compilation transformation approach exactly purpose obtaining efficient compilation prove correctness compilation process proving correct individual transformations wan flm 

program transformations functional languages compilers program transformations functional languages compilers program transformation extensively process compiling functional languages 
mainly contexts ffl compiling functional languages standard technique transform source language subset functional language simpler 
subset enriched lambda calculus chu wad bar 
process simplifying language called desugaring 
transforms syntactic constructs language expressed terms simpler constructs 
process desugaring described source source transformation hmm pey 
examples transformations compilation pattern matching aug wad compilation list comprehensions aug pey compilation overloading pj aug 
ffl way program transformation compilation process occurs program needs transformed order compiled implementation technique 
examples kind transformation lambda lifting transformation hug joh pl necessary compiling program form hug compiling machine joh 
continuation passing style cps translation kra flm app 
ffl automatic program transformations solely improve efficiency functional programs optional compilation process 
program transformations discuss thesis fall category 
examples program transformations deforestation 
source inefficiency functional languages style programming advocates results creation traversal intermediate data structures evaluation program 
trying improve techniques avoid creating traversing intermediate data structures researched 
techniques 
lazy functional languages compilers deforestation automatic transformation eliminate intermediate data structures program chi wad glp gil 
transformations strictness information 
important optimisation lazy functional languages transformation call need lazy call value strict 
possible strictness analysis myc gives information expressions evaluated strictly efficient keep semantics 
information obtained strictness analysis program transformations pp hb 
high order removal 
removal high order functions place source source transformations cd 
goal time improve efficiency improve efficacy transformations analysis techniques strictness analysis 
unboxed values 
able express unboxed values intermediate language pl possible optimisations usually regarded code generation optimisations expressed program transformations 
full laziness 
full laziness tries increase sharing data program reducing number times expression re evaluated 
described hug hug pl discuss chapter 
small local transformations 
apart transformations simple ones widely various functional languages compilers 
usually consist simple identities allow efficient expression replaced efficient 
transformations describe chapter fall category 
lazy functional languages compilers section compare transformations ones lazy functional languages compilers 
chalmers lml hbc compiler optimisations performed chalmers lml hbc compiler described aug 
lazy functional languages compilers ffl constant folding ffl fi reduction ffl dead code removal ffl case reduction ffl inlining functions occurring just ffl case case implemented code generator 
perform transformations 
know analysis effects transformations compiler 
fast compiler optimisations fast functional programming arrays transputers compiler developed university southampton 
optimisations ffl caf lifting transformation amounts full laziness transformations section restricted float cafs top level precisely things try avoid due risk space leaks sections 
ffl specialisation creates specialised version high order functions trying improve strictness analysis results 
achieve effect static argument transformation functions high order functions inlining functions 
ffl inlining criteria inlining inline argument position details criteria size expression inlined number occurrences 
ffl strictness analysis save closure allocation updates 
ffl cheap eagerness reduce closure allocation updates 
ffl boxing analysis similar done worker wrapper transformation 
analysis effects optimisations programs concludes benefit strictness analysis boxing analysis 

strict functional languages compilers compiler bee transformations bee compiler analysed 
include ones fast compiler described plus call case merging section uses different function performing inlining decisions 
benefits come inlining caf lifting 
strict functional languages compilers section compare optimisations state art strict functional language compiler sml nl app ones lazy functional language compiler 
sml nj compiler allows compare approach cps continuation passing style optimisation code generation case sml nj 
transformations superset ones works compilation kkr kra kel continuation passing style continuation passing style cps program notation aspect control flow data flow explicit 
example translation program cps style taken app case 

case true 
false 
function computes product primes equal positive integer translation cps gives program case 

case 
strict functional languages compilers true 
false 
program continuation functions express turning return function call simply function call 
details cps refer app technique described characteristics exploited sml nj compiler 
shows benefits compilation cps obtained source source transformations calls reductions name intermediate results 
shows equivalence compilation strategies claims language normal forms intermediate representation compilers 
core language similar normal form name closures lets 
means approach able achieve benefits compilation cps 
see optimisations done cps similar ones optimising program transformation 
approach similar general terms ffl process iterates point optimisations performed 
consequence fact transformation may expose opportunities transformations 
ffl optimisations carefully chosen interaction incur non termination possible transformation followed turns code back way 
ffl optimisations extensive heuristics try inexpensive analysis techniques impose overhead compilation time 

strict functional languages compilers ffl process relies small optimisations interact produce complex optimisations 
section compare optimisations described appel app ones glasgow haskell compiler 
fi contraction consists inlining functions exposing opportunities fi reductions take place 
glasgow haskell compiler part inlining strategy 
case reduction instances transformation app ffl constant folding switch operator eliminates switches cases known value ffl constant folding selects known records variable statically bound record operand selection operation expression eliminated directly replaced selected field record 
similar case reduction transformation case 


dead variable elimination removes unused variables bindings program 
sml due strictness language non functional extensions optimisation careful remove code modifies store raises exception evaluated variable 
lazy languages sufficient variable 
discussed section 

strict functional languages compilers argument flattening argument flattening optimisation improves way arguments passed functions 
functions arguments passed tuple modified tuple constructor built 
achieved calls function pass explicit tuple explicitly mention tuple constructor 
effect similar get transformation lazy language 
due semantics lazy pattern matching guarantee lazy language tuple argument unboxed components needed 
remove tuple constructor directly pass arguments 
due strictness analysis sure tuple argument evaluated perform similar transformation 
may regarded restricted way similar avoiding extra boxing unboxing operations described pl worker wrapper transformation 
dropping unused arguments slightly complicated instance dead variable elimination 
removes function arguments function body argument list consequently removes respective arguments call sites 
transformation pl handles transformation glasgow haskell compiler 
fi expansion fi expansion fi contraction functions called inlining functions call sites trying expose local optimisations 
due possible code duplication done heuristically selecting functions expanded inlined 
inlining discussed chapter repeat issues discussed chapter 

strict functional languages compilers reduction sml compiler performs reduction glasgow haskell compiler perform eta reduction explicitly simple functions inlining strategy choose inline achieving cases fi reduction result 
uncurrying uncurrying transformation tries transform curried functions functions receive tuples arguments sml treat efficiently done calls function passes number arguments requires partial applications function 
lazy language gain doing transformation fact introduce extra constructor tuple matched 
may look exactly opposite transformation described section 
difference section know calls function pass tuple argument explicit partial applications 
expect partial application function implementation partial applications cps inefficient 
intended get uncurried version flattening eventually applied 
major difference approaches lazy functional languages currying extensively supported efficiently underlying model evaluation 
sml efficient tuples transformation worthwhile 
lazy functional languages opposite transformation avoiding tuple constructor possible 
valid transformation argument strict guaranteed evaluated due semantics lazy pattern matching 
call saturated arguments arity 

strict functional languages compilers hoisting hoisting tries move bindings reduce expand scope individual definitions 
glasgow haskell compiler achieves effect local floating transformation full laziness inner lets floated increase scope possibly expose opportunities transformations 

transformation evaluated time called original definition 
sml float lambda evaluated regardless entered 
true strict functional languages lazy language allocating closure evaluate 
sml may float lets lets applications 
possible float lets single branch cases careful floated side effecting expressions affect program behaviour performed different order 
possibility hoist downwards example definition single branch floated branch 
strict context avoid evaluation condition false 
lazy context save allocation closure evaluated needed 
sml strict language opportunities hoisting taken possible lazy functional language presence strictness information valid strict context case 

case 
argument evaluated expression evaluated second lazy context 
complications algorithm hoisting due impure characteristics sml assignment exceptions introduce need extra restrictions hoisting 

strict functional languages compilers common subexpression elimination risks common subexpression elimination functional language discussed section related optimisation imperative languages section 
sml overcomes part problem looking common subexpressions expression dominates inside scope 
way find common subexpressions sum sum prod sum sum prod try get common subexpression code sum sum prod space leak may occur common subexpression elimination space reclaimed evaluation sum possibly reused evaluating sum 
transformation reclaimed prod evaluated 
investigated transformation similarly full laziness transformation risk space leak reduced restricting types expressions 
closure conversion transformation turns free variables closures arguments 
identical lambda lifting joh lazy functional languages 
effect transformations appel app analysed effect transformations new jersey sml compiler important ones inlining functions called dead variable elimination case reduction constant folding selects known records 

imperative languages compilers imperative languages compilers optimisations imperative languages divided categories ffl local transformations 
optimisation techniques imperative languages take part called basic blocks referred local transformations local context information 
basic block sequence consecutive statements flow control enters leaves halting branching 
ffl global transformations 
global optimisations data flow analysis extend local optimisations global context introduce optimisations 
extra optimisations see related optimising loops procedure calls 
ffl peephole optimisations 
go closer code generation get set local specialised transformations called peephole optimisation 
easily find similarities procedures optimising functional languages 
optimisations included categories local transformations example extended applied global context information 
case discuss commenting possible differences local global transformation 
section discuss optimisations classes 
extensively described asu 
common subexpression elimination common subexpression elimination tries locate places expression basic block eliminate multiple evaluations 
example common subexpression assigned recomputing compute assign 
imperative languages compilers new variable replace occurrences directly variable 
see code optimised copy propagation 
optimisation complicated initially check variables common subexpression modified occurrences 
optimising basic blocks global optimisation harder keep track common expressions eliminated due multiple entry points blocks 
functional world notion assignment easier keep track expression common subexpression values bindings variable change 
fact assuming unique names program name case stages compilation functional languages syntactical expression occurs regarded common subexpression easier detect occurs 
hand common subexpression elimination functional languages drastically change space behaviour program causing called space leaks 
introduce large data structure shared due common subexpression elimination space reclaimed garbage collection reclaimed 
illustrate problem program creates times list elements prod product list sum sum list space immediately reclaimed possibly space creating lists 
sum sum prod regarded common subexpression transform program sum sum prod case space allocated list available evaluating sum reclaimed evaluation prod assuming left right evaluation sum 

imperative languages compilers copy propagation copy propagation consists eliminating assignment values variable variables substituting occurrences example optimisation presents difficulties global framework basic blocks 
problems arise due fact example jump statement different point program single basic block anymore possibly true get right value transformation 
similar transformation functional framework extra difficulties notion assignment pure functional languages dead code elimination tries locate portions code accessible program execution removed 
example goto goto jumps reached instruction unconditional jump 
removed 
similarly functional languages definition removed way removed 

imperative languages compilers algebraic transformations algebraic transformations algebraic properties operators replace expensive computations expensive ones 
includes example identity properties operators expressions replace optimisation called constant folding falls category consists eliminating run time computations operations constants results replacing constant 
properties valid functional languages similarly functional framework 
code motion code motion tries remove invariant computations loops avoiding recomputation iteration 
transformation presents basic concept fib fib clearly computing value depend variable modified loop need computed iteration computed loop executes considerably reduces overhead iteration 
functional framework iterations done recursion similar transformation removes invariant computation loops full laziness transformation section 
similarly finds computations depend variables recursion floats computations loop 
example transformation carried full laziness transformation fib fib similarly transformation fib computed 
drawbacks transformation may space leak 
imperative languages compilers common subexpression elimination 
arise case value floated outside loop structure allocates large amount memory freed loop recomputed iteration 
basically space time trade option computing value keeping longer space recomputing reclaiming space sooner 
loop unrolling loop unrolling consists reducing number iterations loop executes trying get local optimisations unrolled code possibly delay jump instructions specially useful pipelined machines 
example see effect unrolling loop halving number iterations 
step functional languages similar effect obtained inlining recursive definition reducing number recursive calls 
example definition inlined unrolled 
fact fact fact fact procedure inlining procedure inlining consists heuristically selecting usually small procedures inlined call procedure replaced actual code procedure 
aims save time eliminating overhead procedure calls increasing opportunity optimisations procedure code exposed local context information optimisations 
course done specific small procedures excessive inlining easily lead large increase code size due code duplication 

imperative languages compilers functional framework idea similarly concept inlining function definitions 
risk code explosion due excessive code duplication done controlled way similar benefits obtained opportunities local optimisation appear 
procedure cloning procedure cloning quite similar procedure inlining tries reduce code duplication sharing code 
inlining procedure called tries match characteristics different call sites generate specialised versions procedures example different arguments chk 
idea uses similar techniques partial evaluation 
functional programming techniques partial evaluation applied 
technique example reduce extra overhead imposed overloading languages haskell 
case different versions functions generated specific contexts types 
technique discussed sp function context type replaced specific non overloaded version function 
redundant instruction elimination redundant instruction elimination tries avoid redundant loads stores memory locations data kept register 
sequence instructions store mem load mem stores contents register memory location loads value memory location register clearly eliminate second instruction register contains data 
achieve similar effect avoiding redundant boxing unboxing operations case reduction transformation 
consider expression core language case mkint 
case 
imperative languages compilers mkint 
case 
mkint unboxing twice remove extra unboxing obtain efficient version case mkint 
case 
mkint flow control optimisation flow control optimisation peephole optimisation example tries optimise jump instructions destinations jump instructions 
goto goto 
goto goto functional framework similar optimisation achieved directly copy propagation example combining reduction copy propagation 
definition clear calls simply add extra indirection level call reduction gives transformation copy propagation rest 
chapter cost semantics way proving transformation correctness presenting expressions transformation applied showing forms semantically equivalent denotational semantics sch 
class transformations interested code improving program transformations prove transformations correct improving code 
transformations suggested intuitions constitutes optimisation 
discussed measured effects transformations implementation independent way proving reducing maintaining evaluation costs 
ideally formal framework reasoning optimising transformations ffl tractable ffl concrete model sharing cost evaluating expressions 
chapter natural operational semantics lazy lambda calculus lau extended notion cost perform proofs transformations chapter 
define cost relation show examples transformations preserve reduce costs 
important property relation contextual expressions related arbitrary context gamma related 
provide proof cost relation 
cost semantics proof directly related known open problem general ps 
discuss section 
believe idea associating costs semantics form suggest useful tool understanding efficiency aspects transformations 
cost semantics cost semantics natural semantics lau extended notion costs associated rules 
allows prove correctness transformations prove transformation preserves reduces increases cost evaluating expression 
believe notions costs restricted specific implementation technique apply lazy functional languages general 
judgements form gamma theta meaning heap gamma binding variables expressions expression reduces cost heap theta weak head normal form expression main difference original semantics notion cost annotation incremented particular rule applied 
costs ffl cost application rule 
ffl cost evaluating variable 
ffl cost update 
ffl cost allocating closure heap 
ffl cost evaluating case expression 
ffl cost basic operation 
argue costs 
may vary factors cost closure allocation may depend number free variables closure aims exactly notion costs 
believe easily costs concrete semantics reason effects program transformations 

cost relation gamma gamma constructor gamma gamma lambda gamma delta delta theta gamma phi theta phi basic operation gamma delta delta theta gamma theta app application gamma delta gamma 
delta 
updatable variable gamma delta gamma 
delta 
variable gamma 
delta gamma delta gamma delta delta theta gamma case fc 
theta case case cost relation call need semantics just efficient implementation call name semantics existing definitions equivalence expressions evaluated call name directly prove correctness program transformations lazy functional languages 
call need semantics inherent notion efficiency need cost evaluation expression sharing evaluation observable property notion equivalence 
goal establish relation semantically equivalent expressions intuitive meaning 
cost relation iff evaluating expensive evaluating observational cost relation relation means 
ultimately want observational cost relation obs closing boolean contexts heaps delta delta delta true iff delta delta delta true definition condition define observational equivalence rp definition 
direct cost relation quantification contexts difficult prove expressions obs relation 
seek direct definition section develop definition section discuss question proving implies obs course cost evaluating depends value free variables start defining expression related expression arbitrary heap heap expression pairs related relation definition gamma gamma gamma proceed define relation heap expression pairs 
relation inductively defined similar definitions defining applicative bisimulation pure functional languages gor 
define relation heap expression pairs expression weak head normal form definition 
cost relation delta delta delta 
delta 
definition implicitly implies dom delta dom delta restrict closed expression domains different pick variable intersection definition false 
definition delta delta ng delta delta need definition relation expression weak head normal form 
failed attempt idea relation identical defining applicative bisimilarity extended comparisons cost evaluation expressions definition gamma gamma delta delta gamma delta gamma delta delta delta alas definition clearly observed comparing programs 


cost relation clearly context lambda expression shared evaluated multiple times cheaper evaluated 
example context 

relation defined difference noticed look expressions context 
considered expensive includes variable lookup update 
difference arises expression shared 
second attempt solve problem introduce alternative version cost relation expressions basically demands cost evaluating expressions related resulting heaps related definition gamma gamma delta delta gamma delta gamma delta delta delta delta delta definition relation delta delta delta delta 
cost relation reexamining example failed previous definition 

notice ffl expressions reduce weak head normal form cost cost allocating closure 
ffl weak head normal form expressions related add binding arbitrary expression heap check subexpressions related 
new condition introduced important evaluation expressions heaps cost related anymore evaluated won 
extra condition checking amount evaluation performed heap expression evaluated weak head normal form 
definition correct 
establish prove cost relation observational cost relation 
observational cost relation revisited mentioned quantification contexts difficult prove expressions obs relation 
prove iff obs new problem 
similar task proving applicative bisimulation equivalent observational equivalence ao gor 
proof known difficult uses clever technique due howe 
technique sands san time analysis similar cost semantics restricted call name semantics 
discusses difficulties trying extend call need semantics 

examples alas problem significant difficult 
difficulties related difficulties described ps observational properties presence dynamically created names model heaps 
ps presence dynamically created local names bindings updates shown pose significant difficulties establish observational equivalence 
simple language elaborated method show observational equivalence shows method complete expressions order types incomplete higher types 
able prove iff obs cost relation obs relation 
rp uses definition applicative bisimilarity prove full abstraction contextual equivalence translation lambda calculus types standard ml 
uses environment model dealing strict language environment notion updates bindings unevaluated expressions heaps 
prove applicative bisimilarity implies observational equivalence due presence dynamically created local state notions coincide ps 
examples section proofs obtained cost relation introduced previous section 
floating application proof expressions floating application transformation applied keep cost semantics showing starting assumptions heap get resulting expression cost different reduction rules different sequence reduction rules starting different expressions 
proofs follow line theorem proof mean 
examples gamma 
delta gamma delta delta theta gamma theta app gamma 
delta delta theta gamma 
delta app gamma theta case floating application theorem case fc 
case fc 
proof gamma pi pi delta gamma case fc 
delta case delta theta gamma case fc 
theta app gamma pi pi delta delta theta pi theta app gamma case fc 
xg theta case floating case scrutinee theorem case fc 
case fc 
proof 
examples gamma 
theta gamma theta theta delta gamma case fc 
delta case gamma 
theta theta delta gamma 
case fc 
delta case gamma case fc 
delta unboxing case want prove constructor type strict case 
able reason effect transformation need introduce notion expression strict variable variable guaranteed due strictness analysis demanded evaluation expression 
possible definition property strict gamma 
delta 
definition infer important fact reduction gamma 
delta 
rule way updated 
fact derive rule strict strict gamma delta delta 
delta 
gamma 
delta 

examples formal proof rule correct intuition comes basic property strictness know expression going evaluated may evaluate expression advance transforming call need call value 
doing just identity add cost update assuming weak head normal form 
weak head normal form extra cost 
proceed analyse transformation suggest gamma delta delta 
theta gamma 
theta gamma theta gamma delta delta 
theta delta theta gamma case kl 
kl theta case case ended resulting cost condition transformation reduce cost expressions floating want show strict case demanded evaluation strict gamma 
delta gamma delta delta 
delta gamma delta gamma 
delta delta 
delta gamma 

delta gamma delta 
examples case demanded evaluation gamma 
delta 
gamma delta 
gamma 

delta 

gamma delta 

done extra transformation second case 

strict keep cost 
evaluated result strict keep cost 
evaluated code worse 
possibility weak head normal form saving update cost transformation improving code 
precisely stated described transformation chapter 
case floating theorem case fc 
case fc 
strict fv fv fv 
formal proof heaps different bindings 
shows ideally restrictive definition 

gamma theta theta delta gamma case delta case delta 
delta gamma case fc 
delta gamma theta theta delta delta 
delta theta delta gamma case fc 
delta case chapter definition cost semantics cost relation call need language 
difficulties involved obtaining suitable definition cost relation 
caused inherent non compositionality definition semantics dynamically created names expressions cost related may shown cost related certain contexts 
cost relation suggest useful reasoning transformations may restrictive due requirement heaps bindings 
interesting try obtain definitions relax restriction 
rp introduce similar restriction definition equivalence modelling language 
useful proof cost relation contextual cost relation 
unfortunately just presence dynamically created names model heaps pose difficulties obtain proof open problem general 
dynamically create names bindings names perform updates able obtain proof 
shown cost semantics call need lambda calculus useful way assess effects program transformations form promising area research 
chapter systematically analysed large set local transformations discussed importance measured occurrence 
measured effect number large set programs 
achieve combined transformations interact non obvious ways achieve major improvements performance real programs 
fine tuning local positioning lets shown important transformation studied 
full laziness transformation known quite investigated detail 
shown major effect programs risks space leaks creates rare greatly reduced 
static argument transformation opposite lambda lifting 
far bigger effects programs initially suspected turned important transformation optimising compiler 
shown having perform lambda lifting important feature stg machine claim implementations may paying significant performance penalty 
restricted lambda lifting specific cases beneficial stg machine got improvements heap allocation reflected improvements instructions executed 
proceeded combine selective lambda lifting static argument transformation get major improvements 
effects inlining showing quickly get diminishing returns optimal amount inlining far smaller initially suspect 
problems excessive code duplication due inlining 

general cost semantics suggests way relating program transformations effects performance 
allows effect transformations formally studied independently particular implementation formalise notion code improvement 
general substantial hidden benefit performing measurements thesis debugging fine tuning transformations programs benefiting transformation getting worse 
due obscure interaction transformation obvious started implement probably go unnoticed working large set programs 
important large set programs small toy programs 
easily get wrong measuring effects small programs programs 
clear obtain optimal result transformations create examples result efficient code 
course true smaller scale program transformations imperative languages 
performing experiments reasonably large scale diverse set programs decide average worthwhile transformations 
believe lot effort done studying large scale transformations small local transformations combined just big effect complicated global transformations 
interesting observation results significant effect heap allocation reflected actual performance improvement 
performing experiments seen program allocate times heap version better performance 
shows importance relying measuring effect transformations heap allocation predict effect execution time 
quite transformations result small average improvement clear major impact programs 
optimising compiler perform bound major effects programs 

vast majority transformations lazy functional language compiler 
believe effects similar ones thesis 
interesting topics certainly deserve investigation ffl linear type systems update analysis mtw certainly help reduce number updates performed help inlining tell lambdas entered allow inlining expressions risks duplication 
provide useful information full laziness pass avoiding bind expressions floated past lambda shared lambda entered create overhead extra closure 
seen cases happens 
ffl reduce number iterations needed simplifier reach fixed point 
probably done systematic approach currently ad hoc manner 
aj describes approach minimise number iterations similar pass sml nj compiler linear time algorithm perform 
algorithm tries keep track usage counts variables occurrence information simplification process reducing number iterations needed reach fix point 
set transformations performed far smaller glasgow haskell compiler similar approach probably 
ffl set transformations know confluent terminating extended 
ffl static argument transformation improved cases shows improvement static argument selected 
important cases example function map static argument benefit transformed inlined missed improve strictness analysis place 
ffl interaction static argument transformation selective lambda probably improved managed combine best results obtained transformations 

ffl important obtain proof cost relation cost semantics contextual cost relation 
important try obtain restrictive cost relation allow programs comparable 
appendix function definitions appendix definition data types function definitions glasgow haskell compiler 
arithmetic define basic int data type data int mkint int int data type boxed data type single constructor mkint unboxed int argument 
basic functions ints defined unboxing arguments applying primitive version function unboxed arguments case mkint 
case mkint 
case 
mkint case primitive addition function works int operators similarly defined unboxed counterparts 
floats doubles implemented similar way 

comparison comparison bool data type boxed data type data bool true false currently provision glasgow haskell compiler unboxed versions enumerated types 
efficiency reasons lead primitive comparison operators returning unboxed integers int 
case mkint 
case mkint 
case 
false 
true comparison operators similarly defined 
boolean operators definitions boolean operators case true 
case true 
true false 
false false 
false case true 
true false 
case true 
false false 
true bibliography aj andrew appel trevor jim 
making lambda calculus smaller faster 
technical report cs tr november 
appear journal functional programming 
ao abramsky 
ong 
full abstraction lazy lambda calculus 
information computation 
app andrew appel 
compiling continuations 
cambridge university press 
app andrew appel 
loop headers lambda calculus cps 
lisp symbolic computation 
asu aho sethi ullman 
compilers principles techniques tools 
addison wesley 
aug lennart augustsson 
compiling pattern matching 
functional programming languages computer architecture fun pages 
aug lennart augustsson 
compiling lazy functional languages part ii 
phd thesis department computer science chalmers university technology goteborg november 
aug lennart augustsson 
implementing haskell overloading 
functional programming languages computer architecture pages 
acm press 
bar henk barendregt 
lambda calculus syntax semantics 
north holland 
bd rod burstall john darlington 
transformational system developing recursive programs 
journal acm january 
bibliography bee 
lazy functional intermediate language 
technical report cs university amsterdam december 
bee marcel 
optimizing transformations lazy functional language 

editor th computer systems pages eindhoven netherlands nov 
eindhoven univ technology 
cd chin john darlington 
removing higher order expressions program transformation february 
chi chin 
automatic methods program transformation 
phd thesis imperial college london march 
chk cooper hall kennedy 
procedure cloning 
ieee computer society international conference computer languages pages april 
cho chow 
portable machine independent global optimizer design measurements 
technical report stanford university 
chu church 
calculi lambda conversion 
princeton university press 
dan olivier danvy 
lambda dropping transforming recursive equations programs block structure 
technical report dart computer science department aarhus university aarhus denmark january 
db john darlington rod burstall 
system automatically improves programs 
acta informatica 
dh davidson holler 
study function inliner 
software practice experience 
dh jack davidson anne holler 
subprogram inlining study effects program execution time 
ieee transactions software engineering february 
fea feather 
system assisting program transformation 
acm toplas january 
fir firth 
fold unfold transformation system non strict language 
phd thesis university york december 
flm fradet daniel le metayer 
compilation functional languages program transformation 
acm trans 
programming languages systems january 
bibliography cormac flanagan amr sabry bruce duba matthias felleisen 
essence compiling continuations 
programming languages design implementation pages 
acm 
fun functional programming languages computer architecture number lncs nancy september 
springer verlag 
fun functional programming glasgow ayr scotland 
springer verlag workshops computing 
fun functional programming languages computer architecture copenhagen june 
acm press 
fw philip fleming john wallace 
lie statistics correct way summarize benchmark results 
communications acm march 
gil andrew gill 
cheap deforestation non strict functional languages 
phd thesis department computing science university glasgow 
glp andrew gill john launchbury simon peyton jones 
short cut deforestation 
functional programming languages computer architecture fun pages 
gor andrew gordon 
functional programming input output 
phd thesis university cambridge 
tr 
gor andrew gordon 
bisimilarity theory functional programming 
mathematical foundations programming semantics new orleans march 
elsevier electronic notes theoretical computer science volume 
har hartel 
benchmarking implementations lazy functional languages ii years 
technical report department computer systems university amsterdam december 
hb howe geoffrey burn 
strictness stg machine 
functional programming glasgow fun 
hbh hammond geoffrey burn howe 
spiking caches 
functional programming glasgow fun 
pieter hartel hugh glaser john wild 
benefits different analyses compilation lazy functional language 
workshop parallel implementation functional languages pages southampton june 
bibliography cordelia hall kevin hammond simon peyton jones amd philip wadler 
type classes haskell 
report department computing science glasgow university 
hl pieter hartel koen langendoen 
benchmarking implementations lazy functional languages 
functional programming languages computer architecture fun pages 
hmm harper robin milner 
standard ml 
technical report ecs lfcs university edinburgh 
hol carsten holst 
improving full laziness 
glasgow workshop functional programming 
springer verlag 
howe 
equality lazy computation systems 
logic computer science pages 
ieee computer society press 
hug john hughes 
super combinators new implementation method applicative languages 
acm conference lisp functional programming pages pittsburg 
hug john hughes 
design implementation programming languages 
phd thesis programming research group oxford university july 
hug john hughes 
functional programming matters 
computer journal april 
joh thomas johnsson 
machine machine graph reduction 
declarative programming workshop pages university college london april 
joh thomas johnsson 
lambda lifting transforming programs recursive equations 
functional programming languages computer architecture fun pages 
kel kelsey 
compilation program transformation 
phd thesis yale university department computer science may 
yaleu dcs rr 
kkr david 
kranz richard kelsey jonathan rees paul hudak james philbin norman adams 
orbit optimizing compiler scheme 
acm sigplan symposium compiler construction pages june 
sigplan notices 
kra kranz 
orbit optimising compiler scheme 
phd thesis yale university department computer science may 
bibliography lau john launchbury 
natural semantics lazy evaluation 
acm sigplan principles programming languages charleston 
john launchbury andrew gill john hughes simon marlow simon peyton jones philip wadler 
avoiding unnecessary updates 
launchbury sansom ls 
ls john launchbury sansom editors 
functional programming glasgow ayr scotland 
springer verlag workshops computing 
mar simon marlow 
update avoidance analysis interpretation 
functional programming glasgow fun 
mat brian matthews 
equational reasoning system standard ml 
th international conference rewriting techniques applications number lncs pages 
springer verlag 
mat brian matthews 
analysing set transformation rules completion 

john martin odersky david turner philip wadler 
call name call value call need linear lambdacalculus 
mathematical foundations programming semantics 
electronic notes theoretical computer science 
mtw mossin david turner philip wadler 
type 
functional programming languages computer architecture san diego june 
myc alan mycroft 
interpretation optimising transformations applicative programs 
phd thesis dept computer science university edinburgh 
par william partain 
nofib benchmarking suite 
launchbury sansom ls 
peyton jones clack hardie 
grip highperformance architecture parallel graph reduction 
ifip conference functional programming languages computer architecture 
springer verlag september 
pey simon peyton jones 
implementation functional programming languages 
prentice hall 
bibliography pey simon peyton jones 
implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming april 
simon peyton jones hall kevin hammond william partain philip wadler 
glasgow haskell compiler technical overview 
uk joint framework information technology technical conference keele march 
pj john peterson mark jones 
implementing type classes 
proceedings acm sigplan symposium programming language design implementation 
acm sigplan june 
pl simon peyton jones john launchbury 
unboxed values class citizens 
functional programming languages computer architecture pages september 
pl simon peyton jones david lester 
modular fully lazy lambda haskell 
software practice experience may 
pp simon peyton jones william partain 
effectiveness simple strictness analyser 
functional programming glasgow fun 
ps andrew pitts ian stark 
observable properties higher order functions dynamically create local names new 
mathematical foundations computer science pages berlin 
lncs 
ps simon peyton jones andr santos 
compilation transformation glasgow haskell compiler 
functional programming glasgow ayr scotland 
springer verlag workshops computing 
rg richardson ganapathi 
interprocedural analysis versus procedure integration 
inform 
proc 
lett 
rp eike ritter andrew pitts 
fully translation calculus types standard ml 

san sands 
naive time analysis theory cost equivalence 
technical report diku university copenhagen 
sch schmidt 
denotational semantics 
allyn bacon 
bibliography sew seward 
interpretation functional languages quantitative assessment 
phd thesis university manchester september 
sp andr santos simon peyton jones 
program transformation glasgow haskell compiler 
launchbury sansom ls 
sp patrick sansom simon peyton jones 
generational garbage collection haskell 
functional programming languages computer architecture fun pages 
sun sun microsystems 


tak takeichi 
lambda hoisting transformation technique fully lazy evaluation functional programs 
new generation computing 
tur david turner 
new implementation technique applicative languages 
software practice experience 
tur david turner 
applicative programming 
eci munich october 
wad wadsworth 
semantics pragmatics lambda calculus 
phd thesis department mathematics oxford university 
wad philip wadler 
efficient compilation pattern matching 
pey 
wad philip wadler 
deforestation transforming programs eliminate trees 
theoretical computer science 
wan wand 
deriving target code representation continuation semantics 
acm toplas july 
wb philip wadler blott 
ad hoc polymorphism ad hoc 
symposium principles programming language austin 
