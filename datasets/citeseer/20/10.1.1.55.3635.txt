linda implementation revisited andrew douglas alan wood antony rowstron department computer science linda model communication ordination parallel processes 
model provides virtual shared memory called tuple space primitives place tuples remove tuples tuple space 
style programming provided linda quite different style say occam 
describe new implementation linda network transputers 
provide linda primitives rd eval new primitive collect developed york 
implementation focuses issues 
issue ordering operations sequential process preserved want linda act coordination langauge 
implementation provides 
second issue implementation eval linda mechanism spawning processes 
outline implementation provides arbitrary spawning processes execute concurrently despite restriction enforced transputer architecture declaring static number processes compilation stage 
provide small example show linda write parallel programs outline current undertaken york focuses interpretive environments high level parallel programming languages 
prototype linda implementation interpreter developed 

transputer programming easy thinks 
design principles formal process calculi require certain restrictions way programs written static previously declared number communication channels processes 
results spatial temporal coupling processes processes know sending messages execution time sending receiving processes overlap 
outlines research implementation shared memory style parallelism linda communication model meiko computing surface 
linda provides simple model communication ordination processes 
approach highly de coupled communication performed simply placing messages virtual shared memory 
process sending message knows receiver message vice versa 
fact temporal existence sending receiving processes may quite distinct 
describe implementation linda currently construction university york 
goal research implement high level programming language environments 
embed linda model languages running processes set processors accessing shared memory distributed processors 
language environments interpreted aspect affected design 
proceeds outlining york variant linda model including new primitive collect developed york 
point problems addressed implementation 
outline implementation phases phase gives tuple space implementation second phase describes process creation management 
give comparison implementation linda implementations particular describe transputer implementations 

linda linda provides primitives communication processes 
communication takes place tuple spaces shared memories associative lookup mechanism 
tuple space bag tuples tuple ordered sequence typed objects 
example true fred tuple fields type integer boolean string 
tuple access individual fields indexing 
example true fred value fred true fred undefined 
corresponding tuples templates process associative matching 
template ordered sequence typed objects 
example true fred template fields 
template precisely match tuple true fred 
templates different tuples field template may typed value 
example template bool fred matches tuple match tuple false fred 
type notation represents typed hole 
templates class objects may passed processes 
template match tuple hold ffl tuple template equal number fields ffl field contains item type ffl field contains object equal value template field contains hole 
functions supplied linda manipulating tuple spaces ffl ts takes tuple space ts tuple places tuple tuple space ts ffl ts takes template searches tuple space ts tuple matching suitable tuple returned result 
process making call blocked suitable tuple enters tuple space 
tuple returned removed tuple space 
ffl rd ts takes template searches tuple space ts tuple matching suitable tuple returned result 
process making call blocked suitable tuple enters tuple space 
tuple returned remains tuple space 
ffl collect ts tt takes tuple spaces ts tt template moves tuples ts match tuple space tt 
returns count number tuples moved 
collect primitive replaces functions original linda inp rdp operations 

multiple tuple spaces allow multiple tuple spaces unique identifier provide new primitive function tsc returns new unique tuple space identifier 
system tuple space independent item yale multiple tuple spaces tuple space enclosed larger 
multiple tuple spaces ideal local communication select set processes hiding communication processes 
tuple spaces class objects tuple space identifiers passed processes 

eval eval primitive linda way spawning processes tuple space tuple 
thread spawned evaluate tuple place result tuple space 
instance eval ts spawn new process evaluate tuple 
resulting tuple placed tuple space ts 
evaluate expressions parallel components access tuple space 
reason care taken ensure unintentional deadlock processes blocked 

important issues comment important issues considered implementing linda 
mentioned previously relation linda commercial linda implementation 
issues code fragments written style pascal imperative language 

ordering outs take fragments code series operations tuple space ts 
tuples followed done tuple ts tuple ts tuple ts done second performs number operations ts tuples ts tuple done appears collect ts ts done perform stuff collect remaining tuples private tuple space collect ts tt int perform clear tt pattern fragment code master worker style parallelism 
loops time working tuples tuple space ts 
tuple production signalled appearance tuple done 
appears count move remaining tuples perform operations tuples finish 
important issue done tuple detected tuple space collect operation catch tuples generated proceeding operations 
sequence outs sequential process tuple ordering preserved tuple available produced 
implementing eval second issue concerns eval demonstrated fragment code 
take function func stuff return finished func spawn process eval primitive computes function parallel eval ts local ts finished code fragment starts thread waits spawned process finish 
computation performed eval immediately block waiting result 
second issue implement eval primitive way enforces intuitive say obvious meaning eval eval spawn new thread 
demonstrated implementations eval observe meaning consequently leads deadlock programs 
similar issue discussed points computation eval ts compute parallel deadlock occur due dependencies functions 
points context programming language functions sideeffect global variables amounts communication processes 
solve problem dealing closures 
closure package separate environment created separate thread 

implementing tuple space consider set processors fp local memory 
consider say transputer megabytes memory 
distribute tuple space set tuple space managers ft tm distributed way 
consists process queue requests exact processor topology distribution tuple space managers fixed 
tuple space manager able communicate tuple space managers 
user processes tuple space requests adding commands queue tuple space manager 
approach ways 
requires user process know tuple space manager manager take care placement tuples tuple space 
second approach requires user process know tuple space managers placement decided user process hashing approach slight cost advantage certain flexibility placement schemes compiled application tuple space managers 

tuple space distribution tuple space distributed set tuple space managers 
tuple placement lookup decided pair hashing algorithms 
hashing algorithm uses information determined produce subset tuple space manager processes kind tuple placed 
example tuple template determine number fields individual types 
second hashing algorithm uses result algorithm plus specific information determine precisely place tuple question 
tuple information obtainable template information required second hashing algorithm may determinable 
say tuple template information determinable completely 
example perform operation tuple completely contains holes 
hashing algorithm give range tuple space place kind tuple 
second algorithm take value field tuple produce integer value representation return value modulo gamma 
assuming value field changes regularly distribution kind tuple range tuple space managers fairly 
performing operation follows similar routine 
algorithm take template produce range tuple space managers kind tuple distributed 
template completely argument argument hole determine precisely tuple space manager contain may implemented separate process 
tuple 
template completely argument argument hole leave requests tuple queue tuple space managers range specified algorithm 
arbitration required matching tuple removed tuple space returned user process 
note number things 
firstly hashing takes computation time choose hashing algorithms take time compute 
secondly distributing tuple space processors tuple space managers want provide hashing algorithms give fair distribution tuples 
compiled languages entire code runtime perform static analysis code determine pattern process communication 
result fast linda runtime system sequences ins outs optimised 
environment processes code dynamic interpreted language environments kind analysis take place 
addition proposing tuple spaces templates class objects passed processes tuple spaces 
static analysis difficult perform highly dependent hashing means providing fast placement lookup tuples tuple space 

servicing requests discuss briefly operation view implementation ffl operation request causes hashing take place 
require tuple completely hashing choose tuple space manager place tuple 
message tuple space manager containing tuple tuple space name sent 
tuple stored particular tuple space manager suitable blocked process waiting case action take place 
cost operation cost sending message 
ffl rd complicated cases completely template template hashing determine exact tuple space manager 
case completely template template tuple space name communication address requesting user process sent hashed tuple space manager 
search undertaken find suitable matching tuple 
find cause tuple sent requesting process action tuple removal performing take place 
find cause process kept list blocked processes 
subsequent outs cause list searched matching tuple prompt manager send tuple requesting process take action tuple 
cost completely template messages 
case incompletely template request tuple space managers set returned hashing algorithm 
responsibility taken process see tuple sent requesting process 
tuple space manager request sent chosen arbitrarily set keeps record transaction assigning unique transaction analogy static analysis functional languages higher order functions 
number passes tuple tuple space name rest tuple space managers set find tuple space managers prompts finder send tuple tuple space manager charge 
transaction list tuple sent requesting process cancellation messages sent tuple space managers involved transaction transaction removed list 
tuples matching request subsequently received tuple space manager charge cause tuple received re record transaction transaction list 
tuple tuple space managers transaction added blocked process list 
receipt remove transaction message causes transaction removed list transaction list ignored 
receipt tuple matching transaction cause transaction removed list tuple sent tuple space manager charge 
note keeping transaction records means tuple returned user process 
cross matching tuple delete transaction message occurs inconsistency incurred delete message ignored tuple returned re 
hashing algorithm returns range containing tuple space managers best case cost matching tuple tuple space manager charge template completely messages 
worst cases single match tuple space manager tuple space manager charge requires messages messages send request receive reply gamma message requesting tuple tuple space managers reply gamma requests remove transaction 
second worst case match tuple space manager charge match tuple space managers set 
cost gamma messages messages send request receive reply gamma messages requesting tuple tuple space managers gamma replies gamma re tuples 
ffl collect causes global send set tuple space managers may contain tuples kind hashing algorithm 
operation tuple space manager request chosen arbitrarily set tuple space managers put charge summing results returning count 
execution collect primitive tuples moved tuple space managers placement tuples depends value tuple tuple space 
case tuple space names different individual tuple prompts lists blocked processes searched 
blocked process list search required destination host tuple space identifier tuple space sufficient proof processes blocked tuple 
cost collect messages number tuple space managers returned hashing algorithm 
initial search tuple space manager receiving request find require broadcast tuple space managers 

data structures naive approach storing tuples blocked processes lists 
list advantages comes adding items takes constant time 
action searching tuple space matching tuples matching tuples lists blocked processes benefit considerably thoughtful approach 
example take tuple space list tuples matching template tuples take nm time measure size template matched number tuples list 
storing tuples hash tree better 
adding tuples takes log time finding match takes log find list tuples search nr time matching number tuples hash value 
kind trie tree representation convenient 
structure tuple space takes tree format size type tuples contains 
adding tuples means adding branches represent parts tree don exist 
marker containing integer represents number tuples particular size type value 
addition include marker list processes blocked kind template 
storage scheme complexity hash tree smaller storage space requirement integrates blocked process list tuple space 
moment implementation uses naive data structures progress hash trees 

tuple space garbage collection garbage collection tuple space performed implementation garbage collection simple matter tagging tuple space count 
class tuple spaces necessary include count occurrences tuple space identifiers embedded tuples tuple space 
mean searching tuples rd operation requested update 
interesting note slight modification linda model possible linda persistent way 
include model kind global tuple space available processes 
tuple space identifiers placed tuple spaces required persistent 
kind model appear suitable kind database applications clients database come go 
eval eval primitive linda way spawning processes part linda 
view eval acting tuple space take view eval simply spawning processes language computation linda 
require engine computation spawn thread perform computation place result tuple space 
importantly want give impression unlimited dynamic creation processes implementing garbage collection tuple space mean removing entire tuple spaces exist doesn implement sophisticated persistence described propose active tuples tuples tuple space evaluating passive tuples 
go far able active process suspending computation 
strict regime enforced computing surface 
engine consist items ffl single heap shared threads ffl list runtime elements containing stack pointers code pointers ffl main function takes closure computes value ffl single communication channel semaphore control sharing buffer hold messages ffl main function spawn threads perform garbage collection 
spawned thread index list stack pointers holds information state computation 
heap embedded list time main process thread process perform garbage collection 
consequence transputer architecture communication links declared advance computation begins 
threads need communication channel assigned tuple space manager share channel 
communication channel transport meiko csn terminology buffer stores incoming messages 
semaphore required control access transport 
sending messages performed way tagged unique identifier belonging particular thread 
receiving incoming messages requires process check message store message received 
thread wait suitable message arrives 
main function waits messages containing closures thread created function provided meiko cs tools environment 

floor management number engines distributed set processors useful kind process performing load balancing kind 
time new thread requested requested floor manager process returns message containing address loaded engine 
loaded engine calculated keeping count number threads executing time particular engine 
thread terminates result computation placed tuple space message sent floor manager say thread completed 
true load balancing take account amount processing needed particular thread 
engines running processor handle threads single engine processor 
floor manager process extended cope kind information 

comparisons implementations described uniform distribution model outlined hashing schemes 
closure expression code required environment containing values time closure created free variables done zenith feng implementation linda transputer networks 

zenith implementation zenith describes implementation linda number transputers 
approach compilation programming language embedded linda operations occam programming language compiled execute transputers 
zenith approach similar respects 
proposes divide tuples distinct subsets kind tuples appear 
kind tuple decided compile time 
hashing determine place tuple set processors 
tuples hash value get placed private non distributed hash table 
node zenith machine consists transputer run tuple space manager transputers act computation nodes approach flexible topology processors implement approach wished 
clear zenith approach preserve order operations 
clear eval issue addressed satisfactory way 
eval operation transformed operation performed parallel 
implemented occam presumably par construct 
occam forbids replicated parallel processes constant bound 
causes problem code eval ts determine statically processes required 
solution proposed transform code ts create optimal number process dependent number processors available machine int ts ts place number tuples tuple space representing eval create processes repeatedly eval tuples computation result 
clear possible processes performed sequentially dependencies processes deadlock occur 
example consider outline program void worker tuple space ts tt ts tt assumption processors cheap 
worker function takes tuple spaces 
example tuples ts produce results tt 
void main int tuple space ts arr ts arr eval worker ts arr ts arr rest main ts arr main function declares array tuple spaces integer set function 
loop evals processes act pipeline tuple space array communication medium 
eval transformation described deadlock occur optimal number processors started happens 

approaches feng papers choose methods tuple placement uniform distribution 
chooses intermediate uniform distribution processor topology fixed grid processors 
feng discuss topology similar approach 
common approaches sets processors 
processor assigned set processors oe 
operation occurs tuple duplicated processors 
requested search performed processors matching tuple 
appears suffer problems due arbitration operations duplication tuple space need keep consistency 
approach describes basis linda machine arbitration performed hardware 
approach taken define tuple space manager sets tuple level 
tuple template define cardinality cardinality varies completely 
sets determined runtime hashing algorithms 

case study parallel addition bag numbers 
program performs parallel addition bag integers function parameters number integers contained bag tuple space containing integers 
spawns num threads evaluate worker function 
worker passed extra arguments calculate perform dies voluntarily 
course program modified perform commutative binary operation 
func int num ts local num eval worker num num worker terminated return func function worker see repeatedly loops pulling numbers tuple space adding placing sum back tuple space 
addition pair numbers tuple space taken place left half numbers add processes perform addition 
processes left compute grab number tuple space block waiting 
require half remaining processes die 
second parameter worker function purpose 
task simple appears 
calculation addition performed conditionals bit manipulation speed establishes thread lives dies 
addition die loop continues number remains tuple space 
addition completed thread placed worker terminated tuple tuple space 
worker func ts local int position int tuples local position tuples local local local position tuples tuples tuples position position return worker terminated worker 
goal research implement high level languages contain primitives parallel processing 
languages gofer interactive environments 

linda interpreted imperative language main data structure finite sets 
tuple spaces viewed bags similar sets respects items may occur times bag 
integrating tuple space operations adding new types bags templates implementing operations behave linda primitives 

gofer linda gofer interpreted functional programming language 
propose extension language operations act tuple spaces 
noted bags better basic data structure parallelism lists hope successful adding linda primitives fast functional programming 
parallelism essentially non deterministic stateful especially shared memories concerned 
hope techniques investigated add linda operations gofer way preserves properties functional languages 

current progress prototype linda implementation interpreter developed 
ultimately languages investigated expressing image processing algorithms 
undertaken relation linda partially funded epsrc research gr 
antony rowstron supported epsrc case british aerospace military aircraft division 
ahuja carriero gelernter krishnaswamy 
matching language hardware parallel computation linda machine 
ieee transactions computers august 
brian anderson dennis shasha 
persistent linda linda transactions query processing 
ban atre le editors research directions high level parallel programming languages volume lecture notes computer science 
springer verlag 
nancy baxter ed gary levin 
learning discrete mathematics 
springer verlag 
paul butcher alan wood martin atkins 
global synchronisation linda 
concurrency practice experience 
carriero 
implementing tuple space machines 
phd thesis department computer science 
available technical report number yaleu dcs rr 
nicholas carriero david gelernter timothy mattson andrew sherman 
linda alternative message passing systems 
parallel computing 

intermediate uniformly distributed tuple space transputer meshes 
ban atre le editors research directions high level parallel programming languages volume lecture notes computer science 
springer verlag 
feng gao 
distributed linda tuplespace algorithms implementations 
appear 
david gelernter 
generative communication linda 
acm transactions programming languages january 
david gelernter 
multiple tuple spaces linda 
rem 
editors parallel europe volume lecture notes computer science pages 
springer verlag 
mark jones 
gofer 

marino 
data structures parallel execution functional languages 
rem editors parallel architectures languages europe vol 
ii number lecture notes computer science 
springer verlag 
james jr informal operations semantics linda 
technical report yaleu dcs rr yale university 
scientific computing associates incorporated 
linda example 
available scientific computing associates incorporated century tower new haven ct 
dennis 
identifier search mechanisms survey generalized model 
acm computing surveys september 
steven ericsson zenith 
linda ordination language subsystem kernel architecture transputers 
technical report yaleu dcs rr yale university 
