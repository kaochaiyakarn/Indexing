university pennsylvania walnut street suite philadelphia pa may site nsf science technology center research cognitive science ircs report institute research cognitive science efficient constraints possible worlds reasoning necessity matthew stone efficient constraints possible worlds reasoning necessity matthew stone department computer information science university pennsylvania south rd st philadelphia pa matthew linc cis upenn edu summary modal logics offer natural declarative representations describing modular structure logical specifications attitudes behaviors agents 
results goal building practical efficient reasoning systems modal logics 
key problem modal deduction reasoning world model scope proof inference rule applied potentially hard problem 
investigates partial order mechanisms maintain constraints application modal rules proof search restricted languages 
main result simple incremental polynomial time algorithm correctly order rules proof trees combinations necessity operators governed variety interactions assuming encoding negation scoped constant 
contrasts previous equational unification methods exponential performance general simply guess possible modal operators 
new fast algorithm appropriate wide variety applications modal logic planning logic programming 
content area reasoning techniques deduction efficiency complexity 
necessity operator modal logic provides natural declarative construct specifying content search control describe change time specify attitudes agents knowledge belief simply enforce modularity complex specifications moore halpern moses giordano martelli 
automatic interpretation modal specifications requires efficient reasoning mechanisms modal logic 
despite advances wallen ohlbach efficient modal reasoning remains elusive 
identifies important new opportunities performing tractable inference modal logic 
results show time automatic systems program synthesis planning logic programming modal logic practical representation 
mark steedman extensive comments dale miller helpful discussion 
supported nsf graduate fellowship ircs graduate fellowship nsf iri arpa aro daah 
submitted journal logic computation 
may 
matthew stone reviewed section key difficulty modal reasoning capture scope discipline formulas modal proofs 
attempting prove necessity truth reason possible truth creates scope deduction necessary truths 
classic descriptions scopes 
chellas lead explosion search space automated deduction 
systems hilbert type axiom systems manage scope protocol transfers valid inferences step step top level nested scopes gentzen type sequent calculi perform inference scope inside contiguous region proof 
treatments scope force proof search algorithms guess alternatives information determine alternatives possibly relevant 
difficulties avoided translating modal formulas classical logic worlds accessibility relations kripke semantics modal logic kripke explicitly deriving full proofs accessibility worlds unmanageable 
investigates description modal inference 
system pioneered fitting wallen ohlbach assigns proof theoretic abstraction scope explicitly formulas 
formula labeled string recording sequence embedded operators path scope formula holds 
allowing label formula partially instantiated unification formula proof search procedure avoids severe drawbacks deduction earlier systems 
method involves complex expensive equational unification processes limit practical 
show significantly better results achieved modal logics encoding negation possibility terms scoped propositional constant 
encoding modal connective encoding creates languages 
analyzing unification problems proofs languages show solutions respect order terms representing scopes introduced 
constraint resolves essential ambiguities unification paths accessibility 
determined polynomial time constraints encountered point proof search represented partial order mechanism avoids need backtrack alternative unifiers 
strategy generally applies logics multiple modalities correctness strategy requires constraints interactions modal operators 
path explicitly scoped proof system plays integral role statements proofs results 
organization rest follows 
section give proof theory modal logic motivations pitfalls complexities 
section main proof theoretic observation underlies results 
constraint algorithm exploiting observation section 
section finish considering impact algorithms tree constraints necessity range practical problems including synthesis functional programs temporal reasoning automatic planning reasoning agents 
proofs modal logic variety formal systems describe proofs modal logics choice proof system profound impact difficulty automatic proof construction 
decade seen key developments systems result modal deduction shown satisfy advantageous metatheory classical logic respects research experience classical deduction transfers modal logic 
results important deserve widely known claims significance modal logic result just tractable deductive point view ordinary order logic bibel misleadingly optimistic 
purpose section review results briefly connect intuitions new proof systems intuitions old ones highlight distinctive complexities remain modal deduction relate standard characterizations complexity modal deduction 
reader may consult mints thorough modern modal proof theory gallier connections proof theory automated deduction 
section informal example intended motivate modal scoping mechanisms introduce key theme meaning modal operators comes assumptions relationships scopes operators introduce 
section provides inevitable technical necessities language notation introduces different proof systems modal logic concretely 
section reviews familiar axiomatic method modal inference computational limitations 
section describes structurally scoped proof systems style gentzen role inference systems hindering automated deduction 
explicitly scoped proof systems introduced way ground system lifted system unification 
system explicit scoping unification frees search engines unnecessary commitment inherent structurally scoped proof methods relational translations classical logic 
lifted system focus remainder 
section shows success system supporting techniques classical theorem proving offset fact unification procedure relies resolve scopes intractable principle practice 
intractability scope unification local problem compounds global intractability implicit pspace completeness results ladner halpern moses proofs propositional modal logic cases unreasonably large 
global problems possible size proofs familiar ordinary order deduction equality local problem analogue 
matthew stone fact serious problem practice 
small putative modal proof containing step symbol theorem derived intractable find unifier correctly assigns scopes rules 
ambiguities involved arise result equational theory governing scope terms difficult avoid judicious reformulation logical statements sort familiar prolog programmers 
motivation formulas order classical logic specify information ordinary entities formulas expressive logics constrain information reasoning 
proposals expressive logics start informally imposing notion scope deductions 
force notion scope formulas lie scope combined reasoning 
restrictions formulas inference play important roles knowledge representation 
expressive power helps describe complex domains concisely correctly 
example scoped specification describe agents propositional attitudes ensuring facts combined describe content single attitude single agent 
formula scope records agent attitude describes 
similarly scoped specification describe multiple moments time guaranteeing facts true time combined inference 
time fact holds determines scope 
second expressive power imposing scopes proofs offers method ensure scoped specifications modular reusable 
scoped language body knowledge forms module logical interactions limited facts compatible modules 
view scope formula depends module resides 
different proposals halpern moses morgenstern ballim mccarthy buva offer methods realize various notions scopes deductions computational setting 
formalized differently different degrees key feature operator defines scopes deductions formulas restricted variously necessity quotation boxes contexts rules govern transfer formulas scope 
features achieve strikingly similar effects different formalisms 
follows reasoning scopes central problem implementing 
concrete example adapted mccarthy buva illustrates motivation behavior scopes proofs 
introduce modal logic particular scoped representation time emphasize practical applications modal logic depend availability flexible range reasoning principles 
discussion modal proof systems section parametrized different modal operators reasoning principles right start 
tree constraints necessity example 
general electric navy different ideas price component ge establishes base list prices component separately 
navy specifications refer prices include cost individual component cost equipment spare parts navy purchase 
determine price component navy specification start list price add list price specified spare components 
formalize choose representation list price spec spares list price oe spec price formula list indicates proved special scope information catalogue taken account likewise spec navy specifications 
similarly represent ge navy may different partial information list specification introducing operators ge navy ge indicates proved ge information account 
way model operators list spec ge navy necessity operators modal logic 
section list necessity operator modal proof list simplest modal logic precisely proof takes list formulas account 
expressive power scoped representations particularly attractive relate information different scopes 
purposes practical inferences real applications streamlines statement commonalities facilitating maintenance reuse 
knowledge representation may possible range natural inferences including important inferences nested scopes difficult impossible describe 
example list specification example represent kinds accounting information parallel inferences may required scope list scope spec 
common inferences motivate operator acct specifying facts price list specification share 
simple example fact prices measured dollars xp acct price oe dollar value statements play intended role reasoning need way transfer results scope 
draw inferences units list specification record prices need able infer list spec acct operator records information ge navy share needed capture commonalities ge navy 
example record organizations aware method calculating prices described matthew stone list price spec spares list price oe spec price intended need way infer ge navy operators interact way needed generalizations intuitive annotation succinctly describes range contexts facts apply 
give useful separate roles operators order components formulas list price spec price 
illustrates scoped representation natural convenient corresponding complex order representation list price spec price common generalizations measurement price dollars spelled explicitly separately 
modal operators kind reasoning described formally investigated mathematically introducing axiom schemas applied constructing proofs 
example axiom relating inclusion oe capture import acct modalities relate ge navy operators acct list spec 
different strategy relating operators relies establishing relationships outer scopes deeply nested scopes 
need strategy direction 
need way infer need strategy direction arises modeling hypothetical reasoning agents 
example suppose navy knows specified 
navy list price fx engine navy spec spares fx engine fx fan blades navy knows needs fx fan blades fx engine navy ge list price 
expect able conclude navy determine specification price knew list price fx fan blades 
requires hypothetical reasoning reasoning navy 
fact derived navy navy list price fx fan blades oe navy spec price fx engine derive consequence goal form navy navy price double embedding 
strategy appeal inference navy navy navy navy knows knows knows 
inference expresses different natural relationship scopes 
continue establishing tree constraints necessity navy navy list price fx engine navy navy navy spares fx engine fx fan blades navy navy ge price fx fan blades obtained indirectly inference nested scopes 
get third assumed proving implication 
establishes result 
discussion shows need additional axiom schemas formalize reasoning modal logic ver pi ver oe pi positive introspection oe example 
general may invoke variety axioms augment basic modal logic better match modal operators common sense notions meant model 
addition axioms ver pi introduced axioms con ni widely con consistency ni negative introspection oe shall explain subsequently additional axioms immediately compatible framework developed 
example combination con pi known kd argued give rise sensible model belief normative agent beliefs consistent keeping con agent believes believes proposition believes keeping pi 
combination ver pi known provides model knowledge agent knows true keeping ver 
modeling attitudes agents modal logics begins hintikka subsequent reviewed fagin offers case studies 
surprisingly choice axioms describe different kinds attitudes controversial 
example may appropriate incorporate ni models belief knowledge finite domains giving kd respectively may appropriate incorporate con models belief giving 
modalities called governed just con ver 
range modal proof systems consider family order modal languages parametrized set paired operators necessity possibility finite integer theory specifying relations operators terms ver pi axioms 
usual presume signature describing arity functions predicates set atomic formulas form matthew stone 
formulas formulas described grammar oe formal manipulations keep concise notation continue name notation seen example contexts necessity operators profitably assigned intelligible legible names 
note connectives may defined terms refrain doing interested language fragments language express definitions 
fragments particular importance propositional fragment omits quantifiers fragment omits negation usual definitions free bound variables carry modal logic 
denotes result substituting bound variables renamed variable appears free avoid capture 
treat formulas differing names bound variables identical 
allowing terms substituted freely inside implicitly adopt increasing cumulative domain constraint modal logics allows formulas nested scopes refer freely objects introduced outside 
objects introduced nested scopes need available outside 
note proof theoretic devices section modified straightforwardly handle alternative varying constant domain systems 
hilbert systems inference modal logic succinctly intuitively characterized hilbert systems 
systems proof sequence formulas formula instance axiom derivable earlier formulas action simple inference rules 
simplest propositional modal logic halpern moses axiom schemas tautology classical propositional logic oe oe combined rules inference modus ponens oe infer necessitation infer principles relating scopes accommodated simply adding appropriate additional axiom schemas 
relatively straightforward see proof system imposes scope discipline modal operators scope logic combine information explicitly asserted 
system formula tree constraints necessity proof theorem holds real world root scope 
depend additional assumptions sake argument rule necessitation apply theorems 
formula proof takes form predicates ith deeply nested scope 
tautology established nested scope introducing root scope instance axiom applying introduce necessary nestings 
axiom rule modus ponens allows action modus ponens nested scopes 
result nested scopes closed logical consequence way root scope hand logical means introducing formulas form derive contingent form example consequent implication combine explicit assumptions form example antecedent implication action 
hilbert systems intuitive facilitate mathematical study modal systems example proofs soundness completeness 
hilbert systems computationally unattractive 
key difficulty hilbert systems lack subformula property common proof systems efficient classical theorem proving methods 
subformula property guarantees result provable system proof system instantiations subformulas 
general axioms modus ponens runs counter subformula property forces deduction formula formula appeal explicit derivation complicated formula oe modal logic virtue nested application modus ponens complicated formula derived carry inference forward oe indirectly related premise 
theorem proving subformula property crucial controlling search allows search engine rule options extending proof soon options introduce non subformulas 
methods ruling options vital allowing theorem prover detect failure branch proof search move 
subformula property streamlines theorem proving enabling variety methods improving space usage structure sharing boyer moore 
structurally scoped sequent calculi modal proof system satisfy subformula property shown 
proof system extends sequent calculus classical logic rules governing modal operators modal rules governed parameters vary order encode relationships scopes 
sequent calculus represents sound complete inference system semantics hilbert system characterizes equivalent system 
system respects subformula property reasoning performed directly inside scope modal rules mediation rules necessitation axioms matthew stone consequential closure 
proofs system trees built accordance inference rules 
label node proof tree sequent form multisets formulas represents derivation disjunction formulas formulas assumptions 
label root proof called sequent 
instantiation axiom rule proof facts derived assumption facts 
proofs sequents instantiates unary inference rule tree proof instantiates binary inference rule tree proof 
proofs 
convenient define proofs top characterization typically natural read proofs bottom record proof search sequent 
read rule decomposes outer connective distinguished formula sequent called principal formula rule 
yields new typically smaller search problems immediate subformulas principal formula side formulas rule application occur sequents place principal formula 
written inference rules carry principal formula sequent higher sequents 
convention allows formulas repeatedly proofs structural rule contraction required duplicated formulas clutter proofs occasionally suppress 
informal justification system creates maintains scopes proofs follows 
sequent appears scope corresponds position proof tree 
proof applications 
mark boundaries scopes 
entire subproof application deeply nested scope application operator 

rules represent applying necessary information current scope 
tree constraints necessity axiom oe oe oe 
oe oe oe oe 
structurally scoped cut free sequent calculus modal logic 

appear 
matthew stone cases rules may introduce boundaries logics necessary information applied nested scopes 
restriction necessary information nested scopes necessary information nested scopes achieved filtering formulas sequent scope transitions 
filtering accomplished operators 

relate sequents modal rules 
intent filtering functions formulas describe nested scope survive transition application 

transition surviving formulas modified reflect strength new nested scope 
filtering functions distinctive feature structurally scoped modal proof system 
filtering functions vary way indirectly encodes relationships scopes hilbert systems axioms pi 
modalities take scopes face value necessary formulas formulas apply ordinary force nested scopes 

transitions eliminate assumptions form eliminate potential form 
nested scope remove outer assumptions outer 
apply necessary information 
scopes need consistent necessity imply possibility allow necessary information brought bear side effect creating scope 

dispense 
rules 
positive introspection inclusion modeled changes filters 
achieve effect pi surviving assumptions appear true current scope true nested scopes 
surviving likewise appear 
implies effect achieved passing just 
relates modality modality impacts transition scope 
hand formula strong entering scope entering scope 
means ensuring results usual filter scopes appear transition 
time formula strong entering scope formula 
means applying usual filter formulas ensuring results available nested scope 
modeled changes 
filters 
necessary assumptions possible demonstrated current scope 
change scope formulas rule application 
filters ver logics identities 
formal description filtering functions follows completeness 
formal presentation plays little role follows reader may safely skip ahead examples structurally scoped proofs 
assume tree constraints necessity gg gg gg aj gg aj gg dg dg dg aj dg aj dg primitive rules governing changes scopes structurally scoped modal logics 
assigned primitive type modalities related partial order inclusion oe formulas start primitive functions shown show alter sequent build particular modal theories 
note entry table sequent rules invoke value entry apply logic regardless inclusions available 
determine appropriate change combine primitive functions effects inclusions definition ji ji ji ji example 
figures show proofs system sequents involving single modality oe oe oe oe oe oe theorems involve necessary assumptions may different scopes nested nested twice nested 
key difference different proofs scope order lower rule applies 
rule highlighted box proofs 
proof rule lies inside nested scopes matthew stone oe 
oe oe oe oe oe oe oe oe oe example theorem structural system 
oe 
oe oe oe oe oe oe oe example theorem structural system 
applications 

second lies inside application 

third root scope 
scoped location application crucial case allowing proof completed 
proofs rely application oe 
left branch consists axiom link oe 
application performed scope introduced 
hand rule assumed nested scope introduced formula proved 
assumption contingent assumption scope introduced oe 
oe oe oe oe oe example theorem structural system 
tree constraints necessity pass filtering higher 
rules 
example 
significance relative positions rules proof represents problematic departure classical logic 
classical sequent calculi rules freely interchanged long structure formulas respected quantifier rules continue introduce new variables necessary kleene 
exploiting property search key feature classical theorem provers 
example tableau matrix andrews bibel theorem proving methods seen optimizations sequent calculi eliminate redundancy 
difficulty arises absence free 
automated deduction engines build sequent proofs root determine move helpful matching atomic formulas leaves 
rules introduced right scope right time automated methods prepared apply rule know application needed 
regime imposing scope proofs means proofs longer constructed goal directed manner 
explicitly scoped sequent calculi overcome limitation represent rules notation give rules interpretation matter rules appear proof 
achieve labeling formula proof distinguished term represents scope formula 
doing capture scope rule application labels principal side formulas 
technique goes back fitting prefixes fitting considerably refined fitting wallen ohlbach 
explicitly scoped sequent calculus 
calculus sequent takes form formulas labeled strings distinguished alphabet scope variables terms composed scope variables associative binary operation concatenation left right identity ffl 
write annotation variables ff fi represent strings 
multiset auxiliary premises associated sequent specifies types free scope order variables sequent call typing context 
notation common programming language theory identify premises typing 
scope variable represents transition level nesting modal operator type records operator order variable introduced quantifier rule scope type records string representation scope 
multiset pairs form ff scope variables order variables 
information combined derive judgments complex scope representations order terms take particular types 
scope terms judgment indicate describes matthew stone axiom oe oe oe 
oe oe oe oe oe oe ff ff oe oe ff ff path explicitly scoped cut free sequent calculus modal logic 

ff appear 

appear 
tree constraints necessity ax oe oe ver ver ffl oe pi pi deriving judgment transition modality matches judgments derived rules shown realize axioms ver pi rules inference amalgamating terms 
similarly judgments form indicates order term available scope determined definition definition free variable occurs assignment prefix 
explicitly scoped calculus imposes scope discipline earlier systems manipulation terms 
rules connectives ordinary order logic identify scopes principal side formulas 
axiom rule system requires labels formulas match formulas 
atomic established nested scope virtue assumption introduced scope lower modal rule 
rules apply result nested scope appending additional term label side formula 
terms constrained match strength principal formula imposing judgment 
rules create new nested scope appending new variable representing type nesting label side formula 
new variable introduced 
rule appear scope fixed point necessary assumptions instantiated new variable new scope axiom 
strategy isolating nested formulas outer formulas subtler ultimately similar strategy structurally scoped sequent calculus 
ensure order terms escape scopes require judgment 
applied scope instantiation explicit scoping new system somewhat expressive previous modal proof systems 
correspondence stated follows derivation sequent matthew stone structurally scoped sequent calculus derivation sequent explicitly scoped sequent calculus assumption labeled ffl 
result typically established showing explicitly scoped calculus sound complete usual semantics modal logic kripke 
recall modal frame consists set worlds binary relations pair operators axiom schemas correspond properties relations satisfy ver reflexivity pi transitivity 
truth formula relativized world particular true true 
explicitly scoped system labels formulas point evaluated manipulates scopes logical rules analogous quantifiers obviously quite close semantics 
fact annotations thought paths accessibility possible worlds 
ohlbach devised model theory modal logic takes paths primitive idea replace relation set functions af af 
model theory explicitly scoped sequent calculus translation modal logic classical logic semantics ohlbach ohlbach 
explicitly scoped calculus offers number advantages deduction reasoning traditional semantics called reified methods modal deduction moore jackson reichgelt frisch scherl 
expressive equations terms encode axioms necessity captured order axioms accessibility relations van benthem ohlbach 
consider cases 
second efficient 
encoding scopes terms reasoning equality proofs compact search constrained reasoning relations 
shall see section equational unification relatively simple partially specified paths accessibility working simply efficiently worlds partially specified proofs relatedness involved 
advantages known general uses equality theorem proving plotkin 
explicitly scoped calculus need regarded semantic method despite apparent similarity 
stone considers intuitionistic logic proofs structurally scoped sequent calculus derive independent interest interpretation programs howard shows explicitly scoped sequent calculus describes exactly proofs structurally scoped system 
result stronger mere equivalence provability semantics explicitly scoped calculus considered purely proof theoretic optimization 
explicitly scoped calculus studied fruitfully proof theoretic object right see schmidt example 
example 
consider theorems example 
proofs identical tree constraints necessity fffi fffi axiom fffi fffi fffi fffi axiom fffi fffi fffi fffi fffi fffi oe 
fffi oe fffi fffi fffi oe fffi oe oe oe fffi oe oe ff oe oe example theorem explicitly scoped system 
ff ff axiom ff ff fffi fffi axiom ff fffi fffi ff ff fffi ff ff ff oe 
ff oe ff ff ff oe ff oe oe oe ff oe oe example theorem explicitly scoped system 
structure earlier worked explicitly scoped calculus adding appropriate labels formulas proofs 
proofs figures 
note labels encode scopes different applications 
side formula lower gets fffi indicating double nesting likewise gets ff empty string 
structurally scoped system rules permuted remaining 
rules 
violate condition says scope introduced 
rule appear sequent 
hand explicitly scoped system proof constructed rules permuted higher 
assumption scope remains available left sequent leaves proof tree 
example 
lifted system general proof theoretic techniques 
lincoln shankar explicitly scoped sequent calculus lifted unification 
unification streamlines search ways 
choice instantiated terms delayed formulas containing appear axioms 
course information available values useful 
matthew stone ffl ffl axiom fffi fffi axiom fffi fffi fffi ff oe 
oe oe oe oe oe example theorem explicitly scoped system 
second requirements variables new replaced herbrand skolem terms 
herbrand terms contain subterms values appear sequent variable introduced account possible permutations 
ruling circular terms occur check unification ensure variable chosen place herbrand function proof reordered variable new 
eliminates remaining calculus 
shows final lifted system le remainder addresses 
system inference rules describe proofs simply derivations proof attempts 
derivation associated set equations solved obtain proof 
precisely sequent form formulas labeled terms explicitly indicating scope 
terms variables introduced globally typing context grow proof represents input context represents output context enriched describe new variables terms introduced subproof 
similarly accumulate list equations indicating constraints values variables input list equations output list equations 
note binary inferences propagate list right subproof second left subproof 
sections exploit ordering equations results equations left subproofs follow equations right subproofs 
formula sequent associated list free variables schematized subscript inference rules quantifier modal rules introduce variable add variable list 
herbrand terms involve function symbols associated uniquely quantifiers modal operators indicated subscripting build herbrand term placeholder fresh applying function symbol list free variables tree constraints necessity axiom oe oe oe 
oe oe oe oe ff iff ff iff ff iff ff iff lifted path explicitly scoped cut free sequent calculus modal logic le 
variables may appear matthew stone xy fffi xy fffi fffi fffi xy fffi xy fffi xy fffi 
fffi oe 
xy fffi fffi fffi oe fffi xy fffi fffi fffi oe fffi oe xy fffi fffi oe oe fffi xy fffi fffi oe fi oe ff xy fffi fffi oe ff fi oe example theorem lifted system 
formula 
resulting system necessarily dense notation operates straightforwardly 
proof pair consisting derivation sequent formula labeled ffl substitution finite map scope variables scope terms order variables order terms satisfying certain conditions 
usual write describe action term term homomorphism induced 
abbreviate set modal assignments form ff ff ff herbrand term gives types exactly ground scope transitions introduced proof 
notation conditions satisfy 
declaration order variable herbrand term subterm prefix 
ensures values order variables respect scopes variables introduced 
second declaration modal variable derive inference rules 
ensures transitions modal rules respect strengths modal statements 
correctness theorem system states provable lifted system provable ground system 
style herbrand theorem classical logic lincoln shankar proof gives explicit transformations derivations systems cf 
frisch scherl 
example 
proofs lifted system theorems appear figures 
figures uniform proofs miller illustration lifted system facilitates systematic goal directed proof search 
proofs proceed performing possible left rules decompose formula proved atomic goal fffi apply right rules strategically assumption oe match literal assumption goal 
generates equation xy fffi new goal goal established matching assumption right tree constraints necessity xy fffi xy fffi ff ff xy fffi xy fffi xy fffi 
fffi oe 
xy fffi ff ff oe fffi xy fffi ff ff oe fffi xy fffi ff ff oe fi ff oe xy fffi ff oe oe fi ff xy fffi ff oe ff oe fi example theorem lifted system 
xy fffi xy fffi ffl xy fffi xy fffi xy fffi 
fffi oe 
xy fffi ff oe fffi xy fffi ffl oe fffi xy fffi ffl oe fi ff xy fffi ffl oe ff fi oe xy fffi ffl oe oe ff fi example theorem lifted system 
subtree proof 
lifted system different theorems proved rules order order need considered proof search 
different scopes rules represented values variables determined unification 
lower application scoped value scope identical scope assumption ffl ff fffi 
example 
problem system modal inference tractable classical logic sense just classical logic proof search carried modulo permutations rules unification 
particular unification explicit choice determine scoped locations modal operators introduced 
results modal logic practical unification involved ordinary unification string unification 
general algorithms exist problems see schulz 
procedures typically extend transformation algorithms ordinary unification martelli montanari guessing inclusion relations initial free variables equal strings possibly backtracking 
existing modal inference systems nondeterministic equational unification algorithms sort otten kreitz 
methods extremely expensive 
matthew stone example constructing proofs shown figures search engine constructing right branch solving equation xy fffi cases 
problem string unification algorithms return unifiers corresponding different solutions exhibited proofs 
possibility needed resolved axiom reached final equation processed 
branching possible unifiers prohibitive easy see number may exponential length strings unified 
effective way exploit constraint 
backtracking internals equational unification algorithms frequently fail solve systems equations efficiently backtracking program called algorithm sequence equation system 
shall see section resolving scopes modal deduction unification fact intractable problem 
presenting result observe problem quite different nature origin known space complexities modal logic 
classical propositional logic np complete ladner ladner halpern moses halpern moses shown number propositional modal logics including considered pspace complete 
proof logics pspace hard relies describing large objects concisely modal theories 
descriptions apply formula number scopes modal proof statements possibility create different scopes proof may proceed applying necessary information 
order quantifiers provide point interpreting results quantifiers worlds 
order logic number instantiations universal statement needed complete proof bounded 
order logic undecidable 
matters proof sheer number instantiations modal provability pspace complete resolving scopes unification easy 
example variables instantiated single terms scope equations solved ordinary linear time unification 
provability pspace complete 
order logic number instantiations size proof depends greatly logical theory better bounds easily derived arguably cases interest 
prolog programmers analyze theories ensure efficient proof search reports application pspace complete deduction system intuitionistic logic proof size corresponds number interacting subtasks rarely problematic 
bounds proof size known theory general pspace completeness results add 
complexity results unifying scopes continue apply 
fact complexity scope unification pose significant obstacle modal logic practical applications alternatives unifying scopes arise axioms relating scopes modal logic attractive representation place 
tree constraints necessity noteworthy complexity resolving scopes unification established usual encodings hard problems string unification kapur narendran kapur narendran 
encodings repeat variables different contexts enforce constraints 
repetitions unavailable unique prefix property occurrences variables equations modal scopes cf 
wallen 
scope variable herbrand term ffl term occurrence equation term form unique prefix associated 
unique prefix property means equations arise proof search describe tree variables herbrand terms occur uniquely equating terms means identifying nodes terms designate 
fact unique prefix property may imposed ground proofs loss generality 
see observe obtain new ground proof ground proof substituting fresh scope ff occurrences scope variable fi preceded prefix 
unique prefix property reasoning annotation equations easier reasoning string equations general 
polynomial amount information specifies tree corresponding unifier annotation equations finite number general solutions guaranteed general case 
efficient algorithm determine set strings equal polynomial size substitution problem resolving scopes unification np 
problem hard 
theorem le problem determining proof containing derivation component np hard 
proof 
proceed reduction partition standard np complete problem defined follows cf 
garey johnson 
finite set containing elements positive integer size function mb 
determine partitioned disjoint sets sizes elements set sum proceed steps 
construct unification problem corresponds instance partition second describe modal sequent proof attempt gives rise unification problem 
unification problem 
element construct string form strings containing variables string containing constants 
construct string containing successive sequences variables followed constant variables distinct constants matthew stone typing context contain assigning modality governed introspection axiom oe 
unification problem set equations partition np complete strong sense means polynomial length problem specification problem remains np complete values bound size function bounded encoding depends represent size element string length 
bound polynomial length partition instance length unification problem polynomial length instance 
unification problem solution original partition problem solution 
suppose solution 
note variable bound string containing zero constant constants appear 
mb constants mb variables variable bound exactly constant constant appears exactly 
look contains constants contain constants adjacent bordered string constants 
needed partition set elements constants appear 
suppose partition problem solution 
naming elements construct unifier km ensures assign jth variable jth constant prefix string suffix length 
complete assign variables remainder empty string assign variables empty string remainder 
second step designing proof attempt gives rise problem 
assign distinct proposition letter element prove formula notation represents formula preceded nested operators similarly sequences operators 
introduces fresh variable introduces herbrand term unique head function constant 
proving formula ensures established scope denoted string include available assumption axiom available assumption scope represented operators introduce correct sequence variables distinct constants represented herbrand terms 
proving tree constraints necessity generates proof attempt goal scope matched assumption scope precisely unification problem considered 
logic variable proof systems reviewed section possible streamlined deduction procedures efficiency limited inherent ability modal theories express hard problems 
building proof requires choosing right modal operators exponential number possibilities cases choices intractable search problems 
support efficient sound complete inference modal specifications avoid expressive features give rise problems 
section identifies possibility classical negation problematic features modal logic 
absence possibility negation logics simple rule suffices determine order modal herbrand terms unifiers ff nest fi fi nest ff nests introduced proof 
theorem section 
restriction negation dire may shown section negation encoded scoped constant 
effect encoding transform certain alternatives unifying scopes alternative axiomatic links proof search remaining scope alternatives managed efficiently 
invariant terms hold 
formal argument section informally invariant combined effect properties proofs le 
terms representing scope formula grow application modal rules 
accordingly terms labeling scope formula appear label formula derivable 
property equational theory typing rules governing scope paths fail accounts additional axiomatic relationships scopes 
example adding ni axiom oe gives system necessary formula irrespective label applied scope whatsoever 
second appears proof variables introduced annotations precisely annotations change left rules herbrand terms introduced annotations annotations change right rules 
fails possibility added language 
left oe rule allows new variable positions transferred right sequent left 
left oe rule leaves positions left sequent 
contrast sequent rule classical negation simply moves formula right left 
conditions propagate variables occurrence variable equation appears left term 
conclude induction left term unified corresponding right term matthew stone ground string herbrand terms introduced earlier proof 
herbrand terms introduced right terms way newer herbrand term represent scope older nested 
constraint rules resolves search ambiguities investigated section 
theorem variable proofs section require easy corollaries simple structure le 
lemma weakening le derivation sequent obtain le derivation sequent adding formulas left hand side sequent likewise add additional lemma contraction le derivation sequent obtain le derivation sequent eliminating occurrence left likewise eliminate duplicate formulas lemma monotonicity le derivation sequent set containing elements list containing elements obtain derivation sequent contains elements elements contains elements elements proof 
straightforward induction structure derivations 
tree constraints necessity lemma simplicity le derivation sequent rule application different principal formula different side formulas lower rule application 
proof 
eliminate higher application identical lower contraction lemma observe side formulas lower application available preservation side formulas higher application duplicates 
list annotation equations resulting le proof attempt numbered increasing order 
recall equations generated axioms right branches proof precede left branches 
denote term coming right formula ith axiom coming left formula definition definition variable property variable introduced rule occurs term occurs variable theorem states key observation true derivations le regardless solution list equations associated 
theorem variable le derivation construct derivation sequent contains elements contains elements contains elements enjoys variable property 
proof 
consider proof attempt sequent say formula linked occurs formula prefix occurs linked say unlinked occurrence equation appears say gives rise induction structure le proof attempts shows proof attempt corresponding satisfying conditions statement lemma properties holds unlinked gives rise equation prefix matthew stone occur sequent sequent includes contains left words gives rise equation prefix prefix right equation term intuition conditions problematic formula starts unlinked fall base case start instance axiom rule construct axiom consists formulas linked axiom prefix 
axioms introduce variables axiom satisfies variable property 
equations typings unchanged 
unlinked formulas annotations prefixes appear left equation term 
correctly eliminated new derivation 
labels unlinked formulas appear left definition labels prefixes suppose claim true derivations height consider derivations height 
right rules alter annotations straightforward 
case apply induction hypothesis immediate subderivation observe principal side formulas available new derivation apply right rule new results 
induction hypothesis monotonicity lemma ensure resulting derivation meets needed conditions 
takes care cases 
oe 


left cases alter annotations somewhat involved 
rules oe 
consider case oe 
detail key illustration 
consider derivation oe oe oe oe 
oe multiset formulas appears rule application right subderivation rule application 
unlinked formulas derivation unlinked right subderivation 
apply induction hypothesis right subderivation eliminate find left uses unlinked formulas 
particular principal formula oe unlinked eliminate side formula subderivation find left formulas labeled prefix 
eliminate obtain new subderivation sequent form tree constraints necessity oe subformula appears 
monotonicity lemma ensures contains elements contains elements new subderivation satisfies needed conditions 
cases principal formula linked principal formula unlinked preserved right subderivation parallel structure 
apply induction hypothesis left subderivation observing applies unlinked formulas derivation labeled prefixes 
apply weakening lemma new derivation unlinked formulas appear new derivation 
subderivations agree multiset formulas survive 
derivations combined needed derivation oe oe oe oe 
oe annotations formulas weakened subderivation equations left deduction induction hypothesis annotations left subderivation 
unlinked formula occurs equations new subderivations left prefix applicable 
new subderivation equation term involving left term precede equation terms involving subderivation 
monotonicity lemma ensures contain elements cases remain 
suppose proof attempt ends 
ff iff ff iff observe unlinked formulas immediate subderivation exactly unlinked derivation 
consider unlinked formula derivation 
definition prefix 
way prefix ff ff 
ff unique herbrand function application associated occurrence formula 
labels preserved extended sequent rules monotonicity ff descendant lower occurrence ff simplicity lemma may assume loss generality 
induction hypothesis applies subderivation unlinked formulas 
applying 
result gives derivation needed properties ff iff ff iff matthew stone consider fresh scope variable different variables herbrand terms 
immediate subderivation unlinked prefix annotation formula 
apply induction hypothesis 
disappears subderivation suffices 
new subderivation construct derivation surviving unlinked formulas appears left equation induction hypothesis 
deduction variable property witnesses needed properties unlinked formulas 
variable property represents strong constraint equations result shows 
lemma substitution ordering suppose le proof attempt enjoys variable property suppose sequent substitution unifies strings equation respects typings 
variable appearing string herbrand terms contains herbrand term herbrand term term proof 
induction number equations base case equations show 
suppose proposition true gamma equations consider solution equations naturally solution gamma equations induction hypothesis variables introduced gamma equations bound earlier herbrand terms 
proposition variable asserts variables occur earlier 
string herbrand terms associate new variable contain new herbrand terms 
results establish main result theorem constant ordering proof le proof enjoys variable property satisfies substitution ordering property 
tree constraints necessity proof 
variable theorem construct satisfying variable property difficulty show obtaining smaller eliminated premises needed show respects types 
unifies scope equations imposed subset equations imposed unifies scope equations imposed substitution ordering lemma assigns strings herbrand terms scope variable appears equations 
herbrand term variable mentions introduced assigned identical types order variables eliminating typing premises eliminates typing requirements 
follows proof 
logics number proof strategies allow modal herbrand terms represented constants distinguished unification technically function applications free variables 
mating method multiplicities andrews bibel 
uniform proof search miller miller abstraction backward chaining applying left rules right rules applicable 
modal herbrand functions unified applications 
permuted lower proof collapsed needed uniform proof search right rules apply early possible 
techniques allow definition ordering herbrand constants advance solving unification equations definition 
equations corresponding proof attempt ordered arbitrary constants appearing equations 

occurrence term term 
occurrences term precedes total order constants 
substitution ordering property entails solution proper substring occur follows term equation appears term variable includes encoding negation general describe oe propositional constant governed inference original formula denote result recursively replacing subformulas oe subformulas oe oe 
return ground explicitly scoped modal sequent calculi 
lifting rules matthew stone straightforward presenting lifted versions distracting 
encoding describes correspondence proofs 
original rule instances match encoded rule instances oe oe oe 
oe right subproof instance new rule 
encoding puts rule instances correspondence patterns oe oe oe rule fact rule establish right establish addition right change provability sequent immediate subderivation 
new constant 
establish breaks invariant variable theorem 
scopes fact suffices introduce scoped constant governed rule rule clearly sound specialization general rule 
completeness rule consequence fact provable sequent proof modal rules extend scopes strings introduced lower 
circumstance establish left fact formula right 
generality lost scoped rule 
scoped rule variable theorem goes algorithms section may correctly applied 
presently formal proof correctness encoding proofs scoped constant 
want show magic involved translation 
original proof ambiguities scope constants nested 
translation eliminate ambiguities 
level proof search ambiguities rule inferring deduce 
accordance tree constraints necessity constant ordering theorem scope constants introduced whichever rule appear 
proof search sequent illustrates point kinds proof 
apply sequent rules establish ff establish fffi follows fffi fffi 
proof similar instantiate fi translation sequent oe oe oe oe oe oe consider proof search 
reduce sequent oe oe oe oe oe oe point may formula formula establish 
formula simplify oe oe oe ff ff formula oe ff fffi fffi negation possibility fffi remainder proof clear ff fffi fffi clear proof corresponds original proof 
likewise find translated proof 
note translating deduction problem introduced number new dead ends proof search corresponding early instantiation negation possibility 
quickly dispensed early possibilities establishing translation possibility negation obviously start need faster mechanisms identifying ruling new alternatives 
translation negation scoped rule pitfalls correct 
informally underlies correctness observation 
proofs need instantiate necessary formulas arbitrary accessible annotations 
current annotation serve witness possibility apply necessary formula 
need possibility instantiation incorrect 
property scopes particular logics 
note kd kd logics support consistency matthew stone instantiate necessary formulas new arbitrary accessible points 
informal observation falls formally follows 
suppose deduction explicitly scoped ground sequent system sequent consider rule application 
rule extends modal annotation principal formula string oe oe string modal variables introduced lower 
rules observation consequence sequent rules extend typing contexts declarations variables 
rules rules combine terms declared longer strings 
unique prefix property cf 
section assume oe fact annotates lower formula 
lower formulas preserved logical rules applied oe label formula sequent 
apply necessary formula apply scope consideration 
exploit observation lemma 
lemma encoding negation proof sequent ground explicitly scoped system corresponds proof scoped rule 
proof 
define translation recursively structure sequent annotation annotation prefix annotation specifies additional formulas add additional translated formulas add consider rules explicitly 
cases straightforward light cases 
ends applying 
principal formula subderivation oe oe observe system contraction rule preservation presence ensures annotation side formula ok ends applying principal formula subderivation oe oe 
oe assumption appears formula right subderivation instance scoped rule 
new left formulas appear subderivation translation applies 
tree constraints necessity ends applying subderivation oe oe ff ff oe ff oe oe oe ff oe oe oe oe 
oe oe final step follows assumption appears formula 
contraction replacing preservation root invocation satisfies needed invariant 
ends application 
subderivation oe oe oe oe oe 
oe oe oe oe oe oe key step establish oe occurs formula 
oe string introduced lower modal rules observation 
unique prefix property annotations oe annotation formula lower remains preservation 
constructing trees constraints constant ordering theorem established invariant eliminates source nondeterminism unification scope equations 
herbrand terms ff fi appear scope terms equal introduced proof appear unified term 
proofs scope equations may exponential number unifiers constant ordering theorem leaves open strings herbrand terms partitioned matching variables 
seen concrete example unification problem common proofs figures xy fffi 
order complete proofs need able assign possible prefixes fffi possibilities brute force search 
section develops constraint algorithm finds representative unifiers set equations efficiently allows additional equations added incrementally 
algorithm relies viewing set equations describing tree terms simple relationships nodes 
constraints operationalized simple local rules 
rules enforce constraints making smallest possible changes structure tree representation variables constants 
develop algorithm steps deferring technical complications essentials algorithm possible 
analyze basic version algorithm solves constraints single modal operator illustrate action matthew stone algorithm proofs figures 
complications come observed inclusion axioms may introduce hard problems variable ambiguities 
accordingly consider restrictions interaction axioms rule problematic cases observed provide constraint solver multimodal logics restrictions uses algorithm subroutine 
languages strategy recast unification problems terms constructing tree satisfy types constraints 
relation meaning ancestor tree representation corresponding constraint prefix string equation 

relation meaning ancestor 
relation meaning parent ancestor encoding depends assumption introduced section equality herbrand terms determined advance unification matrix uniform proof methods 
encoding consists way describe annotations substitutions way impose equalities annotations way manage domain constraints values order variables 
encoding described justified follows 
substitutions 
set images prefixes equations describes tree unique prefix property 
associate scope herbrand term logic variable mapped node tree derive substitution tree identify node tree canonical symbol reading symbols path tree root obtain value path node representing including encodes 
set constraints ensures herbrand terms mapped induced substitution 
impose constraints form earlier refers order herbrand terms proof 
total order constraints ensure pair herbrand terms associated distinct nodes tree 
constant ordering theorem allows impose constraint trees substitutions loss generality 
constant ordering theorem says impossible solution path prefix may assume symbol identifying node unique herbrand term exists 
ensures takes form xc 
ensure empty string add constraints 
describe node constant prefix find node representing add constraint meaning child meaning proper tree constraints necessity ancestor defined conjunction defined conjunction constraint unique node path node representing similar constraint manages values variables 
introduce node variable prefix find node representing add constraint appropriate logic meaning child represented conjunction final step stipulate arbitrary symbols correspond node tree herbrand term assigned 
fact constant ordering theorem ensures substitution solves equations includes arbitrary symbols 
step superfluous constraints identified far describe trees encodes possible solution substitutions values variables 
equations 
equations solve likewise realized simple constraints equate add constraint equivalent conjunction domain constraints 
modal constraints order unification represented associating node order variable term order herbrand term introduced scope recorded typing pair 
arguments introduced formula wider scope arguments associated prefixes 
just node corresponding 
order variable associated new node represents nested scope value defined 
typing pair represented constraint node corresponding 
constraint may represented equation access variables introduce new variable add equation variable unique occurrence resulting set equations 
proofs analyzing unification problems terms equations convenient adopt representation give domain constraints scope equations treatment 
impose correct domain constraints simply extend ordinary order unification algorithm order terms unified corresponding nodes constrained equal 
modal variables appear arguments order herbrand terms unified imposing equality constraints 
unifier computed domains definition unified terms refer correct nodes tree necessary constraints values variables respected 
problem unifying annotations equivalent problem solving set simple tree constraints 
efficient algorithm solve problem 
algorithm extends tree construction algorithm aho matthew stone handles 
algorithm node corresponding variable constant represented common ancestor distinct pair leaves denoted 
tree constructed grouping leaves sets constraints 
set disjoint sets constructed depth tree nodes set depth indicate leaves descendants node depth tree solves constraints 
process need consider levels partitions number leaves tree 
tree satisfying constraints exists tree satisfying constraints exists branching nodes constraints refer common ancestors branching nodes 
tree depth correspondingly discover need merge cells depth know constraints solution 
set constraints algorithm computes tree applying rules merging partitions 
initial 
leaves cell depth 


cell depth cell depth 

cell depth cell depth 


cell depth cell depth rules respect natural property lemma sanity cell depth proof length cell depth proof length 
proof 
induction length proof cell 
accordingly ends building internal node depth non unit cell making child internal node depth subset 
sanity lemma ensures node disjointness partitions ensures 
leaves attach greatest depth cell belong 
theorem correctness tree constructed satisfies constraint set warned aho opposite sense notation conflicts intuition tree represents collection paths root leaves ordered prefix relation 
tree constraints necessity proof 
aho consideration constraints 
example constraint partition associated rule fired putting partition parent 
descendant node constraint satisfied 
prove algorithm complete means lemma lemma descendants tree satisfying constraint set cell depth containing leaf 
node depth leaf descendant proof 
aho induction number steps constructing partitions 
example consider step causing cell depth induction hypothesis node depth dominates leaves cell depth 
nodes depth dominate cells show single node dominates parent node satisfies constraints descendant parent fact proof descendants lemma straightforwardly extended commitment property 
set trees satisfying constraint set initialize algorithm nodes cell depth relation holds tree assigns node depth greater run algorithm completion 
cell containing leaf depth tree node depth leaf descendant theorem completeness algorithm returns tree tree satisfies constraints 
proof 
procedure succeeds nodes partition depth case terminate algorithm report failure 
descendants lemma means solution nodes depth solution depth greater observed solution solution depth case fact solution 
algorithm performed time mn log number constraints number leaves tree 
cells represented union find algorithm hopcroft ullman cell stores set nodes set productions may triggered set merged set 
considering shorter list cells merged ensures log productions considered merges cells depth tree 
proof attempt contains rule applications means algorithm contributes time log constructing unifier matthew stone proof 
modal constants variables rule applications origin rule application 
likewise order variables unified imposing linear number equalities terms standard algorithms martelli montanari 
equalities scopes imposed axioms 
simple presentation algorithm requires adding constraints enforce distinctness constants 
running time brought log specialized representation distinctness constraints 
distinctness constraints corresponding constant pair cell need triggered step 
distinctness constraints duplicate effects 
identify relevant constraints ensure production firings needed keep constants distinct 
constant pair cell easily maintained inspection rules shows pair cell dominating leaf 
algorithm constraints corresponding additional equations added dynamically trees algorithm produces possible commitment 
consequence generalized descendants lemma 
commitments algorithm strings share prefix length 
members common cell depth tree know value share prefix length features tree example ancestor command relation prefixes may changed possible merging appropriate cells 
descendants lemma know nodes cell depth algorithm children node depth tree satisfies constraints 
means algorithm constructs unifier assigns common prefix length unifier assigns common prefix length example return simple example figures 
start equation xy fffi 
corresponds constraints names root real world ff ff ff ff fi fi fi fi algorithm computes tree shown 
constraint causes ff ff merge depth second constraint causes fi fi merge ff ff depth constraint merges cell depth 
point tree satisfies constraints solves needed equation 
note provisionally identified root keeping algorithm policy leaving endpoints path variables close root possible 
tree constraints necessity gamma gamma gamma gamma delta delta delta deltaa delta delta delta delta gamma gamma gamma gamma delta delta delta delta ff ff fi fi tree xy fffi 
recall impose equations finish proof ff fffi 
imposed adding additional constraints problem progress 
causes merges second merges ff depth third merges fi depths 
problematic interactions multimodal languages efficient multimodal deduction requires limitations introspection axioms combinations introduce ambiguities allow hard problems encoded unifications modal indices 
ambiguities associated problem determining types string 
result shows type interactions multimodal language remain quite simple 
lemma subset lemma oe derivable oe nonempty string containing symbols appear oe oe derivable 
proof 
induction height derivations typing judgments 
ax ver prove atomic strings involved 
derive oe oe apply induction hypothesis derivation oe show oe reapply show oe pi oe form derive oe symbol ff oe appears applying induction hypothesis appropriate subderivation may derive ff new proofs symbol oe may combined appropriate order successive applications pi 
problematic ambiguities multimodal deduction arise logical theories force modal path different types different formulas apply path 
characteristic example matthew stone consider interaction axioms oe yt oe yf oe oe oe axioms relate modalities yt yf specific modality specific modality 
theory provides illustration associated ambiguity yf oe yt oe prove yt oe introducing constant ff 
applying second clause introduces variable string uv match ff new goal proved scope 
clause introduces variables yz reach scope 
proof attempt gives rise equations uv ff yz equations governed typing context ff yt fi yf solutions fu ff ffl ff fig fu ffl ff fi fflg solutions variable bound exactly ff fi 
language problem ambiguities values long different values variable length way force particular resolution ambiguity impose equation specifies exactly value variable 
explicit equations included straightforwardly set constraints 
multimodal language general method forcing ambiguities resolved 
ff type yt fi type yf think encoding boolean variable value determined type string unified add additional conditions establishing multimodal language allow impose new equations test kind value 
interaction axioms allow tests impose disjunctive constraints values variables 
obtain result strategy describing possible assignments values variable types types impose disjunctive constraints values theorem np hard determine solution equations resulting proof attempt modal modalities interact unrestricted axioms 
tree constraints necessity proof 
reduction sat 
sat set disjunctions containing propositional literals letters negations letters 
problem determine assignment true false letters disjunction true 
proof theorem describe proof steps giving set equations corresponding sat instance proof search problem gives rise equations 
string equations construct string oe constrained possible values encode assignments truth values proposition letters 
disjunction associated string ffi unifies oe disjunction true assignment oe represents 
unification problem completed equating oe ffi particular encoding uses definitions modalities 
proposition letter modalities yt yf related axiom schemata described previous example 
additional modality inclusions modalities 
disjunct introduce add modality inclusion axioms modal types corresponding cases true 
instance ith disjunct get oe ut oe vf oe yt inclusions represent ffi string fresh variables governed typings string oe contains constants type ffi unifiable oe oe string containing constant type characterizes assignment specifying truth falsehood literal ith disjunction true 
construct single assignment string repeatedly invoke equations preceding example 
oe gamma assignment proposition letters extend assignment kth letter adding equations oe gamma ff fi typing context ff yt fi yf reasons described includes string oe gamma value followed ff fi value establishes assignment oe completes construction unification problem corresponds sat instance 
logical theory proof search gives rise equational unification problem 
theory refers propositions matthew stone variable proposition conjunct variable add oe consecutive variables add statements form oe yf oe yt oe variable successive replace conjunction disjunct add theory proof attempt gives rise unification problem observed 
successive proofs chain construct assignment outlined example need prove ultimate nested scope introduces equations ffi oe 
practical relevance result unclear axioms involved construction pathological 
example involving navy ge typical example useful modal representation exercises variety introspection axioms related modalities introducing kinds pathologies theorem exploits point justify carefully presently 
rarity problematic examples response baldoni natural provide complete solution trust programmers unwittingly hack hard problems manipulations 
algorithm exploits invariant longer holds domain problematic complete cases spoiling performance easy problems 
section adopts different approach gives broad syntactic conditions interaction axioms modalities axioms modalities ensure unification modal paths remains easy 
restrictions multimodal languages problems arise multimodal languages variable may unified constants different types different unifiers 
conditions variables take binary values constraint algorithm computes simplest unifier impossible 
theories needed practical applications syntactic characteristics eliminate ambiguities 
section explores characteristics 
typing conditions fact reduce length conditions representative typing planning representations 
second conditions satisfied relaxation representative typing logic programming representations 
typing length constraints observe simple useful syntactic restriction homogeneity multimodal language allows algorithm directly 
restriction tree constraints necessity starts distinguished negative modality theory specifying relations modal operators homogeneous just case contains inclusion oe modality sequent proved homogeneous just case formulas syntax formulas syntax definitions oe oe atomic formulas 
modality may appear positive positions may appear negative positions 
homogeneous modal herbrand terms proof represent arbitrary transitions 
homogeneous herbrand terms match variables modal type whatsoever 
different types modal operators may specified completely terms length sequences operators match 
possibilities introducing node variable prefix depending variable matches sequences variables length length 
demonstration variable matches sequence length applied pi repeat step match longer sequence 
represent variable find node representing add length length greater length length 
obtain sound complete specification unification problem incorporating order distinctness constraints section 
algorithm computes solution reports exists time log 
typing commitment different kind restriction enforce strict uniformity solutions allows unifier constructed local modifications prospective solution 
central notions involved restriction forced modalities separate modalities 
theory specifying relations modal operators say modality forced governed pi equivalently ffl derived 
extension say constants variables forced assigned forced modality type 
forced variables ones may insist binary values 
modality separate typing context terms derive cd significance separate modalities 
variables type type separate solution equation uv oe 
suppose proper prefix unifiers nonempty overlap subset lemma separate modalities distinguished disjoint modalities disjoint context term apply auxiliary notions 
modality simple separate simple modality looks modality matthew stone possible inclusions account 
second modality clean oe forced separate clean modality responsible ambiguities number identity forced constants string matches matches exactly 
goal proving modality unambiguous formula multiset formulas grammar oe oe fg oe separate disjoint fkg simple atomic formulas 
unambiguous modality interactions problematic general happen manipulations modalities particular logical theory question 
interactions desired sequent require modality clean unambiguous 
intuitively role definitions imposing restriction ensure forced herbrand terms vary unifiers 
turn ensures forced variables values unifiers ambiguous forced variables impossible 
consequence equations simplest solutions just terms lengths values variables terms constants appear values variables 
result fact stronger commitment result languages 
formally theorem agreement substitutions solve equations arising proof search interactions modality clean unambiguous 
forced herbrand term contains 
proof 
induction number equations 
base case equations herbrand terms prove 
suppose claim true gamma equations consider solutions equations 
apply induction hypothesis show agree forced herbrand terms gamma equation consider nth equation variable theorem form contain terms appear earlier sequence new variables sequence new herbrand terms 
induction hypothesis know forced herbrand terms appear likewise terms equation representing domain constraint done unique new variable new prefixes 
equations show contradiction herbrand term forced modality variable type tree constraints necessity appears suppose consider counterexample cases clean unambiguous 
suppose clean 
separate ffl forced 
means includes forced herbrand term precedes appear constant ordering theorem precede 
include separate contain earlier variable contain substitution know 
clean assumptions incoherent 
suppose unambiguous ensures followed string vz variable type separate sequence variables simple type disjoint 
sequence variables constrained sequences modalities permitted fig formulas alternative vz equation appear appears final 
final matches exactly herbrand term contain forced herbrand terms 
string variables vz compare vz vz observe forced forced herbrand term appear continuing find string herbrand terms begins constant appear appear afterward 
disjointness appear appear 
include constants 
absurd conclude counterexample exist 
theorem commitment set equations arising proof attempt possibility negation modality clean unambiguous 
solution solution appears appears solution proof 
proof relation unifiers holds appears appears relation founded unifier assigns values finite number variables values finite strings 
suffices show unifiers unifier show induction number equations show simultaneously contains exactly constants order dictated constant ordering theorem 
base case zero equations show 
suppose constructed gamma equations consider equation involves additional variables 
matthew stone construct value inductively follows lx lx minus lx gamma contains herbrand terms contains herbrand terms herbrand term appears lx gamma lx gamma herbrand term appears lx gamma lx gamma appear lx lx means precedes solution precedes solution conflict constant ordering theorem 
long nonempty subset lemma shows type empty forced 
forced value shares forced herbrand terms follows previous result 
appear 
intersection solves relaxation commitment multimodal languages section outlines relaxation algorithm computing modal matches repeatedly performs algorithm modifies result progress typechecking 
progress achieved straightforward procedure computes larger typed modal match particular equation 
arguments section show simplest global solution exists easily adapted show local improvements possible 
presenting algorithm computing small typed modal matches 
principle need match left term right term equation 
value match variables constants appear earlier equations determined fixes final string herbrand terms unaccounted 
need match final string new variables constants subject constraints values variables identified 
task string variables string herbrand terms base substitution problem find unifier variable typed short possible including prefix 
proof commitment theorem argument intersecting substitutions shows match exists match assigns fewer herbrand terms prefix describe match lm 
observe restricted variables match 
smaller prefix match construct smaller match string 
characterize lm follows 
match exists prefix prefix condition met longest string constants matching type gamma lm 
exists match 
lm tree constraints necessity substitution sends agrees gamma characterization operationalized directly dynamic programming algorithm maintains table lm values prefixes prefixes procedure combined algorithm construct unifying trees multimodal languages 
combination algorithm goes follows construct constraints input equations domain restrictions order variables algorithm propagate consequences constraints 
changes occur consider equations order sequence variables lies lower match constants bound perform merges cells bump variables match configuration recompute sequence variables match fail 
theorem correctness completeness algorithm produces tree solution input equations associated domain constraints solution produces 
proof 
tree algorithm produces corresponds correct unifier fact tree fixpoint algorithm means substitution solves satisfies domain constraints extracted tree 
algorithm terminates sequence variables matches path appropriate type substitution respects types variables constants 
correct unifier assigns prefix string shorter returns failure unifier 
establish somewhat stronger claim induction number equations far solved 
call relation conservative entails share common prefix length solution remarked section proof correctness algorithm adapted show initialized leaves nodes put common cells conservative relation run completion output relation includes input remains conservative 
conservative relation solves equations show new relation induced bumping sequence variables equation match match includes old remains conservative 
claim show induction input conservative relation algorithm returns conservative relation includes input represents solution equations 
equations show 
suppose claim true running gamma equations consider solving equations 
algorithm induction hypothesis solve gamma equations extend input relation conservatively 
bump variables kth equation dictated match claim extends relation conservatively 
continue process needed fixed matthew stone point reached discover need place variable deep tree 
relations remain conservative lose solutions 
variable bumped past depth tree reach fixed point gives solution extending input relation equations solution exists 
left claim including match keeps relation conservative 
consider arbitrary solution matched different string terms appear equations solved conservatively include constants order 
contain exactly forced constants appear agreement theorem 
know string match construct match small intersection commitment theorem 
match exists solution earlier equations allows match equation local progress complete 
compute match conclude smaller needed local progress conservative 
algorithm runs time worst case number variables constants analysis earlier general show multiple invocations require total time log 
algorithm requires iterations converge node bumped depth iteration nodes check 
kinds checks shall see different complexities 
case easy case input substitution identical output substitution 
checks perform fall class introduce changes 
case compute new different time easy check time hard check algorithm takes log 
compute time check takes observe successive variables originate formula occurrence 
maximum number successive variables needed matched equation bounded statically complexity axioms 
current purposes considered constant 
likewise possible interactions modalities specified advance computed advance may assume relationship type constant type variable computed constant time 
string constants matched worst case length 
principle bounds input computing requires filling table size kn entry may require checking earlier entries 

hand table filled demand input match typed access compute entries table 
easy checks require time 
conclude algorithm worst case complexity 
tree constraints necessity applications previous research efficient deduction modal logic devised explicitly scoped calculus describing modal provability 
calculus nice formal properties checking axioms link proof represents intractable problem 
identified new invariant deduction problems modal logic shown invariant leads fast algorithms correctly applying axioms modal proofs 
presentations modal logic terms scope equations provide theoretical tool analyzing proofs proof search new ways practical tool implementing fast deduction 
adding scope logical representations important goal developed tractable solutions 
algorithms described apply variety domains call natural means describing modular inference time agents 
conclude briefly sketch role algorithms sections developing practical applications deduction 
automatic synthesis functional programs intuitionistic theorem proving related problem automated synthesis functional programs represents natural domain apply constraint algorithm section 
problem application relies observations 
functional programs characterized terms types inputs types outputs 
types turn represented formulas logical language formula represents type functions objects type objects type correspondence propositions types known curry howard time identifies programs proofs 
example application function argument recorded inference type function type argument type result 
parallel underlies number systems synthesis functional programs martin constable 
type denotes implication intuitionistic logic assumption derive scope discipline fact characterized correspondence intuitionistic formulas proofs formulas proofs modal logic odel sikorski 
correspondence achieved translating intuitionistic formula formula follows atomic oe xp xp matthew stone correspondence programs proofs holds explicitly scoped proof system semantic translation investigated stone 
explicitly scoped deduction basic log constraint algorithm described section derive proofs programs 
constraint reasoning branching time constraint technique proposed section applies variety problems temporal causal reasoning including typical ways deriving particular predictions basis causal generalizations 
constraints represent ordering intervals events known technique ai sacerdoti allen dean boddy focused linear models time events ultimately temporally ordered 
ai theorists preferred terms branching models time situation calculus mccarthy hayes 
algorithm described section taken description range cases efficient constraint methods check consistency conjunctions ordering constraints points branching time causal reasoning 
ontology causal theories consists homogeneous theory cf 
section involving pair modal operators fl 
negative operator fl fl represents true event occurs 
constraints operator time branch 
persistence effects captured modal operator represents holds continue hold notice 
described axioms oe oe oe flp 
predicate ha gives way talk occurrence actions ha true event include action characterized setup allows represent prediction modal deduction causal theory world expressed terms fl series statements describing events formula ensuring prediction holds series events 
deductions encode homogeneous problem long needed positive positions allow proposition established time propagated forward time single step instantiation time proposition needed 
typical case planning prediction explanation ai 
simplicity deductive framework results section solve modal equations deductions efficiently time log 
fact proof theory simple modal languages continue leveraged interesting way presence defeasible inertia stone 
defeasible argumentation pollock dung permits proofs retain simple form omits disjunctive negative conditions needed handle inertia classical logic schubert reiter 
tree constraints necessity executing specifications agents return example section executing modal specifications agents 
specification described representative broad useful class formal theories multimodal constraint algorithm section applies 
class specify set modalities interacting set modalities interacting interactions linking kinds modalities 
call specifications 
recall section identified restrictions multimodal reasoning modality required clean unambiguous technical definition characterizing modal interactions sequent proved 
technical language section modalities clean simple modalities clean inclusions forced modalities 
specifications restrictions interactions formulas needed ensure scope equations easy solve techniques section 
specifications describe key reasoning problems needed specifications navy ge specification section 
navy ge example family consists operators ge describing ge knowledge navy describing navy knowledge describing organizations shared knowledge 
family consists operators list describing ge list spec describing navy specification acct describing accounts general 
family allows efficient specifications just agents knowledge common knowledge 
common knowledge crucial component coordination agreement fagin 
inclusion axioms model shared knowledge ge navy example section modality example subjected inclusion axioms oe navy oe ge inclusions allow nesting navy ge operators derived single operator 
fact describes common knowledge ge navy 
family operators provides complementary tool structure specifications 
giordano martelli baldoni modal operators cases provide description modularity logic programs 
list spec acct modalities navy ge example modal operators allow concepts described distinct list price spec price compactly describing bodies knowledge apply uniformly concepts 
fact schild shows similar modal operators provide general encoding terminological knowledge 
constraint algorithms described section specifications combining features designed prolog programs offer efficient execution declarative semantics 
logic programs restricted syntax restricted proof procedure ensures problematic scope matthew stone arise 
scope ambiguities modal logic programs define search problems nondeterminism depends solely number alternative clauses establish goal just prolog programs 
stone extends general framework miller develop modal logic programming language dialup partial order mechanisms described section 
dialup provides concrete environment explore algorithms described efficient specifications agents possible 
aho sagiv szymanski ullman 

inferring tree lowest common ancestors application optimization relational expressions 
siam journal computation 
allen 

maintaining knowledge temporal intervals 
communications acm 
andrews 

theorem proving general 
journal association computing machinery 


modal theorem proving equational viewpoint 
journal logic computation 
baldoni giordano martelli 

multimodal logic define modules logic programming 
ilps pages 
ballim wilks 

belief ascription metaphor intensional identification 
cognitive science 
bibel 

automated theorem proving 
vieweg braunschweig 
bibel 

deduction automated logic 
academic press london 
boyer moore 

sharing structure theorem proving programs 
meltzer michie editors machine intelligence pages 
edinburgh university press 
chellas 

modal logic 
cambridge university press cambridge 
constable 

implementing mathematics nuprl proof development system 
prentice hall englewood cliffs dean boddy 

reasoning partially ordered events 
artificial intelligence 
tree constraints necessity 

multimodal logic programming equational order sorted logic 
theoretical computer science 
dung 

acceptability arguments fundamental role reasoning logic programming 
ijcai pages 
fagin halpern moses vardi 

reasoning knowledge 
mit press cambridge ma 
fitting 

tableau methods proof modal logics 
notre dame journal formal logic 
fitting 

proof methods modal intuitionistic logics volume synthese library 
reidel dordrecht 
frisch scherl 

general framework modal deduction 
proceedings kr pages 
morgan kaufmann 
gallier 

logic computer science foundations automated theorem proving 
harper row new york 
garey johnson 

computers intractability guide theory np completeness 
freeman san francisco 
giordano martelli 

structuring logic programs modal approach 
journal logic programming 
odel 

eine interpretation des uls 
feferman editor kurt godel collected works volume pages 
oxford 
troelstra 
halpern moses 

guide modal logics knowledge belief preliminary draft 
th international joint conference artificial intelligence pages 
hintikka 

knowledge belief 
cornell university press 
hopcroft ullman 

set merging algorithms 
siam journal computation 
howard 

formulae types notion construction 
curry essays combinatory logic lambda calculus formalism pages 
academic press new york 
jackson reichgelt 

general proof method order modal logic 
proceedings ijcai pages 
matthew stone 

efficient program synthesis computational models 
journal logic programming 
kapur narendran 

np completeness set unification matching problems 
cade 
kapur narendran 

complexity unification problems associative commutative operators 
journal automated reasoning 
kleene 

permutation inferences gentzen calculi lk lj 
papers predicate calculus pages 
american mathematical society providence ri 
kripke 

semantical analysis modal logic 
normal modal propositional calculi 
zeitschrift fur mathematische logik und grundlagen der mathematik 
ladner 

computational complexity provability systems modal propositional logic 
siam journal computing 


epistemic logic 
acta philosophica 
lincoln shankar 

proof search order linear logic cut free sequent calculi 
lics pages 


eine der logik der 
nagoya mathematical journal 
martelli montanari 

efficient unification algorithm 
acm transactions programming languages systems 
martin 

constructive mathematics computer programming 
cohen editor logic methodology philosophy science vi pages amsterdam 
north holland 
mccarthy buva 

formalizing context expanded notes 
technical report stan cs tn stanford university 
mccarthy hayes 

philosophical problems standpoint artificial intelligence 
meltzer michie editors machine intelligence volume pages 
edinburgh university press edinburgh 
tree constraints necessity miller 

multiple meta logic 
abramsky editor proceedings international symposium logics computer science pages 
miller nadathur pfenning scedrov 

uniform proofs foundation logic programming 
annals pure applied logic 
mints 

short modal logic 
number csli lecture notes 
csli 
moore 

formal theory knowledge action 
hobbs moore editors formal theories commonsense world pages 
ablex norwood nj 
morgenstern 

knowledge preconditions actions plans 
proceedings th international joint conference artificial intelligence pages milan italy 
ohlbach 

semantics translation methods modal logics 
journal logic computation 
ohlbach 

optimized translation multi modal logic predicate logic 
voronkov editor logic programming automated reasoning volume lncs pages 
springer berlin 
otten kreitz 

string unification unifying prefixes nonclassical proof methods 
tableaux volume lnai pages 
springer 
plotkin 

building equational theories 
machine intelligence 
pollock 

reason defeasibly 
artificial intelligence 
sikorski 

algebraic treatment notion satisfiability 
fundamenta mathematicae 
reiter 

frame problem situation calculus simple solution completeness result goal regression 
lifschitz editor artificial intelligence mathematical theory computation pages 
academic press 
sacerdoti 

nonlinear nature plans 
proceedings ijcai pages 
schild 

correspondence theory terminological logics preliminary report 
ijcai pages 
matthew stone schmidt 

resolution decision procedure propositional modal logics 

schubert 

monotonic solution frame problem situation calculus efficient method worlds fully specified actions 
kyburg loui carlson editors knowledge representation defeasible reasoning pages 
kluwer boston 
schulz 

word unification transformation generalized equations 
journal automated reasoning 


order logic volume ergebnisse der mathematik und 
springer verlag berlin 


generalization intuitionistic modal logics 
leblanc editor truth syntax modality pages 
northholland amsterdam 
stone 

representing scope intuitionistic deductions 
submitted university pennsylvania 
stone 

partial order reasoning nonmonotonic theory action 
aaai workshop theories action providence ri 
stone 

reasoning natural language generation fast modal logic programming 
submitted university pennsylvania 
van benthem 

modal logic classical logic 
bibliopolis 
wallen 

automated proof search non classical logics efficient matrix proof methods modal intuitionistic logics 
mit press cambridge 
