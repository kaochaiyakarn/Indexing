interprocedural aliasing presence pointers william alexander landi dissertation submitted graduate school new brunswick rutgers state university new jersey partial fulfillment requirements degree doctor philosophy graduate program computer science written direction barbara gershon ryder approved new brunswick new jersey january fl william alexander landi rights reserved dissertation interprocedural aliasing presence pointers william alexander landi ph dissertation director barbara gershon ryder alias occurs program point execution names exist location 
investigated theoretical difficulty determining aliases program developed approximation algorithm solving aliases languages explored precision closeness approximate solution actual solution time behavior algorithm 
myers mye explored theoretical difficulty solving flow sensitive interprocedural data flow problems presence aliasing 
claims difficulty determining aliases 
isolate various programming language mechanisms create aliases 
complexity alias problem determining aliases program induced mechanism combinations considered separately categorized np hard complement np hard polynomial time 
proved levels indirection regardless alias mechanisms aliasing np hard 
level indirection possible alias problem addition show alias problem presence mechanisms space complete 
language allows general purpose pointers problem determining aliases occur program execution np hard 
algorithm safely approximates interprocedural may alias fail report ii alias occurs presence pointers 
able show relative definition precision algorithm precise possible worst case 
pinpoint sources imprecision algorithm empirically bound precision 
algorithm implemented prototype analysis tool programs preliminary empirical investigation algorithm speed precision 
iii barbara ryder community providing environment doing productive research 
siemens corporate research pande michael michael wagner providing front implementation 
pande helping various parts thesis 
parents family friends support encouragement played cards helping keep sane 
iv table contents ii iv list tables list figures xi 

problem representation 
interprocedural control flow graph 
types 
object names 
aliases 
terminology 
related 
theoretical classification 
algorithms finding aliases programs pointers 
conflict dependence analysis 
classification alias problems 
formals 
single level pointers 
intraprocedural may alias 
intraprocedural alias 
interprocedural may alias computing conditional may alias information assuming local variables modeling effects parameter bindings computing conditional may alias information return node factoring local variables computing interprocedural may alias conditional may alias 
interprocedural alias conditional alias computing interprocedural alias conditional alias 
non pointer formals single level pointers 
multiple level pointers 
may alias 
alias 
formals single level pointers 
interprocedural may alias 
interprocedural alias 
structures containing single level pointers 
may alias 
alias 
alias sets associated program paths 
single level pointers 
formals 
space hard alias problems 
safe approximate algorithm interprocedural may alias 
may hold relation 
conditional may alias definition 
representation vi 
alias consequences 
modeling parameter bindings computing bind call computing bind call hx yi 
computing may hold 
aliases introduced assignment node 
aliases introduced call node 
alias call implies call assumed alias possible alias 
alias exit implies exit assumed alias possible alias 
alias implies node assumed alias possible alias 
may alias 
theoretical empirical results 
theoretical precision 
prototype 
optimizations 
empirical comparison weihl algorithm 
number aliases 
time 
may alias solution 
empirically measured solution size 
measurement empirical precision 
may alias solution size vs conditional may alias size 
algorithm time performance 
theoretical issues 


summary thesis 
vii appendix dictionary functions appendix intraprocedural aliasing presence single level pointers 
building sppag 
sppag algorithm polynomial time precise may alias 
sppag algorithm polynomial time precise alias appendix interprocedural aliasing presence single level pointers 
back bind 
definition 
proof correctness 
computable constant time 
bind 
definition 
proof correctness 
computable constant time 
precise polynomial time algorithm computing interprocedural may alias sets presence single level pointers 
terminology 
building pointer alias graph pag 
algorithm computing precise may alias sets presence single level pointers 
proof lemma 
proof theorem 
precise polynomial time algorithm computing interprocedural alias sets presence single level pointers 
lattice conditional alias sets definitions 
algorithm computing precise conditional alias sets viii 
algorithm computing precise alias sets presence single level pointers 
conditional alias sets relationships cond alias pair node values 
proof correctness precise conditional alias algorithm 
proof theorem 
replacing formals pointers appendix interprocedural may alias approximate algorithm pseudo code 
approximate non visible 
alias call implies 
alias exit implies 
alias implies appendix safe approximate algorithm 
types approximation vita ix list tables 
alias problem decomposition classification 
number aliases comparison weihl 
time comparison weihl 
number aliases time comparison weihl 
size may alias solution 
size may alias solution 
precision may alias solution 
size may alias solution vs size may hold 
number assumptions alias 
number assumptions alias 
timings algorithm 
timings algorithm 
may hold sec list figures 
program icfg 
syntax directed definition object names program 
examples apply trans 
bad case weihl algorithm 
polynomial time algorithm intraprocedural may alias level pointers 
polynomial time algorithm intraprocedural alias level pointers 
holds return node local variables 
calls affecting alias pairs involving non visible object names 
holds icfg node assumed alias possible alias program 
polytime algorithm interprocedural may alias presence single level pointers 
may alias icfg node program 
conditional alias example 
lattice possible values cond alias pair node 
holds icfg node possible alias program 
polynomial time algorithm interprocedural alias presence single level pointers 
alias icfg node program 
sat solution iff false noi intraprocedural may alias 
sat solution iff false noi interprocedural may alias 
sat solution iff false noi interprocedural may alias xi 
sat solution iff false noi intraprocedural may alias 
sat solution iff fh truei ng intraprocedural may set alias 
sat solution iff truei ng interprocedural may set alias 
sat solution iff truei ng interprocedural may set alias 
reduction alias problem 
justification code state edges 
computing consequences alias 
calls affecting alias pairs involving non visible object names 
computing bind call 
support functions computing bind call hx yi 
computing bind call hx yi 
computing may hold 
aliases introduced assignment node 
aliases introduced call node 
holds relation return nodes 
creation alias non visible object names 
may hold representation interesting stores 
implication known may hold exit node 
action may hold node assumed alias hy zi successor succ node prefix deref 
action may hold node assumed alias hp vi successor succ node 
program yields imprecise results 
description programs empirical study xii chapter programming language environments contain tools improve quality efficiency understandability usability code 
tools optimizers debuggers testers verifiers data flow analysis hec statically extract semantic information programs increase efficacy 
alias information important semantic information greatly affect quality optimized code utility program languages tools 
alias occurs program point program execution names exist location 
aliases particular name program point names refer memory location path execution path traverses procedure solving interprocedural may alias problem 
calculation aliases fortran understood ban coo ck mye show general pointers added language construct cause problem computing aliases np hard situation approximation algorithms exist 
aliases complicate data flow analysis problems absence alias information prevent optimizations 
example consider example optimize code code motion asu aliased versions code aliased original version optimized version alias information optimizations done 
originally interested problem working ismm incremental data flow analyzer solves modification side effect problem mod ban ban bur ck ck programs designed help programmers maintain large evolving software systems 
mod interprocedural data flow problem meaning determine semantic information programs procedure boundaries mod determining variables program value change modified execution statement procedure invocation procedure 
mod problem traditionally decomposed simpler problems combined yield mod solution 
ismm incremental implementation standard fortran decomposition mod problem ck ck bur 
difference fortran turned major theoretical difficulty 
major components mod decomposition determining aliases 
mod solution obtained ignoring alias effects afterward factoring obtain full solution 
unfortunately alias problem little common fortran alias problem decomposition useful fortran dynamic method creating aliases formals 
solving aliases presence pointers presents additional complications 
formals aliases hold invocation procedure hold entire execution called procedure pointers case aliases affected pointer assignments called procedure 
addition formals call procedure affect aliases calling procedure pointers longer true 
facts suggest existing fortran alias algorithms extensible handle pointers 
existing alias algorithms originally tried extant alias technique wei finding aliases pointers combined fortran decomposition solving mod 
information resulted solution safely claimed practical purposes statement modify variable 
result inappropriate decomposition mod fact extant aliasing technique wei approximate see chapter 
mod data flow solutions extremely useful especially optimization decided derive better algorithm determining aliases reformulate mod contrast intraprocedural data flow problem hec concerns semantic information procedures deal procedure calls 
paradigm 
looking approaches mod rest thesis devoted problem solving aliases 
theoretical complexity results starting point examined theoretical difficulty vs np hard various aspects alias problem 
results show aspects alias problems provably hard need approximated 
clear understanding alias problem difficult lends insight information lost approximation loss information necessary 
understanding easier alias problems handled precisely useful framework approximations harder alias problems 
chapter theoretical complexity solving intraprocedural may alias intraprocedural alias interprocedural may alias interprocedural alias problems presence programming language mechanisms create aliases 
mechanisms considered combination formal parameters single level pointers multiple level pointers pointers values pointers structures containing single level pointers 
informally results show multiple levels indirection lead np hard np hard alias problems aliases introduced single level indirection polynomial time 
alias approximation algorithm chapter detailed description algorithm finding safe approximation interprocedural may alias presence general pointers call value parameter passing 
efficiency algorithm demand driven calculate information aliases hold path maintain data structures quickly accessing certain kinds information alias solution 
safety algorithm account various sources approximation alias occurs path 
main ideas algorithm highlighted text interested reader find pseudo code algorithm figures appendices 
algorithm program point specific precise weihl algorithm wei 
currently prototype implementation analyzing programs 
precision efficiency approximate algorithm chapter give theoretical bounds precision algorithm approximation algorithm 
show definition precision algorithm precise worst case 
able pinpoint sources approximation empirically bound imprecision algorithm 
interestingly sources intraprocedural 
say interprocedural approximation possibly erroneous interprocedural alias included safety depends possibly erroneous intraprocedural alias included safety chapter discuss implementation algorithm chapter give preliminary empirical results conclusive encouraging 
remainder thesis contains supporting infrastructure 
chapter chapter contains 
chapter contains representation alias problem necessary definitions 
chapter overviews related areas 
chapter summarizes contents thesis gives directions research 
appendix glossary functions thesis remainder appendices formal proofs various theorems lemmas 
contributions main contributions thesis ffl better understanding difficulty detecting aliases 
particular realization multiple levels indirection alias problem difficult chapter 
ffl presentation precise solution interprocedural flow sensitive problem interprocedural may alias presence single level pointers chapter 
algorithm prl 
ffl formulation conditional may alias problem chapter feel useful may alias data flow analysis presence precision measure erroneous information contained solution 
possible intraprocedural alias precise solution interprocedural alias 
standard assumptions data flow analysis pointers 
prl indicates case reaching definitions currently investigating suitability conditional may alias information mod 
ffl development approximation algorithm interprocedural may alias presence pointers chapter provably precise possible worst case chapter 
empirically compared approximate algorithm weihl algorithm wei 
surprisingly algorithm slower produced precise solution chapter 
ffl isolation sources approximation algorithm lemma 
allows bound empirically imprecision algorithm chapter importantly gain better understanding algorithms introduce imprecision 
chapter problem representation interprocedural control flow graph dealing languages imperative sophisticated pointer usage data structures explicit function calls function variables 
allow arrays simply treat aggregates 
represent programs interprocedural control flow graphs originally lr 
icfg intuitively union control flow graphs cfgs hec procedure calls connected procedures invoke 
formally icfg triple ae ae entry node main contains node statement program entry exit node procedure call return node call site contains edges cfg procedure slight modification edges involving call sites 
icfg call site split call return node 
intraprocedural edge call node represents execution flow call site intraprocedural edge return node represents flow call site 
addition intraprocedural edges interprocedural edges added call site call node entry node invoked procedure exit node procedure return node call site 
see example icfg 
types object location store information example variables 
objects types need perform handful operations types 
node cfg source code statement 
int void int main int null ffl ffi fi fl entry main ffl ffi fi fl null ffl ffi fi fl call ffl ffi fi fl return ffl ffi fi fl ffl ffi fi fl call ffl ffi fi fl return ffl ffi fi fl exit main ffl ffi fi fl entry ffl ffi fi fl ffl ffi fi fl exit oe ak program icfg straightforward listed avoid confusion address type type returns type objects point type 
deref type true iff type legally dereferenced casting 
deref type type type dereferenced deref type returns type objects type may point 
field type type field type structure field field type returns type field 
field field type true iff type structure type field legal field type 
struct type true iff type structure 
object names objects locations store information terminating programs containing recursive data structures arbitrarily potentially addressable objects 
example program linked list llist llist possible names distinct run time objects 
practical alias algorithm represent set possible objects alias relationships objects small finite data structure 
solution roughly analogous defined jones muchnick jm 
naive schemes developed cwz hn hpr lh examine suitability purposes 
object names provide ways refer objects program 
object name variable possibly empty sequence dereferences field accesses 
definition asu object names 
prohibited casting interested object names type error 
recursively defined data structures example linked lists number object names type error infinite 
deal infinite number object names finite amount time rule production semantic rules object deref object type object object type deref type object type object type error object field field object type object field object type field type object type field object type error object var object type type var field declared field structure program 
var variable declared program 
syntax directed definition object names program limit constant number applications rule 
restrict number object names type error generated finite number number vars max number fields struct 
raises issue deal object names dereferences 
simplistically considering object name dereferences represented object name obtained ignoring dereferences yielding unique limited name 
represented 
borrow jones muchnick jm terminology call limiting limit dynamic structures limit object names processes analogous 
unfortunately despite interested aliases object names construct object name affect alias information address operator example 
define class object name object name object name 
state algorithm concisely accurately pseudo code need non trivial functions class object name prefix object name object name returns true iff object name transformed object name possibly empty sequence dereferences field accesses applications rule rule 
prefix deref object name object name returns true iff object name transformed object name sequence dereferences field accesses applications rule rule dereference 
apply trans object name object name object name object name object name type prefix object name object name true 
function applies object name sequence dereferences field accesses necessary transform object name object name returns true iff dereference occurs sequence 
examples apply trans 
fairly straightforward functions amp object name object name object name object name start error 
deref object name removes object name starts returns object name 
corresponds rule 
field access object name field name object name field name object name start error 
corresponds rule 
object type object name type data stored objects object name object name start 
name object name name address type name 
limited object name true iff object type object name dereferenced object name contains dereferences object name start address operator 
simple object name variable object name just variable rule 
value type attribute object name obtained 
initial final return object name object name object name object name value true true data data false data data false data data true true true examples apply trans aliases alias occurs object names refer location point program execution 
lr represent aliases unordered pairs object names example hv pi 
order unimportant alias relation symmetric 
limited object names order represent aliases safely assume alias ha limited component represents alias ha alias ha transformed sequence dereferences field accesses prefix true 
alias ha limited components represents aliases ha prefix prefix alias ha bi represents fact refer object 
objects types allowing casting type object type limiting necessarily true 
say alias program point hx yi type int type int 
limiting alias represented hx yi 
function alias type determine type object represented alias 
alias type alias type object referred object names alias 
function correctly accounts limiting 
example alias type hx yi int example 
terminology definitions program point program point refer part program represented icfg node 
realizable path realizable iff path icfg procedure path returns returns call site invoked 
definition intraprocedural paths vacuously realizable 
holds alias ha bi holds realizable path aen iff refer location execution program point execution sequence defined path occurs 
aliases symmetric ha bi holds path iff hb ai holds path distinguish ha bi hb ai 
interprocedural may alias precise solution interprocedural may alias ha bi realizable path aen icfg ha bi 
intraprocedural may alias precise solution intraprocedural may alias ha bi path aen cfg ha bi 
interprocedural alias precise solution interprocedural alias ha bi realizable paths aen icfg ha bi 
intraprocedural alias precise solution intraprocedural alias ha bi paths aen cfg ha bi 
complement interprocedural alias precise solution complement interprocedural alias ha bi realizable path aen icfg ha bi 
cfg intraprocedural case 
usual data flow definition precise means precise symbolic execution 
words assuming paths program executable ban 
complement intraprocedural alias precise solution complement intraprocedural alias ha bi path aen cfg ha bi 
visible call site object name example calling procedure visible called procedure iff called procedure scope object name run time object name refers object calling called procedure 
means local variable procedure recursive call visible call execution time different instantiation 
chapter related main areas related topics thesis 
deals theoretical classification various portions alias problem np hard second concerns alias algorithms presence pointers 
third conflict dependence detection identical alias analysis directly addressed thesis similar warrant comment 
theoretical classification myers mye proves certain data flow problems presence aliases np complete 
considers fortran aliasing aliasing result passing call parameters classify alias problem 
np hardness proofs variations myers proof 
larus lar modified myers proof prove intraprocedural aliasing presence structures np hard 
owing common origin larus np hardness proofs similar 
algorithms developed solve aliasing presence callby formals aliasing fortran 
myers mye presents algorithm finding alias sets precise traditional assumptions static analysis ban 
alias set myers solution program point path aliases represented exist myers solution set alias sets size exponential number variables program 
avoid problem algorithms including algorithm compute alias pairs alias sets number alias pairs polynomial number variables program 
precise polynomial time algorithms finding aliases fortran programs ban bur coo ck 
presents incremental algorithm finding aliases presence call parameters 
noteworthy uses mechanism similar assumed alias chapter assuming alias entry procedure assume alias head node strongly connected component call graph 
algorithms finding aliases programs pointers algorithms finding aliases presence pointers developed weihl wei wei 
weihl finds program aliases aliases path program program point aliases aliases path specific program point approximates object names limiting 
solution fairly simple 
possible type pointer assignment adds aliases introduced assignment set affect 
example statement add pair qi affect 
done statement program computes alias solution affect ffi affect unfortunately weihl algorithm imprecise 
fact simple program straight line code see aliases number variables program weihl reports aliases 
solved modification side effect problem programs weihl algorithm determine aliases 
analysis generally reported variables modified 
weihl algorithm give information sufficient quality useful problem 
empirical observations size alias solutions produced weihl algorithm chapter 
chow cr algorithm finding aliases presence single level pointers 
approach sense generalization weihl approach computing program point aliases program aliases 
weihl start making pass statement program adding direct affects initial alias solution 
example qi added alias solution program point 
define alias solution node related alias solution immediate predecessors 
int temp int main temp temp temp temp 
temp temp program non reflexive alias pairs fh temp number variables program 
weihl reports set possible alias pairs non reflexive alias pairs 
bad case weihl algorithm solution simply maximum fixed point rules 
chow algorithm suffers treat interprocedural alias intraprocedural problem 
analysis insure procedure returns control passes call site invoked 
addition handle local variables incorrectly 
asu presents intraprocedural algorithm finding aliases presence single level pointers similar intraprocedural portion chow algorithm allow arrays treated aggregates 
similar intraprocedural algorithm chapter 
coutant cou extended weihl different direction 
kept restriction finding program aliases relaxed restriction limiting added additional language constructs example structures arrays 
doesn explicitly mention recursive data structures doesn appear handle doing type limiting arbitrary coutant algorithm follows general pattern weihl computes initial information statement statement pass program transitive closure 
addition extensions weihl coutant considers pragmas user provided information aliasing improve precision aliasing algorithm 
benjamin cooper coo developed algorithm uses explicit path information form alias histories insure interprocedural paths procedure returns call site invoked 
alias histories mye consist call site execution stack set aliases hold path entry procedure 
bears resemblance assumed alias chapter maintain top execution stack restrict alias sets entry size zero 
cooper method time space infeasible restricting size alias sets 
deu npd detecting aliases higher order programming languages languages functions treated data type 
npd considers programs single level dereferences added difficulty tracking binding functions names 
interprocedurally solve alias problem procedure initial information induced call chain fail take advantage assumed alias pairs initial alias sets 
problem addressed deu order magnitude complication general aliasing 
allows closures partially evaluated functions continuations storing runtime environment reuse 
deu uses formal interpretation cc difficult read 
conflict dependence analysis related area research done compiling community dependence analysis conflict detection programs recursive structures cwz ha hn hpr jm lh 
particularly important parallelizing programs 
conflict lh occurs statements statement writes location accesses reads writes location loc preventing possibility statements executed parallel 
data dependence exists statements iff conflict execution path program point loc written 
types data dependences pw wol flow dependences anti dependences output dependences 
type dependence determined direction path endpoint write loc 
algorithms detecting dependences conflicts need information alias calculation 
aliasing need concern relationship object names program point 
dependence analysis general relationship object names different program points maintained 
fundamental difference alias pair information sufficient parallelizing compilers target application dependence analysis community detailed information data structure just isolated parts recursion requires fixed point calculation data structure needed parallelize loops 
dependence analysis alias analysis different goals restrictions placed 
concentrate papers dependence analysis community deal recursive data structures 
jones muchnick jm analyzed track dynamic lisp structures research area way ideas jm 
restrict intraprocedural domain graphs represent structure dynamic memory 
nodes graph represent locations memory directed edges represents fact location refers 
program point associated set graphs 
associated statement means path correctly represents dynamic store 
unfortunately infinite number possible graphs 
introduce notion limiting allows nodes dereferences away labeled node 
summary nodes represent portions graph collapsed meet requirements limiting 
limiting effectively reduces number graphs finite number 
borrowed notion algorithm 
jm jones muchnick show interprocedural data flow analysis presence recursive structures 
interpretation cc 
represent possible execution states program triples hq ti ffl program point ffl abstraction program store ffl abstraction runtime stack general framework particular abstraction program store runtime stack 
solution framework interpretation 
high level alias algorithm viewed model abstracting program store set limited alias pairs abstracting runtime stack single assumed alias pair alias assumption 
larus hilfinger lh developed algorithm conflict detection jm 
alias graph represent dynamic store 
extended graphs jm alias graphs adding unique labels node making easy detect conflicts 
statements conflict writes reads writes node respective alias graphs label 
conflict detection easy labeling processes trivial 
lh horwitz pfeiffer reps hpr interested intraprocedural detection dependencies 
augmenting jm graphs unique labels added lh node labeled allocation site assigned storage represented node 
allows easy dependence detection 
hpr interpretation framework presenting solution 
extended cc adding fourth semantics instrumented semantics 
done prove validity abstraction 
unclear extension utility outside 
hendren nicolau hn hn take different approach 
assume known underlying data structure example linked list tree dag 
assumption necessary analysis verified algorithm 
graphs represent dynamic store path matrices entries path expressions 
rows columns path matrices handles variables program 
path expression row column represents relationship restricted regular expressions hn hn interprocedural algorithm absence recursion interprocedurally analogous assumed alias algorithm 
amounts assumed path matrix entry procedure basically assumed individual entry matrix 
loose course matrices viewed adjacency matrices viewed graphs labeled edges 
need restricted equality path expressions computed time polynomial size expressions 
function calls intraprocedural loops analogy don assumed path matrices propagate path matrices execution paths npd effectively analyze procedure calling chain invokes 
idea limiting assumption single alias assumption valid problem methods produce solution efficiently 
able reduce amount redundant calculation done having re calculation identical portions different assumed path matrices 
presence recursion hn hn amounted assumed condition nomenclature meet conditions entry procedure recursive invocation 
recursive function call treated differently non recursive call avoid imprecision meeting various conditions hold entry recursive procedure 
chase wegman zadeck cwz storage shape graphs represent dynamic store change notion limiting 
original idea limiting simply represent distance labeled node summary node 
data structure represented linked list length length information lost representation 
propose method limiting graphs preserve information 
possible view cwz storage shape graph type finite state automaton 
sure relates hn hn limited regular expressions represent path expressions 
cwz gives algorithm determining underlying data structure list tree agree hn hn information exploited 
uses trees represent defined object names 
defined object names set names derivable grammar uses actual parse trees 
redefines traditional data dependence calculation pw terms trees 
account point specific aliasing transitive closure may alias solution program point insure safety 
determined assumption viable hn hn 
loops think imprecise aliasing path transitive relation may alias transitive closures certainly introduce unnecessary imprecision 
chapter classification alias problems problem classification analyzed theoretical difficulty solving aliases presence formals single level pointers multiple level pointers structures containing single level pointers 
allow arrays simply treat aggregates 
results analyses shown table 
blanks table correspond problems involve parameters inherently interprocedural 
surprisingly difference problem difficulty intraprocedural interprocedural problems terms np hard vs salient property number possible levels indirection regardless mechanism create indirection 
level indirection possible aliasing precisely solved polynomial amount time soon levels problem np hard 
distinct approximations practical alias algorithm 
program contains recursive data structures potentially infinite number objects aliases 
aliasing algorithm represent possible objects finite polynomial number objects type representation precision distinguishes different conflict detection methods 
second source approximation illustrated scenario 
suppose assignment program point alias pair hp qi holds path immediate predecessor yi holds path level indirection mean value stored location address location 
example limited defined jones muchnick jm 
remember holds defined execution statement path 
immediate predecessor yi hold path 
yi 
ff omega hp qi yi hp qi yi occur path yi holds path extended conclude may true 
solve alias pairs precisely need information multiple alias pairs path 
unfortunately property generalizes determine precisely single path set alias pairs hold need information sets alias pairs 
np hard presence single level pointers determine intraprocedural path set number variables program aliases hold theorem approximation occur 
third source similar second 
consider assignment program point suppose hp qi holds path immediate predecessor pred zi holds path immediate predecessor zi hold path 
zi 
ff omega hp qi zi path pred zi holds hp qi hp zi holds path zi holds path extended paths pred zi holds hp qi holds zi necessarily hold path fourth involves distinct aliases lhs assignment 
ff omega hp ui hp vi normally hold path assigning assignment path hp ui holds 
necessarily case 
example path hp vi holds necessarily hold node ffl ffi fi fl succ ffl ffi fi fl oe oe fourth kind approximation different requires recursive data structures type casting occur 
cases approximation rarely occur 
np hardness proofs variations proofs myers mye similar independently discovered proof recursive structure aliasing indicated table lar 
problems categorized polynomial time corollaries proofs theorem theorem 
rest chapter presentation proofs theorems table 
formals theorem exists polynomial algorithm determining precise interprocedural may alias sets presence formals 
theorem exists polynomial algorithm determining precise interprocedural alias sets presence formals 
problem determining interprocedural may alias sets presence formals examined extensively 
notable algorithms ban coo ck mye 
formal proofs theorem theorem follow directly previous 
theorems easy corollaries theorem theorem 
intraprocedural intraprocedural interprocedural interprocedural alias mechanism may alias alias may alias alias formals polynomial polynomial pointers ban coo ban coo structures theorem theorem single level pointers polynomial polynomial polynomial polynomial ref 
formals structures theorem theorem theorem theorem single level pointers polynomial polynomial formals pointer ref theorem theorem erence formals structures mult 
level pointers np hard complement np hard complement ref 
formals np hard np hard structures theorem theorem corollary corollary single level pointers np hard complement pointer np hard formals theorem theorem structures single level pointers np hard complement np hard complement structures lar np hard lar np hard ref 
formals theorem theorem corollary corollary table alias problem decomposition classification single level pointers precede results area mentioned chow cr previously attempted devise algorithm determining aliases presence mechanism 
definition precise interprocedural may alias weaker consider realizable paths icfg consider paths 
algorithm incomplete 
intraprocedural may alias algorithm section best way solve intraprocedural may alias presence single level pointers 
polynomial time precise extensible interprocedural may alias problem 
algorithm explained manner aid understanding efficient implementation 
algorithm originally lr 
presentation lr contains implicit assumption valid practice reasonable proofs contained chapter 
consider statement 
lr assumed qi holds path valid null 
example null immediate predecessor qi hold path 
consider assumption null path reasonable practice approximate algorithm see chapter 
algorithms chapter modified avoid assumption 
reflexive aliases keep track non null pointers qi holds path iff null execution sequence defined taken 
natural extension refers location iff contains location non null 
extension holds implies qi may alias iff path including non null 
implies qi alias iff paths non null 
means alias qi may alias precisely captures information relation null needed solve may alias qi alias precisely captures information relation null needed alias 
note null introduced class object name occur alias pair 
definitions chapter equally valid regardless null explicitly considered 
cfg ae procedure analyzed single procedure pointer alias graph sppag constructed 
node sppag form cfg node alias pair fixed point value holds cfg node alias pair true iff path ae cfg node cfg alias pair holds 
edges sppag represent dependence holds predicate various sppag nodes 
holds ha bi depend cfg node pair ha bi single edge ae 
holds ha bi holds ha bi holds ha bi edges ha bi ha bi ae ha bi ha bi ae sppag 
holds ha bi true regardless holds value edge ae ha bi ae sppag 
chow cr consider relationship execution path aliases hold statement executed aliases hold executed 
consider node ha bi sppag 
statements true ffl dereferenced pointer variable variable aliased paths holds ha ai true 
cases assume dereferenced pointer variable 
ffl assignment pointer holds ha bi true iff path immediate predecessor ha bi holds 
ffl pointers remember node cfg corresponds single statement 
implies holds cfg node alias pair calculated exit cfg node 
remember aliases symmetric represents object name alias just name 
holds pi true iff path immediate predecessor qi holds 
holds bi true iff path immediate predecessor bi holds 
holds ha bi true iff path immediate predecessor ha bi holds 
ffl holds pi true holds bi true iff path immediate predecessor hv bi holds 
holds ha bi true iff path immediate predecessor ha bi holds 
ffl malloc null 
holds pi true malloc false null holds bi false bi hold path 
holds ha bi true iff path immediate predecessor ha bi holds 
sppag formally specified appendix built reflect rules 
naive algorithm computing intraprocedural may alias 
theorem exists polynomial time algorithm determining precise intraprocedural may alias sets presence single level pointers 
primitive type structure 
build sppag 
initialize holds ha bi false ha bi sppag 
calculate fixed point holds relation 
polynomial time algorithm intraprocedural may alias level pointers claim algorithm algorithm 
polynomial jn nodes edges sppag node set cfg number object names may aliases fixed point calculation holds sppag node change value ftrue falseg lattice 
proof precision induction path length induction iteration fixed point calculation 
formal proof appendix 
intraprocedural alias intraprocedural alias algorithm see identical intraprocedural may alias algorithm 
intraprocedural may alias algorithm sppag node specify alias held path immediate predecessor contrast alias alias hold path paths immediate predecessors 
means holds relation need conjoin predecessors node 
holds holds relation defined conjoining immediate predecessors 
difference may algorithms alias algorithm holds initialized true 
theorem exists polynomial time algorithm determining precise intraprocedural alias sets presence single level pointers 
claim algorithm algorithm 
proof programs just single level pointers number variables program 
build sppag 
initialize holds ha bi true ha bi sppag 
calculate fixed point holds relation 
polynomial time algorithm intraprocedural alias level pointers similar theorem formally proved appendix 
interprocedural may alias interprocedural may alias presents additional complication 
obvious solution intraprocedural algorithm icfg 
unfortunately introduces imprecision 
intraprocedural algorithm computes mfp maximum fixed point distributive framework computes mop meet paths solution hec 
approach interprocedural algorithm paths icfg realizable procedure call return site invoked 
seen example ignoring problem result imprecise alias computations alias pi hold realizable path hold path entry main null call entry exit return call entry exit return 
possible solution problem keep path information avoid paths realizable 
concept alias histories coo sp 
chosen approach 
idea solving data flow problem procedure assuming alias condition entry 
reminiscent lomet approach solving data flow problems different aliasing conditions lom marlowe notion representative data flow problem 
key idea solution unrealizable path problem devise step algorithm 
step solve conditional may aliases answer question path entry node procedure containing alias set holds may aliased 
second step conditional may aliases solution solve actual aliases 
step approach avoids alias propagation unrealizable paths 
step edges call nodes entry nodes icfg ignored 
information propagated procedure entry nodes exits calculation return node combines information corresponding call node called procedure exit node 
potential alias effects called procedure calling procedure incorporated aliases introduced call ignored 
second step aliases introduced propagated call node corresponding entry node called procedure ignoring edges exit nodes returns 
conceptually analogous propagation program call graph hec 
idea conditional may aliases promising exponential number possible sets aliases 
lemma insures sufficient consider sets 
level indirection possible longer precise consider safe 
naive version algorithm manner aid understanding facilitate proof correctness efficient implementation 
lemma pointer usage restricted single level pointers ffl realizable paths entry node procedure containing number calls path equals number returns ffl possible alias pairs ha bi alias pairs set fa am holding execution path implies ha bi holds similar pass approach construct interprocedural program slices hrb hs 
alias solution imprecise actual alias pairs contained solution calculated 
assuming aliases executing path forces ha bi hold assuming alias pair executing path forces ha bi hold lemma basically states interprocedural path information captured single empty set assumptions alias assumption 
proof lemma induction jpj basis trivially true induction step easy messy case analysis possible required 
appendix 
computing conditional may alias information assuming local variables conditional may aliases computed building pointer alias graph pag 
nodes alias graph form icfg node assumed alias alias pair assumed alias single alias pair 
fixed point holds icfg node assumed alias alias pair true iff alias pair holds path procedure entry icfg node assuming path entry procedure containing icfg node assumed alias holds 
sppag edges pag represent dependence holds predicates pag nodes 
consider intraprocedural aspects pag 
assume sppag holds ha bi holds hc di holds hc di obvious relationship holds pag fixed assumed alias possible assumed alias explanation algorithm illustrative intended efficient implementable algorithm 
holds assumed alias ha bi holds assumed alias hc di holds mk assumed alias hc di understanding sppag realization entry node holds entry ha bi ha bi true give intuition intraprocedural aspects pag 
unrealizable path problem avoided pag including edges call nodes entry nodes procedure invoked 
definition conditional may aliases call site gives information conditional may aliases hold entry invoked procedure holds entry aa ha bi true aa ha bi dereferenced pointer false 
call exit nodes simply collect alias information 
holds call exit aa ha bi call holds aa ha bi programs parameters simplicity assume dealing programming language local variables parameters 
assume interested holds return assumed alias ha bi true 
clearly true ha bi holds exit node conditional assumed alias holding entry assumed alias conditional assumed alias holds call node see 
assumed set possible assumed aliases 
holds return node defined holds return assumed alias ha bi holds exit ha bi aa assumed holds exit aa ha bi holds call assumed alias aa modeling effects parameter bindings need able model effects parameter bindings back bind call back bind call call site 
back bind call assumed alias specifies alias holding path ae call guarantees assumed alias holds places aa represent assumed alias sets size 
holds return assumed alias ha bi true holds call assumed alias assumed alias true holds assumed alias ha bi true holds assumed alias assumed alias true ff ae ae ae ae ae ae ae ae ae holds return node local variables ae call entry 
back bind formally specified appendix informal definition 
consider back bind call assumed alias arbitrary call assumed alias ffl assumed alias condition holds 
ffl assumed alias hc di local called procedure clearly dereferenced formal procedure aliases entry procedure 
aliased entry corresponding actuals aliased call 
back bind call hc di actual corresponding actual corresponding ffl assumed alias hc di local alias hold entry dereferenced formal actual aliased call 
back bind call hc di di actual corresponding ffl assumed alias hc di locals hc di holds entry iff held call node 
back bind call hc di hc di 
ffl consider int int main int note call main creates alias pair xi destroys alias pair xi 
calls affecting alias pairs involving non visible object names assumed alias hold entry 
unfortunately simple modeling parameter bindings sufficient 
procedure call create destroy calling procedure alias involving object name visible called procedure 
example call creates alias xi destroys alias xi return visible visible object name alias pair affect alias holds path direct object name visible 
fortunately procedure effect alias pairs contain visible object name non visible object name 
object name may aliases introduce alias pair hw non visiblei representing aliased non visible object name set possible alias pairs set possible assumed aliases 
addition back bind define back bind back bind call ha non visiblei specifies alias holding path ae call guarantees aliased non visible object name ae call entry 
back bind formally specified appendix informal definition follows 
consider back bind call ha non visiblei arbitrary call ffl local called procedure 
back bind call ha non visiblei ha bi ffl dereferenced formal 
back bind call ha non visiblei bi actual corresponding ffl ha non visiblei hold entry 
computing conditional may alias information return node factoring local variables assume interested ha bi holds realizable path node return conventions return aen entry call entry exit return exit aen entry call entry exit entry aen entry call entry call aen entry call entry aen entry return procedure realizable paths number calls returns entry exit call return entry exit call return nodes respectively associated call 
consider cases ffl visible called procedure impossible called procedure create destroy alias pair ha bi holds return iff holds call holds return assumed alias ha bi holds call assumed alias ha bi ffl visible called procedure ha bi holds return hold exit lemma aliases need hold entry ha bi hold exit exists hc di hc di hold entry ha bi hold exit case holds exit ha bi true definition holds 
second case holds exit hc di ha bi true back bind call hc di hold call lemma assumed alias single alias pair hold entry definition holds holds assumed alias back bind call hc di true 
holds return assumed alias ha bi holds exit ha bi aa assumed holds exit aa ha bi holds call assumed alias back bind call aa ffl assume visible 
ha bi holds return iff ha non visiblei holds exit non visible object name non visible 
lemma single ha non visiblei hold path entry back bind call ha non visiblei hold path call lemma assumed alias single alias pair hold entry definition holds holds assumed alias back bind call ha non visiblei true 
holds return assumed alias ha bi ha non visiblei assumed holds exit ha non visiblei ha non visiblei holds call assumed alias back bind call ha non visiblei formal specification pag holds relation appendix 
fixed point holds program 
ri ri non visiblei included main table involves local aliases hold path entry main assumed alias qi omitted space consideration main table reflexive assumption occurs 
true entry means value holds icfg node assumed alias possible alias true assumed alias hold path entry procedure containing icfg node 
values efficient version algorithm compute 
computing interprocedural may alias conditional may alias computed conditional may aliases interprocedural may alias information computed simple data flow problem icfg 
conditional may alias able model effects parameter bindings 
know aliases hold entry node certain alias holds call node 
bind call functions model parameter effects 
bind call set aliases hold path aen call entry holds aen call 
bind call formally specified appendix may thought bind call hc di fi fi fi fi fi fi fi back bind call hc di ha bi back bind call hc di ha bi holds bind functions node icfg may alias defined follows ffl may alias ae ffl entry node may alias nae bind may alias ffl may alias ha bi fi fi fi fi fi fi fi fi fi fi fi non visible holds ha bi true aa may alias entry holds aa ha bi true theorem exists polynomial time algorithm determining precise interprocedural may alias sets presence single level pointers 
icfg node assumed possible alias alias hp qi hp ri ri omega nv ff nvi qi ri false false false false false false false null false false false false false false false false false false false false false false false false false false false false false false false false false false false false call false false false false false false false return true false false false false true false true false false false false true false nvi false false false true false false false null nvi false false false true false false false nvi false false false true false false false nvi false false false true false false false nvi false false false true true false false call nvi false false false true true false false return nvi true false false false true true false nvi true false false false true true false icfg node assumed possible alias alias fi nvi nvi qi fi false false false false false false false false false false false false false false false fi false false false false true fi true false false true true fi true false false true true fi true false false false false fi false false false false false fi false false false false false nvi false true false false false nvi false false false false false nvi false false false false false nvi false false true false false nvi false true true false false nvi false true true false false nv non visible 
holds icfg node assumed alias possible alias program build pag 
initialize holds aa pa false aa pa pag 
calculate fixed point holds 
initialize may alias icfg 
calculate fixed point may alias 
polytime algorithm interprocedural may alias presence single level pointers claim algorithm algorithm 
claim holds calculation computed polynomial time 
fixed point calculation interprocedural may alias takes polynomial time node icfg may alias change value times number variables program 
precision algorithm stems lemma formal proof theorem induction path length induction number iterations fixed point calculation 
formally proved appendix 
gives fixed point may alias program 
interprocedural alias interprocedural may alias solve interprocedural alias problem step algorithm 
step solve conditional aliases second step conditional alias information calculate alias sets 
nature conditional alias little common conditional may alias 
directly prove mfp equations precise may alias solution need prove distributivity function space show mfp mop kil 
icfg node may alias icfg node entry main null call return call return fh qi qig exit main fh qi qig fh fig fh fi fi qig fh fi fi qig may alias icfg node program conditional alias intuitively conditional alias node icfg alias pair unique minimal set assumed aliases entry node procedure containing node insures alias pair hold paths node 
set exists conditional alias false 
example insure xi holds paths xi xi assumed entry cond alias pair node refer precise conditional alias information 
cond alias pair node value 
path node alias pair doesn hold cond alias pair node definition false 
consider case holds paths node 
lemma unique aa assumption single assumed alias holds including entry node procedure containing node guarantees alias pair holds unique minimal set assumed aliases entry node procedure containing node insures alias pair hold paths node clearly union aa union assumptions individual paths 
possible values cond alias pair node false subset set int 
paths xi holds iff xi xi hold paths entry conditional alias example possible aliases possible aliases 
values ordered restrictiveness conditional aliases form lattice 
false restrictive means conditions force alias pair hold node 
just lifting superset lattice adding new bottom false 
iff false meet elements lattice false element false set union elements 
lattice formally specified appendix 
need model effects procedure calls interprocedural may alias back bind relation see section appendix 
basis conditional alias algorithm relationship various cond alias pair node values 
conditional alias information computed maximal fixed point calculation holds relation simplify formulas ffl holds false false nodes icfg 
ffl holds ho oi nodes icfg possible pointer object names false iff false 
possible aliases set possible aliases 
define lattice ffl powerset possible aliases false ffl iff false note false iff false 
ffl false false false ffl ffl false lattice possible values cond alias pair node define relation holds ha bi node icfg ae ha bi possible aliases dereferenced pointer follows ffl entry node clearly fha big unique minimal set aliases hold entry 
ffl return node return assume interested ha bi holds realizable paths return page return aen entry call entry exit return exit aen entry call entry exit entry aen entry call entry call aen entry call entry aen entry return procedure realizable paths number calls returns entry exit call return entry exit call return nodes respectively associated call 
consider cases visible procedure called 
ha bi hold return ha bi hold exit invoked call site return ha bi hold exit aliases holds exit ha bi hold entry true hc di holds exit ha bi back bind call hc di hold call case alias hc di holds exit ha bi holds call back bind call hc di holds entry visible procedure called 
ha bi hold return ha non visiblei hold exit non visible non visible object ha non visiblei hold exit aliases holds exit ha non visiblei hold entry true hc non visiblei holds exit ha non visiblei back bind call hc non visiblei hold call case alias holds call back bind call hc non visiblei hc non visiblei holds ha non visiblei holds entry visible procedure called 
ha bi hold return iff ha bi hold call ffl entry return node interprocedural may alias know unique hc di path aen icfg ha bi holds iff hc di holds path aen see section section 
holds ha bi union conditional alias sets hc di immediate predecessors sets exist false 
intuitively true ha bi hold hc di hold immediate predecessors holds formally specified appendix 
fixed point holds program 
icfg node possible alias hp qi hp ri ri nv entry main fhp qig fhp rig fh rig fh null fhp qig false false fh call fhp qig false false fh return fhp qig false false fh fhp qig fhp qig fh qig fh call fhp qig fhp qig fh qig fh return fhp qig fhp qig yy fhp exit main fhp qig fhp qig fhp icfg node possible alias nvi qi ri entry main fh fh qig fh rig null false fh qig false call false fh qig false return false fh qig false fh fh qig fh qig call fh fh qig fh qig return fh fh qig exit main fh fh qig icfg node possible alias fi nvi nvi qi fi fh fig fh fh fh qig fh fig fh fig fh fh fh fig fh fig fh fig fh fh fh fig fh fig nv non visible 
holds nvi nvi back bind call nvi hp pi holds call hp pi 
yy holds nvi nvi back bind call nvi hp ri holds call hp ri hp qi 
holds icfg node possible alias program computing interprocedural alias conditional alias interprocedural alias information computed simple data flow problem icfg conditional alias information 
interprocedural may alias able model effects parameter bindings 
bind relation see section appendix 
holds bind functions node icfg alias defined follows ffl alias ae ffl entry node alias nae ha bi fi fi fi fi fi fi fi ha bi bind alias contain non visible ffl alias fha bi holds ha bi alias entry theorem exists polynomial time algorithm determining precise interprocedural alias sets presence single level pointers 
claim algorithm algorithm 
formally proved appendix 
fixed point calculations converge polynomial amount time lattices height polynomial size program function spaces monotonic 
gives fixed point alias program 
non pointer formals single level pointers program mechanisms easily transformed program single level pointers rules alias hold calls 
ae false false lattices height number variables program 
icfg ha bi possible aliases initialize holds ha bi 
calculate fixed point holds 
icfg initialize alias possible aliases 
calculate fixed point alias 
polynomial time algorithm interprocedural alias presence single level pointers icfg node alias icfg node entry main null call return call return fhp qi qig exit main fhp qi qig alias icfg node program ffl procedure formal replace declaration ref type 
type 
replace program 
replace program actual formal 
transformation case 
ffl call actual formal replace formal 
ffl formals pass value 
transformation essentially inverse developed carroll car 
lemma realizable paths aen icfg original program hx yi holds iff ffl case formals yi holds path transformed program 
ffl case formal yi holds path transformed program 
ffl case formals hx yi holds path transformed program 
proof induction path length formally proved appendix 
theorem exists polynomial time algorithm determining precise interprocedural may alias sets presence non pointer formals single level pointers 
ref indicates formal follows lemma theorem 
theorem exists polynomial time algorithm determining precise interprocedural alias sets presence non pointer formals single level pointers 
follows lemma theorem 
multiple level pointers far precise polynomial time algorithms determining aliases presence various mechanisms 
possible remainder mechanisms chapter 
proofs presence subsequent mechanisms determining aliases np hard np hard 
may alias theorem presence level pointers problem determining precise intraprocedural may alias sets np hard 
corollary presence level pointers problem determining precise interprocedural may alias sets np hard 
proof theorem reduction sat problem propositional variables fv reduction specified program polynomial size sat problem 
conditionals specified program assuming paths executable 
seen paths code represent truth assignments propositional variables 
truth assignment particular path encoded aliasing relationship certain variables intraprocedural version problem theorem subproblem interprocedural version 
int vm int true false int path section code corresponds truth assignment fv true falseg fv false trueg fv true falseg fv false trueg 
fv true falseg fv false trueg false code break false noi alias iff truth assignment formula false 
string literal represents vk vk 
sat solution iff false noi intraprocedural may alias program 
paths encode alias relationships truth assignment resultant path taken satisfies 
interpret aliased true meaning variable true path interpreted truth assignment 
truth assignment corresponds path 
idea aliases represent truth assignment myers mye larus lar independently developed similar proof aliasing dynamic structures 
consider paths 
truth assignment particular path satisfies formula clause literal true 
pick path clause assigns true literal 
assignment corresponds true false noi intraprocedural may alias 
formula unsatisfiable truth assignment clause say false literals 
means aliased false 
path go statement alias false yesi hold paths false noi 
sat polynomial reducible intraprocedural may alias level pointers theorem holds 
alias theorem presence level pointers complement problem determining precise intraprocedural alias sets np hard 
corollary presence level pointers complement problem determining precise interprocedural alias sets np hard 
proof theorem reduction sat theorem see 
claim sat formula satisfiable iff false yesi complement intraprocedural alias 
proof theorem sat formula satisfiable path false noi holds false yesi intraprocedural alias 
sat formula unsatisfiable path false yesi holds false yesi intraprocedural alias 
formals single level pointers interprocedural may alias theorem presence formals single level pointers problem determining precise interprocedural may alias sets np hard 
proof theorem reduction sat problem variables fv conceptually identical proof theorem 
reduction specified program polynomial size sat problem 
conditionals specified program assuming intraprocedural paths executable 
essentially proof theorem 
interpret aliased true meaning variable true path interpreted truth assignment truth assignment corresponds path 
consider paths 
truth assignment particular path satisfies formula clause literal true 
pick path clause assigns true literal 
assignment corresponds true false noi interprocedural may alias 
formula unsatisfiable truth assignment clause say false literals 
means aliased false 
path go statement alias false yesi hold paths false noi 
interprocedural alias theorem presence formals single level pointers complement problem determining precise interprocedural alias sets alternate reduction works scope rules 
int true false path section code corresponds truth assignment var ref int var true false var false true var ref int var true false var false true 
var ref int code break false noi alias iff truth assignment formula false false 
main var true false var false true note order proof scope pascal scoping rules procedures nested 
ref indicates formal string literal represents vk vk 
sat solution iff false noi interprocedural may alias int true false path section code corresponds truth assignment var ref int var true false var false true var ref int var true false var false true 
var ref int 
code break false noi alias iff truth assignment formula false ref int 
false 
main var true false var false true ref indicates formal string literal represents vk vk 
sat solution iff false noi interprocedural may alias np hard 
proof theorem reduction sat theorem see 
claim sat formula satisfiable iff false yesi complement interprocedural alias 
proof theorem sat formula satisfiable path false noi holds false yesi interprocedural alias 
sat formula unsatisfiable path false yesi holds false yesi interprocedural alias 
structures containing single level pointers may alias theorem presence structures containing single level pointers problem determining precise intraprocedural may alias sets np hard 
corollary presence structures containing single level pointers problem determining precise interprocedural may alias sets np hard 
proof theorem reduction sat problem variables fv larus lar presents alternate proof theorem 
proof conceptually identical proof theorem 
reduction specified program polynomial size sat problem 
conditionals specified program assuming paths executable 
essentially proof theorem 
interpret aliased true meaning variable true path interpreted truth assignment truth assignment corresponds path 
consider paths 
truth assignment particular path satisfies formula clause literal true 
struct list int value struct list struct list 
struct list true false struct list path section code corresponds truth assignment fv true falseg fv false trueg fv true falseg fv false trueg 
fv true falseg fv false trueg false code break false noi alias iff truth assignment formula false 
string literal represents vk vk 
sat solution iff false noi intraprocedural may alias pick path clause assigns true literal 
assignment corresponds true false noi intraprocedural may alias 
formula unsatisfiable truth assignment clause say false literals 
means aliased false 
path go statement alias false yesi hold paths false noi 
alias theorem presence structures containing single level pointers complement problem determining precise intraprocedural alias sets np hard 
corollary presence structures containing single level pointers complement problem determining precise interprocedural alias sets np hard 
proof theorem reduction sat theorem see 
claim sat formula satisfiable iff false yesi complement intraprocedural alias 
proof theorem sat formula satisfiable path false noi holds false yesi intraprocedural alias 
sat formula unsatisfiable path false yesi holds false yesi intraprocedural alias 
alias sets associated program paths determining alias pair holds path program point try determine set alias pairs holds path program point alias problem introduced previously considered sets mechanisms np hard 
holds set alias pairs holds realizable path aen iff ha bi refer location program point execution sequence defined path occurs 
interprocedural may set alias precise solution interprocedural may set alias realizable path aen icfg 
intraprocedural may set alias precise solution intraprocedural may set alias path aen cfg 
single level pointers theorem presence single level pointers problem determining precise intraprocedural may set alias np hard 
proof theorem reduction sat problem variables fv reduction specified program polynomial size sat problem 
conditionals specified program assuming paths executable 
interpret aliased true meaning variable true path interpreted truth assignment 
truth assignment corresponds path 
consider paths 
truth assignment particular path satisfies formula clause literal true 
pick path th clause assigns true literal int vm int 
int true false path section code corresponds truth assignment fv true falseg fv false trueg fv true falseg fv false trueg 
fv true falseg fv false trueg code create truei fi fi fi alias iff truth assignment formula true 
string literal represents vk vk 
sat solution iff fh truei ng intraprocedural may set alias assignment creates alias truei ae truei fi fi fi fi oe intraprocedural may set alias 
formula unsatisfiable truth assignment clause say false literals 
means aliased false 
path go statement alias ae truei fi fi fi fi oe holds path 
sat polynomial reducible intraprocedural may set alias single level pointers theorem holds 
easy corollaries theorem corollary presence single level pointers problem determining precise interprocedural may set alias np hard 
corollary presence multiple level pointers problem determining precise intraprocedural may set alias np hard 
corollary presence multiple level pointers problem determining precise interprocedural may set alias np hard 
corollary presence structures containing single level pointers problem determining precise intraprocedural may set alias np hard 
corollary presence structures containing single level pointers problem determining precise interprocedural may set alias np hard 
formals theorem presence formals problem determining precise interprocedural may set alias np hard 
proof theorem reduction sat problem variables fv conceptually identical proof theorem 
reduction specified program polynomial size sat problem 
conditionals specified program assuming paths executable 
interpret aliased true meaning variable true path interpreted truth assignment 
truth assignment corresponds path 
consider paths 
truth assignment particular path satisfies formula clause literal true 
pick path clause passes true literal th clause clause call corresponds passing true ae hc truei fi fi fi fi oe interprocedural may set alias 
formula unsatisfiable truth assignment clause say false literals 
means aliased false 
path go clause alias ae hc truei fi fi fi fi oe holds path 
sat polynomial reducible interprocedural may set alias formals theorem holds 
space hard alias problems chapter proved may alias presence various language constructs np hard see table 
natural question ask problems np complete 
space np time answer 
space set languages accepted polynomial space bounded deterministic turing machines np space set languages accepted polynomial space bounded nondeterministic turing machines 
np space space ahu 
section show np hard problems alternate reduction works scope rules 
int true false path section code corresponds truth assignment var ref int var true false var false true var ref int var true false var false true 
vm vm ref int vm vm clause code create hc truei fi fi alias iff truth assignment formula true clause clause clause clause clause ref int clause clause clause clause ref int clause clause clause 
clausen cn ref int cn main var true false var false true note order proof clause ck scope vm vm clausen cn scope cn pascal scoping rules procedures nested 
ref indicates formal string literal represents 
sat solution iff truei ng interprocedural may set alias int true false path section code corresponds truth assignment var ref int var true false var false true var ref int var true false var false true 
vm vm ref int vm vm clause vm vm code create hc truei fi fi alias iff truth assignment formula true clause vm ref int vm clause vm clause vm clause vm clause vm ref int vm clause vm clause vm clause vm clause vm ref int vm clause vm clause vm clause vm 
clausen vm cn ref int vm cn main var true false var false true ref indicates formal string literal represents 
sat solution iff truei ng interprocedural may set alias table space hard levels indirection possible 
show space complete problems open complete space 
theorem presence multiple level pointers levels indirection intraprocedural may alias complete space common assumptions static analysis 
theorem presence multiple level pointers levels indirection intraprocedural alias complete space common assumptions static analysis 
prove theorem theorem concurrently 
space defined deterministic turing machines space closed complementation 
theorem show complement intraprocedural alias complete space 
show problems space 
consider polynomial space bounded control flow graph cfg start node ae starts path ae nondeterministically generates legal path new node path computes aliases new path aliases old path 
needs remember path node path aliases path 
program constant dereferences polynomial number possible alias pairs needs polynomial amount storage 
node alias pair node ha bi node ha bi intraprocedural may alias iff generate path node ha bi alias solution 
node ha bi complement intraprocedural alias iff generate path node ha bi alias solution 
polynomial number pairs asking node ha bi intraprocedural may alias complement intraprocedural alias generate full solutions problems 
intraprocedural may alias intraprocedural alias space closed complementation space 
show problems space hard complicated 
proof uses fact certain language known space complete reduce language problems 
regular expression denote language represents 
set regular expressions 
complete space ahu 
reduce various alias problems 
need lemma section 
lemma regular expression symbols operators construct nfa time accepts jsj degree oe oe ffl oe degree 
theorem pp 
ahu identical lemma additional claim oe oe degree examination nfa construction ahu verify claim true 
reduce intraprocedural may alias complement intraprocedural alias 
regular expression symbols operators alphabet oe build nfa meeting requirements lemma 
program simulates key ideas paths program represent various strings particular path program represents string alias information capture possible states achieve input way path represents string determine may alias requires existence alias path determine exists path representing string 
part true iff size program dominated ffl closure macro size jsj 
generated time polynomial respect regular expression nfa lemma 
define macro ffl closure repeat physically jsj times state ffl degree state ffl ffl degree repeat macro int nc int oe oe int int state state int temp state state oe temp oe state state ffl closure nc oe nc oe nc oe foe oe state oe nc oe temp oe oe ffl closure reduction alias problem variables declared 
int nc int oe oe int int state state int temp program letter oe variable called oe 
string generated loop pass loop adds character string 
nc aliased character string 
path executed times string character referred nc th iteration loop path string representation program refers initial substring input read far 
variables state called 
ideally aliased state iff string ffl simulate wasn possible came sufficient compromise 
alias state yesi holding path represent fact valid simulation path valid simulation state aliased aliased state iff string ffl appears times temp just temporary areas 
lemmas program 
lemma non trivial paths program state yesi holds iff state noi 
int variables program 
state type int refer 
examination code obvious state refer 
lemma path including code ffl closure ae fi fi fi fi statei holds oe ffl closure thing executed 
ffl state yesi holds path ffl closure state yesi holds ffi ffl paths ffl closure state yesi holds ffi statei iff ae fi fi fi fi ffl ffl oe consider ffl degree 
code represents adding ffl closure state adding ffl closure code needs insure ffl closure code ffl closure code 
possible relevant alias conditions code executed remember state noi holds paths 
aliases executed path path statei statei statei statei statei statei statei statei state noi statei statei statei state noi statei statei statei statei statei achieve desired effect aliased state execution code iff aliased state execution 
cases branch code meets requirements path doesn destroys alias state yesi creating state noi 
code states edges justified similarly 
gives analysis space reasons abbreviations listed top 
list relevant alias situations execution code possible local exceptions state ffl ffl degree specify desired alias situation execution code alias situation achieved path code 
particular abbreviation deserves comment error represents fact state noi holds paths indicated 
state noi holds path state yesi state different values path paths valid simulation state yesi holds path th copy state ffl degree state ffl ffl degree ffl closure simple induction ffl state yesi holds ffi ffl statei holds ffi ffl ffl aliased state immediately execution ffl closure 
ffl statei holds ffi ffl ffl aliased state immediately execution ffl closure 
addition paths true state aliased 
clearly ffl ffl iff ffl ffl jsj cycle involving just ffl transitions don need consider paths ffl 
code ffl closure satisfies lemma 
ffl ffl statei statei error state noi breaking state yesi aliases desired alias executed execution path path path error error error error error error error error error justification code state edges lemma exists path program appears jwj times string state yesi holds quick inspection code shows places variable type int directly indirectly assigned initialization ffl closure 
state type int place alias state yesi destroyed executed ffl closure 
lemma lemma holds 
lemma paths program appears times state yesi holds statei holds iff string ffl 
consider meaning path pm pm ffi program occurs times occurs times pm ends proof lemma induction basis initialization phase state state oe temp oe alias state yesi represents fact path far legal simulation alias state noi invariant 
local places state yesi happens invariant alias immediately restored 
assignment oe temp simply points oe unimportant location 
rest initialization phase state state ffl closure code states initially state creating alias statei 
lemma depending path executed ffl closure destroys alias state yesi creates alias statei state ffl ffl 
fortunately path true lemma holds 
induction hypothesis lemma holds occurs times 
induction step stated path loop represents string 
state yesi hold pm lemma follows 
assume hold pm hold pm alias created initialization 
induction get fact string ffl iff statei holds pm code nc oe nc oe nc oe foe oe simply generates character string considered 
fact code state oe nc oe temp oe oe unique lemma simulates effects oe oe 
aliasing oe state iff aliased state character oe nc aliased oe 
consider nc nc aliased oe nc aliased nc aliased temp 
nc change value iff nc aliased oe 
assuming nc aliased oe nc aliases state iff aliased state 
fact fact imply string nc ffl iff statei holds pm loop ffl closure lemma lemma holds pm finish proof theorem theorem 
claim iff state yesi precise intraprocedural may alias solution 
claim iff state noi complement precise intraprocedural alias solution 
ffl assume exist 
lemma path ae executed times string state yesi holds lemma aliases hold ae hold ae states statei holds iff string ffl 
aliased state accepting state code change value state state yesi holds extended state yesi may alias state noi complement alias 
ffl assume assume program path ffi ae state yesi holds appears times 
code assign alias state yesi holds lemma states statei holds iff string ffl 
statei hold code assign state value state yesi hold contradiction 
paths state yesi hold lemma state noi 
state yesi may alias state noi complement alias 
easy corollaries theorem theorem corollary presence multiple level pointers levels indirection interprocedural may alias interprocedural alias space hard common assumptions static analysis 
corollary presence recursive data types intraprocedural may alias intraprocedural alias space hard common assumptions static analysis 
corollary presence recursive data types interprocedural may alias interprocedural alias space hard common assumptions static analysis 
chapter safe approximate algorithm interprocedural may alias may hold relation conditional may alias definition chapter step algorithm finding interprocedural may alias programs single level pointers mechanism creating aliases 
step algorithm compute conditional may alias defined answer question path entry node procedure containing alias set aa holds may object name aliased object name path represent answer question boolean relation holds aa ha bi 
fortunately necessary consider aa sets aliases cardinality equal lemma 
second step conditional may alias solve may alias simple fixed point calculation 
algorithm precise standard assumptions data flow analysis symbolic execution 
single level pointer algorithm determining may alias basis safe interprocedural may alias algorithm programs general pointers 
major obstacles goal 
obstacle precision safety 
restriction single level pointers lifted assumption necessary consider sets assumed aliases aa size equal longer valid 
alias pa depends aa multiple assumed aliases sufficient single assumption necessary 
single assumption safely considered assumption 
continue deal sets assumed aliases size approximation 
second obstacle practicality 
algorithm described chapter compute holds node aa pa possible triple node icfg aa pa program icfg nodes variables different possible aa possible pa means minimum just single level pointer case insure efficiency algorithm differently chapter 
calculate holds demand driven fashion concern holds node aa pa value true 
holds relation value false improve average time complexity algorithm immensely unfortunately help worst case complexity 
improve efficiency changing definition conditional may alias path entry node procedure containing assumed alias aa holds path ha bi holds 
path entry node procedure containing alias set aa holds path ha bi holds path entry node procedure containing assumed alias set aa holds 
changed definition conditional may alias change notation may hold aa ha bi represent answer new conditional may alias question 
formally may hold aa ha bi true iff ha bi holds path entry entry procedure containing assuming path entry main entry assumed alias aa holds path entry main entry aa holds 
consider necessary return nodes complexity introduced minor amount imprecision algorithm order increase efficiency understanding consider statement 
assume qi holds path valid null example null immediate predecessor qi hold path 
consider assumption non null path reasonable practice approximate algorithm 
general existence alias depends fact object name non null path assume verification representation order efficient implementation alias algorithm able operations constant time ffl set may hold node aa pa false possible node aa pa ffl find value may hold node aa pa node aa pa ffl set value may hold node aa pa node aa pa solution problem constant time initialization array 
single level pointers require space 
solution choose dynamic hashing 
dynamic hashing scheme ks implement table shrinking purposes needed giving constant time operations average case 
implement needed operations follows ffl set may hold node aa pa false possible node aa pa simply initialize hash table takes constant time 
optimization removed algorithm great difficulty 
constant null 
number nodes icfg number variables program 
ffl find value may hold node aa pa node aa pa look node aa pa hash table return value associated return false 
ffl set value may hold node aa pa node aa pa node aa pa hash table simply change value associated add 
note may hold node ha bi implies may hold node assumed alias ha bi assumed alias 
want know value may hold node assumed alias ha bi assumed alias look node ha bi 
associated value return true return value associated node assumed alias ha bi table case return false 
alias consequences consider alias declared struct list fint data struct list alias yields situation 
alias implies existence aliases example 
existence alias assumption null 
consequences alias qi defined set aliases implied qi 
alias consequences computed simple recursive procedure see 
procedure terminate aliases recursive types limiting 
set alias consequences ha bi type answer fha big deref alias type ha bi answer answer alias consequences deref struct alias type ha bi field field alias type ha bi answer answer alias consequences access field field access field computing consequences alias assumption null rhs assignment actual procedure call assume prefix dereferences null path immediate predecessor 
sections detailed description main ideas interprocedural algorithm computing may hold including pseudo code descriptions 
mechanisms modeling affects parameter bindings aliases 
second algorithm computing may hold relation 
modeling parameter bindings order interprocedural analysis able model affects parameter bindings aliases 
function bind call assumed alias 
intuitively bind call aliases entry called procedure exist parameter bindings bind call ha bi set aliases entry called procedure existence implied aliased call 
consider example global type int ffl ffi fi fl call ffl ffi fi fl entry store store bind call fh fig bind call ri fh ri rig unfortunately definition sufficient deal object names visible chapter 
procedure call create destroy alias calling procedure involving object name visible called procedure 
example call creates alias xi destroys alias xi return visible visible object name alias pair affect alias holds path direct object name visible 
fortunately procedure effect alias pairs contain visible object name non visible object name 
able correctly account non visible object names need object name type represent non visible object names type call non visible type non visible type considered ordinary object name dereferenced field accessed typing rules permit 
implementation explicit type information necessary just non visible leave type implicit 
leads change bind function 
reasons apparent aliases bind set involve non visible want know object name calling procedure corresponds non visible 
consider example global type int lr referred 
int int main int note call main creates alias pair xi destroys alias pair xi 
calls affecting alias pairs involving non visible object names ffl ffi fi fl call ffl ffi fi fl entry store store non visible bind call fh fig bind call ri non visiblei non visiblei occurrence non visiblei bind call ri represents fact aliased non visible object name entry called procedure case non visible object name 
computing bind call ways aliases implied parameter bindings 
alias corresponds simple formal actual pairing 
example function formal type int call invocation actual ai bind call 
second occurs distinct formals passed non visiblei visible actuals actual prefix 
example function formals type int type int call bind call 
algorithm computing bind call straightforward 
computing bind call hx yi ways alias call site may imply alias entry procedure 
trivial object names global called procedure aliased entry called procedure 
illustrated example global st way call entry nd way call entry rd way call entry ffl ffi fi fl call ffl ffi fi fl entry store store example aliased call aliased example generalized second way alias call site imply alias entry procedure 
actual alias object name corresponding formal picks alias object name non visible object name visible called procedure 
example aliased call aliased entry typical third case actuals aliased necessarily directly call site corresponding formals aliased entry called procedure 
algorithm computing bind call hx yi straightforward encoding cases 

implied binding call visible called procedure return alias consequences deref return alias alias alias consequences deref non visible bind call bind alias effects parameter binding formal actual pair deref object type bind bind implied binding struct object type field field object type dereferenced bind bind implied binding field access field field access field alias effects pairs parameter bindings formal actual pair formal actual pair prefix form apply trans form deref object type bind bind alias consequences deref form struct object type field field object type bind bind alias consequences deref field access field deref field access form field return bind puts copy computing bind call object call name name implications name name object name name visible called procedure return alias consequences name name name assume name visible called procedure return alias name alias alias consequences non visiblei value call name name implications name name referring object deref alias type name return object call deref name deref name struct alias type name val field field type alias type name dereferenced val val object call deref field access name field deref field access name field return val support functions computing bind call hx yi uses functions defined bind call hx yi bind visible called procedure bind bind fhx assume visible called procedure bind bind hx non visiblei rst way chapter formal actual pair deref object type struct object type assume prefix form apply trans form bind bind object call form bind bind value call form nd way chapter formal actual pair formal actual pair prefix prefix form form apply trans form apply trans form yy bind bind object call form form bind bind value call form form rd way chapter puts copy dereference occurs form aliases just contain value 
yy form form dereferenced aliases 
form form dereferenced contain value 
computing bind call hx yi find aliases worklist alias node node icfg node assignment pointer aliases introduced assignment node node call node aliases introduced call node implied aliases worklist empty remove node assumed alias possible alias worklist node call node aliases call implies node assumed alias possible alias node exit node alias exit implies node assumed alias possible alias alias implies node assumed alias possible alias computing may hold computing may hold algorithm computing may hold high level simple 
find may hold relations trivially true example may hold qi true 
initial set compute set true may holds worklist algorithm 
algorithm level abstraction 
remainder section gives detailed descriptions algorithm 
chapter chapter address interprocedural aspects may hold primarily entail insuring aliases realizable paths considered 
chapter chapter cover intraprocedural aspects may hold 
fact may hold qi true implicit assumption null paths node 
reformulate algorithm assumption necessary algorithm inefficient 
current formulation safe reasonable 
aliases introduced assignment node node pointer assignment prefix hu vi alias consequences deref set may hold node hu vi true add node hu vi worklist aliases introduced assignment node aliases introduced call node entry entry called procedure hu vi bind node set may hold entry hu vi hu vi true add entry hu vi hu vi worklist aliases introduced call node aliases introduced assignment node routine simple 
node pointer assignment 
clearly may hold node deref may hold node hu vi hu vi alias deref true prefix example assignment create alias refer different objects assignment alias relationship change 
code function 
aliases introduced call node implementation bind function chapter routine simple see 
alias call implies call assumed alias possible alias call node effectively successor nodes 
entry node procedure invokes explicitly represented edge icfg 
second return node corresponds call site explicitly represented icfg edge known order aliasing algorithm function correctly considers realizable paths icfg 
may hold call assumed alias possible alias effects corresponding entry return nodes 
effects corresponding entry node entry holds defined chapter nice property holds relations true call node affect hold relations entry called procedure true may hold requires existence path entry node certain characteristics holds simply assumed existence path 
effects simple alias ha bi bind call possible alias may hold entry ha bi ha bi false set may hold entry ha bi ha bi true add entry ha bi ha bi worklist 
effects corresponding return node return go details handle effects return introduce functions back bind back bind definitions back bind call ha bi specifies alias path call guarantees aliased control flows corresponding entry node 
back bind call ha non visiblei specifies alias path call guarantees aliased non visible object name control flows corresponding entry node 
definitions imply back bind call ha bi hc di iff ha bi bind call hc di back bind call ha non visiblei hc di iff ha non visiblei bind call hc di non visible non visible object name words entry ha bi ha bi added worklist 

rule visible called procedure holds return assumed alias hx yi holds call assumed alias hx yi 
rule visible called procedure holds return assumed alias hx yi holds exit hx yi aa assumed holds exit aa hx yi holds call assumed alias back bind call aa 
rule visible symmetric case similar holds return assumed alias hx yi ho non visiblei assumed holds exit ho non visiblei hx non visiblei holds call assumed alias back bind call ho non visiblei holds relation return nodes rules return node chapter contains equations holds return node explanation rules valid see chapter 
may hold simple encoding rules minor modifications 
holds rules valid may hold may hold basically holds added restriction assumed alias hold path entry node procedure interest 
equation holds holds exit assumption paired follows holds exit aa ha bi holds call assumed alias back bind call aa way holds exit aa ha bi contribute value return node holds call assumed alias back bind call aa true simple inductive argument path length suffice show means path entry procedure exit alias aa holds 
valid definition may hold 
consider implications may hold call assumed alias possible alias may hold return 
possible alias ha bi need case analysis 
visible called procedure corresponds rule desired action obviously may hold return assumed alias ha bi true set true add return assumed alias ha bi worklist 

visible called procedure corresponds rule may hold return assumed alias hx yi may hold exit hx yi aa may hold exit aa hx yi may hold call assumed alias back bind call aa know may hold call assumed alias ha bi 
ak ak hy denotes implication call exit means call determine exit 
hold call assumed alias back bind call aa specifies rule free variable hx yi obvious action may hold call assumed alias ha bi aa bind call ha bi possible hx yi may hold exit aa hx yi true may hold return assumed alias hx yi false set may hold return assumed alias hx yi true add return assumed alias hx yi worklist 
acceptable requires done possible hx yi hx yi necessary 
performing strictly speaking means may hold exit hx yi true may hold return assumed alias hx yi true possible assumed alias 
necessary sufficient may hold return hx yi true 
conjunction know half true doing hx yi prefer hx yi may hold exit aa hx yi 
keeping set true assumption exit node assumed alias pair true assumption exit aa fhx yi hold exit aa hx yi trueg easily consider interesting hx yi 
trick may hold chapter initialize constant time 
set may hold exit aa hx true add hx exit aa 
iff may hold exit aa hx yi true need processing may hold call assumed alias ha bi true reverse order 
fortunately case process exit node corresponding call node captured alias exit implies chapter 

assume visible called procedure corresponds rule analogous case visible called procedure need fill non visible exit get action may hold call assumed alias ha bi aa nv bind call ha bi hx yi exit aa assume contains non visible nv apply trans non visible may hold return assumed alias hx yi false set may hold return assumed alias hx yi true add return assumed alias hx yi worklist 
may case call site procedure assumption aa produced entry called procedure earlier iteration alias algorithm 
complex effects return nodes sufficient single level pointers allowed sufficient general case 
general possible alias non visible see 
handle case creation called procedure alias non visible object names 
special case may hold assumed aliases may hold exit ho non visiblei ho non visiblei nv represents fact aliased non visible object name aliased non visible object name path entry procedure path exit nv non visible portion represents aliased nv non visible portion represents 
show may hold represent stores 
point reader expected able understand may holds derived obtainable algorithm simply show may hold represent stores aliases non visible object names 
encoding scheme derive may hold true ffl may hold non visiblei non visiblei non visible non visiblei ffl may hold back bind non visiblei ffl may hold back bind non visiblei fortunately need type may hold exit nodes order handle change slightly 
may hold exit ho non visiblei ho non visiblei nv example non visible 
considering case visible called procedure included alias type exit node reader easily follow example 
int main int ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl entry main call entry exit return exit main creation alias non visible object names ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl call entry exit return may hold may hold may hold may hold may hold may hold may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold may hold may hold may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei may hold non visiblei non visiblei non visible non visible ae may hold non visiblei non visiblei non visible non visible ae may hold may hold may hold implementation quirk 
may hold non visiblei non visiblei true redefined may hold non visiblei non visiblei true non visiblei alias consequences non visiblei 
may hold representation interesting stores add nv ho non visiblei condition necessary nv exit ho non visiblei nv exit ho non visiblei 
handle may hold call assumed alias ha bi correctly need function approximate non visible call node nv non visible name non visible name name aa name aa substitutes non visible name non visible nv substitutes non non visible nv uses assumed aliases name aa name aa establish safe assumed alias condition procedure entry 
function specified appendix discussed implementation theoretically interesting 
action may hold call assumed alias ha bi aa nv bind call ha bi hx yi hx yi condition exit aa contain non visible aa nv may hold call aa alias visible nv bind call alias approximate non visible call hx yi nv nv assumed alias aa assume contains non visible nv apply trans non visible may hold return assumed alias hx yi false set may hold return assumed alias hx yi true add return assumed alias hx yi worklist 
order action efficient need able find aa nv alias may hold call aa alias visible nv bind call alias time linear number aa nv 
data structure back bind true defined follows back bind true call assumed alias aa nv fi fi fi fi fi fi fi alias may hold call aa alias assumed alias nv bind call alias aa object name non visible aa fi fi fi fi fi fi fi alias may hold call aa alias assumed alias bind call alias preceding discussion ignored issue scope variables 
care taken insure aliases appear program points scope object names 
requires simple scope check setting values may hold true 
continue omit check code 
appendix contains final algorithm computing alias call implies node assumed alias possible alias 
alias exit implies exit assumed alias possible alias exit node number successors return nodes 
function simply encodes rules return nodes additional case aliases non visible object names 
encoding analogous alias call implies 
know may hold exit aa hx yi true specifies rule leaving free variable assumed alias see 
alias exit implies presents problems weren addressed alias call implies omit informal description routine 
pseudocode appendix 
may hold return assumed alias hx yi may hold exit hx yi aa may hold exit aa hx yi may hold call assumed alias back bind call aa know may hold exit aa hx yi 
ak implication known may hold exit node alias implies node assumed alias possible alias implications may hold node assumed alias possible alias depends strongly successors 
implications considered separately successor 
examined cases node call exit node successors node call exit statement program possible successors entry return node 
successor call node exit node program statement assignment pointer nodes simply collect may hold information parents 
alias path nodes holds held path parent 
action may hold node assumed alias possible alias simple case successor succ types 
may hold succ assumed alias possible alias false set may hold succ assumed alias possible alias true add succ assumed alias possible alias worklist successor succ assignment pointer case encompasses major intraprocedural affects pointers aliasing 
effects may hold node assumed alias possible alias depends relationship object names possible alias object names involved pointer assignment 
discussion consider succ statement arbitrary object names pointer type necessarily simple variable names 
follows case analysis 
effects possible alias application suitable cases 
cases possible alias hy zi 
assignment preserve alias 
true prefix 
effects alias 
case applicable prefix deref 

effects alias 
case applicable detailed examination cases 

possible alias hy zi prefix cases point object assignment changes value 
example distinct object names node ffl ffi fi fl succ ffl ffi fi fl clearly assignment effects hy zi action case simply may hold succ assumed alias possible alias false set may hold succ assumed alias possible alias true add succ assumed alias possible alias worklist clearly safe approximate 
consider situation node ffl ffi fi fl succ ffl ffi fi fl zi killed pi occurs time 
safety assume path zi holds pi 
third source approximation chapter 
possible alias hy zi prefix deref 
different cases need handled mutually exclusive occur conjunction third 
prefix ii 
prefix iii 
interaction zi known aliases second type approximation chapter 
general effects assignment alias depend prefix 
types effects characterized examples case node ffl ffi fi fl succ ffl ffi fi fl case ii node ffl ffi fi fl succ ffl ffi fi fl si pq si case may hold node assumed alias zi implies may hold succ assumed alias zi may hold succ assumed alias zi 
case ii may hold node assumed alias gives information aliasing occurs succ action may hold node assumed alias hy zi true succ prefix deref prefix prefix case ii prefix case apply trans may hold succ assumed alias hp zi false set may hold succ assumed alias hp zi true add succ assumed alias hp zi worklist aliases prefix consider case iii node ffl ffi fi fl succ ffl ffi fi fl problem existence alias zi succ necessarily follow single alias node 
zi hold entry main node succ pi hz qi hold path entry main node 
unfortunately keep information pairs aliases holding path 
may hold node aa pi may hold node aa hz qi assume may hold aa zi alias holds succ case ii qi holds regardless alias situation node 
prefix prefix case ii prefix case apply trans may hold succ assumed alias hp zi false set may hold succ assumed alias hp zi true add succ assumed alias hp zi worklist aa hp vi may hold node aa hp vi true case iii text contains non visible prefix order apply case iii need hy zi hp vi hold path 
prefix true possible 
example 
path node hp vi holds redefined succ alias hy hold time 
prefix contained non visible safely assume non visible represent object name 
apply trans safely alias succ aa assumed alias action may hold node assumed alias hy zi successor succ node prefix deref order solution safe 
extend action assumed alias hy zi prefix deref account situation 
new action appears 
notable features deserve explanation 
function safely alias defined follows safely alias node aa aa safely alias invoked know hon holds path node 
know assumptions aa aa necessary 
allow multiple assumptions routine safely approximates situation 
assumptions contain non visible special case alias components contain non visible discussed 
assumptions individually necessary safely chosen 
assumption contains non visible assumption 
second data structure maintained aa hp vi may hold node aa hp vi true implemented efficiently similarly 
action correctly may hold node aa hp vi true may hold node aa hy zi prefix deref action handle case true opposite order see 

possible alias hp vi cases consider simple effects done hp vi 
ii 
secondary effects done hp vi 
iii 
interaction hp vi known aliases nd type approximation chapter 
effects hp vi characterized example node ffl ffi fi fl succ ffl ffi fi fl case may hold node assumed alias hp ui implies may hold succ assumed alias hp ui prefix may hold succ assumed alias ui 
case ii alias oi node general implicitly killed hasn explicitly mentioned examination actions show alias oi node effects succ 
case hp ui holds path node ui killed assignment account 
case iii effect may hold node assumed alias hp ui comes handling half case iii 
may hold node assumed alias zi true node ffl ffi fi fl succ ffl ffi fi fl case 
action 
analogous cases data structure maintained implement hy zi aa may hold node aa hy zi prefix deref prefix efficiently 
may alias computing may alias may hold extremely simple may alias node aa may hold node aa pa trueg prefix want create qi reason want create 
ha bi alias consequences hp vi case ii provided prefix prefix alias consequences qi case may hold succ assumed alias ha bi false set may hold succ assumed alias ha bi true add succ assumed alias ha bi worklist aa hy zi may hold node aa hy zi prefix deref prefix prefix deref signals case iii account 
prefix saying account cases equivalent example 
case need relationship shifted 
contains non visible prefix rules effects cases equivalent example apply trans safely alias succ assumed alias aa action may hold node assumed alias hp vi successor succ node clearly computed time linear size may hold solution 
fact clever data structure may hold additional computation space needed get solution may alias 
chapter theoretical empirical results ideally able theoretical claims speed precision algorithm 
worst case algorithm precise fast 
fortunately worst case assumptions fairly contrived hopes average case precision speed 
programs complex subtle allow average case theoretical analysis 
built prototype implementation algorithm observe performance 
chapter starts theoretical examination worst case precision algorithm 
discuss implementation algorithm empirically compare solution weihl solution 
report empirical data size interprocedural may alias conditional may alias solutions timings precision interprocedural may alias solution 
theoretical precision possible definition precision safe algorithm analyzing program precision solution gj solution gj algorithms limiting programs object names dereferences definition 
algorithm landi alias ha bi limited object name represents just ha bi aliases ha bi limited representation places landi refer algorithm chapter 
definition expand limited alias possible aliases represent 
criteria program recursive data structures solution sizes precise algorithm infinite 
limiting deal infinite sets object names apply notion precision 
limit alias solution node omega ff fi fi fi fi fi fi fi fi fi fi fi fi fi fi node ha bi alias solution limited representation limited representation alternate definition precision safe algorithm analyzing program precision fa solution pg solution pg programs object names precise solution limiting constant fewer dereferences precision precision 
worst case algorithm imprecise 
shows construct worst case example approximation algorithm arbitrary program aliases algorithm find program point aliases pad program number statements affect aliasing 
additional statement adds jsj aliases solution precise solution 
padded program size omega including additional statements added statement aliases reported aliases precise solution precision landi 
claim worst case algorithm lemma approximation algorithm better worst case lemma 
worst case program contrived preliminary empirical measurements precision algorithm promising see chapter 
true explained proof lemma 
node precise may alias node may alias node int omitting reflexive aliases int part malloc malloc malloc malloc fh big fh bi big fh dig fh dig bi bi di ci di bi bi bi di ci di bi di null fh di big di bi di null fh dig part ii fh dig fh bi ng fh di ng fi fi fi fi fi fh big null fh di ng fi fi fi fi fi fh dig null fh bi ng fi fi fi fi fi number program point aliases precise solution may alias number aliases may alias program yields imprecise results lemma program size limited object names involved non reflexive alias precise solution precision landi 
algorithm reports aliases omega limited alias pairs precise solution 

omega alias pairs precise solution 
alias pair object names 
object names non reflexive aliases alias pairs 

distinct object names involved alias pair reported algorithm algorithm reports reports point specific aliases 
worst possible case reported aliased non reflexive alias pairs program point 

consider programs assumption null holds 
show report object name alias alias precise solution 
need consider aliases contain object names may appeared alias 
sufficient program execution time object name appears alias 
trivially time appeared alias 
places algorithm alias involving object name appeared alias created ffl statements create aliases alias consequences qi assumption aliases precise solution 
ffl statements create aliases alias consequences vi precise solution assumption ffl pointer formal passed actual create aliases alias consequences ai precise solution assumption 
unfortunately assumption null doesn hold program equal easy remove assumption algorithm case easily prove 
algorithm reports aliases 
lemma alias approximation algorithm exists program size limited object names involved non reflexive alias precise solution precision omega 
reports omega aliases aliases precise solution 
proof stems understanding just worst case algorithm 
consider code part ii 
aliases hold entry loop time easy see aliases hold loop terminates aliases hold loop 
alias di holds entry loop time fh dig fh bi ng fh di ng fi fi fi fi fi fi fi precise alias solution program point part ii null holds aliased null holds aliased 
proof follows ffl di holds path di node di di di di ffi di version algorithm efficient 
di da di ffi di di da ffi di dc di wx di da ffi ffl di holds path di node di di ffi di di ffi di da di ffi di di da ffi path di dc di wx di da ffi di di wx ffi di di ffi di di ffi di di ffi ffl bi holds path bi node bi di da ffi bi dc bi ffi bi wx bi dc ffi bi bi wx ffi bi bi ffi bi bi ffi path bi bi da bi ffi ffl holds path node bi ffi ffi da ffi da ffi dc ffi wx da ffi wx ffi ffi ffi ffi code part ii padded size statements affects aliasing aliases aliases hold code executed alias di holds code executed 
approximate algorithm definition able produce erroneous alias program produces exit program 
isn variable simply assign part ii 
assume part ii variables 
consider program followed statement null pointer variable kills real aliases destroy alias di algorithm safe follow part ii 
approximate algorithm report omega aliases aliases number aliases original constant independent prototype algorithm chapter implemented algorithm finds aliases language reduced version main attributes handled algorithm union types nested structures casting pointers functions exception handling 
omissions theoretically difficult handle complicate implementation 
require theoretical examination 
allow arrays pointer arithmetic deal simple naive level 
icfg building fortunate access ptt program developed siemens research 
siemens pande michael michael wagner siemens assistance ptt 
ptt generates address code source builds icfg address code 
superficially changes notion number program points number variables address code version temporaries 
general aliasing patterns remain source 
implementation differs slightly algorithm chapter 
difference non visible 
chapter non visible object name call node get mapped non visible entry node called procedure 
implementation simply replace variable name non visible object name non visible 
example visible called procedure non visible entry node called procedure map non visible 
reason simply alias object name non visible object represented alias casting malloc problem implementation 
described chapter alias non visible object represented hw non visiblei non visible hw non visiblei non visible implementation representation allowed 
analyzing programs chapter empirical data documenting algorithm behavior programs 
restrictions constructs handle limitations parser couldn analyze source directly therefor modified sources ways ffl parser handle programs single source file 
multiple file programs combined single file 
ffl parser difficulties statements resolved hand 
ffl parser isn equipped resolving undefined routines lint libraries usr lib lint lc unix systems 
resolution performed hand 
ffl handling function variables turned restrictive solved function variables hand transformed code replacing calls function variables calls possible values function variables 
fortunately programs examined didn complicated usage function variables 
ffl assumed programs exception handling exceptions effect alias solution 
necessarily safe assumption shouldn invalidate observations chapter 
optimizations implementation demonstrated majority time implementation comes copying alias nodes icfg reaches created 
substantial room execution time improvement doing certain amount preprocessing icfg eliminating redundant copying 
sections give timing results prototype implementation meant indication current efficiency algorithm 
performed optimization algorithm chapter 
consider statement program isn assignment pointer example printf 
statement affects aliasing alias solution simply union predecessors solutions 
nodes simply remember solution union predecessors solutions remove icfg avoid redundant copying 
currently implementing optimization obtaining timings reported chapter 
pointer assignment kind statement introduce aliases node immediate predecessor node prevent propagation alias immediate predecessor 
assignment alias ha bi prefix deref false prefix false similar restrictions ha bi holds path holds path immediate predecessor 
say group statements head node node immediate predecessors know occur group know aliased aliased node optimize code follows assume occur ffl want know may hold aa ha bi check may hold aa ha bi true 
ffl find may hold aa ha bi passing information ha bi successors pass information successors removing adding successors predecessor successor lists 
call value parameter bindings thought assignment statements 
simplicity assume intraprocedural portion icfg 
mean object name lhs pointer assignment prefix false object name rhs pointer assignment prefix deref false 
empirical comparison weihl algorithm number aliases unfortunately directly compare alias solution weihl solution find program point specific aliases weihl 
define program aliases program aliases fha bi node icfg ha bi may alias table compare size program aliases solution may alias computed algorithm versus number aliases reported weihl algorithm 
programs analyzed weihl algorithm justify development new approximation algorithm lr short description program 
expected weihl algorithm reports program aliases algorithm 
cases weihl reported times number aliases reported programs table average weihl reported times aliases weihl algorithm object names limited 
implementation weihl algorithm comparison value time compare time algorithm versus weihl algorithm unfortunately implementation weihl algorithm lend timing 
weihl algorithm basically stage algorithm 
set affect initialized source 
second aliases computed transitive closure alias affect ffi affect 
able time second stage calculation large programs dominates execution time 
table compare time algorithm versus time weihl algorithm second stage 
lr number aliases weihl reported twice reported aliases counted twice ha bi hb ai 
number statistically significant 
meant claim programs simply observation programs table 
program lines weihl program aliases weihl program aliases ul compress loader learn ed diff tbl lex table number aliases comparison weihl comparison prototype implementations meant give rough feel timing differences implementations optimized 
expected algorithm takes longer weihl algorithm 
case algorithm faster weihl algorithm cases take twice time weihl algorithm 
programs table average algorithm uses times time 
table time number aliases ratios 
ul ed tbl timing ratios higher average 
compute point specific aliases time algorithm takes approximately proportional number point specific aliases 
ul ed tbl ratio number point specific aliases algorithm number aliases reported weihl largest 
may alias solution empirically measured solution size remaining sections chapter various empirical results experiments programs 
suite superset programs ratios ed tbl ul lex compress diff learn loader program lines weihl program aliases program aliases weihl ul compress loader learn ed diff tbl lex table time comparison weihl number aliases time program lines weihl program aliases program aliases weihl ul compress loader learn ed diff tbl lex table number aliases time comparison weihl compared weihl algorithm chapter 
historical accident implementation weihl algorithm restrictions implementation algorithm compare programs weihl algorithm 
programs came pool available programs collected ongoing empirical study structure programs rp 
programs selected pool met restrictions ffl program size larger lines 
ffl function variables simple resolve hand 
ffl little pointer casting 
ffl nested structures 
sample means large draw general algorithm behavior large indicate algorithm performs limited domain programs 
contains short description programs descriptions rp 
implementation defined terms limiting run time constant studies include comparison algorithm behavior program different values tried 
unfortunate choice implementation object names limited experiments programs ffl assembler loader poker simulator ffl table gives size may alias solution algorithm 
interesting aliases node max aliases node columns table 
aliases node gives average number aliases program point program 
ranges average 
max aliases 
average included 
program description allroots find roots polynomial assembler sic assembler bec compress unix compress data diff unix show file differences fast diff unix diff ed unix line editor football football statistics program simple translator learn unix lex generator lexical analyzer lex scanner subset loader sic loader bec unix helps maintain programs poker game cards variant poker simulator sic machine simulator debugger bec tbl unix format tables troff tp tape formatting ul unix underline description programs empirical study icfg may aliases max aliases program nodes aliases node node allroots poker ul lex loader compress tp learn ed assembler diff simulator football tbl lex highlighted numbers valid precise solution 
table size may alias solution node gives maximum number aliases program point program 
ranges average 
numbers indicate number aliases individual program points small implies information provided precise useful 
example aliases program point set variables modified statement stores indirectly pointer small 
table gives information table ranging various values gives idea increasing affects alias solution 
unexpected observation table programs solutions size 
occurred omitted solution 
programs football tbl solution raise average 
size 
general expect size reported alias solution vary directly value program aliases bi bi hold paths program point alias bi needs reported reported 
examination table shows compress ed tbl lex number aliases reported decreased increased 
compress tbl show smaller number aliases contained statement assignment pointer gets limited pointer assignment 
case illustrated example type int gets limited assignment pointer 
assignment bi holds path executed bi killed assignment 
alias represented bi killed assignment 
suspect causes decrease aliases ed lex aliasing complex verify claim hand 
expected programs sort recursive data structure data set case 
allows strong claims 
chapter able claims precision solution programs table 
conclude programs solution algorithm precise solution defined chapter 
highlighted entries tables chapter represent precise information aliasing solution 
measurement empirical precision chapter mentioned sources approximation 

program contains recursive data structures potentially infinite number objects aliases 
represent possible objects finite polynomial number objects 

may aliases max aliases program aliases node node nodes allroots poker ul lex loader compress tp learn ed assembler diff simulator football tbl lex highlighted numbers valid precise solution 
table size may alias solution yi 
ff omega hp qi yi hp qi yi occur path yi holds path extended conclude may true 

zi 
ff omega hp qi zi path immediate predecessor zi holds hp qi hp zi zi holds path extended paths immediate predecessors zi holds hp qi holds zi necessarily hold path case safety assume zi holds path 
ff omega hp ui hp vi normally hold path assigning assigning need hold 
example hp ui hp vi hold path necessarily hold 
lemma states assumption null cases sources imprecision algorithm 
path hp ui holds modified algorithm count cases 
having true false lattice lattice 
implementation may hold node aa pa ffl iff may hold node aa pa false ffl may hold node aa pa true case ffl may hold node aa pa implied may hold node aa pa may hold node aa pa ffl define es may hold computed limit constant es fi fi fi fi ae node pa fi fi fi fi aa may hold node aa pa fi fi fi fi fi fi fi fi fi fi node pa fi fi fi fi fi fi fi aa may hold node aa pa may hold node aa pa fi fi fi fi fi fi fi aforementioned types approximations fourth type occur claim ae node pa fi fi fi fi aa may hold node aa pa oe limit precise solution true type approximation matter limit alias result implied type approximation value 
alias marked limit precise solution lemma assumption type approximations type approximation occur 
es precision landi 
es bound precision solution 
discussion true greater maximum number dereferences object name pointer type syntactically appears remember greater equal maximum number dereferences object name alias precise solution landi precision landi see chapter 
lhs rhs assignment actual procedure call 
implementation dimensional arrays integers assignment represented 
see statement considered pointer assignment 
certainly introduce imprecision accounted es 
table presents empirical precision results programs examining 
programs get bound precision solution programs able find precise solution 
general precision results encouraging 
may alias solution size vs conditional may alias size originally research goal design algorithm computing may alias 
decided solve conditional may alias trivially extract may alias 
may alias problem want solve conditional may alias solution size may alias solution compute store 
table indicates case terms number relations computed 
maximum ratio conditional may alias solution may alias solution average 
indicated prl additional information conditional may alias lead precise results problems reaching definitions 
conditional may alias useful may alias double relation size 
limit implementation fundamental algorithm 
get bound able solve aliases sufficiently large icfg may aliases es program program nodes allroots yy yy yy yy yy poker ul yy lex yy yy loader compress yy tp yy learn yy ed yy assembler diff yy simulator football yy tbl yy lex yy es program precision landi program yy es program precision landi program table precision may alias solution may may may hold program aliases hold may alias nodes allroots poker ul lex loader compress tp learn ed assembler diff simulator football tbl lex table size may alias solution vs size may hold algorithm time performance theoretical issues designing algorithm trying complexity size solution 
possible worst case 
devised algorithm elements conditional may alias solution value true guarantee constant amount ffl bind uses doubly nested loops formal actual lists 
lists tend grow slowly program size 
considered constant size ck 
ffl alias exit implies appendix contains loops executed call site procedure contains exit node 
problem number true conditional may aliases generated loop number call sites 
general expect case loop replaced depends number true cases generated number call sites 
ffl multiple ways may hold node aa pa generated 
possible done different way generated 
node return node problem number different ways may hold node aa pa true fi fi fi fi ae fi fi fi fi nodeae edge icfg fi fi fi programs number edges order number nodes amortized sense constant number ways conditional may alias true 
node return node simplicity ignoring visibility may hold node aa pa holds exit pa aa assumed holds exit aa pa holds call aa back bind call aa number different ways may hold node aa pa true hold exit aa pa define max possible aliases pa fi fi fi fi fi fi fi fi fi fi fi aa fi fi fi fi fi fi fi fi fi fi fi node node icfg may hold node aa pa true fi fi fi fi fi fi fi fi fi fi fi unfortunately table indicates max assumed constant 
table sorted size may hold easier observe max assumed increases may hold increases 
appear slowly growing function true conditional may aliases 
hope algorithm running behavior linear size conditional may alias solution 
table contains information table different values sorted size may hold 
cases max assumed increases increases max assumed decreases 
max assumed increase alias holds conditional different assumed aliases get limited alias program fragment 
temp temp null temp temp temp hi holds path conditional hi hi hi holding entry max assumed decrease smaller multiple aliases limited alias assumed alias sets larger unioned 
wanted claim algorithm performs linearly size may hold theoretical justification claim 
decided conditional may aliases program may hold max assumed avg assumed allroots poker lex compress ul tp diff lex learn loader ed tbl football simulator assembler max assumed max possible aliases pa fi fi fi fi fi fi fi aa fi fi fi fi fi fi fi node node icfg may hold node aa pa true fi fi fi fi fi fi fi avg assumed avg possible aliases pa fi fi fi fi fi fi fi aa fi fi fi fi fi fi fi node node icfg may hold node aa pa true fi fi fi fi fi fi fi table number assumptions alias program may hold max assumed avg assumed allroots poker lex compress ul tp diff lex learn loader ed tbl football simulator assembler max assumed max possible aliases pa fi fi fi fi fi fi fi aa fi fi fi fi fi fi fi node node icfg may hold node aa pa true fi fi fi fi fi fi fi avg assumed avg possible aliases pa fi fi fi fi fi fi fi aa fi fi fi fi fi fi fi node node icfg may hold node aa pa true fi fi fi fi fi fi fi table number assumptions alias program may hold cpu time may hold sec allroots poker lex compress ul tp diff lex learn loader ed tbl football simulator assembler table timings algorithm examine empirical behavior algorithm 
table timings algorithm programs 
table sorted size may hold lists may hold sec 
algorithm linear size may hold sec independent size may hold 
table indicate true 
indication algorithm may linear size may hold table may hold sec vary significantly changes program size may hold changes significantly 
list may hold may hold sec sorted may hold sec table 
indicate properties program important size may hold determining may hold sec 
program may hold cpu time may hold sec allroots poker lex compress ul tp diff lex learn loader ed tbl football simulator assembler table timings algorithm program sec poker poker poker assembler assembler loader assembler simulator simulator loader simulator loader diff diff diff learn learn lex lex learn compress compress lex allroots allroots program sec allroots compress ed tbl tbl tbl tbl lex lex lex tp tp ul ed ul ul tp ed football football football football table may hold sec chapter summary thesis thesis divided major areas theoretical investigation alias problem safe interprocedural may alias algorithm theoretical empirical examination algorithm 
interrelated contributed useful results 
classification alias problem presence various alias mechanisms yielded understanding aliasing difficult levels indirection 
importantly lent insight method tracking interprocedural alias information summarizing runtime stack single assumed alias 
gave feel types approximation safe algorithm 
useful understanding approximation algorithms possible empirically track imprecision algorithm 
research yielded precise algorithm interprocedural flow sensitive data flow problem 
development safe algorithm solving interprocedural may alias promising 
justified conditional may alias method interprocedural aspects alias problem 
conditional may alias precise single level pointers developed classification portion thesis 
longer precise presence general pointers safe introduce imprecision attributable existence alias may exist intraprocedural reasons 
theoretical empirical investigation algorithm showed definition precision worst case algorithm precise algorithm 
empirically yielded encouraging precision results showed great improvement extant technique wei 
main thrust thesis development algorithm approximating aliases presence pointers initial results promising algorithm means word subject 
incomplete list additional needs done follows 
ffl precision results thesis encouraging timing results initial measurements 
optimizing algorithm prototype implementation 
intend obtain additional timings 
ffl limiting alias solution sufficient certain data flow problems appears adequate family programs regardless problem hand 
need investigate possibility mechanisms limiting representation dynamic stores 
ffl continue generalize research prl investigating utility conditional may alias various data flow problems especially mod 
ffl wish remove restrictions placed especially allow presence function variables 
ffl want extend precise algorithm interprocedural alias presence single level pointers safe algorithm presence general pointers 
need investigate utility information 
ffl wish investigate alias analysis object oriented programming paradigms example pointers class members ls 
appendix dictionary functions address type type returns type objects point type 
chapter alias consequences alias set aliases implied alias 
algorithm computing consequences alias 
chapter alias type alias type object referred object names alias 
function correctly accounts limiting 
chapter amp object name object name object name object name start error 
chapter apply trans object name object name object name object name object name type prefix object name object name true 
function applies object name sequence dereferences field accesses necessary transform object name object name returns true iff dereference occurs sequence 
examples apply trans 
chapter approximate non visible call node nv non visible name non visible name name aa name aa substitutes non visible name non visible nv substitutes non visible name non visible nv uses assumed aliases name aa name aa establish safe assumed alias condition procedure entry 
appendix back bind true call assumed alias aa nv fi fi fi fi fi fi fi alias may hold call aa alias assumed alias nv bind call alias aa object name non visible aa fi fi fi fi fi fi fi alias may hold call aa alias assumed alias bind call alias chapter see back bind true 
deref type true iff type legally dereferenced casting 
chapter deref object name removes object name starts returns object name 
corresponds rule 
chapter deref type type type dereferenced deref type returns type objects type may point 
chapter field access object name field name object name field name object name start error 
corresponds rule 
chapter field type type field type structure field field type returns type field 
chapter field field type true iff type structure type field legal field type 
chapter limited object name true iff object type object name dereferenced object name contains dereferences object name start address operator 
chapter prefix object name object name returns true iff object name transformed object name possibly empty sequence dereferences field accesses applications rule rule 
chapter prefix deref object name object name returns true iff object name transformed object name sequence dereferences field accesses applications rule rule dereference 
chapter struct type true iff type structure 
chapter may hold aa ha bi true iff ha bi holds path entry entry procedure containing assuming path entry main entry assumed alias aa holds path entry main entry aa holds 
chapter object type object name type data stored objects object name object name start 
name object name name address type name 
chapter safely alias node aa aa safely alias know hon holds path node 
know assumptions aa aa necessary 
allow multiple assumptions routine safely approximates situation 
assumptions contain non visible special case alias components contain non visible discussed 
assumptions individually necessary safely chosen 
assumption contains non visible assumption 
simple object name variable object name just variable rule 
chapter value type attribute object name obtained 
true assumption exit aa fhx yi hold exit aa hx yi trueg chapter see true assumption 
appendix intraprocedural aliasing presence single level pointers inductive proofs iteration fixed point calculation appendix 
proofs assume values function th iteration computed values function th iteration 
building sppag pointer fv non pointer variable 
set object names program may aliases 
possible aliases cfg ae construct sppag ae holds ftrue falseg 
ha bi ha bi possible fae specification holds 
ha bi 
dereferenced pointer add ae ha bi ae holds ha bi holds ha bi true 
ae dereferenced pointer add ae ha bi ae holds ha bi holds ha bi false 
assignment pointer dereferenced pointer ae nae add ha bi ha bi ae holds ha bi nae holds ha bi holds ha bi nae holds ha bi 
pointer assignment dereferenced pointer ae nae add qi pi ae holds pi nae holds qi holds pi nae holds qi nae add bi bi ae holds bi nae holds bi holds bi nae holds bi nae add ha bi ha bi ae holds ha bi nae holds ha bi holds ha bi nae holds ha bi 
pointer assignment dereferenced pointer ae add ae pi ae holds pi holds pi true nae add hv bi bi ae holds bi nae holds hv bi holds bi nae holds hv bi nae add ha bi ha bi ae holds ha bi nae holds ha bi holds ha bi nae holds ha bi 
pointer assignment malloc null dereferenced pointer ae add ae pi ae holds pi holds pi true malloc false null nae add ae bi ae holds bi holds bi false nae add ha bi ha bi ae holds ha bi nae holds ha bi holds ha bi nae holds ha bi sppag algorithm polynomial time precise may alias cfg ae 
sppag ae holds ftrue falseg specified appendix 
lemma single procedure pointer alias graph sppag polynomial size cfg 
variable program contributes object name may involved aliases pointer may aliases non pointer may aliased 
number possible aliases pairs program variables program variables number possible aliases 
poss aliases jj poss aliases lemma sppag built cfg polynomial time 
specification sppag appendix lends algorithm building sppag 
node requires 
lemma fixed point calculation holds holds sppag takes time polynomial size program 
follows lemma observation node holds holds change value 
lemma path cfg aen ha bi holds path holds ha bi true fixed point calculation 
proof induction path length 
basis path simply ae 
reflexive aliases variables hold 
holds ae ha ai true rule appendix 
ae ae ha ai ae rule fixed point calculation set holds ae ha ai true 
lemma holds 
induction hypothesis lemma holds induction step ha bi hold aen 
dereferenced pointer holds ha ai true definition holds ae ha ai ae 
assignment pointer dereferenced pointer ha bi holds aen hold aen induction hypothesis holds ha bi true 
holds ha bi nae holds ha bi nae holds ha bi true 

pointer assignment dereferenced pointer qi hold aen definition hold means name location 
true long null 
induction hypothesis holds qi true 
holds pi nae holds qi 
holds pi true 
bi hold aen induction hypothesis holds bi true 
holds bi nae holds bi 
holds bi true 
ha bi hold aen induction hypothesis holds ha bi true 
holds ha bi nae holds ha bi holds ha bi true 

pointer assignment dereferenced pointer definition holds pi true ae pi ae 
hv bi hold aen induction hypothesis holds hv bi true 
holds bi nae holds hv bi 
holds bi true 
ha bi hold aen induction hypothesis holds ha bi true 
holds ha bi nae holds ha bi holds ha bi true 

pointer assignment malloc null dereferenced pointer case malloc definition holds holds pi true ae pi ae 
ha bi hold aen induction hypothesis holds ha bi true 
holds ha bi nae holds ha bi holds ha bi true 
lemma holds ha bi true fixed point calculation path cfg aen ha bi holds 
proof number iterations fixed point algorithm 
basis initialization 
holds initially false definition see 
lemma holds vacuously 
induction hypothesis lemma holds iterations fixed point algorithm 
induction step holds ha bi true iteration 
dereferenced pointer lemma trivially holds 

ae dereferenced pointer definition holds ha bi true 

assignment pointer dereferenced pointer ae holds ha bi nae holds ha bi nae holds ha bi true iteration 
induction hypothesis path aen ha bi holds 
ha bi hold path aen mn 

pointer assignment dereferenced pointer ae holds pi nae holds qi nae holds qi true iteration 
induction hypothesis path aen qi holds 
pi hold path aen mn 
holds bi nae holds bi nae holds bi true iteration 
induction hypothesis path aen bi holds 
bi hold path aen mn 
holds ha bi nae holds ha bi nae holds ha bi true iteration 
induction hypothesis path aen ha bi holds 
ha bi hold path aen mn 

pointer assignment dereferenced pointer ae pi hold paths 
holds bi nae holds hv bi nae holds hv bi true iteration 
induction hypothesis path aen hv bi holds 
bi hold path aen mn 
holds ha bi nae holds ha bi nae holds ha bi true iteration 
induction hypothesis path aen ha bi holds 
ha bi hold path aen mn 

pointer assignment malloc null dereferenced pointer ae ffl malloc pi hold paths ffl null definition impossible holds pi true 
definition impossible holds bi true 
holds ha bi nae holds ha bi nae holds ha bi true iteration 
induction hypothesis path aen ha bi holds 
ha bi hold path aen mn 
theorem exists polynomial time algorithm determining precise intraprocedural may alias sets presence single level pointers 
lemmas imply algorithm takes time polynomial size cfg 
lemmas imply finds precise intraprocedural may alias sets 
sppag algorithm polynomial time precise alias lemma path cfg aen ha bi hold holds ha bi false fixed point calculation 
proof induction path length 
basis path simply ae 
reflexive aliases non dereferenced variables hold 
holds ae ha bi false dereferenced variable rule holds appendix 
ae ae ha bi ae fixed point calculation set holds ae ha bi false 
lemma holds 
induction hypothesis lemma holds induction step ha bi alias hold aen 
dereferenced variable possible reflexive aliases non dereferenced variables hold 

ae dereferenced variable handled basis 

assignment pointer dereferenced variable ae ha bi hold aen hold aen induction hypothesis holds ha bi false 
holds ha bi nae holds ha bi nae holds ha bi false 

pointer assignment dereferenced variable ae qi hold aen induction hypothesis holds qi false 
holds pi nae holds qi 
holds pi false 
bi hold aen induction hypothesis holds bi false 
holds bi nae holds bi 
holds bi false 
ha bi hold aen induction hypothesis holds ha bi false 
holds ha bi nae holds ha bi 
holds ha bi false 

pointer assignment dereferenced variable ae pi aliased paths theorem vacuously holds 
hv bi hold aen induction hypothesis holds hv bi false 
holds bi nae holds hv bi 
holds bi false 
ha bi hold aen induction hypothesis holds ha bi false 
holds ha bi nae holds ha bi 
holds ha bi false 

pointer assignment malloc null dereferenced variable ae null case holds pi false definition 
definition holds holds bi false 
ha bi hold aen induction hypothesis holds ha bi false 
holds ha bi nae holds ha bi 
holds ha bi false 
lemma holds ha bi false fixed point calculation path cfg aen ha bi hold 
proof number iteration fixed point algorithm 
basis initialization 
holds initially true 
lemma holds vacuously 
induction hypothesis lemma holds iterations fixed point algorithm 
induction step holds ha bi false iteration 
dereferenced variable definition holds holds ha ai true 
holds ha ai false 

ae dereferenced variable reflexive aliases variable names hold entry procedure 
lemma follows 

assignment pointer dereferenced variable ae holds ha bi nae holds ha bi nae holds ha bi false iteration 
induction hypothesis path aen ha bi hold 
ha bi hold path aen mn 

pointer assignment dereferenced variable ae holds pi nae holds qi nae holds qi false iteration 
induction hypothesis path aen qi hold 
pi hold path aen mn 
holds bi nae holds bi nae holds bi false iteration 
induction hypothesis path aen bi hold 
bi hold path aen mn 
holds ha bi nae holds ha bi nae holds ha bi false iteration 
induction hypothesis path aen ha bi hold 
ha bi hold path aen mn 

pointer assignment dereferenced variable ae holds pi true definition possibly false 
holds bi nae holds hv bi nae holds hv bi false iteration 
induction hypothesis path aen hv bi hold 
bi hold path aen mn 
holds ha bi nae holds ha bi nae holds ha bi false iteration 
induction hypothesis path aen ha bi hold 
ha bi hold path aen mn 

pointer assignment malloc null dereferenced variable ae ffl malloc holds pi true definition false 
ffl null pi possibly hold 
aliases possibly hold 
holds ha bi nae holds ha bi nae holds ha bi false iteration 
induction hypothesis path aen ha bi hold 
ha bi hold path aen mn 
theorem exists polynomial time algorithm determining precise intraprocedural alias sets presence single level pointers 
lemmas imply algorithm takes time polynomial size cfg 
lemmas imply finds precise intraprocedural alias sets 
appendix interprocedural aliasing presence single level pointers inductive proofs iteration fixed point calculation appendix 
proofs assume values function th iteration computed values function th iteration 
back bind definition back bind call alias pair specifies alias holding aen call forces alias pair hold aen call entry 
back bind call node icfg defined back bind back bind ha bi ha bi visible procedure called ha visible procedure called dereferenced formal corresponding actual dereferenced formal corresponding actual dereferenced formal corresponding actual false local non parameter object name back bind call ha non visiblei specifies alias holding path ae call guarantees aliased non visible object ae call entry 
back bind ha non visiblei ha oi visible called procedure oi dereferenced formal corresponding actual false local non parameter object name proof correctness called call node entry node procedure called lemma call nodes ffl back bind paths aen called considered hold 
ffl possible alias pairs ha bi non visible non visible back bind ha bi false paths aen called ha bi hold 
back bind ha bi hc di paths aen called ha bi holds iff hc di holds aen ffl possible alias pairs ha non visiblei non visible possible object name visible called procedure back bind ha non visiblei false paths aen called aliased non visible object name back bind ha non visiblei hc oi paths aen called aliased non visible object name iff hc oi holds aen proof call nodes 
back bind conditional may alias really absence assumed aliases 
safe assume holds path 

possible alias pairs ha bi non visible non visible back bind ha bi false occurs local non parameter object names 
case paths aen called ha bi hold 
back bind ha bi hc di visible called procedure definition hc di ha bi 
clearly paths aen called ha bi holds iff ha bi holds aen ii 
visible called procedure dereferenced formal actual definition hc di ha clearly paths aen called ha holds iff ha holds aen iii 
dereferenced formal actual dereferenced formal actual definition hc di clearly paths aen called holds iff holds aen 
possible alias pairs ha non visiblei non visible possible object name visible called procedure back bind ha non visiblei false occurs local non parameter object name 
paths aen called aliased 
back bind ha non visiblei hc non visiblei visible called procedure definition hc non visiblei ha non visiblei 
paths aen called aliased non visible object name iff ha oi holds aen ii 
dereferenced formal actual definition hc non visiblei non visiblei 
paths aen called aliased object name iff oi holds aen computable constant time lemma call node alias ha bi back bind ha bi computed constant time 
call node alias hc non visiblei object name visible called procedure back bind hc non visiblei computed constant time 
naive encoding definitions back bind ha bi back bind hc non visiblei yields constant time algorithms 
bind definition bind call alias set specifies paths aen call entry aliases hold assuming aliases alias set hold aen call 
pointer fv non pointer variable 
set object names program may aliases 
possible aliases 
possible aliases set possible aliases 
bind call node icfg possible aliases defined bind bind ha bi bind ha bi bind fi fi fi fi fi fi fi fi fi fi fi pointer formals actuals respectively pointer variable fi fi fi fi fi fi fi fi fi fi fi pointer formal actual visible called procedure pointer variable bind ha bi ae ha bi fi fi fi fi visible called procedure oe ha fi fi fi fi fi fi fi visible called procedure pointer formal actual fi fi fi fi fi fi fi pointer formals corresponding actuals proof correctness called call node entry node procedure called call node 
lemma call node set aliases alias set bind alias set set aliases hold aen called alias set holds aen lemma states consider effect alias alias set separately considering true paths case 
precisely function bind 
non pointer pointer variable aliases hold paths called aliases hold aliases dereferenced pointer formals passed non pointer actual aliases dereferenced pointer formals dereferenced non pointer actuals assuming actual visible called procedure 
obviously captured definition bind 
aliases hold paths called ha bi hold ffl ha bi visible called procedure 
ffl ha visible called procedure pointer formal actual ffl pointer formals corresponding actuals cases captured definition bind ha bi 
computable constant time lemma call node alias set alias set bind alias set computed time polynomial number formals called procedure 
naive encoding definition bind alias set satisfies time constraints 
actual variable dereferenced value precise polynomial time algorithm computing interprocedural may alias sets presence single level pointers terminology pointer fv non pointer variable 
set object names program may aliases 
non visible represents object names visible 
possible aliases visible non assumed possible aliases icfg program exit return node icfg exit node corresponding call return node icfg call node corresponding entry icfg node entry node procedure containing back bind call call call node icfg defined appendix 
back bind call alias pair specifies alias holding call site forces alias pair hold entry called procedure 
ffi ffl equal building pointer alias graph pag icfg ae construct pag ae holds ftrue falseg 
holds node aa pa true iff realizable path entry node node icfg contains number calls returns realizable path aem entry node aa holding means pa hold ffl aem entry node node 
order simply algorithm description proof expand definition holds 
node icfg aa assumed holds node aa false false 
node aa pa fi fi fi fi fi fi fi node aa assumed pa possible aliases fae specification holds 
node ha bi possible aliases aa assumed 
dereferenced pointer reflexive aliases variables hold add ae node aa ha bi ae holds node aa ha bi true 
dereferenced pointer node entry node alias conditionally holds entry node iff assume reflexive alias variable 
add ae node aa ha bi ae holds node aa ha bi true aa ha bi false node exit node path ha bi holds exit node iff held exit node nodeae add aa ha bi node aa ha bi ae holds node aa ha bi nodeae holds aa ha bi consider assumed alias hold paths node call node path ha bi holds call node iff held call node nodeae add aa ha bi node aa ha bi ae holds node aa ha bi nodeae holds aa ha bi node return node visible called procedure procedure call affect alias 
alias holds call iff held call 
add call node aa ha bi node aa ha bi ae holds node aa ha bi holds call node aa ha bi ii 
visible called procedure ha bi holds path node iff ha non visiblei holds exit node non visible hc non visiblei assumed back bind call node hc non visiblei false add exit node hc non visiblei ha non visiblei node aa ha bi ae call node aa back bind call node hc non visiblei node aa ha bi ae holds node aa ha bi hc non visiblei assumed holds exit node hc non visiblei ha non visiblei holds call node aa back bind call node hc non visiblei iii 
visible called procedure ha bi holds path node iff ha bi holds exit node add exit node ha bi node aa ha bi ae hc di assumed non visible back bind call node hc di false add exit node hc di ha bi node aa ha bi ae call node aa back bind call node hc di node aa ha bi ae holds node aa ha bi holds exit node ha bi hc di assumed holds exit node hc di ha bi holds call node aa back bind call node hc di node statement node node assignment pointer path ha bi holds node iff held immediately node nodeae add aa ha bi node aa ha bi ae holds node aa ha bi nodeae holds aa ha bi ii 
node pointer assignment pi holds path node iff qi held immediately node nodeae add aa qi node aa pi ae holds node aa pi nodeae holds aa qi bi holds path node iff bi held immediately node nodeae add aa bi node aa bi ae holds node aa bi nodeae holds aa bi ha bi holds path node iff ha bi held immediately node nodeae add aa ha bi node aa ha bi ae holds node aa ha bi nodeae holds aa ha bi iii 
node pointer assignment pi holds paths node add ae node aa pi ae holds node aa pi true bi holds path node iff hv bi held immediately node nodeae add aa hv bi node aa bi ae holds node aa bi nodeae holds aa hv bi ha bi holds path node iff ha bi held immediately node nodeae add aa ha bi node aa ha bi ae holds node aa ha bi nodeae holds aa ha bi iv 
node pointer assignment malloc null add ae node aa pi ae holds node aa pi true node malloc false node null aliased path node add ae node aa bi ae holds node aa bi false ha bi holds path node iff ha bi held immediately node nodeae add aa ha bi node aa ha bi ae holds node aa ha bi nodeae holds aa ha bi algorithm computing precise may alias sets presence single level pointers pointer fv non pointer variable 
set object names program may aliases 
possible aliases 
possible aliases set possible aliases 
define lattice hec powerset possible aliases possible aliases bind aa call node icfg aa possible aliases defined appendix 
entry node icfg entry node procedure containing node icfg define may alias 
may alias ae 
entry node may alias nae bind may alias 
may alias ha bi fi fi fi fi fi fi fi fi fi fi fi non visible holds ha bi true aa may alias entry holds aa ha bi true algorithm 
icfg ha bi possible aliases aa assumed initialize holds aa ha bi false 

calculate fixed point holds 

icfg initialize may alias 

calculate fixed point may alias 
proof lemma lemma pointer usage restricted single level pointers ffl realizable paths entry node procedure containing number calls path equals number returns ffl possible alias pairs ha bi alias pairs set fa am holding execution path implies ha bi holds assuming aliases executing path forces ha bi hold assuming alias pair executing path forces ha bi hold proof induction path length 
basis entry node 
aliases assumed reflexive aliases variables dereferenced pointers hold path assumption case alias holds satisfies lemma 
second case alias assumption necessary 
induction hypothesis lemma holds induction step 
entry node basis applies 

call exit node ha bi ha bi holds assuming ha bi holds assuming induction hypothesis assumption forces ha bi hold true 
return node visible called procedure 
call corresponds return ha bi ha bi holds assuming ha bi holds assuming induction hypothesis assumption forces ha bi hold true 
visible called procedure 
call corresponds return set alias pairs hold entry node assuming ha bi hold assuming ha non visiblei non visible hold assuming shorter meets requirements lemma induction hypothesis assuming sufficient 
lemma back bind hold assuming order ha bi hold assumptions 
lemma follows induction shorter meets requirement lemma 
visible called procedure 
call corresponds return set alias pairs hold entry node assuming ha bi hold assuming ha bi hold assumption case possible non visible involved 
assuming shorter meets requirements lemma induction hypothesis assumption necessary case assumption necessary ha bi hold ii 
assuming sufficient 
lemma back bind hold assuming ha bi hold assumptions 
lemma follows induction shorter meets requirement lemma 

statement node assignment pointer ha bi ha bi holds assuming ha bi holds assuming induction hypothesis assumption forces ha bi hold true 
pointer assignment ha bi pi holds assuming qi holds assuming induction hypothesis assumption forces qi hold true ii 
bi holds assuming bi holds assuming induction hypothesis assumption forces bi hold true iii 
ha bi holds assuming ha bi holds assuming induction hypothesis assumption forces ha bi hold true 
pointer assignment ha bi pi holds paths regardless alias assumptions 
pi holds alias assumptions ii 
bi holds assuming hv bi holds assuming induction hypothesis assumption forces hv bi hold true iii 
ha bi holds assuming ha bi holds assuming induction hypothesis assumption forces ha bi hold true 
pointer assignment malloc null malloc pi holds paths regardless alias assumptions 
pi holds alias assumptions ii 
possible 
iii 
ha bi holds assuming ha bi holds assuming induction hypothesis assumption forces ha bi hold true proof theorem cfg ae 
pag ae holds ftrue falseg specified appendix 
lemma pointer alias graph pag polynomial size cfg 
variable program contributes object name may involved aliases pointer may aliases non pointer may aliased 
number possible aliases pairs program variables program variables number possible aliases 
assumed possible aliases jj assumed possible aliases lemma pag built cfg polynomial time 
specification pag appendix lends algorithm building pag 
node requires max assumed 
lemma fixed point calculation pag polynomial time 
follows lemma observation node holds change value 
lemma holds node aa pa true iff realizable path entry node node icfg contains number calls returns realizable path aem entry node aa holding means pa hold ffl aem entry node node 
proof lemma induction number iterations fixed point algorithm assume holds node aa ha bi true ith iteration 
basis initialization 
holds initially false 
direction lemma holds iteration 
induction hypothesis assume direction lemma holds iterations induction step 
dereferenced pointer reflexive aliases variables hold paths 

dereferenced pointer node entry node definition holds node aa ha bi true iff aa ha bi 
case direction lemma clearly satisfied 
consider assumed alias hold paths node exit node holds node aa ha bi nodeae holds aa ha bi nodeae holds aa ha bi set true earlier iteration 
induction hypothesis path entry satisfies lemma holds aa ha bi 
entry entry node ffi node satisfy lemma holds node aa ha bi 
node call node argument exit nodes 
node return node visible called procedure holds node aa ha bi holds call node aa ha bi holds call node aa ha bi set true earlier iteration 
induction hypothesis path entry call node call node satisfies lemma holds call node aa ha bi 
realizable path entry exit node exit node 
entry call node entry node ffi ffi node satisfy lemma holds node aa ha bi 
ii 
visible called procedure holds node aa ha bi hc non visiblei assumed holds exit node hc non visiblei ha non visiblei holds call node aa back bind call node hc non visiblei holds node aa ha bi true hc non visiblei holds exit node hc non visiblei ha non visiblei holds call node aa back bind call node hc non visiblei true earlier iterations 
induction implies path entry exit node exit node hc non visiblei holds path entry exit node ha non visiblei holds ffl induction implies path entry node call node aa holds path entry node back bind call node hc non visiblei holds ffl lemma imply ffi ffi node path satisfies lemma holds node aa ha bi 
iii 
visible called procedure holds node aa ha bi holds exit node ha bi hc di assumed holds exit node hc di ha bi holds call node aa back bind call node hc di holds node aa ha bi true holds exit node ha bi set true previous iteration hc di holds exit node hc di ha bi holds call node aa back bind call node hc di true earlier iterations 
case induction path entry exit node exit node path entry exit node ha bi holds ffl path entry node call node realizable equal number calls returns ffi ffi node satisfies lemma holds node aa ha bi 
case induction implies path entry exit node exit node hc di holds path entry exit node ha bi holds ffl induction implies path entry node call node aa holds path entry node back bind call node hc di holds ffl lemma imply ffi ffi node path satisfies lemma holds node aa ha bi 
node statement node node assignment pointer holds node aa ha bi nodeae holds aa ha bi nodeae holds aa ha bi entry node entry call node 
set true earlier iteration 
induction hypothesis path entry satisfies lemma holds aa ha bi 
entry entry node ffi node satisfy lemma holds node aa ha bi 
ii 
node pointer assignment holds node aa pi nodeae holds aa qi nodeae holds aa qi set true earlier iteration 
induction hypothesis path entry satisfies lemma holds aa qi 
entry entry node ffi node satisfy lemma holds node aa pi 
holds node aa bi nodeae holds aa bi nodeae holds aa bi set true earlier iteration 
induction hypothesis path entry satisfies lemma holds aa bi 
entry entry node ffi node satisfy lemma holds node aa bi 
holds node aa ha bi nodeae holds aa ha bi nodeae holds aa ha bi set true earlier iteration 
induction hypothesis path entry satisfies lemma holds aa ha bi 
entry entry node ffi node satisfy lemma holds node aa ha bi 
iii 
node pointer assignment pi holds paths node 
path entry node node realizable equal number calls returns satisfies lemma holds node aa pi 
holds node aa bi nodeae holds aa hv bi nodeae holds aa hv bi set true earlier iteration 
induction hypothesis path entry satisfies lemma holds aa hv bi 
entry entry node ffi node satisfy lemma holds node aa bi 
holds node aa ha bi nodeae holds aa ha bi nodeae holds aa ha bi set true earlier iteration 
induction hypothesis path entry satisfies lemma holds aa ha bi 
entry entry node ffi node satisfy lemma holds node aa ha bi 
iv 
node pointer assignment malloc null definition node malloc 
case pi holds paths node 
path entry node node realizable equal number calls returns satisfies lemma holds node aa pi 
definition holds node aa bi true 
holds node aa ha bi nodeae holds aa ha bi nodeae holds aa ha bi set true earlier iteration 
induction hypothesis path entry satisfies lemma holds aa ha bi 
entry entry node ffi node satisfy lemma holds node aa ha bi 
proof lemma induction length path basis entry node 
possibilities pa holding ffl aa holds aa pa case appendix holds entry node aa pa true aa pa possibility pa reflexive alias variable dereferenced pointer 
event case appendix defines holds entry node aa pa true 
induction hypothesis assume direction lemma holds paths length induction step entry node node number calls returns 
ha bi alias holds ffl aem entry node aa holds number calls returns 

dereferenced pointer definition holds node aa ha bi true 

dereferenced pointer node entry node basis applies 
node exit node ha bi holds paths ffl entry node node hold ffl entry node induction hypothesis holds aa ha bi true 
definition holds node aa ha bi nodeae holds aa ha bi 
holds node aa ha bi true 
node call node argument exit node 
node return node visible called procedure aliased path return called procedure iff aliases procedure invoked 
call node corresponds return node 
ha bi holds paths ffl entry node node holds ffl entry node induction hypothesis holds aa ha bi true 
definition holds node aa ha bi holds call node aa ha bi call node holds node aa ha bi true 
ii 
visible called procedure aliased path node aliased non visible path including exit called procedure non visible call node corresponds return node 
aa holds set aliases hold ffl entry node entry node called procedure know ha non visiblei holds ffl entry node lemma unique just assuming sufficient 
shorter path meets necessary restrictions induction hypothesis holds ak ha non visiblei true 
holds ffl entry node lemma back bind holds ffl entry node induction holds aa back bind ak true 
definition holds node aa ha bi hc non visiblei assumed holds exit node hc non visiblei ha non visiblei holds call node aa back bind call node hc non visiblei call node exit node 
holds node aa ha bi true 
iii 
visible called procedure possible non visible involved ak hc non visiblei definition holds node aa ha bi holds exit node ha bi hc di assumed holds exit node hc di ha bi holds call node aa back bind call node hc di aliased path node aliased path including exit called procedure 
call node corresponds return node 
aa holds set aliases hold ffl entry node entry node called procedure know ha bi holds ffl entry node lemma assumptions necessary unique just assuming sufficient 
case shorter path meets necessary restrictions induction hypothesis holds ha bi true holds node aa ha bi true 
case induction hypothesis holds ak ha bi true 
holds ffl entry node lemma back bind holds ffl entry node induction holds aa back ak true 
call node exit node holds node aa ha bi true definition 
node statement node node assignment pointer ha bi holds paths ffl entry node node hold ffl entry node induction hypothesis holds aa ha bi true 
definition holds node aa ha bi nodeae holds aa ha bi 
holds node aa ha bi true 
ii 
node pointer assignment pi holds paths ffl entry node node qi hold ffl entry node induction hypothesis holds aa qi true 
definition holds node aa pi nodeae holds aa qi 
holds node aa pi true 
bi holds paths ffl entry node node bi hold ffl entry node induction hypothesis holds aa bi true 
definition holds node aa bi nodeae holds aa bi 
holds node aa bi true 
ha bi holds paths ffl entry node node hold ffl entry node induction hypothesis holds aa ha bi true 
definition holds node aa ha bi nodeae holds aa ha bi 
holds node aa ha bi true 
iii 
node pointer assignment definition holds node aa pi true 
bi holds paths ffl entry node node hv bi hold ffl entry node induction hypothesis holds aa hv bi true 
definition holds node aa bi nodeae holds aa hv bi 
holds node aa bi true 
ha bi holds paths ffl entry node node hold ffl entry node induction hypothesis holds aa ha bi true 
definition holds node aa ha bi nodeae holds aa ha bi 
holds node aa ha bi true 
iv 
node pointer assignment malloc null node malloc case holds node aa pi true 
alias hold path node 
ha bi holds paths ffl entry node node hold ffl entry node induction hypothesis holds aa ha bi true 
definition holds node aa ha bi nodeae holds aa ha bi 
holds node aa ha bi true 
lemma fixed point may alias calculated time polynomial size icfg ae 
variable program contributes object name may involved aliases pointer may aliases non pointer may aliased 
number possible alias pairs program variables program variables number possible aliases 
fixed point calculation node may alias node decrease size 
maximum size may alias node may alias node change value times 
nodes change value times 
fixed point calculation may alias takes polynomial amount time 
lemma realizable paths entry number calls equals number returns alias pairs set fa am holding execution forces aliases set hold alias assuming fbg execution forces aliases set hold subset additional alias assumptions path create additional aliases destroy existing ones 
lemma ha bi ha bi may alias iff ha bi precise solution interprocedural may alias presence single level pointers 
proof lemma induction iteration fixed point algorithm 
basis may alias initialized lemma holds vacuously 
induction hypothesis assume lemma holds direction iterations fixed point calculation 
induction step ha bi added may alias iteration 
entry node definition may alias nae bind may alias 
nae nae set hc di hc di may alias iteration 
induction hypothesis nae precise solution interprocedural may alias 
ha bi added may alias th iteration ha bi nae bind hc di hc di nae lemmas subset nae bind may alias equals definition may alias 
ha bi precise solution interprocedural may alias 

definition may alias ha bi fi fi fi fi fi fi fi fi fi fi fi non visible holds ha bi true aa may alias entry holds aa ha bi true ha bi may alias holds ha bi true case lemma follows lemma aa may alias entry iteration holds aa ha bi true 
aa may alias entry iteration induction hypothesis entry aa precise solution interprocedural may alias 
lemma implies ha bi precise solution 
proof lemma induction path length 
basis path simply ae aliases hold execution program lemma holds vacuously 
induction hypothesis assume lemma holds direction paths length induction step path aen entry number calls returns 
ha bi alias holds 
entry node entry definition may alias nae bind may alias 
set aliases hold aen induction may alias 
lemma ha bi bind lemma ha bi bind may alias definition may alias 

definition may alias ha bi fi fi fi fi fi fi fi holds ha bi true aa may alias entry holds aa ha bi true set aliases hold aen entry lemma assumptions necessary aa assuming aa entry forces aliased execution entry case holds mk ha bi true lemma ha bi may alias definition 
second case holds mk aa ha bi true lemma aa holds aen entry induction hypothesis aa may alias entry 
ha bi may alias definition may alias 
theorem exists polynomial time algorithm determining precise interprocedural may alias sets presence single level pointers 
algorithm appendix algorithm 
lemma proves precise 
algorithm consists steps 
lemma lemma imply step done time polynomial size icfg 
lemma implies second step done time polynomial size icfg 
third step obviously done time polynomial size icfg 
lemma implies final step done time polynomial size icfg 
precise polynomial time algorithm computing interprocedural alias sets presence single level pointers lattice conditional alias sets definitions pointer fv non pointer variable 
set object names program may aliases 
non visible represents object names visible 
possible aliases visible non 
possible aliases set possible aliases 
define lattice hec ffl powerset possible aliases false ffl iff false ffl false false false ffl note false iff false 
ffl false icfg program exit return node icfg exit node corresponding call return node icfg call node corresponding entry node icfg entry node procedure containing back bind call call call node icfg defined appendix 
back bind call alias pair specifies alias holding call site forces alias pair hold entry called procedure 
algorithm computing precise conditional alias sets holds false false nodes icfg 
holds ho oi nodes icfg possible non dereferenced pointer object names define relation holds ha bi node icfg ae ha bi possible aliases dereferenced pointer follows 
entry node holds ha bi fha big 
exit node holds ha bi nae holds ha bi 
call node holds ha bi nae holds ha bi 
return node visible called procedure holds ha bi false holds exit ha bi false holds exit ha bi holds exit ha bi holds call back bind call visible called procedure holds ha bi false holds exit ha non visiblei false possible holds exit ha non visiblei holds call back bind call hx non visiblei hx non visiblei holds exit ha non visiblei visible called procedure holds ha bi holds call ha bi 
statement node assignment pointer holds ha bi nae holds ha bi assignment pointers holds pi nae holds qi ii 
holds bi nae holds bi iii 
holds ha bi nae holds ha bi assignment pointer holds pi ii 
holds bi nae holds hv bi iii 
holds ha bi nae holds ha bi assignment malloc null pointer holds pi malloc false null ii 
holds bi false iii 
holds ha bi nae holds ha bi algorithm computing precise alias sets presence single level pointers pointer fv non pointer variable 
set object names program may aliases 
possible aliases 
possible aliases set possible aliases 
define lattice powerset possible aliases possible aliases bind call node icfg possible aliases defined appendix 
entry node icfg entry node procedure containing define ffl false false ffl node icfg define alias 
alias ae 
entry node alias nae ha bi fi fi fi fi fi fi fi ha bi bind alias contain non visible 
alias fha bi hold ha bi alias entry algorithm 
icfg ha bi possible aliases initialize ha bi 

calculate fixed point hold 

icfg initialize alias possible aliases 
calculate fixed point alias 
conditional alias sets conditional alias node icfg alias pair unique minimal set assumed aliases entry node procedure containing node insures alias pair hold node paths 
set exists conditional alias false 
cond alias pair node refer conditional alias information 
lattice values conditional alias values defined appendix 
relationships cond alias pair node values lemma icfg ha bi paths aen ha bi holds aen iff hc di holds aen entry node cond ha bi ae cond hc di proof consider ha bi paths aen ha bi holds aen iff hc di holds aen entry node note entry node entry entry ffl immediate predecessor cond hc di false path entry hc di hold regardless aliases hold entry 
ha bi hold entry mn regardless aliases hold entry entry 
cond ha bi false 
ffl nae cond hc di false cond ha bi nae cond hc di definition cond assuming nae cond hc di holds entry means paths entry nae hc di hold ha bi hold entry mn 
cond ha bi nae cond hc di 
nae cond ha bi cond hc di exists path entry assuming cond ha bi holds entry hc di hold 
assumptions ha bi hold entry entry entry 
contradiction 
lemma cond obeys relationships cond false false nodes icfg 
cond ho oi nodes icfg non dereferenced pointer object names consider cond ha bi node icfg ae ha bi 
entry node cond ha bi fha big 
exit node cond ha bi nae cond ha bi 
call node cond ha bi nae cond ha bi 
return node visible called procedure cond ha bi false cond ha bi exit false cond ha bi exit cond ha bi exit cond back bind call call visible called procedure cond ha bi false cond ha non visiblei exit false possible cond ha non visiblei exit hx non visiblei cond ha non visiblei exit cond back bind call hx non visiblei call visible called procedure cond ha bi cond ha bi call 
statement node assignment pointer cond ha bi nae cond ha bi assignment pointers cond pi nae cond qi ii 
cond bi nae cond bi iii 
cond ha bi nae cond ha bi assignment pointer cond pi ii 
cond bi nae cond hv bi iii 
cond ha bi nae cond ha bi assignment malloc null pointer cond pi malloc false null ii 
cond bi false iii 
cond ha bi nae cond ha bi proof cond false false nodes icfg 
just notational convenience 
cond ho oi nodes icfg non dereferenced pointer object names reflexive aliases hold variables 
consider cond ha bi node icfg ae ha bi dereferenced pointer 
entry node cond ha bi fha big 
clearly minimal set assumed aliases ha bi hold 
exit node paths aen ha bi holds aen iff ha bi holds aen lemma cond ha bi nae cond ha bi 
call node paths aen ha bi holds aen iff ha bi holds aen lemma cond ha bi nae cond ha bi 
return node visible called procedure ffl cond ha bi false cond ha bi exit false ha bi circumstances hold exit procedure hold return procedure 
ffl cond ha bi cond ha bi exit cond ha bi exit means procedure containing exit called aliased exit aliased executed 
ffl cond ha bi cond ha bi exit cond back bind call call ha bi holds path ae exit iff holds ae exit 
definition cond ha bi hold exit iff cond ha bi exit holds entry exit 
lemma cond ha bi exit holds entry exit iff aliases bind call cond ha bi exit hold call 
true iff aliases cond ha bi exit cond back bind call call hold entry 
visible called procedure ffl cond ha bi false cond ha non visiblei exit false ha non visiblei circumstances hold exit procedure ha nvi nv non visible object name hold return procedure 
ffl cond ha bi hx non visiblei cond ha non visiblei exit cond back bind call hx non visiblei call ha bi holds path ae exit iff ha non visiblei holds ae exit non visible non visible object name 
definition cond ha non visiblei hold exit iff cond ha non visiblei exit holds entry exit 
lemma cond ha non visiblei exit holds entry exit iff aliases back bind call fi fi fia cond ha non visiblei exit hold call 
true iff aliases cond ha non visiblei exit cond back bind call call hold entry 
visible called procedure paths aen ha bi holds iff ha bi holds call 
argument similar proof lemma replace call cond ha bi cond ha bi call 
statement node assignment pointer paths aen ha bi holds aen iff ha bi holds aen lemma cond ha bi nae cond ha bi 
assignment pointers paths aen pi holds aen iff qi holds aen lemma cond pi nae cond qi ii 
paths aen bi holds aen iff bi holds aen lemma cond bi nae cond bi iii 
paths aen ha bi holds aen iff ha bi holds aen lemma cond ha bi nae cond ha bi 
assignment pointer paths aen pi hold 
cond pi 
ii 
paths aen bi holds aen iff hv bi holds aen lemma cond bi nae cond hv bi iii 
paths aen ha bi holds aen iff ha bi holds aen lemma cond ha bi nae cond ha bi 
assignment malloc null pointer ffl malloc paths aen pi hold 
cond pi 
ffl null paths aen pi hold 
cond pi false 
ii 
paths aen bi hold 
cond bi false 
iii 
paths aen ha bi holds aen iff ha bi holds aen lemma cond ha bi nae cond ha bi proof correctness precise conditional alias algorithm lemma nodes icfg alias pair maximal fixed point holds alias pair cond alias pair show holds alias pair cond alias pair lemma lemma holds alias pair cond alias pair lemma 
lemma ha bi possible aliases ha bi ha bi set assuming entry node procedure containing insures ha bi holds paths false set exists 
formally define ha bi paths entry exists ha bi false ha bi hold execution aliases set hold entry execution forces ha bi hold claim cond ha bi ha bi assume ha bi lemma false 
cond ha bi ha bi definition cond ha bi unique minimal set assuming entry node procedure containing insures ha bi holds paths false set exists 
contradiction lemma consider holds maximum fixed point relation defined appendix 
holds ha bi paths entry exists false ha bi hold execution aliases set hold entry execution forces ha bi hold proof induction path length 
basis remember iff false path simply entry node 
definition ffl dereferenced pointer holds ha ai 
lemma hold reflexive aliases hold 
ffl holds ha bi fha big 
lemma hold fha big 
induction hypothesis lemma holds induction step entry entry consider holds ha bi dereferenced pointer holds ha ai 
lemma hold reflexive aliases hold 

entry node possible 
see basis 

exit node holds ha bi ae holds ha bi argument induction hypothesis holds ha bi 
holds ha bi holds ha bi definition holds 
valid holds ha bi holds ha bi 

call node holds ha bi ae holds ha bi lemma holds argument 

return node visible called procedure ffl holds ha bi false holds ha bi false 
lemma hold false 
ffl holds ha bi holds ha bi 
induction procedure containing exit called aliased exit aliased executed 
satisfies lemma 
ffl holds ha bi holds exit ha bi holds call back bind call induction hypothesis holds ha bi 
call node return node 
induction hypothesis hc di hc di holds hc di 
consider back bind call certainly holds ha bi lemma 
holding entry executing force ha bi hold 
visible called procedure ffl holds ha bi false holds ha non visiblei false 
lemma hold false 
ffl holds ha bi ub holds exit ha non visiblei holds call back bind call induction hypothesis holds ha non visiblei 
call node return node 
induction hypothesis hc di hc di holds hc di 
consider back bind call certainly holds ha bi lemma 
holding entry executing force ha bi hold 
visible called procedure lemma holds trivial modification argument 

statement node assignment pointer holds ha bi ae holds ha bi lemma holds argument 
assignment pointers holds pi ae holds qi induction hypothesis holds qi 
holds qi holds pi definition holds 
valid pi holds qi holds pi 
ii 
holds bi ae holds bi induction hypothesis holds bi 
holds bi holds bi definition holds 
valid bi holds bi holds bi 
iii 
holds ha bi ae holds ha bi lemma holds argument 
assignment pointer holds pi pi holds paths assumptions entry lemma holds 
ii 
holds bi ae holds hv bi induction hypothesis holds hv bi 
holds hv bi holds bi definition holds 
valid bi holds hv bi bi 
iii 
holds ha bi ae holds ha bi lemma holds argument 
assignment malloc null pointer ffl malloc holds pi pi holds paths assumptions entry lemma holds 
ffl null holds bi false 
lemma hold false 
ii 
holds bi false 
lemma hold false 
iii 
holds ha bi ae holds ha bi lemma holds argument 
lemma consider holds maximum fixed point relation defined appendix 
icfg ha bi possible aliases holds ha bi cond ha bi proof induction number iterations maximum fixed point algorithm 
holds ha bi value holds ha bi th iteration fixed point algorithm 
basis holds ha bi icfg ha bi initialized 
lemma holds 
induction hypothesis lemma holds induction step say value holds ha bi changed iteration dereferenced pointer holds ha ai 
lemma hold 

entry node holds ha bi fha big 
lemma cond ha bi fha big lemma holds 

exit node holds ha bi nae holds ha bi argument induction hypothesis nae holds ha bi cond ha bi lemma cond ha bi nae cond ha bi definition holds ha bi nae holds ha bi nae cond ha bi cond ha bi lemma hold 

call node holds ha bi nae holds ha bi lemma holds argument 

return node visible called procedure ffl holds ha bi false holds exit ha bi false 
induction hypothesis false holds exit ha bi cond ha bi exit cond ha bi exit false means lemma cond ha bi false 
ffl holds ha bi holds exit ha bi 
lemma hold 
ffl holds ha bi definition holds exit ha bi holds call back bind call induction cond ha bi exit holds call back bind call induction cond ha bi exit cond back bind call call lemma cond ha bi lemma hold 
visible called procedure ffl holds ha bi false holds exit ha non visiblei false 
induction hypothesis false holds exit ha non visiblei cond ha non visiblei exit cond ha non visiblei exit false means lemma cond ha bi false 
ffl holds ha bi definition holds exit ha non visiblei holds call back bind call induction cond ha non visiblei exit holds call back bind call induction cond non visible 
exit cond back bind call call lemma cond ha bi lemma hold 
visible called procedure holds ha bi definition holds call ha bi induction cond ha bi call lemma cond ha bi lemma holds 

statement node assignment pointer holds ha bi nae holds ha bi lemma holds argument 
assignment pointers holds pi nae hold qi induction hypothesis nae holds qi cond qi lemma cond pi nae cond qi lemma hold 
ii 
holds bi nae hold bi induction hypothesis nae holds bi cond bi lemma cond bi nae cond bi lemma hold 
iii 
holds ha bi nae hold ha bi lemma holds argument 
assignment pointer holds pi lemma cond pi lemma hold 
ii 
holds bi nae hold hv bi induction hypothesis nae holds hv bi cond hv bi lemma cond bi nae cond hv bi lemma hold 
iii 
holds ha bi nae hold ha bi lemma holds argument 
assignment malloc null pointer ffl malloc holds pi lemma cond pi lemma hold 
ffl null holds pi false lemma cond pi false lemma hold 
ii 
holds bi false lemma cond bi false lemma hold 
iii 
holds ha bi nae hold ha bi lemma holds argument 
lemma fixed point calculation holds polynomial time 
variable program contributes object name may involved aliases pointer may aliases non pointer may aliased 
number possible aliases pairs program variables program variables number possible aliases 
icfg ha bi possible aliases iterations holds ha bi iteration holds ha bi iteration 
ha bi change value times 
means iterations fixed point algorithm iteration take time fixed point calculated time polynomial size icfg 
proof theorem lemma fixed point alias calculated time polynomial size icfg ae 
variable program contributes object name may involved aliases pointer may aliases non pointer may aliased 
number possible aliases pairs program variables program variables number possible aliases 
fixed point calculation node alias node increase size 
maximum size alias node alias node change value times 
nodes change value times 
fixed point calculation alias takes polynomial amount time 
lemma ha bi alias implies realizable paths icfg ha bi hold 
proof induction iteration fixed point algorithm 
alias value alias th iteration fixed point algorithm 
basis icfg alias initialized possible aliases induction hypothesis lemma holds induction step say value alias changed iteration 
ae alias ae 
aliases hold program executed 

entry node alias nae bind alias ha bi arbitrary alias pair alias alias 
predecessor icfg ffl back bind ha bi false case lemma paths aen mn ha bi hold 
ffl back bind ha bi alias ha bi alias 
induction realizable path back bind ha bi hold 
lemma lemma ha bi hold realizable path ffi 
entry node alias fha bi hold ha bi alias entry ha bi arbitrary alias pair alias alias 
ffl hold ha bi false lemma path ha bi hold 
ffl hc di hold ha bi alias entry 
induction hypothesis path entry hc di hold 
lemma path ha bi hold 
lemma realizable path aen icfg ha bi hold implies ha bi alias 
proof induction path length basis ae 
aliases hold alias ae 
induction hypothesis lemma holds induction step ha bi alias pair hold path 
ae see basis 

entry node alias ae bind alias 
ffl back bind ha bi false lemma lemma lemma hold 
ffl back bind ha bi hold ha bi hold lemma 
induction back bind ha bi element alias lemma ha bi element alias ae 
entry node alias fha bi hold ha bi alias entry ffl hold ha bi false lemma lemma hold 
ffl lemma hc di hold ha bi hold entry induction hc di alias entry 
hold ha bi alias entry 
ha bi ha bi 
theorem exists polynomial time algorithm determining precise interprocedural alias sets presence single level pointers 
algorithm appendix algorithm 
lemma lemma prove precise 
algorithm consists steps 
step obviously done time polynomial size icfg 
lemma implies second step done time polynomial size icfg 
third step obviously done time polynomial size icfg 
lemma implies final step done time polynomial size icfg 
replacing formals pointers lemma realizable paths aen icfg original program hx yi holds iff ffl case formals yi holds path transformed program 
ffl case formal yi holds path transformed program 
ffl case formals hx yi holds path transformed program 
assume variable program unique name dealing paths assume instance variable unique name 
example say variable declared recursive procedure called times path 
simply refer variable invocation second 
easily done path allows ignore issue visibility proofs 
proofs statements actual formal refer original program explicitly stated 
proofs case analysis node icfg alias 
cases directions direction starts alias original program direction starts alias transformed program 
cases outlined 
formals entry node procedure containing corresponding actuals formals formal formals ii 
formal procedure containing corresponding actual formal formal iii 
formals procedure containing call node exit node return node statement node 
formal entry node formal procedure containing corresponding actual formal dereferenced pointer formal procedure containing actual ffl formal ffl formal formal dereferenced pointer formal procedure containing formal dereferenced pointer formal procedure containing actual ffl formal ffl formal formal dereferenced pointer formal ii 
formal procedure containing dereferenced pointer formal procedure containing actual ffl formal ffl formal iii 
formal procedure containing dereferenced pointer formal call node exit node return node statement node impossible pointer assignment formal 
pointer assignment original program ii 
pointer assignment original program iii 
pointer assignment malloc null original program 
formals entry node pointer formals procedure containing corresponding actuals ffl formals ffl formal formal ffl formal ii 
pointer formal actual dereferenced pointer formal procedure containing ffl formal ffl formal iii 
dereferenced pointer formals procedure containing call node exit node return node pointer assignment original program ii 
iii 
pointer assignment original program ii 
iii 
pointer assignment malloc null original program ii 
iii 
proof induction path length 
basis path simply ae 
aliases hold program executed 
lemma vacuously holds 
induction hypothesis lemma holds paths length induction step hx yi hold aen original program 
aen path corresponds transformed program 
path corresponds transformed program 

formals entry node procedure containing corresponding actuals formals ha holds original program induction hypothesis holds transformed program 
requires yi hold transformed program passed passed formal ha holds original program induction hypothesis holds transformed program 
requires yi hold transformed program passed passed formals equal way ha hold original program 
holds transformed program formals passed 
ii 
formal procedure containing corresponding actual formal ha yi holds original program induction hypothesis yi holds transformed program 
yi yi holds passed transformed program 
formal ha yi holds original program induction hypothesis ha yi holds transformed program 
yi yi holds passed transformed program 
iii 
formals procedure containing hx yi holds original program induction hypothesis yi holds transformed program holds call node exit node return node cases hx yi holds original program induction hypothesis yi holds transformed program 
implies holds 
statement node impossible pointer assignment formals pointers 
hx yi holds original program induction hypothesis yi holds transformed program holds 
formal entry node formal procedure containing corresponding actual formal dereferenced pointer formal procedure containing actual ffl formal ha fi holds original program induction hypothesis fi holds transformed program 
yi holds passed passed transformed program 
ffl formal ha holds original program induction hypothesis holds transformed program 
yi holds passed passed transformed program 
formal dereferenced pointer formal procedure containing ha yi holds original program induction hypothesis yi holds transformed program 
yi yi holds passed transformed program 
formal dereferenced pointer formal procedure containing actual ffl formal ha fi holds original program induction hypothesis ha fi holds transformed program 
yi holds passed passed transformed program 
ffl formal ha holds original program induction hypothesis ha holds transformed program 
yi holds passed passed transformed program 
formal dereferenced pointer formal ha yi holds original program induction hypothesis ha yi holds transformed program 
yi yi holds passed transformed program 
ii 
formal procedure containing dereferenced pointer formal procedure containing actual ffl formal hx fi holds original program induction hypothesis fi holds transformed program 
yi holds passed transformed program 
ffl formal hx holds original program induction hypothesis holds transformed program 
yi holds passed transformed program 
iii 
formal procedure containing dereferenced pointer formal hx yi holds original program induction hypothesis yi holds transformed program holds 
call node exit node return node cases hx yi holds original program induction hypothesis yi holds transformed program 
implies holds 
statement node impossible pointer assignment formal 
pointer assignment original program hx qi holds original program induction hypothesis qi holds transformed program pi yi holds hx yi holds original program induction hypothesis yi holds transformed program holds ii 
pointer assignment original program hx vi holds original program induction hypothesis vi holds transformed program pi yi holds hx yi holds original program induction hypothesis yi holds transformed program holds iii 
pointer assignment malloc null original program aliased possibly 
hx yi holds original program induction hypothesis yi holds transformed program holds 
formals entry node pointer formals procedure containing corresponding actuals ffl formals hf holds original program induction hypothesis holds transformed program 
hx yi holds passed passed transformed program 
ffl formal formal hf holds original program induction hypothesis holds transformed program 
hx yi holds passed passed transformed program 
ffl formal holds original program induction hypothesis holds transformed program 
hx yi holds passed passed transformed program 
ii 
pointer formal actual dereferenced pointer formal procedure containing ffl formal hf yi holds original program induction hypothesis yi holds transformed program 
yi hx yi holds passed transformed program 
ffl formal yi holds original program induction hypothesis yi holds transformed program 
yi hx yi holds passed transformed program 
iii 
dereferenced pointer formals procedure containing hx yi holds original program induction hypothesis hx yi holds transformed program 
implies holds 
call node exit node return node cases hx yi holds original program induction hypothesis hx yi holds transformed program 
implies holds 
pointer assignment original program qi holds original program induction hypothesis qi holds transformed program pi hx yi holds ii 
yi holds original program induction hypothesis yi holds transformed program yi hx yi holds iii 
hx yi holds original program induction hypothesis hx yi holds transformed program holds 
pointer assignment original program definition pi hx yi holds transformed program 
ii 
hv yi holds original program induction hypothesis hv yi holds transformed program yi hx yi holds iii 
hx yi holds original program induction hypothesis hx yi holds transformed program holds 
pointer assignment malloc null original program definition pi hx yi holds transformed program malloc possible alias hold null 
ii 
possible aliased possibly 
iii 
hx yi holds original program induction hypothesis hx yi holds transformed program holds proof induction path length 
basis path simply ae 
aliases hold program executed 
lemma vacuously holds 
induction hypothesis lemma holds paths length induction step ha bi hold aen transformed program 
aen path corresponds original program 
path corresponds original program 

ha bi yi formals original program entry node procedure containing corresponding actuals original program formals transformed program passed passed hold induction hypothesis ha holds requires hf hx yi hold formal transformed program passed passed hold induction hypothesis ha holds requires hf hx yi hold formals hold non pointer variables original program passed non pointer formals 
equal hf holds ii 
formal procedure containing corresponding actual original program 
formal passed transformed program yi holds induction hypothesis ha yi holds hf yi hx yi holds formal passed transformed program ha yi holds induction hypothesis ha yi holds hf yi hx yi holds iii 
formals procedure containing yi holds induction hypothesis hx yi holds holds 
call node exit node return node cases yi holds induction hypothesis hx yi holds holds statement node impossible pointer assignment original program formals pointers 
yi holds induction hypothesis hx yi holds holds 
ha bi yi formal original program isn entry node formal procedure containing corresponding actual original program 
formal dereferenced pointer formal procedure containing actual original program ffl original program formal passed passed transformed program fi holds induction hypothesis ha fi holds hf hx yi holds ffl formal original program passed passed transformed program holds induction hypothesis ha holds hf hx yi holds formal dereferenced pointer formal procedure containing passed transformed program yi holds induction hypothesis ha yi holds hf yi hx yi holds formal dereferenced pointer formal procedure containing actual original program ffl formal original program passed passed transformed program ha fi holds induction hypothesis ha fi holds hf hx yi holds ffl formal original program passed passed transformed program ha holds induction hypothesis ha holds hf hx yi holds formal dereferenced pointer formal procedure containing passed transformed program ha yi holds induction hypothesis ha yi holds hf yi hx yi holds ii 
formal procedure containing dereferenced pointer formal procedure containing actual original program ffl original program formal passed transformed program hx fi holds induction hypothesis hx fi holds hx hx yi holds ffl original program formal passed transformed program hx holds induction hypothesis hx holds hx hx yi holds iii 
formal procedure containing dereferenced pointer formal procedure containing yi holds induction hypothesis hx yi holds holds 
call node exit node return node cases yi holds induction hypothesis hx yi holds holds 
statement node impossible pointer assignment original program formal 
pointer assignment original program qi holds induction hypothesis hx qi holds hx pi hx yi holds yi holds induction hypothesis hx yi holds holds ii 
pointer assignment original program vi holds induction hypothesis hx vi holds hx pi hx yi holds yi holds induction hypothesis hx yi holds holds iii 
pointer assignment malloc null original program aliased possibly 
yi holds induction hypothesis hx yi holds holds 
ha bi hx yi formals original program entry node pointer formals procedure containing corresponding actuals original program ffl original program formals passed passed transformed program holds induction hypothesis hf holds hx yi holds ffl original program formal formal passed passed transformed program holds induction hypothesis hf holds hx yi holds ffl formal passed passed transformed program holds induction hypothesis holds hx yi holds ii 
pointer formal actual dereferenced pointer formal ffl formal passed transformed program yi holds induction hypothesis hf yi holds yi hx yi holds ffl formal passed transformed program yi holds induction hypothesis yi holds yi hx yi holds iii 
dereferenced pointer formals hx yi holds induction hypothesis hx yi holds holds 
call node exit node return node cases hx yi holds induction hypothesis hx yi holds holds 
pointer assignment original program qi holds induction hypothesis qi holds pi hx yi holds ii 
hx qi holds induction hypothesis hx qi holds hx pi hx yi holds iii 
hx yi holds induction hypothesis hx yi holds holds 
pointer assignment original program definition pi hx yi holds ii 
hx vi holds induction hypothesis hx vi holds hx pi hx yi holds iii 
hx yi holds induction hypothesis hx yi holds holds 
pointer assignment malloc null original program definition pi hx yi holds malloc possible alias hold null 
ii 
possible aliased possibly 
iii 
hx yi holds induction hypothesis hx yi holds holds appendix interprocedural may alias approximate algorithm pseudo code find aliases worklist alias node node icfg node assignment pointer aliases introduced assignment node node call node aliases introduced call node implied aliases worklist empty remove node assumed alias possible alias worklist node call node aliases call implies node assumed alias possible alias node exit node alias exit implies node assumed alias possible alias alias implies node assumed alias possible alias approximate non visible approximate non visible call node nv non visible name non visible name name aa name aa substitutes non visible name non visible nv substitutes non visible name non visible nv uses assumed aliases name aa name aa establish safe assumed alias condition procedure entry 
approximate non visible call node nv non visible name non visible name name aa name aa apply trans non visible nv non visible name apply trans non visible nv non visible name name aa name aa contain non visible creates alias object names non visible exit exit node procedure containing call node may hold exit name aa name aa non visible name non visible name isi false may hold exit name aa name aa visible name non visible name isi true add exit name aa name aa visible name non visible name isi worklist assumptions individually necessary safely chosen 
assumption contains non visible need non visible object name non visible represents assumption requiring aa requiring just aa 
name aa name aa contains non visible aa name aa aa name aa hx yi alias consequences visible name non visible name isi return return node corresponds call node may hold return aa hx yi false set may hold return aa hx yi true add return aa hx yi worklist name aa name aa necessary aliasing conditions entry procedure aliased return 
allow alias condition safe approximate arbitrarily pick 
alias call implies alias call implies call assumed alias ha bi return return node corresponds call exit exit node called procedure entry entry node called procedure visible called procedure rule may hold return assumed alias ha bi false set may hold return assumed alias ha bi true add return assumed alias ha bi worklist expanded version code page effects entry added 
aa aa nv bind call ha bi may hold entry aa aa false effects entry set may hold entry aa aa true add entry aa aa worklist hx yi hx yi condition exit aa contain non visible rule may hold return assumed alias hx yi false set may hold return assumed alias hx yi true add return assumed alias hx yi worklist 
contain non visible rule special case aa nv call visible approximate non visible call hx yi nv nv assumed alias aa assume contains non visible rule nv apply trans non visible may hold return assumed alias hx yi false set may hold return assumed alias hx yi true add return assumed alias hx yi worklist 
element element bind alias exit implies alias exit implies exit aa hx yi contain non visible aa ha call node call invokes procedure containing exit assumed nv call visible assumed nv call visible approximate non visible call hx yi nv nv assumed assumed contains non visible call node call invokes exit procedure assumed call aa return return node corresponds call object names call visible called procedure aliased locals recursive procedure may hold return assumed hx yi false set may hold return assumed hx yi true add return assumed hx yi worklist contains non visible assume call node call invokes procedure containing exit assumed nv call aa return return node corresponds call object name call visible called procedure apply trans non visible nv pa alias consequences yi may hold return assumed pa false set may hold return assumed pa true add return assumed pa worklist alias implies alias implies node assumed alias hy zi successor succ node succ assignment pointer may hold succ assumed alias hy zi false set may hold succ assumed alias hy zi true add succ assumed alias hy zi worklist node assignment prefix prefix case may hold succ assumed alias hy zi false set may hold succ assumed alias hy zi true add succ assumed alias hy zi worklist prefix deref case prefix apply trans may hold succ assumed alias hp zi false set may hold succ assumed alias hp zi true add succ assumed alias hp zi worklist aa hp vi may hold node aa hp vi true contains non visible prefix apply trans safely alias succ aa assumed alias case ha bi alias consequences hp yi provided prefix prefix alias consequences qi may hold succ assumed alias ha bi false set may hold succ assumed alias ha bi true add succ assumed alias ha bi worklist aa ha bi may hold node aa ha bi prefix deref prefix contains non visible prefix apply trans safely alias succ assumed alias aa variable renaming node assignment pointer successor appendix safe approximate algorithm types approximation chapter mentioned sources approximation 

program contains recursive data structures potentially infinite number objects aliases 
represent possible objects finite polynomial number objects 

yi 
ff omega hp qi yi hp qi yi occur path yi holds path extended conclude may true 
zi 
ff omega hp qi zi path immediate predecessor zi holds hp qi hp zi zi holds path extended paths immediate predecessors zi holds hp qi keep track arriving edge problem arise edges arriving predecessors 
hp zi holds zi necessarily hold path case safety assume zi holds path 
ff omega hp ui hp vi normally hold path assigning assigning need hold 
example hp ui hp vi hold path necessarily hold 
lemma limit constant algorithm 
arrays treated aggregates assumption null 
may hold node aa pa true pa type approximation derived directly indirectly type approximation node pa limit precise solution 
proof lemma induction iteration number algorithm 
basis ffl aliases intro assignment node chapter prefix node assignment lemma follows assumption null 
prefix new aliases created algorithm 
path hp ui holds account aliases involving non visible object names 
assume non visible represent non visible objects names precise solution 
ffl alias intro call node chapter ways aliases generated chapter actual passed formal formal passed formal passed prefix cases lemma follows assumption null 
induction hypothesis lemma holds induction step 
alias call implies call assumed alias possible alias chapter induction hypothesis know possible alias limit precise solution derived type approximation 
type approximation may holds set true set true possible alias derived type approximation satisfies lemma 
assume case possible alias limit precise solution ffl effects corresponding entry node entry may hold entry ha bi ha bi set true ha bi bind call possible alias 
ha bi result chapter st way call entry nd way call entry rd way call entry ffl ffi fi fl call ffl ffi fi fl entry store store st way possible alias path call hold path entry making sure account visibility 
lemma hold 
nd way actual dereferenced alias call clearly formal dereferenced aliased thing entry modulo visibility 
lemma hold 
rd way actuals aliases clearly corresponding formals dereferenced dereferenced 
lemma hold 
ffl effects corresponding return node return simply clever encoding holds relation 
induction hypothesis may hold exit aa hx yi aa bind call pos sible alias type approximation exit hx yi limit precise solution 
case definition may hold return assumed alias hx yi derived type approximation 
second case complicated 
indirectly proved appendix alias holds path exit requires assumptions single assumed alias entry relation valid 
hx yi depends aa entry path encoding valid lemma follows 
hx yi depends aa plus assumptions path hx yi approximation exit 
information single aliases path requires information multiple aliases approximation 
hx yi approximation exit induction may hold exit aa hx yi true earlier iteration hx yi type approximation hx yi derived type approximation 

alias exit implies exit assumed alias possible alias chapter induction hypothesis know possible alias limit precise solution derived type approximation 
type approximation may holds set true set true possible alias derived type approximation satisfies lemma 
assume case possible alias limit precise solution 
routine simply clever encoding holds relation 
induction hypothesis may hold call aa pa assumed alias bind call pa type approximation call pa limit precise solution 
case definition may hold return assumed alias hx yi derived type approximation 
second case complicated 
indirectly proved appendix alias holds path exit requires assumptions single assumed alias entry relation valid 
pa depends call path encoding valid lemma follows 
pa depends aa plus assumptions path pa approximation exit 
information single aliases path requires information multiple aliases approximation 
pa approximation call induction may hold call aa pa true earlier iteration pa type approximation pa derived type approximation 

alias implies node assumed alias possible alias chapter possible alias hy zi 
induction hypothesis know possible alias limit precise solution derived type approximation 
type approximation may holds set true set true possible alias derived type approximation satisfies lemma 
assume case possible alias limit precise solution 
ffl successor call node exit node program statement assignment pointer nodes simply collect may hold information parents lemma holds possible alias node holds case 
ffl successor succ assignment pointer cases consider 
assignment preserve alias 
true prefix discussion easier way alias hold path succ holds path node redefined succ path succ holds 
clearly get redefined statement alias approximate succ hp hp holds path including succ 
definition rd type approximation lemma holds 
effects alias 
case applicable prefix deref 
consider 
case ii chapter algorithm doesn create new aliases 
case chapter zi hold path succ zi holds node 
clearly refer object assignment referred assignment 
discussion easier different object assignment hp holds path succ 
hp holds path succ hold assumption null precise solution 
leaves case iii chapter case specifically handles nd source approximation lemma follow 
effects alias 
case applicable induction hypothesis know possible alias limit precise solution derived type approximation 
type approximation may holds set true set true possible alias derived type approximation satisfies lemma 
assume case possible alias limit precise solution 
case chapter qi holds path succ hy zi holds node refers different object assignment 
case cases prefix case generate erroneous alias hp vi prefix holds path 
th type approximation lemma follows 
alias generated case ii chapter meets requirements lemma succ assumption null 
leaves case iii chapter case specifically handles nd source approximation lemma follow 
ahu aho hopcroft ullman 
design analysis computer algorithms 
addison wesley 
asu aho sethi ullman 
compilers principles techniques tools 
addison wesley 
ban banning 
method determining side effects procedure calls 
phd thesis department electrical engineering stanford university 
ban banning 
efficient way find side effects procedure calls aliases variables 
conference record sixth annual acm symposium principles programming languages pages january 
bec beck 
system software 
addison wesley reading massachusetts 
bur burke 
interval approach exhaustive incremental interprocedural data flow analysis 
acm transactions programming languages systems july 
car carroll 
new pointer removing program transformation 
unpublished manuscript 
cc cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth annual acm symposium principles programming languages pages january 
ck cooper kennedy 
efficient computation flow insensitive interprocedural summary information 
proceedings acm sigplan symposium compiler construction pages june 
sigplan notices vol 
ck cooper kennedy 
complexity interprocedural side effect analysis 
computer science department technical report tr rice university october 
ck cooper kennedy 
efficient computation flow insensitive interprocedural summary information correction 
computer science department technical report tr rice university october 
ck cooper kennedy 
fast interprocedural alias analysis 
conference record sixteenth annual acm symposium principles programming languages pages january 
coo cooper 
analyzing aliases formal parameters 
conference record twelfth annual acm symposium principles programming languages pages january 
coo cooper 
ambitious data flow analysis procedural programs 
master thesis university minnesota may 
cou coutant 
retargetable high level alias analysis 
conference record thirteenth annual acm symposium principles programming languages pages january 
cr chow 
design data flow analyzer 
proceedings acm sigplan symposium compiler construction pages june 
cwz chase wegman zadeck 
analysis pointers structures 
proceedings sigplan conference programming language design implementation pages june 
sigplan notices vol 
deu deutsch 
determining lifetime aliasing dynamically allocated data higher order functional specifications 
conference record seventeenth annual acm symposium principles programming languages pages january 

technique analyzing pointer structure parallel restructuring compilers 
proceedings international conference parallel processing pages 
ha harrison iii 
parcel symbolic numeric programs 
international workshop compilers parallel computers december 
hec hecht 
flow analysis computer programs 
elsevier north holland 
hn hendren nicolau 
parallelizing programs recursive data structures 
proceedings international conference parallel processing pages august 
hn hendren nicolau 
parallelizing programs recursive data structures 
ieee transactions parallel distributed systems january 
hpr horwitz pfeiffer reps dependence analysis pointer variables 
proceedings acm sigplan symposium compiler construction pages june 
hrb horwitz reps binkley 
interprocedural slicing dependence graphs 
proceedings sigplan conference programming language design implementation pages july 
sigplan notices vol 

hs harrold soffa 
computation interprocedural definition dependencies 
proceedings international conference computer languages pages 
jm jones muchnick 
flow analysis optimization lisp structures 
muchnick jones editors program flow analysis theory applications pages 
prentice hall 
jm jones muchnick 
flexible approach interprocedural data flow analysis programs recursive data structures 
conference record ninth annual acm symposium principles programming languages pages january 
kil kildall 
unified approach global program optimization 
conference record acm symposium principles programming languages pages january 
ks korth silberschatz 
database system concepts 
mcgraw hill new york ny 
lar larus 
restructuring symbolic programs concurrent execution multiprocessors 
phd thesis university california berkeley may 
lh larus hilfinger 
detecting conflicts structure accesses 
proceedings sigplan conference programming language design implementation pages july 
sigplan notices vol 

lom lomet 
data flow analysis presence procedure calls 
journal research development november 
lr landi ryder 
aliasing pointers problem taxonomy 
center computer aids industrial productivity technical report caip tr rutgers university september 
lr landi ryder 
pointer induced aliasing problem classification 
conference record eighteenth annual acm symposium principles programming languages pages january 
ls lippman stroustrup 
pointers class members 
proceedings usenix conference pages 
marlowe ryder 
efficient hybrid algorithm incremental data flow analysis 
conference record seventeenth annual acm symposium principles programming languages pages january 
marlowe ryder 
hybrid incremental alias algorithms 
proceedings hawaii international conference system sciences volume ii software pages january 
mye myers 
precise interprocedural data flow algorithm 
conference record eighth annual acm symposium principles programming languages pages january 
npd panangaden demers 
computation aliases support sets 
conference record fourteenth annual acm symposium principles programming languages pages january 
prl pande ryder landi 
interprocedural def associations programs 
proceedings fifth testing analysis verification symposium october 
pw padua wolfe 
advanced compiler optimizations supercomputers 
communications acm december 
rp ryder pande 
interprocedural structure programs empirical study 
laboratory computer science research technical report lcsr tr department computer science rutgers university february 
ryder 
ismm incremental software maintenance manager 
proceedings ieee computer society conference software maintenance pages october 
sp sharir pnueli 
approaches interprocedural data flow analysis 
muchnick jones editors program flow analysis theory applications pages 
prentice hall 
wei weihl 
interprocedural data flow analysis presence pointers procedure variables label variables 
master thesis june 
wei weihl 
interprocedural data flow analysis presence pointers procedure variables label variables 
conference record seventh annual acm symposium principles programming languages pages january 
wol michael wolfe 
optimizing supercompilers supercomputers 
mit press cambridge ma 
vita william alexander landi computer science cook college rutgers university new brunswick nj 
computer science rutgers university new brunswick nj 
teaching assistant department computer science 
lecturer course coordinator computer science 
research assistant professor barbara ryder 
research fellow 
siemens corporate research 
ryder landi pande profiling incremental data flow analysis algorithm 
ieee transactions software engineering february 
landi ryder 
pointer induced aliasing problem classification 
conference record eighteenth annual acm symposium principles programming languages january 
pande ryder landi 
interprocedural def associations programs 
proceedings fifth testing analysis verification symposium october 
ph computer science 
