appear ieee transactions cad may tentative salsa new approach scheduling timing constraints john nestor senior member ieee ganesh krishnamoorthy describes new approach scheduling problem high level synthesis meets timing constraints attempting minimize hardware resource costs 
approach modified control data flow graph cdfg representation called salsa 
salsa provides simple move set allows alternative schedules quickly explored maintaining timing constraints 
shown move set complete legal schedule reached sequence move applications 
addition salsa provides support scheduling conditionals loops subroutines 
scheduling salsa performed steps 
initial schedule meets timing constraints generated constraint solution algorithm adapted layout compaction 
second schedule improved salsa move set control simulated annealing algorithm 
results show scheduler ability find schedules meet timing constraints reasonable execution times 

goal high level synthesis translate procedural specification behavior register transfer design implements behavior 
approaches high level synthesis control data flow graph cdfg intermediate representation behavioral specification break synthesis problem subtasks scheduling assigns cdfg nodes representing operators control steps allocation assigns cdfg nodes representing operators edges representing data values hardware alus registers interconnections realize datapath 
scheduling particularly important part process reasons 
fixes requirements manuscript received february revised september april 
nestor department electrical computer engineering illinois institute technology chicago il 
krishnamoorthy mentor graphics independence blvd warren nj 
supported part nsf mip iit education research initiative fund 
appear ieee transactions cad may tentative various hardware resources allocation 
second equally important fixes relative timing operators satisfaction timing constraints 

timing constraints important allow designers specify desired performance interface information 
fig 
illustrates scheduling problem typical cdfg directed graph nodes represent operators edges represent ordering dependencies operators 
source sink nodes represent activities graph 
edges nodes represent different types ordering dependencies 
data edges represent flow data operator implying ordering relationship data computed 
control edges represent ordering relationships associated control operations conditionals 
timing edges represent timing constraints operators satisfied correct design 
timing constraint specifies required relative timing operators 
minimum timing constraints specify lower bound relative timing operators maximum timing constraints specify upper bound 
dependencies imply ordering operator precedes second operator execution 
scheduling assigns operator node control step represents controller state operator execute 
fig 
illustrates typical schedule displaying control step boundaries horizontal lines 
scheduling fixes order operators implemented design perform task way meets dependencies specified edges graph 
performed hardware allocation ordering sets lower bound resources required implement cdfg hardware 
functional unit requirements determined maximum number operators type adders alus scheduled control step 
register requirements determined maximum number values live control step represented data edges cdfg cross control step boundaries 
example schedule fig 
requires adders multiplier registers 
weighted sum requirements cost function estimate schedule quality 
schedulers include estimate interconnection requirements total number data transfers control step 
convention edges figures directed top bottom arrowhead indicates appear ieee transactions cad may tentative early approaches scheduling simple soon possible asap possible algorithms minimize schedule length ignoring hardware costs timing constraints 
large number approaches developed attempt minimize hardware costs resulting allocation 
approaches minimize hardware cost broken constructive approaches greedy heuristics iterative transformational approaches simulated annealing exact approaches integer linear programming 
greedy heuristics attempt minimize resource costs guarantee optimal schedule 
examples greedy approaches include fast simple heuristics list scheduling complex effective heuristics force directed scheduling 
greedy heuristics suffer shortcoming trapped local minima cost function may find globally best schedule 
transformational approaches alter existing schedule find new schedules search low cost schedules 
iterative probabilistic approaches simulated annealing employ small set transformations applied randomly selected parts schedule 
probabilistic acceptance function allows controlled hillclimbing escape local minima 
simulated annealing employed combined scheduling allocation schemes 
simulated evolution related approach group scheduled operators probabilistically selected unscheduled rescheduled greedy algorithm 
transformational approaches require large number move applications properly explore schedule space typically exhibit large execution times 
exact approaches techniques integer linear programming ilp guarantee globally optimum schedule large execution times 
approaches represent scheduling decisions set decision variables possible assignment operator control step set constraints satisfied guarantee legal schedule 
ilp find optimal schedule respect cost function 
worst case execution times approaches exponential special characteristics scheduling problem exploited reduce runtime making techniques practical fairly large problems 
execution time approaches depends number variables constraints 
value grow quite large large problems especially schedule length increased cdfg 
appear ieee transactions cad may tentative scheduling approaches attempt meet arbitrary timing constraints minimizing resource costs 
constructive heuristics include modified list scheduling heuristics attempt meet timing constraints scheduling force directed scheduling uses local timing constraints limit time frames control steps operator may scheduled 
approach timing constraints included ilp formulation 
approaches scheduling consider timing constraints separately allocation attempt minimize resource costs 
example parker consider timing constraints part controller generation problem scheduling allocation complete 
path scheduling treats timing constraints functional unit constraints intervals serialized control flow graph cfg derives controller minimum number control states scheduling path cfg separately 
recognized constraint solution algorithms drawn layout compaction find asap schedule meets timing constraints 
approach borriello synthesis asynchronous interface transducers 
similar approach satisfy constraints loop iterations 
ku de micheli applied constraint solution problem scheduling timing constraints allocation performed 
technique called relative scheduling added feature guarantee constraint satisfaction presence unknown unbounded delays specialized controller scheme 
relative scheduling performed allocation resource costs considered 
describes new transformational approach scheduling timing constraints 
key approach simple set moves transformations alter existing schedule rescheduling individual operators cases multiple operators 
asap schedule meets timing constraints generated constraint solution techniques similar 
schedule generated allocation starting point search schedules lower cost 
accomplished applying sequence moves randomly selected operators alter schedule control simulated annealing algorithm 
moves applied resulting schedule legal respect ordering timing constraints 
shown legal appear ieee transactions cad may tentative schedule reached legal schedule application sequence moves 
moves alter schedule applied times modified cdfg representation called salsa represent scheduled cdfg speed tasks checking move legality move application evaluation cost function move application 
salsa representation provides support conditional operations mutual exclusion functional units registers accurate representation storage requirements loops subroutines 
annealing approach allows scheduler avoid local minima trap greedy algorithms 
key contribution development conceptually simple transformational approach scheduling timing constraints uses simulated annealing small move set find high quality schedules data dominated 
results show accomplished reasonable amounts cpu time schedule length substantially longer minimum schedule length 
constraint solution provides effective way find initial schedule meets timing constraints constraints preserved move set 
analysis showing legal schedules reached move set lends intuitive support effectiveness approach provides new insight structure scheduling problem 
support conditionals subroutines loops allows application approach large structured designs 
remainder organized follows section describes notation key concepts 
section introduces salsa representation move set explore alternative schedules 
addition discusses completeness move set describes support conditionals loops subroutines 
section discusses techniques initial schedule generation schedule improvement salsa representation 
section describes implementation presents scheduling results number examples 

preliminaries cdfg represented directed graph represents set nodes graph represents set edges nodes 
set nodes includes source node src sink sink operator nodes represent appear ieee transactions cad may tentative operations high level specification 
term delay denotes combinational delay operator node 
schedule length ordered tuple integer represents control step node scheduled 
explicitly included tuple schedules length source node src scheduled control step src sink node sink scheduled control step sink 
edge ij represents data control timing dependency nodes edge weights may associated edge represent spacing requirement associated dependency 
edge weight ij min denotes minimum allowable spacing control steps nodes simple ordering data flow constraints represented weight weight value minimum timing constraints weighted constraint value control steps 
edge weight ij max denotes maximum allowable spacing control steps nodes specified maximum timing constraint 
edge represents inequality relationship scheduled values nodes satisfied legal schedule 
example minimum timing constraint time ij min schedule represents inequality ij min maximum time ij max constraint represents inequality ij max minimum maximum constraints edge ij separated edges ij ji forward edge ij represents minimum constraint backward edge ji represents maximum constraint 
formulation constraints expressed uniform way inequalities form ij ij ij min minimum constraint forward edge ji max maximum constraint backward edge schedule length legal satisfies constraint inequalities specified edges cdfg node scheduled range control steps cdfg definition includes ordering edges source node sink node second requirement satisfied src sink 
appear ieee transactions cad may tentative slack ij constraint ij schedule represents amount scheduled positions nodes decreased increased violating minimum maximum constraint represented ij defined ij ij note legal schedule ij constraint ij inequality satisfied 
useful think schedule nodes point dimensional schedule space 
constraint inequality defines legal half space schedule space satisfies particular constraint 
legal schedule satisfy constraints region legal schedules defined intersection half spaces 
half space convex easily shown region resulting intersection half spaces convex 
illustrate concept schedule space fig 
shows dimensional schedule space results operators constraints time step time steps inequalities implied constraints combine constraints schedule length form trapezoidal region schedule space 
fig 
shows schedules points contained region schedule 
point schedule space adjacent point reached changing schedule single operator node control step 
schedule reached schedule manner rescheduling node diagonally adjacent points schedule space reached changing scheduling operators control step 
schedule reached schedule manner rescheduling nodes useful quantify amount scheduled position operator node varies schedules denoted specifies distance schedules node similarly total distance schedules nodes denoted value equivalent rectilinear distance points schedule space 
example fig 

appear ieee transactions cad may tentative 
salsa schedule representation salsa representation supports transformational approach scheduling describing scheduled cdfg providing set simple moves transform schedule new schedule 
repeated application moves provides means search schedule space guided cost new schedule encountered 
transformational approach requires move applications evaluations cost function important moves fast simple 
addition important quickly test application move result legal schedule 
salsa supports needs explicit representation slack constraints scheduled cdfg 
section describes salsa representation move set 
addition shows move set complete legal schedule reached legal schedule application sequence moves move set 
describes additional considerations including support conditional execution loops subroutines 
slack nodes salsa explicitly represents slack scheduled cdfg new class nodes known slack nodes 
slack nodes inserted data control timing dependency edges operator nodes represent slack existing schedule slack node explicitly represents step slack 
schedule node scheduled step node scheduled step constraint weight ij edge ij contain ij ij slack nodes 
maximum timing constraints represented backward edges slack nodes inserted way 
data edges slack nodes explicitly represent need storage data value control step crossed edge 
data slack node considered scheduled control steps crossed edge shown fig 

representation register costs calculated locally control step examining nodes scheduled control step operator nodes create new value slack nodes represent storage previously created value 
example fig 
shows salsa graph schedule simple cdfg 
step operator nodes produce values control steps 
addition slack nodes represent storage previously created values control appear ieee transactions cad may tentative steps 
total registers required control step 
maximum number registers required control steps schedule require minimum registers 
simple transformation changes part scheduled cdfg local nature calculations exploited speed calculation register costs 
move set important property slack nodes operator rescheduled adjacent control step satisfying constraints predecessor successor nodes slack nodes 
furthermore rescheduling accomplished local rearrangement operator node adjacent slack nodes 
properties exploited defining simple set moves alter schedule rescheduling operator nodes adjacent steps 
salsa provides moves 
moves applied target operator legal schedule results move violate data control timing dependencies 
move legality easily determined performing move checking dependency edges direction move contain slack operators 
simple moves alter schedule moving single operator node adjacent control step 
defined follows move operator node current control step preceding control step 
transforms schedule new schedule 
legal predecessor edges connected slack nodes 
applying removes slack node predecessor edge operator adds slack node successor edge shown fig 

move operator node current control step control step 
transforms schedule new schedule 
legal successor edges connected slack nodes 
applying removes slack node successor edge operator adds slack node predecessor edge shown fig 

application simple move transforms schedule new schedule immediately adjacent schedule space 
example fig 
schedule appear ieee transactions cad may tentative reached schedule applying move node repeated application simple moves allows exploration schedule space simple transformations 
chaining supported minor extension allows moves non slack predecessors successors delay permits 
corresponds slight relaxation ordering constraints estimated combinational delay chained nodes exceed clock period 
chaining single node accomplished modified versions take calculation effect 
powerful recursive chaining move useful move recursively moves predecessor successor nodes chained target node block completion simple chaining move 
chaining affects initial schedule generation discussed section 
scheduling operators multiple control steps pipelined functional units supported directly require special handling 
simple moves require local changes salsa graph cost individual move application low 
moves may required significant changes schedule 
especially true move blocked chain constraints slack 
example fig 
shows schedule operator moved preceding control step slack predecessor edge 
preceding operator moved previous control step slack allowing move 
overcome problem powerful moves defined similar concept shove aside transformations routers 
move recursively moves predecessor successor operators blocking simple move target operator rescheduling operators added expense cpu time 
moves defined follows shove operator node current control step preceding control step 
move accomplished steps predecessor nodes operator nodes block moving recursively apply nodes shove preceding control steps 
move preceding control step move 
operator node moved slack nodes removed predecessor edges added successor edges appropriate 
applied operator node transforms schedule chain non slack predecessor constraints jk li new schedule appear ieee transactions cad may tentative 
legal chain dependent operator nodes extends source node represents schedule 
case completing move result illegal schedule 
fig 
shows example move 
shove operator node current control step control step 
move accomplished steps successor nodes operator nodes block moving recursively apply nodes shove control steps 
move control step move 
node moved slack nodes removed successor edges added predecessor edges appropriate 
applied operator node transforms schedule chain non slack successor constraints ij kl new schedule 
legal chain dependent operators extends sink node represents schedule 
case completing move result illegal schedule 
fig 
shows example move 
moves important minimum maximum timing constraints combined create fixed time constraints specify exact spacing operator nodes 
example fig 
shows schedule space possible schedules nodes fixed time constraint consisting constraints time steps time steps 
constraints form cycle non slack constraints slack constraints cycle 
reason simple moves alter schedule 
moves applied reschedule operators non slack cycle simultaneously example fig 
simple moves legal schedule immediately adjacent legal schedules 
moves reschedule operators simultaneously transforms schedule schedule 
corresponds diagonal move schedule space 
completeness move set moves proposed searching schedule space important show move set complete legal schedules schedule support fixed time constraints moves detect cycles recursively predecessor successor nodes 
accomplished simple marking scheme 
appear ieee transactions cad may tentative space reached moves 
demonstrated showing arbitrary legal schedules sequence moves applied operator nodes cdfg transform sequence legal schedules successively closer schedule schedule 
accomplish useful property legal schedules 
lemma 
legal schedules length differ scheduled position node 
scheduled position node greater schedule schedule successor constraint edge ij node slack schedule scheduled position node greater schedule schedule 
similarly scheduled position node smaller schedule schedule predecessor constraint edge ji node slack schedule scheduled position node smaller schedule schedule 
proof 
consider case slack schedule constraint ij ij replace constraint inequality ij schedule equality relationship ij addition legal schedule constraint inequality constraint ij hold schedule ij inequality satisfied proof case similar omitted 
result show schedules distance move create new schedule closer original schedule lemma 
legal schedules length differ scheduled position node 
scheduled position node greater schedule schedule exists legal schedule reached application move node 
similarly scheduled position node smaller schedule schedule exists legal schedule appear ieee transactions cad may tentative reached application move operator 
proof 
consider case scheduled position node greater schedule schedule case applying move schedule create new schedule node step closer scheduled position schedule show constraints involve satisfied new schedule closer original schedule constraints associated predecessor edges need considered inequalities represent satisfied move 
successor edges consider cases illustrated fig 
case succeeds successor constraint ij slack ij node moved forward control step simple move create new schedule shown fig 

constraints satisfied reduced slack values 

case succeeds successor constraints zero slack node may moved forward control step move create new schedule shown fig 

move complete successfully recursively applied successors successor node 
recursive applications move forward nodes lie paths non slack successor constraints starting node providing path terminated constraint slack forms cycle zero slack constraints 
move simultaneously moves forward nodes path constraints path remain satisfied move completed 
edge path constraint slack lemma node path number nodes moved 
case fail move succeed successor constraints contain slack 
move succeed path constraints involving nodes terminated slack node 
occur node non slack successor constraint sink node sink shown fig 

situation occur legal schedules 
demonstrate assertion assume path constraints extends node sink node shown fig 

appear ieee transactions cad may tentative case lemma sink sink definition schedules legal sink sink occur schedules legal 
case occur cases show move create new schedule 
proof case scheduled position node smaller schedule schedule similar omitted 
result lemma show possible reach schedule schedule theorem 
legal schedules length differ scheduled position node 
exists sequence applications moves selected nodes cdfg transform schedule schedule proof 
lemma move transform schedule new schedule closer schedule applying move create new schedule 
similarly move transform schedule new schedule 
process continued creating sequence intermediate schedules successively closer equivalent intermediate schedule created simple move intermediate schedule reduces distance schedule 
case exactly moves required transform schedule schedule moves reduce distance intermediate schedule moves reduce number moves required reach schedule moves required transform schedule schedule result important shows moves region legal schedules fully explored legal starting schedule 
choice particular starting schedule preclude exploration set schedules region 
direct path legal schedules lies region suggesting illegal configurations needed desirable searching schedule space 
important note number legal schedules grows exponentially number operator nodes exhaustive exploration prohibitively expensive 
motivates probabilistic algorithm simulated annealing guide exploration schedule space 
appear ieee transactions cad may tentative variable length schedules straightforward extension salsa representation allows explore schedules different lengths 
defined section sink node sink cdfg schedule length assigned control step 
varying length schedule corresponds varying scheduled position sink accomplished applying moves defined section sink node nodes graph 
example move move successfully applied sink final step schedule contains slack nodes 
effect shortening schedule control step 
hand applying move sink lengthen schedule user specified upper bound 
move shove redefined slightly complete lengthening schedule necessary 
move fails upper bound schedule length violated 
sequence moves create maximum length schedule analysis move set completeness previous section holds 
cost estimation salsa salsa normally uses cost function weighted sum register functional unit requirements 
variable length schedules specified additional weighted term added cost function account schedule length 
weights userspecified allow tradeoffs resources different types schedule length 
functional unit register costs computed counting requirements control step maximum values control steps 
approaches functional unit costs calculated counting number similar operator nodes type 
register costs determined counting number operator nodes produce data values steps number slack nodes represent previously stored values described section 
full calculation functional unit register costs control steps cdfg expensive 
local nature simple moves allows changes calculated incrementally fashion resource type functional unit register control steps contain maximum demand resource retained critical step list 
simple move affects control steps refer source step operator removed appear ieee transactions cad may tentative destination step operator added adding operator destination step raises demand resources step 
value current maximum demand action taken 
equal current maximum added list critical steps resource 
greater current maximum current critical steps removed destination step new critical step 
removing operator source step lowers demand resources step 
step currently critical step particular resource cost lowered critical steps recalculated 
moves implemented repeated applications 
moves applied incremental cost adjustment recalculated operator moved adding expense moves 
conditionals subroutines loops salsa represents conditional activities approach similar shown fig 

list input conditions attached operation represents conditions activated 
row list represents set input conditions encoded 
universal condition xxx attached unconditional operations signifying execute 
input conditions values cdfg data edges added conditional operators represent values conditional execution 
edges maintain proper sequencing account storage requirements 
conditional operators produce data values require added multiplexer operator select proper value tested condition 
control operators change control flow restarting loop require multiplexer operator may require added control edges maintain proper sequencing 
mutual exclusion operator nodes detected intersection condition lists 
intersection empty mutually exclusive share functional unit 
condition lists attached slack nodes allowing detection mutual exclusion value storage 
condition lists pair nodes slack operator intersect values produce mutually exclusive share register 
note true single cycle multicycle operators move operator adjacent control step 
appear ieee transactions cad may tentative subroutines important tool structuring control data flow behavioral descriptions synthesized designs 
depending designer intent subroutines behavioral description may synthesized number different ways different advantages subroutines may implemented directly controller program 
approach assumes single thread control multiple instances subroutine implemented directly subroutine calls control program 
advantage allowing datapath hardware shared subroutines calling routines 
second subroutines may treated separate structural entities synthesized independently 
case multiple instances subroutine may implemented single datapath datapaths 
advantage allowing hierarchy parallelism 
subroutines may eliminated altogether expanding calling routines 
approach advantage simplifying control structure increases size calling routines 
salsa representation directly supports approach implementing subroutines 
approach allows datapath resources shared subroutines calling routines 
remaining approaches implemented behavioral level transformations process formation inline expansion alter structure behavioral description 
representation subroutines implemented method similar cmu value trace extensions support accurate register cost calculation subroutine execution 
approach subroutines represented separate graphs implemented datapath controller scheduling allocation 
graph scheduled separate sequence control steps bound datapath allocation 
call operator nodes represent activation subroutine graphs 
call node represents transfer control control step calling context sequence control steps subroutine graph 
addition represents transfer data values subroutine calling context data edges call node corresponding edges source node subroutine graph 
similarly represents transfer data values subroutine calling context subroutine data edges sink node subroutine graph corresponding edges call node 
fig 
shows example subroutine graph call nodes transfer control graph 
appear ieee transactions cad may tentative scheduling salsa allows moves applied subroutine graph graph representing main program 
allows scheduling tradeoffs considered simultaneously entire design 
subroutines register cost estimation account local storage requirements subroutine graphs storage requirements calling routines 
example fig 
call nodes activate subroutine graph different storage requirements 
call values require storage execution subroutine 
second call value requires storage 
values considered live calculating register cost scheduled subroutine 
salsa representation describes values explicitly adding data edges source sink node subroutine graph shown fig 

slack nodes edges explicitly represent storage requirements control step imply additional scheduling slack 
call subroutine may active time values different calling contexts mutually exclusive respect 
salsa represents mutual exclusion creating unique bit vector calling context adding vector condition list slack operator 
value trace loops treated special case subroutines 
loop represented separate graph 
loop execution initiated call operator new iterations loop initiated restart operator feeds data values back loop 
wait operations external synchronization implemented way simple loops control step 

scheduling salsa previous section discussed salsa representation alternative schedules explored salsa move set 
schedule meets timing ordering constraints application legal move operator schedule result new schedule meets constraints 
initial schedule meets timing constraints created exploration process proceed 
initial schedule creation method guide exploration process 
section describes techniques accomplish tasks 
appear ieee transactions cad may tentative initial schedule generation initial scheduling phase takes traditional cdfg input finds schedule meets timing constraints adds slack operators form salsa graph 
schedule minimum length schedule schedule length specified user 
find schedule uses iterative algorithm adapted layout compaction 
algorithm similar relative scheduling algorithm performed allocation support unbounded delays 
dimensional layout compaction objects compacted treated nodes directed constraint graph single source sink node 
edges represent relative positioning object left object 
edge weights represent spacing constraints objects distance centers objects greater 
problem constraint solution find assignment objects locations meets spacing constraints minimizes layout size 
compaction research shown constraint graph contains minimum maximum constraints solved execution time refers number nodes refers number maximum constraints 
additional algorithms allow determination graph contains contradictory constraints 
straightforward apply constraint solution techniques problem finding schedule cdfg 
cdfg constraint graph edges weighted represent timing constraints expressed control steps 
data control edges weighted guarantee proper operation ordering timing edges weighted represent constraint values 
fig 
shows constraint solution algorithm scheduling patterned constraint solution algorithm burns newton extended deal chaining 
algorithm operates initially scheduling operators control step iteratively correcting constraint violations moving operators control steps 
operators may violate constraints placed queue processing 
outer loop algorithm removes operators queue time tests constraint violations 
tests violation minimum ordering constraints predecessor operators 
minimum constraint violated corrected moving node control step 
tests violation maximum timing constraints successor nodes 
maximum timing constraint violated corrected appear ieee transactions cad may tentative moving operator control step 
moving operator cause violations constraints operators connected potentially violated constraints placed queue processing 
process iterates queue empty represents schedule constraints met 
chaining supported initial schedule generation slight modification constraint solution algorithm 
chaining enabled operator depends data output operator may placed control step estimated combinational delay cascaded operators exceed clock period 
value exceeded second operator placed control step 
schedule results algorithm equivalent soon possible asap schedule adjusted meet timing constraints 
constraint graph solved reverse order starting sink node number steps 
schedule equivalent late possible schedule meets timing constraints 
schedules way asap schedules determine operator time frames ranges control steps operator may scheduled 
scheduling minimum number control steps operators scheduled control step schedules critical path operators placed control step schedules length 
multiple graphs represent loops subroutines initialization part algorithm modified subroutine assigned unique set control steps 
task straightforward 
maintaining timing constraints presence calls subroutines loops complicated 
execution time subroutine loop known exactly call operators assigned delay represents execution time subroutine loop control steps 
operator scheduled dummy control steps represent time spent execution loop subroutine 
case constraint solution find schedule meets timing constraints 
constraint solution completed dummy control steps removed 
guarantee normal operators scheduled dummy control steps normal operators constrained precede follow call operators adding edges cdfg 
execution time loop subroutine known timing constraint crosses call operation constraint operator precedes appear ieee transactions cad may tentative call operator follows call satisfied circumstances 
lower bound execution time known solving graph assuming minimum number control steps result schedule meets minimum time constraints cross call 
similarly solving graph assuming maximum number control steps result schedule meets maximum timing constraints cross call 
approach minimum maximum constraints cross call remains area research 
schedule improvement schedule improvement implemented simulated annealing 
configuration space annealing problem set legal schedules cdfg 
move set consists moves 
terms schedule space configuration space corresponds region legal schedules 
application simple move operator adjacent control step corresponding move adjacent point schedule space 
application move multiple operators adjacent control steps corresponding move point schedule space differs control step multiple dimensions 
global moves larger changes schedule move operator control step considered experiments showed improvement basic move set 
repeated application move set control simulated annealing corresponds search different points schedule space 
individual schedules may visited move rejected reversed move sequence moves 
illegal configurations annealing implementations particularly module placement 
illegal configurations supported salsa completeness move set guarantees legal schedule reached starting schedule 
region legal schedules convex shortest path schedules lies region legal schedules 
path schedules includes illegal configurations longer 
true module placement module overlap constraints result region legal configurations convex shortest path configurations sequence illegal overlapping configurations 
constraint solution discussed earlier create initial legal schedule 
minimum length schedule specified user critical path operators identified appear ieee transactions cad may tentative time 
critical path operators schedule position excluded consideration move applications 
simulated annealing implemented straightforward manner cost value weighted sum resource requirements described section temperature control parameter temperature parameter set initial temperature gradually lowered 
temperature move attempts 
attempt move operator selected random move tested legality selected operator 
illegal attempt discarded applying move 
legal move applied change cost dc calculated 
negative value dc reflects improved configuration 
downhill move accepted 
positive value dc reflects inferior configuration 
uphill moves accepted probability dc acceptance probability allows acceptance uphill moves escape locally optimal points design space 
rejected moves reversed applying equivalent move opposite direction 
temperature controlled adaptive cooling schedule adaptation 
calculates initial temperature temperature changes equilibrium conditions statistics gathered number moves annealing begins 
move attempts temperature equilibrium detected upper bound reached weighted sum number critical operators schedule length 
schedule terminates change cost number successive temperatures typically 
move selection biased moves operators reduce schedule cost 
accomplished selecting operators critical steps resources contribute current cost 
selection resource chosen probability proportional relative resource cost demand resource exceeds preset threshold typically lower bound functional units type 
operator chosen random critical step selected resource 
moving operators critical steps reduces demand control step tends reduce schedule cost 
useful attempt moves operators control steps may indirectly provide opportunities reduce cost 
appear ieee transactions cad may tentative reason selected operators typically chosen random list non critical operators regard current control step 
operator selected simple move selected random attempted 
attempt fails chaining allowed simple chaining move attempted direction 
second attempt fails move recursive chaining move attempted 
attempts fail final move applied occasionally typically cases returns search best schedule far 

implementation results salsa representation scheduler implemented lines including initial schedule generation schedule improvement phases 
separate translator developed reads cmu value trace files system architect workbench translates files salsa representation 
salsa scheduler tested number examples 
results examples summarized tables iii 
examples include small examples previously literature control dominated benchmark example larger data dominated examples 
table lists schedule length resource requirements estimated problem size cpu seconds execution time annealing run cpu times measured sun sparcstation ipc mb memory 
evaluating scheduling speed important recognize complexity scheduling problem grows number operators cdfg length schedule 
estimated problem size entry tables iii attempts estimate complexity total number scheduled positions operator may assigned 
value equal number variables required represent scheduling problem ilp formulation 
table summarizes results examples 
code sequence example shows operation chaining small data dominated example 
schedule created chaining second schedule created chaining enabled 
case chaining created schedule fewer control steps expense added functional units 
temperature controller example simple example illustrates interaction scheduling timing appear ieee transactions cad may tentative constraints 
cases quality results matches reported previously 
rcvr example control dominated example part high level synthesis benchmark 
scheduler reduces resource demands possible control oriented approaches path scheduling give better results example especially terms number control states 
improving performance area important area 
fifth order elliptic wave filter benchmark intensively studied 
consists operators multiply constant addition 
table ii summarizes results example number schedule lengths different sets assumptions 
set results chaining allowed adder delay assumed clock cycle multiplier delay assumed clock cycles 
non pipelined multipliers case 
second set results set assumptions pipelined multipliers latency clock cycle 
third set results chaining allowed 
case execution time annealing increases schedule length increases slower rate increase estimated problem size 
sets results compared results literature 
cases salsa finds schedules match cost best schedules researchers including known optimal fewer results available chaining schedules 
reports step schedules path scheduling functional unit constraints serially ordered cdfg 
similar schedules salsa shown table iii 
addition salsa step schedule requiring multiplier functional unit 
comparing approaches important note quality schedule path scheduling depends initial serial ordering nodes orderings result longer schedules 
contrast salsa requires ordering minimizes functional unit register requirements 
examining quality schedules chaining interesting compare functional unit requirements absolute lower bounds resource requirements register requirements may reduced cases input assumed stored dedicated input register 
appear ieee transactions cad may tentative derived 
chaining bound predicts number functional units type smaller number operators type divided number control steps 
chained ewf schedules multiplier adder costs equal absolute lower bound 
demonstrates contrast initial experience small example chaining possible find low cost schedules smaller number control steps approaches 
opportunities come expense complex scheduling problem estimated problem sizes chained versions ewf example larger approaches due larger time frames result chaining 
discrete cosine transform dct show behavior salsa larger examples 
dct extensively image coding compression implemented hardware special purpose image processors 
fig 
shows cdfg point dct patterned implementation described 
consists operators multiply constant add subtract 
ewf example relatively long minimum schedule length steps case dct short minimum schedule length steps case 
substantially increases difficulty finding schedules contain reasonable number functional units 
table iii summarizes scheduling results example scheduling conditions ewf example non pipelined multipliers pipelined multipliers chaining 
addition assumed add subtract operators implemented alu functional units perform operations 
ewf example pipelined multipliers allow substantial reduction functional unit costs 
ewf example chaining provides best way find low cost schedules small number control steps 
schedules produced chaining match absolute lower bound functional units steps 
scheduler able produce step schedule absolute lower bound multiplier adders 
result step schedule 
execution times dct show execution times grow reasonable rate schedule length increases 
salsa consistently finds best schedules small examples ewf single annealing run larger examples dct 
occurs multiple runs improve schedule expense additional cpu time 
appear ieee transactions cad may tentative table iv summarizes execution times salsa ewf example compared number previous approaches 
measurements processors widely varying speed difficult results accurate comparisons 
drawn results 
salsa shows clear advantage simulated annealing approach simultaneously considers scheduling operator allocation estimated interconnect cost 
believe advantage due reduced problem scope scheduling due fact salsa efficient representation move set allows configurations explored quickly 
salsa appears clear advantage execution times force directed scheduling discrepancy processor speed sets measurements large render comparison meaningless 
compared results extended fds algorithm advantage faster processor 
importantly analysis fds algorithm shown execution time grows square schedule length 
contrast difficult characterize execution time probabilistic algorithm time related maximum number move attempts temperature 
salsa value grows linearly respect schedule length 
results ilp approach non pipelined multipliers control steps 
execution times smaller salsa grow rapidly increasing schedule length 
extension adds constraints support chaining pipelined functional units 
execution times available features chaining number added constraints grows exponentially depth chaining allowed 
results ip approach scheduling allocation step schedules pipelined multipliers 
approach uses cpu time salsa approach includes consideration interconnect cost allocation 
execution times greatly reduced functional unit cost considered shown final entry table iv 
ilp ip approaches attractive optimal solution guaranteed 
results show schedule lengths close minimum schedule lengths execution times quite 
cases schedule length substantially longer minimum length chaining number variables problem formulation grows rapidly shown tables ii iii 
execution times approaches expected grow rapidly number appear ieee transactions cad may tentative variables believe heuristic approaches salsa competitive large class practical synthesis problems 

described new approach scheduling timing constraints minimizes resource costs 
specialized representation move set provide way quickly explore scheduling alternatives initial schedule constraint solution 
simulated annealing provides effective way implement exploration yields results reasonable execution times especially chaining schedule lengths substantially longer minimum schedule lengths 
proof legal schedules may reached move set provides confidence schedule space thoroughly explored annealing 
addition provides new insight scheduling problem may useful approaches 
concentrate improving schedule quality control dominated examples improving annealing performance large examples extending approach include support interconnections allocation general timing constraints 
authors anonymous reviewers suggestions improving mcfarland vissers helpful discussions concerning scheduling helpful discussions concerning simulated annealing 
mcfarland parker high level synthesis digital systems proceedings ieee vol 
feb 
nestor thomas behavioral synthesis interfaces proceedings iccad pp 
nov 
considering timing constraints synthesis behavioral description proceedings iccd pp 
oct 
borriello katz synthesis optimization interface transducer logic proceedings iccad pp 
november 
paulin knight force directed scheduling behavioral synthesis asic ieee trans 
cad vol 

pp june 
appear ieee transactions cad may tentative hitchcock thomas method automatic data path synthesis proceedings th dac pp 
june 
tseng siewiorek automated synthesis data paths digital systems ieee trans 
cad vol 
cad pp 
july 
thomas walker nestor rajan blackburn algorithmic register transfer level synthesis system architect workbench kluwer academic publishers 
knight ada standard cell hardware compiler graph grammars scheduling proceedings iccd pp 
oct 
mcfarland kowalski incorporating bottom design high level synthesis ieee trans 
cad vol pp 
sept 
gajski slicer state synthesizer intelligent silicon compilation proceedings iccd oct 
goossens vandewalle de man loop optimization register transfer scheduling dsp systems proceedings th dac pp 
june 
kirkpatrick gelatt vecchi optimization simulated annealing science vol 
pp 
may 
devadas newton algorithms hardware allocation data path synthesis ieee trans 
cad vol 
pp july 
grover pipelined non pipelined data path synthesis simulated annealing progress computer aided vlsi design vol 
feb 
ly applying simulated evolution scheduling highlevel synthesis proceedings ieee rd midwest symposium circuits systems 
lee new integer linear programming formulation scheduling problem data path synthesis proceedings iccad pp 
november 
global optimization approach architectural synthesis proceedings th dac pp 
june 
parker automatic production controller specifications control timing behavioral descriptions proceedings th dac pp 
june 
path scheduling ieee trans 
cad vol 
january 
liao wong algorithm compact vlsi symbolic layout mixed constraints ieee trans 
cad vol 
cad pp 
april 
borriello new interface specification methodology application transducer synthesis ph thesis university california berkeley may 
ku de micheli relative scheduling timing constraints proceedings th dac pp 
june 
steiglitz combinatorial optimization algorithms complexity prentice hall 
appear ieee transactions cad may tentative routing physical design automation vlsi systems ed benjamin cummings 
tseng wei tong bose bridge versatile behavioral synthesis system proceedings th dac pp 
june 
resource sharing control synthesis method conditional branches proceedings iccad pp 
nov 
burns newton new constraint ic symbolic layout spacer proceedings pp 
may 
newton symbolic layout procedural design design systems vlsi circuits pp 
nijhoff 
parker program datapath synthesis proceedings nd dac pp 
july 
simulated annealing algorithms overview ieee circuits devices magazine vol 
january 
huang romeo sangiovanni vincentelli efficient general cooling schedule simulated annealing proceedings iccad pp 
november 
borriello high level synthesis current status directions proceedings th dac pp 
june 
paulin knight scheduling binding algorithms high level synthesis proceedings th dac pp 
june 
hwang lee hsu formal approach scheduling problem high level synthesis ieee transactions cad pp 
vol 
april 
rabaey chu potkonjak fast prototyping architectures ieee design test computers vol 

june 
dimensional linear picture transformer patent 
aarts korst improved force directed scheduling proceedings pp 
february 
appear ieee transactions cad may tentative timing constraint time steps source node sink node fig 

control data flow graph cdfg john nestor krishnamoorthy appear ieee transactions cad may tentative fig 

schedule space john nestor krishnamoorthy appear ieee transactions cad may tentative source node sink node slack operator timing constraint step step step fig 

salsa cdfg representation john nestor krishnamoorthy appear ieee transactions cad may tentative fig 

simple moves john nestor krishnamoorthy appear ieee transactions cad may tentative fig 

move shove john nestor krishnamoorthy appear ieee transactions cad may tentative fig 

move shove john nestor krishnamoorthy appear ieee transactions cad may tentative fig 

operators fixed time constraint john nestor krishnamoorthy appear ieee transactions cad may tentative case succeeds vi vi vj vk vi vj vk case succeeds schedule schedule schedule schedule sink vi vj vk vr case fail fig 

considerations moving operator john nestor krishnamoorthy appear ieee transactions cad may tentative xx xxx unconditional operator xx condition cube fig 
conditional execution john nestor krishnamoorthy appear ieee transactions cad may tentative call call sink src const const subroutine graph calling context value value value fig 

subroutine graph call nodes john nestor krishnamoorthy appear ieee transactions cad may tentative sink src const value value value fig 

subroutine graph added data edges john nestor krishnamoorthy appear ieee transactions cad may tentative constraint solution start ops scheduled step node successor source src enqueue check constraints nodes queue queue empty dequeue lower bound upper bound process minimum constraints dependencies predecessors predecessor edge ij chaining enabled ij timing constraint comb delay longest comb delay delay comb delay lower bound max lower bound lower bound max lower bound lower bound max lower bound ij min process maximum constraints successors successor edge jk upper bound max upper bound jk max reschedule necessary enqueue constrained nodes max max lower bound upper bound predecessor edge ij vj ij max represents valid max 
constraint enqueue successor edge jk jk min represents valid min 
constraint enqueue fig 

constraint solution algorithm initial schedule generation john nestor krishnamoorthy appear ieee transactions cad may tentative fig 

cdfg dct example john nestor krishnamoorthy appear ieee transactions cad may tentative example steps fu fu fu reg cpu sec chained rcvr table various examples john nestor krishnamoorthy appear ieee transactions cad may tentative schedule characteristics steps fu fu reg prob 
size cpu sec non pipelined multipliers chaining pipelined multipliers chaining table ii fifth order elliptic wave filter john nestor krishnamoorthy appear ieee transactions cad may tentative schedule characteristics steps fu fu reg prob 
size cpu sec non pipelined multipliers chaining pipelined multipliers chaining table iii discrete cosine transform example john nestor krishnamoorthy appear ieee transactions cad may tentative scheduler cpu time machine type salsa sun sparc ipc sa dec vax fds xerox extended fds apollo dn ilp dec vax intel fu intel table iv comparison execution times ewf example 
