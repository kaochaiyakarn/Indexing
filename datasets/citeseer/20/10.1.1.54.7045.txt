logic programming golog logic programming language dynamic domains hector levesque raymond reiter yves lesp erance fangzhen lin richard scherl proposes new logic programming language called golog interpreter automatically maintains explicit representation dynamic world modeled basis user supplied axioms preconditions effects actions initial state world 
allows programs reason state world consider effects various possible courses action committing particular behavior 
net effect programs may written higher level abstraction usually possible 
language appears suited applications high level control robots industrial processes intelligent software agents discrete event simulation formal theory action specified extended version situation calculus 
prototype implementation prolog developed 

computer systems embedded complex environments interact 
programming applications designer normally elaborate research received financial support information technology research center ontario canada institute robotics intelligent systems canada natural science engineering research council canada 
levesque reiter fellows canadian institute advanced research 
address correspondence department computer science university toronto toronto canada 
reiter fl cs toronto edu 
www cs toronto edu current address department computer science college york university ave toronto canada 
current address department computer information science new jersey institute technology university heights newark nj usa 
journal logic programming fl elsevier science avenue americas new york ny mental model environment system actions change environment state 
users system kind mental model 
typically system maintain explicit model world operating 
life difficult programmers users may having reconstruct model way system explain justify behavior 
importantly difficult reconfigure extend system giving high level instructions understanding doing 
propose programming language systems design sophisticated logic action 
interpreter language automatically maintains explicit model system environment capabilities queried reasoned run time 
allows complex behaviors defined higher level abstraction possible 
language appears distinct improvement current technology applications high level control robots mechanical devices programming intelligent software agents modeling simulation discrete event systems section outline theory action language 
show complex actions defined framework explain resulting set complex action expressions viewed programming language 
section illustrate language example simple elevator controller 
section describe implementation language sketch experimental applications developed 
section discusses main distinguishing characteristics language 
conclude summarizing main features proposal discussing limitations outlining ongoing seeks address 
presentation informal nature companion explore formal aspects 

informal situation calculus obtain benefits mentioned necessary explicitly model world changes result performing actions 
variety ways doing language situation calculus 

intuitive ontology situation calculus situation calculus mccarthy order language shall see second order features specifically designed representing dynamically changing worlds 
changes world result named actions 
possible world history simply sequence actions represented order term called situation 
constant denote initial situation situation actions occurred 
distinguished binary function symbol ff denotes successor situation resulting performing action ff 
actions may parameterized 
example put stand action putting object object similar view advanced dixon 
case put denotes situation resulting placing world situation notice situation calculus actions denoted order terms situations world histories order terms 
example putdown walk pickup situation denoting world history consisting sequence actions pickup walk putdown 
notice sequence actions history order occur obtained situation term reading actions right left 
relations truth values vary situation situation called relational fluents denoted predicate symbols situation term argument 
example carrying robot meaning robot carrying package situation relational fluent 
functions denotations vary situation situation called functional fluents 
denoted function symbols extra argument situation term loc robot robot location situation 
axiomatizing actions effects situation calculus actions preconditions necessary sufficient conditions characterize action physically possible 
example blocks world oss pickup holding heavy world dynamics specified effect axioms 
describe effects action fluents causal laws domain 
example robot dropping fragile object causes broken oss drop fragile oe broken drop exploding bomb object causes broken oss explode oe broken explode robot repairing object causes broken oss repair oe broken repair 
frame problem observed mccarthy hayes axiomatizing dynamic world requires just action precondition effect axioms 
called frame axioms necessary 
specify action invariants domain fluents remain unaffected action 
example robot dropping things affect object colour oss drop colour oe colour drop formulas free variables considered universally quantified outside 
convention followed 
frame axiom describing fluent broken remains unaffected oss drop broken fragile oe broken drop problem introduced need frame axioms expect vast number 
relatively actions affect truth value fluent actions leave fluent unchanged 
example object colour changed picking things opening door going walk electing new prime minister canada problematic think axioms problematic theorem proving system reason efficiently presence frame axioms 

counts solution frame problem 
suppose person responsible axiomatizing application domain specified causal laws world axiomatized 
precisely succeeded writing effect axioms fluent action cause truth value change axioms form oss oe order formula specifying contextual conditions action specified effect solution frame problem systematic procedure generating effect axioms frame axioms 
possible want parsimonious representation frame axioms simplest form 

simple solution frame problem appealing earlier ideas haas schubert pednault reiter proposes simple solution frame problem illustrate example 
suppose effect axioms fluent broken describe ways action change truth value broken 
rewrite logically equivalent form oss fa drop fragile fa explode oe broken similarly consider negative effect axiom broken rewritten oss repair oe broken general assume effect axioms fluent written forms poss fl oe poss fl gamma oe fl formula describing conditions doing action situation leads fluent true successor situation similarly fl gamma describes conditions performing results false successor situation 
solution frame problem rests completeness assumption causal axioms characterize conditions action lead fluent true respectively false successor situation 
words axioms describe causal laws affecting truth values fluent action possible truth value changes false true result doing fl true similarly change true false 
reiter shows derive successor state axiom form causal axioms completeness assumption 
successor state axiom oss oe fl fl gamma single axiom embodies solution frame problem 
notice axiom universally quantifies actions fact way parsimonious solution frame problem obtained 
applying example breaking things obtain successor state axiom oss oe broken fa drop fragile fa explode broken repair important note solution frame problem presupposes state constraints example blocks world constraint oe 
constraints implicitly contain effect axioms called indirect effects case completeness assumption true 
assumption state constraints axiomatization domain 
approach discussed section extended deal state constraints compiling effects successor state axioms :10.1.1.51.3134

axiomatizing application domain situation calculus general particular domain application specified union sets axioms ffl action precondition axioms primitive action 
ffl successor state axioms fluent 
ffl unique names axioms primitive actions 
ffl axioms describing initial situation true initially actions occurred 
finite set sentences mention situation term situation term ffl foundational domain independent axioms situation calculus 
include unique names axioms situations induction axiom 
play special role omit 
details metamathematical properties see lin reiter reiter 

complex actions procedures golog previous section outlines situation calculus approach representing reasoning simple actions 
fails address problem expressing reasoning complex actions procedures example ffl car drive walk endif ffl block ontable block remove block endwhile ffl proc remove block pickup endproc introduced procedure declaration remove block nondeterministic operator ffi means nondeterministically pick individual perform ffi 
shall see kind nondeterminism useful robotics similar applications 

complex actions procedures situation calculus approach define complex action expressions additional extralogical symbols act abbreviations logical expressions language situation calculus 
extralogical expressions thought macros expand genuine formulas situation calculus 
define abbreviation ffi ffi complex action expression intuitively ffi hold situation terminating situation execution complex action ffi starting situation note complex actions may nondeterministic may different executions terminating different situations 
defined inductively structure argument follows 
primitive actions def oss notation mean result restoring situation arguments functional fluents mentioned action term see item immediately 
example read favorite book john favorite book functional fluent means value situation dependent read favorite book john 

test actions oe def oe oe pseudo fluent expression situation calculus formula stands formula language situation calculus situation arguments suppressed 
oe denotes situation calculus formula obtained oe restoring situation variable suppressed situation argument fluent names relational functional mentioned oe 
examples oe ontable oe stands ontable oe favorite block mary oe stands favorite block mary 
sequence ffi ffi def ffi ffi 
nondeterministic choice actions ffi ffi def ffi ffi 
nondeterministic choice action arguments ffi def ffi 
nondeterministic iteration execute ffi zero times 
ffi def ffi oe oe words doing action ffi zero times takes iff set smallest set set situations 
set doing ffi situation takes situation set 
definition nondeterministic iteration utilizes standard second order way expressing set 
appeal second order logic appears necessary transitive closure order definable nondeterministic iteration appeals closure 
conditionals loops defined terms constructs follows oe ffi ffi endif def oe 
ffi oe 
ffi oe ffi endwhile def oe 
ffi oe procedures difficulty giving situation calculus semantics recursive procedure calls macro expansion straightforward way macro expand procedure body body includes recursive call 

auxiliary macro definition predicate symbol arity pair situation arguments def follows expressions form occurring programs serve procedure calls understand mean executing procedure actual parameters causes transition situation notice macro expansion actual parameters evaluated respect current situation passing procedure procedure mechanism defining call value 
want include procedure calls actions extend definition complex actions consist expression constructed primitive actions procedure calls complex action constructors 

define situation calculus semantics programs involving recursive procedures 
suppose standard block structured programming style golog program consists sequence declarations procedures pn formal parameters procedure bodies ffi ffi respectively followed main program body ffi ffi ffi ffi complex actions extended actions procedure calls described 
golog program form proc ffi endproc delta delta delta proc pn ffi endproc ffi define result evaluating program form follows ffi endproc delta delta delta proc pn ffi endproc ffi def pn ffi oe oe ffi situation calculus definition corresponding usual scott strachey fixed point definition standard programming language semantics stoy 
examples 
means move elevator floor define meaning move elevator floors 
proc 
gamma endproc 
parking elevator ground floor proc park loor 
endproc 
define test action transitive closure 
proc 

endproc 
clean means put away blocks box 
proc clean block oe box 

put box clean endproc programs bodies procedures obtain treestructured nesting procedures typical algol languages 
get lexical scoping rules languages free quantifiers definition 

golog blocks world program consisting procedure declarations devoted creating towers blocks main program block tower ensuring block clear final situation 
proc tower blocks 
tower 
tower means tower blocks top block stack gamma unstack gamma endif endproc proc stack place blocks tower top block 
put stack gamma endproc proc unstack remove blocks tower top block 

movetotable unstack gamma endproc main create block tower clear 

procedures formalization draws considerably dynamic logic 
effect reifies situations object language situation calculus possible worlds semantics dynamic logic defined 
technical treatment macro approach complex actions see levesque lin reiter 

macros 
programs complex actions macro expand second order formulas situation calculus complex behaviors described situation calculus formulas 
treat macros class objects terms language situation calculus 
see consider complex action block ontable block remove block endwhile ask kind thing ontable block 
fluent fluents take situations arguments 
meant stand fluent expression ontable block evaluated respect current situation execution loop 
see happen avoid macro approach suppose treat complex actions genuine order terms language situation calculus 
ffl augment language new distinguished function symbols 
ffl loop order term order term 
formula standing situation calculus formula ontable block ontable red ffl introduce new function symbols language ontable exists 
need distinguish fluent 
formulas look genuine terms ontable block exists exists ontable red notice constants 
words reify fluents formulas fluents situation arguments suppressed 
resulting order language complicated 
ffl worse axiomatize correspondence reified formulas actual situation calculus formulas stand 
axioms reified formulas get evaluated apply apply true iff reified formula situation argument restored genuine situation calculus formula true 
axiomatize apply 
axioms schemas fluents reified formulas quantified variables expressions 
apply apply apply apply restores situation arguments functional fluents 
needed apply apply apply apply apply apply result complex theory 
avoid technical clutter chosen take macro route defining complex actions see just far push idea 
shall see possible develop rich theory actions way 

programs macros price pay 
opting define programs macros obtain simpler theory reify actions 
price pay expressive formalism 
example quantify complex actions objects language situation calculus 
means example synthesize programs conventional theorem proving techniques manna waldinger 
approach program synthesis obtain program satisfying goal formula goal side effect proving entailment axioms ffi ffi goal axioms described section 
program synthesized existentially quantified theorem theorem expressed language 
hand program properties principle provable formalism 
doing conceptually straightforward precisely program executions formulas situation calculus 

correctness show program ffi terminates leads world situation satisfying property axioms ffi oe stronger axioms ffi oe 
termination show program ffi terminates axioms ffi stronger axioms ffi words macro account suited applications program ffi job prove property 
see main property concerned execution ffi initial situation find terminating situation ffi exists 
prove termination ffi extract proof binding terminating situation 

golog program complex action expressions defined viewed programming language semantics defined macro expansion sentences situation calculus 
call language golog algol logic 
golog appears offer significant advantages current tools applications dynamic domains high level programming robots software agents process control discrete event simulation section simple example 

elevator controller golog show axiomatize primitive actions fluents simple elevator write golog program control elevator 
primitive actions ffl move elevator floor ffl move elevator floor ffl turnoff turn call button ffl open open elevator door 
ffl close close elevator door 
fluents ffl current loor situation elevator floor ffl situation call button 
ffl loor situation floor served primitive action preconditions oss current loor oss current loor oss open true oss close true oss turnoff successor state axioms oss oe current loor fa current loor oss oe turnoff defined fluent 
loor oe jm gamma current loor jn gamma current loor defines floor served nearest floor elevator happens 
golog procedures proc serve go loor turnoff open close endproc proc go loor current loor 
endproc proc serve loor loor 
serve endproc proc control serve loor endwhile park endproc proc park current loor open open endif endproc initial situation current loor notice axiom specifies initially buttons buttons 
words complete information initially call buttons 
completeness property initial situation justify part prolog implementation described section 
running program theorem proving task need establish entailment axioms control speaking prove sentence pi control pi sequence procedure declarations just 
call control sentence serves main program 
see definition golog programs semantics section 
axioms section 
notice especially entailment says sense 
ffl expression control looks atomic formula macro predicate expression stands longer second order situation calculus sentence 
mention primitive actions turnoff open close fluents current loor loor distinguished situation calculus symbols oss 
ffl macro expanded sentence legitimate situation calculus sense seek proof axioms characterize fluents actions elevator world 
successful execution program successful proof return binding open close open turnoff close open turnoff binding represents execution trace golog program description initial situation 
trace action sequence turnoff open close turnoff open close open passed elevator execution module controlling physical world 
see example golog logic programming language sense 
interpreter general purpose theorem prover 
general form theorem prover second order logic practice see section levesque lin reiter order logic sufficient purposes 

prolog golog programs executed side effects obtain bindings existentially quantified variables theorem 

implementation experimentation section discuss implementation golog language prolog 
presenting simple version interpreter 
show elevator example written interpreter execution traces 
conclude listing applications currently investigated golog 

interpreter execution golog involves finding proof second order logic somewhat surprising easy write golog interpreter 
shows entire program 
predicate takes arguments golog action expression terms standing initial final situations 
normally query 
golog interpreter op 
nondeterministic action choice 
clause sequences 
holds 

neg 
star star 
star neg 
pi sub 
proc 
poss 
sub name new term term term term name replaced new 
sub var 
sub var 
sub sublist 
sublist 
sublist sub sublist 
holds holds holds 
holds holds holds 
holds neg holds 
negation failure holds sub holds 
form answer binding final situation implementation legal golog action expression ffl en sequence 
ffl condition see 
ffl nondeterministic choice ffl conditional 
ffl star nondeterministic repetition 
ffl iteration 
ffl pi nondeterministic assignment atom standing golog variable golog action expression uses ffl name user declared primitive action defined procedure see 
condition fluent expression form neg atom condition evaluating conditions interpreter uses negation failure handle neg consults user supplied holds predicate determine fluents true 
implementation golog application elevator expected parts 
collection clauses form primitive action act declaring primitive action 

collection clauses form proc name body declaring defined procedure recursive 
body legal golog action expression 

collection clauses define predicate poss act situation primitive action situation 
typically requires clause action variable range situations 

collection clauses define predicate holds situation fluent situation 
normally done parts collection clauses defining holds characterizing fluents true initial situation 
clauses need atomic involve arbitrary prolog computation determining entailments initial database 
usual prolog closed world assumption database 
collection clauses defining holds act situation combination fluent primitive action situation 
typically done single clause fluent variables actions situations 
amounts writing successor state axiom fluent 
interpreter appear intuitively doing right thing cases closed world assumption cwa turns non trivial state precisely sense correct 
hand specification formula second order logic predicate characterized set horn clauses 
exact correspondence depends number factors intend discuss 
formal statement proof correctness interpreter interested reader consult companion 
simplicity characterization predicate order horn clauses complexity formula results secondorder logic reasonable question ask bother 
answer definition weak sufficient finding terminating situation exists initial show non termination 
consider program ffi program ffi entailed predicate simply run forever 
hand semantics prolog formulated terms minimal models case simple logic programs interpreter number desirable features 
ideas second order quantification characterize golog program execution 
answer set axioms characterizing initial situation part logic program 
specification needs hedged prolog interpreter sufficient assume breadthfirst execution strategy 
golog programs park section terminate cause run forever 
hand fully general exactly right thing axioms describing initial situation contain disjunctions existential quantifications 
semantics logic programs generalized accommodate axioms clear resulting specification simpler 
emphasize interpreter relies standard prolog cwa initial database facts true initial situation complete 
case logical specification elevator example section 
applications reasonable assumption 
unrealistic example robotics setting environment completely known robot 
cases general golog interpreter necessary 
interpreter prolog backchaining mechanism reduce queries current situation queries initial situation 
words regression query evaluation waldinger pednault reiter implemented prolog 
answering regressed queries initial situation require general full power order theorem prover 

elevator example clauses defining previously discussed elevator example show queries interpreter program 
query ask interpreter repeatedly pick floor turn call button buttons 
answers show ways turn floor way 
second query ask interpreter turn call button go floor satisfies test floor 
predicate defined hold floors button gives choices turn floor go floor 
final query call main elevator controller control serve floors park elevator 
ways doing serve floor park serve floor park note attempted prune backtracking avoid duplicate answers 

experimentation actual implementation golog university toronto quintus prolog incorporates number additional features debugging efficiency simple interpreter 
example serious limitation style interpreter determining condition current floor holds situation involves looking actions led situation unwinding actions way back initial situation 
process called regression ai planning literature 
doing repeatedly long sequences actions take considerable time 
prolog terms representing situations far removed initial situation gigantic 
possible cases progress initial database handle lin reiter 
idea interpreter periodically rolls initial database forward response actions generated far 
elevator controller primitive control actions turnoff 
turn call button open 
open elevator door 
close 
close elevator door 

move elevator floor 
move elevator floor definitions complex control actions proc 
proc serve turnoff open close 
proc pi serve 
proc park open open 
control main loop 
long active call button serves floor 
buttons parks elevator 
proc control park 
preconditions primitive actions poss holds poss holds poss open 
poss close 
poss turnoff holds 
successor state axioms primitive fluents 
holds holds 
holds holds turnoff 
initial situation 
call buttons 
elevator floor 
holds 
holds 
holds 
determines active call buttons served 
simply choose arbitrary active call button 
holds holds 
evaluation program 
progressed database new initial database purposes continuing evaluation program 
way interpreter maintains database just current value fluents 
running elevator program pi turnoff 
turnoff turnoff pi turnoff 
turnoff turnoff control 
open close open turnoff close open turnoff open close open turnoff close open turnoff open close open turnoff close open turnoff open close open turnoff close open turnoff distance initial situation longer problem 
evaluate interpreter entire golog framework experimenting various types applications 
advanced involves robotics application mail delivery office environment 
high level controller robot programmed golog interfaced existing robotics package supports path planning local navigation 
system currently works simulation mode experiments real robot begun collaboration robotics group university bonn 
application involves tools home banking 
case number software agents written golog handle various parts banking process responding buttons atm terminal managing accounts bank monitoring account levels user communicate tcp ip 
congolog version language supporting concurrency including interrupts priorities support exogenous actions implemented experiments various applications meeting scheduling multi elevator coordination way 

discussion golog designed logic programming language dynamic domains 
full name algol logic implies golog attempts blend algol programming style logic 
borrows algol known studied programming constructs sequence conditionals recursive procedures loops 
algol conventional programming languages programs golog decompose primitives cases refer actions external world picking object telling agent opposed commands merely change machine states assignments registers 
furthermore primitives formulated axioms order logic effects formally reasoned 
feature golog supports specification dynamic systems right level abstraction 
importantly golog programs evaluated theorem prover 
user supplies precondition axioms action successor state axioms fluent specification initial situation world golog program specifying behavior agents system 
executing program amounts finding ground situation term oe axioms program oe done trying prove axioms program constructive proof obtained ground term obtained binding variable sequence actions sent primitive action execution module 
looks logic programming languages prolog 
general purpose logic programming languages golog designed specifically specifying agents behaviors modeling dynamic systems 
particular golog actions play fundamental role 
body literature related golog project 
dixon 
programming language conventional imperative style 
designed observation semantics embedded programs reflect assumptions environment directly possible 
similar concern language primitives user defined high level abstraction 
golog requires primitives formally specified language 
consequence programs golog executed theorem prover 

classical ai planning green fikes nilsson 
classical ai planning golog requires primitives effects formally specified 
major difference golog focuses highlevel programming plan synthesis run time 
sketchy plans allowed nondeterminism infer missing details 
elevator example left golog interpreter find legal sequence actions serve active call buttons 
go 
extreme case program goal appropriate endwhile repeatedly selects appropriate action performs goal achieved 
finding legal sequence actions case simply reformulation planning problem 

situated automata 
golog shares situated automata philosophy designing agents high level language compiling high level programs low level ones immediately executed 
framework considered low level programs simply sequences primitive actions 
consider cases involving sensing see sequence exists necessary compile low level programs containing loops conditionals 

shoham agent programming language 
includes model commitments capabilities simple communication acts built agents generic rule architecture global clock beliefs time stamped propositions 
automatic maintenance agents beliefs specification primitive actions golog types complex actions handled emphasis having complete formal specification system 
number groups developing formalisms specification artificial agents 
see detailed survey research 

transaction logic bonner kifer 
new logic defining complex database transactions golog provides rich repertoire operators defining new transactions terms old 
include sequence nondeterministic choice conditionals iteration 
approach focuses definition complex transactions terms elementary updates 
assumption elementary updates successfully address frame problem complex update defined terms elementary ones inherit correct solution frame problem 
unfortunately bonner kifer address frame problem elementary updates task left person specifying database 

strategies mccarthy hayes 
surprisingly early proposal representing complex actions called strategies situation calculus 
mccarthy hayes appeal algol language rep strategies include mechanism returning symbolic execution traces sequences actions strategies 
sketch method proving properties strategies 
mccarthy hayes provide formal development proposal anticipates spirit technical content golog project 
version golog omits important considerations 
partial list 
sensing knowledge 
modeling autonomous agent necessary consider agent perceptual actions acts seeing hearing ordinary actions affect environment perceptual actions affect agent mental state state knowledge 
scherl levesque provide situation calculus account knowledge setting show solve frame problem perceptual actions 

sensing knowing 
presence sensing actions method described executing golog program longer adequate 
example suppose sensing action reads truth value primitives possible 
program perfectly reasonable endif executable respect initial situation 
case axioms oe ground situation term oe compile time agent know truth value know exact sequence primitive actions corresponds execution program 
considered possible solutions problem 
see 

exogenous actions 
assumed events importance agent control 
elevator example include primitive action meaning push call button action occur time elevator control 
example exogenous action 
examples actions nature control starts rain falling ball bounces reaching floor 
writing elevator robot controller include exogenous actions part program robot position cause actions happen 

concurrency reactivity 
allow exogenous events useful write programs monitor certain conditions take appropriate actions true 
example middle serving floor smoke detected elevator case normal operation suspended alarm sounded alarm reset 
mentioned earlier investigating concurrent version golog number complex actions sort executed concurrently different priorities 
believe form concurrency allows natural specification controllers need quickly react environment predetermined plans 

continuous processes 
widely believed virtue reliance discrete situations situation calculus represent continuous processes evolution time object falling influence gravity 
shown pinto view process fluent falling true time instantaneous action start falling occurs false time occurrence instantaneous action falling 
write axioms describe evolution time falling object 
reiter gives situation calculus account natural events behaviors described known laws physics 
means write golog simulators dynamical systems 
explored possibility golog programmer write robot controllers allow robot exploit naturally occurring exogenous events environment 

golog logic programming language implementing applications dynamic domains robotics process control intelligent software agents discrete event simulation basis formal theory actions specified extended version situation calculus 
golog number novel features programming language implementation tool dynamic modeling 

formally golog program macro expands evaluation program usually second order sentence situation calculus 
sentence mentions primitive user defined actions fluents 
theorem proving task evaluation program prove sentence relative background axiomatization consisting foundational axioms situation calculus action precondition axioms primitive actions successor state axioms fluents axioms describing initial situation 

golog programs normally evaluated obtain binding existentially quantified situation variable top level call program 
binding obtained successful proof symbolic trace program execution denotes sequence actions performed external world 
point entire golog computation performed line 
effect actual change world program trace passed execution module knows physically perform sequence primitive actions trace 

golog program macro expands situation calculus sentence prove properties program termination correctness directly situation calculus 

conventional programming languages primitive instruction set fixed advance assignments variables pointer changing primitive function predicate set predefined values types program variables golog primitive actions fluents user defined action precondition successor state axioms 
simulation dynamic systems facility allows programmer specify primitives accordance naturally occurring events world modeling 
turn allows programs written high level abstraction concern system primitive architecture implemented 

golog programmer define complex action schemas advice robot achieve certain effects specifying detail perform actions 
theorem prover responsibility detailed executable sequences primitive actions achieve desired effects 
block ontable block remove endwhile action schema specify particular sequence blocks removed 
similarly elevator program specify order floors served 
view describing complex behaviors golog programmer specifies skeleton plan evaluator uses deduction context specific initial world situation fill details 
golog allows programmer strike compromise computationally infeasible classical planning task plan deduced entirely scratch detailed programming little step specified 
limitations version golog 
implementation works completely known initial situations 
adapting golog non prolog theories initial situation require effort see ideas 
handling sensing actions requires system knowledge state modeled explicitly complicates representation updating world model 
exogenous events affect picture system may longer know actual history domains necessary deal sensor noise control error see initial results 
developing extended version language called congolog supports concurrent processes interrupts differing priorities processes interleaving semantics concurrent processes 
techniques representing reasoning continuous processes filling investigation 
progress multi agent distributed version congolog agent oriented programming applications support distinct world models agent library high level communication actions 
notions ability goals commitments rational choice important domains extending model deal 

fahiem bacchus joseph halpern levesque hector 
reasoning noisy sensors situation calculus 
chris mellish editor proceedings fourteenth international joint conference artificial intelligence pages montr eal august 
morgan kaufmann publishing 

anthony bonner michael kifer 
overview transaction logic 
theoretical computer science october 

michael dixon 
embedded computation semantics programs 
phd thesis department computer science stanford university stanford ca 
appeared xerox parc technical report ssl 

richard fikes nils nilsson 
strips new approach application theorem proving problem solving 
artificial intelligence 

robert goldblatt 
logics time computation 
csli lecture notes 
center study language information stanford university stanford ca nd 
edition 

green 
theorem proving resolution basis question answering systems 
meltzer michie editors machine intelligence volume pages 
american elsevier new york 

andrew haas 
case domain specific frame axioms 
brown editor frame problem artificial intelligence proceedings workshop pages lawrence ka april 
morgan kaufmann publishing 

todd kelley modeling complex systems situation calculus case study dagstuhl steam boiler problem 
aiello doyle shapiro editors principles knowledge representation reasoning proceedings fifth international conference kr appear 
morgan kaufmann publishers san francisco ca 

yves lesp erance hector levesque lin daniel marcu raymond reiter richard scherl 
logical approach high level robot programming progress report 
benjamin kuipers editor control physical world intelligent agents papers aaai fall symposium pages new orleans la november 

yves lesp erance hector levesque lin daniel marcu raymond reiter richard scherl 
foundations logical approach agent programming 
working notes ijcai workshop agent theories architectures languages august 

yves lesp erance hector levesque fangzhen lin richard scherl 
ability knowing situation calculus 
preparation 

hector levesque 
concurrency situation calculus 
preparation 

hector levesque 
planning presence sensing 
proceedings thirteenth national conference artificial intelligence pages portland oregon aug 
aaai press mit press 

hector levesque fangzhen lin raymond reiter 
defining complex actions situation calculus 
technical report department computer science university toronto 
preparation 

fangzhen lin 
embracing causality specifying indirect effects actions 
chris mellish editor proceedings fourteenth international joint conference artificial intelligence pages montr eal august 
morgan kaufmann publishing 

fangzhen lin raymond reiter 
progress database logical foundations 
jon doyle erik sandewall pietro torasso editors principles knowledge representation reasoning proceedings fourth international conference pages bonn germany 
morgan kaufmann publishing 

fangzhen lin raymond reiter 
state constraints revisited 
journal logic computation 

fangzhen lin raymond reiter 
progress database ii strips connection 
proceedings fourteenth international joint conference artificial intelligence pages montreal aug 

zohar manna richard waldinger 
clear block theory plans 
journal automated reasoning 

john mccarthy patrick hayes 
philosophical problems standpoint artificial intelligence 
meltzer michie editors machine intelligence pages 
edinburgh university press edinburgh scotland 

edwin pednault 
adl exploring middle ground strips situation calculus 
brachman levesque reiter editors proceedings international conference principles knowledge representation reasoning pages toronto may 
morgan kaufmann publishing 

javier andr es pinto 
temporal reasoning situation calculus 
phd thesis department computer science university toronto toronto february 
available technical report krr tr 

raymond reiter 
frame problem situation calculus simple solution completeness result goal regression 
vladimir lifschitz editor artificial intelligence mathematical theory computation papers honor john mccarthy pages 
academic press san diego ca 

raymond reiter 
proving properties states situation calculus 
artificial intelligence pages december 

raymond reiter 
natural actions concurrency continuous time situation calculus 
aiello doyle shapiro editors principles knowledge representation reasoning proceedings fifth international conference kr appear 
morgan kaufmann publishers san francisco ca 

stanley rosenschein leslie kaelbling 
synthesis digital machines provable epistemic properties 
joseph halpern editor proceedings conference theoretical aspects reasoning knowledge pages 
morgan kaufmann publishers monterey ca 


golog agent programming language experiments developing banking applications 
master thesis department computer science university toronto toronto 
preparation 

richard scherl hector levesque 
frame problem actions 
proceedings eleventh national conference artificial intelligence pages washington dc july 
aaai press mit press 

len schubert 
monotonic solution frame problem situation calculus efficient method worlds fully specified actions 
loui carlson editors knowledge representation defeasible reasoning pages 
kluwer academic press boston ma 

steven shapiro yves lesp erance hector levesque 
goals rational action situation calculus preliminary report 
working notes aaai fall symposium rational agency concepts theories models applications cambridge ma november 

yoav shoham 
agent oriented programming 
artificial intelligence 

joseph stoy 
denotational semantics 
mit press 


interval situation calculus 
proc 
ecai workshop logic change pages amsterdam august 

richard waldinger 
achieving goals simultaneously 
michie editors machine intelligence pages 
ellis horwood edinburgh scotland 

wooldridge jennings 
intelligent agents theory practice 
knowledge engineering review 
appear 
