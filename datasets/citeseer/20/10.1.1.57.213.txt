shortest path minimum delay algorithms networks time dependent edge length ariel orda raphael rom department electrical engineering technion israel institute technology haifa israel august consider shortest path problem networks delay weight edges changes time arbitrary functions 
algorithms finding shortest path minimum delay various waiting constraints investigate properties derived path 
show departure time source node unrestricted shortest path simple achieves delay short unrestricted path 
case restricted transit shown exist cases minimum delay finite path achieves infinite 
research supported foundation research electronics computers communications administered israel academy science humanities shortest paths algorithms subject extensive research years resulting large number algorithms various conditions constraints 
vast majority deal fixed graphs fixed topology fixed link weights 
advancement computer networks distributed processing brought renewed interest subject new twist time dependency 
works published dealing topological changes links may occasionally unavailable infinite weight deal quasi static models link weights change time time remain constant infrequent changes 
time dependent shortest path problems studied case discrete delay functions domain range positive integers 
problems addressed directly indirectly context maximal flow 
address shortest path problem restrictions allow arbitrary functions link delays 
respect broadest generalization 
problem briefly treated dreyfus ling address limited cases 
direct treatment date done halpern arbitrary waiting times considered 
algorithm proposed various waiting constraints algorithm bounded network topology number operations bounded function number nodes edges properties resulting path investigated simple path 
works avoid treatment functions addressing problem single instance time time ranges 
algorithms finding shortest path minimum delay instances time various waiting constraints investigate properties derived path 
show messages arbitrarily delayed source node shortest path simple achieves delay short unrestricted path having wait enroute 
interpretation time dependency links message traversal 
example interpretation delay incurred message traversing links 
note time dependency may continuous function 
consider dial link nodes established periodically 
message arriving link established suffer relatively short delay message arriving immediately link suffer greater delay 
restrict fifo links potential cases fifo assumption invalid 
example consider link composed physical communication channels faster 
policy link management send message available channel message sent slower may arrive message sent faster channel meaning messages arrive non fifo order 
interest problem stems related problems computer communication networks messages 
results reported hold general graph 
particular transportation networks may serve examples 
example traveler standing platform railway station wondering take local train stopping front wait express train destination 
time dependency delays possible non fifo behavior 
structured follows 
presenting formal model section ii shortest path algorithms various types node behavior classes delay functions 
section iv concludes results points research problems extend 
ii 
model consider bi directed network 
set nodes set links implying ik set timedependent link delays ik strictly positive function time defined describes delay message link time 
results valid smaller class functions continuous piecewise continuous shall indicate restrictions need arises 
interpretations link delay functions possible resulting somewhat different models 
model referred frozen link model delay message fixed time message starts traversing 
referred elastic link model ik instantaneous link length time model messages start traversing link time arrive instance time ik 
matter fact elastic link model submodel frozen link 
consider transformation function ik ik ik min ik ik interpreted delay function elastic link ik interpreted delay function frozen link model result exactly network behavior 
note elastic link fifo behavior frozen link model non fifo behavior possible 
rest focus attention general frozen link model 
possible non fifo characteristics ik may preferable wait certain amount time sending node embarking link traversal 
waiting consumes buffer space may permitted nodes 
consider different network traversal policies unrestricted waiting uw unlimited waiting allowed message path network 
forbidden waiting fw waiting disallowed message path network 
source waiting sw waiting disallowed message path network source node permits unlimited waiting 
note waiting time means flow control 
uw model implies hop hop flow control sw flow control mechanism fw rules flow control 
define terminology analyzing models 
consider message arrives node time waits period departs link time message arrives node time ik 
define ik ik combined waiting time link delay traversing link 
minimize traversal time interested finding link time optimal waiting time waiting time waiting time ik ik 
note cases value may exist 
consider example link ik inf ik value achieved 
point overlooked previous works 
shall implicitly assume delay functions time instant proper optimal waiting time exist 
property clearly holds continuous functions piecewise continuous functions sufficient condition property hold ik min ik ik 
denote set node neighbors topological path network sequence nodes 
link exists pair definitions topological path topology dependent time dependent 
simple topological path node appears 
waiting schedule waiting times tt 
signifying duration waiting node traversal path ordered pair pp tt topological path pp waiting schedule tt tt having component pp 
traversal path pp tt called simple pp simple topological path 
ambiguity exists shall term path refer topological traversal paths 
earliest time message start traversing network usually message creation time 
referred starting time 
suppose message travels source node destination node traversal path pp tt pp 
tt 

define im starting time arrival time node departure time node traversing network pp tt 
path delay pd pp tt path pp tt starting time pd pp tt shortest path problem graph formulated 
nodes time find traversal path pp tt pp 
tt 
traversal path pp tt pp 
pd pp tt pd pp tt traversal path minimum delay path shall refer shortest path 
topological path component minimum delay traversal path referred shortest topological path 
shortest path defined denoted sp may shortest traversal paths denote set 
shortest topological path may property subpaths shortest topological path source intermediate nodes starting time 
topological path said concatenated 
formally shortest topological path pp 
nodes starting time said concatenated im schedule tt 
tt shortest traversal path starting time note schedule subpaths may different 
consider shortest traversal path corresponding topological path concatenated 
optimal schedule subpath corresponding sub schedule entire traversal schedule say shortest traversal path concatenated 
formally shortest traversal path pp tt pp 
tt 
starting time said concatenated im traversal path 

shortest traversal path shortest paths delay may differ number hops edges 
considering subset paths simple concatenated assuming subset nonempty define hop index minimal number hops simple concatenated shortest paths 
iii 
shortest path algorithms unrestricted waiting model 
shortest path algorithm starting time source node starting time look shortest paths minimum delays nodes starting time 
noted dreyfus straightforward extension algorithms dijkstra ford 
algorithm familiar notions differences standard version helpful 
start making observations regarding optimal waiting times 
define ik min ik consider 
observe message departing node time link delay ik meaning message arrives node ik 
message departure arrival times immediate departures arrival times departure times optimal departure time depicts arrival times node departing times node noteworthy fact delayed departure results earlier arrival 
reader easily convince minimize delay message arriving depart see 
point characterized rightmost intersection point ik ik cord closest origin 
ik differentiable derivative equals 
note messages arriving depart achieve minimum delay 
ik defined function shows function ik resulting ik 
proceed algorithm version labeling algorithm node labeled earliest possible arrival time node starting time source node 
terminology labeling algorithms permanent label node null indicating node permanently labeled temporary label 
algorithm builds shortest topological paths spanning tree constructed values computed algorithm 
identity node father tree 
functions ik defined part algorithm input 
algorithm uw 
initialization nil null nil 
neighbors null optimal delay function including optimal waiting delay function min jk changed step set 
nodes nonnull value 
node null null 
set jl proceed step 
main difference conventional shortest path algorithms calculation jk step simple operation see section operations performed algorithms simple 
theorem algorithm uw terminates operations 
execution relation forms spanning tree rooted path node shortest topological path starting time delay proof proof follows closely dijkstra algorithm see example 
corollary uw model source destination pair starting time exists simple concatenated shortest path 
note optimal waiting times implicitly functions ik ik message arriving node time having depart link waits node period ik ik 
algorithm enables construction shortest traversal paths 

shortest path algorithm starting times algorithm generalization uw 
main difficulty stems fact values functions time 
addition constructing spanning tree complicated tree changes time manner harder capture 
overcome problem define single value set functions kl defined node neighbors earliest arrival time node starting time known certain step execution 
kl similarly earliest arrival time node neighboring node message started time double index determine spanning tree 
tree defined choosing father node time kl single node exists choose arbitrarily smallest index done selection unique 
algorithm uw 
kl 

set kl kl 

set min kl 

just changed proceed step 
proceed theorem explanations order 
assignments functions 
example step function kl set sum functions kl 
order analyze compare algorithms functions introduce terminology operations performed functions 
refer dimensional functions domain range 
simple operation functions function assignment 
linear combination functions 
minimum functions min 
compounding functions 
computing maximal right neighborhood function constant max say algorithm operating functions functional complexity order denoted constant input length functions operated number simple function operations performed algorithm bounded ka 
clearly execution function operation may quite involved 
definition useful reasons assuming operations performed finite time algorithm finite functional complexity finite algorithms operate functions compared algorithms operate functions compared uw uw 
definition functional complexity leads theorem 
theorem algorithm uw terminates function operations 
just changed means exists instance function changed value executed step 
operations algorithm uw introduced 
ii 
termination minimum delay node node starting time iii 
time node father lowest index kl relation denoted termination relation defines spanning tree rooted topological path node tree simple concatenated shortest topological path starting time proof see appendix note functional complexity uw complexity uw 
difference starting times considered longer identify iteration single node serves center operation iteration disregarded subsequent iterations done uw labeling node permanently 
iteration uw edges considered attempt improve earliest arrival times 
words dijkstra type algorithm resort ford type see 
forbidden waiting model possible fw model shortest paths simple concatenated 
simple node example shown sp shortest path contains loop fw model waiting schedule zeroes traversal path fully described topological path distinction concepts dealing model 
shortest path node node sp 
sp simple concatenated 
fact rules ford dijkstra type algorithms suggests polynomial algorithm exists number operations bounded polynomial 
shortest paths concatenated partial results calculation shortest path nodes consider possible paths 
authors suspect problem shortest path forbidden waiting fw model np hard currently working proof 
circumstances possible infinite shortest path containing infinite number hops minimum delay finite 
depicts case shortest path nodes 
starting node time node revisited sequence times meaning possible arrival times node 
arrive node time 
halpern algorithm attempts find finite shortest path timedependent network 
waiting node limited predetermined possibly empty set intervals delay functions nonnegative piecewise continuous 
fw model special case model 
example infinite shortest path conclude halpern algorithm perform task cases supposed 
close examination halpern proof reveals slightly tighter constraints imposed delay functions algorithm correct constraints discussed 
facts stated generally regarding model 
obvious characteristic optimal waiting time zero case ik ik behavior algorithm fw uw identical 
characteristic network fifo links differentiable delay functions means slope ik decreases 
general fact stated finite exists depending tt holds ik shortest path nodes finite 
example infinite shortest path finite minimum delay source waiting model observe immense gap uw fw models finding shortest paths uw model behaves just time independent case delays constant fw model efficient algorithms exist 
just alleviating slightly constraint waiting permitting source waiting efficient algorithms 
particular delay functions class described theorem proves equivalence shortest path standpoint uw sw models 
theorem kj continuous piecewise continuous negative discontinuities kj kj kj kj kj kj shortest topological path uw model shortest topological path sw model having delay 
words pp 

uw pp tt 

sw pd pp pd pp 
proof assume delay functions continuous 
pp uw uw 

uw respectively arrival departure times node pp uw traveling pp uw uw 
prove theorem show pp uw time source departure time leave travel pp uw sw model arrive time words adjust departure times arrive node desired preset time long earlier 
prove claim induction nodes pp uw claim trivially true 
assuming truth ith node prove st 
choose 
arrive node time depart node time question exists arrive node time 
consider function 
continuous intermediate value theorem infinitesimal calculus exists 
inductive assumption exists departure time cause arrival node time node time suppose delay functions countable number negative discontinuities 
point continuity assumed proof remains 
case piecewise continuous negative discontinuities verified intermediate value theorem holds case exists proof follows 
noted path traversed departure times intermediate node may different 
shall see algorithm sw follows separate calculation needed source destination pair 
theorem corollary get immediately corollary ik theorem source destination pair starting time exists shortest traversal path sw model simple corresponding topological path concatenated 

shortest path algorithm continuous functions starting time uw model algorithm find shortest path node nodes starting time addition computation departure times destination node assume delay functions theorem holds 
algorithm results theorem corollary 
destination determine minimum delay shortest topological path uw model 
theorem know topological path sw model arrival time destination 
start destination node known arrival time compute departure time predecessor shortest topological path 
process repeated nodes path 
backtracking complete source node reached computation process computed departure time source node trivially yields source waiting time 
algorithm sw 
compute shortest topological path algorithm uw node starting time execution spanning tree relation minimum delay known node 

set find ii 
theorem true algorithm sw stops operations 
ii 
termination relation forms spanning tree rooted path node shortest topological path time delay iii 
termination nonnegative waiting time departing node time moving waiting tree result arrival node minimum delay 
proof theorem relation defines spanning tree meaning step terminates fact executed times provided value appears step algorithm computed 
demonstrate fact 
continuous piecewise continuous functions negative discontinuities equation kj solution solutions intersection points kj line theorem guarantees solutions fulfills proving claim iii 
claims follow immediately 
step involves operations executed times resulting total operations step 
theorem claim ii holds 
claim follows directly theorems 
example computation consider network links delay functions ik 
starting time seek minimum delay source node node hops away traversing nodes way 
shows function respective arrival departure times uw model dashed lines 
having determined compute backwards visiting times sw model marked 
computed follows 
determine departure time arrival compute departure time arrival dot dashed lines 
determines departure time source sw model waiting time 

shortest path algorithm starting times assume section delay functions theorem holds 
observations show algorithm uw solving problem sw model 
proved uw terminates earliest arrival time node node starting time uw model 
waiting allowed uw model implies 
time instant destination node may associate latest starting time results arrival time destination 
formally node 
fact latest departure time node uw model enables arrival node earliest possible arrival time starting time computation waiting times fairly easy determine follows 
lemma establishes useful property values 
lemma source node destination node starting time defined pp shortest traversal path 

traversing waiting source enroute 
proof assume contrary shortest path pp 

im 
distinguish cases depending value assume 
earliest arrival time node starting time shortest path pd consider traversal path pp 
consider starting time straightforward notice arrival time node paths pd pd pd hand earliest arrival time pd conclude 
property definition implies contradicting 
assume smallest 

denote departure time node path starting time 
theorem guarantees leave node time traversing topological path pp arrive node time waiting enroute 
pp 

pd pd shortest path seen contradiction follows 
corollary source node destination node starting time optimal source waiting time sw model shortest topological path uw model shortest topological path sw model 
proof latest departure time starting time assures earliest arrival time node sw model 
theorem follows establishing part corollary 
second part follows directly lemma 
corollary approach clear 
run algorithm uw obtain function minimal delay node times uw sw models 
construct shortest traversal path starting time calculate source waiting time wait wait max want leave wait traverse topological path defined values wait kl wait 
discussion summarized formal specification algorithm corresponding theorem 
algorithm sw 
execute algorithm uw 

wait max 
theorem true algorithm sw sw model stops function operations 
ii 
termination minimum delay node node starting time wait optimal source waiting time 
iii 
time node topological path spanning tree defined way described theorem wait kl wait shortest topological path proof theorem claim true part algorithm 
second part algorithm involves function operations 
conclude algorithm terminates executing function operations proving claim 
claim ii follows theorems corollary 
claim iii follows corollary 
note functions stored kl 
wait need computed function calculation wait done need arises message generated time destination shortest topological path node sw model constructed spanning tree defined wait kl wait described theorem 
way avoid type simple function operations restrict definition functional complexity simpler types operations 

extension general piecewise continuous functions gain insight regarding problematic aspect positive discontinuities consider network uw model get sp units delay 
sw model sp units delay demonstrating shortest path minimum delay sw model different uw model 
example network computing shortest path functions slight change problematic delay function follows function continuous 
change sw model leave node go node arriving node uw model 
demonstrates corollary hold general functions demonstrates reason 
consider network link delay functions function see 
starting time uw arrival time computed 
going backwards notice exists time cause arrival graphically line intersect 
corollary hold general functions expand previous results cover wider class functions slightly relaxing waiting constraints 
clearly allow unrestricted waiting nodes incoming links functions uw model node considered source traversal subnetwork delay functions continuous 
piecewise continuous functions shall demonstrate achieve minimum delay equal uw model amount waiting intermediate nodes may bounded terms long waiting allowed 
computation waiting times discontinuous functions consider network delay functions piecewise continuous require ik ik ik ik 
sw policy relaxed allow limited waiting nodes incoming links delay functions addition unrestricted waiting source 
negative discontinuities treated theorem focus positive discontinuities 
ik positive discontinuity ik ik 
discontinuity assign relaxation instant time ik waiting restrictions relaxed manner 
messages arriving node node relaxation instant may wait node amount time exceeding ik ik predetermined arbitrarily small 
ik ik may choose 
refer policy relaxed sw policy 
illustrates simple example method 
ik positive discontinuity kind ik ik 
choose ik allow messages departing link time wait node amount time limited ik ik 
doing guarantee messages arriving node link time may depart time interval 
lemma relaxed sw model results theorem hold piecewise continuous delay functions 
proof see appendix example treating delay function discontinuity iv 
investigated shortest path problem networks link delays functions time 
shown problem solved efficiently constraints imposed waiting times nodes 
hand examples fw model indicate general waiting constraints render problem complex 
wide class delay functions shown efficient solution exists allow waiting just source node 
pointed delaying departure source node commonplace practical cases 
proved performance case minimum delay standpoint equivalent unrestricted case 
relaxation needed order cover piecewise continuous delay functions slight changes waiting constraints countable number points continuum 
practical cases delay functions continuous piecewise continuous conclude waiting restrictions intermediate nodes really impose limitations minimal delay increase complexity computing delays 
restricted delay functions optimal waiting time defined times 
avoid restriction considering paths optimal delay predetermined arbitrary small range infimum delay paths 
wide family delay functions including piecewise continuous ones algorithms applied optimal paths problem making modifications optimal waiting time consider optimal defined time ik ik function ik defined accordingly 
algorithms uw sw handle starting times 
useful scenario messages may created source node time optimal path 
efficient way run algorithm starting times prior time range considered message created time optimal path immediately values kl computed algorithm value computed sw model 
algorithms conceptual point demonstrate difference cases having single starting time consider starting times 
study offers insight nature time dependent environment functions serve building blocks extending algorithms distributed environment 
possible extensions results describe 
drive came field computer communication networks interesting consider distributed versions network control algorithms 
static quasi static environment distributed shortest path algorithms developed centralized versions 
see example segall 
distributed versions developed investigated algorithms 
considers minimum delay paths 
general case length link may characterized factors delay reliability traversal cost factors may time dependent interest investigate shortest path problem general time dependent link weights 
problem far complicated minimum delay extent restricted uw model guarantee existence simple concatenated finite optimal paths 
interested reader referred discussion analysis problem 
appendix proof theorem start notations 
denote execution step algorithm uw iteration 
var value var nth iteration 
neighbor node smallest index lk clearly neighbor exists 
path 
defined theorem proven lemmas 
lemma defined path simple topological path delay starting time choosing optimal waiting time node 
proof way calculated nodes clear path defined finite topological path denote meaning value strictly increasing path impossible move loop monotonically decreasing follows path simple way constructed topological path clear delay path section ii defined hop index minimal number hops edges simple concatenated shortest paths definition prove lemma 
lemma 
path simple concatenated shortest topological path delay choosing optimal waiting time node proof induction assumption trivially correct assuming correct times nodes prove times nodes hop index corresponding time 

node neighbor hop index equals inductive assumption iteration path simple concatenated shortest topological path delay st iteration algorithm sets ki step subsequently sets step earliest arrival times 
operation appends node path yield path simple concatenated shortest topological path 
henceforth inductive assumption remain unchanged 
arbitrary assumption holds completing proof 
lemma shows iterations algorithm terminates 
step involves functional operations algorithm requires total functional operations 
rest claims theorem follow directly lemmas 
appendix proof lemma sp uw pp uw tt uw 

uw respectively arrival departure times node pp uw traveling sp uw loss generality assume tt uw earliest possible arrival time departing rule applies recursively 

show pp uw time departure time leave travel pp uw relaxed sw policy may depart node time prove claim induction nodes pp uw claim trivially true assuming truth ith node prove st 
choose 
set nonempty inf done inductive assumption may depart node time arrive time depart immediately 
inf follows 
positive jump assume 
follows earliest arrival time departure time contrary assumption tt uw choose relaxation point follows inductive assumption relaxed sw model may depart node time arrive node time may wait period depart time assume 
piecewise continuous value close 


denote 
choose relaxation point may depart node time arrive node time may wait period depart time acknowledgment authors reviewers extraordinary reviewing effort considerably improved presentation 

deo pang shortest path algorithms taxonomy annotation networks pp 


richer rosen new routing algorithm arpanet ieee trans 
communications com pp 
may 

updating distances dynamic graphs methods operations research pp 
may 

determination shortest path network time dependent edge lengths mathematische statistik pp 


cooke shortest route network time dependent transit times journal math 
analysis applications pp 


ford jr fulkerson flows networks princeton university press princeton new jersey 

ford jr fulkerson constructing maximal dynamic flows static flows operations research pp 


dreyfus appraisal shortest path algorithms operations research pp 


ling optimal path networks time varying traverse time expenses branches technological reports osaka university japan 

halpern shortest route time dependent length edges limited delay possibilities nodes zeitschrift fuer operations research pp 


gerla kleinrock flow control comparative survey ieee trans 
communications com pp 
april 

dijkstra note problems connection graphs numerical analysis pp 
october 

graph algorithms computer science press new york 

segall distributed network protocols ieee trans 
information theory pp 
january 

orda rom distributed shortest path protocols time dependent networks pp 
proceedings tel aviv israel november 

orda rom minimum weight paths time dependent networks networks pp 
may 
