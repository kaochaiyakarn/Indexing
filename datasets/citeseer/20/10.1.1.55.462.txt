generation lr parsers partial evaluation michael sperber universitat tubingen peter thiemann university nottingham partial evaluation turn general parser parser generator 
inherently functional approach implement general lr parsers specialize respect input grammars offline partial evaluation 
functional specification lr parsing yields concise implementation algorithms 
furthermore demonstrate elegance functional approach incorporating fly attribute evaluation attributed grammars schemes error recovery lend natural elegant implementation 
parsers require minor changes achieve specialization results 
generated parsers production quality match produced traditional parser generators speed compactness 
categories subject descriptors programming techniques applicative functional programming programming techniques automatic programming programming languages language classifications applicative languages programming languages processors parsing mathematical logic formal languages grammars rewriting systems parsing artificial intelligence automatic programming program transformation program synthesis general terms algorithms experimentation languages performance additional key words phrases lr parsing parser generation partial evaluation functional programming continuations 
lr parsing knuth predominant parsing technique compiler front ends formal language processors 
lr parsing popular realistic grammars immediately amenable technique 
lr parser generators readily available notably yacc johnson 
easy tool yacc techniques underlying lr parser generators harder comprehend implement ll techniques earlier version parts appeared proceedings acm sigplan symposium partial evaluation semantics program manipulation title essence lr parsing 
authors addresses michael sperber wilhelm institut fur informatik universitat tubingen sand tubingen germany sperber informatik uni tuebingen de 
peter thiemann department computer science university nottingham university park nottingham ng rd great britain cs nott ac uk 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission acm 
copy republish requires fee specific permission 
delta sperber thiemann traditionally implemented recursive descent 
traditional model underlying lr parsing complicates understanding implementing parsers 
traditional expositions implementations stack automaton johnson chapman soininen wilhelm maurer 
lr parser generated way essentially interpreter table representation automaton 
naive table representation lr automaton may quite large 
choosing appropriate sparse representation preserving efficient access table requires significant algorithmics coding tarjan yao 
consequently resulting lr parsers usually unreadable 
turn finding errors tending parsing conflicts difficult testing possible generated parsers 
known alternative start functional specification lr parsing derive implementation program calculation leermakers 
follow approach inherently functional formulations general lr parsing 
formulations recursive ascent technique roberts analogous recursive descent commonly ll parsers 
approaches requires handling explicit parse table parsing stack 
recursive ascent results lr parsers considerably simpler compact formulations stack automaton 
specifications parsing algorithms translate directly scheme ieee kelsey programs 
general parsers run independently take grammar input string operands 
easy write debug 
adding attribute evaluation synthesized attributes effective error recovery fits elegantly functional framework 
input grammar lookahead partial evaluator transform parsers automatically efficient specialized parsers 
particularly simple specialization technique offline partial evaluation suffices achieve results 
offline partial evaluation automatically generate stand parser generators self application partial evaluator jones turchin compiler generator cogen launchbury holst 
generated parsers simple structure consisting mutually recursive procedures encode parser states 
achieve results offline partial evaluation realistic programs require slight changes called binding time improvements 
parsers exception 
techniques fairly standard jones improvements disrupt structure original parsers 
easy augment parsers error recovery mechanism 
implemented method yacc johnson depends user annotations input grammar automatic backtrack free mechanism 
compared real world parser generators performance generated parsers competitive 
compiled high performance scheme implementation fast parsers generated bison donnelly stallman 
overview organized follows sections introduce generation lr parsers partial evaluation delta notational preliminaries basic concepts functional lr parsing sec 
offline partial evaluation sec 

section presents deterministic firstorder direct style implementation lr parsing algorithm scheme describes necessary binding time improvements 
section describes alternative formulation scheme implementation functional lr parsing continuations description needed binding time improvements 
section describes implementation attribute evaluation error recovery continuation implementation 
section gives results practical experiments sec 
discusses related 

notational preliminaries section reviews notation sequences context free grammars 
introduces bunch notation leermakers express non deterministic algorithms 
sequences set denotes set finite sequences elements denoting empty sequence 
length 
prefix jk min 
context free grammars start separated context free grammar just grammar tuple 
set nonterminals set terminals disjoint start symbol set grammar symbols 
set productions productions form ff nonterminal sequence ff grammar symbols 
production form 
exactly production left hand side 
form letters denote elements certain sets default ae ff fi fl ffi induces derives relation ff fi ff fi ffi fl stands variables ff fl implicitly existentially quantified 
reflexive transitive closure 
derivation ff ff sequence ff ff ff ff ff sentential form sequence appearing derivation start symbol 
leftmost symbol rewriting relation defined bff ffi ffi reflexive transitive closure delta sperber thiemann lr item just item triple consisting production position right hand side terminal string length lookahead 
item written ff delta fi ae dot indicates position ae lookahead 
lookahead omitted 
kernel item form ff delta fi ae jffj 
predict item form deltaff ae 
lr state just state non empty set lr items 
productions items states implicitly range productions items states arbitrary fixed context free grammar 
bunches bunches notational convenience expressing non deterministic algorithms readable way set notation leermakers 
bunch denotes non deterministic choice values 
atomic bunch denotes just value 
bunches ja ja bunch consisting values ak empty bunch said fail denoted fail 
words non deterministic choice operator unit fail 
bunch boolean expression 
reads false fails true cases 
functions distribute bunches 
subexpression fails surrounding expressions fail 
bunches expression guarded expression guard fails entire expression fails value behaves fail 
special guard binding construct denotes choice values returned fails fails 
scope variables may pattern precisely bunch 
functional lr parsing parser context free grammar function maps sequence terminals derivation start symbol 
lr parser implements function automaton operating lr states 
automaton state item ff delta fi means parser processed suffix derivable ff input looking derivable fi 
cases 
fi xffi terminal input 
case parser shift moving state contains ffx delta ffi 
fi parser seen input derivable ff parser directly shift parser return state introducing production 
state contain items deltaff fl delta affi 
state corresponds third case fi affi parser shift effectively reducing production ff making part derivation 
specification functional lr parser set mutually recursive functions corresponds lr state ff delta fi derivation fi representative value ff delta fi bunch 
derivation represented item originated rest input string parsed 
specification formalizes lr generation lr parsers partial evaluation delta parsing leermakers xn gamma ff delta fi fi delta ff delta fi xn initial state lr parser fs 
holds deltaa occurs bunch produced 
auxiliary definitions necessary cast specification algorithm 
function needed computing lookahead information ff phi jk ff psi state comes set predict items predict phi delta ff delta fi ae delta ff delta fi ae psi transitive closure relation exactly pairings ff delta bfi ae 
predict items state predictions derivations parser may enter state elements predict exactly leftmost symbol derivations starting items union predict called closure henceforth predict denotes closure state states generated repeated application goto 
state grammar symbol goto fa ffx delta fi ae ff delta xfi ae qg general parser involves auxiliary function state invocation xn means grammar symbol string derived just seen input removed 
specification xn ff delta fi fi xfl fl ff delta fi xn called functional equivalent shift action happens 
implementation calls goto recursively returns result kernel item form ff delta fi jffj shifts left hand side nonterminal predict item form deltaff implemented recursive call 
implementation gives implementation functions leermakers 
implementation correct respect specification derived specification straightforward calculation 
includes testing lookahead delta sperber thiemann delta ae predict jk ae ff delta ae jk ae ff delta ff delta xfl ffx delta fl goto ff delta xfl predict delta ffi goto fig 

functional lr parser direct style version implements non deterministic lr parsing algorithm 
applied lr grammar algorithm deterministic 
implementation function tries shift terminal symbol production delta shifts contains item ff delta reduction possible parser returns item part input string seen 
parser passes item upwards returning procedure call technique called recursive ascent contrast recursive descent implementation ll techniques 
calls function associated goto returns item rest string 
parser arrived state containing item ff delta returns jffj function invocations moving dot back symbol return ffx delta fl returned goto ff delta xfl 
second alternative considered dot arrived front right hand side process just described 
case shifts corresponding left hand side returning items function calls may prohibitively expensive 
practice necessary return item left hand side production integer counting number levels left return sufficient 
implementation specification exploits property 
functional lr parsers close relation known implementations deterministic case run time stack procedure calls corresponds parsing stack traditional expositions lr parsing 

offline partial evaluation offline partial evaluation specialization technique aggressive constant propagation 
consists stages binding time analysis static reducer 
binding time analysis annotates expressions subject program binding time executable partial evaluation time static deferred run time dynamic usually starting user supplied annotation inputs programs 
prominent example course general parser essentially accepts static grammar dynamic input arguments 
generation lr parsers partial evaluation delta parsers amenable offline partial evaluation monovariant binding time analysis 
analysis expression receive annotation appear binding time context 
forces analysis annotate expression dynamic may static certain situations specialization 
static reducer processes annotated program static inputs generate specialized program reducing static parts rebuilding dynamic parts 
default static reducer unfolds procedure applications 
recursive procedures result infinite specialization static reducer generates procedures specialized program 
expressions static reducer generates procedures called specialization points 
static reducer encounters specialization point unfold generates procedure call 
encountered specialization point static components free variables generated call refers previously generated procedure 
generate appropriate specialized procedure 
consel danvy tutorial notes consel danvy give overview partial evaluation 
textbook jones gomard sestoft jones gives depth study techniques applications field 
binding time improvements program transformation enables binding time analysis mark expressions static binding time improvement 
necessary ensure specialization results 
trick 
trick known binding time improvement jones 
applies dynamic value known belong finite set static values 
suppose occurs context trick amounts replacing loop foreach continue suitable partial evaluation system automatically propagate context static value inside loop danvy 
context propagation place need replace loop get effect trick foreach continue loop translates directly scheme procedure returns static version dynamic parameter element occurs static list set define member element set loop set set cond null 
set equal 
element car set car set loop cdr set delta sperber thiemann code returns case element occur set 
element known set slightly modified version member exploit knowledge save comparison 
define member element set loop set set cond null 
cdr set car set equal 
element car set car set loop cdr set polyvariant expansion 
monovariant binding time analyses mark expressions dynamic static contexts 
consider code fragment assuming main called static dynamic define main define principle specializer perform addition monovariant binding time analysis provides annotation argument annotate dynamic situations overly conservative choice unsatisfactory specialization define main possible get problem providing versions binding time pattern define main define define specialization program produces desired result define main generating extensions attractive feature partial evaluation ability construct generating extensions 
generating extension program inputs inp inp program gen accepts static input inp produces specialized program inp program accepts dynamic input inp generation lr parsers partial evaluation delta produces result inp inp provided inp terminate 
jp inp inp jp inp inp result inp inp result generating extension results applying program generator generator pgg customarily pgg results double self application partial evaluator described third futamura projection futamura turchin jones 
called compiler generators cogen partial evaluation compilers turn interpreters compilers 
call pgg constructed self application partial evaluator cogen 
specialization generating extensions called cogen approach attractive considerably faster specialization generic specializer bondorf 

implementing direct style functional lr parsing formal specification functional lr parsing gives rise naive working implementation general lr parser 
naive parser suitable effective partial evaluation performing binding time improvements 
optimizations serve resulting specialized parsers highly efficient 
specification implementation assuming lr input grammar lr parsing algorithm deterministic easily functional program 
implementation function delta procedure ds parse accepts grammar grammar number lookahead characters function compute closure computes closure state set lr items state input input 
input stream pairs representing input 
input pair contains terminal component attribute value seconds component 
attribute values relevant attribute evaluation discussed sec 
function delta returns parse result record containing left hand side production reduced position dot right hand side production remaining input 
function find lookahead item selects item current state matching lookahead current input 
procedure returns element list matching predicate 
accept extracts items form ff delta closure state 
grammar assumed lr find lookahead item returns returns item item matches lookahead 
parse results subsequently processed ds parse bar implementation delta 
computes state goto function applies ds parse obtain parse result 
position dot returned item extracted parse result dot guides actions 
dot zero parser move backwards 
case ds parse bar terminates dot shifted symbol left 
left hand side lhs remaining input input remain unchanged 
result values lhs dot input 
dot reached zero symbols right hand side delta sperber thiemann define ds parse grammar compute closure state input closure compute closure state grammar define reduce cond find lookahead item accept closure input 
lambda item rhs length length item rhs item lhs item lhs item zero 
rhs length ds parse bar grammar compute closure closure lhs input values lhs rhs length input error parse error cond stream empty 
input reduce member car stream car input terminals closure grammar 
lambda symbol ds parse bar grammar compute closure closure symbol stream cdr input reduce define ds parse bar grammar compute closure closure symbol input nonterminals nonterminals closure grammar call values lambda ds parse grammar compute closure goto closure symbol input lambda lhs dot input cond null 
nonterminals values lhs dot input 
dot values lhs dot input initial 
closure grammar equal 
grammar start grammar lhs stream empty 
input accept error parse error ds parse bar grammar compute closure closure member lhs nonterminals input fig 

scheme implementation direct style functional lr parser generation lr parsers partial evaluation delta reduced production popped 
ds parse bar current state 
shifts symbol lhs consumes remaining input input 
improving binding times apart applications trick specialization direct style parser works surprisingly 
shifting statically 
calls ds parse bar require application trick symbol argument symbol dynamic result function dynamic 
stands symbol arguments dynamic 
call ds parse bar set symbols may occur finite static 
naive approach take grammar symbols finite set 
possible restrict set 
calls ds parse correspond shifts terminal symbols 
idea define function maps lr state set terminals perform shift action fx ff delta xfi qg static finite set call ds parse bar context calls static values symbol parameter 
calls pass nonterminal symbol argument 
remaining call ds parse passes lhs unique item empty right hand side argument static 
recursive call ds parse bar apply trick analogy function maps state set left hand side nonterminals items form deltaff fa deltaff qg trick applicable exactly way 
construction goto function left hand side lhs item returned ds parse member 
possible member member case 
shows parser improvements 
implementation passes closure directly ds parse bar recomputing state speeds parser generation 
improved parser contains subtle change separate binding times ds parse restructure test reduction results calls function reduce 
separate dynamic test input static test nonterminal 
anding original version nonterminal dynamic 
checking lookahead 
place trick applies implementation find lookahead item 
loop naive implementation implicit unrolling amenable effective specialization 
possible perform lookahead comparisons slightly efficiently loop unrolling 
shows result 
section describes efficient lookahead checking strategies avoid repeated deconstruction input stream 
delta sperber thiemann define ds parse grammar compute closure state input closure compute closure state grammar define reduce cond find lookahead item accept closure input 
lambda item rhs length length item rhs item lhs item lhs item zero 
rhs length ds parse bar grammar compute closure closure lhs input values lhs rhs length input error parse error cond stream empty 
input reduce member car stream car input terminals closure grammar 
lambda symbol ds parse bar grammar compute closure closure symbol stream cdr input reduce define ds parse bar grammar compute closure closure symbol input nonterminals nonterminals closure grammar call values lambda ds parse grammar compute closure goto closure symbol input lambda lhs dot input cond null 
nonterminals values lhs dot input 
dot values lhs dot input initial 
closure grammar equal 
grammar start grammar lhs stream empty 
input accept error parse error ds parse bar grammar compute closure closure member lhs nonterminals input fig 

direct style lr parser binding time improvements generation lr parsers partial evaluation delta define lookahead matches 
lookahead input loop lookahead lookahead input input cond zero 
null 
lookahead stream empty 
input stream empty 
input equal 
car lookahead car stream car input loop cdr lookahead stream cdr input define find lookahead item item set input loop item set item set null 
item set item car item set lookahead matches 
item lookahead item input item loop cdr item set fig 

checking lookahead generating code 
binding time analysis processing parser respect static grammar static lookahead size classifies computations concerned computing lookahead sets items closures actions static 
direct dependencies input parse results remain dynamic 
specializer performs equivalent standard sets items construction fly specialization point mechanism state specialization generates version ds parse ds parse bar 
beneficial cater fact parser represents states item lists scheme lacks native set data type set typically representations list 
parser normalizes states sorting items avoid redundant procedures specialized parser 
furthermore performs optimization parse tables known compiler community chapman chap 

parse tables simplified merging reduce actions immediately preceding shift action shift reduce action conflicts arise 
transformation happens automatically unfolding due null 
nonterminals 
shows specialized code parsing procedures 
notable differences hand optimized code contains superfluous lets simplest compiler optimizers inline code accesses head input times 
duplication arises strictly behavior original find lookahead item procedure performs access lookahead check 
easy avoid duplication turns efficient lookahead procedure described sec 
takes care problem side effect 
delta sperber thiemann define ds parse bar clone mlet lambda ds parse clone mlet lambda lhs dot input cond 
dot values lhs dot input equal 
lhs stream empty 
input accept error parse error equal 
lhs ds parse bar input equal 
lhs ds parse bar input ds parse bar input call values mlet mlet define ds parse input stream empty 
input mlet stream car input mlet car mlet equal 
mlet values input mlet stream car input mlet car mlet equal 
mlet values input mlet stream car input mlet car mlet equal 
mlet values input error parse error mlet stream car input mlet car mlet cond equal 
mlet ds parse bar stream cdr input equal 
mlet ds parse bar stream cdr input mlet stream car input mlet car mlet equal 
mlet values input mlet stream car input mlet car mlet equal 
mlet values input mlet stream car input mlet car mlet equal 
mlet values input error parse error fig 

specialized functional parser generation lr parsers partial evaluation delta improving optimizations generated parsers efficient 
improving trick 
uses trick literature employ simple linear search implementation shown sec 

total order elements static set binary search possible 
terminals nonterminals simply numbers trick loop member changes variant shown fig 

variant member results adding special cond branch element lists 
define member element set loop sorted sort list set size length set cond null 
sorted size middle quotient size static element list ref sorted middle cond static element element static element 
element static element loop take middle sorted middle loop list tail sorted middle size middle element car sorted car sorted loop cdr sorted size fig 

trick binary search call sort list set sorts set ascending order take middle sorted returns initial segment length middle list sorted 
impure features 
major bottleneck direct style implementation results necessity return multiple values function left hand side production currently reduced remaining number procedure calls returned remaining input 
far return values differ second component 
live time execution 
safe replace components global variables 
new version uses global variables left hand side nonterminal lhs remaining input input pass position dot dot right hand side item result 
shows changes implementation modified lines indicated 
delta sperber thiemann define lhs define input define ds parse grammar compute closure state input ds parse bar grammar compute closure closure lhs input 
set 
lhs lhs 
set 
input input rhs length define ds parse bar grammar compute closure closure symbol input 
dot ds parse grammar compute closure 
goto closure symbol input 
lhs lhs 
input input fig 

direct style parser imperative features 
continuation lr parsing possible express lr parsing sec 
continuation form sperber 
continuation parser merely result straightforward cps transformation intrinsic expression lr parsing continuations 
continuation parser concise direct style parser amenable effective specialization 
addition allows natural elegant implementation attribute evaluation error recovery see sec 

suitable improvements scope example extended model attribute evaluation sperber cumbersome direct style version 
formulating continuation parsing functional parser sec 
reduces production ff return jffj invocations lr states step step 
continuations serve reach destination state containing deltaff 
continuation parser needs new definitions 
state associated number active symbols ff delta fi qg parser state maximal number states parser may return reduces production definitions continuation functional parser considerably simpler direct style formulation reduction occurs directly calls continuation belonging destination state shifting dot back multiple procedure invocations 
shows specification 
focus deterministic parsers 
transliteration specification shown 
state state represented list items generation lr parsers partial evaluation delta letrec goto goto ff delta ae jk ae jffj fig 

functional lr parser continuation version define cps parse grammar compute closure state continuations input closure compute closure state define symbol input cond initial 
state grammar equal 
grammar start grammar symbol cps parse grammar compute closure goto closure symbol cons take goto closure symbol continuations input stream empty 
input accept error cond stream empty 
input member car stream car input terminals closure grammar car stream car input stream cdr input find lookahead item accept closure input 
lambda item list ref cons continuations length item rhs item item lhs item input error fig 

continuation parser continuations list containing state specification 
take function extracts elements list specializing continuation parser just parser sec 
changes necessary naive implementation parser specialize 
programs transformed continuation passing style specialize better consel danvy 
continuations parser motivated binding time considerations intrinsic formulation delta sperber thiemann parsing algorithm 
binding time improvements 
trick applies situations direct style parser 
compact specification parser place shifting occurs continuation direct style version separate function calls responsible shifting terminals nonterminals respectively 
know symbol argument member state state 
applying trick naively specialize loop tests symbol terminals nonterminals 
parser calls different call sites 
site passes nonterminals second terminals 
splitting version nonterminals terminals applying trick way direct style parser yields desired results specialization 
removing list continuations 
standard scheme lists storing continuations introduces performance problem partial evaluators partial evaluators treat cons car cdr ordinary primitive operations data constructors selectors 
traditional monovariant binding time analyses henglein expect arguments primitive static data base type specializer reduce primitive 
parser passes procedure primitive cons binding time analysis detects type clash defers expected error runtime marking cons dynamic 
specialized parsers presently construct pass lists continuations 
grossly inefficient structure list static 
specification parser states simply pass continuations separate arguments 
achieve effect specialized parsers necessary convey structure list continuations binding time analysis specializer 
partial evaluators support partially static data structures just purpose allow construction aggregates contain static dynamic components 
case spine list known 
declaring partially static list datatype partial evaluator replacing cons car cdr counterparts achieves desired purpose 
bindingtime analysis keeps spine list static 
static reducer performs arity raising creates separate parameter list element 
splitting list continuations crucial performance specialized parsers 
change binding time analysis propagates information 
maintains functions list static prompts specializer generate separate versions state possible constellation continuations may parameters resulting code blowup 
force binding time analysis regard elements continuations list dynamic 
typically achieved special operator provided partial evaluator hand forces argument dynamic 
applying operator occurrences desired effect 
final implementation achieves effect different means 
parser state item form deltaff parser shift nonterminal state 
state parser puts dummy generation lr parsers partial evaluation delta value list continuations construct actual continuation 
situation element continuations list function actual continuation boolean binding time analysis detects apparent type clash list elements dynamic 
corresponding test code null 
nonterminals 
generating code 
results specializing continuation parser similarly satisfying specializing direct style version 
shows sample 
code generated version find lookahead item shows duplication calls stream car car remedied section 

efficient checking lookahead specialized parsers check lookahead efficiently possible 
specifically touch input characters possible perform operations possible determine state parser 
seen sections generated code contains redundant accesses head input 
problem gets worse 
displays implementation variant trick 
variant find lookahead item successively narrows set items matches current lookahead 
purpose find lookahead item pairs remaining lookaheads respective items uses filter lookaheads items weed items match single lookahead subsequently remove lookahead lookahead item pairs 
filter function code employs takes predicate list arguments 
returns list exactly elements match predicate 
new version effectively encodes tries performs redundant accesses input checks 

additional features parsers far lr recognizers 
modifications additions necessary useful applications slr lalr parsing attribute evaluation error recovery mechanism 
partial evaluation parser generation amenable additions 
slr lalr pure lr parsers realistic languages lead prohibitively big state chapman aho impractically big parsers 
fortunately realistic formal languages amenable treatment slr lalr parsers introduce lookahead essentially lr parsers 
slr parser corresponding lr parser states states closures qn contrast lr parser slr automaton states fa ff delta fi ae ff delta fi ae follow definition follow set terminal sequences length may follow sentential form 
follow fl delta sperber thiemann define data list cons car cdr nil define cps parse grammar compute closure state continuations input closure compute closure state grammar accept items accept closure nonterminals nonterminals closure grammar define shift symbol input state goto closure symbol cps parse grammar compute closure state cons null 
nonterminals shift nonterminal take state continuations input define shift nonterminal nonterminal input initial 
state grammar equal 
grammar start grammar nonterminal stream empty 
input accept error shift member nonterminal nonterminals input define reduce item list ref cons null 
nonterminals shift nonterminal continuations length item rhs item item lhs item input cond stream empty 
input cond find lookahead item accept items 
reduce error member car stream car input terminals closure grammar 
lambda symbol shift symbol stream cdr input find lookahead item accept items input 
reduce error fig 

continuation parser binding time improvements generation lr parsers partial evaluation delta define cps parse mlet mlet clone clone stream empty 
clone mlet clone mlet stream car clone mlet car mlet equal 
mlet mlet clone mlet stream car clone mlet car mlet equal 
mlet mlet clone mlet stream car clone mlet car mlet equal 
mlet mlet clone mlet stream car clone mlet car mlet equal 
mlet mlet clone mlet stream car clone mlet car mlet equal 
mlet mlet clone error define shift nonterminal nonterminal input cond equal 
nonterminal stream empty 
input accept error equal 
nonterminal mlet lambda nonterminal input shift nonterminal nonterminal input cps parse mlet input equal 
nonterminal mlet lambda nonterminal input shift nonterminal nonterminal input cps parse mlet input mlet lambda nonterminal input shift nonterminal nonterminal input cps parse mlet input fig 

specialized continuation parser delta sperber thiemann define find lookahead item item set input loop lookaheads items map lambda item cons item lookahead item item item set remaining input input cond null 
lookaheads items zero 
remaining cdar lookaheads items null 
cdr lookaheads items cdar lookaheads items remaining stream empty 
input empties filter lambda lookahead item null 
car lookahead item lookaheads items null 
empties cdar empties loop filter lookaheads items lookaheads items car stream car input remaining stream cdr input define filter lookaheads items lookaheads items terminal non empties filter lambda lookahead item null 
car lookahead item lookaheads items lookaheads map lambda lookahead item car car lookahead item non empties static terminal member terminal lookaheads matches filter lambda lookahead item equal 
static terminal lookahead item non empties map lambda lookahead item cons cdr car lookahead item cdr lookahead item matches fig 

efficient checking lookahead tries generation lr parsers partial evaluation delta analogously predict items lr case added lookahead predict fa ff delta fi ae ff delta fi predict ae follow state transition goto just variant lr case called goto goto goto immediately obvious modify lr parser slr parser main parsing function merely replace current state decorated lookahead described 
effects slr lr expected generation time size decrease dramatically realistic grammars see table section 
lalr method uses precise method computing lookahead works decorating lr parser 
methodology slr case applicable merely replacing follow involved lalr lookahead function 
unfortunately efficient methods computing lalr lookahead sets require access entire lr automaton advance park ives park choe ives ives 
parser access representation automaton introducing lalr method require computing operating relying partial evaluator implicitly generate 
feasibility approach impaired explicitly computing automaton somewhat breaks spirit elegance 
attribute grammars pure recognizers far little practice 
take advantage results parsing process parser associate semantics input string 
common way attribute grammar mechanism knuth knuth 
popular parser generators johnson restrict attributed grammars attributes evaluated fly parsing 
principal restriction language higher order functions general attribution schemes simulated functions martin 
attributed grammar context free grammar nonterminal associated synthesized attribute production augmented attribution 
attribution production xn function xn maps synthesized attributes synthesized attribute xn xn straightforward extension direct style parsers continuation parsers performs attribute evaluation attributed grammars fly parsing input 
attribute evaluation direct style parser requires explicit attribute stack 
continuation parser handles attributes way list continuations partially static list contains attributes delta sperber thiemann letrec goto goto goto ff delta ae jk ae jffj ff jffj fig 

continuation lr parser attribute evaluation currently active symbols 
continuation parser adheres specification 
attribute value domain assumed contain value parser assigns terminals 
implementation parser accepts sequences token attribute pairs terminals may carry attribute information 
implementation shown fig 
straightforward 
specification direct style parser fly attribute evaluation shown somewhat complicated 
accepts input string attribute stack returns triple consisting lr item remaining input value synthetic attribute left hand side nonterminal item 
attribute value generated reduction item ff delta initiated 
similarly extended deal attribute stack 
attribute stack grows right pushes stack denotes tuple rightmost elements stack 
order perform attribute evaluation attribution production transferred generated parser 
way achieve attribute evaluation interpret attributions interpret cons attribution definition attribution program take rhs length attribute stack unfortunately approach drawbacks 
interpreter written straightforward tedious especially full scheme supported 
second parser generation grossly inefficient partial evaluator specialize interpreter runs code attribution superfluous layer interpretation 
better choice consists eval transform text attribution actual code apply eval attribution interaction environment take rhs length attribute stack attribution static specializer remove eval code simply paste static value attribution considered code 
example attribution lambda specializer generate code var lambda car var car var car clone generation lr parsers partial evaluation delta define cps parse grammar compute closure state continuations attribute values input closure compute closure state grammar accept items accept closure nonterminals nonterminals closure grammar define shift symbol attribute value input state goto closure symbol keep state cps parse grammar compute closure state cons null 
nonterminals shift nonterminal take keep continuations cons attribute value take keep attribute values input define shift nonterminal nonterminal attribute value input initial 
state grammar equal 
grammar start grammar nonterminal stream empty 
input attribute value error parse error shift member nonterminal nonterminals attribute value input define reduce item rhs length length item rhs item attribution production attribution item production item attribute value apply attribution attribution list list reverse take rhs length attribute values list ref cons null 
nonterminals shift nonterminal continuations rhs length item lhs item attribute value input cond stream empty 
input cond find lookahead item accept items 
reduce error parse error member car stream car input terminals closure grammar 
lambda symbol shift symbol cdr stream car input stream cdr input find lookahead item accept items input 
reduce error parse error fig 

implementation continuation parser attribute evaluation delta sperber thiemann delta ae predict jk ae 
ff delta ae jk ae ff delta ff jffj ff delta xfl ffx delta fl goto ff delta xfl predict delta ffi goto fig 

direct style lr parser attribute evaluation authors developed partial evaluator able handle eval apply correctly thiemann results clear concise efficient solution problem 
error recovery realistic applications parsers require sensible handling parsing errors 
specifically parser encountering parsing error issue error message resume parsing way repairing error possible 
literature abounds theoretical treatments recovery techniques applicable lr parsing chapman soininen wide variety methods 
methods phrase level recovery techniques transforming incorrect input correct deleting terminals input inserting generated ones 
phrase level recovery techniques production lr parser generators 
demonstrate amenability approach effective error recovery implemented realistic algorithms user assisted method yacc johnson error productions fully automatic technique implemented lalr parser generator 
effective error recovery requires fairly fine grained control operation parser continuation parser considerably amenable implementation techniques treatment error recovery entirely context continuation parsers 
yacc style error recovery 
yacc provides special error terminal means user specify recovery annotations 
typical example grammar arithmetic expressions terminals number typewriter error number error parser encounters parsing error pops symbols parse stack reaches state shift error terminal 
parser shifts skips input terminals input symbol acceptable generation lr parsers partial evaluation delta parser 
example parser encountering error parenthesized expression skip closing parenthesis 
keep error messages parser needs keep track number terminals shifted error error happened chances new error effected error recovery 
case parser skip input terminal guarantee termination refrain issuing error message 
method fairly crude proven effective situations 
advantage fully automatic methods provides user ability tailor specific error messages context error specify sensible attribute evaluation rules 
continuation parser yacc method fairly straightforward implement 
addition usual continuations perform reductions supply error continuation handle error brings parser back immediately state shift error terminal 
addition parameter error status keeps track number terminals parser needs shift resume issuing error messages case number 
calls cps parse pass handle error error status parameters cps parse handles error 
closure grammar handle error handle error handle error needs dynamic prevent non terminating specialization 
parser shifts terminal adjusts error status zero 
error status error status error status shows relevant handle error function 
yacc style error recovery fits parser model naturally calling error continuation directly certainly efficient scanning stack explicitly yacc needs 
additionally option keep error status count static 
results increase code size small gain parser speed 
fully automatic backtrack free error recovery 
contrast simple model yacc sophisticated method allows fully automatic error recovery 
price added complexity lower performance 
sketch method details algorithm involved 
algorithm constructs continuation automaton parsing automaton turn constructs valid continuation input valid prefix prefix correct input 
continuation automaton merely special interpretation variant lr state automaton 
variant states longer sets items sorted sequences 
automaton capable error recovery larger canonical lr automaton 
delta sperber thiemann define handle error error status input state goto closure grammar error grammar keep state closure compute closure state grammar accept items accept closure input cond zero 
error status input stream empty 
input error parse error premature input stream cdr input define recover attribute value input cps parse grammar compute closure state cons null 
nonterminals shift nonterminal take keep continuations cons attribute value take keep attribute values handle error input loop input input define reduce recover item rhs length length item rhs item attribution production attribution item production item attribute value apply attribution attribution list list reverse cons take rhs length attribute values recover attribute value input cond stream empty 
input cond find lookahead item accept items 
reduce recover error parse error premature input member car stream car input terminals closure grammar 
lambda symbol recover cdr stream car input input find lookahead item accept items input 
reduce recover loop stream cdr input fig 

yacc style error recovery generation lr parsers partial evaluation delta encountering error algorithm performs steps simulates running parser constructed continuation current correct prefix parsing terminates 
terminals continuation form set anchors valid restarting points parsing 
parser deletes terminals input terminal anchors 
parser synthesizes continuation generated step anchor resume parsing 
parser interprets representation lr state table simulation automaton straightforward 
simulate running parser merely needs copy parsing stack restored actual parsing resumes 
continuation parser essentially choices construct separate functions running parser simulating functions task keep track difference local state 
alternative disadvantage partial evaluation create variants parser regular parsing collecting anchors continuing input 
chosen regular parsing functions keep global state 
repairing flag true error recovery progress 
state component anchors contains current list anchors collected 
shows code parser executes encountering parsing error 
brevity sake perform attribute evaluation 
parser repair mode checks state continue parsing current lookahead 
state associated continuation terminal parser 
case generate attribute value generated terminal supplied part source grammar 

experimental results direct style continuation implementation models generated lr parsers compare favorably generated traditionally built parser generators bison donnelly stallman produced partial evaluation stack implementation mossin mossin 
table size specialized parsers cons cells size mossin lr cps lr slr implementation models different merits direct style approach leads compact parsers continuation parsers faster delta sperber thiemann report error display syntax error expected write uniq append terminals closure grammar flatten items lookaheads accept items newline set 
repairing set 
anchors construct set anchors cps parse grammar compute closure state continuations input skip anchor input loop input input stream empty 
input member car stream car input anchors input display deleting write car stream car input newline loop stream cdr input set 
anchors set 
repairing repair cps parse grammar compute closure state continuations attribute values input fig 

style error handling cases 
applied mossin parser generator continuation direct style approaches different example grammars 
confine results parsing proper generated parsers perform attribute evaluation error recovery 
table shows sizes input grammars sizes generated parsers 
sizes number cells scheme representations 
column mossin gives numbers parsers generated mossin general parser lr direct style parsers cps lr parsers 
column slr give sizes specialized direct style slr parsers 
example grammars mossin defines balanced parentheses arithmetic expressions language jones 
table ii shows run times generated parsers different grammars generation lr parsers partial evaluation delta table ii 
run times specialized parsers timings ms size input mossin lr cps lr lr imp bison inputs varying sizes 
measurements taken ibm rs model mb real memory running aix 
bigloo scheme compiler generates code maximum optimization 
code compiled native compiler 
column lr imp shows results imperative version direct style parser lines fig 

column shows timings equivalent lalr parsers generated bison compiled maximum optimization 
input bison parser fed directly constant array containing token codes 
timings measure purely parsing time 
timings indicate speed functional parsers factor direct style parsing surpasses continuation approach generated stack approach mossin mossin 
imperative direct style version surpasses timings gets close bison generated parsers speed 
results prove practicability approach 
continuation parser generator develop front ansi compiler kernighan ritchie 
possible test grammar general parser observation users typically apply parser generator development cycle 
development general parser allows instant turnaround 

related pioneering functional lr parsing due 
gives low level implementation direct style functional parser 
reports speedup implementations utilize table representation parsing automaton 
overview functional parsing leermakers book leermakers 
summary description continuation approach author sperber 
uses continuation parsing algorithm implement sophisticated attribute evaluation 
resulting algorithms parser generator rk system preprocessor generation 
mentioned mossin mossin uses similix bondorf obtain specialized lr parsers general parsers 
starts delta sperber thiemann stack order approach specialize 
transforms stack data structure continuation pops elements stack 
transformation complicates program considerably requires intricate binding time improvements optimizations achieve specialization 
ershov ostrovsky ershov ostrovsky describe previous attempts specialize general parsers 
describes examples partial computation construction ll lr parser generators 
approach ad hoc generation parser generators automatic done hand 
notion partial evaluation application automatic program generation stems futamura futamura 
compiler generation self application main fields interest researchers partial evaluation 
led discovery offline partial evaluation construction practical compiler generators jones 
partial evaluator self application create stand program generators possible hand written program generator generator launchbury holst boosts efficiency solves coding problems compared self application 
program generator generator thiemann generate parser generators 
trick old offline partial evaluation gomard jones bondorf jones necessary effective 
existing offline partial evaluator automates trick 
formalization incorporates trick binding time analysis lambda calculus defines context propagating rules static reductions danvy 

partial evaluation generate fast compact lr parsers general functional parser grammar 
alternative approaches implement general parser represents parsing stack procedure call stack continuations 
sacrifice generality necessary programs amenable specialization 
need cater specific optimizations parser generators 
functional approach needs straightforward known improvements generate efficient specialized parsers 
generated parsers faster compact generated straightforward parser generator compare favorably parsers 
consequently partial evaluation realistic approach implementing production quality parser generators 
acknowledgments christian mossin graciously supplying source code programs sample inputs 
due pepm referees provided detailed constructive comments 
frank patient beta tester development front 
generation lr parsers partial evaluation delta aho sethi ullman 
compilers principles techniques tools 
addison wesley 
bondorf 
automatic higher order recursive equations 
science computer programming 
bondorf 
similix manual 
diku university copenhagen 
chapman 
lr parsing theory practice 
cambridge university press cambridge 
martin 
order algebraic definition semantics 
theor 
comp 
sci 

consel danvy 
better support static data flow 
see hughes pp 

consel danvy 
tutorial notes partial evaluation 
proc 
th annual acm symposium principles programming languages charleston south carolina pp 

acm press 
danvy palsberg 
eta expansion trick 
acm transactions programming languages systems nov 

optimization parser tables portable compilers 
acm transactions programming languages systems oct 

efficient computation lalr look ahead sets 
acm transactions programming languages systems oct 

practical translators lr parsers 
ph thesis department electrical engineering massachusetts institute technology cambridge ma 

simple lr grammars 
communications acm 
donnelly stallman 
bison yacc compatible parser generator 
boston ma free software foundation 
part bison distribution 

parsers partial evaluation experiment 
student report july diku university copenhagen denmark 
ershov ostrovsky 
controlled mixed computation application systematic development language oriented parsers 
meertens ed program specification transformation proc 
ifip tc wg working conference program specification transformation pp 

north holland 
futamura 
partial evaluation computation process approach 
systems computers controls 
gomard jones 
partial evaluator untyped lambda calculus 
journal functional programming jan 

lalr generator efficient parsers 
software practice experience nov 
henglein 
efficient type inference higher order binding time analysis 
see hughes pp 

hughes 
ed 

functional programming languages computer architecture volume lecture notes computer science cambridge ma 
springer verlag 
ieee 
standard scheme programming language 
tech 
rep institute electrical electronic engineers new york 
ives 
unifying view lalr lookahead set algorithms 
sigplan notices july 
proceedings sigplan symposium compiler construction 
ives 
lalr lookahead set algorithm 
unpublished manuscript 
ives 
response remarks algorithms lalr lookahead sets 
sigplan notices august 
johnson 
yacc compiler compiler 
tech 
rep bell laboratories murray hill nj 
delta sperber thiemann jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall 
jones sestoft 
experiment partial evaluation generation compiler generator 

jouannaud ed rewriting techniques applications france pp 

springer verlag 
lncs 
kelsey clinger rees 
revised report algorithmic language scheme 
tech 
rep kernighan ritchie 
programming language 
prentice hall 
nd edition 
knuth 
translation languages left right 
information control 
knuth 
fundamental algorithms nd ed volume art computer programming 
addison wesley reading ma 
knuth 
semantics context free languages 
mathematical systems theory 
correction knuth 
launchbury holst 
handwriting cogen avoid problems static typing 
draft proceedings fourth annual glasgow workshop functional programming scotland pp 

glasgow university 
leermakers 
functional treatment parsing 
kluwer academic publishers boston 
mossin 
partial evaluation general parsers 
schmidt ed proc 
acm sigplan symposium partial evaluation semantics program manipulation pepm copenhagen denmark pp 

acm press 

partial computation construction language processors 
prentice hall 
park choe 

remarks algorithms lalr lookahead sets 
sigplan notices april 
park choe chang 
new analysis lalr formalisms 
acm transactions programming languages systems jan 

fast lr parsing 
sigplan notices 

methods automatic construction error correcting parsers 
acta inf 

roberts 
recursive ascent lr analog recursive descent 
sigplan notices 
soininen 
parsing theory volume ii lr ll parsing eatcs monographs theoretical computer science 
springer verlag berlin 
sperber 
attribute directed functional lr parsing 
unpublished manuscript 
tarjan yao 
storing sparse table 
communications acm 
thiemann 
cogen lines 
dybvig ed proc 
international conference functional programming philadelphia pa pp 

acm press new york 
thiemann 
partial evaluation full scheme 
kiczales ed reflection san francisco ca usa pp 

turchin 
supercompiler system language 
sigplan notices feb 
wilhelm maurer 
compiler design 
addison wesley 
