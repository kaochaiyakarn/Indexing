efficient reasoning russell greiner department computing science general service bldg university alberta edmonton alberta canada christian darken adaptive information signal processing siemens corporate research college road east princeton nj usa november tasks require reasoning deriving corpus explicitly stored information solve range problems 
ideal reasoning system produce correct answers possible query produce answers specific possible expressive permit possible fact stored possible query asked efficient 
unfortunately provably impossible correct precise systems expressive increasingly inefficient undecidable 
tutorial formalizes hardness results context logic probability reasoning overviews existing techniques address side step dilemma 
include alternative proposals 
information systems corpus explicitly stored information knowledge base kb solve range problems 
example medical diagnostic systems general facts diseases specific details particular patient determine diseases possible treatment appropriate 
similarly configuration synthesis systems stored descriptions various components specifications proposed device vlsi chip software program factory produce design device satisfies requirements 
scheduling planning systems likewise synthesize schedules sufficient achieve specified objective 
case underlying system reason derive diagnoses designs schedules sanctioned knowledge 
typically expert compile time provides corpus general background facts medicine types components run time user specifies details specific situation symptoms specific patient specifications particular desired artifact poses specific questions disease 
connected 
reasoning system produces appropriate answers current knowledge base kb includes specifics problem general background knowledge 
potentially infinite set possible situations typically explicitly stored kb computed needed 
computation called reasoning aka derivation deduction inference 
general user interact reasoner subroutines tell kb tells reasoner extend knowledge base kb include new information ask kb asks reasoner true reasoner answer convey information user lev 
provide details nature kb 
particular section motivates symbolic reasoners presents broad categories systems 
describes quality measures evaluate reasoner correctness precision expressiveness efficiency 
clearly prefer reasoner returns correct precise answers immediately arbitrary queries 
unfortunately see possible 
implemented reasoning systems sacrifice correctness precision expressiveness gain efficiency 
remainder tutorial various approaches section resp section section overviews ways improving worst case efficiency reducing expressiveness resp allowing imprecise answers allowing occasional incorrect responses section considers ways producing expressive precise correct systems performance high possible 
provide new proposals addressing problems extend ideas existing literature 
symbolic reasoners symbolic reasoners 
focus symbolic reasoning deals knowledge bases kb individual components isolation semantic content kb may contain statements world propositional logic predicate calculus probabilistic structure details 
contrast example knowledge encoded numeric function embodied neural net 
reasons symbolic encoding useful explanation systems interact people 
crucial systems able justify produced answers addition course supplying correct answer 
symbolic reasoners convey decisions justifications person terms computations terms semantics typically meaningful user 
construction debugging maintaining individual components system rules random variables 
meaningful people isolation relatively easy expert encode relevant features 
semantics helps expert debug update problematic knowledge base domain expert examine single specific component isolation determine appropriate 
handling partial information exists distributions formalisms including ones admit explicit reasoning capable dealing complete knowledge corresponding universally quantified statements gender female disease meningitis meningitis 
situations may partial knowledge disease meningitis hepatitis people meningitis 
logics including containing propositional logic readily express information completely general may include routines retract assertions general revise beliefs agm consider issue 
disjunction negation 
expressive systems predicate calculus deal existentials 
may want explicitly state confident claim probabilities 
broad categories reasoning systems standard formalisms encoding semantic information associated type reasoning 
tutorial focus major categories 
sound monotonic logical reasoning formalism assumes precise discrete descriptions objects expect obtain precise categorical answers questions posed 
particular systems provide assurances answers correct believe input facts believe 
detail category includes propositional logic order logic predicate calculus higher order logics gn cl 
example logical system may include facts woman child bearing years abdomen pregnant 
assert patient female correct age abdomen reasoner conclude pregnant 
view systems collection inference rules possibly augmented rewrite rules infer new statements existing kb see appendix 
appendix shows turn forward chaining systems systems answer queries 
rules sound read truth preserving resulting extended kb correct initial kb see appendix 
robinson rob proved word logical order inference terms resolution see appendix 
ongoing challenge find proof efficiently possible see section appendix 
systems sound deductive techniques natural deduction thinker pel mizar rud mca equational logic ot ter mw 
note systems resolution addition specialized inference rules 
systems better viewed proof checkers theorem provers main function verify proposed proof legitimate 
hope gain efficiency sharing burden hopefully insightful person 
brevity tutorial discuss approaches 
non monotonic logical reasoning standard logical inference monotonic new information cause reasoner retract 
example deriving patient pregnant general medical information information specific patient finding new information change 
appropriate subsequent information compromise prior 
imagine example finding patient 
note mean earlier inappropriate earlier store knowledge probably correct interpretation 
useful allow reasoner change mind new data 
intuitive concept nonmonotonicity motivated proven difficult provide effective implementation see vast literature common sense reasoning includes default reasoning rei circumscription mcc autoepistemic logics mt variants see bob gin 
visible exception claim theorist pga handled useful intuitive subset table joint probability distribution fortunately alternative approaches promising precise definitions implementations discussed 
tutorial discuss non monotonic reasoning formalisms 

probabilistic statistical reasoning forms information inherently probabilistic certain symptoms may confident patient hepatitis evidence may sure specific stock go price 
possible downside dealing probabilities amount information encoded general may express entire joint distribution exponential number features see table 
years observation motivated researchers seek ways avoid dealing probabilities 
situations ways express information factoring joint distribution 
led belief nets aka causal nets probability networks bayesian nets decade representation choice dealing uncertainty pea sp 
concrete consider claims hepatitis causes causes positive chance symptoms increase patient hepatitis 
represent information full joint binary variables see table realistic fabricated numbers information compute example posterior probability patient hepatitis negative blood test 
associated computation fh bg fbg involves standard steps marginalization summations shown deal unspecified values various symptoms conditionalization division compute conditional probability see fel 
belief network represent graphical structure nodes represent probabilistic variables hepatitis directed links roughly speaking represent causal dependencies understanding path possibly direct connection knowing value help specify value particular node associated conditional probability table aka specifies conditional distribution assignment parents see 
default reasoning 
note identifying node associated variables 
gamma gamma gamma psi simple minimal belief network general binary valued variables node parents fy include rows possible assignments columns possible value entry table specify conditional probability represents th assignment fh delta delta delta ig 
note final column table superfluous row add 
course ideas generalize general ary variables 
notice redundancy network shown patient ff hepatitis probability ff depend ff positive blood test 
independent blood test hepatitis 
reduction called factoring allows simpler network shown 
factored representations include relevant connections include 
directly influence means resulting network typically requires user specify fewer links fewer parameters entries means inference process discussed generally performed efficiently 
saving relatively small links total parameters savings significant larger networks 
real world example complete joint distribution alarm belief net nodes arcs require approximately parameters naive tabular representation la table 
actual belief net includes parameters 
final comment belief net exploit distribution factored formalism force representation factored inappropriate belief net represent general non factored distribution 
course network require comprehensive set parameters gamma parameters binary variables 
note combine notion probability utility functions specify goodness various possible outcomes resulting system address issues inference discussed 
particular problematic deciding includes entries omits superfluous columns values just gamma 
tricks representation reduce number parameters required pea 
example known cpcs belief net require parameters dealing explicit 
note huge savings table form 
network represented parameters 
gamma gamma gamma psi corresponding minimal belief network actiona optimal decision data may contradict actiona appropriate data delta 
ways deal uncertainty including fuzzy logic theory evidence forms neural nets focus systems standard notions probability fel 
obvious connections logic probability formalisms 
example view possible worlds shown table qualitative version atomic events see table understanding impossible world probability occuring possible words non probability 
including nilsson nil provided formalisms attempt link areas 
note standard models probability belief nets viewed natural extension propositional logic fundamental unit considered proposition female pregnant 
predicate calculus general propositional logic basic unit individual may certain properties mary property female property pregnant 
groups actively trying extend probabilities expressive see hal nh kp poo 
fascinating scope survey 
information belief nets see pea www af mil schools en eng labs ai 
challenges reasoning reasoning systems address challenges knowledge encoded available 
standard approaches involve knowledge acquisition acquiring relevant information human domain experts see scg standard protocols interviewing techniques 
learning gathering required information training data typically information specifies set earlier situations coupled correct response mit 
quite combination 
tutorial assume available information general situation specific knowledge sufficient reach appropriate may obvious reach approximate see 
directly consider issues learning explicitly consider related challenges maintaining updating knowledge 
tutorial focuses second major challenge efficiently producing correct answers relevant queries 
quality measures course reasoning system correct returns correct answer precise returns specific answer expressive allows express possible piece information ask possible question efficient returns answers quickly 
see ge dp 
note correctness precision defined respect base 
unfortunately impossible order logic decidable 
particular sound complete read correct precise reasoning system decidable representation expressive arithmetic 
hardness results expressive systems general propositional reasoning np complete gj fact hard val probabilistic reasoning context belief nets coo 
getting approximate answers belief net additive factor np hard dl getting answers multiplicative factor gammaffl ffl rot 
view general property reasoning fundamental tradeoff worst case run time efficiency correct precise reasoning process increases monotonically expressiveness reasoner language 
mentioned prompted implemented reasoning systems sacrifice correctness precision expressiveness gain efficiency 
sections consider possibility improving worst case efficiency resp 
reducing expressiveness allowing imprecise answers allowing occasional incorrect responses section considers producing expressive precise correct systems average case performance high possible 
improving worst case efficiency reducing expressiveness section discusses reasoning systems give expressiveness obtain guarantees efficient performance 
expressive logic reasoners standard database management sytems dbms allow conjunctions positive ground atomic literals 
systems allow users state mcd army tanks answer questions correspond existentially quantified boolean combinations atomic literals 
systems allow user explicitly state ask questions claims combine measures single decision theoretic grounds quality vs efficiency tradeoff 
form mcd tanks mcd mcd tanks typical dbms allow disjunctions negations existentials rei 
upside database reasoning answering standard sql queries efficient worse linear size database 
comments relevant linear efficiency may optimal takes time simply input information 
clever reasoning system may able better query run time ask routine done appropriate information asserted compile time tell 
extreme imagine dbms explicitly stores answers allowed queries assertions entered sufficiently narrow space possible queries see section sufficiently indexing scheme reasoner answer queries time considerably extremely important practice linear complexity expensive large databases 
return general issue perform inference 
second database systems typically embody implicit assumptions extend set queries correctly answered 
particular closed world assumption allows dbms conclude mcd tanks database explicitly include assertion mcd tanks rei special case negation failure policy logic programs cla 
unique names assumption allows dbms conclude mcd products database includes mcd mcd rei assumption allows conclude fact names distinct see rei 
note assumptions extend set queries correctly answered extend information user express generally user option expressing assertions 
semantic nets frame systems artificial intelligence ai representation formalism 
hindsight view research areas guided objective producing efficient reasoning system fin 
systems general allowed conjunctions atomic unary binary literals simple antecedent rules literals 
terminological logics aka description logics attempted formalize extend systems producing system language expressive possible constraint worst time capacity remain polynomial 
relates notion complexity cliffs lb lev keep increasing expressiveness language adding new logical connectives increasing number disjuncts allowed clause retain worst case polynomial complexity reaching cliff moves system np hard 
add set additional connectives reaching cliff complete system goes decidable np hard undecidable 
see mentioned reinforced appendix resolution sufficient answer logic query 
prolog specific embodiment resolution derivation process deal certain class knowledge bases queries 
particular prolog deals horn clauses knowledge bases expressed conjunctions disjunctions disjunction includes positive literal cm 
explain note claim true different names similarly professor greiner russ refer mcc 
entries form mcd closed world assumption allows reasoner conclude items unique names assumption items 
clausal form horn clauses definite clauses datalog propositional definite function free propositional calculus propositional clauses cnf cnf propositional database decidable undecidable turing equivalent np hard polynomial complexity cliff taken pmg restrictions note propositional reasoning np hard linear time algorithm answering queries horn database dg 
exchange potentially exponential speed statements expressed prolog particular state arbitrary disjuncts patient hepatitis meningitis 
prolog show existentially quantified query entailed specific instantiation variables entailed 
note case see appendix fortunately practice limitations severe standard tasks require reasoning cases 
programming systems fre attempt accomodate larger subset clauses course systems provide guarantees system 
expressive belief nets probabilistic queries consider probabilities belief nets focusing belief updating task computing em posterior probability hypothesis variable conditioned concrete evidence form cough true temp 
note conditioning evidence typically involve variables 
note fast inference processes associated certain types structures certain types queries 
inference trivial naive bayes classifiers form shown 
node bch de provide syntactic situations reasoning efficient 
prolog perform sound return answer correct 
efficiency means unification procedure running innermost loop size largest literal gn 
prolog includes impurities negation failure delta cut 
tasks computing maximum posteriori assignment variables concrete evidence similar complexity dec ah 
delta delta delta gamma gamma psi hj example naive bayes structure pregnant insulin age dpf glucose mass tan model dashed lines naive bayes solid lines express correlation attributes taken fgg belief nets motivated task classification assigning label instance specified set attribute values 
net includes node represent classification parent nodes attributes 
inference guaranteed fast number specified attributes systems express general dependencies attributes 
efficient algorithms inference general class poly trees belief nets include single undirected path connecting pair nodes pea see appendix 
notice class generalizes tree structures fortiori naive bayes structures ignoring directions arrows allowing multiple root nodes 
dependencies expressed 
friedman geiger goldschmidt fgg combine ideas naive bayes poly tree structures produce tree augmented bayesian net tan structures classify instances 
structures resemble naive bayes trees express certain dependencies children read attributes 
define tan structures arc single classification node attribute node 
bn structure obtained removing classification attribute links initial 
bn poly tree 
see 
close comments efficient structures quick comments classes naive bayes poly tree learned efficiently cl efficient reasoning 
coincidence classes networks admit efficient inference hard learn vice versa 
system designers learning algorithms sin sm heuristic networks fewer arcs tend see efficient algorithm observe tan structure single node cut set see appendix 
efficient argument seeking networks fewer connections 
course belief net inference np complete node network parents coo 
efficient algorithms reasoning simple structures similarity networks hec 
positive results deal general queries subset possible conditioning variables set 
efficient ways compute em evidence fe comprehensive includes variables variables easy compute em general belief net fe set includes members parents descendents fe includes markov blanket parents children parents non immediate parents immediate refering pregnant parents age age parents insulin 
contrast efficient known algorithms answering general queries general belief nets exponential 
algorithms junction tree aka clique tree cf bucket elimination exponential network induced tree width measure topology network arn 
class algorithms cut set elimination 
complexity exponential min cut separation network 
appendix provides quick summary major algorithms computing posterior probabilities belief net 
summary section considered types reasoners produces correct precise answers situations accomodate state appropriate facts pose appropriate question system produce correct answers precisely 
limitations stated 
sections reasoners attempt remain expressive possible hope gain efficiency imprecise occasionally incorrect improving worst case efficiency allowing vague answers general reasoning algorithm produces answer query 
answer correct follows knowledge base 
note correct answer vague imprecise 
example hep answer hep correct precise 
extreme answer hep vague useless wrong 
similarly answering propositional query don know incorrect vague answer situations better arbitrarily guessing say 
extreme situation system may answers question disease bacteria correct precise stating similarly correct vague answer stan adult men living kansas adult men living outside california precision correctness relative knowledge base 
example stating fido isa dog precise kb sanctions 
answer imprecise respect specific kb entails fido isa 
especially true systems deal qualitative reasoning qualitative belief nets wel 
general say answer precise respect knowledge base kb query specific possible considered imprecise vague approximate 
note note point orthogonal goal learning accurate networks regularizing term hec 
ps flow diagram ps addressing sigma issue precision orthogonal correctness answer precise wrong imagine stating hep 
section consider reasoners return correct vague answers 
state precisely general ff answer query predicate calculus situation may correspond fi binding fi fi delta delta delta fi user seeking answers 
probabilistic case ff 
assume correct precise answer query means know kb answer ff correct necessarily precise kb ff ff satisfy syntactic requirements insure relates query 
view tautology true false notice answer correct 
correct answer precise kb consider relative measure precision fixed kb say precise kb fact induces partial ordering 
imprecise logical reasoners horn approximation reasoners sk imprecise logical reasoners 
recall inference general propositional theory np hard efficient algorithms reasoning horn theory 
note bound theory sigma pair horn theories sigma means statement theory logically entailed theory 
sigma fa cg fa bcg stronger horn theory bcg weaker horn theory 
reasoner called ps pair called horn approximation sigma answer sigma asks returns query succeeds 
asks returns query fails 
test produces definitive answer reasoner simply returns imprecise see 
note answers correct implies sigma implies sigma precise answers arise original sigma 
sigma return categorical answer ps 
challenges maximal strengthenings np hard find optimal weakening exponentially larger initial theory 
section discusses approach address issues 
body approximation coupled related notion abstraction course logically entailed kb know ff 
write claim ff form symmetry way express precision 
dalal etherington de discuss various extensions framework 
aaa ell sac 
results removing hopefully inconsequential distinction knowledge base query order simplify reasoning process 
consider stochastic algorithms 
prominent example gsat algorithm slm attempts solve satisfiability problems hill climbing space assignments random starting assignment think row table 
example score assignment fixed sat formula clauses number clauses satisfied note score ranges assignment gsat considers changing individual variable climbs new assignment highest score recurs 
gsat finds satisfying assignment assignment score correctly reports problem solution 
gsat unable determine sat instance solution terminate number iterations random walks return inconclusive don know 
gsat algorithm hs knows knows answer returns correct answer silent 
worth commenting despite inherent incompleteness gsat proven extremely useful able solve problems current algorithm solve 
related ideas successfully planning ks 
imprecise probabilistic reasoners mentioned probabilistic reasoner returns hep correct answer hep correct imprecise 
unfortunately finding approximately correct answer hard getting answer additive factor np hard dl getting answers multiplicative factor gammaffl ffl rot 
systems address task 
include algorithms return answers guaranteed bounds bounds correct value view meaning answer interval means 
approximation techniques best described relative algorithm perform exact belief update general 
relevant algorithms described appendix 
dr dechter rish modify bucket elimination algorithm see appendix provide approximate answer replace bucket function set smaller functions include subset functions associated variable 
results hold discrete variables 
jaakkola jordan jj jj similar idea continuous gaussian variables algorithm sequentially removes unassigned variable replacing approximation function computes bound resp bound correct function 
horvitz similarly tweaked idea context cut set conditioning see appendix consider values cut set variables get approximation guaranteed additive factor ffl away correct value summing values probability mass collectively exceeds gamma ffl see hsc 
approaches removing aspect belief net node arc values variable 
lpe localized partial evaluation algorithm dh maintains propagates intervals belief update process compute range posterior probability interest 
lpe disregard variable appears distant query nodes relatively irrelevant setting value 
see srinivas sri wilkins mw consider removing nodes networks reduce complexity computation 
attempt reduce complexity removing arcs network 
particular kjaerulff proposes heuristics suggest arcs removed respect clique tree algorithm see appendix 
van extends idea providing algorithm applies arbitrary inference algorithms just clique tree approach allows cases arcs removed 
bounds error jp nr ns gamma obtained ns correct compute conditional 
ns network obtained removing arc network pnr ns probability value returned network result obtained original network 
wellman liu lw wel leave structure belief net unaffected algorithm reduces complexity inference abstracting state individual variables changing variable range states range say values partitioning values original variable smaller set 
related approach reduces complexity inference disregarding values variables relatively poo 
reduction maximal graph network relevant variable variables occur early topological ordering variable occurs children 
finding dagum luby dl networks extreme values approximated efficiently 
observation hardness proofs involve include essence means network logical inference 
general values bounded away entries greater sub exponential time algorithm computing value bounded multiplicative factor optimal time poly ffl ln depth belief net number nodes poly time algorithm return answer gamma ffl ffl correct answer ffl parameter supplied user 
comments obvious ways reasoner interact user respect approximations user set precision bounds expect reasoner return answer satisfies requirement reasoner charge user requiring time return answer precise 
results shown dagum luby property 
return answer bounds bounds specify answer user adjust parameters get answer bound pair bound presumably better 
note systems improve efficiency underlying computation produce answer approximation correct value 
body tricks help reduce average complexity answering query degradation precision mention tricks section 
improving worst case efficiency allowing incorrect responses course reasoners provide answers correct may occasionally return erroneous answers 
sub divide correct systems groups deterministic presumably give correct answers queries reliably time query posed returns possibly incorrect answer versus stochastic may return different answers query different calls 
bn returns estimate belief net bn dom done samples threshold 
bn return estimates dom bn returns random instance bn maps node value domain root node draw dom prob pbn set remaining node order satisfying dag structure finding values parents draw dom prob pbn set return logical sampling example motivated deterministic unsound algorithms consider anytime algorithms systems required produce answer requested 
note appropriate reasoner really return answer decide action hard deadline 
course action decision 
systems may guess computed appropriate answer 
example consider variant horn see returns definitive tests fail 
focus stochastic algorithms reasoner uses source random bits computation 
general evaluate correct reasoners distance measure computes distance correct answer query response returned 
note function iff function just determine returned correct answer 
worst case score largest value queries average score expected value queries encountered 
evaluate stochastic reasoner average answers returned setting random bits 
stochastic logical reasoning algorithms obvious example gsat return unsatisfiable satisfying assignment 
necessarily correct 
taken sufficient number restarts confident correct 
stochastic probabilistic reasoning algorithms huge inventory algorithms stochastically evaluate belief net 
simplest algorithm logic sampling appears 
simply draw number samples distribution associated belief net compute empirical estimate times conditioning event occured instances generated equal domain 
algorithm uses bn 
explain subroutine works consider cloudy rain sprinkler wet grass simple belief net taken rn network shown 


get value cloudy flip coin assume flip returns cloudy true 
get value sprinkler flip coin cloudy true assume flip returns false 
get value rain flip coin cloudy true assume flip returns rain true 
get value flip coin sprinkler rain assume flip returns true return instance cloudy true false rain true true calls see different results coin flips return instances 
note algorithm ignore instance 
corresponds tuple values variables clearly inefficient especially rare event 
algorithm likelihood weighted sampling shown avoids problem routine uses generate samples delta similar delta insists generated instance evidence variable gave instance score observe new bn routine weight parents current example estimate rain associated 
bn dom done samples threshold 
bn random instance bn parents assignment return estimates dom likelihood weighted sampling 
get value cloudy flip coin assume flip returned cloudy false 
get value sprinkler flip coin cloudy false assume flip returned true 
rain note evidence variable set required value true 
cloudy false run counts 
get value flip coin sprinkler rain assume flip returned true associated tuple cloudy false true rain true true probability increment 
stochastic algorithms belief net inference importance sampling monte carlo sampling pd algorithms combine stochastic algorithms parts exact reasoning nodes 
described ccf 
improving average case note specific hardness results mentioned worst case parameterized class decision problems exhibits exponential scaling gj 
particular problematic problems encountered practice 
general implement system average performance high possible performance defined function incorporates correctness precision efficiency weighted appropriate tasks average respect distribution tasks encountered approach discussed simply define away problematic problems dealing restricted class tasks excludes expensive situations 
considering angle finding algorithm appropriate actual tasks encountered 
decision algorithm data structure arbitrary just hope associated system adequate actual system 
system designer knows lot way eventual reasoner designer engineer specific algorithm algorithms works best subspace tasks 
example designer knows attribute values conditionally independent classification sense build naive bayes classifier similarly system needs reason cases prolog inference process quite appropriate 
alternatively reasoner learn information distribution tasks identify reasoner set parameterized reasoning algorithms performs best see gre 
consider situations designer versus know performance task 
efficient average logical reasoners noted appendix logic reasoning systems decide step inference rewrite rule set statements 
resolution systems fewer options decide clauses select 
general schemes set support may constrain selection possible options 
logical reasoning community investigated variety techniques improving performance logic reasoning systems providing explicit meta level control information controlling inference process cf sg database community join ordering magic sets sg 
general systems may improve performance reasoner single query clever pre processing step 
interested angle modifying underlying reasoner average distribution queries encounter typically requiring preprocessing step 
example resolution system may search strategy specify clause clause appeared fixed ordering prefer clause fewest number literals prefer clauses name relation appearing literal 
clearly time required find solution specific query depends critically search strategy 
want find strategy average time distribution queries minimum 
general system designer may know compile time queries posed 
reasoner times learner may able estimate distribution tasks watching initial reasoner solving tasks 
learner distributional information identify algorithms best 
system including reasoner learner pay expense solving problems standard general methods tasks obtaining information required find best special purpose algorithm 
lead body explanation learning ebl solving set queries ebl system analyse results seeking ways solve queries related ones efficiently encountered see gre 
underlying optimization task np hard gre systems hill climb initial strategy better gre gd 
note learner learning usage patterns reasoner domain se 
note hill climbing systems contexts deal optimizations 
particular palo system gre find horn approximation precise read categorical possible see gs 
returning topic improving average efficiency recall interface reasoner tell ask subroutines 
prolog tell routine trivial ask routine essentially reasoning answer query 
systems including built ops including xcon bulk inference forward chaining manner tell forward chain assert newly entailed information 
answering certain questions trivial situation especially know answer query explicitly iff entailed 
genesereth tg consider mixed systems ask tell share load 
finding correct allocation minimizes total computational time challenging requires knowing estimating distribution queries asked distribution new information asserted typically solving np hard problem 
similar caching solutions derivation improve performance queries 
greiner cg efficient algorithm specifies results stored function frequency queries updates costs storage efficient average belief nets inference bn inference algorithms perform inference specific belief net involved 
systems examine specific query preprocessing step modify algorithms datastructure accordingly remove nodes separated pea query nodes including nodes zp find ordering process appropriate nodes instantiated dec forth course preprocessing expensive involve solving underlying inference process np hard problem 
effective inference process may try find inference procedure optimal distribution queries encounter 
modification query 
herskovits cooper hc consider caching answers common queries reasoner simply return explicitly stored answers particular queries posed reasoner standard belief net computation 
researchers analytic model obtained belief net induce distribution queries determine queries common 
dp dp takes different cut designer specified belief net queries performance system handle system compiles appropriate inference system produce efficient system efficient queries 
compiled version performs computations basic inference algorithm perform avoids run time look ups find particular nodes tact appendix shows known algorithms fqa answering queries bn 
algorithm slow particular query possible algorithm may quite efficient query 
different bns express distribution provide answers queries 
specific qa algorithm slow query net bn ff algorithm may efficient query uses different equivalent net bn fi seek efficient bn qa combination determine algorithm parameters run belief net set equivalent bns minimize expected time answer queries expected time average time distribution queries encountered 
task corresponds model deals efficiency 
search best algorithm encoding need blind incorporate known results avoid cutset conditioning show require computations junction tree algorithms dec empirical evaluations shenoy ls suggests shafer shenoy algorithm efficient hugin algorithm improve original :10.1.1.57.1097
course extend results seeking acceptable approximation insist precise answer 
researchers practitioners confront issue building reasoning system reliable sense efficient tutorial provides sampling techniques 
leave tutorial relatively small skip large bodies techniques 
example considered techniques radically change representation re expressing information neural net ts considering characteristic models theory kks kr 
chose focus techniques specific reasoning pass huge inventory techniques associated improving efficiency computations general including clever compilation techniques exploiting parallel algorithms 
needless say techniques essential producing reasoning algorithms efficient possible 
summarize large variety techniques improving effectiveness reasoning system considering sound logical reasoning systems horn clauses probabilistic reasoners typically belief nets 
general techniques embody implicit tradeoff system designer willing sacrifice desirable property expressiveness precision correctness increase system efficiency 
foundations logical reasoning appendix explains typical logical reasoning systems works discusses notions soundness completeness defines resolution inference process overviews issue control inference 
logical derivation logical derivation reasoner begins particular knowledge base propositions kb square triangle square polygon triangle polygon uses inference rules form ff fi ff fi sequentially produce larger sets propositions 
particular rule called modus ponens means expressions ff fi specific statements ff fi ff explicitly knowledge base reasoner allowed extend knowledge base adding new clause fi 
notice kb true ff square fi polygon reasoner allowed form kb kb inference rules including elimination ff fi ff states reasoner add ff sees ff fi knowledge base instantiation ff ff ground term allows reasoner add instance universally quantified formula 
example big big 
triangle polygon conclude say triangle polygon 
subsequent modus ponens allow reasoner add polygon 
note reasoner add triangle polygon triangle frog polygon frog course inference modus ponens apply 
general inference process ir uses set inference rules extend knowledge base 
process mapping knowledge base larger knowledge base adding propositions sanctioned inference rules commonly called forward chaining 
contrast reasoning systems take input knowledge base kb specific query try determine follows kb polygon 
conceptually reasoner blindly forward chain initial knowledge base reaching knowledge base contains query 
practice reasoners query guide search 
approach run inference rules backwards query reasoner investigating reasoner find inference rules allow add see antecedents knowledge base enable rule recur attempting add propositions 
process called backward reasoning see gn 
appendix show way backward reasoning 
general write kb ir ir inference process derive proposition knowledge base kb 
ab bc ab ac delta delta delta 















table possible worlds correctness inference listed inference rules equations 
obvious question rules arbitrary 
asked different way possible say inference rules appropriate inappropriate 
notion semantics general set propositions possible worlds world assigns proposition true false see table 
assertion eliminate subset worlds 
example asserting ab holds means believe correct world eliminate impossible 
similarly statement ab ab means correct world fi ab false ab true 
suppose asserted statements ab ab ab means believe correct world intersection sets fi observe ab holds worlds 
believe ab ab ab safely conclude ab true write ab ab ab ab say ab entailed ab ab ab note table exponentially large propositional case finite predicate calculus context constant unary function delta unary relation delta table include columns labeled 
find way compute logical inferences producing table subsequently eliminating rows 
role derivation aka reasoning 
noted view derivation process involving collection inference rules 
inference rule property true antecedents called sound 
note modus ponens ff fi fl ff fi fi fl ff fl false false false false true false false false true false true true false true false true false false false true true true true true true false false true true true true false true true true true true true false true false true true true true true true true table resolution sound taken rn elimination instantiation sound rule ff fi ff fi 
trivial see rules mentioned sound cases obvious 
consider example resolution inference rule delta delta delta gamma delta delta delta bm delta delta delta gamma delta delta delta bm literal 
propositional form 
additional complications predicate calculus situation rule deal variables find substitution literals look alike apply substitution remaining see gn 
table considers slightly simpler cases 
underlined situation ff fi fi fl hold note cases ff fl holds 
observe immediately inference process works applying sequence sound inference rules necessary sound 
easy see ir involves sound rules kb ir kb ir inference process reaches knowledge base kb true kb 
course direction particular just say inference process reaches kb sound 
useful inference process complete kb kb ir eventually conclude true statement 
note sound complete corresponds earlier accurate precise 
resolution sufficient general reasoning requires sequentially selecting inference rule inventory rules findings set facts knowledge base match rule antecedents adding 
obvious questions large number rules reasoner rule 
set rules sufficient guarantee resulting inference process complete find true 
fortunately single resolution inference rule equation sufficient 
determine kb robinson rob provided algorithm form new theory kb kb adding negation query expressing resulting theory conjunctive normal form cnf conjunction set clauses clause disjunction zero positive negative literals 
note resolution looking information exactly form 
inference process repeatedly resolution inference rule trying derive empty clause disjunction literals 
reasoner repeatedly select clauses current knowledge base add resolvent 
continue finding empty clause returning running clauses resolve returning 
robinson proved re express theory equivalent cnf trivial theory includes quantifiers variables kb iff kb kb inconsistent kb fg resolution refutation complete theory inconsistent resolution proof concludes empty clause 
note robinson specify pair clauses step see 
logically follow kb guarantee resolution process terminate 
follows observation encode halting problem representation 
control inference results reasoner answer question need encode knowledge negation query cnf repeatedly apply single resolution rule various pairs propositions current knowledge base seeking empty clause 
remaining issue deciding gamma delta possible pairs clauses time increasing value clauses current set 
reasoning reduces task determining knowledge base inconsistent 
unfortunately problem undecidable general propositional case np hard means probably efficient algorithm solve general 
understand challenging consider complementary challenge finding consistent assignment cnf formula trying find assignment maps variable true false clause true 
note assignment due third clause assignment fails due 
haken proved resolution algorithm worst case exponential complexity 
heuristics reduce complexity 
example set support resolution insists propositions part initial negated query added earlier inference step refutation complete lock resolution allows resolving clauses literals unify ancestry filtered resolution see gn 
variety specialized variants resolution refutation complete horn clauses 
search issue remaining see discussion section questions prolog represent consider question irrational number irrational power rational 
resp represent set rational reals resp irrational reals 
note particular course take domain discourse reals 
asking pair trivial proof uses simple facts arithmetic fact consider cases 
rational done just set 
alternatively suppose irrational 
note theta just set 
situation see pair rational 
unfortunately prolog able answer question state situation basically state equation reason cases 
addition notice explicit assignment returned single pair values satisfies requirement 
reasoning belief nets bn inference hard 
pearl pea proved belief net inference straightforward networks polytree structure undirected path connecting pair nodes 
obvious algorithm simply propagates numbers node immediate neighbors children parents recurs simpler structure obtained deleting unfortunately idea general networks contain undirected cycles nodes may induce dependencies may difference places far away network 
see consider asking probability true network shown 
naive incorrect algorithm see true half time means true half time suggests true true probability theta course wrong true false vice versa 
chance true 
issue course simply propagate information forget source dependency induced common parent rg heard lecture steve cook 
actual algorithm runs phases going roots leaves going leaves roots 
ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl gamma gamma psi gamma gamma psi simple non poly tree belief network cloudy rain sprinkler wet grass tt tf ft ff cloudy spr rain wet grass original non pt belief net equivalent poly tree bn taken rn belief updating belief networks major categories algorithms belief updating general belief nets 
rely observation efficient algorithm computing arbitrary posterior probabilities poly tree structure algorithm subroutine 
clustering clustering trick convert belief network equivalent network poly tree merging various sets nodes associated mega nodes 
example consider transforming network left side network right side 
note new structure may exponentially bigger original belief net cp tables mega node huge formed nodes fn include column combination values fn 
inference linear size new network size exponential size initial belief network 
ways form clusters see ls details hugin system jlo 
general algorithm network connecting aka parents node resulting graph form forms junction tree tree structure nodes correspond maximal cliques arcs ae labeled nodes wet grass rain sprinkler cloudy cloudy wet grass rain sprinkler cloudy cloudy example cutset conditioning taken rn intersection nodes label algorithm uses poly tree algorithm produce answer original query 
approach called junction tree algorithm clique tree algorithm 
see ls specification algorithms lauritzen spiegelhalter hugin shenoy shafer 
bucket elimination simpler ways understand basic computation including li ambrosio spi ld zhang poole algorithm zp dechter bucket elimination dec 
focus third performs belief updating storing set buckets th bucket contains just involve variables largest index 
note algorithm requires ordering nodes 
sequentially eliminates read away variable updating remaining buckets appropriately include marginals left removing dependencies dechter shows relatively straightforward algorithm fact doing computation general clustering algorithm worst case complexity 
proves small variant algorithm corresponds poly tree algorithm 
cut set conditioning cut set conditioning algorithm uses poly tree algorithm different manner 
belief net cp nodes query finds subset fx ae nodes ffl bx bn poly tree ffl easy compute see sc 
exploits equality answer query 
note trivial compute easy construction poly tree computation 
illustrates construction 
run time algorithm exponential jx sum terms 
space requirement linear jx need maintain running tally 
aaa aaai 
workshop approximation abstraction computational theories 
technical report aaai 
agm carlos alchourr peter gardenfors david makinson 
logic theory change partial meet contraction revision functions 
journal symbolic logic 
ah 
approximating maps belief networks np hard theorems 
artificial intelligence 
andersen olesen jensen jensen 
hugin shell building bayesian belief universes expert systems 
proceedings eleventh international joint conference artificial intelligence ijcai volume pages detroit michigan august 
morgan kaufmann 
arn stefan arnborg 
efficient algorithms combinatorial problems graphs bounded decomposability survey 
bit 
paulo azevedo 
magic sets full sharing 
journal logic programming march 
bch hammer 
polynomial time inference valid implications horn related formulae 
annals mathematics artificial intelligence 
farrell kant martin 
programming expert systems ops 
addison wesley reading ma january 
bacchus grove halpern koller 
statistical knowledge bases degrees belief 
artificial intelligence 
bob artificial intelligence april 
special issue non monotonic logic 
virginia barker dennis connor judith elliot soloway 
expert systems configuration digital xcon 
communications acm march 
beinlich suermondt chavez cooper 
alarm monitoring system case study probabilistic inference techniques belief networks 
proceedings second european conference artificial intelligence medicine london 
springer verlag berlin august 
ccf cousins chen frisse 
tutorial stochastic simulation algorithms belief networks 
artificial intelligence medicine 
cg vinay chaudhri russell greiner 
formal analysis solution caching 
proceedings ninth canadian conference artificial intelligence vancouver 
cl chow lui 
discrete probability distributions dependence trees 
ieee transactions theory 
cl chin liang chang richard char tung lee 
symbolic logic mechanical theorem proving 
academic press new york 
cla clark 
negation failure 
gallaire minker editors logic data bases pages 
plenum press new york 
cm william clocksin christopher mellish 
programming prolog 
springer verlag new york 
coo cooper 
computational complexity probabilistic inference bayesian belief networks 
artificial intelligence 
de dalal david etherington 
tractable approximate deduction limited vocabulary 
proceedings ninth canadian conference artificial intelligence vancouver may 
de dalal david etherington 
hierarchy tractable satisfiability problems 
information processing letters december 
dec rina dechter 
topological parameters time space tradeoff 
eric horvitz finn jensen editors proc 
uncertainty ai pages san francisco 
morgan kaufmann publishers 
dec rina dechter 
bucket elimination unifying framework probabilistic inference 
learning inference graphical models 
dg william dowling jean gallier 
linear time algorithms testing satisfiability propositional horn formula 
journal logic programming 
dh denise draper steve hanks 
localized partial evaluation belief networks 
ramon lopez de mantaras david poole editors proceedings th conference uncertainty artificial intelligence pages san francisco ca usa july 
morgan kaufmann publishers 
dl dagum luby 
approximating probabilistic inference bayesian belief networks np hard 
artificial intelligence march 
dl dagum luby 
optimal approximation algorithm bayesian inference 
artificial intelligence 
francesco donini maurizio lenzerini daniele nardi werner nutt 
complexity concept languages 
information computation april 
dp jon doyle ramesh patil 
theses knowledge representation language restrictions taxonomic classification utility representation services 
artificial intelligence 
dp adnan darwiche gregory provan 
query dags practical paradigm implementing belief network inference 
proc 
uncertainty ai 
dp adnan darwiche gregory provan 
standard approach optimizing belief network inference query dags 
proc 
uncertainty ai 
dr rina dechter rish 
scheme approximating probabilistic inference 
proc 
uncertainty ai 
ell thomas 
abstraction approximate symmetry 
ijcai 
herbert enderton 
mathematical logic 
academic press new york 
fel feller 
probability theory applications ii 
john wiley new york 
fgg nir friedman dan geiger moises goldszmidt 
bayesian network classifiers 
machine learning 
fin nicholas findler editor 
associative networks representation knowledge computers new york 
academic press 
fre freuder editor 
principles practice constraint programming 
springer 
gd jonathan gratch gerald dejong 
decision theoretic approach adaptive problem solving 
artificial intelligence 
ge russell greiner charles elkan 
measuring improving effectiveness representations 
proceedings twelfth international joint conference artificial intelligence pages sydney australia august 
russell greiner adam grove dale schuurmans 
learning bayesian nets perform 
uncertainty artificial intelligence 
gin matthew ginsberg editor 
readings nonmonotonic reasoning 
morgan kaufmann publishers los altos ca 
gj michael garey david johnson 
computers intractability guide theory np completeness 
freeman new york 
gn michael genesereth nils nilsson 
logical foundations artificial intelligence 
morgan kaufmann publishers los altos ca 
gre russell greiner 
finding optimal derivation strategy redundant knowledge base 
artificial intelligence 
www cs ualberta ca greiner papers ps 
gre russell greiner 
palo probabilistic hill climbing algorithm 
artificial intelligence july 
www cs ualberta ca greiner papers palo aij ps 
gre russell greiner 
explanation learning 
wilson frank keil editors encyclopedia cognitive science 
mit press bradford book 
appear 
gs russell greiner dale schuurmans 
learning useful horn approximations 
nebel rich swartout editors proceedings kr san mateo ca october 
morgan kaufmann 
www cs ualberta ca greiner papers horn ps 
haken 
intractability resolution 
theoretical computer science august 
hal joseph halpern 
analysis order logics probability 
artificial intelligence december 
hc herskovits cooper 
algorithms bayesian belief network precomputation 
methods information medicine 
hec david heckerman 
probabilistic similarity networks 
mit press cambridge 
hec david heckerman 
tutorial learning bayesian networks 
technical report microsoft research 
hs holger hoos thomas stutzle 
evaluating las vegas algorithms pitfalls remedies 
proc 
uncertainty ai san francisco 
morgan kaufmann publishers 
hsc eric horvitz jacques suermondt gregory cooper 
bounded conditioning flexible inference decisions scarce resources 
proceedings fifth conference uncertainty artificial intelligence uai pages windsor ontario 
morgan kaufmann 
jj jaakkola michael jordan 
computing upper lower bounds likelihoods intractable networks 
proc 
uncertainty ai 
jj jaakkola michael jordan 
recursive algorithms approximating probabilities graphical models 
technical report mit computational cognitive science june 
jlo finn jensen steffen lauritzen kristian olesen 
bayesian updating causal probabilistic networks local computations 
siam journal computing 
kjaerulff 
reduction computational complexity bayesian networks removal weak dependences 
lopez de mantaras poole editors uncertainty artificial intelligence proceedings tenth conference seattle wa 
kks henry kautz michael kearns bart selman 
reasoning characteristic models 
aaai pages 
koller levy pfeffer 
classic tractable probabilistic description logic 
proceedings th national conference artificial intelligence aaai providence rhode island august 
kp koller pfeffer 
learning probabilities noisy order rules 
proceedings th international joint conference artificial intelligence ijcai nagoya japan august 
kr roni khardon dan roth 
reasoning models 
aaai pages 
ks henry kautz bart selman 
pushing envelope planning propositional logic stochastic search 
proceedings aaai pages menlo park august 
aaai press mit press 
lb hector levesque ron brachman 
fundamental tradeoff knowledge representation reasoning 
ron brachman hector levesque editors readings knowledge representation pages los altos ca 
morgan kaufmann publishers ld li bruce ambrosio 
efficient inference bayes nets combinatorial optimization problem 
international journal approximate reasoning 
lev hector levesque 
foundations functional approach knowledge representation 
artificial intelligence 
ls lauritzen spiegelhalter 
local computations probabilities graphical structures application expert systems discussion 
journal royal statistical society series 
reprinted sp 
ls prakash shenoy 
comparison lauritzen spiegelhalter hugin shenoy shafer architectures computing marginals probability distributions 
proc 
uncertainty ai san francisco 
morgan kaufmann publishers 
lw 
liu wellman 
state space abstraction anytime evaluation bayesian network 
sigart bulletin 
mca david mcallester 
knowledge representation system mathematics 
mit press cambridge massachusetts 
mcc john mccarthy 
epistemological problems artificial intelligence 
proceedings fifth international joint conference artificial intelligence ijcai cambridge massachusetts august 

mcc john mccarthy 
circumscription form non monotonic reasoning 
artificial intelligence april 
mit tom mitchell 
machine learning 
mcgraw hill 
thomas mitchell richard keller kedar 
example generalization unifying view 
machine learning 
mt marek truszczy nski 
relating autoepistemic default logics 
hector levesque ronald brachman raymond reiter editors proceedings st international conference principles knowledge representation reasoning pages toronto canada may 
morgan kaufmann 
mw william mccune larry wos 
otter cade competition incarnations 
journal automated reasoning april 
mw wilkins 
abstraction aggregation belief networks 
aaai workshop abstractions decisions uncertainty 
nh ngo haddawy 
probabilistic logic programming bayesian networks 
lecture notes computer science 
nil nils nilsson 
probabilistic logic 
artificial intelligence february 
pd malcolm pradhan paul dagum 
optimal monte carlo estimation belief network inference 
eric horvitz finn jensen editors proceedings th conference uncertainty artificial intelligence uai pages san francisco august 
morgan kaufmann publishers 
pea judea pearl 
probabilistic reasoning intelligent systems networks plausible inference 
morgan kaufmann san mateo 
pel pelletier 
thinker 
jorg siekmann editor proceedings th international conference automated deduction volume lncs pages oxford uk july 
springer 
pga david poole randy goebel aleliunas 
theorist logical reasoning system default diagnosis 
cercone mccalla editors knowledge frontier essays representation knowledge pages new york 
springer verlag 
pmg david poole alan mackworth randy goebel 
computational intelligence logical approach 
oxford 
poo poole 
probabilistic horn abduction bayesian networks 
artificial intelligence 
poo david poole 
average case analysis search algorithm estimating prior probabilities bayesian networks extreme probabilities 
proceedings ijcai pages france august 
malcolm pradhan gregory provan middleton max henrion 
knowledge engineering large belief networks 
ramon lopez de mantaras david poole editors proceedings th conference uncertainty artificial intelligence pages san francisco ca usa july 
morgan kaufmann publishers 
rei raymond reiter 
deductive question answering relational data bases 
herv gallaire jack minker editors logic data bases pages 
plenum press new york 
rei raymond reiter 
closed world data bases 
herv gallaire jack minker editors logic data bases pages 
plenum press new york 
rei raymond reiter 
equality domain closure order databases 
journal association computing machinery april 
rei raymond reiter 
nonmonotonic reasoning 
annual review computing sciences volume pages 
annual reviews incorporated palo alto 
rn stuart russell peter norvig 
artificial intelligence modern approach 
prentice hall 
rob robinson 
machine oriented logic resolution principles 
jacm 
rot roth 
hardness approximate reasoning 
artificial intelligence journal april 
rud piotr rudnicki 
overview mizar project 
notes talk workshop types proofs programs june 
sac sacerdoti 
planning hierarchy abstraction spaces 
ijcai 
sc suermondt cooper 
initialization method conditioning bayesian belief networks research note 
artificial intelligence june 
scg carlisle scott jan clayton elizabeth gibson 
practical guide knowledge acquisition 
addison wesley pub reading ma 
sg david smith michael genesereth 
ordering conjunctive queries 
artificial intelligence may 
sg swami gupta 
optimization large join queries 
sigmod record acm special interest group management data september 
smith genesereth ginsberg 
controlling recursive inference 
artificial intelligence 
sin singh 
learning belief networks 
phd thesis department computer science university pennsylvania 
sk bart selman henry kautz 
knowledge compilation theory approximation 
journal acm 
slm bart selman hector levesque david mitchell 
new method solving hard satisfiability problems 
proceedings twelfth national conference artificial intelligence pages san jose july 
sm sumit sarkar murthy 
constructing efficient belief network structures expert provided information 
ieee transactions knowledge data engineering february 
sp glenn shafer judea pearl editors 
readings uncertain reasoning 
morgan kaufmann publishers los altos ca 
sri srinivas 
probabilistic hierarchical model diagnosis 
technical report research report 
ksl knowledge systems laboratory stanford university february 
tg richard michael genesereth 
choosing orders rules 
journal automated reasoning december 
ts towell shavlik 
extracting refined rules knowledge neural networks 
machine learning 
val leslie valiant 
complexity enumeration reliability problems 
siam journal computing 
rick van der lans 
sql standard complete 
prentice hall englewood cliffs nj 
translated andrea gray 
van 
approximating bayesian belief networks arc removal 
ieee pami august 
daniel weld johan de kleer editors 
readings qualitative reasoning physical systems 
morgan kaufmann publishers los altos ca 
wel michael wellman 
fundamental concepts qualitative probablistic networks 
artificial intelligence 
wel michael wellman 
abstraction probabilistic reasoning 
technical report university michigan 
tutorial prepared summer institute probability ai corvallis july 
see ai eecs umich edu people wellman tut abstraction html 
shlomo zilberstein 
operational rationality compilation anytime algorithms 
technical report csd university california berkeley 
shlomo zilberstein 
resource bounded reasoning intelligent systems 
acm computing surveys es december 
zp zhang poole 
simple approach bayesian network computations 
proc 
th canadian conference artificial intelligence banff alberta canada may 
