combining fuzzy information multiple systems ronald fagin ibm almaden research center harry road san jose california email fagin almaden ibm com url www almaden ibm com cs people fagin traditional database system result query set values values satisfy query 
data servers system queries image content text retrieval systems result query sorted list 
example case system queries image content query ask objects particular shade red result query sorted list objects database sorted color object matches query 
multimedia system synthesize types queries result set result sorted list consistent manner 
discuss solution adopted garlic multimedia information system developed ibm almaden research center 
solution graded fuzzy sets 
issues efficient query evaluation multimedia system different traditional database system 
multimedia system receives answers subqueries various subsystems accessed limited ways 
important class queries conjunctions atomic queries atomic query evaluated different subsystem naive algorithm retrieve number elements linear database size 
contrast algorithm implemented garlic conjuncts independent arbitrarily high probability total number elements retrieved evaluating query sublinear database size case conjuncts order square root database size 
shown queries algorithm optimal 
matching upper lower bounds robust sense hold reasonable rule including standard min rule fuzzy logic evaluating conjunction 
find query provably hard sense naive linear algorithm essentially optimal 
appear special issue computer system sciences selected papers symposium principles database systems 
extended appears proc 
fifteenth acm symp 
principles database systems montreal pp 

garlic chs multimedia information system developed ibm almaden research center 
designed capable integrating data resides different database systems variety data servers 
single garlic query access data number different subsystems 
example nontraditional subsystem garlic access qbic nbe query image content 
qbic search images various visual characteristics color texture 
discuss semantics garlic queries 
semantics resolves mismatch occurs result qbic query sorted list items match query best result relational database query set 
semantics uses graded fuzzy sets za 
issues efficient query evaluation system different traditional database system 
step dealing fascinating new issues optimal algorithm evaluating important class garlic queries 
algorithm implemented garlic 
section discuss problem mismatch semantics detail give simple solution 
section consider various operators literature conjunction disjunction focus properties interest conjunction monotonicity strictness 
section algorithm variations evaluating conjunction atomic queries 
section define performance cost algorithms prove performance cost algorithm small particular sublinear natural assumptions 
upper bound depends conjunction monotone 
section prove lower bound implies cost algorithm optimal constant factor 
lower bound depends conjunction strict 
section lower bound machinery prove certain query hard sense algorithm query retrieve linear number objects database 
section discuss subsystem interest different semantics garlic semantics 
section discuss additional assumptions lead efficient algorithms 
section consider related 
section give 
semantics response query qbic returns sorted list top say items database match query best 
example query asks red objects result sorted list object object second qbic trademark ibm 
christoph implementation different version garlic 
contrast result query relational database simply set 
leads mismatch result queries sorted list queries set 
combine queries boolean combinations 
example consider application store sells compact disks 
typical traditional database query ask names albums artist beatles 
result set names albums 
multimedia query ask album covers particular shade red 
result sorted list album covers 
see mismatch example query artist beatles gives set query red gives sorted list 
combine traditional database query multimedia query 
example consider query artist beatles red 
result query 
case probably want sorted list contains albums beatles list sorted goodness match color 
complicated queries 
example result replaced previous query 
answer set sorted list combination 
combine multimedia queries 
example query color red shape round 
solution terms graded sets 
graded set set pairs object tuple grade real number interval 
convenient think graded set corresponding sorted list objects sorted grades 
graded set generalization set sorted list 
graded set semantics applicable generally shall certain simplifying assumptions rest 
discussion statement results easier 
furthermore simplifying assumptions enable avoid messy implementation specific details object oriented system versus relational database system choice query language 
easy see semantics robust depend assumptions 
hand results view step depend assumptions 
assume data subsystems considering accessed garlic deal attributes specific set objects fixed course relational database result query may sorted way convenience presentation sorting department members salary logically speaking result simply set defined collection members 
writing query form red simplicity 
reality expressed selecting color color wheel selecting image predominantly red asking images colors close image systems qbic sophisticated color matching algorithms io nbe sc compute closeness colors images 
example image contains lot red little green considered moderately close color image lot pink green 
type 
running example involving compact disks considering query query artist beatles query red deals attributes compact disks 
examples take atomic queries form name attribute target 
queries boolean combinations atomic queries 
atomic query grade assigned object 
grade represents extent object fulfills atomic query larger grade better match 
particular grade represents perfect match 
traditional database queries artist beatles grade object means query false object means query true object 
queries qbic query corresponding red grades may intermediate values 
question assign grades query necessarily atomic possibly boolean combination atomic queries 
consider issue section 
dealing boolean combinations number different rules evaluating boolean combinations atomic formulas fuzzy logic appeared literature 
particular number reasonable aggregation functions assign grade fuzzy conjunction function grades assigned conjuncts 
section aggregation functions 
section zimmermann textbook zi 
introduce notion strictness literature probably 
interested notion strictness known notion monotonicity possibly aggregation functions literature intended deal conjunction monotone strict properties sufficient sake theorems 
particular theorems apply large class possible choices aggregation functions fuzzy conjunction 
consider standard rules fuzzy logic defined zadeh za 
object query denote grade query assume defined atomic query object possible extend queries boolean combination atomic queries rules 
conjunction rule ab minf disjunction rule ab maxf negation rule gamma standard conjunction rule fuzzy logic min aggregation function 
rules attractive reasons 
conservative extension standard propositional semantics 
restrict attention situations atomic query rules reduce standard rules propositional logic 
second reason due important theorem bellman bg extended simplified yager ya vg dubois prade dp wimmers wi 
discuss bellman theorem 
standard conjunction disjunction rules fuzzy logic nice property logically equivalent queries involving conjunction disjunction negation object example aa 
example bc ab ac 
desirable optimizer replace query logically equivalent query guaranteed getting answer 
furthermore aggregation function min conjunction monotone sense ab ab 
similarly aggregation function max disjunction monotone 
monotonicity certainly reasonable property demand models user intuition 
intuitively grade object query big object grade object query big object grade object query big object theorem due yager ya dubois prade dp variation bellman theorem says min max unique aggregation functions conjunction disjunction properties 
bellman original theorem required assumptions 
theorem unique aggregation functions evaluating preserve logical equivalence queries involving conjunction disjunction monotone arguments min max 
mention possible aggregation functions evaluating conjunction disjunction appeared literature introduce notation 
define ary aggregation function function 
sake generality consider ary aggregation functions evaluating conjunctions atomic queries practice ary conjunction evaluated associative ary function iterated 
define ary query conjunction formulas terms ary aggregation function 
semantics ary query am defining example standard fuzzy logic semantics conjunction am defining am minf am object ary aggregation function 
define ary query am am example min am equivalent standard fuzzy semantics am max am equivalent standard fuzzy semantics am consider important class ary aggregation functions 
triangular norm ss dp ary aggregation function satisfies properties conservation monotonicity commutativity 
associativity 
reasonable expect aggregation function conjunction satisfy properties triangular norm 
call condition conservation implies particular conservative extension standard propositional semantics conjunction discussed case min 
triangular norm dp ary aggregation function satisfies properties conservation monotonicity commutativity 
associativity 
reasonable expect aggregation function disjunction satisfy properties triangular norm 
triangular norms triangular norms duals sense triangular norm function defined gamma gamma gamma triangular norm 
decker bd show suitable negation aggregation functions standard gamma natural generalization laws hold triangular norm norm examples triangular norms corresponding norms bd mi minimum maximum maxfx drastic product maxfx drastic sum max fx bounded difference maxf gamma bounded sum minf einstein product delta gamma gamma delta einstein sum delta algebraic product delta algebraic sum gamma delta product delta gamma delta sum gamma delta gamma delta mentioned earlier ary conjunction course obtained ary conjunction iterating 
example ary conjunction defined ary aggregation function ary conjunction defined 
properties hold ary aggregation function obtained iterating triangular norm monotonicity xm strictness xm iff aggregation function strict takes maximal value precisely argument takes maximal value 
strictness follows fact dp triangular norm bounded drastic product min 
call am monotone resp strict query monotone resp strict 
properties query required theorems hold monotonicity strictness 
need monotonicity upper bound efficiency algorithms evaluating queries certain assumptions strictness lower bound 
note aggregation functions conjunction considered literature triangular norms 
example zimmermann various weighted unweighted arithmetic geometric means perform empirically quite 
aggregation functions triangular norms fact arithmetic mean conserve standard propositional semantics arguments takes value 
functions satisfy monotonicity strictness upper lower bounds hold case 
system say arithmetic mean aggregation function evaluating conjunction lower upper bounds tell efficiently expect evaluate conjunction natural assumptions 
discuss examples algorithms section 
algorithms query evaluation vital issue database management system efficiency processing queries 
section give algorithm evaluating monotone queries 
show certain assumptions algorithm optimally efficient constant factor 
probably important queries conjunctions atomic queries 
sake current discussion assume conjunctions evaluated standard min rule 
example conjunction atomic queries query artist beatles red discussed running example 
example conjunct artist beatles traditional database query second conjunct red addressed subsystem qbic 
different subsystems case relational database management system deal conjunct qbic deal second conjunct involved answering query 
garlic piece information subsystems order answer query 
reasonable assumption objects satisfy conjunct artist beatles way evaluate query determine objects satisfy conjunct call set objects obtain grades qbic random access second conjunct objects obtain grade objects full query 
artist beatles grade object minimum grade 
artist beatles grade object grade obtained qbic evaluating second conjunct minimum grade 
note expect result full query graded set objects grade nonzero artist beatles objects artist beatles album cover closest red highest grades 
consider challenging example conjunction atomic queries conjunct nontraditional 
example query color red shape round 
sake example assume subsystem deals completely different subsystem deals shapes 
denote subquery color red denote subquery shape round grade object query minimum grade subquery subsystem grade subquery second subsystem 
garlic combine results different subsystems 
assume interested obtaining top answers 
means want obtain objects may refer top objects highest grades query grades 
ties want arbitrarily obtain objects grades objects objects query obvious naive algorithm 
subsystem dealing color output explicitly graded set consisting pairs object 
subsystem dealing shape output explicitly graded set consisting pairs object 
information compute minf object objects top grades output object grade 
better 
face clear efficiently obtain desired answers efficient means 
assuming qbic random accesses fact 
return issue shortly 
assume interface garlic subsystem qbic 
response subquery color red assume subsystem output graded set consisting objects grades subquery sorted order grade garlic tells subsystem 
garlic tell subsystem resume outputting graded set left 
alternatively garlic ask subsystem say top objects sorted order grades request refer types access sorted access 
way expect garlic interact subsystem 
garlic ask subsystem grade respect query object 
refer random access 
shortly shall give algorithm evaluates conjunctions atomic queries returns top answers 
fact algorithm applies monotone query 
note case max certainly monotone standard fuzzy disjunction defined terms efficient algorithm shall discuss section 
discussed fw algorithm applies user weight relative importance conjuncts example user decides color twice important shape weighted conjunctions monotone 
give proposition key algorithm correct 
say set objects upwards closed respect query objects upwards closed respect object grade strictly greater member proposition assume upwards closed respect query assume am monotone query objects 
proof ease notation write am case monotonicity am am contradicts assumption 
upwards closed respect follows desired 
give algorithm called algorithm returns top answers monotone query am denote assume objects top answers sense 
assume subsystem evaluates subquery algorithm proposition 
idea subsystem generate set upwards closed respect contains objects 
follows show proposition objects highest grades algorithm consists phases sorted access random access computation 
algorithm somewhat informally 
sorted access phase give subsystem query sorted access 
subsystem begins output sorted order grade graded set consisting pairs object grade query wait matches wait set objects subsystem output members random access phase object seen random access subsystem find 
computation phase compute grade am object seen 
set containing objects seen highest grades ties broken arbitrarily 
output graded set describe sorted access phase random access phase little formally introduce notation useful 
sorted access phase denote graded set consisting pairs output subsystem fx projection component 
consists objects output subsystem sorted access phase wait matches find contains members 
random access phase say object seen mean random access phase object random access subsystem find 
course determined random access needed object subsystem prove correctness algorithm 
theorem monotone query algorithm correctly returns top answers 
proof monotone query 
total number objects contains objects contains objects 
assumption contains objects 
defined sorted access phase algorithm contains objects 
definition members 
definition top answers need show arbitrary object 
assume shall derive contradiction 
subset members consists members highest grades follows 

clearly upwards closed respect follows proposition follows definition contradiction 
note algorithm nice feature finding top answers order find best answers continue left 
various minor improvements algorithm improve performance slightly 
performance algorithm formally defined section 
example uniform value find contains members 
replace occurrences algorithm lead fewer random accesses 
ait kassel ak give improvement 
particular aggregation functions modify algorithm improve performance 
example consider important special case standard fuzzy conjunction am min 
case give strengthening proposition shall see leads slightly efficient algorithm 
proposition assume upwards closed respect query assume min 
value value minimizes subsystems assume objects 
proof ease notation write am min fact says minf am minf am definition follows minf am 
minf am 
upwards closed follows desired 
proposition give efficient algorithm algorithm min 
idea follows 
denote query am min 
proposition 

intuitively subsystem shown smallest grade sorted access phase algorithm object smallest grade subsystem min rule grade define candidates objects word candidates turn objects need consider top objects 
define algorithm result replacing occurrences algorithm set candidates 
algorithm defined sorted access phase sorted access phase algorithm remaining phases follows random access phase object grade member subsystem 

candidates defined objects candidate random access subsystem find 
computation phase compute grade minf am candidate set containing candidates highest grades ties broken arbitrarily 
output graded set intuitively algorithm better performance random access candidates member theorem shows algorithm gives correct answer min 
theorem case standard fuzzy conjunction aggregation function min algorithm correctly returns top answers 
proof standard fuzzy conjunction am proof exactly proof theorem applying proposition conclude apply proposition conclude stronger fact certain monotone aggregation functions define algorithm performs substantially better algorithm algorithm performs better algorithm constant factor 
obvious example constant function arbitrary set objects grades taken top answers 
consider interesting important example max corresponds standard fuzzy disjunction am example consider limitations lower bound results 
give algorithm called algorithm returns top answers standard fuzzy disjunction am atomic queries am algorithm phases sorted access phase computation phase 
sorted access phase sorted access subsystem find set containing top answers query computation phase max set containing members highest values ties broken arbitrarily 
output graded set theorem straightforward 
theorem case standard fuzzy disjunction aggregation function max algorithm correctly returns top answers 
shall discuss particular define performance cost algorithm substantially better performance algorithm performance cost section consider performance cost algorithms evaluating queries 
particular focus cost algorithm aggregation function monotone 
measure cost corresponds intuitively cost middleware system garlic processing information passed database subsystem qbic 
sorted access cost total number objects obtained database sorted access 
example lists corresponding case conjunction query conjuncts algorithm requests altogether top objects list top objects second list sorted access cost algorithm 
similarly random access cost total number objects obtained database random access 
sorted access cost random access cost 
take middleware cost positive constants fact may different reflects fact cost middleware system sorted access random access may different 
find convenient sum sorted access cost random access cost 
total number elements retrieved middleware system 
may refer unweighted middleware cost corresponds 
middleware cost unweighted middleware cost constant multiples maxfc delta minfc delta note middleware cost defined probably reflection total system cost accurately account costs inside black box qbic 
situations case query optimizer want comprehensive cost measure 
finding cost measures interesting open problem 
believe algorithm sufficiently robust may turn optimal comprehensive cost measures 
earlier version took unweighted middleware cost middleware cost measure cost referred database access cost 
probabilistic statements performance cost algorithms need define probabilistic model 
number objects database 
shall prove atomic queries am independent arbitrarily high probability cost algorithm evaluating am gamma sublinear contrast naive algorithm described near section linear 
particular exactly atomic queries cost algorithm order square root database size 
define terms statements precise 
consider formal framework 
assume database contains objects ease notation call considering scenario involving atomic queries am database 
purposes convenient focus graded sets associated atomic query 
define scoring database function associating graded set objects graded intuitively ith graded set scoring database graded set corresponding result applying atomic query original database 
may speak random access resp sorted access ith graded set scoring database corresponds random access resp sorted access original database atomic query define skeleton objects function associating permutation scoring database consistent skeleton ith permutation gives sorting ith graded set descending order grade 
scoring database consistent skeleton ties distinct objects grade ith graded set 
interested middleware cost algorithms find top answers am 
simplicity shall consider algorithms run scoring database opposed run original database scoring database captures relevant 
algorithms allowed sorted access random access scoring database 
ties sorted access cost depend skeleton course algorithm 
objects grade list possible appears sorted access list algorithm scoring database skeleton consistent define sorted access cost algorithm applied scoring database provided sorted access goes skeleton define maximum scoring databases consistent sorted access cost algorithm skeleton worst case sorted access cost algorithm scoring databases consistent skeleton 
similarly define cost cost corresponding middleware cost algorithm behave differently databases skeleton action algorithm depend specific grades sees 
example algorithm take special action sees grade 
corresponding unweighted middleware cost sum sorted access cost random access cost 
note follows maxfc delta cost minfc delta note scoring database consistent skeleton specification algorithm says gives top answers input matter skeletons algorithm sees matter skeleton algorithm run conceivably middleware cost different different skeletons 
answers different ties case top answers possibilities 
explain formalize meaning statement atomic queries independent arbitrarily high probability middleware cost algorithm gamma 
database size number lists finite number possible skeletons mn algorithm skeleton middleware cost cost defined 
say atomic queries independent consider probabilities middleware costs mean skeleton equal probability 
equivalent assumption sorted lists atomic query contains objects random order words permutation equal probability independent lists 
say algorithm arbitrarily high probability middleware cost gamma mean ffl constant pr cost cn gamma ffl write pr delta clear probability taken possible skeletons prove theorem cost algorithm need lemma 
lemma say random set members ng mean subsets ng cardinality selected equal probability 
state prove lemma explain 
sorted access phase algorithm sorted access subsystem takes place matches sorted access phase continues subsystem output values sorted access property contains members 
analysis interested determining function 
expected size 
probability size smaller expected size particular 
compute quantities inductive fashion determining expected size probability size half expected size 
order carry induction know function expected size intersection members ng randomly selected members ng probability size intersection half expected size 
lemma assumption big lemma convenience simply assume 
denote size jbj 
lemma set members ng random set members ng 
expected size assume 
pr jbj gammam proof fb random variable value expected value pr bm 
order estimate probability size define probabilistic processes involving flipping coins 
show 
pr jbj pr heads process 
pr heads process pr heads process 
pr heads process pr heads process 
pr heads process pr heads process 
pr heads process gammam clear statements taken imply pr jbj gammam desired 
define probabilistic processes 
process coins flipped 
probability coin heads assuming inductively far heads tails probability coin heads max gamma gamma gamma 
process coins flipped 
probability coin heads assuming inductively far heads tails probability coin heads maxf gamma gamma gamma gamma gamma note situation process need include set take max gamma gamma 
process coins flipped 
flip probability coin heads gamma gamma 
process coins flipped 
flip probability coin heads proof calculate pr jbj considering members probability jth member gamma members happens members maxf gamma gamma gamma 
think event jth member member corresponding jth coin process coming heads 
straightforward see pr jbj pr heads process pr heads process proof show gamma gamma gamma gamma 
assume numerator equal denominator gamma gamma subtract nonnegative number case gamma numerator denominator value fraction increase numerator decreases big percentage denominator 
gamma gamma gamma gamma furthermore gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma probability maxf gamma gamma gamma process equals probability maxf gamma gamma gamma gamma gamma process 
follows write combinatorial sum process sum probabilities possible ways number heads get answer corresponding combinatorial sum process 
pr heads process pr heads process desired 
proof follows immediately fact probability maxf gamma gamma gamma gamma gamma process greater equal probability gamma gamma process 
proof need show probability gamma gamma process big probability process 
bm 
gamma gamma gamma desired 
proof estimate pr heads process chernoff bound 
results av see hr probability heads flips coin probability gamma ffl heads expected number heads gammaffl expected number heads interested probability bm heads 
big ffl gamma ffl shown ffl gamma gamma gamma chernoff bound gammaffl gamma gammam desired 
ready state prove theorem performance cost algorithm sake making explicit dependence cost algorithm obtaining top answers thinking function number objects database suspect users interested case small constant 
note middleware cost gamma sublinear particular constant case interest 
note constant corresponds atomic queries middleware cost 
comments order extreme case dealt specially lower bound proofs section 
case certainly know priori top objects objects highest grades simply set objects 
find grades objects required specification finding top answers clearly necessary general access entry database 
note extreme case middleware cost gamma claimed theorem simply expect 
theorem determine middleware cost algorithm theorem need assume am monotone 
monotonicity arises correctness performance algorithm guaranteed correct am monotone theorem 
theorem assume atomic queries independent 
middleware cost algorithm gamma arbitrarily high probability 
proof comments need prove theorem model sorted lists contains objects random order independent lists 
assumption 
middleware cost bounded constant times unweighted middleware cost inequality need prove statement theorem replace middleware cost unweighted middleware cost 
constant gamma cases depending 
assume 
algorithm certainly unweighted middleware cost mn object accessed times list 
follows probability unweighted middleware cost mn mt cn gamma cn gamma sufficiently large 
rest proof assume 
show sufficient show pr converges goes infinity 
need show implies pr 
cm gamma goes goes infinity 
bounded pr 
cm gamma unweighted middleware cost times sorted access cost 
furthermore bounded pr mt follows fairly straightforwardly fact ff ff 
bounded pr sorted access cost greater mt sorted access cost greater lists implies sufficient show pr converges goes infinity 
define cn gammaj particular dd dd members 
furthermore dm ck 
event show induction pr gammad base case immediate probability dd 
inductive step assume holds 
denote size assumption 
lemma pr gammam gamma evaluate pr 
fact cn gamma gamma event holds gamma event 
subset event probability gammam implies follows pr gammam gammad pr pr pr pr pr gammad inequality follows 
completes inductive step fact shows inequality strict 
follows pr dm ck gammad see pr gammad sufficiently large probability right hand side arbitrarily small 
precisely ffl probability ffl 
pr converges goes infinity 
previous proof see probability cn gamma objects accessed sorted access list gammad easy see terms term negligible moderate sized involvement exponent earlier terms 
dominant term note wimmers wi done refined analysis case exactly atomic queries obtained improved upper bound probability nk objects accessed sorted access list 
improved upper bound dominant term gammac wimmers upper bound theta gamma theta gamma 
probability theta gamma nk objects accessed sorted access list theta gamma nk objects accessed sorted access list 
theorems immediately obtain theorem 
theorem algorithm finding top answers monotone query am am independent middleware cost gamma arbitrarily high probability 
monotone queries important class 
example natural notion conjunction monotone 
theorem guarantees efficient algorithm monotone queries atomic queries independent 
lower bounds theorem gives upper bound gamma monotone queries 
section give matching lower bound omega gamma gamma strict queries 
show case strict queries correct algorithm finds top answers better 
results say algorithm pr cost minfc gamma definition middleware cost 
function gamma atomic queries independent arbitrarily high probability middleware cost algorithm 
middleware cost gamma algorithm optimal 
prove lower bound omega gamma gamma need assume aggregation function strict 
note max strict 
fact case max lower bound fails 
algorithm theorem middleware cost mk independent size database 
aggregation function strict median 
lower bound fails case 
example assume wish consider query evaluates median object give algorithm finds top answers query 
algorithm fact leave reader verify median gg describe algorithm informally follows 

find top answers query evaluates minf object algorithm set containing objects highest scores 

find top answers query evaluates minf object algorithm set containing objects highest scores 

find top answers query evaluates minf object algorithm set containing objects highest scores 

output objects highest median scores scores 
hard see implies correctness algorithm 
algorithm middleware cost nk arbitrarily high probability lower bound fails 
interesting example aggregation function strict aggregation function arises real life occurs assigning scores artistic 
number judges assigns score top bottom scores eliminated remaining scores averaged 
corresponding aggregation function strict 
judges aggregation function simply median lower bound fails 
lemma proof lower bounds says strict extreme situation unweighted middleware cost number objects database sorted access cost closely related size intersection top objects list 
defined aggregation functions range 
scoring actual case perfect score 
complete discussion scoring rules currently available www usa org scoring artistic html 
lemma assume strict 
skeleton objects arbitrary algorithm finds top answers am 
assume 
denote top objects list skeleton contains members 
proof case special case discussed 
case unweighted middleware cost mn hypothesis fails 
assume assume contains members shall derive contradiction 
specifically shall construct skeleton scoring database consistent algorithm run scoring database sees skeleton gives wrong answer 
define scoring database consistent skeleton follows list grades list members grades list remaining members list 
say grade object list determined grade list obtained algorithm applied scoring database sorted access goes skeleton say grade object list undetermined 
say untouched grade object list undetermined list intuitively untouched algorithm determine information grades 
assumption object untouched 
define scoring database scoring database grade list 
strict members grade query am objects grade 
assumption contains members necessarily top objects scoring database query 
skeleton consistent top objects list skeleton top objects list skeleton th member list 
correctness algorithm give top answers run scoring database algorithm sees skeleton particular give grade top objects 
algorithm run scoring database algorithm sees skeleton algorithm see exactly information run scoring database sees skeleton case know grade top answers algorithm see grades list 
true algorithm run scoring database sees skeleton contradiction 
help show subtleties involved lemma note contrast lemma possible opposed contains members 
lemma tells consistent sg consistent sg contains members 
possible specific scoring database consistent skeleton contains members 
fact happen min 
example assume top object list grade list 
single sorted access list tells object grade greater random access lists tells grade 
determined top answer sorted access list tells object list grade know unique top object requiring information 
situation guaranteed top object single sorted access add small number random accesses 
happen empty fairly large prove lower bound says intuitively correct algorithm middleware cost constant times algorithm theorem 
assume strict 
arbitrary algorithm finds top answers am 
definition middleware cost 
am independent pr cost minfc gamma 
proof follows second inequality section cost minfc gamma gamma sufficient show pr gamma assume result trivial 
case special case discussed 
case unweighted middleware cost mn gamma pr gamma assume gamma lemma know contains members 
particular contains members 
follows pr pr estimate probability right hand side 
argument similar lemma expected size gamma gamma follows easily gamma expected size pr follows pr desired 
theorem puts results obtain matching upper lower bound 
says monotone strict middleware cost finding top answers am am independent theta gamma arbitrarily high probability 
usual theta means matching lower upper bound constant factor 
case means 
algorithm finding top answers am ffl constant pr cost cn gamma ffl 
algorithm finding top answers am ffl constant pr cost dn gamma ffl theorem middleware cost finding top answers monotone strict query am am independent theta gamma arbitrarily high probability 
proof follows straightforward way theorems 
intuitively theorem tells matching upper lower bounds natural notions conjunction triangular norms 
close section giving variation theorem focuses sorted access cost 
theorem shows sorted access cost algorithm essentially optimal 
result restriction random access cost naive algorithm mentioned section implemented sorted access cost accessing object random access subsystem 
theorem 
assume strict 
arbitrary algorithm finds top answers am unweighted middleware cost database objects 
am independent pr gamma 
proof follows small variation proof theorem 
assume monotone strict 
theorem tells algorithms extremely large random access cost linear number objects database correct algorithm sorted access cost constant times algorithm interesting consider similar result holds random access cost 
show algorithm essentially optimal sorted access cost random access cost 
stronger result algorithm optimal arbitrary positive linear combination costs obtain theorem 
provably hard query algorithm evaluating conjunction atomic queries efficient conjuncts independent 
conjuncts independent 
see algorithm upper bound lower bound machinery particular lemma order obtain top answers necessary retrieve roughly objects database value contains members 
conjuncts positively correlated help efficiency 
conjuncts negatively correlated 
section consider extreme case negative correlation queries considering queries atomic query 
standard propositional logic query unsatisfiable 
situation different fully fuzzy take value just 
consider standard fuzzy semantics conjunction evaluated min negation evaluated letting gamma 

furthermore easy see maximal possible value convenience restrict attention section scoring databases distinct objects 
way ties 
particular query restrict attention skeletons consisting permutation subquery reverse permutation gamma subquery top object permutation bottom object permutation show middleware cost finding top answer theta 
case probabilities involved means 
algorithm finding top answer constant skeleton cost cn 
algorithm finding top answer constant skeleton cost dn theorem middleware cost finding top answer standard fuzzy conjunction fully fuzzy theta 
proof upper bound follows naive algorithm described near section linear 
lower bound follows second inequality section sufficient show correct algorithm skeleton number objects 
assume shall derive contradiction 
follow general outline proof lemma changes 
proof lemma goal construct scoring database algorithm run scoring database gives wrong answer 
define scoring database consistent skeleton follows grades bn objects permutation skeleton earlier notation grades members bn distinct strictly greater grades remaining objects distinct strictly 
proof lemma define means object untouched means intuitively algorithm see grades 
assumption object untouched 
define scoring database scoring database grade lists corresponds situation 
follows course running algorithm database information seen inconsistent having grade 
algorithm correct algorithm determine grade top object query database object top grade 
algorithm run scoring database algorithm see exactly information run scoring database case know grade top answer algorithm see grade 
true algorithm run scoring database contradiction 
theorem gives provably hard query query requires linear middleware cost cost incurred naive algorithm evaluating query 
subsystems different semantics garlic top various subsystems may control semantics subsystems 
may lead confusion 
example garlic asked evaluate query subsystem say qbic responsible evaluating assume case currently qbic different semantics conjunction garlic 
simply ask qbic evaluate conjunction get different results garlic asks qbic separately evaluate answers combined garlic rules 
natural way account issue define flavors conjunction call internal conjunction external conjunction 
fact flavor internal conjunction subsystem 
user request internal conjunction sake efficiency 
user requests external conjunction external conjunction involve calls subsystem 
exploiting information discussed algorithm works evaluating monotone query am atomic queries am independent 
additional assumptions algorithm may perform better 
example due jeff ullman personal communication 
assume evaluating standard fuzzy conjunction min 
give algorithm finds top answer easy see modify algorithm obtain top answers 
inconsistency arise sorted access consecutive objects seen grade greater grade object grade 
idea suggested ed wimmers 

give subsystem query sorted access 
subsystem begins output sorted order grade graded set consisting pairs 

pair output subsystem random access subsystem obtain 

object object continue objects seen 

objects seen object highest grade minf output 
correctness easy verify straightforward see object seen grade greater assume atomic queries independent grades objects query uniformly distributed maximum value grades objects query say 
expected time objects seen independent number objects database 
case middleware cost constant 
assumption grades objects query bounded constant fairly strong 
interesting consider performance ullman algorithm assumptions atomic queries independent grades objects queries uniformly distributed 
assume trying find top answer 
ariel landau personal communication shown case expected time middleware cost theta 
case performance better algorithm middleware cost sole assumption atomic queries independent theta 
clearly assumptions lead consider algorithms 
important problem find natural assumptions lead efficient algorithms cases interest 
related chaudhuri gravano cg consider ways simulate algorithm filter conditions say example color score 
wimmers haas roth carry detailed studies performance algorithm consider implementation issues see author fa discussion 
semantics garlic allows combine information different subsystems natural way 
furthermore algorithm works efficiently probably important class queries proven performance cost optimal 
upper bound lower bound quite robust hold reasonable rule evaluating conjunction 
acknowledgments author grateful laura haas petkovic suggesting problem helpful discussions 
author grateful eli upfal valuable suggestions laura haas ed wimmers detailed comments preliminary version 
author moshe vardi suggesting term middleware cost 
family connectives fuzzy sets fuzzy sets systems pp 

av angluin valiant fast probabilistic algorithms hamiltonian circuits matchings comput 
system sci 
pp 

ak ait kassel improved algorithm retrieving fuzzy information systems information processing letters appear 
bd bonissone decker selecting uncertainty calculi granularity experiment trading precision complexity uncertainty artificial intelligence kanal lemmer eds amsterdam bg bellman analytic formalism theory fuzzy sets information sciences pp 

chs carey haas schwarz arya cody fagin flickner niblack petkovic thomas williams wimmers heterogeneous multimedia information systems garlic approach ride dom th int workshop research issues data engineering distributed object management pp 

cg chaudhuri gravano optimizing queries multimedia repositories proc 
acm sigmod conference pp 

cody haas niblack arya carey fagin flickner lee petkovic schwarz thomas roth williams wimmers querying multimedia data multiple repositories content garlic project ifip rd working conference visual database systems 
dp dubois prade fuzzy sets systems theory applications academic press new york 
dp dubois prade criteria aggregation ranking alternatives framework fuzzy set theory fuzzy sets decision analysis 
zimmermann zadeh gaines eds studies management sciences pp 

dp dubois prade review fuzzy set aggregation connectives information sciences pp 

fa fagin fuzzy queries multimedia database systems proc 
acm symposium principles database systems pp 

fw fagin wimmers incorporating user preferences multimedia queries proc 
th international conference database theory jan springer verlag lecture notes computer science ed 
afrati ph 
kolaitis pp 

full version appears title formula incorporating weights scoring rules www almaden ibm com cs people fagin icdt rj ps hr hagerup ub guided tour chernoff bounds information processing letters pp 

io method defining similarity images basis color information technical report rt ibm tokyo research lab 
mi pictorial representations fuzzy connectives part cases norms averaging operators fuzzy sets systems pp 

nbe niblack barber equitz flickner petkovic yanker qbic project querying images content color texture shape spie conference storage retrieval image video databases volume pp 

qbic web server almaden ibm com 
ss schweizer associative functions semi groups publ 
math 
pp 

sc smith 
chang searching images videos worldwide web technical report center telecommunications research columbia university 
stricker similarity color images spie conference storage retrieval image video databases iii volume pp 


zimmermann suitability minimum product operators intersection fuzzy sets fuzzy sets systems pp 

vg note characterization max min operators information sciences pp 

wi wimmers minimal bellman theorems preparation 
wi wimmers formula getting top elements preparation 
wimmers haas roth fagin algorithm merging ranked results multimedia middleware preparation 
ya yager procedures selecting fuzzy set theoretic operations international journal general systems pp 

za zadeh fuzzy sets information control pp 

zi 
zimmermann fuzzy set theory third edition kluwer academic publishers boston 
