closure alpha conversion randy pollack laboratory foundations computer science university edinburgh king buildings edinburgh eh jz scotland rap dcs ed ac uk consider informal presentation simply typed calculus bar 
leaving details oe range simple types range class term variables range church style terms 
statement form oe subject statement oe predicate 
context ranged gamma list statements variables subjects 
context valid contains distinct variables subjects defined inductively nil valid ffl valid cons valid gamma valid gamma oe valid dom gamma statement oe derivable context gamma notation gamma oe gamma oe produced rules 
var gamma valid gamma oe oe gamma lda gamma oe gamma oe oe app gamma oe gamma oe gamma presentation usually considered formal everyday reasoning 
implemented literally type synthesis algorithm compute type variable look context compute type lambda supported esprit basic research actions logical frameworks types proofs programs british science engineering research council 
version appears types proofs programs international workshop types nijmegen may selected papers lncs 
abstraction compute type body extended context compute type application compute types left right components check match appropriately 
lets algorithm compute type oe failure rule applies dom oe valid oe oe oe 
oe oe 
system fails derive intended type oe oe 
notice oe oe oe derivable system closed subjects 
went wrong 
directly implementing system informal notation literally oe names bound variables meant taken seriously 
rule lda read order type oe choose suitable alpha representative oe 
formal systems variable binding implemented machines basis programming languages proof checkers applications 
clear concrete syntax users enter implementations see printed implementation response formally related implemented formal system 
users implementors need exact concise description system informal explanation 
concrete syntax properties 
users implemented systems construct large formal objects complex binding 
implementation help task naming small example job difficult 
say ml implementation claims fn 
fn 
typed 
approaches naming implementations formal systems 
best known explicit names curry style renaming definition substitution 
technique probably formalized 
difficulty arises ignore distinction terms treat equal 
known solution problems alpha conversion de bruijn nameless variables db 
nameless variables metatheoretic study admit explanation substitution term variable painful presentation carried elegantly alt hue direct nameless variables real possibility pragmatic applications human users find difficult write small expressions nameless variables 
necessary translate named syntax nameless back named syntax pretty printing translation formalized 
know proposals take names seriously avoid need alpha conversion 
proposal coquand coq follows style logic distinguish free variables parameters bound variables variables 
idea formalize large theory pure type systems including reduction conversion typing mp 
formalization distinguish alpha convertible terms typing judgement closed alpha conversion 
proposal martin lof tas goes explicit names explicit substitutions making notion substitution part formal system originally proposed nameless terms accl 
unfortunately system tas current formulation closed alpha conversion fails derive judgement section 
proposal gor formalization mixing nameless terms named variables way named terms equal alpha conversion 
constructive engine constructive engine hue machine type checking calculus constructions 
basis coq dfh lego lp 
interesting aspects 
non deterministic rules underlying type theory converted deterministic syntax directed program 
syntax directed program implements relation equivalent type theory smaller derivations 
external concrete syntax explicit variable names translated internal syntax locally nameless terms local binding de bruijn indexes global binding explicit names 
efficient technique testing conversion locally nameless terms special attention treatment definitions basic ideas second points appeared early writing martin lof 
point studied extensively pol class pure type systems 
second point addressed pol 
fourth point clearly remaining limiting factor pragmatic implementations proof checkers received theoretical attention knowledge hue db suggest interesting ideas 
example metatheory nameless variables inconvenient see discussion thinning lemma mp note focus third item relationship concrete syntax syntax constructive engine 
locally nameless style internal representation terms basic decisions constructive engine reflects huet interest experimenting de bruijn representation ultimate conviction right notation implementing type checker 
want study pros cons representation efficient typechecking muse relationship concrete terms representations types 
plan 
section discuss simply typed lambda calculus 
presenting concrete presentations typing rules derive constructive engine consider variations 
section consider issue pure type systems pts 
new problem case dependent types 
explain constructive engine dependent types show closed alpha conversion terms 
careful knowledgeable referee useful suggestions 
simply typed lambda calculus crude way close relation subjects adding rule alpha gamma oe gamma oe ff ff alpha conversion defined inductive definition 
solutions heavy ideal implementation formal meta reasoning 
reasoning rules ll reason rules ff 
rules alpha syntax directed hard reason non deterministic allow derivations judgement prevents proof induction structure derivations 
concrete presentation closed alpha conversion approach formalize informal meaning lda rule suggested choose sufficiently fresh variable name substitute informally replace lda gamma oe gamma oe oe substitution defined usual definition involves alpha conversion 
give formulation suggested coq formalized detail mp 
range infinite set parameters variables 
parameters variables disjoint sets define operations replacement 
replacing parameter term entirely textual oe oe replacing variable term respect scope variable binding rename variables prevent capture oe oe replace lda lda gamma oe gamma oe oe means textual occurrence 
side condition rule necessary check dom gamma failure condition prevents completing derivation just choose parameter occur rule 
necessary check premiss doesn bind instances arise define beta reduction beta conversion prove church rosser subject reduction mp purposes alpha conversion ff refl ff ff lda ff oe ff oe ff app ff ff ff state prove closed alpha conversion informality 
required terms distinguishable necessarily underlying objects 
depending formalization terms weaker conditions 
mp terms inductive type distinct constructors parameters variables don require parameters variables distinct 
informal presentations logic common term inductive relation strings alphabet case course require distinct objects alphabet distinct 
lemma closure alpha conversion 
gamma oe ff gamma oe proved outline proof subject reduction closure beta reduction fact ff contained parallel reduction lemma corollary subject reduction 
treats parameters seriously oe oe oe oe oe different problem problem 
analysed transition local variable global parameter treatment parameters 
induction principle interesting variation previous idea generalized induction truly remove fresh name derivations 
replace lda lda dom gamma gamma oe gamma oe oe notice side condition time appearing antecedent generalized premiss 
don exclude happen occur derive gamma oe infinitely class variables infinite contain finitely hand dom gamma gamma oe derivable reasons having case excluded 
derive judgements fact equivalent 
lemma 
gamma oe gamma oe gamma oe fact proved allows structural induction induction principle stronger structural induction lemma states extensionally equivalent judgements 
consider proving extensional property gamma oe structural induction 
case lda justify gamma oe oe induction hypothesis gamma oe particular lemma suffices justify gamma oe oe stronger induction hypothesis dom gamma gamma oe 
informally strength comes showing judgements derivable system fewer derivations 
clear infinitely derivations example oe oe oe containing particular parameter oe oe oe derivation contain particular parameter 
loosely speaking subformula property lacks 
induction principle justifies belief judgement gamma oe occurrence parameter gamma treated binding occurrences actual parameter doesn matter long sufficiently fresh 
arguments times formalization named variables mp pol justifying constructive engine 
proof lemma 
direction induction derivation gamma oe 
direction easy 
proved induction length subject rule subject longer subject premiss 
proof extend case pure type systems considered section 
give proof extend better proof mp 
pol describes different ways prove equivalence detail 
introduce renaming 
renaming ranged oe function parameters parameters finitely extend action renamings compositionally terms contexts 
easy see bijective renamings respect particular oe bijective gamma oe oe gamma oem oe 
little difficult construct bijective renamings general parameters get moved considered fixed combinatorial nightmare 
clear renaming swaps parameters fq 

qg bijective 
prove gamma oe structural induction derivation gamma oe 
cases trivial rule lda lda gamma oe gamma oe oe induction hypothesis gamma oe show gamma oe oe lda need gamma oe arbitrary parameter dom gamma 
oe fr 

rg oe gamma oe oe derivable renaming induction hypothesis 
finished show oe gamma oe gamma oe oe notice dom gamma premiss lda derivable know dom gamma 
observations clear equation holds 
second equation notice oe identity renaming done assume premiss lda assumption dom gamma 
lemma easily proved structural induction terms oe oem oen oe reason oe fp 
rg fp 
fp 
lemma required 
ut discussion proof emphasised lemma extensional equivalence don expect intensional properties derivations height occurrence particular parameter preserved 
proof better statement lemma sense renames derivations leaving shape intact infinitely branches lda created proof shape 
systems working constructive engine system typing concrete terms named variables closed alpha conversion 
optimization suggests new idea handling global variables 
idea see presentation mentioning substitution closed alpha conversion 
optimization 
think optimization appears early writing martin lof constructive engine 
interesting purposes distinguishes variables global bound context part judgement locally global construction derivation 
inductive definition inefficient duplicating test gamma valid branch derivation 
example 
oe oe oe valid oe oe oe oe oe 
oe oe oe valid oe oe oe oe oe oe oe oe optimize moving test valid context outside typing derivation test context fact valid derivation extends context lda rule check extension preserves validity 
var gamma oe oe gamma lda gamma oe gamma oe oe dom gamma app gamma oe gamma oe gamma comparing notice var check gamma valid lda maintain property derivations 
sense correct lemma correctness 
gamma oe gamma valid gamma oe tiny example need check 
oe oe oe valid oe oe oe oe oe oe oe oe oe oe oe oe oe directions lemma easily proved structural induction 
similar optimization similar correctness lemma pure type systems see pol 
case correctness context typing judgement mutually inductive direction trivial direction 
understandable difficult says terminating algorithm putting back redundant information removed derivation root problem view systems far leaving unspecified context searched type variable 
leaves open possibility various implementations linear search 
price pay requirement binding occurrence variable valid context 
root problem closure alpha conversion don restrict binding instance variable term 
informally idea replace rule var specify search gamma assignment gamma assoc gamma searches gamma linearly assoc gamma returns type occurrence gamma viewing gamma list right 
precisely replace var rules search gamma right left 
start gamma oe oe weak gamma oe gamma oe lda gamma oe gamma oe oe dom gamma app gamma oe gamma oe gamma fewer judgements example oe oe oe oe 
judgements incorrect excluded gamma valid order search doesn matter 
lemma correctness 
gamma valid gamma oe gamma oe owe observation stefano berardi 
closure alpha conversion 
system strange operational presenting relation required 
payoff side condition dom gamma rule lda dropped giving system liberal terms lt start gamma oe lt oe lt weak gamma lt oe gamma lt oe lt lda gamma oe lt gamma lt oe oe lt app gamma lt oe gamma lt oe gamma lt consider new relations lt gamma valid lt 
notation 
relation write gamma oe gamma valid gamma oe local version clearly ae lt ae lt containments proper suggested examples lt lt variable may bound twice branch judgement derivable 
lt context valid lt derivable restriction variable re 
lt restriction variable re 
notice gamma lt oe iff lt gamma gamma oe gamma gamma gamma oe oe lt doesn property lt called local system liberal terms 
lt lt systems typing closed alpha conversion require notion substitution 
course interested reduction conversion typed terms require substitution 
criticism lt suggested non operational abstraction gamma requires bound valid context matched goal presenting typing relation informal notion term allows variable name bound implicitly contains idea linearly searching variable instance enclosing scopes find binding variable instance 
fact presentations type systems style presentation validity context means variable name bound common literature example bar luo hhp 
type theory designers presentations style lt problem lt bad properties weakening 
gamma oe gamma contains bindings gamma valid gamma oe lt doesn property 
logical property shows global bindings treated local bindings 
lt treat local global bindings uniformly unsatisfactory restrictive local bindings closed alpha conversion lt unsatisfactory liberal global bindings closed weakening 
lt just right 
nameless variables known technique avoid questions variable names de bruijn nameless variables 
pure nameless terms 
presentation pure nameless de bruijn terms 
db start gamma oe db oe db weak gamma db oe gamma db oe db lda gamma oe db gamma db oe oe db app gamma db oe gamma db oe gamma db notice real choices restrictions context ambiguity possible search context immaterial 
locally nameless terms 
consider terms local binding de bruijn indexes global binding named variables 
range class variables global free variables 
usual define operations substitution see hue replaces th free index appropriately lifted instances lowers free indexes higher longer hole replaces name th free index lifting indexes greater equal room new free index 
system typing locally nameless terms 
ln var gamma valid gamma ln oe oe gamma ln lda gamma oe ln gamma ln oe oe ln app gamma ln oe gamma ln oe gamma ln system similar spirit section 
handling global names identical central feature analysis local variable global reminiscent particular sufficiently fresh variable ln lda rule formalize observation proving exactly lemma judgements ln changed replacing ln lda dom gamma gamma oe ln gamma ln oe oe observation stronger induction principle ln structural induction discussed relation lemma 
course ln closed alpha conversion alpha conversion identity locally nameless terms 
constructive engine uses ln kernel system typing conventional named terms inherits closure alpha conversion ln locally closed terms 
call term locally closed free index occurrences 
easy see gamma ln oe locally closed type systems locally nameless terms property 
constructive engine ln treats global names just may optimization transformations section ln analogous iln iln start gamma oe iln oe iln weak gamma iln oe gamma iln oe iln lda gamma oe iln gamma iln oe oe dom gamma iln app gamma iln oe gamma iln oe gamma iln similar lemmas gamma ln oe gamma valid gamma iln oe section define system liberal terms replacing iln lda lda gamma oe gamma oe oe section step lt changed derivable judgements fact lt closed alpha conversion 
case iln closed alpha conversion step change derivable judgements 
main point occurs lda iln lda 
lemma correctness gamma ln oe gamma valid gamma oe proof 
suffices show gamma iln oe gamma oe 
direction trivial 
prove direction induction derivation gamma oe strong induction principle derived fact lda replaced dom gamma gamma oe gamma oe oe changing derivable judgements proof lemma 
ut constructive engine 
ready constructive engine 
system rules inductive relation shape gamma oe 
gamma concrete objects named variables think inputs engine 
oe outputs respectively translation locally nameless form gamma type example rule application terms ce app gamma oe gamma oe gamma read translate compute type named term context gamma evaluate rule inputs translate compute types evaluate premisses rule inputs computed inputs return result computed results premisses 
called systems translation systems pol 
difficulty remaining rule lambda terms 
ce app example gamma oe gamma oe oe oe clear compute oe 
reading lda algorithmically term oe input compute type strip lambda put variable hole created compute type extended context 
translation system named term oe translate named term locally nameless term construct locally nameless version oe fix problem consider system lda replaced pce lda gamma oe pce gamma pce oe oe pce pre constructive engine claim lemma correctness pce gamma ln oe gamma valid gamma pce oe proof 
suffices show gamma oe gamma pce oe 
equations locally closed direction pce derivation ends pce lda gamma oe pce gamma pce oe oe locally closed apply lda equation fact matter conversely assume derivation ends lda gamma oe gamma oe oe equation apply pce lda 
ut give constructive engine ce start gamma oe oe ce weak gamma oe gamma oe ce lda gamma oe gamma oe oe oe ce app gamma oe gamma oe gamma system clear operational reading 
soundness property gamma oe derivable gamma pce oe derivable derivation just erase named terms get derivation 
show translation named terms locally nameless terms correct correctness engine established 
dependent types familiar class pure type systems bar bar gn ber mp ado system rules table 
new difficulty arises alpha conversion dependent types binding dependency term type may different 
example expect able derive fx derive fx example suggests rule lda gamma gamma fx agb gamma fx agb ax ffl ax start gamma gamma dom gamma weak gamma oe gamma gamma oe oe sort variable dom gamma pi gamma gamma gamma fx agb rule lda gamma gamma fx agb gamma fx agb app gamma fx agb gamma gamma conv gamma gamma gamma table 
typing judgement pts 
bound variable term type exactly intend 
formalization pts distinguishes parameters variables lines discussed section described mp 
lda rule lda gamma gamma fy agb gamma fy agb system closure parallel reduction pol writing parallel reduction lemma 
gamma gamma gamma im ia gamma alpha conversion contained parallel reduction corollary corollary 
gamma gamma ff gamma ff ff gamma proof instantiating closure parallel reduction degenerate case alpha conversion intensionally satisfactory uses rule conv alpha conversion 
presentation pts nameless terms conv alpha conversion know structurally isomorphic nameless presentation just isomorphic judgements 
vc srt gamma vc ax vc var gamma vc assoc gamma vc pi gamma vc gamma vc gamma vc fx agb rule dom gamma vc lda gamma vc gamma vc fx agb gamma vc fx agb dom gamma vc app gamma vc fx bga gamma vc gamma vc vc gamma vc gamma vc gamma vc nil vc ffl vc cons vc gamma vc gamma vc gamma vc dom gamma table 
system valid contexts 
section derived system lt variable renaming closed alpha conversion 
don think pts 
follow transformations section optimizing check context validity linearizing context search arrive system table 
system correct sense gamma gamma vc gamma vc try drop side conditions dom gamma vc pi vc lda section call system bad find incorrect derivation gamma px bad px gamma bad fx gamma bad fx constructive engine remind addressing issue making pts syntax directed constructive engine derive program typechecking pts particular non syntax directed conversion rule remains explain interaction named nameless variables operational constructive engine 
table correct presentation pts locally nameless terms corresponding iln section 
section may drop side iln srt gamma iln ax iln var gamma iln assoc iln pi gamma iln gamma iln gamma iln rule dom gamma iln lda gamma iln gamma iln gamma iln dom gamma iln app gamma iln gamma iln gamma iln iln gamma iln gamma iln gamma iln iln nil ffl iln iln cons gamma iln gamma iln gamma iln dom gamma table 
intermediate system locally nameless terms 
condition dom gamma rules iln pi iln lda getting system just lemma 
locally nameless representation essential way dependent types 
continuing section argument lemma replace pi lda pce pi gamma pce gamma pce gamma pce fag rule pce lda gamma pce gamma pce gamma pce fag giving system pce constructive engine section 
constructive engine table closed alpha conversion 
ce srt gamma ax ce var gamma assoc ce pi gamma gamma gamma fx agb fag rule ce lda gamma gamma fx agb gamma fag ce app gamma gamma gamma ce gamma gamma gamma ce nil ffl iln ce cons gamma iln gamma gamma iln dom gamma table 
constructive engine pts 
accl abadi cardelli 
curien 
levy 
explicit substitutions 
journal functional programming october 
alt thorsten altenkirch 
formalization strong normalization proof system lego 
proceedings international conference typed lambda calculi applications tlca 
springer verlag lncs march 
bar henk barendregt 
generalised type sytems 
functional programming april 
bar henk barendregt 
lambda calculi types 
abramsky maibaum editors handbook logic computer science volume ii 
oxford university press 
ber stefano berardi 
type dependence constructive mathematics 
phd thesis dipartimento di informatica torino italy 
coq thierry coquand 
algorithm testing conversion type theory 
huet plotkin editors logical frameworks 
cambridge university press 
db nicolas de bruijn 
lambda calculus notation nameless dummies tool automatic formula manipulation application theorem 

math 
db nicolas de bruijn 
generalizing automath means lambda typed lambda calculus 
proceedings maryland special year mathematical logic theoretical computer science 
dfh dowek felty herbelin huet murthy parent paulin mohring werner 
coq proof assistant user guide version 
technical report inria rocquencourt february 
gn herman geuvers mark jan nederhof 
modular proof strong normalization calculus constructions 
journal functional programming april 
gor andrew gordon 
mechanism name carrying syntax 
proceedings hol user meeting vancouver 
springer verlag 
lncs 
hhp robert harper furio honsell gordon plotkin 
framework defining logics 
journal acm 
preliminary version lics 
hue erard huet 
constructive engine 
narasimhan editor perspective theoretical computer science 
world scientific publishing 
volume gift 
hue erard huet 
residual theory calculus formal development 
journal functional programming july 
lp zhaohui luo robert pollack 
lego proof development system user manual 
technical report ecs lfcs lfcs computer science dept university edinburgh king buildings edinburgh eh jz may 
updated version 
see www dcs ed ac uk packages lego luo zhaohui luo 
extended calculus constructions 
phd thesis department computer science university edinburgh june 
mp james mckinna robert pollack 
pure type sytems formalized 
bezem groote editors proceedings international conference typed lambda calculi applications tlca utrecht pages 
springer verlag lncs march 
pol robert pollack 
implicit syntax 
informal proceedings workshop logical frameworks antibes may 
pol pollack 
typechecking pure type sytems 
informal proceedings workshop types proofs programs sweden pages june 
available ftp 
pol robert pollack 
theory lego proof checker extended calculus constructions 
phd thesis university edinburgh 
available anonymous ftp ftp cs chalmers se directory pub users pollack 
tas 
formulation martin lof theory types explicit substitutions 
master thesis chalmers may 
van benthem jutting 
typing pure type sytems 
information computation july 
van benthem jutting james mckinna robert pollack 
checking algorithms pure type systems 
henk barendregt tobias nipkow editors types proofs programs international workshop types nijmegen may selected papers volume lncs pages 
springer verlag 
article processed macro package llncs style 
