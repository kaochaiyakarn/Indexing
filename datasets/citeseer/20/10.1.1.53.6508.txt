literature review quantification software change powell department computer science university york york yo dd major characteristic software engineering compared engineering disciplines inability get product right time 
change intrinsic essential part software development reasons 
difficult specify required having form model help formalise problem 
real world problem software exists solve subject change 
know produce design development invisible intangible complex software products inherently difficult 
time software critical competitive factor organisations 
instance development software controllers critical developments 
ability produce software higher quality cost shorter timescales matter survival 
organisations continually seek improve processes software produced 
processes advanced demand increasingly complex applications appears 
review surveys number different software research fields including measurement maintenance estimation process improvement form contribution change measurement management review ends summary open problems modelling quantification software change 
survey covers literature june 
page intentionally left blank 
background cost hardware relative software continued fall software significant component large proportion system developments 
software product represents critical competitive factor organisations 
result organisations continually strive effective ways perform software process increase productivity reduce cycle times improve planning control whilst securing product quality 
technically commercially organisations operate limits 
effort devoted turn software creation mature engineering discipline characteristics established engineering disciplines embody structured methodological approach developing maintaining artefacts mcdermid 
decades seen discipline increase maturity represented large body research facets software development catalogued texts sommerville mcdermid 
improvements brought advanced tools methods techniques aid engineering software including case structured methods formal notations 
despite advances productivity improvements failed 
explanation software development ultimately design endeavour accordingly reliant quality human 
tools support supplant designer 
nature software generally sequence offs shepperd certainly helped ability consistently achieve successful results 
software engineering processes advanced demands increasingly complex applications duncan 
motivation report need survey review current research approaches overcoming problems 
factors interest improvement process software produced ii importance measurement driver improvement iii role change software development 
process improvement software development process main driver product quality 
iso standard iso defines process set interrelated activities transform inputs outputs 
consider inputs consumption quantities function effort cost time outputs produced qualities function complexity functionality reliability goal limits acceptable risk optimise quantity quality relationship set project demands 
quantity quality function represented point representing particular product state shaded area potential improvements 
quantities consumed qualities produced reliability maintainability effort time quantity quality improvement optimising quantity quality relationship take forms 
set qualities goal usually minimise quantities necessary achieve example reduce effort cost timescale efficient eliminating steps reducing rework building simpler products reusing components boehm 
set quantities goal usually maximise product qualities 
authors generally easier define quantities qualities definitions quality exist 
mccall mccall defines software quality factors revision transition operation taxonomy 
example boehm give conventional hierarchical list 
clear quality multi dimensional concept 
follows improve software process businesses need understand trade offs qualities sought products quantities resource produce 
rombach uses term know capture need formalise understanding demand software engineering know caused stronger requirements quality productivity predictability software engineers represent essential software engineering know reliable adequate correct complete consistent robust testable understandable structured concise self descriptive measurable quantifiable usable efficient transportable maintainable interoperability reusability portability maintainability flexibility testability correctness reliability usability efficiency integrity product transition product operation product revision mccall quality factors quality factors explicit reusable form 
requires organisational setup building explicit models software engineering respect business demands models effectively similar projects rombach 
measurement modelling measurement fundamental engineering discipline 
process assigning numerical representations process quantities product qualities interaction gives benefits control desire measure process driven need control 
measurement provides feedback reasoning alternative actions 
assessment measurement gives ability evaluate status product process identify trends patterns value judgements 
prediction measurement predict value attribute aid formation assessment decision criteria 
measurements underlying assumptions world purport capture impossible talk measurement implying form model 
change early models software development process waterfall model royce simple sequence canonical phases specification design coding testing activities 
models soon identified unrealistic assumed complete consistent specifications produced prior design implementation 
despite attempts apparent software development inherently iterative evolutionary process progressively refines requirements design acceptable product parnas 
lead authors reflect change models software process 
example spiral model boehm treats software development evolutionary process requires careful management technical managerial risks 
change causes economic technical managerial problems 
economic problems caused unplanned impact change cost timescales 
technical problems experienced change potentially introduce new defects system time successive changes reduce system quality 
managerial problems result control demands economic technical impacts change effects sponsors customers 
processes operate near limits increasingly sensitive change increased risk 
levels software change having different problems management software process time 
time production software artefacts considered extreme form change 
aim optimise productivity product quality 
rework process form change caused inconsistencies different abstractions software products specification design code artefacts world purport model 
main problem balancing costs detection activities risk defects final product 
maintenance change final delivery product meet changes product operational environment remove remaining defects provide desired enhancements 
aspect maintenance problem need capture adequate design information system efficiently maintained people responsible construction 
reuse provides potentially high economic savings components known qualities 
presents particular problems effective identification modification application components 
subject matter software change spans number areas software development having individual characteristics difficulties 
despite traditional treatment separate problems underlying relationships ability achieve success area 
transfer know areas actively place basili argues viewing maintenance re oriented development basili 
eclectic view change implies improve product change intrinsically improving process 
survey objectives criteria limitations literature survey driven critical questions management software processes facets change need measured control process 
processes software change software process improved 
unreasonable expect answer questions fundamental questions driving software process research 
intention capture state understanding facets software change means identify limitations current knowledge potential research 
intention selected material highlight author thinks papers contribution understanding change 
hoped construction wide review pertinent literature inevitably incomplete provide firm grounding useful research area 
study software engineering know nature empirical subject 
methodological epistemological aspects appear correct proof contribution relies empirical confirmation phenomena various application domains 
problem symptomatic empirical software research undoubtedly slowed communities progress understanding complex dynamics software process 
research software metric model validation currently active developing research area right 
approach taken overcome problem filtering material academic support taken widely accepted field 
papers appear contribution relatively untested identified 
author attempted identify review promising detail time constraints limit useful constructive criticism certain papers deserve reflecting large amount theoretical empirical research remains done field 
structure survey response question section contains review efforts quantify various aspects change product level 
examines general research software change followed overview general software measurement basis evaluating research attempts quantify aspect software change 
response question section contains review efforts model improve change process level 
process modelling literature summarised basis evaluating research quantitative models software change 
section examines relationship change models process environments generally current process improvement approaches 
section summarises open research problems modelling quantification software change 
page intentionally left blank 
change change measurement change overview need change long recognised intrinsic part software engineering process lehman 
estimated changes due maintenance rework accounts percent total costs griss 
despite traditional literature focus change largely confined considering change formal configuration management change delivery software maintenance 
take eclectic view change argues view software evolutionary development process interactions software development team user system 
software maintenance conceived natural projection process current assumption point time software product finished delivered 
concepts evolutionary delivery means new innovative 
book principles software engineering management tom chapter reviews wider perspectives need evolution drawing supporting research computer science fields management engineering architecture 
classic rational design process fake parnas clements parnas captured essence paradox ideal linear stepwise software process captured academics standards authorities actual iterative software process performed software engineers 
give reasons paraphrased brevity software development proceed perfectly rational way 
people commission building software system frequently know exactly want unable tell know 
knew requirements details known progress implementation 
costs permit backtrack easily designs 
human beings unable comprehend fully plethora details taken account order design build correct system increasing likelihood errors 
case trivial projects subject change external reasons 
human errors avoided avoid humans 
concerns separated errors 
burdened preconceived design ideas 
encouraged economic reasons software developed project 
need fake supporting documentation reasons communication validation certification maintenance helps explain despite obvious failings waterfall lifecycle remains popular 
mismatch real perceived process notably driving force process modelling research 
implication trying measure model process need capture real opposed ideal process aspects change 
relatively little research seeking investigate explain aspects software change study right 
lehman lehman earliest highlight contradiction software engineering hand strives absolute correctness artefacts problems modelling real world continuous unbounded 
capture essence change lehman classified program types correctness 
type programs required satisfy pre stated specification 
correctness absolute relationship specification program 
type programs required form acceptable solution stated problem real world 
correctness type programs determined acceptability solution 
type programs required solve problem implement application real world domain 
correctness determined program behaviour operational conditions 
type programs interest study change focus survey 
interaction real world forms feedback system defines correctness 
lehman argues limits confidence results execution type programs viewing organisms driven human experiences interpretation reaction decision imply 
lehman observed feedback effects type systems growth decay large software systems formulated laws program evolution lehman 
law continuing change systems prone change progressively useful 
law increasing complexity software data control structure deteriorates changes occur done maintain reduce 
law self regulation fundamental law program evolution software evolution subject feedback processes act stabilise evolution determinable trends invariances 
law conservation organisational stability activity organisation support evolving program attempts maintain stability sustainable growth 
law conservation familiarity perceived complexity release content changes additions deletions successive releases evolving program statistically invariant 
law continuing growth functional content program continually increased maintain user satisfaction lifetime 
law declining quality type programs perceived declining quality rigorously maintained adapted changing operational environment 
observations clearly parallel general systems principles internal contextual conditions complex software system seen move stable equilibrium states period disequilibrium new stable states 
laws accurately described phenomena served lay foundation exploration dynamics software growth change 
maintenance field takes pragmatic view change ieee corrective performed correct faults hardware software perfective performed improve performance maintainability attributes computer program adaptive performed computer program usable changed environment 
classifications equally valid change outside maintenance phase 
corrective change internal software process representing failure preserve integrity software representations transformations software process functionality performance 
perfective change represents internal external change due mismatch product environment 
adaptive change responds changing external environment system 
type change implications management process 
causes change described lehman lehman terms uncertainty faced type systems 
del uncertainty arises software model model model computer application real world lehman 
say software development model problem reality 
result development type software changes real world system purports model 

heisenberg uncertainty results processes development system change user perception understanding application 

pragmatic uncertainty due problems performing development 
firstly embedded uncertainty relating validity assumptions application operational domain solution system 
secondly process uncertainty relating assumptions validity software development process 
lehman demonstrated change essential unavoidable aspect software creation operation captured uncertainty principle outcome real world software system operation inherently uncertain precise area uncertainty 
uncertainty results types change resulting failure get things right time pragmatic uncertainty ii necessary consequence changing circumstances del heisenberg uncertainty 
capability software process respond handle change important driver process quality 
measurement evaluation properties vital element understanding nature software dynamics 
software measurement history years seen large amount research aimed determining measurable properties mathematical relationships product qualities process quantities 
attempts capture notions complexity relate actual expected external properties development effort defect potential 
quantitative understanding fundamental control assessment prediction software process attributes 
earliest measures analysis software code fundamental basic count number lines code loc 
despite widely criticised measure complexity continues widespread popularity azuma mainly due simplicity 
suggested loc null hypothesis experiments compare quality software measures basili 
search theoretically software measures predictive capability pioneered maurice halstead 
halstead software science halstead modelled program comprehension function program operands variables constants operators arithmetic operators keywords alter program control flow 
concept triggered large number papers correlating measure proposed extensions various external properties error proneness studies shown flawed 
early measure proposed mccabe mccabe viewed program complexity related number control paths program module function number edges control graph equivalent branching points number vertices equivalent sequential block code number connected components 
modules higher cyclomatic complexity control loops selections considered difficult test 
despite having significant weaknesses neglect data flow complexity mccabe cyclomatic complexity measure improvement existing methods predicting testing effort aiding evaluation alternative module decomposition strategies 
general problems early software measures documented shepperd 
problems generally revolve measures software code lacking predictive capability early stage process erroneous assumptions particular programming environment poorly articulated models ill defined aims counting rules 
theory frameworks software measurement field plagued problems defining measures collecting consistent useful data cost effectively performing analyses interpreting results putting 
hundreds measures defined literature accepted academia industry briand 
confusion arises measurements taken analyse past monitor predict 
years seen watershed software measurement research recognition need disciplined scientific approach 
developing field paved way major improvements quality measurement research 
notably demonstrated importance rigorous application measurement principles baker statistical methods importance sound methodological experimental basis empirical studies explicit documentation validated fenton importance multiple measures capture multi dimensional facets software maintainability capture differences software environments munson importance predictive measures indicators earlier process specification design code strategic change easier accommodate fenton importance practical application embedding software measures decision setting baker 
despite widely accepted research necessary identify frameworks techniques measure evaluation selection integration application fenton 
shepperd write shortage metrics evidence metrics generally valid usable useful widely accepted shepperd 
difficulty task represents software environment conducting experiments due reliance inherent variability humans process 
repeatable scientific experiments evidence fields manufacturing logothetis 
factor hampering progress difficulty collecting valid engineering data basili andersen 
lack suitable data extraction analysis tools implied costly unpopular manual collection 
absence large data repositories validate results data frequently corrupted project organisational noise 
organisations frequently unwilling publish share information commercially sensitive nature data limited shelf life rapid changes development environments practices 
problems led formation large collective bodies software engineering institute sei software engineering laboratory sel international software engineering research network isern 
situation improving problems continue hinder largescale measurement research time come 
considering circumstances unsurprising practical successful measures date appear simple atomic counts 
null hypothesis lines code commonly outperform complex composite measures software development lind 
change measurement earlier sections shown change intrinsic feature software development 
control process requires quantitative understanding software change dynamics 
remainder section reviews attempts measure properties considering current measurement research change context 
terms change research categorised change counts causal analysis measures quantity causes change time 
ii statistical defect models models predict change historic change 
iii orthogonal defect classification analysis patterns process change 
iv requirements volatility measures likelihood requirements change 
error proneness prediction change design product characteristics 
vi ripple effect impact second order change system 
sections consider amount reasons trends change process iii 
sections consider external internal prediction ripple effects change iv vi 
change counts causal analysis basic change measures quantify amount nature change different periods time 
distinguishes types monitoring 
checkpoint monitoring takes snapshot stages defined lifecycle 
comparison quantifiable targets activities outputs indicates progress anomalous behaviour 
ii time monitoring individual entity module document subsystem detects deviation expected trend 
iii monitoring observes interphase build status product activities checkpoint 
basic data collected quantity impact cost quality reason type change 
causal analysis performed determine root cause change eliminate source defects 
information analysed techniques classification pareto analysis scatterplots rank correlation identify patterns data areas requiring attention 
significant techniques control charts statistical process control identify variations data values time predetermined limits exceeded appropriate corrective action taken 
analysis defect detection success latency shown importance time impact change 
cost correcting software defects shown rise rapidly progress software lifecycle basili 
study quotes cost requirements errors caught software test times correct caught requirements engineering jaffe 
number reported successes defect analysis techniques process improvement 
large proportion published case studies industrial process improvement change analysis hewlett packard grady ibm nasa rombach 
evidence demonstrates significant business returns proactive approach change 
limitations techniques 
predictive potential relies historical comparison giving late indication change suitable corrections current process time damage done improvement process time round 
benefits limited manual data analysis required 
statistical defect models desirable research goal prediction software defects historical patterns defect detection removal 
driven desire prove software system correct reliable particularly case safety critical safety related systems latent defects disastrous consequences 
application judge software application fit release stability 
case considerations economic safety decision criteria apply 
terms change measurement reliability modelling provides means predict change past experience 
reibman reibman identifies general applications models 
help set interpret system reliability requirements 
predict reliability different system configurations 
identify system reliability weak points reliability bottlenecks early product lifecycle designers changes expensive 
determine cost effective maintenance strategies 
software reliability modelling significant research area captured comprehensive texts subject musa musa 
term reliability probability entity perform required function conditions time interval 
intention review specific models judgements success usefulness dynamic models software change 
yu yu identifies general form parametric defect models ed number software defects certain phase software lifecycle 
dependent variable model 
program measures program size number decisions number variables ed number defects detected earlier phase software lifecycle testing time measured cpu time calendar time effort measure 
factors including hardware facilities types software development effort programmer experience design methodologies models generally assumption increasing time detected defects developmental operational failures indicates increasingly stable reliability 
progress early models musa musa predictive accuracy traditionally poor making unsuitable high reliability applications requirements failures hour greater 
fundamental problems models suggested date oversimplification failure process assumption perfect removal flaws potential bad fixes flat rate execution profile reality certain parts system executed 
majority models assumptions system behaviour particular environment equivalent presuming reliability growth profile telecommunications product nuclear reactor protection system 
unsurprising published empirical validations widely different results inevitably making assessment difficult 
comparative studies demonstrated model trustworthy circumstances 
consequently research directed providing statistical methods evaluate select appropriate model particular application domain abdel 
specific problem software change models available late lifecycle integration testing phase development limiting predictive potential 
accordingly models appear late control process problems dramatic expensive change representing high effort fact 
give idea scale change required mean fix time specified 
models evidence success decisions testing economic problem diminishing returns dalal net benefit plot dalal model laprie 
providing additional product certification evidence industrial usage remains low 
response problems attention shifted problem predicting proving product reliability design development opposed testing 
include building reliability models product design techniques reibman evaluating integrity software engineering tools environments 
way having statistical methods prove product reliability matter predictive models software change 
orthogonal defect classification team ibm including ram chillarege produced useful technique establishes existence cause effect relationships development process 
intention overcome weaknesses defect analysis techniques reliability modelling occur late lifecycle perform major corrective process change 
concept orthogonal defect classification odc chillarege semantic classification defect data information points part process requiring attention 
hypothesis semantics fix type relates changes shape reliability growth curve 
correct potential benefits 

relates defect data subset process activities may require improvement 
gives potential automated tools avoid costly time consuming manual analysis 

provides method checking development logically place chronologically 
providing additional rich form control information defect trend analysis 

defect type signatures current historical processes compared indicate likelihood defects remaining provide evidence process converging product interesting hypothesis arise 
case study approach demonstrated potential technique identifying process improvement opportunities automated data analysis 
study uses attribute focusing approach interestingness filtering functions indicate trends data areas concern 
orthogonal defect classification appears promising technique change analysis consequent process improvement real time 
empirical validation odc necessary particularly evaluate process product assessment 
requirements volatility completeness risk requirements volatility measures provide method assessing quantity reasons requirements change consistent current development activities 
basic form requirements volatility analysis counts requirements added deleted modified classification reasons change 
costello metrics requirements engineering costello provides comprehensive list measures analysis performed requirements 
includes measures requirements completeness indicating number requirement decompositions completed 
information highlights problems requirement elicitation capture representation external causes change 
analysis stress changeable parts system reasons appropriate action taken avoid change 
trends requirements volatility indicate status product process 
extremely valuable control purposes obvious limits predictive capability techniques constrained similarity application inherent volatility external environment 
ultimately volatility reflects uncertainty software change section 
limited amount research uses requirement volatility project risk analysis example semantic classification approach palmer palmer 
important role play management software change majority area currently qualitative assessment 
error proneness main body software measurement research extract certain properties software design form notion complexity 
basic assumption property design implementation contain defects effort required produce test 
despite hundreds suggested measures accepted definition meant term complexity 
state research area summarised points section 
hope single measure capture properties say misguided experimental elements complexity valuable role providing feedback improvement design practices 
second proven application focus testing resources efficiently modules high probability error 
time permit thorough review numerous measures suggested indicators defect potential 
generally fall classes module length basili shen token measures halstead software science halstead control flow measures mccabe cyclomatic complexity mccabe information flow measures henry kafura information flow measure henry 
sizeable amount measurement research dedicated study evaluation measures failings widely documented kafura 
fact measure surfaced generally agreed indicator error proneness demonstrates research suggests single metric represent multi dimensional notion complexity 
second class studies started emerge 
observations faults fall uniformly components software products concentrate small subset components boehm boehm quotes rule thumb percent software system responsible percent errors cost rework lead research pattern recognition classification approaches identify predict high risk components historical data 
porter proposed classification tree calibrated certain dataset predict high risk modules order focus testing resources porter 
approach highly dependent selected characteristics classification tree 
similar vein munson munson discriminant analysis examine relationship program faults various complexity attributes 
identify unique contribution metric model map metrics orthogonal complexity domains 
discriminant analysis classify dataset modules fault prone fault prone 
produce statistical model predict quality attributes software system 
applied technique success large telecommunications project 
approach tried neural networks perform classification task 
benefit neural nets ability operate noisy non normally distributed datasets 
inherent assumption considering metrics possible lead complete model 
case study approach claimed predictive properties 
briand briand provided review criteria traditional regression analysis techniques classification approaches appropriate 
classification techniques notable expressive nature neural nets potential automation 
main problem potential common denominator returned ignore useful predictor 
criticised shepperd shepperd scatter gun black box approach measure evaluation selection 
evidence traditional regression classification approaches useful developing understanding effects different design strategies defect potential briand 
ripple effect sections considered termed order causes software change direct impact change product 
change causes second order impacts seen propagate system series consequent changes need change module requiring change modules 
ripple effect due structural properties representations software artefacts interrelatedness reflection cohesion coupling artefacts 
earliest attempting measure tendency change ripple product 
modelled large software system impact matrix element representing probability change module gives rise change 
model predict number changes required stabilise system maintenance determine strategy staging releases system 
technique relied manually provided subjective probabilities reducing usefulness assumed system requirements frozen 
yau yau identifies general problems early measures proposed myers myers assumption modifications module ripple effect assumption symmetry change module impacts module reverse true 
yau proposes measure stability resistance amplification change connection modules system parameters global variables intra module change propagation ii inter module change propagation 
measures identify certain characteristics software design 
yau turn attention design measures potential ripple effect yau early indicators maintainability measure design quality 
main feature yau distinction logical stability measure resistance impact modification modules program terms logical considerations performance stability measure resistance modification modules program terms performance considerations 
significantly yau highlights importance modelling functional non functional impacts change point largely neglected literature 
side note attempts model ripple change process level 
attempted model spread faults affected detection correction activities 
ripple effect demonstrated useful indicator maintainability software system 
empirical evaluation required order validate relationships particularly light new programming design practices 
measurement change software change presents problems control software development deceptively easy introduce changes software effects propagate 
mcdermid 
possible measure dynamic properties provide feedback process control albeit somewhat delayed indicate opportunities improvement development techniques 
mechanisms provide capability evaluate current expected amount change change counts methods reduce minimise change causal analysis impact design techniques ability evaluate attempts limit impact change error proneness ripple effects 
relative immaturity mechanisms described indicates scale research required understanding low level properties 
lack progress attributed difficulties empirical validation representing numerous attributes change 
fundamentally represent inadequate understanding relationship software product process 
page intentionally left blank 
change modelling improvement phenomenon software change dynamics number highly interrelated factors technical operational sociological 
ability control process depends quality models relationships 
assigning objective quantitative values models give ability reason trade offs product design decisions decomposition strategy process decisions time versus cost defect detection activities evaluating alternative software engineering approaches formal methods 
having briefly surveyed research quantifies dynamic aspects change section considers attempts developing predictive models change 
cost modelling earliest attempts software process modelling driven desire accurately predict cost software development early stage process 
models boehm constructive cost model boehm putnam slim model putnam widely applied subjected critical evaluation extension mukhopadhyay 
fundamental weakness early macro cost estimation models basis lines code loc measure system size accurate figures loc generally available late process time estimation problem 
alternative sizing mechanisms suggested take early information designs specification 
notable albrecht function point analysis albrecht estimates product size counting number inputs outputs inquiries logical files interfaces 
counts empirically adjusted normalise impact total adjusted weighting complexity code data algorithms product domains timing storage constraints reuse percentage distribution degree reliability requirements 
significant industrial uptake function points relatively simple measure calculate generic available early process 
function points criticised inconsistent counting rules attempts correct problem best practice emerge 
whilst demonstrated useful domains little analysis variation measure applied different domains applications function strong versus data strong environments 
accuracy maturity cost estimation models say immature 
number independent evaluations kemerer kemerer reported mixed successes 
warn local calibration models check manual estimates 
notable decline quantity research conducted macro cost modelling techniques possibly representing amount low level micro cost relationships understood 
general problem majority published cost models deal change implicitly explicitly 
investigation subramanian alterations software estimates subramanian confirmed factors estimates highly vulnerable change traditionally cost models give discrete values indication error margins 
inevitable changes unreasonable expect accurate estimates early process desirable models produce estimates stated bounds accuracy 
tendency literature treat cost estimation cost control separate distinct problems 
results lederer survey causes inaccurate cost estimates lederer demonstrated whilst managers perceived problem user sourced changes requirements fundamental problem inadequate monitoring control development change 
abdel hamid suggested maintenance metaphor adapting correcting estimates overcome problems abdel hamid 
current estimating methods criticised discrete software artefact seen change continuously 
argues adaptive corrective perfective maintenance take place continuous estimate increase accuracy act focus alternative decision strategies 
significantly highlights need understanding consequences rework requirements change just productivity 
response problems abdel hamid proposes simulation models having significant benefits current analytical models 

causal structure provides superior explanatory power regression models explain conditions relationship exists 

solution analytical models usually specifies terminal steady state eventually results changing values controlled variables 
simulation exposes continuous transitions 

controlled experimentation 
continuous self correcting nature means systems dynamics techniques appear promising approach construction predictive software models 
traditional parametric models remain inherently constrained inadequate understanding fundamental product process inter relationships 
process modelling general practical processes reflect theoretical models software development curtis 
experiences lifecycle cost modelling highlighted inadequacy large grain techniques capture convey low level characteristics software process process steps required resolve customer reported software problems triggering terminating conditions activity state product component process step notational methodological operational tools different process steps inputs outputs activity sources destinations data manner data flow activity roles played humans process constraints process steps communication humans supported parallel sequential process steps exist 
fine grain modelling gives capability provide framework understanding experimenting reasoning process ii facilitate process guidance enforcement automation iii provide basis process management iv allow packaging experience applications 
process modelling potential key factor improving software development effectiveness krasner 
writes improvement solid methodological organisational background guide direct assessment decision making processes effectively 
general process models seen reflect certain key constructs curtis agent actor human machine performs process element 
role coherent set process elements assigned agent unit functional responsibility 
artefact product created modified enactment process element 
large number process modelling approaches suggested 
differ nature prescriptive requiring process performed particular way requires process performed particular way descriptive describes way development conducted 
curtis classified perspectives process models take curtis functional represents process elements performed flows informational entities data artefacts products relevant process elements 
behavioural represents process elements performed sequencing aspects performed feedback loops iteration complex decision making conditions entry exit criteria organisational represents process elements performed physical communication mechanisms transfer entities physical media locations storing entities 
informational represents informational entities produced manipulated process entities include data artefacts products intermediate objects perspective includes structure informational entities relationships 
perspective particular advantages different audiences engineers technical management general management quality assurance customer 
generally accepted single modelling technique capture complex software process 
research effort focused evaluation integration process modelling techniques 
rombach rombach performed comprehensive review current research research directions process modelling finding despite large number different representations empirical evidence successful application representing relative immaturity discipline 
rombach states software process representation languages reflect practical needs documented supported appropriate tools 
languages real pilot projects tools process sensitive software engineering environments bought 
promising application fine grain process modelling helping define measurement needs meaning metric dependent process operates 
shepperd shepperd argues product measures embedded process descriptions aid application ii aid reuse successful applications iii supports training educational aspects introducing measures iv aid potential powerful advanced tools environments automated collection aid understanding 
considering product measured measured hoped problems measurement research problems validation incorrect usage overcome 
appears promising research potential methods integrate process models software measures 
process modelling play significant useful role capturing developing understanding mechanisms software created 
rapidly expanding research area software measurement inherently difficult assess contribution technique empirical problem domain 
need improved frameworks techniques basis evaluating different approaches integration successful elements 
change modelling software research contains relatively examples explicit quantitative models software change 
majority related field software maintenance largely prediction maintenance task effort 
study maintenance task effort prediction models highlighted poor state knowledge area rgensen 
rgensen notes published examples currently organisations relying expert judgement function point analysis methods 
compares number different approaches including regression analysis neural networks pattern recognition measure size lines code loc size loc inserted loc updated loc deleted author highlights critical failures measure firstly reflect task characteristics change software functionality quality usefulness secondly reflect actual maintenance tasks design test documentation 
proceeds measure factors 
mixed success 
unintentionally effectively demonstrates need improved measures change size precondition accurate predictors change effort 
convincing approach attempts model correction effort required isolate cause fault ii fix fault isolated 
correction effort information ways predictive evaluate effort resources required complete task prescriptive evaluate impact specific software changes effort required correct faults potentially leading design implementation modifications 
model categories variables relating fault locality spread fault software software characteristics structural complexity features code cumulative changes software questionable assumption changes imply increased familiarity correction effort 
line developmental effort estimation attempts model maintenance fault correction tasks currently poor state understanding 
imprecise results reflect failure adequately capture low level empirical relationships software structure cognitive complexity indirect change tasks documentation testing 
consequently high noise signal ratio models prevents meaningful results outside original dataset 
models maintenance suitable management decision making outside cost estimation service agent model maintenance 
queuing network provide information consequences assigning particular individuals particular kinds tasks interactive mode adopting certain general management strategies automatic mode 
model appears comprehensive appreciation separate decision tasks change phase model analysis stage includes decision accept reject change technical needs basis cost estimate 
accepted detailed breakdown subtasks produced maintenance plan task 
processing stage working change different service agents potentially parallel 
testing stage resultant need testing changes consequent system integration tests 
whilst comprehensive model significant assumptions nature particular maintenance environment example assuming change priorities solely costs expected profit 
serves demonstrate potential research software change decisions 
majority measurement modelling research concerns linear single team developments 
attempts developing process models incorporate problems change 
reports successful concurrent processes reduce software cycle times 
significant indicates absence research advanced techniques managing software projects concurrent distributed development teams 
suggests great deal research done control complex processes 
olsen olsen proposes software change management model dynamically overloaded queues 
model treat development maintenance activities essentially thing change 
olsen uses fluid approximation model separates changes create demands staff requirements market shifts services perform documentation coding testing inspecting defect resolution 
model simplistic serve demonstrate project phenomena mythical man month brookes demonstrates queuing models useful approach change modelling 
similar manner hansen hansen simulated software process dynamic model maintenance tasks 
hansen highlights importance explicit account rework estimation techniques opposed current implicit account change 
simulation approach aid reasoning basic feedback effects change project outcome model simplistic terms parameters underlying assumptions 
selected reviews current change models appear representative general body area 
inadequacy low level process understanding means unreasonable assumptions macro relationships assuming linear effect project pressure productivity ignoring effects completely 
low level empirical relationships accurately understood potential control prediction inherently limited 
view reflected current lehman lehman undertaking new investigation role feedback software process acknowledges importance feedback apparent far back 
lehman earlier investigations software system stability evolution section identified positive negative feedback 
positive feedback driven ambitious growth targets 
negative feedback arises techniques inspections reviews prototyping measurement 
observed phenomena oscillation system size hypothesized symptom excessive positive feedback leading periods instability consequence human nature evolution decisions 
lehman asserts pre existing negative feedback mechanisms act limiting factor improvements forward path software process formulating feedback evolution software technology conjecture feedback system type software process display global invariance characteristics 
intention process modelling systems dynamics techniques capture properties feedback mechanisms 
conjecture appears promising approach tackling problems software change dynamics provide valuable basis quantitative change models 
change environments technologies problems change due limitations current software development technology supporting change handling providing information change decision making 
attempts create new paradigms software development amenable assessment accommodation change 
research strand proteus project highlighted importance having software engineering environments facilitate effective change 
argue importance assessing suitability approaches requirements engineering methods systems design dealing requirements instability 
outcome project development sets criteria evaluate method contribution minimising adverse impact change 
fundamentally proteus approach little aid improvement wider change problem 
strategies largely qualitative give little support management imply subjective approach processes change handling 
desirable long term goal development transformational approaches software development 
term automated software synthesis describes transformation requirements high level design specifications operational code 
automated production operational code directly requirements elusive remain time come 
revolutionary attempts improve environment capability change handling particularly reduce problems software maintenance 
largely driven need provide evolution systems definition record contextual information software designs 
notable baxter baxter highlights loss important kinds design knowledge problem specification ii design justification 
general approach development techniques record re constitute design rationale capture resultant changes time example 
number tools environments proposed investigated information requirements necessary impact analysis change propagation 
continuing research improve configuration technology support advanced process models give guidance change handling gulla 
general review environments 
major research area involving software change software reuse 
economic technical benefits motivated industrial uptake reuse techniques including reduced development timescales effort increased system reliability simplified estimation 
despite problems classifying cataloguing retrieving software components mili recorded case studies identifying reuse benefits achievable hewlett packard griss claim reduced product costs sustainable percent defect rates dropping percent levels long term maintenance costs dropping percent 
practical capability software reuse highlights need improved process models reflect change including mechanisms measure evaluate reuse effectiveness 
change process improvement significant research aimed capturing high level mechanisms achieving process improvement 
basic assumption process improvement process instrumental producing product 
practical experience shown progress transferring new tools methodologies industrial practice limited largely non technical factors basili 
origins management organisation behaviour research area practical application fields manufacturing 
concepts statistical process control deming continuous improvement imai associated techniques pareto analysis control charts successfully applied software development 
need evaluate organisations process capability lead approaches capability maturity model cmm software engineering institute humphrey 
maturity frameworks desire repeatable predictable process process free variation 
cmm framework rates organisation levels process capability 
level initial software process poorly controlled level repeatable management basic control software process level defined software process standard consistent level managed software process quantitatively understood controlled level optimising software process focuses continuous improvement 
levels recommended best practice key process areas 
assessment largely question driven attempts attach specific quantitative measures level pfleeger notably indication measures level 
cmm contemporary models spice serving encourage force organisations evaluate process maturity improve time 
significant contribution process improvement basili software engineering laboratory 
tame model tailoring measurement environment basili presents framework guide support process improvement step quality improvement paradigm qip characterise current maturity ii define quantifiable goals improvement strategies iii evaluate achievements measures performance iv package disseminate reuse experience organisation 
second thread goal question metric gqm paradigm encourages measures specified terms goals achieve questions need answered metrics needed answer questions basili 
gqm aids focused measures captures measures context aid communication evaluate suitability environment 
high level tame environment uses concepts qip gqm capture process understanding experience base aid reuse projects 
number published case studies measurement process improvement relatively contribute research terms documented application basic advice pragmatics metrics programmes 
indicate measures worked improvement certain applications example bull information systems 
handful notable exceptions hewlett packard grady 
grady reports application product analysis process improvement 
outputs developmental stages passed analysis tools including design tom design weight measure generated compare module complexity versus system complexity ii code graphical plot mccabe cyclomatic complexity measure provides visual impact complexity iii test test coverage measures iv documentation readability statistics kincaid indexes 
demonstrates value automated data collection techniques products providing useful measurement information 
motorola 
motorola example carefully focused measurement programme 
emphasises benefits having fewer informative measures meaningful appropriate audiences users software engineers senior managers software managers quality teams 
essence successful measurement scheme captured analysis different dimensions considered metrics usefulness audience goals 
key feature comprehensive page vital signs summary management 
dion 
report significant fact describes attempts calculate costs savings measurement programme 
majority case studies main benefits come reducing rework notable account tangible rewards reduced pressure late nights weekends worked improved communication 
describes claimed dramatic improvements fold increase productivity return dollar invested calculated 
lockheed martin henry 
study interesting focus implementing measurement maintenance process 
main benefits experienced impact different types change quantitatively known strategies management place 
second effectiveness process phases quantitatively assessed ability detect defects early lifecycle 
third significantly quantify impact late specification changes software product maintenance process 
key measurement gave insight severity problem knew existed advance 
say explicit understanding magnitude problem promoted effective management approach 
software process improvement large industry right academic institutions having turned 
unfortunate consequence amount hype surrounding different process improvement approaches conflict attempts assess true nature benefits achieved 
general observation majority reported case studies measurement driven process improvement claimed benefits largely centred reduction rework 
techniques fundamental process improvements remain unproven 

open problems change fields software measurement process modelling research unfortunately noticeable limitations achievements 
areas struggling meet potential particularly judged rate benefits seen industry 
significant research performed rigorous measurement statistical methods section lack sound empirical validation hampering progress 
open research problems fields remain time rombach 
research process improvement starting identify resolve current blocks industrial adoption measurement research 
basili software engineering laboratory significant highlighting need embed measures decision criteria basili 
critical current reported industrial success stories measurement driven process improvement defect programmes considered process corrections real process changes 
absence automated data collection analysis meant measurement process improvement approaches appear undergo significant diminishing returns 
significant step forward recognition important relationship measurement process modelling 
apparent contextual information measures plays valuable role meaning successful application 
example ibm chillarege notable links measures process models order perform corrections process giving opportunity automation richer view product process interaction 
increasing recognition software processes evolve meet changing circumstances way software product 
continuing need integrate knowledge measurement process modelling give improved understanding interaction role process improvement 
document stressed importance change critical factor systems development 
continued pressure organisations operate limits increasingly exposed risks change 
urgent need integrated proactive approach management inherently iterative evolutionary software process 
control processes need measures capable capturing dynamic iterative nature 
relatively little directly targeted developing measures capture dynamics software change 
number alternative mechanisms surveyed capture aspects change dynamics including change trend analysis ripple effect 
individually mechanisms give useful limited tools feedback analysis control change effects generally damage done 
suitable major process deviations correct minor process problems identify process improvements project 
hand useful provide models software dynamics give capability provide analytical potential aid understanding combined effects change predictive potential allow reasoning project behaviour affected alternative change decisions 
abdel abdel chan littlewood evaluation competing software reliability predictions ieee transactions software engineering vol 
se pp 

abdel hamid abdel hamid madnick software project dynamics integrated approach prentice hall englewood cliffs nj 
validation verification testing computer software computing surveys vol 
pp 

agresti agresti projecting software defects analyzing ada designs ieee transactions software engineering vol 
pp 

software maintenance approach impact analysis objects change software practice experience vol 
pp 

albrecht albrecht software function source lines code development effort prediction software science validation ieee transactions software engineering vol 
se iss 
pp 

andersen andersen industrial applications software measurements information software technology vol 
pp 

concurrent development process model ieee software vol 
pp 

baxter freeman tmm software maintenance transformation ieee software pp 

arthur arthur nance establishing software development process control technical objectives operational requirements foundation framework journal systems software vol 
pp 

azuma azuma mole software management practice metrics european community japan results survey journal systems software vol 
pp 

fuggetta picco modeling improving industrial software process ieee transactions software engineering vol 
pp 

baker baker bieman fenton gustafson melton philosophy software measurement journal systems software vol 
pp 
july 
basili basili software errors complexity empirical investigation communications acm vol 
pp 

basili basili weiss methodology collecting valid software engineering data ieee transactions software engineering vol 
se pp 

basili basili rombach tame project improvement oriented software environment ieee transactions software engineering vol 
pp 

basili basili viewing maintenance reuse oriented software development ieee software pp 
january 
basili basili musa engineering software management perspective computer vol 
pp 

baxter baxter design maintenance systems communications acm vol 
pp 

belady belady lehman program growth dynamics ed statistical computer performance evaluation academic press new york pp 

davis impacts life cycle models software configuration management communications acm vol 
pp 

halliday chillarege jones atkinson jasper lewis yonezawa process improvement defect data interpretation ibm systems journal vol 
pp 

boehm boehm brown characteristics software quality north holland 
boehm boehm software engineering economics prenticehall englewood cliffs nj 
boehm boehm understanding controlling software costs ieee transactions software engineering vol 
pp 

boehm boehm spiral model software development enhancement ieee computer vol 
pp 

critical look software capability evaluations ieee software vol 
pp 

briand briand basili thomas approach software engineering ieee transactions software engineering vol 
pp 

briand briand basili property software engineering measurement ieee transactions software engineering vol 
pp 
january 
littlewood new ways get accurate software reliability modelling ieee software 
brookes brookes mythical man month addison wesley reading ma 
card card agresti measuring software design complexity journal systems software vol 
pp 

chillarege chillarege halliday ray 
wong orthogonal defect classification concept process measurements ieee transactions software engineering vol 
pp 

assessment management software technical risk ieee transactions systems man cybernetics vol 
pp 

coleman coleman oman application software maintainability models industrial software systems journal systems software vol 
pp 

costello costello liu metrics requirements engineering journal systems software vol 
pp 

curtis curtis krasner shen building software models proceedings ninth international conference software engineering ieee computer society washington dc pp 

curtis curtis kellner process modeling communications acm vol 
pp 

dalal dalal mcintosh testing large software systems changing code ieee transactions software engineering vol 
pp 

practical view software measurement implementation experiences motorola ieee transactions software engineering vol 
pp 

controlling software projects management measurement estimation yourdon press new york 
deming deming crisis institute technology cambridge ma 
dion dion process improvement corporate ieee software vol 
pp 

duncan duncan software development productivity tools methods proceedings th international conference software engineering singapore pp 

commonsense approach process modeling ieee software vol 
pp 

model framework integration software metrics journal systems software vol 
pp 

modelling effort correct faults journal systems software vol 
pp 

fagan fagan advances software inspections ieee transactions software engineering vol 
se pp 

fenton fenton software metrics rigorous approach chapman hall london 
fenton fenton software measurement necessary scientific basis ieee transactions software engineering vol 
pp 

tools environments improve software process information software technology vol 
pp 

software cost models information management vol 
pp 

principles software engineering management addison wesley reading ma 
grady grady measuring managing software maintenance ieee software pp 

grady grady product analysis philosopher stone software ieee software march pp 

griss griss software reuse library factory ibm systems journal vol 
pp 

gulla gulla 
karlsson yeh change oriented version descriptions epos software engineering journal pp 
november 
halstead halstead elements software science elsevier 
halstead software science critical examination th international conference software engineering 
module connection analysis tool scheduling software debugging activities afips fall joint computer conference pp 

hansen hansen simulating software development processes ieee computer pp 
january 
software cost estimation information software technology vol 
pp 

henry henry kafura software structure metrics information flow ieee transactions software engineering vol 
pp 

henry henry defining implementing measurement software maintenance process journal software maintenance research practice vol 
pp 

humphrey humphrey characterizing software process maturity framework ieee software march pp 

humphrey humphrey making process improvement personal ieee software vol 
pp 

ieee ieee standard glossary software engineering terminology software engineering standards collection ieee cs press los alamitos calif imai imai key japan competitive success mcgraw hill 
sheppard system design metrics review perspective proceedings iee bcs conference software engineering se 
iso iso standard information technology software lifecycle processes international standards organisation international electrotechnical committee 
jaffe jaffe leveson heimdahl software requirements analysis real time process control systems ieee transactions software engineering march 
rgensen rgensen experience accuracy software maintenance task effort prediction models ieee transactions software engineering vol 
pp 

kafura kafura canning validation software metrics metrics resources proceedings th international conference software engineering london pp 


laprie software reliability trend analyses theoretical practical considerations ieee transactions software engineering vol 
september 
kemerer kemerer empirical validation software cost estimation models communications acm vol 
pp 

neural network approach early detection program modules having high risk maintenance phase journal systems software vol 
pp 

szabo exploring behaviour neural network software quality models software engineering journal vol 
pp 
may 
allen goel early quality prediction case study telecommunications ieee software january 
evaluation design metrics software engineering journal vol 
pp 

law critical review quantitative assessment software engineering journal march pp 

krasner krasner arnold ett lessons learned software process modeling system communications acm vol 
pp 

decision driven maintenance journal software maintenance research practice vol 
pp 

lederer lederer prasad causes inaccurate cost estimates journal systems software vol 
pp 

lehman lehman model large program development ibm systems journal vol 

lehman lehman software projects fail state art conference pergamon press 
lehman lehman programs life cycles laws software evolution proc 
ieee special issue software engineering pp 
september 
lehman lehman belady program evolution processes software change academic press new york 
lehman lehman software engineering software process support software engineering journal vol 

lehman lehman process improvement way forward th international conference advanced information systems engineering caise finland june lecture notes computer science eds 
lyytinen rossi 
lehman lehman laws software evolution revisited proc 
nancy october lind lind experimental investigation software metrics relationship software development effort ieee transactions software engineering vol 
pp 

quantitative monitoring software development time monitoring software engineering journal vol 
pp 

logothetis logothetis managing total quality deming taguchi spc prentice hall new york 
process cycle software engineering journal vol 
pp 
september 
environment evolution prism model changes ieee transactions software engineering vol 
pp 
may 
mayrhauser mayrhauser vans program comprehension software maintenance evolution ieee computer august 
jones holloway experiences defect prevention ibm systems journal vol 
pp 

mccabe mccabe complexity measure ieee transactions software engineering vol 
pp 

mccall mccall richards walters factors software quality vols ii iii rome air development center reports ntis ad 
root classification scheme software process modelling approaches information software technology vol 
pp 

mcdermid mcdermid ed software engineer book oxford butterworth heinemann 
mili mili mili mili reusing software issues research directions ieee transactions software engineering vol 
pp 
june 
mukhopadhyay mukhopadhyay software effort models early estimation process control applications ieee transactions software engineering vol 
pp 

munson munson detection programs ieee transactions software engineering vol 
pp 

musa musa theory software reliability application ieee transactions software engineering se pp 

musa musa malek software reliability measurement prediction application mcgraw hill 
myers myers art software testing new york wiley 
lyu experiment determining software reliability model applicability proceedings sixth international symposium software reliability engineering france pp 
october 
basili representing software engineering models tame goal oriented approach ieee transactions software engineering vol 
pp 

olsen olsen software rush hour ieee software september pp 

palmer palmer evans software risk management requirements risk metrics ieee international conference systems man cybernetics 
breuer software maintenance management model queuing networks journal software maintenance research practice vol 
pp 

torres software maintenance versus software evolution approach software systems evolution ieee symposium workshop engineering computer systems germany march 
parnas parnas criteria decomposing systems modules communications acm vol 
pp 

parnas parnas clements rational design process fake ieee transactions software engineering vol 
se pp 

curtis capability maturity model software software engineering institute carnegie mellon university 
performance effort estimating techniques current development environments software engineering journal pp 
september 
pfleeger pfleeger software metrics process maturity framework journal systems software vol 
pp 

porter porter selby empirically guided software development metric classification trees ieee software vol 
pp 

prieto az prieto az status report software reusability ieee software vol 
pp 
may 
putnam putnam general empirical solution macro software sizing estimating problem ieee transactions software engineering vol 
se pp 

reibman reibman reliability modelling overview system designers ieee computer april 
rombach rombach controlled experiment impact software structure maintainability ieee transactions software engineering vol 
se pp 

rombach rombach full life cycle control adding maintenance measurement sel journal systems software vol 
pp 

rombach rombach directions software process research advances computers academic press 
royce royce managing development large systems concepts techniques 
reprinted proceedings th international conference software engineering pp 

ieee computer society press los alamitos ca 
methodology validating software metrics ieee transactions software engineering vol 
pp 

shen shen yu identifying error prone software empirical study ieee transactions software engineering vol 
se pp 

shepperd shepperd design metrics empirical analysis software engineering journal vol 
pp 

shepperd shepperd products processes metrics information software technology vol 
pp 

shepperd shepperd critique metrics journal systems software vol 
pp 

sommerville sommerville software engineering addison wesley international computer science series 
change analysis step meeting challenge changing requirements ieee symposium workshop engineering computer systems germany march 
subramanian subramanian empirical analysis software effort estimate alterations journal systems software vol 
pp 

strategies tactics methods handling change ieee symposium workshop engineering computer systems germany march 
tate software size model ieee transactions software engineering vol 
pp 

metrics manage software projects computer vol 
pp 

error density size ada software ieee software vol 
pp 
january 
rner software faults spreading detection costs software engineering journal pp 
january 
yau yau stability measures software maintenance ieee transactions software engineering vol 
se pp 

yau yau design stability measures software maintenance ieee transactions software engineering vol 
se pp 

yu yu shen analysis software defect models ieee transactions software engineering vol 
pp 

