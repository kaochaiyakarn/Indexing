declarative procedural semantics logic programs przymusinski december revised march important difficult problems logic programming problem finding suitable declarative intended semantics logic programs 
importance problem stems declarative character logic programming difficulty largely attributed non monotonic character negation operator logic programs 
problem viewed problem finding suitable formalization type non monotonic reasoning logic programming 
introduce semantics logic programs class perf necessarily herbrand perfect models program show proposed semantics natural combines desirable features previous approaches time eliminating drawbacks 
positive program class perf perfect models coincides class min minimal models perfect model semantics shown equivalent semantics mccarthy circumscription equivalent remaining major formalizations non monotonic reasoning artificial intelligence reiter closed world assumption moore autoepistemic logic reiter default theory establishing closer link areas logic programming non monotonic reasoning 
define generalization sld resolution called sls resolution prove sls resolution sound complete respect perfect model semantics 
article appeared journal automated reasoning 
address department mathematics university texas el paso el paso tx 
mail uucp cs utexas edu contents notation definitions declarative vs procedural semantics discussion declarative semantics clark completion herbrand model semantics minimal model semantics positive programs perfect model semantics general programs procedural semantics appendix remaining proofs proof theorem proof proposition proof theorem proof theorems proof theorem logic programming introduced computer science important concept declarative opposed procedural programming mathematical logic 
logic programs logical negation rely non monotonic operator referred negation failure 
result problem finding suitable declarative intended semantics logic programs important difficult problems logic programming frequently discussed literature see lm abw vg bh gpp mi 
due non monotonic character negation operator problem viewed problem finding suitable formalization type non monotonic reasoning logic programming 
spite close relationship non monotonic reasoning logic programming research areas developing largely parallel tandem interaction fields expect 
possible explanation phenomenon fact traditionally declarative semantics logic programming non monotonic formalism developed clark called clark completion see ld 
clark formalism intuitive useful idea constructing completion program essentially replacing statements suitable iff statements 
unfortunately clark formalism sufficiently general applied realm logic programming play major role formalizing general non monotonic reasoning ai 
addition clark semantics considered researchers weak important drawbacks discussed literature see 
describe semantics class perf perfect necessarily herbrand models program approach leads natural intended semantics logic programs shown combine desirable features previously defined semantics time eliminating drawbacks 
results outgrowth earlier stratified logic programs initiated apt blair walker abw van gelder vg 
consider class positive logic programs conclude wellknown herbrand model semantics see important drawback call universal query problem caused fact herbrand models considered 
show universal query problem eliminated considering class min minimal models just unique minimal herbrand model demonstrate defined semantics retains advantages herbrand model semantics eliminating universal query problem equivalent model semantics existential queries 
address problem extending minimal model semantics class general logic programs 
abw apt blair walker independently van gelder vg see chandra harel ch naqvi introduced class stratified logic programs defined unique natural herbrand model stratified logic program argued model represent intended semantics programs 
przymusinski introduced class perfect herbrand models logic program showed stratified logic program exactly model coincides natural model basing semantics general logic programs unique perfect herbrand model causes difficulties discussed connection universal query problem 
show difficulties eliminated extending notion herbrand perfect model general logic program class necessarily herbrand models considering semantics determined class perf perfect models general logic program demonstrate positive program class perf perfect models coincides class min minimal models perfect model semantics generalization minimal model semantics 
important class existential queries perfect model semantics equivalent semantics generated unique perfect herbrand model perfect model semantics natural extension class disjunctive deductive databases see 
easily seen minimal model semantics equivalent semantics mccarthy parallel circumscription see mc mc mi show perfect model semantics proposed equivalent semantics mccarthy prioritized circumscription 
shown perfect model semantics equivalent remaining major formalizations non monotonic reasoning reiter default theory moore autoepistemic logic reiter closed world assumption see 
results establish closer link logic programming non monotonic reasoning underscore naturality proposed semantics 
relating logic programming closely non monotonic reasoning suggested literature see 
addressing problem procedural semantics show positive programs standard sld resolution negation failure sound complete respect minimal model semantics 
define called linear resolution selection function stratified programs show non floundering queries sls resolution sound complete respect perfect model semantics 
sls resolution natural generalization sld resolution linear resolution selection function definite programs class positive definite programs class stratified programs 
sls resolution powerful procedural mechanism sldnf resolution sound respect perfect model semantics 
extension results obtained called founded semantics see 
notation definitions general logic program just program mean finite set universally quantified clauses form lm atom positive negative literals see ld 
literals clauses positive say program positive definite 
alphabet program consists constant predicate function symbols appear countably infinite set variable symbols usual punctuation symbols connectives quantifiers 
assume equality predicate appear contain constants added alphabet 
language consists formed formulae obtained order theory 
formula called positive contain negation symbol 
herbrand base set ground atoms theory 
prolog convention names variables capitalized functions constants predicates written lower case program clauses commas constants identified functions arity zero 
formula resp 
denote existential resp 
universal closure general query just query mean conjunction literals form lm literals 
literals positive query called positive 
universally resp 
existentially quantified query called universal resp 
existential query 
clark equational theory cet see mean theory augmented equality predicate set universally quantified axioms called cet axioms cet 
cet 
cet 
cet 
xm ym xm ym function cet 
xm ym xm ym predicate cet 
xm different function symbols cet 
xm ym xm ym function cet 
term different containing axioms describe usual equality axioms remaining axioms called unique names axioms freeness axioms 
significance axioms logic programming widely recognized see ld lt consequence important role unification logic programming lemma due clark lemma suppose terms 
unifiable cet unifiable cet assume cet axioms satisfied considering theory consider extension cet cet equality axioms cet cet ensure assume equality predicate interpreted identity models cet 
result models cet identified precisely models equality predicate interpreted identity satisfies unique names axioms cet cet 
means models cet simply viewed subclass class models herbrand models equality interpreted identity satisfy axioms cet cet identify herbrand models cet 
view order simplify exposition continue talk models precisely models cet 
assume discussed formulae queries contain equality symbol 
assume domain closure axioms 
domain closure axioms combined unique names axioms tend reduce entire theory propositional case strong restriction unacceptable applications see gpp gpp 
herbrand interpretations usual identified subsets herbrand base 
models universe interpretation functions constants say extension predicate contained extension model called minimal distinct model follows known results bs model minimal model easy see minimal model cet iff minimal model model cet 
positive logic program exists exactly minimal herbrand model called herbrand model see ave 
declarative vs procedural semantics precise meaning semantics associated logic program know answer queries distinct closely interrelated methods semantics logic program defined 
declarative procedural 
declarative semantics logic program specified various ways common 
called proof theoretic associates order completion clark completion comp declares substitution correct answer substitution see ld query iff logically derived 
called model theoretic associates set mod models mod set minimal models unique herbrand model positive declares substitution correct answer substitution query iff satisfied models mod mod 
common feature definitions declarative semantics provide mathematically precise definition meaning independent procedural considerations 
combinations approaches possible see 
procedural semantics logic program usually providing procedural mechanism theory additional assumptions capable providing answers wide class queries 
example sld resolution provides computational mechanism positive programs positive queries see ld 
researchers agree logic programs clearly defined declarative semantics independent procedural implementation issues 
kunen puts logic component give declarative semantics language tells answer follows semantically 
user able understand semantics just logic detailed understanding implementation interpreter 
really key fact separates logic programming conventional procedural forms programming 
suitable declarative semantics logic programs procedural mechanism described produce answers accordance semantics 
performance mechanism evaluated describing behavior differs behavior prescribed declarative semantics 
words declarative semantics serve specification computational mechanisms cf 

natural point view logician solution problem finding appropriate declarative semantics logic programs obtained declaring correct answer substitution query iff follows logically various reasons unacceptable 
reason definition force implement full classical negation logic programs making query answering expensive impractical 
important reason really want classical negation logic programs 
want logic programs easy write comprehend possible free overwhelming amounts explicit negative information close natural discourse possible 
words want semantics logic programs determined commonsense meaning purely logical contents 
example information natural number natural number able derive non monotonic commonsense natural number fact clearly follow logically assumptions 
discussion declarative semantics section briefly discuss desirable features drawbacks successful semantics logic programs semantics clark completion herbrand model semantics 
restrict attention aspects relevant presentation 
clark completion declarative semantics logic programs called clark completion comp program 
clark completion obtained rewriting clause form lm terms containing variables clause lm replacing predicate symbol alphabet possibly empty set clauses appearing head single universally quantified logical equivalence 
clark approach founded natural idea common discourse tend statements really mean iff statements 
example may program describe natural numbers natural number natural number succ natural number theory weak 
imply say constant mary natural number 
really mind natural number 
succ natural number fact clark completion implies natural number mary 
success clark semantics due features possesses ffl clark completion natural easily intelligible definition 
ffl positive program positive formula derivable comp iff derivable positive programs comp introduce new positive information see ld 
ffl sldnf resolution prolog sound respect clark semantics positive programs queries recursion free programs complete see ld 
observe second property natural important positive programs 
non monotonic semantics logic programs considered built important premises imply formulae provable imply negation positive formulae provable 
obviously depending semantics set negated formulae varies 
consequently positive program add new positive information implied hand general logic program presence negative premises may result condition forcing new positive information introduced 
unfortunately clark completion result satisfactory semantics 
programs clark completion leads semantics appears weak 
problem known pointed literature 
illustrate examples 
suppose program add seemingly neutral clause natural number natural number appears newly obtained program semantics 
clark completion natural number 
natural number succ natural number longer follows mary matter natural number 

suppose program clauses bird tweety ly bird abnormal abnormal irregular irregular abnormal clauses merely state irregularity synonymous abnormality 
fact leads believe tweety abnormal justified expect tweety flies clark completion merely yields ly 
bird abnormal abnormal 
irregular follow flies 
hand clauses just clark semantics produces correct results 

van gelder suppose want describe vertices graph reachable vertex write program edge edge edge reachable reachable reachable edge clearly expect vertices reachable 
clark completion predicate reachable gives reachable 
reachable edge derived 
difficulty caused existence symmetric clauses edge edge 
described behavior clark completion bound confusing thoughtful logic programmer may wonder example addition seemingly harmless statement natural number natural number change meaning program 
explanation occur procedural nature fact added clause may lead loop 
idea replacing procedural programming declarative programming brought concept logic programming place procedural explanation rejected 
argued criticism clark semantics unfounded clark meant completed program comp considered real program program written programmer serve abbreviated form 
unfortunately great majority prolog programmers heard clark completion remaining small minority able write completed version programs surprised contents 
clearly programs logic programmers write reflect users intended meaning completions translations programs hidden user complex understand 
herbrand model semantics pointed section positive logic program unique herbrand model words unique minimal herbrand model ave considered represent intended declarative meaning motivation approach idea minimize positive information possible limiting facts implied making false 
example program number natural number succ exactly intended 
similarly herbrand model program edge edge reachable reachable exactly expect 
similar situation occurs programs herbrand model semantics intuitive properly reflect intended meaning positive logic programs 
important drawback caused fact herbrand models considered 
call universal query problem 
discussion wish point universal query problem new 
problem pointed literature see lloyd book ld pp 
different ways try rectify leading essentially different results extended domain assumptions extensions language 
far know problem possible solutions formally investigated compared 
problem important decided give name propose systematic formal solution appears satisfactory offer technical advantages possible approaches 
suppose program consists trivial clause 
herbrand model fp herbrand model semantics implies fact negative consequences positive formula implied herbrand model semantics violates principle new positive information introduced semantics positive programs pointed natural important requirement 
herbrand model semantics priori prevent standard unification computational mechanisms complete respect semantics 
ask query logic programming want answer question fact interested obtaining bindings substitutions semantics implies 
case semantics determined unique herbrand model ask expect simply answer indicating satisfied words signifying empty substitution correct answer substitution 
unfortunately standard unification computational mechanisms capable returning special case substitution 
argued logic programming concerned herbrand models general models motivated belief role logic programming answer existential queries known fact existential formula derivable universal theory satisfied herbrand models see 
argument partially correct 
reality logic programming concerned answering existential queries primarily concerned providing general bindings substitutions answers 
example program parent father parent mother grand parent parent parent ask grand parent expect obtain answers mother father mother mother signifying grand parent mother father grand parent mother mother words expect obtain general substitutions query holds result fact interested answers universal queries true grandparent mother father general models herbrand models general provide different answers illustrated case trivial program 
explains order provide declarative semantics logic programs herbrand models need considered 
minimal model semantics positive programs section assume positive logic program 
pointed section herbrand model semantics intuitive properly reflect intended meaning programs 
showed semantics important drawback called universal query problem caused fact herbrand models considered 
section show problem eliminated considering class minimal models positive program just considering unique minimal herbrand model avoiding universal query problem minimal model semantics equivalent herbrand model semantics existential queries 
positive queries sld resolution negation failure sound complete respect semantics 
minimal model semantics equivalent semantics mccarthy parallel circumscription providing close connection logic programming non monotonic reasoning ai 
give precise definitions 
definition positive logic program min set minimal necessarily herbrand models minimal model semantics mean semantics induced set min 
semantics sentence considered true iff satisfied minimal models case write min say substitution correct answer substitution query min 
consider example 
example suppose program consists clauses renowned physicist einstein president ford famous man renowned physicist famous man president able mathematician renowned physicist program different models 
einstein ford presidents renowned physicists able mathematicians 
models hardly describe intended meaning program imply ford physicist able mathematician einstein president 
fact inclined believe lack information indicates assume contrary 
recall assume cet axioms models considered fact models cet 
unique minimal herbrand model equivalently herbrand model equal physicist einstein president ford able mathematician einstein famous man einstein famous man ford properly interpret intended meaning far ground atoms concerned implies universal everybody famous famous man derived standard unification interpreters 
clearly positive formula derivable 
program minimal models common characteristics coincide model far ground atoms concerned 
result minimal model semantics provides ground information model semantics add new positive information 
hand semantics imply new universal negative facts president renowned physicist formalize claims 
need result obtained gelfond przymusinska przymusinski gpp showing positive existential queries negations minimal model semantics min equivalent herbrand model semantics particular result applies positive negative ground queries 
theorem gpp suppose positive logic program positive query 
min min example illustrates assumptions 
example assumption positive essential 
single clause min 
assumption query existential essential 
min 
assumption positive logic program essential nonpositive logic programs general unique minimal models cf 
section 
assumption models cet considered essential 
consists clauses positive ground query exist minimal models holds minimal models may corollary shows existential positive negative queries minimal model semantics min equivalent herbrand model semantics example shows may longer true negations queries 
corollary suppose positive logic program query 
min proof represented conjunction literals clearly min suppose represents unique model exist ground substitution 

positive theorem min 
negative atom 
theorem follows min min 
consequently min min results important confirm far existential queries concerned minimal models just unique minimal herbrand model produces exactly results 
proof shows query min iff ground substitution min 
hand follows previous examples theorem universal queries approaches longer equivalent 
minimal model semantics introduce new positive information avoids universal query problem pointed section herbrand model semantics property 
theorem suppose positive logic program positive sentence 
min positive formula implied min iff logically derived 
mentioned desirable property positive logic programs 
theorems yield important result showing positive queries sld resolution negation interpreted failure prove sound complete respect minimal model semantics 
recall sld resolution defined positive queries 
substitution fl general substitution mean exists substitution ff flff 
assume fixed computation rule selecting literals non empty lists literals see ld 
definition sld answer substitution see ld 
sld tree query failed branches infinite failure node equivalently sld answer substitution theorem soundness completeness sld resolution suppose positive program fixed computation rule positive query substitution 
min sld answer substitution ii min sld tree failed iii min 
sld answer substitution general proof parts iii follow immediately theorem known ld soundness completeness sld resolution positive queries stating positive queries exists sld answer substitution 
exists sld answer substitution general prove ii suppose min sld tree failed suppose exists sld answer substitution 
part min impossible 
suppose sld tree failed min 
theorem completeness result sld answer substitution impossible 
observe equivalence consequence ii iii 
notice universal query problem analogous result valid herbrand model semantics 
answer substitution produced sld resolution substitution 
clark semantics general weaker minimal model semantics analogous result true failure prove replaced finite failure prove cf 
section 
mc mccarthy defined notion parallel circumscription developed mc lifschitz 
parallel circumscription circ theory defined second order formula known semantics simplest case predicates minimized determined class min minimal models consequently theorem minimal model semantics positive logic program coincides semantics parallel circumscription sentence min circ choice minimal model semantics positive logic programs establishes clear relationship logic programming non monotonic reasoning ai 
minimal model semantics introduced context deductive databases minker mi form called generalized closed world assumption studied bs gpp bh 
sections minimal model semantics results obtained section generalized class general logic programs 
perfect model semantics general programs section define perfect model semantics extends minimal model semantics class general logic programs 
apt blair walker abw independently van gelder vg see chandra harel ch naqvi introduced class stratified logic programs defined unique natural herbrand model stratified logic program argued model provides natural intended semantics programs 
przymusinski extended notion stratified program class disjunctive deductive databases introduced class perfect herbrand models deductive databases 
showed stratified deductive database perfect herbrand model stratified logic program exactly model coincides model view result refer model unique perfect herbrand model stratified logic program 
definition perfect models idea assigning different priorities predicate symbols provided additional justification explanation naturality model natural logic programs disjunctive databases stratified perfect models 
fairly large class databases called locally stratified discussed 
przymusinski showed herbrand model stratified disjunctive database perfect iff model mccarthy prioritized circumscription analogous result logic programs pointwise circumscription obtained 
proven bf gpp ge pr suitable forms remaining major formalizations commonsense reasoning reiter default theory reiter closed world assumption moore autoepistemic logic equivalent perfect model semantics see detailed discussion 
semantics unique perfect herbrand model stronger clark semantics avoids difficulties discussed section caused fact clark semantics weak 
positive logic programs unique herbrand perfect model coincides herbrand model 
consequently perfect model semantics limited herbrand models necessarily suffer universal query problem 
show extend notion perfect herbrand model gen eral logic program class necessarily herbrand models demonstrate class perf perfect models general logic program describes natural declarative semantics combines advantages eliminates drawbacks previous approaches 
positive program class perf perfect models coincides class min minimal models perfect model semantics extends previously discussed minimal model semantics 
show perfect model iff model mccarthy prioritized circumscription relating semantics logic programming non monotonic reasoning 
example suppose know typical tends avoid advanced mathematics happens mathematician einstein physicist 
express facts general program follows avoids math mathematician physicist einstein program minimal herbrand models einstein physicist avoids advanced mathematics mathematician 
models capture intended meaning 
clearly 
placing negated predicate mathematician premises rule intended say general avoid advanced mathematics happen mathematicians 
reason believe mathematician inclined infer advanced mathematics 
minimal model corresponds intended meaning reason asymmetry easy explain 
clause logically equivalent clause negation mathematician avoids math models minimal models theory obtained replacing 
models provide suitable semantics assign different priorities predicates mathematician avoids math treating equally plausible 
program hand gives higher priority predicate mathematician predicate avoids math sense predicate mathematician higher priority minimization extension predicate avoids math 
easily imagine priorities reversed 
instance case program mathematician physicist avoids math physicist einstein says physicist specific evidence showing avoids mathematics allowed assume mathematician 
predicate avoids math higher priority minimization predicate mathematician 
shows relative priorities predicates program determined syntax clauses heads having lower priority negated premises 
analogous remarks apply non herbrand minimal models preceding example see set min minimal models general program may contain models properly interpret declarative meaning program need properly identify class minimal models properly describe intended meaning class perfect models described fulfill needs 
class perfect models subclass class minimal models enjoying natural properties 
view need consider necessarily herbrand models definition extends definition perfect herbrand models 
observed syntax program clauses determines relative priorities predicate symbols negative premises higher priority heads 
ii 
positive premises priority higher equal heads 
minimizing immediately results minimized 
consequently minimized time minimized 
formalize conditions ii introduce dependency graph program cf 
abw vg vertices predicate symbols 
symbols directed edge clause occurs head premises 
premise negative edge called negative 
define priority relations elements set predicate symbols follows resp 
iff directed path leading resp 
passing negative edge 
say priority lower ab say priority lower equal priority example program pr pr 
consequently pr 
defined priority relation predicates prepared define notion perfect model 
goal minimize extensions high priority predicates possible willing cost enlarging extensions predicates lower priority 
follows model new model obtained changing extensions predicates consider new model preferable addition new element extension lower priority predicate justified simultaneous removal elements extension higher priority predicate model considered perfect models preferable 
formally definition suppose distinct necessarily herbrand models general program universe interpretation functions constants 
denote em en extensions respectively predicate say preferable oe predicate set en gamma em non empty predicate symbol set em gamma en non empty 
say model perfect models preferable call relation oe preference relation models 
write oe sake simplicity definition priority relation corresponding definitions preference relation oe perfect models ordering set predicate symbols ordering set ground atoms 
result definitions generalize concepts local introduced 
suitable extension easily obtained approach outlined 
theorem relates perfect models minimal models 
theorem perfect model minimal 
positive program notions perfect model minimal model coincide 
proof logic program 
see perfect model minimal perfect model suppose minimal 
exists different model interpretation functions en em predicate symbol immediately implies oe impossible 
suppose positive minimal model perfect 
exists different model oe positive priority relation empty implies en em predicate symbol contradicts minimality example model example perfect 
physicist einstein avoids math physicist einstein mathematician know mathematician avoids math oe consequently perfect 
logic program perfect model example program minimal herbrand models fpg fqg oe oe models perfect 
cause peculiarity quite clear semantics relative priorities ground atoms consistent assigning priorities avoid priority conflicts cycles render semantics meaningless 
reflects idea underlying approaches apt blair walker van gelder naqvi negation referring defined relation definition circular van gelder puts avoid negative recursion 
words non existence perfect models example fact preference relation oe transitive caused fact priority relation irreflexive partial order observation leads definition stratified logic program 
definition abw vg general logic program stratified priority relation partial order 
theorem shows introduced notion stratified program defined equivalently follows theorem abw general program stratified possible decompose set predicates disjoint sets 
called strata clause am atoms stratum stratum stratum stratum stratum predicate symbol belongs particular decomposition fs satisfying conditions called stratification partial order mean irreflexive transitive relation definition decomposition determines priority levels strata lower level stratum denoting higher priority minimization 
general stratified program may 
definition perfect model depends priority relation set perf perfect models independent choice stratification 
observe lower strata higher priority minimization 
theorem confirms stratified programs preference relation models partial order peculiarities example occur 
theorem stratified program preference relation oe models partial order 
proof suffices show preference relation oe transitive 
partial interpretation models suppose gamma suppose gamma partial order assume maximal atom property 
suppose gamma gamma assume maximal atom property 
belong gamma contradiction 
gamma gamma gamma contradiction 
gamma gamma contradicts maximality suppose belong gamma gamma assume maximal 
obtain contradiction 
gamma maximal gamma belong contradiction 
gamma gamma contradicts maximality completes proof 
basic result states model stratified program subsumed perfect model exactly perfect herbrand model coincides natural model defined apt properties completely analogous corresponding properties minimal models herbrand model 
theorem basic model stratified program exists unique perfect model particular stratified program unique perfect herbrand model 
model coincides natural model proof proof theorem appendix 
define perfect model semantics general logic program 
definition general logic program perf set perfect necessarily herbrand models perfect model semantics mean semantics induced set perf 
semantics sentence considered true iff satisfied perfect models case write perf substitution called correct answer substitution query perf 
clearly follows theorem positive programs perfect model semantics coincides minimal model semantics 
theorem shows perfect model semantics defined stratified program theorem shows stratified programs perfect model semantics strictly stronger semantics defined clark completion 
proof need technical result showing perfect models supported 
notion supported model introduced bidoit hall bh apt abw 
notion model introduced bidoit hall bh 
notions defined appendix 
observe view fact perfect models supported supported models models clark semantics clark completion consistent stratified programs 
result proved apt abw 
proposition perfect model supported 
proof proof appendix 
theorem suppose stratified logic program 
sentence comp perf implies perfect model semantics strictly stronger semantics defined clark completion 
proof known see ave model clark completion comp program iff supported model cet 
proposition perfect model supported sentence satisfied models comp satisfied models perf 
see perfect model semantics strictly stronger semantics defined clark completion observe program consisting clause perf comp mc mccarthy defined notion prioritized circumscription developed lifschitz generalizes notion parallel circumscription 
suppose decomposition set predicates program disjoint sets 
prioritized circumscription circ logic program priorities defined second order formula semantics defined terms models prioritized circumscription see 
theorem shows semantics prioritized circumscription equivalent perfect model semantics similar result pointwise circumscription obtained lifschitz 
generalizes theorem 
theorem suppose stratified program fs stratification model perfect model prioritized circumscription circ 
consequently perfect model semantics coincides semantics prioritized circumscription sentence perf circ proof see appendix 
corollary suppose fs ft program model circ model circ 
proof definition perfect model depend choice stratification theorem model perfect model prioritized circumscription respect corresponding set priorities 
consequently models prioritized circumscription sets priorities identical 
results provide justification perfect model semantics underscore fact notion perfect model proper extension notion minimal model class general logic programs 
underscore relationship logic programming non monotonic reasoning ai 
gpp assumption domain closure axiom syntactic characterization perfect model semantics obtained form called iterated closed world assumption 
procedural semantics section define called sls resolution linear resolution selection function stratified programs 
sls resolution sound complete non floundering queries perfect model semantics 
sls resolution natural generalization sld resolution linear resolution selection function definite programs class positive definite programs class sake simplicity ignore variable predicates 
name suggested topor 
stratified programs 
sls resolution modification sldnf resolution obtained results generalize results obtained section minimal model semantics 
suppose stratified program set predicate symbols fs stratification atom stratum unique integer predicate symbol belongs stratum stratum 
recall goal clause literals 
write define stratum follows stratum empty kg 
example stratum stratum stratum 
assume fixed safe computation rule see ld rule selects possible exactly positive ground negative literal goal goal non empty selection possible computation rule cf 
lt 
ready define sls resolution 
definition definition sls trees induction stratum define notions sls tree success leaf failure leaf flounder leaf program goal stratum empty clause sls tree consists node 
leaf success leaf 
assume stratum sls trees defined goals strata define sls tree root node node immediate descendents successors obtained follows ffl empty immediate descendents success leaf ffl rule immediate descendents flounder leaf ffl literal selected positive immediate descendents goals obtained goal resolving variant program clauses literal general unifiers immediate descendents failure leaf apt points sls resolution generalization interpreter defined abw 
ffl selected literal negative ground atom easy verify stratum sls tree defined 
consider cases leaves failed immediate descendent gamma flg goal removed contains success leaf immediate descendents failure leaf immediate descendents flounder leaf 
standard definitions 
definition definition sls resolution sls tree successful success leaf empty node 
sls tree floundered flounder leaf 
sls tree failed leaves failed equivalently branches infinite failure leaf 
branch root success leaf successful branch called sls refutation substitution obtained composition corresponding general unifiers successful branch called substitution query say sls answer substitution partial branch sls tree root called sls derivation process constructing sls derivations called sls resolution 
branch called failed infinite ends failure leaf 
branch flounder leaf called floundered 
say query floundered sls tree goal floundered 
say substitution fl general substitution exists substitution ff flff 
leaf sls tree success leaf failure leaf flounder leaf sls tree successful floundered failed 
sls tree failed iff branches failed 
notice sls tree successful floundered failed tree successful floundered 
observe negative subgoals sls resolution ground effect answer substitutions 
observe special case positive program positive non empty goal stratum goal including negative literals stratum 
case sls resolution equivalent standard sld resolution second case equivalent sld resolution necessarily finite 
negation failure cf 
theorem 

example examples assume computation rule selects leftmost positive ground negative literal literal exists 
suppose suppose goal 
sls tree looks 
sls tree failed immediate descendent empty node sls tree successful 
leftmost branch failed flounder branches 
suppose goal 
sls tree looks 
leftmost branch tree infinite failed 
rightmost branch floundered 
remaining infinitely branches successful answer substitution 
tree successful floundered 
suppose 
sls tree 
sls tree successful node failed 
consequently branches tree infinite failure leaf shows failed 
prove theorem showing non floundered existential queries negations perfect model semantics perf equivalent unique perfect herbrand model semantics result generalizes theorem positive queries positive programs sls resolution coincides sld resolution case query non floundered 


theorem suppose stratified program safe computation rule non floundered query 
perf perf proof proof appendix 
result important confirms far existential queries concerned perfect models perf just unique perfect herbrand model produces exactly results long query floundered 
perfect model semantics perf avoids universal query problem 
observe theorem depend computation rule suffices know non floundered computation rule 
assumption non floundered essential example shows example fp query floundered perf theorems generalize theorem prove sls resolution sound respect perfect model semantics complete non floundered queries 
resolution generally possible properly handle non ground negative literals result sense expect see 
notice universal query problem analogous completeness result valid unique perfect herbrand model semantics 
theorem soundness sls resolution suppose stratified program safe computation rule query 
sls answer substitution perf correct answer substitution particular perf ii sls tree failed perf proof proof contained appendix 
theorem soundness completeness sls resolution suppose stratified program safe computation rule non floundered query 
perf iff exists sls answer substitution ii perf iff sls tree failed 
iii perf correct answer substitution iff exists sls answer substitution general proof proof contained appendix 
observe sls answer substitutions compositions general unifiers general substitutions condition ii expected holds sld sldnf resolutions 
example assumption non floundered essential 
shown example goal floundered 
obviously perf sls answer substitution 
show sls resolution powerful sldnf resolution defined ld 
particular shows sldnf resolution sound respect perfect model semantics 
theorem suppose stratified program safe computation rule query 
fl sldnf answer substitution fl sls answer substitution ii sldnf tree finite failed sls tree finite failed 
particular sldnf resolution sound respect perfect model semantics 
proof proof contained appendix 
examples show sls resolution strictly powerful sldnf resolution 
obviously related fact perfect model semantics strictly stronger clark semantics see theorem 
comments sls resolution relation sldnf resolution 

soundness completeness sls resolution respect perfect model semantics suggests sls resolution considered theoretical construct describing ideal sound complete query answering procedure stratified programs general queries similar sense negation failure see theorem ideal sound complete procedure positive programs positive queries 
apt consider sldnf resolution special effective variant sls resolution providing possible effective approximations sls resolution 
role sls resolution performance yardstick evaluate extent actual implementation measures ideal differs 
fact sls resolution general effective diminish theoretical value fact riemann integral gammax dx finite representation approximated diminish theoretical importance 

easy see suitable loop checking added sls resolution destroying completeness 
large classes stratified programs sls resolution subsumption check result finite evaluation trees implemented complete terminating algorithm 
case particular function free programs generally programs called bounded tree property see kt si 
obviously general effective terminating implementation sls resolution reasonably complete procedure including sld sldnf resolution possible 

defining sls resolution usual concerned properties sls tree particular method searching 
obviously order implement sls resolution appropriate computation rule chosen search strategy sls trees devised 

mentioned general resolution incapable properly handling non ground negative literals lt see ch discussion constructive negation 
example program ask goal receive positive answer stating equal unification unable produce answer cf 
consequently completeness non floundering queries essentially reasonably expect see 
observed shepherdson floundering fairly harmless form incompleteness occurs immediately notified able appropriately modify program query avoid clark shepherdson lloyd topor lt investigated problem query 
sls resolution essentially different sldnf resolution propositional positive programs 
ffl designed different semantics 
corresponds clark completion sls resolution corresponds perfect model semantics 
example program contains sldnf resolution give answer query sls resolution answers 
caused fact clark completion merely states perfect minimal model semantics implies ffl secondly opposed sldnf resolution sls resolution considers infinite trees failed undefined 
appears resolution logic programming limited trees finite sldnf resolution 
finite trees tightly related semantics clark completion pointed literature discussed section weak 
ffl thirdly sls resolution designed stratified programs defined induction level stratum goal 
prevents definition circular negative literals 
definition hand rely price paid complex definition see ld fact sldnf trees defined see ld 

theorem sls resolution sound complete respect perfect model semantics non floundering queries 
hand sldnf resolution complete respect clark completion comp ground non floundered queries 
example program example logically implies sldnf resolution provide answer query 
sldnf resolution known complete special cases program query positive really coincides sld resolution negation finite failure program involve recursion 
appendix remaining proofs introduce definition pre interpretation base ground substitutions 
definition see ld pre interpretation program mean non empty universe fixed interpretation functions including constants assume equality predicate interpreted identity floundering 
introduced notion allowed query showed allowed queries flounder 
satisfies cet axioms 
interpretation obtained selecting interpretation predicate symbols 
model mean interpretation clauses satisfied 
call assignment ff elements universe variables language ground substitution 
logical expression language formula term list terms ff ground substitution call eff variables substituted elements ff ground instance call set possible ground instances atoms language base pre interpretation just base 
easy see interpretations identified subsets easily verify interpretation model program iff ground instances clauses true definitions generalize notions ground herbrand base 
proof theorem suppose fs stratification suppose model pre interpretation set clauses heads involve predicate symbols belonging set elements base predicate symbols belong ji ji obviously 
subset ji denote restriction notice definition follows set atoms contained identify models subsets lemma plays crucial role proof theorem lemma suppose subset perfect model exists unique subset called minimal extension properties minimal model ii ji iii iv perfect model proof proof lemma analogous proof lemma 
observe definition depend model pre interpretation lemma construct induction subsets satisfying conditions perfect model jj ji 
just take 
suppose constructed 
define 
follows immediately lemma conditions satisfied 
clearly model perfect model observe constructed model unique perfect model pre interpretation model perfect implies stratified logic program exactly herbrand perfect model 
follows theorem unique model coincides natural model constructed apt proof proposition give definition supported models 
definition abw bf model pre interpretation supported ground atom exists ground instance clause head equal positive premises belong negative premises belongs model minimal supported 
showed models constructed proof theorem perfect models fact conditions iv lemma show induction perfect model supported 
perfect model minimal imply perfect model 
empty prove 
suppose inductive assumption satisfied 
construction proof theorem 
suppose ground atom belongs supported inductive assumption condition definition satisfied 
suppose belongs negative premises decided previous levels existed ground instantiation clause head equal positive premises belong negative premises belongs removing obtain smaller model contradicts minimality 
shows supported completes proof 
proof theorem showed models constructed proof theorem perfect models fact conditions iv lemma easy verify induction perfect model satisfies condition definition model prioritized circumscription 
consequently perfect model model prioritized circumscription 
prove model prioritized circumscription perfect induction obvious 
minimality condition definition model prioritized circumscription show models prioritized circumscription satisfy conditions iv lemma exactly way models constructed proof theorem 
shows model perfect 
proof theorems prove basic proposition proposition suppose safe computation rule query perfect model stratified program pre interpretation ff ground substitution 
sls answer substitution ground substitution fi ff fi qff 
ii converse implication valid non floundering query show theorems derived proposition 
proof theorem prove suppose sls answer substitution perfect model pre interpretation fi ground substitution 
ff fi 
proposition qff fi 
fi arbitrary shows perf 
prove ii suppose sls tree failed perf 
exists perfect model 
consequently ground substitution ff qff 
sls tree failed floundered proposition sls answer substitution contradicts fact sls tree failed 
proof theorem implications left right obvious 
prove implication right left assume 
exists ground substitution ff qff 
proposition sls answer substitution theorem perf perf 
prove implication right left ii assume perf 
perfect model ground substitution ff qff 
proposition sls answer substitution theorem perf contradicts 
proof theorem implications right left follow immediately theorem 
prove implication left right ii assume perf sls tree failed 
floundered exists substitution perf impossible 
prove implication left right iii assume perf 
fx different variables occuring 
clearly assume contains dummy clauses containing constants fc appear program query fl ground substitution obtained substituting 
clearly perf 
ff ffifl 
proposition sls answer substitution ground substitution fi ff fi ffifl constants appear relevant part substitution contain constants 
fi obtained fi replacing constants corresponding variables view equality fi ffi shows general answer substitution ffi 
prove implication left right suffices observe perf theorem sls tree failed floundered contain successful branch 
prove proposition 
proof proposition proof induction stratum 
empty perf identity substitution sls answer substitution shows ii satisfied 
suppose proposition proved queries stratum 
query stratum 
prove 
observe successful sls derivation leading substitution sequence goals fg gm qm general substitutions gamma obtained resolving variant program clause general unifier removing negative ground subgoal failed case corresponding substitution empty 
case formula known logically valid 
particular perf equivalently perf second case sls tree failed floundered 
stratum inductive assumption perfect models perf consequently condition holds 
gm qm empty perf qm transitivity obtain perf delta delta delta gamma clearly delta delta delta gamma sls answer substitution perf 
particular fi qff completes proof 
prove ii 
suppose non floundered qff 
sake simplicity assume consists exactly literal generalization general case straightforward 
consider cases 
case assume negative literal 
non floundered ground sls tree floundered 
stratum observe sls tree failed 
exist sls answer substitution contradicts consequently identity substitution sls answer substitution ii satisfied fi ff 
case ii 
assume positive atom aff 
suppose fs stratification stratum denote set ground instantiations clauses heads involve predicate symbols belonging positive premises true negative premises true denote set elements base true predicate symbols belong represent union non decreasing subsets defined follows 

fc clause having head positive premises construction perfect models proof theorem precisely minimality minimal extension easily follows aff satisfied belongs aff proof induction empty prove 
suppose ii proved elements belong assume aff belongs variant dm clause variables common ground substitution fl 
afl cfl 
fl 
fl 
fl belong gamma sake simplicity assume assume clause form possibly missing 
general case straightforward generalization 
observe aff cfl variables common general unifier ffi ground substitution affi ffi ffi 
ff fl ff fl denote union combination substitutions ff fl see gpp 
suppose example exists selected rule cases completely symmetric 
dfl dffi 
floundered query dffi 
inductive assumption sls answer substitution ground substitution fi fi exists consider ffi floundered ground sls tree floundered 
notice efl ffi 
ffi fi ffi ground efl ffi repeating argument proof case show implies sls tree failed 
combining sls trees obtain sls answer substitution ffi restrict variables fi ffi fi ffi 
ff completes proof ii proof proposition 
proof theorem proof theorem done straightforward induction stratum query stratum empty prove 
theorem proved stratum stratum sufficient notice essential difference sls resolution handling negative ground literals sls resolution require failed tree necessarily finite 
program literals encountered derivation property stratum inductive assumption complete proof 
acknowledgments author grateful krzysztof apt howard blair michael gelfond jean louis lassez vladimir lifschitz john mccarthy jack minker przymusinska rodney topor allen van gelder suggesting examples helpful discussions comments 
apt private communication 
abw apt blair walker theory declarative knowledge foundations deductive databases logic programming ed 
minker morgan kaufmann 
ave apt van emden contributions theory logic programming jacm 
bf bidoit froidevaux minimalism subsumes default logic circumscription stratified logic programming preprint 
bh bidoit hull vs minimalism deductive databases proceedings acm sigact sigmod symposium principles database systems cambridge mass march 
bs siegel saturation nonmonotonic reasoning closed world assumption artificial intelligence 
ch chandra harel horn clause queries generalizations journal logic programming 
ch chan constructive negation completed database proceedings logic programming conference seattle wash 
clark negation failure logic data bases gallaire minker eds plenum press new york 
etherington reasoning incomplete information 
investigations non monotonic reasoning phd thesis dept computer science university british columbia 
etherington mercer reiter adequacy predicate circumscription closed world reasoning computational intelligence 
fitting kripke kleene semantics logic programs journal logic programming 
gabbay modal provability foundations negation failure preprint 
gallaire minker nicolas logic databases deductive approach computing surveys 
ge gelfond stratified autoepistemic theories proceedings aaai seattle washington august 
gpp gelfond przymusinska przymusinski extended closed world assumption relationship parallel circumscription proceedings acm sigact sigmod symposium principles database systems cambridge mass march 
gpp gelfond przymusinska przymusinski relationship circumscription negation failure artificial intelligence print 
gpp gelfond przymusinska przymusinski minimal model semantics vs negation failure comparison semantics proceedings acm sigart international symposium methodologies intelligent systems torino italy 
jaffar lassez 
lloyd completeness negation failure rule ijcai karlsruhe 
jaffar lassez 
maher issues trends semantics logic programming proceedings iclp london 
kt kemp topor completeness top query evaluation procedure stratified databases proceedings logic programming conference seattle wash 
kunen negation logic programming logic programming 
kunen answer sets negation failure proceedings iclp melbourne 
lm lassez 
maher optimal fixpoints logic programs theoretical computer science 
lifschitz declarative semantics logic programs negation foundations deductive databases logic programming ed 
minker morgan kaufmann 
lifschitz computing circumscription proceedings ijcai los angeles 
ld lloyd foundations logic programming springer verlag 
ld lloyd foundations logic programming springer verlag second edition 
lt lloyd topor making prolog expressive journ 
logic programming 
lt lloyd topor basis deductive database systems ii logic programming 
mc mccarthy circumscription form non monotonic reasoning artificial intelligence 
mc mccarthy applications circumscription formalizing common sense knowledge aaai workshop non monotonic reasoning 
mi minker perspectives deductive databases university maryland tech 
report 
mi minker indefinite data bases closed world assumption proc 
th conference automated deduction springer verlag 
naqvi logic negation database systems preprint 
pr przymusinska relationship autoepistemic logic circumscription stratified databases proceedings international symposium methodologies intelligent systems charlotte october 
przymusinski declarative semantics stratified deductive databases logic programs foundations deductive databases logic programming ed 
minker morgan kaufmann 
przymusinski constructive negation logic programming appear 
przymusinski non monotonic reasoning vs logic programming new perspective formal foundations artificial intelligence eds 
partridge wilks cambridge university press appear extended relationship non monotonic reasoning logic programming proceedings aaai st paul pp 

przymusinski valued non monotonic formalisms logic programming appear 
przymusinski logic program natural stratification iterated fixed point model appear 
reiter logical reconstruction relational database theory conceptual modeling brodie eds springer verlag 
reiter closed world data bases logic data bases gallaire minker eds plenum press new york 
si seki itoh query evaluation method stratified programs extended cwa proceedings logic programming conference seattle wash 
shepherdson negation failure comparison clarke completed data bases reiter closed world assumption journal logic programming 
shepherdson negation failure logic programming 
shepherdson negation logic programming foundations deductive databases logic programming ed 
minker morgan kaufmann 
van emden kowalski semantics predicate logic programming language journ 
acm 
vg van gelder negation failure tight derivations general logic programs foundations deductive databases logic programming ed 
minker morgan kaufmann 
