expressive power declarative programming languages matsushita submitted degree doctor philosophy university york department computer science october thesis investigates aspects expressive power declarative programming languages 
widely accepted definition expressive power programming languages 
literature expressiveness may mean power describe algorithms describe computations check types presenting clearer idea expressiveness programming languages part aim research 
concentrate expressive power declarative languages languages highest level abstraction 
people argue relative expressiveness declarative languages 
declarative paradigms logic functional programming 
define compare expressive power languages belonging different paradigms order compare expressive power logic functional languages translation schemes subsets prolog haskell defined 
translation aim preserve structural correspondences possible 
doing compare expressive differences assessing amount extra programming required 
course translation exercises define translation scheme mode annotated prolog haskell including translation cut operator prolog declarative counterpart go statements imperative languages 
examine accepting power subsets prolog power express language recognisers 
richer subsets accept complex formal languages chomsky hierarchy 
main result research accepting power prove logic programs unary predicates unary functors accept exactly set regular languages 
result strong theoretical interest study relationships syntactical complexity logic language related automata 
contents evolution programming languages 
expressiveness programming languages 
declarative languages expressiveness 
contributions 
structure thesis 
literature review expressive power extended languages 
programming language extension 
translation scheme 
macro expressibility 
comparison arbitrary pairs languages 
expressibility abstraction context 
definition language 
operational equivalence 
abstraction preserving reduction 
summary 
functional counterparts logic programming techniques techniques counterparts 
backtracking list success technique 
definite clause grammars parser combinators 
difference list lambda abstraction 
meta logical operators higher order functions 
clause manipulation continuation passing style 
cut operator 

concluding remarks 
functional translation moded prolog moded logic language 
syntax 
moded constraint 
translation list comprehensions 
single clause predicates 
negation 
linearity problems 
multiple clauses 
partially defined predicates 
translation cut 
cut clause 
pruning solutions subsequent clauses 
removing outer list structures 
motivation 
single valued predicates non failing predicates 
translation rules single valued predicates 
implementation notes examples 
implementation notes 
examples textbook 
discussions 
related 
textual complexity computational complexity 
summary 
functional translation scheme logic programs translation unary logic programs 
general translation scheme 
translation unit clauses 
translation non unit clauses 
negation 
removing inner brackets 
summary translation 
translation unary string logic programs 
translation goals 
translation unit clauses 
translation non unit clauses 
continuations 
matchc 
summary 
discussion 
residue unification 
logical variables 


accepting power unary string logic programs preliminaries 

rus 
finite state automata 
deriving rus program fsa 
derivation rus program 
verification derivation 
deriving fsa program 
construction 
interpretation body literals 
construction 
verification construction 
discussion summary 
expressiveness rus 
expressive power answer set 
different types correspondences 
summary 
binary string logic programs bs describe turing machines 
turing machines 
bs representation turing machines 
restricted bs describing npda 
non deterministic pushdown automaton 
bs description npda 
extension multiple terminal symbols clause heads 
extension ii terminal symbol clause body 
discussion 
complexity languages language acceptors 
context free grammar possible extension 
simultaneous extension 
mixed languages 
summary 
summary accepting power logic languages 
accepting power 
accepting power bs 
remarks accepting power 
logic computation functional languages 
experimental translation practical logic program 
translation scheme moded prolog 
non ground computation 
summary translation exercises 

summary 
bibliography list figures syntax wm prolog 
tree 
literals trunk tail form translation 
syntax language 
example translations 
syntax predicate language 
functional terms 
function match 
function 
function 
function match 
matchc continuation passing style 
syntax 
syntax rus 
dfa accepting strings containing number rus program 
program 

program 

step iteration 
final graph 
syntax language bs 
syntax bs state sym disjoint sets names 
syntax bsc term disjoint sets names 
completed received help encouragement friends york 
person name support supervisor dr colin runciman 
years ago just came york introduced realm declarative programming giving range exercises append reverse great educator logic functional languages 
impressed astonishing patience proof read awful english drafts 
imagine finishing degree academic personal support 
declaration chapter different form dr colin runciman joint author fuji international workshop functional logic programming 
part chapter th international workshop functional logic programming 
chapter evolution programming languages advent electronic computers programming languages various levels devised 
ffl machine languages assembly languages perfect ability control hardware 
programmers specify atomic action computer resulting programs hard understand human beings 
chance re program computer 
languages stick strongly computers 
ffl imperative languages provide simple abstraction mechanisms allow programmers write single statement assignment jump sequence machine codes 
high level imperative languages enable programmers write readable re usable programs 
programmers specify computational step algorithms want execute 
ffl declarative languages describe algorithms abstractly sequences assignments jumps 
declarative programmers precisely describe want compute specifying component computations 
compilers automatically break description problem sequence imperative commands achieve result 
transition designers gave extra power abstraction programming languages 
power abstraction programs written new language drastically shorter older languages 
programmers successively able concentrate problems disturbed irrelevant details 
programming language evolution process enriching abstraction power machine code imperative languages declarative languages 
language criteria today range high level programming languages belonging various paradigms survive fortran pascal prolog ml people managing software projects choose intuitively languages appropriate problems 
fact researchers suspicious designing single language applications 
want choose language depending problem want solve 
obvious language best describe problem 
programming project time point programmers choose programming language 
criteria choose programming languages practical 

availability compiler available target machine 
machine languages hardly application software 

understandability software development projects include team programmers programs written language easy understand debug 

verifiability program written language easy prove correct 
safety critical systems important characteristic 

efficiency compiler produce fairly efficient object code 
real time systems speed critical 

portability desirable language compiler run various computers 
software system includes computer necessity 
criteria applicable designing programming languages language designers trying invent powerful programming languages 
expressive power language expressiveness important criterion language design somewhat different criteria languages previous paragraph 
argue expressiveness experimental language known handful researchers 
may contain cryptic notations demanding programmers lots brain effort 
written practical program language 
compiler language may produce inefficient code 
worse may compiler interpreter 
may run single specific computer 
despite disadvantages designer claim language enormous expressive power 
felleisen states literature programming languages contains abundance informal claims expressive power programming languages 
widely accepted formal definition expressiveness programming languages 
expressive power programming languages expressiveness programming languages programming language system formal notation expressing algorithms readable machines human beings spectrum language aspects human side machine side 
criteria previous paragraph discuss connection expressiveness programming languages 
abstraction promotes expressiveness programs written machine languages hard understand programs contain details interest programmers 
high level imperative languages hide details 
watt writes high level languages called allow algorithms expressed terms closer way conceptualise algorithms heads 
imperative programs easier understand machine code ones reason programs terms assignments jumps distracted implementation details statements 
similar arguments imperative declarative languages seen 
high level imperative languages provide ways encoding instructions imperative programmers need give machines recipes solve problems 
imperative programs describe problems describe solutions problems 
declarative languages program precise statement answer 
concentrate problem worrying solve sequential machine 
individual steps answer abstracted resulting clear concise programs 
familiar imperative languages may find difficult understand declarative programs constructs indicating assignments jumps declarative programs 
start thinking terms functions predicates declarative programs clearer concise imperative counterparts 
crucial point giving old scheme 
level language coincides level conceptualise problem language expressive 
expressiveness consistent easy reason 
abstraction may hinder expressiveness arguments suggesting contrary abstraction may hinder expressive power 
example high level language expressive programmer peculiar reason tries specific machine register 
may able specify registers high level imperative language course machine language 
expressiveness depends programmers want machine 
abstraction may enhance verifiability way abstraction reduces expressive power 
structured programming enhanced program proof imposing structural restriction programs 
replace go statements appropriate conditional blocks resulting programs easier prove correct 
carefully sparingly go statements known effective produce concise clear programs 
knuth wrote kinds programming situations go statements harmless desirable 
ease proof obtained giving part expressiveness 
example showing conflict expressiveness verifiability call name parameter passing scheme formulated hoare logic 
call name scheme language powerful proofs difficult 
expressiveness related abstraction discussed expressive power connection language abstraction 
languages level abstraction may different expressive power 
felleisen compares equivalent programs written pure scheme purely functional full scheme assignments 
full scheme expressive pure scheme describing global counter assignment statements 
try modify way counter manipulated pure scheme version updated occurrence counter scattered program rewrite place full scheme version 
addition assignment destroys referential transparency enable describe state change conveniently 
papers comparing expressive power different lisp dialects mutable data 
pippenger shows functions computed constant amortised time assignment take omega gamma log steps eager language assignments 
addition mutable data reduces order amount computation 
bird argues computation done efficiency mutable data lazy evaluation 
single functional language may different expressiveness depending evaluation scheme 
pay attention points 
firstly scheme example lisp example languages level abstraction 
expressive power caused hiding details case looks similar argument go statements structured programming constraint gives rise additional expressive power 
secondly lisp example expressive power refers computational power 
language expressive easy reason obtain efficient program 
temporary definition expressiveness far discussed language expressiveness means 
arguments expressive differences languages belonging distinct abstraction levels may conjecture programming language expressive programmer identify direct representation concepts reasons problem 
expressiveness strongly depends level programmers thinking 
trends language design helped forced people think level 
conjecture satisfactory 
explain expressive differences languages abstraction level 
suit usage expressiveness computational efficiency 
deficiencies come examine declarative languages discuss expressive power declarative languages 
declarative languages expressiveness assuming expressiveness mainly comes abstraction possible claim declarative languages expressive languages lower abstraction levels 
declarative languages declarative programming paradigms logic programming functional programming 
stem different theoretical bases order predicate logic lambda calculus 
deduced abstraction 
logic programmers build problems terms predicate definitions functional programmers describe problems function definitions 
case way obtain results implicit underlying computation scheme 
temporary definition expressiveness explain expressive differences declarative paradigms 
thesis try obtain finer definition expressiveness declarative languages investigating issues 
compare expressiveness logic functional languages 
measure expressiveness logic languages 
comparing expressiveness pair languages describe computation programs similar textual complexity may say languages equally expressive 
program text seen tree generated signature language possible compare programs size trees 
compare languages ability interpret program language counterpart 
order avoid turing tar pit need proper restrictions translation schemes 
order assess relative expressiveness logic functional languages define range translation schemes logic functional languages whilst trying preserve original program structure possible 
measuring expressiveness aspect investigation establish new measure absolute expressiveness 
measure expressiveness think ability accepting formal languages various levels chomsky hierarchy 
logic program function symbols describe infinite data 
start restricted language successively augment extra programming constructs examine class formal language logic program accept 
contributions main contributions investigation 
experimental translation practical logic program functional language programming techniques thought specific logic programmers natural functional counterparts 
defining translation schemes cut operators major obstacles 

defined translation scheme moded prolog containing cut operators haskell 
cut operator prolog hard translate provides mechanism controlling computational sequence go statements imperative languages 
logic predicates behave functions moded translate cut operators connection list comprehensions 

defined translation schemes subsets prolog haskell preserving structural correspondences extra functions 
languages belonging different paradigms may compared expressiveness extending translation schemes obtained 

logic program including unary predicates unary function symbols accepts exactly regular sets 
logic language unary predicates unary function symbols contains minimal logic programs capable accepting infinite languages 
class languages corresponds exactly class regular sets theoretical interest 

shown small logic language containing binary predicates unary functors powerful describe turing machines subset accept context free languages 
structure thesis chapter reviews papers discussing expressiveness programming languages directly 
papers propose distinct formal ways identify expressive differences quite similar languages language extension 
languages different syntax semantics formal treatment expressive differences quite difficult may adopt empirical style investigation chapter 
chapter study correspondences prolog haskell taken representatives logic functional programming systems 
languages belong family declarative languages different syntax computation schemes 
aim find correspondences languages 
logic programming constructs functional counterparts sought examined 
study correspondences functional logic programming systems logic programming cause major difficulty translating logic programs functional ones 
chapter describes functional translator moded logic programs logic predicate annotated input output modes 
translator converts logic predicate function 
list comprehensions haskell shown accommodate multiple solution nature logic predicates controversial cut operator prolog shown translatable connection list comprehensions 
chapter explains translation scheme restricted class logic programs functional programs 
source language contains unary string logic program predicate functor argument 
need sorts functions tester generator arising modes predicate parameters 
translation scheme ends nearly translation logic clauses equations 
aim exercise minimise residual unification translation scheme 
trying define set combinators analogous parser combinators write functional programs writing logic clauses different system notation 
chapters examine different aspect expressive power programming languages 
chapters formally investigate expressive power subsets prolog potential ability describing language acceptors 
chapter discusses unary string logic programs 
explained proved accepts exactly regular languages 
subset called regular unary string language rus equivalent regular set involved proof rus easily seen equivalent regular grammars 
difference rus power textual conciseness discussed 
chapter extend source language predicate arguments binary string logic language 
logic predicates allowed arguments describe turing machines type language chomsky hierarchy 
big jump just additional argument 
csl cfl gone 
syntactic restrictions bs just powerful accept cfl csl discussed 
chapter discusses concludes 
chapter literature review discussed expressiveness programming languages comes 
expressiveness languages strongly connected abstraction power languages 
cases languages expressive programs 
widely accepted definition expressive power programming languages 
especially compare declarative languages expressiveness exploit idea abstraction explain difference 
need tools compare languages abstraction level 
situation complicated declarative languages belong distinct paradigms 
suppose compare function definition append ys ys append xs ys append xs ys predicate definition append append xjxs append xs zs definitions structural similarity function append computes part results obtainable predicate append 
draw little kind comparison 
proceed fast 
comparing languages distinct computation schemes need survey measure compare expressiveness formal ways 
range papers discussing expressive power programming languages published 
examine expressive power translations 
boer compares languages embedding 
investigates reasonable restrictions translator languages decoder translator observables languages avoid vacuous equality 
fehr compares type free concepts definability functions objects typed concepts fix point operators 
riecke kfoury discuss translations pcf different parameter passing schemes 
fleck exhibits case study different declarative languages functional logic languages solving sample problem 
chapter discusses works dealing expressive power programming languages directly 
order gain insight language expressiveness defined compare language expressiveness rigorous ways review felleisen treatment programming languages formal systems 
felleisen discusses cases newly added programming constructs may add extra expressive power programming language 
need framework compare languages established distinct foundations 
mitchell proposes way compare expressive power languages translation scheme calls abstraction preserving reduction 
impose similarity languages 
expressive power extended languages felleisen considers compare similar languages extension 
example pair untyped lambda calculus language obtained adding constructs 
example extended language powerful original replaced cases direct substitute new program ming construct original language 
case extended language strictly expressive original 
felleisen target define precise conditions new programming constructs directly expressible original language give extra expressive power 
original language universal possible interpret extra construct original language sense languages equal expressiveness 
turing tar pit 
avoid vacuous equivalence necessary show new construct expressible original language destroying original program structure 
programming language extension felleisen defines programming language variant kleene formal system 
kleene defined range conditions newly added symbols expressed original formal system 
programming language new programming constructs treated formal system new symbols theory eliminable symbols applied prove new programming constructs expressible programming language 
definition programming language programming language defined triple phrase prog eval ffl phrase set terms freely generated set functors ffl prog non empty subset phrase ffl eval predicate prog program prog eval holds iff terminates 
predicate eval characterises subset prog member terminates 
operational semantics observes termination avoiding unnecessary restriction set languages 
languages simple observable data distinguish termination different observables appropriate contexts 
language extended adding set new programming constructs 
language extension conservative program new programming constructs behaves exactly way original language 
definition conservative extension language ff conservative extension ffl functors form subset functors contain ff ffl phrase subset phrase contain ff ffl prog subset prog contain ff ffl eval restriction eval prog condition means extended language expressive original 
translation scheme felleisen examines conditions new constructs expressible original language translation scheme oe mentioned earlier claim expressibility new constructs 
restrictions oe translation preserves program structure 
felleisen requires oe homomorphic programming constructs original language definition translation scheme oe satisfy conditions 
program ness oe translates prog prog homomorphic oe homomorphic programming constructs constructs arity expressions extended language oe oe oe oe preserve termination oe translates terminating programs terminating programs condition means extended language expressive original 
combined conditions conservative extension languages equivalent expressive power 
furthermore translation cause structural change construct original language 
phrases having new programming constructs outermost constructors may changed 
felleisen investigates conditions mapping oe possible 
operational equivalence conditions oe indicate phrase having outermost constructor translate phrase indistinguishable original 
phrases indistinguishable replacement phrase program change termination behaviour program 
programs called operationally equivalent 
identify operationally equivalent phrases need concept program context 
definition program context phrase language program context ff program hole program phrases operationally equivalent program contexts ff program terminates 
felleisen expressibility theorem relies operational equivalence 
theorem expressibility ff conservative extension mapping oe homomorphic functors translating programs programs oe holds phrase express functors theorem asserts phrase having outermost constructor translates operationally equivalent phrase expressible macro expressibility expressibility defined far translations phrases having new constructs outermost functor may arbitrary structure 
newly added constructor program structure completely lost oe 
call programming construct syntactic sugar equivalent phrase preserves compositional nature construct translation built set translations arguments connected programming abstraction 
felleisen calls stronger restriction translation scheme macro expressibility 
definition macro expressibility ff conservative extension expressible syntactic abstraction oe oe oe oe macro expressible corresponding theorem macro expressibility theorem macro expressibility ff conservative extension mapping oe homomorphic functors translating programs programs syntactic abstraction oe oe oe macro express macro expressible translation scheme oe homomorphic constructors newly added constructors macro expressibility stronger theorem non expressibility derived 
theorem states extension language provides extra expressiveness may destroy operational equivalence original language 
theorem ff conservative extension operational equivalence relations language 

operational equivalence relation restricted equal operational equivalence relation jl expressed 
cases expressed new programming constructs affect operational equivalence jl 
additional programming construct distinguishes previously equivalent expressions original language extended language strictly powerful original 
second part theorem indicates change operational equivalence smaller language sufficient condition non expressibility necessary 
felleisen proves showing extension calculus having base types arrow types adding standard head tail cons functions expressive original language destroy equivalence original language original language new functions 
comparison arbitrary pairs languages precisely describes way comparing language conservative extension felleisen admits theory weak compare arbitrary pairs languages 
languages extends compared find third language conservative extension 
theorem macro expressiveness conservative extension macro express contains programming construct express contains expressive existence common extension imposes strong limitation choosing quite similar languages want obtain interesting comparison 
expressibility abstraction context mitchell proposes different expressiveness theory expressive power pair languages compared 
contrast felleisen theory relationship languages assumed theory applied arbitrary pairs languages 
starts informal claim language expressive translation programming construct mapped essentially equivalent programming construct claim indicates translation respect compositional structure define translation scheme precise meaning essentially equivalent programming constructs 
mitchell defines translation scheme calls abstraction preserving reduction homomorphic programming constructs source language preserves observational equivalence 
riecke terms equationally fully translation 
reduction expressive definition language mitchell gives different definition programming languages felleisen 
definition programming language programming language quadruple eval gamma ffl set expressions ffl set observables ffl set program contexts ffl eval gamma 
operational semantics 
definition program language expression 
observable printable expression language 
expression language reduced observable language 
operational semantics eval gamma 
theta partial function expressions observables 
program context expression subexpression replaced hole meta variable abstraction 
program contexts assumed total functions expressions expressions 
program formed operational semantics eval gamma 
considered defined program 
operational equivalence define phrase essentially equivalent mitchell uses operational equivalence expressions 
way distinguish expressions put expression possible program contexts run programs compare results 
expressions give results program contexts terminate observable diverge expressions observationally equivalent 
definition observational equivalence expressions observationally equivalent obs program context eval gamma 
eval gamma 
observational equivalence language depends set possible programming constructs language 
mitchell gives example language pair constructor cons selector operators st snd 
way distinguish pairs examining elements pairs language equivalent having value pair 
augmented selectors pairs equivalent corresponding elements equivalent 
abstraction preserving reduction definition language especially program context concept operational equivalence mitchell defines translation scheme indicates expressive equality languages 
translation abstraction preserving translation respects compositional character programs preserves operational equivalence equivalence expressions 
definition abstraction preserving reduction reduction abstraction preserving expressions obs obs obs condition reduction compositional programming constructs condition forces translation preserve equivalence equivalence expressions 
existence abstraction preserving translation assures source language powerful target language discussed section 
order recognise abstraction preserving translations need concept abstraction context relies operational equivalence 
definition abstraction context context abstraction context operationally distinct expressions obs difference obscured 
contexts indicating equivalence wrapped distinguish expressions obs 
lemma explains abstraction preserving nature reduction 
lemma suppose language abstraction context abstraction preserving reduction 
abstraction context obscures difference lemma asserts translation abstraction context expressions abstraction context obscures difference translations original expressions 
reduction abstraction preserving 
mitchell requires mapping compositional constructors original language resulting translation satisfies macro expressibility felleisen sense 
mitchell approach exploited compare arbitrary pairs languages abstraction preserving reduction forces languages structurally close 
summary felleisen gives precise conditions newly introduced functor expressible language 
functor translatable term operationally indistinguishable new functor translation scheme homomorphic functor original language 
language extension chapter bs may non example felleisen theory resulting strictly expressive language 
central idea mitchell translation scheme abstraction context obscures differences distinguishable expressions 
abstraction contexts mapped abstraction contexts translation scheme compositional program context preserve operational equivalence equivalence 
translation scheme powerful tool expressiveness theory structure preserving nature important constraint 
chapter translation schemes defined respecting logical connectives predicates 
difficulty applying theories translation schemes prolog haskell sections logic programs compositional control structure 
connectives implication conjunction 
order 
may reason theoretical papers referred chapter dealing translations functional languages 
order compare expressiveness logic functional languages start empirical study chapter 
chapter functional counterparts logic programming techniques surveying entire range programming languages systems logic programming functional programming surely appear similar ways 
origins mathematical ideas design computing machines 
declarative offering programming style quite removed principle low level store jump model conventional imperative languages 
paradigm quite distinctive programming techniques 
impression textbooks discuss paradigms depth 
chapter look techniques regarded part distinctive repertoire logic programmer 
point counterparts techniques available functional programmer tools higher order functions lazy evaluation 
claims modest 
offering new translation principle 
specific techniques original 
declarative programmers versed correspondences wider development fruitful avenue 
chapter specific context 
prompted experience translating moderately large logic program source lines functional language 
application program transformation system 
shall system time time source illustration 
original system programmed sicstus prolog translation written haskell 
chapter adopt languages means expression logic functional programs respectively 
rest chapter divides follows 
section discusses different aspects logic programming technique counterparts functional language 
section considers translation cut operator haskell 
section discusses prolog section concludes 
techniques counterparts backtracking list success technique logic programs predicate procedure definitions involve clauses specific call procedures clause may match 
procedures yield multiple results may ways satisfying goal may result different bindings terms variables 
hand body instance earlier clause fails failure occurs context procedure called execution may need backtrack consider alternatives 
standard introductory example member 
member xs member xs 
goal member potential results binding different element list 
clause binds recursion 
leads failure calling context backtracking leads recursive clause solutions 
functional programs function definitions may involve equations equation applies call 
reduction equation leads result backtracking 
wadler points result function list regard items list multiple results lazy evaluation provides counterpart backtracking 
computation list item context demands 
empty list represents failure list concatenation serves disjunction alternatives 
returning member example direct idea leads member member xs member xs example ended identity function 
member applications eliminated altogether equation member xs xs typical situation backtrack necessary parsing context free languages 
context free grammar non terminal symbol associated set strings sub language 
parser function specific non terminal relation input string set output strings obtained input removing initial segment member associated sub language 
member set result successful parsing 
burge shows treat multiple answers lazy functional languages 
lazy lists closely related streams number elements unknown start processing lazy evaluation essential 
prolog multiple answers seen flow solutions examined depth manner mimicked naturally stream 
way representing backtracking functional setting continuation answer carlsson shows 
relying lazy list utilises recursion mimic backtracking 
example list successes technique finds uses translation 
predicate called example extracts possible form expression containing associative commutative operators 
expression rearranged main clauses defining chain op commutes op 
associate op associate op 
chain op derives linear chain operands expression outermost part tree applications binary operator op 
goal generates permutations operand case commutative operator associate generates alternative associations 
translates haskell equation op chain commutes op associate op associate op prolog backtracks returns rearrangement alternative substitution haskell solution yields list possible rearrangements 
note convenience list comprehension associate op commutative case 
definite clause grammars parser combinators programs input 
inputs textual legal inputs form small language program parse 
prolog parsers built giving rules definite clause grammar dcg input output strings implicit 
grammar rules dcg converted ordinary predicates including inputs outputs preprocessor prolog system 
example dcg rule command com name count 
name name count count 
defines simple command consisting command name repetition count assuming separate rules name count 
may alternative rules construct parsing backtracking necessary 
functional language haskell parsers built parser combinators 
parsers functions take input string argument return list pairs parsed value rest string 
parser value type parser string 
string lazy list success technique empty list representing failed parse 
parser combinators combine parsers building greater parser 
combinators inp 
inp inp 
inp combinator 
builds parser values expressed sequence resulting values simply paired 
combinator allows structures default pair types result parsing 
example dcg rule command translates haskell function command name count uncurry com need preprocessing functional language combinators yield parsers directly functional values 
parser parser routines prolog haskell versions follow grammatical structure 
case input lists appear descriptions 
example accepts laws map map map prolog dcg rule parsing top level syntax law law name 
name 
haskell lit 
var name 
law name lit function builds parser literal string 
advantage prolog unification mechanism provides way matching left hand sides inputs decomposed outputs constructed implicitly 
dcg term result represented pattern law name constructed terms unification 
haskell pair structure var name constructed standard parsers syntax derived function var name 
law name difference list lambda abstraction prolog data terms containing uninstantiated variables class citizens passed example arguments goal bound variables result executing goal 
possibility exploited effect 
standard technique called difference list form xs ys xs partial list ys tail point 
example xs ys 
unifying list ys concatenation accomplished recursively reconstructing earlier part list 
append xs ys ys zs xs zs 
obtain normal list data structure xs difference list xs ys simply unifies ys empty list 
functional language data constructions containing variables formed expressions 
possible pass argument obtain result data structure components unbound 
functions class citizens 
introduce variable lambda abstraction body abstraction may course build data structure incorporating functional counterpart difference list ys ys lambda abstraction ys ys 
combining abstractions function composition functional programmer achieves concatenation recursively reconstructing prefix list 
append obtain normal list lambda abstraction simply applies empty list 
example technique function shows defined haskell prelude having type 
string 
string 
function print utility composed functions result type string 
string 
prolog possible examine structure half instantiated terms instantiation 
hand proposed functional counterpart examine body lambda term complete counterpart 
essential list operations head tail take drop map filter lambda terms representing difference lists expensive 
obtain element list example apply lambda term empty list apply head 
operation extra step binding lambda variable required regardless length prefix 
holds operations 
examining individual elements list original lambda term applied arguments 
representation lists lambda abstractions cons different hughes representation concatenation represents list say hughes representation need elements list reduction steps proportional length prefix required 
cons representation step required application time reduction lambda node depend length prefix 
burton similar arguments queue representation lambda terms 
difference list operator evaluated 
logical variable works simply pointer certain position instantiated data structure 
lambda abstraction contains constructor symbols body argument variable works exactly way logical variable non ground term prolog 
assuming lazy evaluation hughes representation obtain head list constant reduction steps 
need list cost depends length list 
display transformed equations back screen eventually write transformed source files 
purpose routines convert syntax lists textual tokens 
simple example consider type declarations may precede defining equations phrase newline define newline char tab char tab newline simplified extract prolog difference list express sequence textual tokens 
tail tail 
rest tail rest text tail 
ts rest tail rest text tss ts tss tail 
translated haskell id ts ts results functions type token token 
example evaluates text partial application text 
meta logical operators higher order functions prolog terms include variables class citizens built meta logical operators exploit distinction variables non variables var ground 
meta logical operators call subvert normal distinction predicate terms data 
kinds operator definition map 
map term os term call instance map term os 
functional language course defining map straightforward 
map map xs map xs meta level operators gone 
purpose logic program build body appropriately instantiated call 
performing operation efficiently central concern functional language compiler explicit functional program 
purpose call operator coerce data term predicate term 
functional language need data structure place functional value passed directly 
technique prolog meta logical operators compensate lack higher order programming 
attempts accommodate lambda terms logic programming extensions cause fundamental change computation scheme prolog implementation order logic 
example procedures similar meta logical techniques defined 
routines widely program 
give just example map simple procedure accessing syntax definitions 
cs ns cs vars map io vars ns 
haskell cs map cs clause manipulation continuation passing style characteristic predicate procedures prolog definitions dynamic 
clauses defining predicates removed added execution program meta logical primitives retract assert 
heavy dynamic predicates poor style applications best programming solution involves small number dynamic predicates 
example options switched assert option 
retract option 
success failure option goals control various program components explicit mention structure options held 
functional program defining equations fixed execution 
dynamic functions meta level operators manipulate defining equations values 
part execution state dynamic communicated section program passing arguments 
represent change dynamic state augment function result new state value 
example redefining function type change state type type 
degenerate case entire purpose function state change type options example state list active options os os os os option os elem os approach leads global cluttering program explicit mentions option list expressions construct access tuples containing 
avoid problem passing option list program large pass parts program large option functions continuations 
os os os os ky kn os elem os ky kn os argument order permits convenient composition state arguments left implicit 
example may write function exec exec trace logfile help id trace logfile provoked function exec initial possibly empty option list 
monadic style programming database manipulation general state change typical impure process 
wadler describes monadic style programming way model impure effects purely functional language 
state change modeled state monad consisting type constructor functions units binds type state 
state units 
units 
binds 


binds 
type constructor represents computation involving state changes 
units corresponds identity function binds composes computations applying initial state apply results state transition mechanism hidden inside function binds 
functions functions type sole aim functions changing state 
definition remains 
os 
os os 
os ky kn os 
elem os ky kn os monadic counterpart function exec exec trace binds 
logfile binds 
help units trace binds 
logfile function receives changes state list options explicit variable representing state program 
monadic version easily translated back continuation passing style versions equivalent 
discussion subtle difference seen wadler :10.1.1.100.9674
cut operator single counterpart cut operator appropriate choice cases 
cuts variety ways prolog programs prevent useless inappropriate backtracking 
example predicate computes sum positive integers limit defined sumto 

sumto sumto 
goal sumto succeeds solution 
cut operator st line backtracking yield spurious solutions 
sumto example illustrates common pattern initial goals body define precondition clause apply separated cut remaining cut free goals 
corresponds guards haskell 
sumto predicate translates haskell function sumto sumto translation sign guard corresponds cut operator 
get right hand side committed equation 
cut sumto discards undesirable answers original program red cut 
naish mu prolog provides construct effect changing red cuts green ones enables avoid cut representing conditional statements sumto sumto shows immediate correspondence functional translation 
translation guards appropriate programmer knows goal condition ground 
unfortunately goal left cut output values translation scheme doesn 
prolog inappropriate possibility greater search space output variables 
cut unavoidable 
example clause 
subgoal succeeds value passed 
assume input output mode 
haskell guard boolean expression binding takes place evaluation guard 
possible haskell translation program take simon peyton jones proposed extension haskell pattern guard enabling pattern matching guards list comprehension 
pattern guard program translates pattern matching different type list comprehension 
clauses containing goal left cut translation pattern guards works 
example clause 
translates comma guard means 
translation cut pattern guards corresponds don know nondeterminism programmers want search possible solutions efficiently 
case don care non determinism programmer wants solution cut different translations 
saw earlier list successes backtracking 
representation cut simple discarding tail list 
suppose define cut cut xs fact function cut defined terms take cut take predicate clause reduce equation match 
cut avoid multiple results equations match ways 
translation reduce cut equations match types cut represented symbol guessing programmers intention necessary translation 
worse case programmer different intention possible translation scheme necessary 
situation indicates cut operator strong expressive power go imperative languages 
cut operator especially important parsers efficiency reasons 
backtracking possible input stream kept 
frequently case reading small number tokens recognise possibility backtracking reach point place cut 
explains cut combinator continuation parsing scheme discarding tail list discards failure continuation retaining success continuation 
arguments prolog predicates input case output case 

example standard definition append append ys ys 
append xs ys zs append xs ys zs 
name suggests append goal append zs result bound zs 
case member ys append xs ys 
goal member predicate append list ys splits list pair xs 
directional characteristic functions predicates direct counterpart functional language 
typical definition append haskell append 

append ys ys append xs ys append xs ys contrast prolog related list splitting function requires separate definition complex structure split 
split split split functions completely different types impossible ordinary append function place split 
darlington absolute set abstraction extension functional language hope allows definition form split zs xs ys append xs ys zs evaluation definition takes outside realm standard implementation methods compiled graph reduction 
respect jayaraman relative set abstraction language powerful enables compute inverse image functions order terms conventional reduction scheme theoretically making underlying sets explicit 
discuss way treat relative set abstraction compiled graph reduction 
simple predicates access data structures func common 
predicate ways goal instances instantiated equivalent function clause 
expr 
bool func instantiated equivalent function clause 
expr func deeper computational workings places characteristics predicates exploited 
time considered issues order solutions placement cuts efficiency procedures practice useful modes computation 
concluding remarks course translating large structurally complex logic program functional language encountered variety programming techniques 
majority cases turns corresponding techniques functional language higher order functions lazy evaluation 
experimental translation notion correspondence remained adhoc 
accepted counterparts techniques allow translated programs similar structure originals 
subsequent chapters define translation schemes syntactic unit logic language mapped parts expression functional language 
question execution efficiency important difficult address implementation methods functional logic programs remain active rich fields research 
marchiori considers limited class prolog programs defines translation functional programs 
translation preserves termination computed answers keeps computational complexity 
resulting functional programs compute similar way logic programs derived 
translation carried exact rules suggesting possibility automatic translator 
marchiori class functionally moded predicates limiting include predicate split append mentioned section poly modality 
topic mentioned passing strong typing functional languages including haskell effects working type system pervasive program 
example auxiliary state arguments named explicitly defining equations functions potentially change state clearly identified types prolog thorough survey required detect possibility state changes 
hand prolog clauses simple comma suffices combine subgoals type computation engage haskell expression type type classes limits overloading combinator symbols 
mentioned obtain limited idea correspondences logic functional languages translation exercise chapter 
subsequent chapters define translation schemes various sub sets prolog haskell seeking stricter notion correspondences 
chapter treat mode annotated prolog 
mode annotation avoid non ground computation serious problems translation 
chapter define translation scheme structurally restricted prolog 
difference underlying computation schemes major topic translation 
chapter functional translation moded prolog preliminary investigation correspondences logic programming lp functional programming fp poly modality lp major obstacle translating lp fp 
predicate invoked variables formal arguments unified actual arguments invoking term 
mean actual arguments contain information formal ones 
data flows actual formal arguments formal actual ones 
take place functional setting 
functional programming actual parameters fully instantiated information flows actual formal arguments 
function symbols constants formal parameters pattern matching guards passed back part result 
typically translation predicate append append append xjxs append xs zs require completely different functions append split corresponding modes append append translates function receiving lists returns concatenation append ys ys append xs ys append xs ys append translated function receiving list returns list possible partitions input split xs ys jx zs xs ys split zs fact modes append involves passing non ground terms serious obstacle translating lp fp 
suppose accept fact source expressiveness lp fp direct counterpart 
avoid usage predicates poly modality lp translated effectively fp maintaining textual correspondences 
order answer question chapter translator mode augmented lp haskell implemented 
source language pure prolog containing cuts negations annotation modes argument predicate terms 
source program required moded explained 
modes predicate terms automatically inferred don go simply assume modes 
case predicate various modes treated different predicates 
main contributions exercise marchiori referred 
translator deals cut operators marchiori mention 

translator distinguishes predicates having multiple answers answer exactly answer 
predicates class translated functions result type respectively 

translation scheme preserves structural similarity avoids auxiliary functions 
extra function combinator defined translation scheme 
section describes source language wm prolog 
explains translation list comprehension 
describes translation cut operators 
deals translation single valued predicates 
describes aspects implementing translator 
discusses potential ways improve translation summarises 
moded logic language investigate expressiveness logic languages usage predicates define wm prolog predicate argument works input output 
furthermore predicate definition subject constraint resolution step non ground parameters returned goal 
cases term wm predicate indicating predicate wm prolog 
possible assign input output mode predicate parameters arbitrary logic programs predicate definitions modified satisfy second constraint wm prolog express proper subset set predicates described ordinary logic languages 
questions arise wm predicate effectively translated fp 
large set wm predicates 
translator gives answer question 
come back second question 
syntax wm prolog pure prolog augmented negation cut operator mode annotation syntax table 
predicate term represented input terms output terms separated semi colon order 
empty 
input term fully instantiated time invocation output term fully instantiated invocation 
output terms arbitrary forms necessarily pure variables functionally moded programs marchiori 
order specify predicate name predicate lengths necessary 
predicate terms having name length different length denote different predicates language 
example built predicate splits predicates different arguments arithmetic comparisons treated truth valued predicates 
non ground 
moded constraint order return ground results sets variables input output arguments clause obey conditions 
denotes set variables occurring set terms ffl unit clause hold 
ffl non unit clauses negative literals gamma hold denotes set union 
left right selection rule body literals condition ensures sub goal receives ground parameters returns ground parameters ffl non unit clause contains negative literals set treated empty 
example predicate append receiving lists returning concatenation correct moded program append append xjxs append xs zs program ffl clause program clause head head body head predicate predicate name terms terms terms ffl term terms term variable constant name terms terms terms variable expr body literal literal body literal predicate expr literal expr expr expr lop expr expr term term aop expr lop 
aop gamma syntax wm prolog put semi colons second arguments append append append xjxs append xs zs predicate moded 
append indefinite mode involving non ground computation indicates limitation language 
swap inputs outputs definition append append append xjxs append zs xs obtain correct moded predicate corresponding function split mentioned 
assume source program self contained predicate terms occurring program defined program 
ensure detect determinacy predicates source program 
translation list comprehensions predicate argument wm prolog annotated mode predicates seen mappings inputs outputs 
order translate mappings functions need functions list type results mappings general relations functions 
list comprehension mentioned previous chapter list comprehensions haskell provide convenient way express multiple solutions logic program predicates functional setting 
haskell expressions include list comprehensions exp exp qual qual qual pat exp exp exp rhs definition called main expression comprehension qual qualifiers 
qualifier boolean expression generator 
meaning notation defined rules concat ok true ok false map filter ok basic version translator converts wm predicate function list comprehensions 
affirmative answer question previous section wm predicate effectively translated fp 
section explain translation rules wm predicates cut operators 
cuts treated 
introduces basic translation rules single clause predicates 
brief discussion effectiveness translation 
handles negations 
clause head variable may appear times fp arguments function definitions linear 
discusses linearity problem translation 
introduces general anti unifiers order translate multiple clauses 
considers missing clauses predicate definitions 
single clause predicates sub section considers translation predicates defined single clauses cuts negations 
consider clauses linear inputs list input terms clause head variable appears list output terms predicate term clause body variable appears 
rule unit clause unit clauses linear inputs translated space separated comma separated var var variables con con constants numbers functors empty list list tail jvar var list tail exp exp expression example xjxs xs unit clause single output omit parentheses 
non unit clauses body literal non unit clause translated qualifier list comprehension 
sub goal denotes set tuples ground instances calculated ground input resulting tuples subsequent goals evaluated obvious correspondence literals qualifiers 
rule non unit clauses lop lop aop aop gamma gamma example zjy zjx negation prolog systems negation works defined fail depends meta logical operator cut 
negation conveniently expressed list comprehension function null 
null rue null xs alse rule negation null expr expr example negation null note resulting qualifier contain terms derived original output parameters corresponds fact computation negation variable binding takes place 
assuming lazy evaluation null reduces false element computed 
literal fails answer amount computation changed translation 
linearity problems lp variable may appear clause head implying corresponding actual arguments unified 
fp contrast variable argument patterns appear 
declare local variable name twice 
order translate clause head duplicated variables input list need replace duplicated occurrence new variable appear clause add guards equating original variables new variables impose relationship input parameters 
body literals may duplicated variables output lists 
order avoid duplicated local variables list comprehension create new name duplicated variable add equality check literal 
step translation convert clause linear form 
scope variable limited clause containing variable conversion done clause clause 
rule non linear input suppose predicate defined clauses new old new old map new old new old expressions negations old duplicated variable names input list clause head new new variables 
old duplicated variable names output list body literal new corresponding new variables 
example wm prolog equality actual parameters corresponding duplicated variables checked unification 
new clause transformed function input patterns filtering effects equality checks postponed evaluation newly generated guards 
translation slightly increases textual complexity resulting function contains extra variable names extra operators guards 
computationally non linearisation variable clause heads cause extra resolution steps equality guards 
transformation function may cause computation 
body literal originally non linear output variable produces possible results filters ensure equality 
general program may cause non termination 
multiple clauses lp predicate may defined clause 
predicate defined clauses input arguments distinct clauses unify perform clause wise translation 
example predicate xjxs translated equations clause xs argument match patterns 
clauses arguments unifiable translate clauses separate equations 
example clauses jy translated equations ys backtracking occurs fp 
calling pattern unifiable clause head equally unifiable second vice versa translation concatenate results clauses jy ys 
general need decompose set defining clauses disjoint clause groups group translates single equation 
goal ground inputs unifies clause heads inputs ground instances input parameters heads partitions characterised way 
definition clause group decomposition set defining clauses predicate partition equivalence class transitive closure relation input arguments unify 
rule predicate definition assume predicate defined clauses order 
number clause groups 
clause group original clause order preserved 
select clause group original order preserved 
example defining clauses predicate delete delete delete xjxs zs delete xs zs delete jy delete zs decompose clause groups xjxs zs delete jy henceforth term clause group represent subset defining clauses translated single equation 
groups containing clause translate equation translation rules 
clause groups clause derive formal parameters resulting equation parameters accept possible inputs group 
example suppose predicate defined clauses xjxs combine clauses equation need compute maximal common part arguments input position 
example clause general form input argument second clause xjxs common form 
having determined formal parameters translate clauses equation introducing filter qualifiers jx jx xs simplified jx xs eliminating redundant generator term 
process obtain maximal common part set terms called 
anti unifier set terms term general equally general term set 
general anti unifier set terms anti unifier contain information set 
anti unification procedure calculate general anti unifier set terms 
assuming absence repeated variables set terms compute general anti unifier similar method obtaining general unifiers 
assuming function takes list terms returns general anti unifier term define translation scheme clause group equation 
rule clause group example delete translate predicate delete previous example clause groups delete delete xs zs delete xs zs delete xs partially defined predicates logic programming absence input patterns set defining clauses simply means invocations missing patterns fail 
example predicate mem defined mem xjy mem jy mem invoked arguments mem eventually calls goal mem unify head defining clauses fails 
parent computation may succeed 
functional setting failure match defining equations causes runtime error 
solution preliminary pass transformer supply new clause mem fail solution modifies input translator 
adopt solution introducing set variables formal parameters pushing pattern matching process inside list comprehension missing patterns simply fail produce answers 
translate predicate mem mem jx ys jy ys mem ys invocation mem eventually causes function call mem simply gives computation reduces correctly 
rule partial predicates new variables checking coverage order translate partially defined predicate way know predicate partial 
partiality predicate detected inspecting input patterns defining clauses 
tree ffl inputs contain constants function symbols list structure treat predicate partial impossible confirm coverage input position predicate input position 
ffl argument pure variable list structure containing variables derive possible argument patterns predicate definition 
possible calculate set argument patterns covered defining clauses 
sets set possible patterns set covered patterns coincide predicate totally defined partial 
rest subsection describes obtain sets 
consider graph list structures prolog terms trees 
list input term form identical node tree 
term form nodes spine form jx covers patterns descendant subtree 
form covers form actual arguments 
property nodes tree pair nodes forms jx complementary sense patterns covered subtree jx covered 
example existence patterns xjxs indicates total coverage 
pair jy covers patterns subtree xjxs covered 
possible patterns order compute set possible patterns predicate definition auxiliary definitions 
definition limit input position predicate definition limit term spine tree terms appeared input position predicate definition term occurs deepest tree complement definition variety input position predicate definition variety set non spine nodes root limit 
example consider predicate xjxs body body terms appearing input position term deepest limit position complement jy 
second input position xjxs deepest limit 
limits varieties input position predicate position gamma limit jy xjxs varieties jy xjxs set possible patterns predicate definition defined terms limit variety predicate 
definition possible patterns set possible patterns predicate definition cross products varieties input positions 
example set possible patterns predicate example elements xjxs xjxs jy jy xjxs covered patterns need compute set patterns covered predicate definition 
concept 
definition range input position defining clause range set patterns argument clause corresponding position non spine form range fug set patterns sub tree depth limit position 
set covered pattern predicate definition defined set covered pattern defining clauses 
definition covered pattern defining clause predicate set covered patterns cross products ranges input positions clause 
set covered pattern predicate definition union covered patterns defining clauses 
example covered patterns consider predicate example xjxs body body range input position clauses xjxs xjxs set covered patterns clause theta xjxs xjxs clause theta xjxs xjxs possible patterns covered clause partial 
predicate total may add say jy body body translation cut cut operator appears sub goal clause may change flow control 
invoked cut succeeds immediately 
backtracking returns cut parent goal fails 
words branches cut exist searched discarded 
explain mimic behaviour functional setting divide translation phases 
consider translate cut operators clause discuss prune results subsequent clauses 
cut clause cut operator clause body discards possible solutions sub goals preceding cut 
express solutions preceding predicates list need simply take head 
solution exists result empty list 
function cut defined chapter cut cut recall effect multiple qualifiers list comprehension defined concat jq current translation scheme clause translates 
omitted parenthesis sake readability 
rhs equation folded point generators 
example equation equivalent previous concat gamma gamma gamma inner bracket represents solutions predicates arising solution gamma consider clause cut operator gamma gamma gamma gamma cut operator succeeds immediately rue operator appear translation resulting expression exactly folded expression need element outer list 
apply function cut applying concat concat cut gamma gamma gamma gamma fails result concat cut 
solution gamma result possible solutions assuming result gamma exactly cut operator affects clause containing 
case clause contains cuts cut clause folded nested expression 
rule cut clause rest rest possibly empty sequence qualifiers cuts rest possibly empty sequence qualifiers 
function defined pairs list terms list literals rest concat cut rest qm example cut clause concat cut jy concat cut concat cut jt jz pruning solutions subsequent clauses clause clause group contains cut solutions subsequent clauses discarded cut committed 
clause containing cut fails cut subsequent clauses searched 
achieve corresponding effect functional translation sight combine results clauses new operator phi phi xs phi clause fails value equal second clause 
succeeds result element results clause subsequent clauses discarded 
fact quite right different cases failure clause 
clause may fail reaching cut 
correctly represented equation 
clause may fail cut producing solution 
case solution empty list committed clause 
operator phi supposed take result application concat cut left hand argument 
concat cut applied way distinguish types failure clause 
avoid premature application concat cut define operator 

cut cut concat cut case denotes failure cut second failure cut distinguish types failures 
translation clause group connected translation clause 
depending clause contains cut 
clause contains cut connected empty list 
rule pruning 
contains cuts example insert predicate insert insert insert jy insert zs insert jy jy 
translates function insert insert ys insert ys jx 
removing outer list structures motivation list comprehension convenient construct fp express multiple answer functions 
preceding sub sections saw negations cut operators expressed conveniently connection comprehension 
protective lp multiple solution nature 
logic program predicates exactly solution 
predicates list comprehension construct unnecessary complication 
example predicate append append append xjxs append xs zs exactly solution fails legal input produce multiple results 
current rules translates function list type result append ys ys append xs ys append xs ys better translate append ys ys append xs ys zs append xs ys zs simplified get append ys ys append xs ys append xs ys standard definition append fp text books 
predicates having solution may fail 
consider predicate xjxs current rules translates xs xjx list structure suggests potential failure sign solution 
map function type result int int just xs just translation informative facts may fail solution explicit 
know predicates exactly solution 
subsection defines criteria predicates single valued non failing 
describes translation rules predicates assumption know characteristics predicates 
single valued predicates non failing predicates classify set wm predicates categories examining properties single valued ness sv non failing ness nf ffl sv true iff predicate produces solution 
ffl nf true iff predicate succeeds 
mutually independent assign pair boolean flags sv nf predicate definition categories 
set possible pairs sv nf form partial order number solutions categories characterised ffl predicates exactly solution 
ffl predicates solution 
ffl predicates solution 
ffl predicates may number solutions 
predicates having properties characterised conditions definition single valued predicate predicate solution clause group gives solution 
clause group gives solution 
clauses contain cuts 
clause containing cuts literals cut single valued 
clause contain cut literals clause 
examples single valued predicates example predicate defined unit clause single valued clause sole member sole group defining predicate vacuously contains single valued literals 
example append predicate append defined append append xjxs append xs zs single valued defining clauses sole member clause group clause third condition vacuously holds sole literal second clause single valued 
body predicate append second clause single valued induction hypothesis explained 
example insert predicate insert jy zs jy jy 
single valued clause single valued sole member group 
second third clause members group 
second clause single valued literal cut cf 
rule 
third clause single valued literal cf rule 
definition non failing predicate predicate non failing arguments defining clauses cover cases clause groups non failing 
clause group non failing 
clause containing cuts literals cut non failing 
group contains clause consisting non failing literals disjunction guards clause group evaluates true guard clause list literals preceding cut 
examples non failing predicates example predicate defined unit clause having variable input non failing argument covers cases unit clause sole member group defining predicate clause consists non failing literals vacuously 
example append predicate append non failing argument patterns cover cases defining clauses sole member clause group clause vacuously contains non failing literals sole literal second clause non failing induction hypothesis 
example merge predicate merge merge xjxs jy merge xs jy zs merge xjxs jy merge xs zs merge xjxs jy merge xjxs zs merge xs xs merge non failing argument patterns cover cases clauses group disjunct guards clauses evaluate true clauses non failing literals cut clauses non failing literals vacuously calculation sv nf order assign predicate appropriate tags execute fix pointing iterations sv nf 
initial state predicates assumed single valued non failing 
iteration iteration cycle predicates program sequentially examined satisfy criterion sv nf assuming current values body literals 
convergence check cycle count number predicates assigned rue compare number previous cycle 
numbers fixed point reached 
consider iteration sv predicates 
multi solution predicates don call predicates 
iteration switched alse subsequent cycle predicates calling switched alse 
similar argument holds nf predicates 
number predicates assigned true decrease fix pointing process terminates 
translation rules single valued predicates having assigned predicate definition pair sv nf translate failing non failing predicates list comprehension 
fact possible remove outer list structure wm predicate translated combination list comprehension see defined terms case construct core haskell 
conversion may result extremely tangled expression adopt naive solution 
translation scheme exploits structural similarity clause groups guarded equation haskell 
clause reach cut commit clause 
similarly guarded equation reach sign commit branch 
example example minimum clauses defining predicate minimum minimum minimum translated guarded branch equation 
minimum translation clause group concentrate translation clause group equation 
consider schematic representation clause guard trunk tail cut right guard cut clause cut tail cut clause 
may cuts trunk 
recall predicate single valued defining clause groups single valued clause group single valued clauses contain cut 
clause cut thought having tail 
single valued literals tail single valued 
assume guard contains literals arithmetic comparison boolean type predicate negative literal 
consider predicates condition paragraph section 
literals chosen computing guard variable binding take place 
translate literals cut short guard guard conjunction boolean expressions 
rule guards gs boolean type predicate negation expr expr comparison expr expr negation alse nf sv failing literals trunk tail translate expression right sign 
clause group contain cut translator generates guard clause 
clause contain cuts cases depending disjunction guards group exhaustive 
order examine exhaustiveness built tiny interpreter logical expressions including boolean type predicate terms 
exhaustive translator adds 
exhaustive translator generates new branch guard rhs alse boolean type predicates single valued predicates 
rule sv clause group gs guard clause 
gs gamma gamma gamma gs exhaustive guards 
gs jj jj rue gs non exhaustive guards 
gs null jj jj alse function rule transforms literals cut trunk tail expression 
literal trunk tail translated expression expression case expression 
list outputs carried nesting blocks position final value 
cut trunk cuts trunk simply translate rue 
cut trunk tail multi solution predicate trunk take element list results 
possible different forms literals trunks tails columns forms translations column summarised table 
categories literals expression literal predicate non boolean nf sv nf sv case case boolean expression true predicate non boolean nf sv failing case case boolean expression literals trunk tail form translation syntax wm prolog table classify literals categories second column 
boolean predicates expressions negations translated expressions 
non boolean predicates translate distinctly depending sv nf 
negation non failing non boolean predicates star table translate alse depending type head predicate discarding rest literals 
type predicate clause head identified function rule defines function rule literals rs rs sv nf rs head rs nf rs case just rs sv rs case rs rs rs rs null boolean rs rs null expression rs rs cut rs null nf rs case rs just sv failing rs case rs rs rs null boolean rs rs null expression base case rue alse boolean predicate alse single valued predicates having described translation rules clause groups define translation rules predicate definitions 
problem remains 
predicate may defined possible input patterns 
example example member predicate member defined clauses member xjxs member jy member translate equation member xs rue member ys rue invocation pattern member cause run time error 
preprocessing source program adding sv nf tags translator records input patterns predicate definition covers cases 
predicate defined partially translator generates catch equation 
actual translation predicate member member xs rue member xs rue member alse rule sv predicate total predicate null partial predicate clause groups guards containing non boolean predicates return case guard contains non boolean predicates 
unfortunately class single valued predicates translated functions list type results 
problem arises guard contains literal output terms 
haskell allow local definitions guards impossible exploit structural similarity 
consider predicate definition suppose single valued non failing sake simplicity means single valued 
procedural reading definition computed calling 
positive value returned called value second clause tried 
want translate definition illegal current haskell syntax 
fact proposal pattern guard simon peyton jones exactly extension standard haskell 
translator maps predicate function list comprehension concat cut jy rule guard trunk tail guard contains non boolean literals implementation notes examples section summarises topics related implementation translator 
order provide partial answer second question posed chapter large set wm predicates example predicates taken translations displayed 
implementation notes translator implemented hugs haskell user gofer system 
size translator lines including comments 
translator works order read set wm clauses classify clauses set predicate definitions partition defining clauses clause groups convert clauses linear form give predicate sv nf tags translate clause group haskell equation output 
resulting program executable hugs 
parsing order parse wm prolog programs small parser combinator library lines similar 
parsing functions lines long 
monadic programming monadic style programming useful situations need carry global data structures 
simple state monad introduced clause bodies assigning sv nf flags predicates translating body literals qualifiers :10.1.1.100.9674
pretty printing output formatting translator employs hughes pretty printing library 
library small lines extremely powerful formatting resulting equations 
printing functions lines long 
simplification predicates translated function definitions translator performs simplification resulting equations 
optimisations program transformations functional language include phase translation schemes 
translating body literals series qualifiers series output variables literals variable referred context replace corresponding expression 
example reverse naive reverse program defined terms predicates reverse append reverse reverse xjxs zs reverse xs append zs translator converts recursive clause expression reverse reverse xs ys reverse xs zs append ys zs simplifier eliminates variables ys zs reverse reverse xs append reverse xs predicate defined functionally moded predicates example functional translation contains fewer variables original clause 
example simplification list comprehension example sort interchange sorting program defined sort xs split xs append xs sort xs sort xs xs ordered xs translation append split ordered subsection 
cut non boolean predicates cut resulting function looks little cluttered sort xs append bs ys sort xs bs split xs 
xs xs 
simplification general equality xjx sort xs sort append bs bs split xs 
xs xs 
examples textbook examples previous sections taken 
example append split append split chapter 
ordinary append example minimal recursive definition append append xjxs append xs zs translates append append xs ys append xs ys append mode defined wm prolog swapping arguments split split xjxs split zs xs translates list type function split split ys ys xs ys jx zs ys xs ys split zs example length predicate length length length xjxs length xs translated function length length xs length xs intermediate variable original clause 
example quicksort predicate quicksort defined sv nf predicates partition append quicksort xjxs partition xs quicksort ls quicksort bs append ls quicksort translates function quicksort xs partition xs append quicksort quicksort quicksort variables ls bs ys original clauses disappear translation 
example merge predicate merge example merge xjxs jy merge xs jy zs merge xjxs jy merge xs zs merge xjxs jy merge xjxs zs merge xs xs merge translates merge xs ys merge xs ys merge xs ys merge xs ys merge xs ys ys xs xs ys example partition predicate partition example partition xjxs bs 
partition xs ls bs partition xjxs ls partition xs ls bs partition translates partition xs ls bs partition xs ls bs ls bs partition xs ls bs partition result simplified introducing clause implemented 
example ordered predicates ordered example 
example boolean type predicate 
ordered ordered ordered jy 
ordered jy translates ordered rue ordered rue ordered ys ordered ys rue alse example neq predicates neq defined cut fail combination 
translate proposition fail false appears boolean type predicate 
neq fail neq translates neq alse rue example sum chapter predicate sum order explain effects cut 
version sum 
proper cut sum 
sum gamma sum translates function sum sum sum gamma expression sum hugs returns 
drop cut clause sum tow 
sum tow gamma sum tow translates sum tow jn jr sum tow gamma value sum tow 
discussions related reddy describes translation moded logic programs small functional language 
moded clause input variable body literal appear input position clause head output occurrence literals body 
moded clause roughly rearrange body literals variable appearing input literal output occurrences preceding literals 
source programs chapter equivalent moded logic programs assume selection rule body predicates assume standard left right selection rule prolog 
connection acyclicity reddy mentions completely acyclic clauses variable occurs output position appearance input position 
despite explanation essential problem variables appear output position regardless relative order occurrences input 
variable appears output positions second occurrence variable bound term works filtering pattern 
functional translation may extra computing spurious variable bindings discard 
serious problem extra may cause non termination translation incomplete marchiori points 
current translation scheme accepts class programs deficiency 
reddy translation scheme valid predicates definite mode 
predicate definite mode resolution goal succeeds returns ground bindings variables 
reddy give syntactic condition predicate definition definite mode may state defining clause output variable clause head appears output position predicate definite mode 
indefinite modes cause problems translation functional language variables appear results 
reddy translates logic programs functional language constructors equation groups set groups correspond expressions list com respectively 
translation list comprehension subsumes programming constructs 
proposal translation negations cuts reddy 
mentions determinate indeterminate modes predicates give translation scheme treats modes different ways 
marchiori gives different functional translation scheme restricted functionally moded logic programs output variable clause body appears 
words clause bodies linear addition output terms pure variables 
imposes restriction source language marchiori concerned completeness translation 
allow functor symbols output positions goal functional translation need enumerate solutions goal filter output functor 
enumeration computation may go loop 
original program functor symbols output position may prevent goal unify clauses may loop 
translation preserve termination 
problem assume ordinary resolution operational semantics information flows output channel clause head goal 
parameter head assigned mode 
purpose assigning modes restrict usage predicates output parameter way 
unify goals clause head unifying input parameters original goal terminate translation preserve termination non termination 
need different operational semantics moded logic programs really want avoid nature logic predicates 
marchiori translates clause composition data handlers computes outputs predicate definition inputs connection join operator connecting multiple solutions 
give different treatments determinate indeterminate predicates 
give translation scheme cut operator hard deal cut operator compositional scheme translation 
textual complexity computational complexity textual complexity translation scheme list comprehensions textual complexity resulting equations order original clause groups 
resulting equation contains set identifiers new variable names created duplicated variables 
number occurrences function names result exactly number predicate names original clause 
left arrow generator corresponds semi colon separating inputs outputs body predicate 
comma generators corresponds comma body predicate original clause 
negations expressed function null cut operators converted new operator 
list structure necessary express non determinism functional framework extra programming construct result 
order translate cut operators need nested list structures separate predicates cut 
source extra complexity duplicated variables clause 
clause contains non linear input head non linear outputs body predicates need equality checks duplicated occurrences variables 
rhs equation may contain extra variables expressions 
size increase induced extra programming constructs exceed twice 
predicate single valued dispense outer list rhs resulting equations case expressions 
predicate non failing rhs set local variable definitions times eliminate resulting equation contains fewer variables example reverse reverse xjxs zs reverse xs append zs translates reverse reverse xs append reverse xs variable zs disappears 
computational complexity concerning computational complexity easy state far succeeded preserving 
number predicate calls original clause number function calls resulting equation 
may extra equality checks induced duplicated variables original clauses change order amount computation 
order obtain total number reduction steps need take reduction steps list comprehensions account 
summary 
translator translates moded logic program haskell function list comprehension defined implemented 
translator preserves order textual complexity computational complexity cases clauses containing non linear output patterns 

cut operators moded predicates translated function cut new combinator connection list comprehensions 

defined conditions predicate solution solution 
case predicate solution predicate translated function type result 

single valued predicate solution words exactly solution dispense constructs 
chapter saw mode annotation logic language functional typical logic predicates naturally translated functions 
excluded predicates involving non ground computations 
chapter define translation schemes prolog investigate extra programming necessary fill gap distinct computation schemes resolution reduction 
chapter functional translation scheme logic programs chapter translator moded prolog haskell defined 
predicate argument assigned mode output assured ground large subset prolog programs directly translated haskell 
cases textual correspondences logic clauses resulting equations 
translation scheme satisfactory senses 
firstly translation scheme defined mode annotated predicates corresponds part logic computation directional 
deal bidirectionality logic computation avoided 
secondly failed dissect predicates directional computational parts 
subset predicates succeeded translation small proper subset 
example predicate append mode moded involving non ground computation 
translation scheme essentially unable deal logical variables 
chapter engage functional translation logic programs involving non ground computations 
aim exercise assess expressiveness functional languages describing logic computation 
want know far write equivalent function definitions look original predicate definitions 
non ground computation implicit logic programming features exist functional computation scheme certain amount extra programming may inevitable translation 
trying minimise extra programming whilst keeping textual correspondences original clauses translated equations 
define translation schemes small subsets prolog haskell 
imposing tight restrictions source language try identify computations specific logic programming emerge translation 
easing restriction observe extra programming necessary translation 
stay purely functional realm extension haskell pursued 
chapter consists sections 
section deals translation scheme subset prolog called unary logic language containing unary predicates nullary functors constants 
restricted language clause needs translated different functions tester generator 
observe simple textual correspondences original logic clauses translations 
section extend language allowing unary functors obtain unary string logic language 
presence unary functors larger residue unification remains translation 
logic clause translates single equation maintaining structural correspondence original clause 
section discusses results concludes 
translation unary logic programs section define translation scheme unary logic language haskell 
language contains unary predicates argument constant variable 
avoid non linear arguments partially instantiated functional terms 
point computation variable unbound bound ground value 
restricted language predicates emerges 
predicate definition translated distinct functions corresponding modes 
resulting equations display structural correspondences original clauses 
source language program possibly empty set predicate definitions 
predicate definition consists clauses 
clause consists head body 
head predicate term body possibly empty list literals 
literal predicate term negation 
assume goal program ffl program clause clause clause head head body head predicate body literal literal body literal predicate predicate predicate name const name var goal literal syntax language single literal 
simplicity exposition restrict language replace goal containing literal new predicate definition new goal single literal 
full syntax general translation scheme translate logic goals expressions logic predicates function definitions 
resolution goal clause mapped reduction expression function definition 
absence functional terms goal contains ground value pure variable 
query inquiring value satisfies predicate set values satisfies predicate 
translate ground goal function application argument 
non ground goal translated function application sake symmetry name name name names order reduce expressions function applications normal forms words order answer different types questions need pair functions predicate definition indicated distinct types arguments 
function called tester predicate tests argument satisfies predicate 
second generator predicate generates set values satisfying predicate 
translation program collection translations predicate definitions program 
translation predicate definition turn pair functions tester generator predicate 
program tester generator suffix name formal parameter introduced translation scheme 
tester takes ground value returns list length number proofs predicate holds value 
generator takes returns list member list singleton containing value predicate holds empty list stands uninstantiated variable 
outer brackets result types indicate multiple answers logic programming systems 
wadler terms lists successes 
possible replace inner list structure type 
case ground value denoted just uninstantiated variable represented 
notation better current double list structure fact term inner list explicit 
adopt notation expressions longer 
predicate may defined clause 
predicate defined clauses translation predicate expressed terms translation defining clauses clause clause clause clause clause clause ps clause clause connecting rhs equations clause corresponds top execution scheme logic programming systems 
abuse symbols representing translation predicate representing rhs resulting equation individual clause 
form lhs testers generators convention cause confusion 
names generators plural forms predicate names 
names testers names predicates 
naming convention chapter 
translation unit clauses possible forms unit clauses variable argument constant 
tester tester unit clause variable returns singleton goal predicate name name immediate refutation clause 
tester unit clause constant argument checks equality actual argument constant goals containing constant unify clause 
name name name name jx example nat nat small small jx generator generators types unit clauses name names name names function declares clause generates ground value 
second function returns constant satisfies name 
inner bracket necessary express unbound variable 
generators clauses previous example nat nats small translation unit clauses observe extra programming constructs 
urges translate predicate functions 
outer list structure testers generators necessary represent backtracking nature prolog 
inner list structure generators stems logical variables logic computation 
equation tester residue unification goal argument term clause head 
apart programming constructs resulting equations contain exactly occurrences predicate names function names arguments clauses 
hidden extra functions 
translation non unit clauses order translate clauses non empty bodies define translation scheme translates literal qualifier list comprehension 
scheme translates subgoals way testers generators 
translate initial goal list type expression subgoals clauses translated list type expressions context list comprehension 
subsection considers positive literals 
negative literals discussed 
takes environment list literals argument 
environment set logical variables clause bound terms 
base case empty list literals translates rue 
rue literal constant argument translation calls tester subgoal 
name rest name rest output pattern qualifier involving tester function usually denoted don care 
example rest rest translation subgoal variable depends variable environment variable call generator predicate name rest names fvg rest translation scheme converts logical variable appeared clause head 
logical variable appearing clause body produces local variable name fresh clause 
assume necessary renaming avoid name conflicts done translation 
translating subgoal name environment takes variable variable bound terms variables 
variable subgoal bound ground value variable need distinguish cases 
bound ground value need test value satisfies current subgoal 
bound variable ask current subgoal provide set possible values variable 
order dispatch cases predicate introduce auxiliary function suffix defined terms tester generator 
name name names auxiliary function receives singleton value function examines value satisfies predicate 
result list singletons value length number proofs value satisfies predicate 
argument empty list invokes generator 
translation subgoal bound variable name rest rest environment change translation variable note new variable hides outer remainder comprehension 
testers scheme testers non unit clauses defined name rhs name jx oe rhs name rhs name jb fvg rhs tester returns possibly empty list 
clause body fails result empty 
succeeds number number successes 
clause head constant argument qualifier checking equality actual argument constant introduced 
clause head variable argument recorded environment 
example jx oe jx qs jb fxg generators generators return list lists singleton list ground value empty list denoting uninstantiated variable 
name rhs names jb oe rhs name rhs names oe rhs rhs name rhs names jb oe rhs rhs denotes set variables term clause head constant main expression list comprehension singleton list constant 
clause head variable argument translation depends clause body 
body includes positive literal variable main expression list comprehension variable 
empty list subgoal generates value variable 
cases initial value environment empty 
example ps jb oe jx qs qs jb oe rs oe xjx ps ps examples suppose predicates small large nat translated fig 
small small small jx jx small large large jx nat nat nat nat jx jx nats nat nats example translations example suppose predicate defined terms nat small 
nat small jb fxg nat small jx fxg small jx fxg jx example bound ground value translation body 
called generators called inside functions passes 
example generator predicate defined nat small oe nat small xjx nats fxg small xjx nats variable appears body main expression list comprehension generator initial environment empty 
nat translated generator listed environment called 
example large nat cs oe large nat cs xjx fxg nat cs xjx predicate large generates singleton 
occurrences result arise distinct proofs goal nat 
example nat nat ds oe nat nat ds xjx nats fxg nat ds xjx nats elements near list generated nat 
nat nat proofs second nat 
elements near list generated second nat receiving value nat 
order values order prolog system returns answers 
evaluation scheme translation non unit clauses forms qualifiers name names indicate directions information flow goal resolved corresponding clause 
case goal contains ground value second case clause generates values 
qualifier involving auxiliary function residue unification 
variable literal bound term time translation decide function tester generator call 
introducing auxiliary function postpone decision run time 
auxiliary function name testers generators contain number predicate function names original clause 
negation discussed negation prolog defined form negation failure 
fail formulation negation relies cut operator negation failure translated haskell function null relying cut 
null rue null alse negated subgoal constant argument call tester predicate subgoal check result empty 
name rest null name rest negated predicate term variable argument translation depends variable environment 
variable call generator subgoal check result empty 
predicate defined program subgoal returns non empty result negation reduces alse 
situation corresponds negation non ground terms prolog systems try avoid 
name rest null names rest case variable variable bound variable 
need call auxiliary function 
name rest null rest prolog execution negative literal cause variable binding 
accordingly translating negated subgoal regardless subgoal environment change 
predicate prolog simply replaced function null translation extra programming introduced 
examples predicates previous examples page series examples 
example nat jb oe nat nats jf alse occurrence variable body main expression comprehension 
list reduces nats returns non empty list 
example nat jb fxg nat nat result depends actual parameter invocation tester nat returns non empty list result 
example nat nat bs oe nat nat bs xjx nats fxg nat bs xjx nats null xjx nats alse second qualifier returns non empty result value generated nats qualifier second qualifier false result 
example nat small cs oe nat small cs xjx nats fxg small cs xjx nats null xjx null null null small null alse result contain 
evaluates empty list small result contains 
empty list result generates non empty list 
example small large ds oe small large ds xjx fxg large ds xjx null example large receives ground values filters large values 
removing inner brackets translation scheme generators involves level list structure 
inner lists singleton empty list necessary possibility uninstantiated results logic program 
refine scheme evaluates 
full half predicates possible divide set predicates groups predicates group answer sets containing ground values answer sets second group contain variables 
call group full predicates second group half predicates 
definition full half predicates predicate full predicate defining clauses full clauses 
half predicate 
definition full half clauses clause full clause constant argument head 
clause variable head cases 
clause body contains subgoal full predicate variable clause full clause 
clause half clause 
program self contained subgoal occurring program defined program annotate predicate definitions full half tags fix pointing procedure 

annotate clauses half tags 
accordingly predicates half predicates 

clause constant argument head replace tag full 

annotate predicate defining clauses full clauses full tag 

find full clauses assuming current annotation predicates give full tags 

go back step repeat cycle number full predicates increase 
process full clause full predicate goes back half clause half predicate number full clauses full predicates increase monotonically 
finite number clauses predicates program procedure terminates 
improved generator assume predicates annotated full half tags 
define new translation scheme generators 
show translate full half clauses 
subgoal full predicate returns ground values variable subgoal fully instantiated execution subgoal 
subgoal half predicate may return uninstantiated variables say goal variable half instantiated 
order record fully instantiated half instantiated variables need distinct environments 
name body names oe oe body body oe oe pair environments fully instantiated half instantiated variables 
empty 
subgoals constant arguments translation scheme name rest names rest variable binding takes place translation 
variable subgoal contained environments subgoal translated generator name rest fname fxg rest full predicate rest fxg rest half predicate fname name full predicate half predicate 
subgoal full half predicate variable name registered second environment respectively 
variable subgoal environments subgoal translated auxiliary functions 
need alter definition auxiliary functions depending full predicate name vj fname difference definitions main expression second branch auxiliary function full predicate returns content argument half predicate returns original argument 
translation subgoals depends status variable predicate subgoal fxg rest fxg rest fxg name rest fxg rest fxg rest fxg rest fxg name rest fname fxg rest variable appeared clause may bound variables 
subgoals translate qualifiers auxiliary functions 
invoke generator tester depending value variable 
subgoal half predicate variable remains full predicate variable moves 
variable fully instantiated predicates simply translate testers status variable change 
example nat small bs oe oe nat small bs xjx nats oe fxg small bs xjx nats translation nat registered auxiliary function called 
final result simple list integer small full predicate 
example small nat cs oe oe small nat cs xjx fxg oe nat cs xjx nat subgoal small full predicate translate second subgoal nat tester 
result previous example 
example nat nat ds oe oe nat nat ds xjx nats oe fxg nat ds xjx nats subgoals nat half predicates result twolevel list structure 
analyse source program identify predicate full half predicate 
information time translation reduce number calls auxiliary functions 
residue unification translation smaller 
summary translation translation schemes unary logic language haskell defined 

bi directionality logic computation predicate translates functions tester generator 

non determinism logic programming function list type result represented list comprehension 

failure literal represented empty list list comprehension 
negative literals translated conveniently checking emptiness 

logical variables need list structure represent unbound variables result 

analysing predicate definitions improved scheme eliminates inner list structure predicate returns ground values 

resulting equations textual correspondences original clauses 
number occurrences predicate function names 
simple extra function definition counterpart logic program 
predicate name term term const name term syntax predicate language translation unary string logic programs immediate extensions source language allow predicates functional terms 
section add unary functors language predicates unary newly added functors nonlinear parameter problem 
unary functors partially instantiated terms 
information may flow flow terms decomposition unification directional parts harder 
logic specific features remain try identify unary functors affect translation 
source language call new language unary string logic language 
syntax changes predicate 
representation functional terms functor argument functional term represented non empty list haskell 
represent variables constants functional terms single data type sym say 
order represent non ground terms sym contains special constructor denoting variable 
integers sole constant 
legal erm element 
hand appear element erm 
typical ground non ground terms constructor denote non ground terms dispense level list structure 
possible allow clauses contain variable 
case add symbols denoting variables sym 
type erm sym data sym 
int functional terms addition variable clause change translation scheme assume variable name 
section upper bar symbol denotes list symbols kind 
example denotes list functors logic program denotes list constructors sym 
abbreviation means 
translation goals translating goals previous section 
goals classified groups ground non ground goals 
groups pose different types questions translate expressions distinct types name ground goal name erm non ground goal case empty list denotes failure 
language non ground goal contained pure variable didn obtain information apart fact variable 
non ground goals may contain functors computation 
translate goal function application translation term name name name names generator function takes term argument 
accordingly types testers generators predicate erm predicate erm erm translation scheme subscript needs formal parameter representing argument translation unit clauses start simpler cases 
unit clause pure variable translated name name name names note argument generator names denotes non ground term 
right hand side definition names expresses answer substitution variable bound 
changed representation situation previous section 
pattern reserved representation non existence variable bindings 
unit clause contains constant translate name name jx name names jx tester qualifier checks argument equal constant previous chapter 
generator function receives argument need check argument unifiable constant 
new residue unification generators 
unit clauses functional terms translate unit clauses functional terms 
type clause 
define translation scheme testers terms new function match name name match clause variable constant rhs translation 
argument match translation term clause head second goal argument 
function match returns singleton goal argument ground instance term clause 
returns empty list 
counterpart match original logic program 
need mimic unification core logic computation scheme 
hidden unification match erm erm match fs match fs match match match function match engine functional translation 
walking turing tar pit writing logic interpreter functional language 
firstly writing interpreter think structural correspondences interpreter program interpreted 
doing transplant logic computation functional language keeping textual similarity possible 
secondly functional program derived translation scheme manipulate original logic program represented data 
logic interpreters describe complete evaluation scheme apply logic programs data interpreting language 
light spirit exercise function match undesirable 
translation unification easily decomposed pair uni directional computations pure variables atomic constants 
unary functors introduce minimal structured data strings decomposition complex need string matching 
match simulates way unification checks goal argument instance term clause need way unification non unit clauses 
function match removes outermost functors second arguments long coincide 
argument clause reduces pure variable match returns indicating argument goal instance term clause 
arguments ground equal result 
result empty list 
function match performs way unification generalisation equality check scheme translate clause generator slightly different function erm erm erm fs fs fs fs function name names vj names arguments match goal argument instance term clause returns translation term goal variable bound 
returns empty list 
firstly removes common prefix arguments 
goal argument instantiated head result residue argument head term unified variable goal 
contrast goal argument instantiated variable goal remains unbound 
cases result empty list 
match conduct way unification combine stands unit clause reduce extra programming translation 
name name name names vj names schemes differ way computing main expression comprehension 
ignores result returns returns result directly 
possible define testers terms generators name name names name names erm erm erm fs fs fs fs function suggests possibility unified translation scheme testers generators 
input arguments match output list terms term goal ground unifies term clause returns 
pattern denotes success unification binding goal variable variable 
unary functors translation unit clauses requires auxiliary function mimicking way unification 
need genuine unification non unit clauses subsection 
translation non unit clauses order translate non unit clauses need modify function previous subsection 
clause head contains variable calculate initial value pass clause body 
function ignores variable clause head 

value goal variable depends value clause variable returned body 
compose function computes value goal variable value returned body keep computation body 
match erm erm erm erm erm erm match fs bs match fs bs match fs bs match fs bs match fs fs init fs fs match bs drop length bs match match function match 
remember parameter pattern invocations body literals transfer value working variable subgoal 
need modifications realise full unification functional setting 
implementing logic languages unification easily realised representing variables pointers 
clause variable represented pointer information transfer clause head leftmost body literal body literals automatic clause head body literals keep pointer variable variable binding occurred literal immediately applied literals 
necessary compose function hold variable binding completed goal variable explicit representation pointer keeping address matter terms bound 
translation communication mechanism simulated variable bindings list comprehension 
left right selection rule prolog essential translation 
function match executes unification goal argument term clause head 
clause variable match computes initial value goal argument 
goal variable match composes function compute binding value clause variable 
function match basis refinement rest section give detailed explanation 
argument match term clause head 
second third arguments complementary parts term goal called textual part variable part respectively 
function match returns list pairs function term 
output function applied value clause variable computes value variable part goal argument 
output term initial value clause variable 
note time invocation subgoal variable part may bound term computations preceding subgoals 
computing need pass value value term 
reason need divide goal argument pieces 
function match removes common prefix term head textual part goal argument 
rest term head functors common variable part match accumulates functors preparing reconstruction variable part 
goal argument reduces pure variable cases 
term head non ground initial value clause variable rest functors added output function 
ground output term clause variable output function returns rest term head 
term head pure variable initial value variable concatenation current textual variable part goal argument output function prepares extract variable part value clause variable 
arguments ground coincide initial value case output function returns regardless variable head variable goal 
translation schemes match defined name rhs name match fxg rhs name rhs name match oe rhs name rhs names vj match fxg rhs name rhs names vj match oe rhs scheme clauses non ground terms variable added environment 
head bound term unifying actual argument took place translation clauses 
example action match consider clauses goal clauses goal prolog systems resolve goal clause obtaining substitution goal variable variable clause 
goal resolved second clause producing substitution variable second clause 
remains unbound answer substitution 
goal non ground need generator functions clauses 
translate clauses goal equations expression ps vj match qs qs vj match ps parameters ps qs receive textual part variable part actual argument respectively 
equation match computes pair function term function applied return value qs 
second argument function call qs denotes variable part actual argument 
partitioning necessary need remember border coefficient variable 
ps invoked match returns pair partial application prepares reconstruction term second term indicates unbound 
function call qs corresponds resolution second goal second clause 
match returns pair drop denotes substitution 
output function drop immediately applied obtain value second goal variable 
output function applied yielding completes reconstruction 
translation scheme subgoals depends goals ground 
goals non ground scheme depends environment 
name rest names fxg rest name rest names rest name rest names rest cases terms head non ground 
variable environment variable part expression 
translation added environment 
environment variable part running variable output occurrence preceding subgoals translation subgoal assures current value denoted variable clause ground argument argument translates variable part textual part empty 
example body literals examples demonstrate scheme ground non ground literals 
mu fxg mu qs fxg mu qs rs ps mu oe mu qs oe mu qs rs example variable clause head environment contains 
second example translating subgoal environment empty variable part translation expression 
subgoal variable part running variable note subgoals body translated generators 
fact need explicit translation scheme tester functions auxiliary functions 
predicate definition tester function defined terms generator 
convert function match continuation passing style subsection 
matchc erm term head erm textual part 
erm erm erm continuation erm variable part matchc fs bs matchc fs bs matchc fs bs matchc fs bs matchc fs fs init fs fs matchc bs drop length bs matchc matchc matchc continuation passing style continuations translation schemes qualifier comprehension communicates running variable suggests computation represented continuation passing style eliminated way 
desirable variables clause body way communication channels list comprehension need distinct sorts variables arguments function calls input channel output patterns pass value qualifier output channel 
carefully placing continuation functions arguments eliminate variables 
convert function match new function matchc continuation passing style 
third argument matchc continuation function takes function term returns list 
position continuation important 
fourth argument variable part denoted running variable previous scheme 
explicit definition matchc functional extensionality leave implicit improved translation scheme 
eliminate second argument textual part translation contains source program information 
example eliminating variables consider clauses example translate clauses continuation passing style equations expression match nv match wrap wrap function wrap continuation target function wraps resulting term brackets 
functional extensionality eliminate match match 
eliminate variable output function obtaining match match eliminate continuation match match translation schemes clauses rhs matchc fxg rhs rhs matchc oe rhs stage translation schemes testers generators identical 
differences testers generators represented continuation function parameters 
obtain unified translation scheme predicate definitions 
body literals translated continuations preceding literal function matchc case leftmost literal name rest names nv fxg rest name rest names nv rest name rest names rest base case translation need continuation translation clause subgoal belongs function returned match 
example literals continuations clauses example illustrate translation scheme 
matchc fxg matchc fxg matchc nv matchc oe matchc nv fxg matchc nv nv concerning relationship patterns variable part environment exactly statements example hold variable part qualifier comes corresponding continuation 
variable part denoted running variable eliminate 
variable part left hand side eliminated 
second example simplified matchc matchc break function matchc set atomic functions recognises specific functor variable 
replacing matchc new functions obtain equations having better structural similarity original clauses 
main idea comes detailed analysis definition matchc 
definition equations deal unary functors removing composing partial application 
procedure repeated long remain unary functors term clause head 
unary functor sym parameter single recogniser function rc defined 
function rc takes unary functors sym argument 
second argument continuation recogniser subsequent functor necessarily unary term 
third fifth arguments arguments matchc textual part goal argument continuation variable part goal argument 
rc sym 
erm 
erm erm erm erm erm 
erm erm erm erm rc bs bs rc bs bs rc rc function rc removes leftmost functor textual part goal argument parameter 
textual part empty composes partial application equal leftmost functor variable part variable part pure variable 
cases result passed recogniser subsequent functor continuation 
innermost constants integers define similar function sym erm 
erm erm erm erm val val val val val innermost argument clause head integer goal argument non ground output function gives singleton integer regardless result body predicate 
goal argument ground coincides innermost argument clause head output function returns empty list regardless clause body 
case initial value empty list variable clause body 
innermost argument clause head variable function deals process erm 
erm erm erm erm drop length case initial value clause variable concatenation textual variable part goal argument 
computation body predicate output function removes remaining textual part term unified clause variable 
functions rc replace function matchc rhs oe rhs rhs fxg rhs functions defined rc example atomic continuations clause similar example term right hand side equation deceptive 
looks term logic program fact sequence recogniser functions containing continuations 
summary series translation schemes unary string logic language haskell defined 

presence unary functors way unification necessary translate unit clauses 
introduced function simulate unification 

order translate non unit clauses need genuine unification express bindings goal variable clause variable 
function match list comprehensions cooperate simulating unification 

converting match continuation passing style matchc eliminate list comprehension variables communication literals 

decompose matchc set atomic recognisers 
resulting equation name formal parameters counterpart original clause 
especially eliminated direct function simulating unification 
discussion chapter investigated expressive power functional languages describing logic computation defining translation schemes subsets prolog haskell 
aim exercise find convenient set functions combinators translate predicates functions equivalent predicates look predicates 
intention may best explained considering parser combinators grammar rules 
parser combinators write functional parser rewriting grammar rules different set symbols 
fact chapter predicates fixed modes obtain functions having obvious structural correspondences 
tried exercise predicates involving nonground computation 
residue unification unification resides core logic computation consider traces unification functional translation 
unification summarised translation schemes language gives function definitions structural correspondences remains small residue unification result 
fact need functions tester generator residue unification 
logic programming ground non ground queries handled uniformly prolog system logic programmers need care answer substitutions empty 
translation contrast ground non ground goals translate expressions distinct types 
need prepare functions different types reduce expressions 
possible merge functions introducing new data type representing non ground terms translation case need guarded equations dispatch different type inputs 
case need patterns deal types queries 
secondly translate non ground literals need auxiliary functions postpone decision call tester generator run time 
prolog systems handle non ground ground literals need devices choose tester generator dynamically 
extra programming need express unification functions predicate auxiliary higher order function 
simplicity source language don function explicitly simulating unification 
unification existence unary functors larger residue unification remained translation 
translating unit clauses introduced function simulating way unification 
avoided introducing translating unit clause series equations unification decomposed distributed 
discussed translated predicates pairs tester generator decomposed unification patterns 
term clause functors need different equations clause 
translation scheme explosion programming may acceptable introduced function counterpart source program 
counterpart inside prolog system 
discussed different writing logic interpreter 
function simulate unification data representing terms logic programming 
program data manipulated 
analogy parser combinators assert similarity grammar rules parser programs exclude defining texts combinators 
may think combinator 
order translate non unit clauses goal variable clause variable computed introduced full unification match 
introducing match difference testers generators ways treat value goal variable 
testers generators stem unification function simulating resemblance reasonable 
adopting continuation passing style matchc predicate obtained unique function 
differences testers generators absorbed continuation 
get rid name match replacing set recognisers 
final translation scheme converts logic clause equation notational changes replacing conjunction function composition 
final translation functions rc extra programming required unification 
translation interpretation aim writing translators assess expressiveness functional languages describing logic computation 
want trace logic computation step functional setting write logic interpreter functional language 
partial evaluation interpreter logic program obtain functional program representing exactly input output function original logic program 
order avoid turing tar pit impose structural correspondences source target programs 
unification implicit logic programming included functional computation scheme need extra function structural correspondence predicate 
predicate exists 
function simulating unification big interpreter 
residue big accept 
long function working data structure representing terms may say translating logic program 
important reason describing logic computation writing interpreters ease proof translation 
extraordinary difficult prove translation scheme derived ad hoc way 
conducting logic computation functional framework purpose 
find way modify computation unification free long prove 
may able stronger claim expressive power describing language 
logical variables restriction source language previous chapter exclusion nonground computation moded prolog output assured ground 
chapter represent uninstantiated variables translation 
translation language extra inner brackets denote unbound variables explicitly 
analysing source programs detect predicates producing uninstantiated results removed brackets 
translated language defined new data type representing term 
done translation eliminated auxiliary function discussed previous subsection 
choice introduces extra constructors resulting functional program adopt 
fact logic programming contains logical variables fundamental differences logic functional programming systems 
reddy states way achieve effect indefinite modes mimicking resolution interpreter functional program 
fact language small explicit resolution interpreter logical variables necessary represent unbound results 
source language augmented minimal structural data strings forced add functions simulating unification 
various possible directions ffl scheme eliminate level list structure full generators improved matched scheme eliminate second list structure cases exactly successful outcome guaranteed chapter ffl allow function symbols nullary constants source language need elaborate environments translation rules record information partially instantiated variables 
similarly multi argument predicate function symbols pose additional problems nonlinear parameter patterns common place logic programs 
course translating notorious meta logical extra logical primitives prolog cut cf 
greatly complicate matters 
ffl think switching source target language 
logic languages cover wider range computation example reddy obvious opposite direction translation easier 
need employ reduction engine translation 
translating higher order functions 
ffl translation scheme cut unary language presents surprisingly subtle problems 
definitive formulation rules kind proof effort may shed useful light obscure corners 

extra programming small subsets prolog shown translatable haskell retaining structural correspondence 
list comprehension convenient construct represent non determinism 
alternatively express non determinism continuation passing style programming 
case non determinism induces certain extra programming construct translation 

list comprehensions failure literals corresponds empty lists 
negation cause extra programming translation 

translation decompose unification uni directional computation 
need extra function simulating unification need equations logic clause 
translation unary functors dissolve unification pattern matching unacceptable increase program size 
introduced extra function simulating unification obtaining equation unit clause 

non ground computation causes extra data structures list structure new data type explicit representation variables 
defining translation scheme haskell wrote example programs verify translation scheme 
writing interesting programs easy regular expressions simply mapped example written obvious arbitrary program represent regular expression 
chapter challenges problem gives affirmative answer 
chapter accepting power unary string logic programs suppose writing logic program manipulate set strings language 
data type type logic programming systems term consisting constants variables functors need unary functors represent words object language 
smallest language able handle strings language containing constants unary functors unary predicates 
chapter discussed language called unary string logic language 
compared expressive power haskell defining translation schemes haskell 
quite small subset prolog order preserve structural correspondences needed extra functions mimicking parts unification 
chapter examine language different point view powerful acceptor formal languages 
unary functors program herbrand model set ground terms contains string functors terminated constant 
predicate defines set strings language word term model 
operationally word belongs language goal refutation program works machine recognising languages 
predicate defined clauses set ground terms satisfying model thought union sets ground terms associated defining clauses 
conjunctive bodies indicate intersection languages corresponding body literals contained set languages corresponding program 
recursively defined predicates suggest kleene closure concatenation 
observations suggest languages associated programs regular 
aim chapter prove conjecture conjecture programs accept exactly class regular languages 
words expressive power accepting languages coincides class regular languages 
regular language specified finite automaton order prove conjecture show mapping set finite automata set programs 
automaton equivalent logic program refutation ground goal implies path associated functors goal leads final state vice versa 
proof consists parts 
firstly show deterministic finite automaton dfa converted equivalent program 
fact convert dfa programs written subset called regular unary string language rus 
strong similarity transition rules dfa rus clauses part relatively easy 
secondly prove program converted equivalent non deterministic finite automaton nfa ffl moves 
cope prefixes clause bodies conjunction body literals second part harder 
translation results conclude programs accept exactly class regular languages 
small logic languages rus explained 
brief definitions finite automata partly introducing notational conventions 
section defines conversion scheme arbitrary dfa rus program proves equivalence 
conversion scheme programs nfa proved 
section discusses related concludes 
preliminaries section defines logic languages rus introduces notations derivations refutations logic programs sections 
clause clause clause head head body head atom body atom atom body atom name term term name term goal atom syntax section includes brief definitions dfa nfa ffl moves notations graph representations automata 
cases terminology logic programming 
automata theory adopt notations 
unary string logic language language definite logic programs containing constant terminator strings object language variable represents suffixes strings countably unary functors countably unary predicates 
syntax 
chapter assumed countably constants 
constant object language constant sets ground terms terminating different constants pair wise disjoint 
sake simplicity assume constant 
language contain negations extra logical predicates 
extralogical predicates read write assert retract impede logical reading programs conjecture relies 
negation understood connection complementation regular sets left 
furthermore assume constant may appear unit clauses 
ground body literals guards computing intersection non ground goals provide especially interesting consequences exclude 
examples legal clauses include atom denoted 

clauses denoted symbols symbols denote goals 
derivation goal program finite infinite sequence goals gamma 
gamma 
gamma 
clauses derived gamma step resolution 
refutation finite derivation goal empty gamma 
gamma 
gamma 
cn gamma 
rus regular unary string logic language rus subset ffl clause atom body ffl unit clause functor symbol ffl non unit clause exactly functor symbol head ffl functor symbol clause body 
syntax rus 
language quite restrictive 
rus clause forms rus clause clause rus clause head head body head name term term name body name syntax rus allowed rus 
finite state automata deterministic finite automaton tuple sigma ffi finite set states sigma finite input alphabet initial state set final states ffi transition function type theta sigma finite automaton depicted graph node corresponds state edge state state annotated symbol corresponds transition graph notation represent transition order represent sequence transitions path associated string write ffi ffi fn gamma 
gamma 
finite automaton accepts string sequence transitions initial state associated string leads final states automaton 
star superscript indicate final state ffi ffi fn name final state relevant fi ffi ffi fn fi nfa ffl moves automaton non deterministic states transition input symbol 
type transition function ffi theta sigma denotes power set empty transition transition consume input symbol denoted ffl transition function ffi nfa ffl moves type theta sigma ffflg known non deterministic finite automaton empty transitions converted equivalent deterministic finite automaton 
state transition system sts order clear matching logic programs recognising machines occasionally term state transition system sts 
sts automaton initial state fa deterministic non deterministic sigma ffi define sts sigma ffi 
define different automata choosing specific state initial state 
subsequent arguments strictly speaking logic programs corresponds sts pair logic program predicate name corresponds pair sts initial state automaton 
deriving rus program fsa section considers translation finite automata regular unary string logic programs 
subsection describes construct rus program arbitrary finite automaton 
prove equivalence original dfa derived rus program 
start dfa accepting strings containing number rus program derivation rus program finite automaton sigma ffi construct rus program rus follows 
state introduce unary predicate 
symbol alphabet sigma introduce unary functor 
transition rule add clause rus 
final state add unit clause rus 
initial state specifies predicate initial goals 
input string represented initial goal 
example graph fig represents dfa accepting strings fa bg containing number number taken 
arrow pointing node denotes initial state 
state final state program fig rus program derived procedure 
claim derived program rus equivalent finite automaton sense theorem 
theorem goal refutation rus accepts string initial state verification derivation direct mapping transition rules clauses proof straightforward 
proof ffl suppose automaton accepts string initial state path fn graph 
transition function ffi contains transitions gamma 
rule derived program contain clauses gamma rule accepted string represented initial goal applying clauses successively initial goal obtain derivation gamma 
gamma 
cn gamma 
gamma derivation refutation initial goal 
ffl suppose goal refutation derived program refutation gamma 
gamma 
gamma 
find accepting path proof induction length string 
initial goal 
order derive empty goal program contain 
unit clause derived program constructed rule clause 
final state path length accepting empty string 
suppose refutable goal exists path final state 
need show exists path final state string 
consider goal refutation gamma 
gamma 
gamma 
gamma 
form initial goal program contain clause resolves initial goal obtaining new goal 
goal refutation resolution step contains gamma functors induction hypothesis exists path leading final state 
existence guarantees existence path gamma 
combining paths finish proof 
deriving fsa program previous section shown dfa equivalent rus program program rus proper subset 
section prove program equivalent nfa ffl moves 
frequently term sts defined 
order construct finite automaton equivalent pair predicate name program describes construction basis sts representing clause heads sts contains possible segments paths containing ffl move 
words paths final automaton contain ffl move 
considers interpret body literals non unit clauses 
procedure construct automaton defined 
non unit clauses iteratively augmented order accommodate conjunctive bodies calculate intersection automata corresponds conjunct body 
construction proved correct construction program construct equivalent finite automaton steps 
subsection focus attention clause heads program construct basis subsequent subsections extend sts contains essential transition sense ignore body literals program non empty move final automaton counterpart additional state collective shadow states see 
sts sigma ffi constructed follows ffl input alphabet sigma set functors ffl state labelled singleton set name lists 
name list predicate name followed possibly empty list functor names 
state names set extend machine need name compound states corresponds set states ffl predicate name contains unique state call states single element unit length predicate states 
ffl clause head 
contains derived states call state including full sequence functor symbols bottom state clause head 
different clause heads introduce different sequences states predicate names sequences functors 
predicate defined set clauses sharing prefixes arguments corresponding derived states distinguished superscripts 
example abbreviations details relevant 
ffl unit clause 
bottom state final state 
star superscript indicate final state 
ffl unit clause variable bottom state program looping arc alphabet symbol sigma 
sigma transitions ffi 
ffl clause head 
gamma hn gamma transitions ffi 
sts set linear sequences states 
derived state exactly coming non empty move 
derived state bottom states unit clauses variables going move 
number states equal sum number predicate names number occurrences functors program 
example consider program fig 
sts derived contains predicate states derived states andf including final state graph fig 
interpretation body literals consider subgoals non unit clauses 
clause read declaratively term true true 
order convert clause set state transitions paraphrase true leads machine final state 
re write sentence path preceded path leads automaton final state path preceded path leads machine final state 
variable body literal denotes set paths begins goal states literal defined 
definition goal states goal states body literal denoted set states reachable predicate state successive moves associated functors order possibly interspersed ffl moves 
connect bottom state clause head goal state ffl move 
connection string connected strings represented starting goal state path final state obtain accepting path example consider clauses goal program query prolog systems give answer 
derived automaton connect bottom state clause ffl move state similarly connect ffl move obtain ffl ffl downward arrows associated ffl represent reversed implications second clauses 
accepting path ffl ffl admits string ace corresponding answer prolog systems 
computing goal states assuming left right selection rule prolog systems goal states body literal constructed examining refutations literal 
refutation prefix functors initial goal removed leftmost literals successive goals sequence clauses unifying leftmost literals 
want know clauses remove functor heads clauses contain goal states searching 
consider literal successful derivation gamma 
gamma 
gamma 
gamma 
goals clauses corresponding resolution steps 
clause unit clause fact final 
consists subgoals 
original goal reduced empty goal reduced empty goals 
argument holds leftmost literal sequence goals represented proof tree nodes depth denote subgoals left right order 
leaf tree empty goal edge indicates descendant subgoals leftmost subgoal instance subgoal goal 
example proof tree refutation represented proof tree 
refutation roof tree leaf tree empty goal path root leaf exactly edge connecting subgoal containing suffix subgoal contain suffix empty goal 
thick arrows indicate edges 
clause resolution step contain suffix term original goal unit clause non ground term 
goal state refutation consists states derived clauses 
example head contains prefix argument subgoals contain second resolution step head argument contains state component goal state 
resolution step involving component derived 
component comes clause goal state refutation goal states goal set states derived refutations number refutations goal may infinite finiteness number functors original goal number goal states specific goal finite 
example consider program partition search goal states literal derivation starts step gamma 
goal contain suffix term instance term literal 
state goal state 
derivation gamma 
gamma 
clause step removing clause removing rest state goal state 
ff gg construction literal clause body variable common conjunction literals asserts terms satisfying respective body literals share suffix denoted context finite automaton clause interpreted path path followed leads automaton final state simultaneously path followed leads machine final state 
need check paths literal share sequence alphabet symbols 
order convert conjunctive goal graph examine possible tuples paths literal denotes set paths starting corresponding goal states 
suppose conjunct goal states fs add theta theta new states fs automaton add ffl moves bottom state 
state automaton just add ffl moves 
new state examine component state outgoing arc alphabet symbol 
create new destination state tuple destination states component connect arc corresponding symbol 
note compound state unique outgoing arc symbol 
view part automaton added clauses conjunctive bodies shadow part path new part set copies repeat process new state arc added graph 
construct converting non unit clauses iteratively 
automaton fixpoint iteration 
formal description process converting non unit clause follows 

starting iteration ffl moves graph status initial 
status ffl moves examined iteration far 

literal choose state construct compound state 
empty set goal states clause processed 
call component state 
state graph graph add 

add ffl move ffl graph 
pointer current node points node going traverse paths starting parallel 

component state transition common alphabet symbol say consider state transitions graph 
add arc graph 
update current node go back 
component set ffl moves case component state bottom state ffl moves checked status choose ffl move consider new state gamma ffl chosen ffl move 
graph add graph add transition ffl change status ffl move checked 
update current node go back 
components share going functor symbol ffl move finished cycle conversion 
component states final states mark final 
go back 
repeat step choices calculate repeat entire procedure clauses new transitions states added graph 
termination process states number occurrences functors plus number predicate names compound state denoted set names number states exceed size power set set names number possible transitions finite number actual transitions graph increases step process terminates 
example consider program fig 
basis program clauses predicate state outgoing edges 
double circle indicates final state derived unit clause 
shows configuration iteration conversion clauses 
total ffl moves dashed arrows added ffl ffl ffl ffl program step iteration state compound state generated conjunctive body clause state start tracing paths parallel 
outgoing edge associated new compound state edge added move ffl caused ffl move ffl proceed edge associated ffl move ffl caused ffl move ffl leads automaton note move names source state reduce union operation building name state 
subgraph starting state final graph intersection subgraphs verification construction theorem claims constructed automaton equivalent theorem finite automaton constructed procedure described previous section accepts string state goal refutation proof ffl part suppose goal refutation gamma 
gamma 
gamma 
cm gamma 
cm clauses successive intermediate goals empty goal 
show sequence moves possibly interspersed ffl moves state final state associated symbols order 
proof induction length derivation 
base case goal step refutation contain unit clause form construction graph contains fn sigma expression sigma denotes set loops alphabet symbol 
final states case path associated final state 
inductive case assume goal refutation length gamma automaton accepts corresponding string refutation length clause derivation step form hm 
automaton contains theta theta ffl moves bottom state compound states fs jm gamma 
ffl fs jm th state derivation step new goal conjunction subgoals hm subgoal refutation length gamma induction hypothesis contains path fs gamma 
fi fs member contains path final state starting compound states eqn 
fs jm gamma 
fi combining eqn eqn contains path gamma 
ffl fs jm gamma 
fi shows accepts string 
ffl part suppose accepts string initial state need prove goal refutation proof proceeds induction number ffl moves path 
base case firstly consider case ffl move accepting path path consists exactly moves ffi fn gamma ffi fn fi path constructed non unit clauses contains ffl move accepting path derived unit clauses 
program contain unit clause forms clause gives step refutation initial goal 
secondly consider case accepting path contains ffl move path starts predicate state contains ffl move program contain non unit clause hm ffl move bottom state compound state fs derived body literals gamma 
ffl fs gamma 
fi 
ffl move compound state final state program contain unit clauses form gives component state 
application clause initial goal gives new goal hm ground subgoal eqn refutation 
state member derivation gamma gamma goal containing suffix clause unit clause eqn 
ground subgoal trying refute instance apply clause ground subgoal 
resulting ground goal instance clause keeps suffix intact 
apply clause 
step refutation unit clause applied gamma finishing refutation 
ground subgoal refutation obtain refutation initial goal 
inductive case assume path gamma ffl moves corresponding goal refutation path gamma 
fi contains ffl moves 
clause applicable initial goal clause form eqn resulting new goal eqn 
clause corresponds ffl move path ffl fs fn fi path fs final state gamma ffl moves 
constructing path compound state trace different paths parallel ffl move add ffl move compound state 
number ffl moves path compound state final state sum number ffl moves component paths 
gamma ffl moves component state final state induction hypothesis ground subgoal eqn refutation 
initial goal refutation 
discussion summary expressiveness rus subsection considers expressive differences rus 
proven lemmas program transformed equivalent nfa ffl moves dfa transformed equivalent rus program 
nfa ffl moves converted equivalent dfa obtain translation scheme subset rus nfa ffl gamma moves dfa rus resulting rus program original program accept exactly language 
syntactic restriction rus doesn hamper expressive power describing language acceptors 
equivalent programs written rus may quite different size 
automaton derived set clause heads program number states sum number predicates number occurrences functors program 
state corresponds subset sets number possible states np convert automaton dfa 
nfa ffl moves converted equivalent dfa steps removing ffl move nfa converting nfa equivalent dfa 
ffl moves removed number states change conversion nfa dfa causes potentially exponential increase number states states resulting dfa correspond subset states nfa 
number states dfa worst case np fact estimation probably pessimistic 
automaton derived program predicate states bottom states compound states containing bottom state component multiple outgoing edges 
outgoing edges bottom states ffl moves 
eliminating ffl moves procedure described number states having multiple outgoing edges nondeterminism occur change 
expressive power answer set results chapter obtained matos published theoretical computer science giving different proof similar equivalence theorem april 
terminology monadic logic programs correspond programs chapter 
order prove equivalence regular sets monadic programs matos reduces monadic logic programs subset called linear monadic programs proves accept exactly set regular languages 
resulting linear program accepts languages original general monadic program 
firstly shows monadic program contain clauses conjunctive bodies reduced set clauses body predicate functor symbol 
monadic program containing clause conjunctive body shown reducible set linear clauses plus clause containing body predicate terms contain functors 
program matos derives simultaneous equations predicate name represented language variable 
solving equations reduces clause body predicates linear form 
main difference matos proof avoids direct construction intersection automata corresponding member conjunctive body reducing clause body minimal form proving solve corresponding algebraic equation 
cases hardest part proof handle conjunctive clause bodies 
proof directly build intersection body predicates tracing path graph built clause heads 
idea body predicate term corresponding states goal states basis essential proof 
different types correspondences correspondence programs regular sets chapter different correspondences logic programs grammars usually considered literature 
papers discuss similarity derivation trees grammars proof trees logic programs 
proof tree definite logic program propositional form similar derivation tree context free grammar cfg 
propositional term logic program corresponds non terminals cfg 
arguments predicate terms general logic programs viewed embedded stack indexed grammar set attributes attribute grammar 
extra information proof tree grammars extension cfg 
authors studying correspondences interested answer set logic program 
papers discussing power logic programming systems describing language acceptors 
expressive power logic language discussed context process calculating answer set chapter 
research may provide clues source expressive power logic languages 
summary 
set programs written small subset pure prolog called shown equivalent class regular languages 

subset called rus shown equivalent ability accepting class regular languages 

try write rus program equivalent program number predicates rus program number predicates program 
result obtain chapter strong 
way write program accepting context free context sensitive recursively enumerable languages 
immediate question minimal extension accept lan guages higher levels chomsky hierarchy 
chapter gives answers problems 
chapter binary string logic programs chapter logic programs containing unary predicates string arguments shown accept exactly type languages regular languages 
long programs contain predicates single string arguments clause interpreted sequence state changes finite automaton 
immediate question order describe acceptors languages higher types context free context sensitive recursively enumerable languages powerful predicates need 
chapter concentrates expressiveness logic languages having predicates string arguments binary string logic language bs 
full syntax bs 
definition bs binary string logic language bs definite logic language containing countably variables countably constants countably unary functors countably predicates arguments 
example clauses correct bs clauses 
exclude prog ffl clause prog clause head head body head atom body atom atom body atom name arg arg arg variable constant name arg goal atom syntax language bs clause contains predicate having argument head second clause argument 
chapter characters near front alphabet denote tape symbols characters near tail alphabet denote stack symbols greek letters ff fi fl denote strings stack symbols 
term fl denotes term fl stack symbols 
string tape symbols write term am stands string am show small subset bs powerful describe turing machines 
considers restrictions bs language describe cfl acceptors 
gives summarises 
bs describe turing machines section show small subset bs describe turing machines acceptors languages 
additional string argument big jump power acceptors finite state machines turing machines 
surprising 
turing machines order represent turing machines logic programs instantaneous descriptions id turing machines 
introduce idea id adopt description turing machines 
standard turing machine consists semi infinite right tape tape head 
tape divided cells hold tape symbol 
tape head reads tape prints symbols tape 
head may move cell time left right 
head contains machine state 
formally turing machine tuple sigma gamma ffi ffl finite set states 
ffl gamma finite set tape symbols containing special symbol ffl sigma ae gamma finite set input symbols contain ffl ffi specifies moves partial function theta gamma theta gamma theta fl rg 
ffl initial state machine 
ffl denotes blank 
initially finite input string written tape left adjusted 
rest tape supposed filled ffl set final states 
ffi contains transition 
currently machine state head looking cell holding machine takes actions 
change state 
print cell currently holding 
move head left right instantaneous description instantaneous description id conveniently describes configuration machine time point 
id ff fi gamma strings tape symbols rightmost non blank symbol machine state 
id indicates current tape symbols string fffi machine head looking head fi 
id describe machine moves 
suppose current id gamma machine chooses transition 
machine move represented transition id gamma gamma gamma note left moving transition defined 
chooses transition 
write gamma gamma tape head right transition tape cell right 
set input strings sigma accepted consists words leads final state written left tape machine initial state head machine looking symbol words language accepted sigma ff fi gamma denotes reflexive transitive closure 
bs representation turing machines describe turing machines bs 
turns order represent turing machines small subset bs suffices 
need variables say clause body atom sole constant say appear program clauses appears initial goal 
syntax subset 
bs clause prog ffl clause prog clause head head body head atom body atom atom state word word word sym word goal atom syntax bs state sym disjoint sets names 
illegal contains body literals body literals contains constant 
legal form clause fact permissive see 
relationship programs finite automata bs rich direct mapping bs programs turing machines 
translation map id gamma qa machine goal bs gamma gamma tape symbol designated functor bs 
strings tape symbols represented unary functional terms constant innermost argument 
state mapped predicate name 
argument corresponds initial part tape cell left head reverse order second argument represents rest tape 
initial id denoted initial goal argument indicates input string left adjusted tape head looking element input string 
map transition rule 
clause single move id simulated single resolution step goal corresponding old id unified clause head new goal derived body literal represents new id move function ffi translates set clauses 
right left moves tape head require different translation schemes 
right move transition head moving right 
causes change id gamma symbol overwritten rightmost symbol left portion string 
represent move clause variables denote left right portion string respectively 
reverse order representation outermost functor argument 
hand second argument stripped outer functor representing string symbol shorter previous id left move action head moving left 
involves change gamma symbol left head old id left move outermost functor appear transition rule 
order describe situation need set clauses gamma 
tape symbol need clause number clauses bs program describing machine may bigger number transitions machine 
acceptance input string accepted lead final state halt gamma transition 
bs translation initial goal set clauses derivation fg leads goal gamma order terminate computation add set unit clause example language turing machine accepting fa jn fq fa bg fa bg ffi fq transition function ffi 









machine changes leftmost moves head right searching 
changing leftmost head returns left searching rightmost 
sequence repeated changed 
machine enters final state accepts string 
machine halts rejecting string 
corresponding bs program functor symbol corresponds transition head moving left expanded set clauses tape symbol 
unit clause program defines termination program 
goal corresponds string aabb program answers 
restricted bs describing npda previous section subset bs shown powerful describe type language acceptors turing machines 
implies language prog ffl clause prog clause head head body head atom body atom atom state word stack word constant variable term word stack constant variable stack goal atom syntax bsc term disjoint sets names 
chomsky hierarchy accepted bs program sense turing machines simulate lower level language acceptors 
hand know previous chapter need expressive languages want describe acceptors languages type type bs fact expressive describe turing machines bs describe way finite automata simply prohibiting write operation tape 
investigate syntactic restrictions bs programs written language accept context free languages 
firstly define restricted bs language describe non deterministic push automata acceptors cfl 
extend language different ways language accepts cfl 
syntax new language bsc 
essential syntactic restriction bs accept cfl arguments predicates disjoint name space 
non deterministic pushdown automaton subsection notations 
non deterministic pushdown automaton npda finite automaton augmented pushdown stack 
tape head read tape move right 
move replaces stack symbol stack top possibly empty string stack symbols tape head moves cell right stays current position empty move finite automaton 
move machine determined triple current state input symbol head currently looking symbol stack top 
machine may distinct moves triple non deterministic 
formally pushdown automaton tuple sigma gamma ffi ffl finite set states 
ffl sigma finite set input symbols 
ffl gamma finite set stack symbols 
sigma gamma assumed disjoint 
ffl ffi partial function theta sigma ffflg theta gamma theta gamma denotes powerset 
ffl initial state machine 
ffl gamma start symbol indicating bottom stack 
ffl set final states 
kinds transitions ffi 
type consume input symbol ffi fl fl fl currently state head looking cell holding stack top machine non deterministically chooses tuples fl set right hand side rule 
changes state 
replaces fl 
moves head cell right 
fl empty machine simply pops stack 
second type transitions ffi ffl fl fl fl case replaces stack top symbol moving head 
transition defined certain triples machine halts accepting rejecting input 
consider acceptance empty stack translation 
string initial state stack symbol bottom stack halts empty string empty stack accepts acceptance empty stack acceptance final state equivalent cfl npda accepting language empty stack show express bsc npda accepting languages empty stack 
instantaneous description describing turing machines instantaneous descriptions id express npda behaviour 
id npda form ff machine state remainder input string ff current stack 
machine id aw ff machine chooses transition 
fi write aw ff sigma string input symbols sigma input symbol gamma stack symbol ff fi gamma sequences stack symbols 
machine sigma gamma phi accepts string empty stack ffl ffl state reflexive transitive closure 
bs description npda translation strategy npda similar turing machines previous section 
represent id goal machine state translates predicate input symbol sigma translates functor stack symbol gamma translates functor sets names state term correspond sigma gamma respectively 
initial id translates initial goal transition rule ffi translated clause derivation successive id simulated resolution step 
types transitions translated slightly different clauses 
transitions consuming symbol transition 
fl causes change id ax sy fly fl possibly empty sequence stack symbols stands rest input represents tail initial stack 
translate transition clause fl term fl stands 
fl empty term fl reduces empty transitions empty transition form ffl 
fl 
tape head doesn move transition input remains intact transition sy fly fl 
translation transition simply fl acceptance npda accepts word sequence transitions ffl ffl 
translated logic program initial goal refutation 
add unit clause program 
example pda accepting language fa jn example cfl accepted state npda fpg fa bg fs dg ffi phi transition function ffi ffi bb db ffi ffl ffi ffl initially sole symbol stack machine state symbol move defined triple machine halts accepting string 
symbol replaced case comes stack top possible character accepted language string ab 
comes stack top machine replaces stack top bb db 
general stack top replaced bb number stack number scanned far 
choice machine expects number rest string 
stack top replaced db number stack number scanned far 
machine expects receive rest string 
machine guesses right assume machine reads counts number stack 
input stack empty time number machine accepts 
case machine halts accepting string 
input string supplied computation displayed id 

db 
bbb dbb abb bb bbb bbb bb bb ffl ffl superscript denotes rejection denotes acceptance 
corresponding bs program symbols hat denote respectively 
body atom argument pure variable indicating head move left 
non determinism seen pairs clauses 
refutation sequence goal phi phi phi phi phi phi phi extension multiple terminal symbols clause heads seen bs program consists set bs clauses form stack symbols unit clause accepts cfl 
words program having special form interpreted description npda accepts cfl 
section try extend form clauses keeping program accepting cfl 
section consider multiple terminal symbols argument clause heads 
clauses represent rule cfg sfl sequence tape symbols fl sequence stack symbols 
rule greibach normal form known convert rule 
process parallels conversion 
consider adding clause fl fl stack symbols clause appears derivation goals form stands tape symbols stands stack symbols derived initial goal 
effect clause derive new goal fl exactly effect obtained replacing new clause clauses standard form involving completely new stack symbol fl derivation steps fl stack symbol new intermediate goals affected replacement replacement change meaning program 
procedure extended arbitrary number functors argument clause head 
extend form clauses program fl arbitrary unary term accepting cfl 
extension ii terminal symbol clause body extension show clause form fl added convert new program fcg normal form programs containing clauses accept cfl 
hard find corresponding grammar rule form clause 
empty move npda 
may help imagine machine behaves npda write arbitrary tape symbol cell head looking moving head 
cases handle distinctly 
fl non empty easy show clause reduced set normal form clauses unfolding 
fl empty need encode pairs non terminals new non terminals 
fl non empty fl non empty find pair fl clause represented clause unfolded clauses form replace clause set clauses normal form 
short extend form non unit clauses sigma gamma gamma clause unfold clause clause useless just remove 
fl empty going show add clause normal form program resulting program fcg accepts cfl 
unfold set clauses form replace set clauses clause appear successful derivation remove 
case non empty fl obtain normal form clauses unfolding 
functors second argument head 
clauses indicate context sensitivity form clauses correspond grammar rules uv rule context sensitive languages 
show add clause normal form program resulting program fc accepts cfl 
order show transform program fc normal form program fc explanation assume clause contains symbol body literal 
restriction lifted basic proof conjecture 
principal idea transformation encode patterns second argument body literals introducing new stack symbol transformation proceeds follows 
replace clause new clause new stack symbol 

clause having inner functor head add new clause head pattern encoded 

clause having stack symbol body literal ff add clause ff newly introduced stack symbols 
rule clause containing stack symbols head replaced normal form clause rule rule introduced new normal form clauses 
obtain normal form program fc prove accept language 
theorem goal 
refutation 
proof ffl suppose fc accepts word refutation fc clause involved 
note need examine refutations involving refutations proceed exactly way clause removed program newly added clauses appear refutation involving contain new stack symbols appear original derivation 
refutation involving resolution step introducing pattern intermediate goal 
intermediate goal fl clause containing ff fi obtain goal ff fi fl derivation steps popping symbols ff outermost functor fi fl clause derivation case induces rightmost stack symbol subsequent derivation 
set normal form clauses ffi ffi gamma ffi program derivation involving clauses order necessarily successively derives goal ffi fi fl case obtain goal fi fl get fi fl goal derivation hypothesis 
may derivations obtaining fi fl normal form clause 
refutations find refutation fc consider resolution goal clause 
transformation rule clause ff fi fl unifies goal 
clause obtain goal containing ff fi fl corresponding goal 
goals derivation tree 
exactly derivation steps obtain fi fl derivations obtain fi fl clause obtain goal fi fl time functor appears goal outermost functor derivation steps original program simulated derivation steps modified program derivations lead goal 
initial goal having refutation involving original program refutation modified program refutation involve new clauses affected transformation program 
shown 
ffl order prove remind program contains clause clause program contains 
refutation involving clauses common refutation 
refutation involving newly added clauses contains resolution step fl ff fi fl newly added clauses ff fi introduces new stack symbol new stack symbols appears intermediate goal symbol descendants remain goal clause clause removes newly introduce stack symbols goal arguments 
derivation step appearance goal step descendant removed goal simulated derivation original program 
derivations contain goal refutation 
refutation refutation proved 
multiple occurrences explanation conjecture assumed clause original program occurrence body clause containing form ff fi ff fi contain transformed clause ff fi order generalise form clauses consider consecutive occurrences clauses form ff fi need add new clauses ff fi ff fi encode term different derivations general encode ff fi consecutive occurrences need add fib clauses fib denotes fibonacci function 
order extend general case clauses consider multiple groups consecutive occurrences clause 
consider clause ff fi ff fi ff fi groups occurrences 
group needs fib different patterns need add program cross product patterns denotes number functors discussion complexity languages language acceptors chapter motivated result previous chapter set unary string logic programs isomorphic set finite automata 
immediate question correspondences subset logic programs set complex automata 
extended obvious need complex logic language describe involved machines 
order gain insight complexity types automata treated previous chapters normalised representation machines containing predicate name fsa npda fl tm clause denotes derivation id corresponding machines 
observe restrict clauses npda second argument form obtain npda having stack depth reduces fsa 
comparing tm fsa recognise forbid tm write tape machine reduces way fsa 
idea rep fsa rep npda rep fsa rep tm 
relationship normalised representations npda tm obvious 
derive original representation npda tm separating set possible functors second arguments restricting predicate names 
reason clear syntactic distinctions languages describing npda tm 
binary string logic languages 
context free grammar possible extension context free grammar transformed greibach normal form npda accepting language generated grammar simulates derivation grammar 
clauses bsc program representing id npda functor corresponding left hand variable rule head afl fl second extension saw add clause program accepts cfl 
clause understood denote grammar rule uv context free grammar add arbitrary number rules form grammar obtain cfg 
grammar contains rules form ff nonterminal ff non empty string terminals non terminals generated language cfg requirement form rules sufficient condition generating cfl 
find necessary condition set rules generating cfl 
need content show extend grammar context sensitive rule changing type generated language 
problem general necessary conditions cfg remains open 
simultaneous extension shown different extensions bsc obvious extension clause adding clause keep program accepting cfl 
mixed languages imagine language containing binary unary string predicates clauses fl chapter conjunctions clause body interpreted intersections fsa 
possible extend interpretation clauses form 
known intersection cfl regular language cfl able devise mixed language program denotes cfl acceptor 
leave problem research 
summary summarise chapter 
binary string logic languages powerful describe turing machines 
order need small subset bs bs clause contains body predicate 

subset bsc bs clause body predicate functors appearing second arguments mutually disjoint describe npda 

possible extend bsc language contain clauses fl language describes npda 
extension corresponds cfg rule fl 
interesting extension allow clauses form bsc programs 
extension corresponds grammar rule uv cfg rule case accepted language contextfree 
chapter summary chapter results previous chapters point view question expressive power declarative programming languages 
far succeeded answering question 
study divided parts accepting power languages comparative study expressiveness translation 
assesses results chapters investigate logic languages power accepting formal languages 
compares expressive power logic functional languages 
extensions suggested section summarises 
accepting power logic languages chapters investigated power logic programming systems accepting languages various levels chomsky hierarchy 
logic language contain function symbols datalog model herbrand universe programs consists predicate terms arity predicate constants 
language impossible write acceptors formal languages level chomsky hierarchy languages may contain infinitely words arbitrary length 
order manipulate words strings symbols taken alphabet unary function symbols necessary logic program 
unary function symbols give additional expressiveness languages datalog model 
example syntactical extension enhances expressiveness original language 
accepting power choice examined definite logic language containing unary function symbols predicates probably minimal language capable manipulating strings 
absence multi argument predicates machinery program conjunction implication connectives logic programming 
turned chapter arbitrary fsa mapped pair program goal 
conversely program written represents set finite automata associated predicate name specifying initial state automaton 
quite strong result impose syntactic restriction programs 
arbitrary program shown equivalent set overlapping finite automata 
program recognise lexical tokens recognise programming languages defined context free grammars 
minimal extension datalog results power accepting regular sets 
accepting power bs confined regular languages investigated logic languages predicate string arguments language bs 
language bs explained turing machine described subset bs clause contains body literal bs 
perform computation bs program 
expressiveness power accepting language reaches maximum adding string argument 
time correspondence programs machines satisfactory arbitrary bs program describe turing machine 
bs program description turing machine need impose restrictions clauses predicate argument function symbols 
language bs expressive find direct mapping programs machines superset bs 
language bsc order fill gap fsa turing machines looked restrictions bs describe push automata 
shown language bsc describes non deterministic pushdown automata 
language bsc obtained bs restricting language predicate sets function symbols second arguments predicate disjoint 
complete separation arguments language longer able represent tape head moving back forth input unable describe turing machines 
bsc programs mapped npda 
identify npda program written subset bsc having function symbol argument clause head representing read input push stack respectively 
examined far restriction bsc lifted find largest subset bsc describing npda 
programs arbitrary function symbols argument representing input tapes describe npda 
discussed bsc programs having function symbols argument representing stack 
shown consecutive symbols encoded new symbol programs containing predicates describe npda 
remarks accepting power expressive power logic languages accepting formal languages reaches maximum early stage language extensions 
small subset bs describe turing machines 
extend accepting power known machines turing machines 
may think reducing language searching minimum language able describe turing machines 
subset bs structurally simple 
contains implication connective logic languages 
contain conjunctions 
language simpler bs describing turing machines 
discussed language bsc seen naturally extension intermediate language binary predicate 
sole predicate language constant string argument 
language accepts exactly set languages regular sets 
obtain bsc intermediate language replacing constant argument unary functional term 
replacement constant arguments string arguments provides additional expressive power 
may case various intermediate languages interest datalog bs 
detailed examination subtle differences languages may shed light expressiveness comes language constructs 
logic computation functional languages previous section summarised results absolute expressiveness 
tried measure expressiveness subsets prolog chomsky hierarchy tool calibration 
relative expressiveness languages issue 
compare logic languages functional ones expressiveness 
chapters concentrated express logic computations functional setting 
cases important rule translation keep structural correspondences predicates resulting functions 
experimental translation practical logic program chapter conducted experimental translation fairly large practical prolog program haskell 
exhibited functional counterparts techniques thought specific logic programmers backtracking list comprehension definite clause grammar parser combinators non ground computation partial applications functional composition meta logical operators higher order functions clause manipulation continuation passing style programs cut operators logic programming major obstacles translation 
furthermore translated program ad hoc way 
order prove soundness translation need define translation schemes 
translation scheme moded prolog chapter defined translation scheme moded prolog haskell 
predicate translated function definition list comprehensions 
structural correspondence predicate definitions functions resulting equations contain number function invocations number body literals original clause 
definition list comprehension haskell defined translation scheme cut operators function cut newly defined combinator 
list comprehension syntactic sugar haskell sufficiently powerful programming construct simulate left right selection rule prolog 
detect determinate predicates get rid redundant list structure predicates 
simplification common predicates textbooks append translated function definitions containing fewer variables 
limitations remain family moded programs 
multivalued predicates need outer list structure extra programming construct comes backtracking nature prolog 
non linear input patterns clause heads gave rise equality tests translation 
non linear output patterns body literals cause equality tests 
addition non linear output pattern may cause computation worst case may terminate discussed 
moded prolog unification replaceable pattern matching 
non ground computation chapter tried formal translation prolog involving non ground computation compromise logic computation scheme 
aim describe logic computation functional setting inevitable result translation contain certain amount extra programming simulating unification 
target minimise residue unification keeping structural correspondences parts translation 
language started small subset prolog unary datalog language 
programs expressed entirely language write general applications non ground computation emerged translation scheme 
predicate translated functions distinct types tester generator 
ground non ground body literals translated invocations testers generators respectively 
despite decomposition unification directional parts time translation possible decide directions intermediate computations 
need auxiliary function postpone decision run time 
furthermore order simulate data transfer body literals need extra programming construct nested list structure representing non ground terms 
auxiliary function double list structure residue unification translation scheme 
predicate translates different functions function definition structural correspondences predicate definition 
predicate translation number function calls translation number body literals predicate 
haskell describes logic computations programs roughly twice big originals small residue unification 
language small step full prolog enriched source language unary functors introducing minimal structured data strings language 
non ground arguments non variable clause heads inevitable introduce extra function simulating unification 
divide unification series pattern matching number necessary equations number function symbols head acceptable translation scheme 
hand unification engine possible translate clause unique generic equation works tester generator calling patterns 
return extra function simulating parts unification obtained better structural correspondence 
summary translation exercises series translation exercises logic programs functional programs non ground computation main obstacles translation 
ad hoc translation exercise find general way translate predicates involving features 
shown predicates involving features naturally translated function definitions structural correspondences 
obtain formal translation schemes subsets logic program containing obstacles 
obtained partial answer question extra programming necessary perform logic computation functional setting 
moded subset prolog major extra programming constructs translation list structure compensating backtracking nature prolog new combinator 
simulating cut operator 
moded predicates determinate translations contain extra programming 
cut operators reduced guarded equations 
case translation scheme moded prolog contain extra function simulating unification 
mode annotation extra programming simulate parts unification necessary 
predicate unary logic language translates functions preserve structural correspondence 
translation scheme includes simple auxiliary function dispatching ground non ground parameters 
unary string logic programs predicate definition translates single function definition having structural similarity original predicate 
translation scheme contains extra functions simulating bi directional information flows resolution step 
order improve answer need gradually expand source logic program closer full prolog examine size functions corresponding unification degree structural correspondence 
far concentrated translation logic functional language mainly asserted logic programming covers wider aspect computation 
course think translation exercises opposite direction functional logic programming 
higher order functions translate meta logical predicates 
fact higher order functions natural cryptic usage meta logical operators logic programming 
functional languages cleaner logic languages 
pose new question extra programming necessary perform functional computation logic programming 
find structure preserving translation programming features specific functional languages higher order functions 
order compare expressiveness different programming languages may instructive define translation schemes language paying attention part result caused difference computation scheme 
possible extensions thesis 

implementation translator nfa 
compare practical cases number clauses program number transitions resulting nfa number derived states sts number states final nfa 

extension language 
defined translation schemes 
allow predicates multiple arguments handle non linear inputs harder keep structural correspondences 
extend source language pure prolog residue unification larger need rethink relationship structure preserving translation interpreters 

formal proof translators defined 
cases translation scheme defined proved 
proof exercise help improve translation schemes 
order prove translation schemes need implement pair interpreters source language target language assuming certain correspondences semantics 

extension translator moded prolog 
chapter assumed source programs mode annotated 
may possible adapt techniques mode analysis automatic mode annotation approach full prolog haskell translator 
summary research ignited naive question people claim programming language expressive exactly mean 
investigation word expressiveness frequently property admitting concise descriptions algorithms 
algorithms described concisely language people call language expressive 
word conciseness problematic 
conciseness measured treating program text term build constructors connectives language 
compare languages having common computation scheme pure scheme full scheme conciseness defined measure 
want compare logic functional languages expressiveness need extra definitions mimic underlying computation schemes 
apart extra definitions conciseness criterion compare program texts 
completely different discipline writing interpreters 
extrapolation translation schemes full prolog full haskell may provide better foundation arguments claims expressiveness hopefully insights designing new programming languages 
bibliography abelson sussman 
structure interpretation computer programs 
mit press 

relationship indexed grammar logic programs 
journal logic programming 
bird 
largest maximal 
march 
bird jones de moor 
speed lazy versus eager evaluation 
journal functional programming september 
brady 
theory computer science 
chapman hall 
burge 
recursive programming techniques 
addison wesley 
burstall macqueen 
hope experimental applicative language 
csr department computer science university edinburgh 
burton 
note higher order functions versus logical variables 
information processing letters 
cadoli 
circumscribing datalog expressive power complexity 
theoretical computer science february 
carlsson 
implementing prolog functional programming 
new generation computing 
carlsson widen 
sicstus prolog users manual 
technical report swedish institute computer science 
chomicki 
depth bounded bottom evaluation logic programs 
journal logic programming october 
dahl dijkstra hoare 
structured programming 
studies data processing 
london academic press 
darlington yi ke 
guo 
narrowing unification functional programming evaluation mechanism absolute set abstraction 
lncs april 
de boer palamidessi 
embedding tool language comparison 
information computation 
saumya debray 
static inference modes data dependencies logic programs 
acm transaction programming languages systems july 
debray warren 
automatic mode inference logic programs 
journal logic programming 
degroot lindstrom 
logic programming functions relations equations 
prentice hall 

relating logic programs attribute grammars 
journal logic programming 

kind grammars logic programs 
saint szpakowicz editors logic logic grammars language processing pages 
ellis horwood 
fehr 
expressive power typed type free programming languages 
theoretical computer science october 
felleisen 
expressive power programming languages 
science computer programming december 
field harrison 
functional programming 
addison wesley 
firth 
fold unfold transformation system non strict language 
phd thesis department computer science university york september 

fleck 
case study comparison declarative programming languages 
software practice experience january 
hagiya 
synthesis rewrite programs higher order semantic unification 
new generation computing 
hopcroft ullman 
automata theory languages computation 
addison wesley series computer science 
addison wesley 
hudak report programming language haskell 
acm sigplan notices may 
hughes 
design library 
johan jeuring erik meijer editors tutorial text st international spring school advanced functional programming techniques pages sweden may 
springerverlag lncs 
hughes 
novel representation lists application function reverse 
information processing letters march 
hutton 
higher order functions parsing 
journal functional programming july 
jones 
hugs user manual 
ftp ftp cs nott ac uk pub haskell hugs hugs 
kfoury tiuryn urzyczyn 
expressive power finitely typed universally polymorphic recursive procedures 
theoretical computer science february 
kleene 
metamathematics 
van nostrand new york 
knuth 
structured programming go statements 
computing survey december 
landin 
programming languages 
communications acm 
lloyd 
foundation logic programming 
springer verlag edition 

graph reduction technique functional logic languages 
manuel hermenegildo editors proceedings sixth international symposium programming language implementation logic programming pages madrid september 
springer verlag lncs 
marchiori 
functional side logic programming 
proceedings fpca conference functional programming language computer architecture june 
martelli montanari 
efficient unification algorithm 
acm transaction programming languages systems april 
armando matos 
monadic logic programs functional complexity 
theoretical computer science april 
matsushita colin runciman 
functional counterparts logic programming techniques 
proceedings fuji international workshop functional logic programming pages july 
miller 
logic programming language lambda abstraction function variables simple unifications 
journal logic computation 
miller nadathur 
higher order logic programming 
goos hartmanis editors proceedings third international conference logic programming pages london july 
springer verlag lncs 
mitchell 
abstraction expressive power programming languages 
science computer programming october 
naish 
negation control prolog 
springer verlag lncs 
ulf nilsson jan 
logic programming prolog 
john wiley sons nd edition 
peyton jones 
new view guards 
www dcs glasgow ac uk simonpj guards html 
peyton jones lester 
implementing functional languages 
prentice hall 
pippenger 
pure versus impure lisp 
acm transaction programming languages systems march 
plotkin 
lcf considered programming language 
theoretical computer science 
reddy 
translation logic programs functional programs 
proceedings international symposium logic programming pages february 
riecke 
fully translations functional languages 
proceedings th acm symposium principles programming languages pages uppsala sweden 
riecke 
fully translations functional languages 
editor mathematical structures computer science volume pages 
cambridge university press 

garbage collection memory efficiency lazy functional languages 
phd thesis department computing science chalmers university technology 
jayaraman 
domain theoretic approach functional logic programming 
journal functional programming july 
sterling shapiro 
art prolog 
mit press 

programming languages past 
acm sigplan notices 
ullman 
principles database knowledge base system 
computer science press 
wadler 
replace failure list successes 
jean pierre editor proceedings nd international conference functional programming languages computer architecture pages france september 
springer verlag lncs 
wadler :10.1.1.100.9674
essence functional programming 
proceedings acm conference lisp functional programming pages january 
wadler 
monads functional programming 
johan jeuring erik meijer editors tutorial text st international spring school advanced functional programming techniques pages sweden may 
springerverlag lncs 
wand 
continuation program transformation strategies 
journal acm january 
david 
watt 
programming language processors 
prentice hall 
david watt 
programming language concepts paradigms 
prentice hall 
