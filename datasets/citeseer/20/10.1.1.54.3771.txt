experiment automatic generation test suites protocols verification technology jean claude fernandez claude thierry describe experiment automatic generation test suites protocol testing 
report results gained generation test suites advanced verification techniques applied real industrial protocol 
experiment tools commercial tool verilog generation finite state graph models sdl specifications tool aldebaran cadp toolbox minimization transition systems prototype named tgv test generation verification techniques generation test suites developed cadp toolbox 
tgv verification techniques synchronous product fly verification 
tools applied industrial protocol protocol 
comparison produced test suites hand written test suites proves relevance techniques 
testing crucial point software development especially development protocols considering intrinsic difficulty design 
kinds tests context 
conformance testing protocol testing method consists checking implementation single protocol entity specification iso 
interoperability testing situated service level 
consists checking implementation communicating entities satisfies specification global service 
cases specification implementation system 
testing consists checking interactions implementation environment points control observation conform specification 
implementation test iut short stimulated tester simulates environment 
experiment tester produces verdict 
experiment described test case 
tree branch sequence interactions decorated 
test case checks particular property generally defined test purpose 
test cases organized hierarchy constitutes test suite 
goal testing find errors implementation 
proving correctness elusive generally impossible describe finite set interactions prove conformance implementation respect specification 
main problems describe systematic way test suite large confidence implementation 
partially supported industrial contract verilog study dga direction en erale pour inria rue montbonnot saint martin france 

fernandez imag fr respectively cnrs inria university irisa campus de beaulieu rennes france 
claude thierry gagnon irisa fr argue verification techniques automatic generation test suites 
focus particular experiment generation tool 
complete description models algorithms tool available 
methodological point view tried take account methods practitioners 
reason test purposes select test cases 
informal test purposes formalized automata 
similar approach appears test purposes formalized message sequence charts msc 
see paragraph main differences approaches 
input tool formal description protocol sdl language cci supposed correct model protocol 
algorithm constitutes heart generation tool main contribution 
verification technology 
principle traverse synchronous product state graph specification automaton describing test purpose synthesizing test graph 
test graph unfolded tree format tree tabular combined notation iso 
article organized follows 
section brief survey existing automatic methods generation test suites sketch links test generation verification 
section describe industrial context study give short description tools study tools experiment 
section describes ingredients involved test generation process test purposes test cases conformance relation specification test architecture protocol 
describe section test cases generated 
section analyses results obtained experiment 
draw section 
state art automated generation test suites years considerable amount done subject automated generation test suites economic challenge reflects 
real world infancy ll 
performance algorithms elaborate integration assisted methodologies 
automatic methods protocol testing come circuit testing automata theory see example gon cho sd vci 
principle consider specification implementation mealy machines finite state automata transitions labelled inputs outputs 
general principle test transition specification reach source state apply input check output correct check target state 
essentially differ way target state checked 
applicability methods requires assumptions specification generally strong realistic 
algorithms generally complex produce long test cases 
methods simplest powerful applicable method called transition tour 
principle tour transitions specification checking target state 
methods come testing theory abr bri dav tre 
formalism model implementation specification test suites labelled transition systems states transitions labelled actions states 
conformance relation specification implementation bri defines implementations correct 
generation algorithm builds tester process may generate possible sequences allowing decide conformance implementation respect specification 
tre tre conformance relations distinction inputs iut controllable environment outputs observable environment 
problem test selection tester infinite behaviour testing activity finite 
far know exist commercial tools generate test suites methods transition tours really industry protocols 
practitioners write test suites hand help simulator 
reason automatic methods formal specification protocol specification informal 
practitioners know experience reasonable try validate possible behaviours protocol 
test purposes select parts protocol want test 
verification test verification consists checking specification satisfies property may temporal logic formula specification 
verification problem different test problem models activities similar 
operational semantics specifications defined terms transition systems 
algorithmic verification presents large spectrum features partial verification fly checking reductions relevant problem test generation formal specification 
verification techniques years think verification techniques context test generation decided extend open verification toolbox cadp caesar aldebaran distribution package test generation feature 
context experiment industrial context experiment related conducted industrial contract direction en erale pour french army 
partners contract verilog cnet centre national etude des el cap research groups grenoble rennes 
study started november ended november 
goal prove automatic generation test sequences feasible profit earning industrial context 
tools studied developed tv eda cnet topic verilog prototype tgv inria 
order compare methods tools tools generate test suites starting sdl specification protocol see paragraph test purposes natural language 
appears consortium agrees different components realistic test generator tgv represents demonstrator main ideas 
think tgv results obtained deserves 
tv eda topic briefly described 
focus results tgv 
description tools section briefly describe main principles tv eda topic test generation tools involved study 
describe tools environment experiment 
tv eda tv eda test generation tool cnet pha accepts estelle sdl formal description techniques produce test suites format 
tv eda may compute test kernels strategies symbolic computation reachability analysis 
symbolic computation study 
principle avoid enumeration data values specification 
specification translated extended finite state machine 
tv eda computes path source state target state accordance conditions variables values 
path transformed tree non determinism specification considered 
topic topic prototype verilog developed inside simulator commercial tool see previous prototype topic mre 
principles quite similar 
takes inputs sdl specification test purposes described mscs 
algorithm computes graph constrained test purpose unfolds tree translated 
tools tgv sdl commercial tool developed verilog 
tool supports requirement analysis graphical design data architecture communication state machines simulation code generation 
simulator allows interactive simulation automatic simulation exhaustive verification 
tgv sdl front order produce state graph specification see details section 
cadp caesar aldebaran distribution package toolbox developed verimag grenoble 
composed tools environments aldebaran open caesar tgv aldebaran tool performs reduction comparison graphs various equivalence relations preorders 
open caesar open environment rapid prototyping verification algorithms algorithms traversals transition systems 
allowed presence libraries management graphs memory 
transition systems may implicitly functions produced lotos compiler caesar compilers explicitly aldebaran graph format 
implicit representation interesting fly algorithms algorithms traversals transition system explicit construction complete transition system 
tgv developed cadp toolbox 
uses libraries open caesar management graphs memory 
experiment explicit representation transition systems fly version currently developed 
aldebaran minimization state graphs produced translated aldebaran graph format 
ingredients test generation process section define test purposes formalized conformance relation test cases 
specification protocol study test architecture 
test purposes formalization experts test know test parts iut 
reason test purposes order select particular parts tested 
test purpose defines property system particularly wants check iut 
generally composed parts ffl context describes constraint applied iut testing 
ffl behaviour defines sequencing interactions iut environment 
experiment protocol context part described filters inputs simulator 
filter describes set forbidden actions 
particularly useful fixing results undefined operators sdl specification 
behavioural part test purpose specified automaton 
transitions automaton labelled interactions specification environment 
automaton acyclic implicit loops state 
allows describe test purposes level considering interactions sequence 
automaton accepting states labelled keyword accept 
sequence observable actions applied automaton accepted sub sequence labelled actions automaton reaching accepting state 
approach test purposes formalized message sequence charts mscs 
msc describes observable behaviour interrupted observable interactions forced immediate successors 
abstraction possible msc describes part test case difficult compute 
mixing approach investigated 
automaton formalism transition sequences interruptible 
test cases conformance test case tree branch describes sequence interactions tester iut 
protocol testing test cases described tree tabular combined notation iso 
role test case detect iut conforms specification particular test purpose 
implies formally define conformance 
conformance notion experiment basically relation described tre tre 
informally iut conforms specification set traces observable trace outputs included outputs case subset traces accepted automaton test purpose 
order detect non conformance transitions test cases decorated 
meaning 
fail means iut conform specification 
conformance relation fail verdict assigned input tester correspond output specification 
achieved adding implicit fail state 
fail assigned timeouts see 
pass means sequence initial state corresponds interaction sequence specification accepted test purpose automaton 
temporary verdict sequence sequence called reach initial state 
execution produce fail 
pass definitive verdict meaning initial state reached pass verdict 
sequence pass pass identifies 
inconclusive input tester corresponds output specification lead pass verdict leads behaviour considered test case testing exhaustive 
protocol specification protocol experiment protocol 
military protocol allows access transit network french air force defined framework integrated service military network 
quite similar dm protocol analogous protocol civil framework 
protocol runs network called connects telecommunication means air bases interface see 
protocol configuration protocol 
protocol chosen reasons 
protocol industrial order prove feasibility automatic test generation methods realistic specifications 
sdl specification similar protocol dm protocol available written cap partner project 
test cases written hand cap help simulator available 
served basis comparison automatically generated test suites 
specification protocol study contains functional description offered services specification user interface call command 
models service protocol entire network 
subset services offered protocol specified sdl 
services priority roving user call forwarding implicit partitioning users safety path user user signaling 
generic sdl specification written instantiated service 
sdl specifications services 
means tests produced service separately interaction services studied 
sdl specification models connection 
called dr requesting de requested 
size sdl specification corresponding service lines 
specification test purpose consistency relation test purpose denotes important part specification tested 
specification test purpose formalized context automatic generation test suites formalize relation formal specification formal test purpose 
done means relation automata test purpose specification 
call relation consistency relation 
weak notion satisfaction meaning sequence specification accepted automaton test purpose 
test case derived specification test purpose agree consistency relation 
test architecture experiment protocol concerned tests services described 
kinds tests generate 
tests subscription record tests check transmission information service tests check service protocol 
tests concern service provided say interested interoperability testing 
test architecture chosen shown 
dr de network test configuration 
implementation protocol entire network seen black box 
tester models behaviour named dr de connected network interface communication network supposed asynchronous 
iso context simplified multi party testing lower tester synchronized upper testers behaving users 
test architecture influence generation test cases 
faced case tester interact directly iut interacts test environment placed iut 
influence way tester control observe iut 
communication tester iut asynchronous considered may introduce concurrency behaviour 
suppose example protocol receives message dr requesting 
treats message internal procedure trt replies sending sequence de requested app cours dr external view receptions de app cours dr concurrent see illustration 
iut dr dr de dr app cours dr app cours de tab app cours environment tester dr de dr app cours de trt concurrency testing 
considered influence test environment way 
assume reasonable environment hypothesis says time environment sends message network waits stabilization 
means new message sent environment receives specified outputs protocol 
hypothesis allows avoid concurrency inputs outputs limiting crossings messages 
asynchronous communication treated considering tester check iut directly checks iut test environment 
transform specification coupling model test environment 
seen extension approach 
considered bidirectional cope 
possible reasonable environment hypothesis particular form specification 
specification sdl transition input followed internal actions outputs exist output loops 
transform sequence outputs transition diamonds modeling concurrency 
generation method section describe tgv package 
detail step test generation describing inputs outputs software component 
describe deeply algorithm constitutes kernel tgv package 
tgv package programmes developed study intended coded complete integrated tool specify protocol analyze different verification methods generate test suites 
particularly taken care fact algorithms fly computation specification graph 
ambition experiment prove feasibility approach 
tgv prototype developed outside verification tool see 
consequence tgv package grey takes input state graph produced 
second input tgv automaton formalizing behavioural part test purpose 
test purpose may specify test cases 
context experiment choosen select arbitrarily test case test purpose 
tgv package outputs test case standard language distinguishing control behaviour data constraints parts 
usual intermediate form mp graphically displayed gr 
tgv developed toolbox cadp described 
particularly useful cadp open environment depend particular language 
sdl front prototype languages lotos estelle 
detail part generation test case 
overview generation method generation test case decomposed functional parts performed different tools see step state graph generation inputs ffl sdl specification 
ffl set messages feeds environment send implementation 
close sdl specification restricted environment order limit size state graph generated 
message parameters fixed 
feeds supposed describe messages accepted implementation 
gr constraints gr behaviour mp constraints mp behaviour graph automaton context behaviour informal test purpose filters feeds sdl specification simulator tgv package mpp bin aldebaran graph minimized graph aldebaran aldebaran imin tgv aut test graph architectural view tgv package 
ffl set filters specify forbidden transitions 
filters represent constraint part test purpose 
simulator verification mode reasonable environment hypothesis 
generates state graph corresponding possible behaviours protocol closed feeds constrained filters 
step translation mirror image step performed tool called aldebaran 
graph generated translated graph aldebaran format represents observable behaviour specification test environment 
implementation seen black box interested observable behaviour protocol interactions environment 
internal actions specification replaced invisible action denoted test environment taken account see paragraph 
means graph transformed diamonds corresponding interleavings model concurrency 
built fly traversal graph 
consider tester view perform mirror image graph inputs replaced outputs vice versa 
feature aldebaran filtering message parameters 
helps producing readable test suites parameters message significant particular test purpose preserved 
step minimization determinization aldebaran step aldebaran minimizes graph produced preceding step respect equivalence result 
equivalence preserves safety properties minimization respect equivalence efficient practice 
minimization roughly means observable actions preserved states observable behaviours collapsed 
collapsing fact necessary important thing hiding actions 
crucial thefly perspective fly minimization efficient 
step graph tester see non deterministic choices protocol 
graph produced called external view graph represents external view protocol behaviour 
step test graph generation kernel tool 
algorithm depth traversal synchronous product external view graph automaton representing test purpose 
usual traversal limited maximal depth 
states product composed state tp automaton state graph 
transition fireable state tp product leads tp cases 
fireable graph state leads fireable automaton state tp leads tp fireable leads fireable tp case tp tp means specification progress automaton progresses synchronized specification 
traversal computations performed ffl algorithm checks consistency relation test purpose specification 
done descent traversal 
accepting state reached computed search shortest path initial state 
ffl skeleton graph synthesized backtracking 
graph contains sequences loop synchronized product contain accepting state automaton reaches initial state specification added 
graph satisfies condition says tester controls outputs 
output fireable state graph transition fireable 
ffl transitions skeleton graph decorated meaning described paragraph 
illustrated 
pass pass pass accept external view graph test purpose construction test graph 
algorithm depth search product graph combined breadth search computation shortest 
complexity linear size state graph specification times size test purpose automaton 
algorithm explained detail annex 
step management timers timers detect deadlocks unobservable loops iut 
input expected tester want wait unbounded time unobservable error may occurred iut 
difficulty managing timers comes necessary distinction concurrency choice 
notice occurs inputs 
timers managed tgv way see example 
start tm cancel tm cancel tm tm tm start tm tm tm cancel tm cancel tm tm tm tm tm tm tm tm cancel tm fail fail fail fail fail fail cancel tm tm management timers tgv timer tm associated possible input message tester 
timer tm started transition necessarily precedes input states input expected timeout tm may occur 
received timers tm corresponding expected input concurrent cancelled 
tm cancelled received input choice concurrent timers generated depth traversal skeleton graph 
concurrency inputs computed traversal 
rules management timers original complete literature consider concurrency problem 
rules insure deadlocks iut detected timeout 
step graph called test graph containing informations needed generation test case 
graph aldebaran format 
informations message names message parameters timers contained transitions labels 
step generation step tool aut takes input test graph generated preceding step produces files 
file describes constraints fact parameters messages 
second file describes behavioural part test case obtained unfolding test graph tree 
identifier refer parameters messages file 
files mp format 
translated files gr format mpp bin tool verilog 
experiment protocol section describe experiment carried protocol 
describe test purposes formalized serve inputs test generation 
give quantitative results experiment qualitative results comparison hand written test suites 
formalization test purposes test purposes natural language formalized 
informal test purpose describes context test property interactions 
context test concerned properties subscription record users properties network 
subscription record modeled specification undefined operators data types generally boolean operators involving choices transitions specification 
example context requesting access service network saturated 
formalized contexts filters mechanism simulator allows disable transitions 
remainder test purpose describes sequencing properties inputs outputs tester network properties parameters messages 
example requested receives establishment message containing parameter user user information 
sends alert message parameter 
verify network sends requesting alert message parameter 
mainly concerned sequencing actions relations parameters treated simple way 
consider equality parameters 
test cases describe behaviour testing process network actions translated tester actions 
example network sends requesting replaced input 
care taken transformation test purpose describes output actions network different may involve concurrency reception messages translated interleaving 
behavioural part test purposes translated automata aldebaran format see automaton example 
des de false value true value de alert false value true value dr alert false value false value accept general test purposes simple example 
small subset test purposes contains interleavings actions 
quantitative results generation protocol graph experiment carried sparcstation mb ram 
size specification service treated described section approximately lines sdl 
depending environment fixed feed mechanism test context fixed filters size state graph generated states transitions 
minimized size external view graphs roughly divided 
time spent generation state graphs aldebaran minimization determinization memory size data stack aldebaran bytes bytes 
expensive part test generation process called state space explosion 
limits verification tools 
exhaustive verification tools reasonably treat specifications having states 
limits pushed symbolic exploration state space implicitly represented binary decision diagrams example fly generation generation tests traversing state space 
formal description test purposes considered test purposes 
size automaton specifying test purpose transitions states 
mean time spent formalization test purpose minutes 
includes description context filters specification behaviour part automaton 
generation test suites time spent tgv package production test case including step step starting graph produced memory size tgv bytes bytes 
results explained linear complexity main algorithm 
size test cases produced varies transitions transitions 
comparison hand written tests cases test suite test cases corresponding informal test purposes written hand 
test cases written formal definition conformance 
examination specification test cases showed conformance relation see paragraph 
hand written test cases served basis analysis results 
compared test cases generated automatically hand written ones lot similarities lot differences 
differences observed principally due fact tgv treats concurrency timers systematic way 
sketch main differences remarks 
tgv just prototype put emphasis behavioural part test cases 
take account possibilities language 
produce pseudo fields test group test purpose comments default libraries generated 
test case generated tgv contains preamble attached test body allows separate different files 
tgv consider hierarchical structure test suite intended integrated complete tool 
reasonable environment hypothesis opinion important differences concern behaviour part test cases 
lot differences explained hypothesis behaviour environment 
assumed reasonable environment hypothesis thought corresponds behaviour tester 
hand written test cases hypothesis assumed 
reason probably test mind test run process real implementation implicitly experience protocol 
case example 
test purpose says dr de 
specification input dr followed outputs de app cours dr implies concurrency de dr app cours 
test case generated tgv table hand written test case shown table 
nr behaviour description constraints ref verdict dr start start tapp cours dr app cours cancel tapp cours de 
cancel pass dr start de 
cancel pass fail fail de 
cancel pass dr app cours cancel tapp cours dr start de 
cancel pass fail tapp cours fail tapp cours fail fail table test case produced tgv difference test cases lies lines automatic test case lines hand written test case 
de action dr app cours considered 
supposed tester decide outputs inputs control priority observation 
think safer assume reasonable environment hypothesis wait dr app cours applying 
wants nr behaviour description constraints ref verdict dr start tw start twait dr app cours cancel tw de 
cancel twait pass post lib drs des timeout twait fail dr de 
cancel twait cancel tw pass post lib drs des timeout tw fail dr cancel twait fail timeout twait fail dr cancel tw fail table hand written test case details discarded 
post lib drs des cancels timers performs outputs dr de 
link test cases may happen forgotten receptions dr app cours influence subsequent test case may lead fail verdict pass verdict produced 
difference appears previous example concerns 
hand written test cases fail 
point view fail verdict produced impossible know state implementation effect starting current state iut foreseeable 
impossible insure initial state reachable reset 
inconclusive relevant 
implemented tgv poses problem 
hand written tests 
due choice messages sent tester implementation specified feeds 
concurrency concurrency events forgotten hand written test cases 
happens complex test cases difficult foresee behaviour protocol automatic tool especially case concurrency 
dramatic consequence hand written test cases correct execution produce fail verdict conformant implementation 
timers hand written test cases timers corresponding internal protocol timers 
conformant black box testing paradigm 
internal timers observable test cases 
order help adjusting values timers test cases executed 
sufficient transmission delays taken account 
considered point view timers test cases events environment 
specification constraints tgv produces inconclusive appear hand written tests 
typically occurs sufficiently constrained context filters 
state graph behaviour case context correctly fixed 
choices protocol supplementary behaviours start receptions tester 
behaviours lead pass verdict receptions considered inconclusive 
differences automatic hand written test cases considered errors 
test case necessary exactly specify context considered 
fail pronounced place inconclusive 
interpretation informal test purposes differences due interpretation test purposes unavoidable ambiguity natural language 
deep knowledge protocol impossible know exact meaning test purpose 
strong argument formalized test purposes automata formalisms mscs temporal logics 
ambiguities disappear formalization everybody agree exact meaning test purposes 
comparison test cases produced tv eda topic main advantage tgv regard tools experiment fact tgv tool able take account tester iut 
advantage tgv management timers elaborated 
comparison topic relatively easy principles 
algorithms tgv efficient complete topic 
topic allows specify test purposes mscs extended automata produces declarations constraints better user interface 
tv eda complete tgv produces complete descriptions declarations constraints test purposes comments comparison tgv tv eda concerning behavioural part test cases difficult principles different 
tv eda test purposes implicit transition sdl specification test purpose 
tv eda produced test cases 
correspond informal test purpose produced tgv topic 
discarded inconsistent constraints message parameters 
new version tv eda reachability analysis development study 
comparing results results produced new version interesting 
year carried study goal prove formal methods successfully applied generation test suites 
interest industrial partners motivated economical considerations 
want reduce time spent development test suites hand 
shown formal techniques developed area verification useful profit earning automatic generation test suites 
formalized notion test preorder developed generation algorithm depth traversal synchronous product graph representing external behaviour protocol specification automaton formalizing test purpose 
prototype developed accepts inputs specifications written different languages connections sdl lotos available 
standardized languages sdl specification test suites best known algorithmic tools applied 
able generate test suites protocol real industrial example coming considerable algorithmic complexity 
graphs generated translated reasonable time 
viability forthcoming integrated tool 
produced results conform intended 
able automatically generate test cases corresponding hand written ones 
gain quality undeniable hand written tests cases proved incorrect correctly generated tgv 
proves necessary automation indispensable test suite generation 
particularly systematic treatment concurrency timers offers safety 
shortcoming automatic method requires time specify protocol formalize test purposes 
amply balanced benefit time quality automatic methods 
particularly true long term perspective formalization integrated development process 
automatic test suite generation methods suppose protocol specification 
need formalized test purposes 
user point view effort specification protocol conception formalization test purposes 
think conception test purposes done process specification 
nature test purposes modelled automata mscs temporal logic 
consider type algorithm envisage develop methods fly 
fact cadp environment gives access high level primitives graph traversal allowing couple simulation verification test sequence generation 
advantage algorithm specifications state graph completely generated 
drawback minimize state graph aldebaran absolutely necessary 
fly generation test cases cadp treat data complete way 
done graphs aldebaran format transition function cadp give access data types 
offering possibility allow really apply fly verification techniques generation test suites enrich verification methods 
acknowledgments wish referees helpful comments partners experiment related particular 
celar verilog cap cnet irisa 
abr abramsky 
observational equivalence testing equivalence 
theoretical computer science 

project validation environment sdl msc descriptions 
sdl forum 
brinksma van de tretmans 
formal approach conformance testing 
de meer editors second international workshop protocol test systems pages north holland 
bri 
theory derivation tests 
protocol specification testing verification viii pages north holland 
cci ccitt wp specification description language sdl 
ccitt recommendation 

approaches linking test generation tool verification techniques 
th int 
workshop protocols test systems france september 
cho chow 
testing software design modelled finite state machines 
ieee transactions software engineering se may 
kim automated protocol conformance test generation formal methods lotos specifications 
elsevier science publishers editor protocol test systems pages montr eal 
dav az ema 
refusal graphs conformance tester generation computational framework 
protocol specification testing verification xiii ifip transactions north holland 
de nicola 
testing equivalences processes 
theoretical computer science 
fujiwara 
test selection finite state models 
ieee transactions software engineering june 

fernandez rodriguez sifakis 
tool box verification lotos programs 
th international conference software engineering melbourne australia may 

fernandez 
fly verification techniques generation test suites 
appear conference computer aided verification cav new brunswick new jersey usa july 
grabowski nahm 
test case generation test purpose specification mscs 
elsevier science 
north holland editor th sdl forum pages sarma darmstadt germany 
gon 
method design fault detection experiments 
ieee transactions computing june 
iso osi open systems interconnection information technology open systems interconnection conformance testing methodology framework part general concept part test suite specification part tree tabular combined notation 
international standard iso iec 
ll lai leung 
industrial academic protocol testing gap means convergence 
computer networks isdn systems 
mre roth donaldson 
eds 
methods qos verification protocol conformance testing results recommendations 
race project topic deliverable dat tms ds november 
pha 
test sequence estelle sdl structure information 
forte berne october 
sd 
protocol testing procedure 
computer network isdn systems 
tre tretmans 
formal approach conformance testing 
phd thesis university twente enschede netherlands 
tre tretmans 
testing labelled transition systems inputs outputs 
th int 
workshop protocols test systems france september 
tre tretmans 
test generation inputs outputs quiescence 
margaria steffen editors second international workshop tools algorithms construction analysis systems tacas passau germany march 
vci chan ito 
method protocol test sequence generation 
second international workshop protocol test systems berlin october 
tretmans brinksma 
testing 
von das editors fifth international workshop protocol test systems ifip transactions north holland 
annex generation algorithm tgv generation algorithm combines main functions described 
sake readability part test generation algorithm ffl checks consistency relation synthesizes skeleton graph 
algorithm performs depth traversal graph associated synchronous product external view graph automaton specifying test purpose 
checks sequence synchronous product reaches state automaton component accepting state 
case searches sequence external view graph leading initial state graph 
starting accepting states synthesizes skeleton graph ffl computes shortest breadth search 
complete algorithm search called accepting state reached 
ffl ensures condition tester outputs 
output enable state test graph transitions discarded 
done traversal allows cut parts graph 
ffl skeleton graph decorated timers produce test graph generate suites 
assigned transitions backtracking traversal 
timers produced depth search 
allow dfs computation data structures functions required data structures ffl gamma stack elements fl ff tp fl act fl state fl succ ff action preceding tp ffl initial state tp init init tp couple states synchronous product list successors tp see 
stack gamma managed usual operations push pop top 
ffl result boolean value initially set false set true test purpose consistent specification 
value returned dfs 
ffl set states synchronous product 
set stored visited states longer gamma 
ffl pre test post sets nodes preamble test body respectively 
updated function create trans 
ffl nodes subset elements vertices test graph 
initially nodes accept init trans set transitions test graph 
functions ffl function succ list delivers successors list compound state 
choose remove chooses transition removes list 
ffl create trans updates transitions nodes test graph 
function dfs tp init init state returns boolean gamma result false post accept init pre test nodes post trans pass pass succ list tp init init push ffl tp init init gamma gamma loop tp top gamma choose remove tp tp gamma accept theta fq init new state succ list tp push tp gamma tp nodes create trans tp tp tp top gamma pop gamma tp nodes gamma create trans top gamma state tp tp loop tp init init pre accept theta fq init result true return result procedure create trans tp tp nodes nodes tp trans trans tp tp tp post tp tp post post tp test test tp tp test tp tp init tp tp init pre pre tp test test tp tp pre pre pre tp function succ list tp returns list action state tp tp init return ff tp init ff return ff tp ff tp ff tp tp tp ff tp tp tp 
