syntactic theory dynamic binding appear proceedings tapsoft lille france april lecture notes computer science springer verlag 
luc moreau university southampton 
dynamic binding associated lisp semantically obscure 
largely replaced lexical scoping dynamic binding remain interesting expressive programming technique specialised circumstances key notion semantics 
presents syntactic theory enables programmer perform equational reasoning programs dynamic binding 
theory proved sound complete respect derivations allowed programs dynamic environment passing style 
theory derive sequential evaluation function context rewriting system 
exhibit power usefulness dynamic binding different ways 
prove dynamic binding adds expressiveness purely functional language 
second show dynamic binding essential notion semantics define semantics exceptions 
refine evaluation function popular implementation strategy called deep binding 
saying deep binding suitable parallel evaluation parallel evaluation function functional language extended constructs dynamic binding 
dynamic binding traditionally associated lisp dialects 
appeared mccarthy lisp bug feature succeeding implementations instance maclisp gnu emacs lisp :10.1.1.50.9776
modern dialects language favour lexical scoping provide form dynamic variables special declarations common lisp simulate dynamic binding lexically scoped variables fluid 
lexical scope norm imperative languages functional languages scheme common lisp standard ml haskell 
scope name binding text occurrences name refer binding 
lexical scoping imposes variable expression refers innermost lexically enclosing construct declaring variable 
rule implies nested declarations follow block structure organisation 
contrary scope name said indefinite may occur program 
hand dynamic binding refers notion dynamic extent 
dynamic extent expression lifetime expression starting control enters exits expression 
dynamic binding binding exists dynamic extent expression 
dynamic variable refers latest active dynamic binding exists variable 
expression dynamic scope convenient refer indefinite scope variable dynamic extent 
dynamic binding initially defined meta circular evaluator formalised denotational semantics gordon :10.1.1.50.9776
part research supported part epsrc gr 
author address department electronics computer science university southampton southampton bj 
united kingdom 
mail moreau ecs soton ac uk 
interpreted mode 
folklore exists translation dynamic environment passing translation translates programs dynamic binding programs lexical binding 
continuation passing transform dynamic passing translation adds extra argument function dynamic environment dynamic variable translated lookup current dynamic environment 
late eighties saw syntactic theories new semantic framework allows equational reasoning programs non functional features class continuations state 
frameworks extended take account parallel evaluation 
purpose syntactic theory allows user perform equational reasoning programs dynamic binding 
contribution 
dynamic environment passing translation construct inverse translation 
sabry felleisen technique derive set axioms define calculus prove sound complete respect derivations accepted dynamic environment passing style section 
second devise sequential evaluation function algorithm prove return value calculus 
evaluation function relies context rewriting technique section 
third order strengthen claim dynamic binding expressive programming technique useful notion semantics give formal proof expressiveness definition exceptions 
section define relation observational equivalence evaluation function prove dynamic binding adds expressiveness purely functional programming language establishing dynamic binding macro expressed call value lambda calculus :10.1.1.51.4656:10.1.1.51.4656
section dynamic binding semantic primitive formalise different models exceptions non exceptions ml ones common lisp 
fourth refine evaluation function strategy called deep binding facilitates creation restoration dynamic environments section 
fifth extend framework parallel evaluation construct 
section define parallel evaluation function relies deep binding technique 
deriving calculus motivate describing broad categories dynamic binding conciseness control delimiters distributed computing 
insist purpose qualities lexical binding essence abstraction block structure organisation syntactic theory allows equational reasoning dynamic binding claim dynamic binding expressive programming technique sensible manner show dynamic binding elegantly define semantics constructs 
note dynamic binding lisp perl unix tm shells 
practical uses dynamic binding conciseness typical dynamic binding printing routine print number requires basis numbers displayed 
solution pass explicit argument call print number 
repeating programming pattern program source programming mistakes 
addition solution scalable require print number routine take additional parameter indicating font numbers displayed modify program 
scheme functions take optional input output port 
procedures file output file simulate dynamic binding parameters 
gnu emacs example large program dynamic variables 
contains dynamic variables current buffer current window current cursor position avoid pass parameters functions refer 
examples illustrate felleisen conciseness conjecture sensible expressive programming constructs reduce programming patterns programs :10.1.1.51.4656
order strengthen observation prove dynamic binding adds expressiveness purely functional language section 
control delimiters standard ml lexically scoped language raised exceptions caught latest active handler 
usually programmers install exception handlers duration expression handler dynamically bound extent expression 
maclisp common lisp catch throw cc examples exception control operators dynamic extent 
generally control delimiters create partial continuations different semantics tolerate various degrees :10.1.1.40.9946
parallelism distribution parallelism distribution usually considered possible mean increasing speed programs execution 
motivation distribution exacerbated ubiquitous www quest new resources computation migrate site site holds resource accessible explanatory purpose consider simple resource name computer 
solutions model name running host language entirely satisfactory 
lexical variable hostname bound name computer process created 
unfortunately variable may closed closure return value evaluated different site 
ii primitive hostname defined function arguments ffi return different values different contexts defined nondeterministic function prevent equational reasoning 
iii special form hostname satisfy goal contradiction minimalist philosophy scheme avoids adding unnecessary special forms 
furthermore define special form resource natural unique special form parameterised resource name introduces new name space exactly dynamic binding offers 
iv solution dynamically bind variable hostname name computer process creation time 
occurrence variable refer latest active binding variable 
control tasks parallel distributed setting usually relies notion dynamic extent sponsors allow programmer control hierarchies tasks 
calculus dynamic binding displays syntax language accessible user 
observe purpose capture essence dynamic variables propose new syntax language disjoint sets variables dynamic static lexical variables 
consequence programmer choose lexical abstractions lexically bind parameter applied dynamic abstractions dynamically bind parameter 
represent regular abstractions calculus model constructs common lisp abstractions special variables dynamic scope 
xd term xs xs xd value xs sv ar xs static variable xd dv ar xd dynamic variable fig 

user language paramount importance clearly state naming conventions adopt language 
barendregt consider terms equal renaming bound static variables equivalent 
contrary terms differ dynamic variables considered equivalent 
fv fv xd yi extend xd fv xs xs xd lookup xd xs xs dlet ffi ffi ffi xd extend ffi xd fig 

dynamic environment passing transform dynamic environment passing translation call program transformation maps programs target language deps extended call value calculus lexical variables 
intuitively abstraction static dynamic translated abstraction extra dynamic environment argument target language contains variable denotes unknown environment 
result application protocol target language changed accordingly operator values applied pairs 
translation application dynamic environment translations operator operand passed argument operator 
dynamic abstractions translated abstractions extend dynamic environment 
dynamic variable translated lookup corresponding constant current dynamic environment 
source language extends dlet construct dlet stands dynamic 
construct inaccessible programmer internally system model bindings dynamic variables di values syntax input language called appears 
binding lists defined concatenation operator satisfying property 
dn vn dn vn dn vn dn vn evaluation target language set axioms displayed second part 
applications binary abstractions require double fi reduction modelled rule fi theta environment lookup implemented lk lk 
sabry felleisen purpose rest section derive set axioms perform terms reductions allowed terms language deps lookup xd term xs yi value extend xd dynamic environment unknown env 
variable xs sv ars xs fy static variable xd xd dynamic identifier axioms yi pfe yg fi theta yg fi lookup xd extend xd lk lookup xd extend xd lookup xd xd xd lk yi yi fv theta fig 

syntax axioms deps calculus gamma dlet gamma gamma gamma gamma lookup xd dlet gamma xd gamma gamma gamma gamma yi gamma gamma xs xs gamma gamma xs gamma gamma extend xd gamma xd gamma fig 

inverse dynamic environment passing transform gamma deps 
precisely want define calculus equationally corresponds calculus deps 
definition equational correspondence taken verbatim 
definition equational correspondence languages calculi xr xg translation translation calculus xr equationally corresponds calculus xg conditions hold 
xr ffi 
xr xg 

xg ffi 
xg xr 
contains inverse dynamic environment passing transform mapping terms deps terms case worth explaining term represents application operator value pair dynamic environment operand value inverse translation application inverse translations scope dlet inverse translation cases inverse translation removes environment argument added abstractions translates occurrence dynamic environment dlet expression 
state space xd dlet ffi term xs xs xd value ffi ffi xd binding list xs sv ar xs fy static variable xd dv ar xd dynamic variable primary axioms xs fi xd dlet xd fv dlet intro dlet ffi dlet ffi dlet ffi fv ffi dlet propagate dlet ffi dlet ffi dlet ffi ffi dlet merge dlet ffi dlet elim dlet dlet elim dlet ffi xd xd dlet ffi xd lookup dlet ffi xd xd dlet ffi xd xd xd lookup fv fi omega fv jv derived axioms xd dlet xd dlet intro dlet ffi dlet ffi dlet ffi dlet ffi dlet propagate compatibility xs xs xd xd dlet ffi dlet ffi fig 

syntax axioms calculus apply dynamic environment passing transform term immediately translate result back gamma find primary axioms 
explanatory purpose prefer derived axioms dlet intro dlet propagate 
axiom dlet intro counterpart fi dynamic abstraction applying dynamic abstraction value creates dlet construct dynamically binds parameter argument body abstraction 
rule dlet propagate rewritten syntactic sugar tells transform application appearing inside scope dlet 
dlet ffi dlet ffi dlet ffi dlet ffi operator operand separately evaluated inside scope dynamic environment application operator value operand value appears inside scope dynamic environment 
interpretation dlet merge dlet elim dlet elim straightforward 
establish properties concerning composition gamma lemma term value alue list bindings ffi bind environment deps ffi gamma dlet ffi gamma ffi ffi gamma ffi gamma lemma term deps value deps alue dynamic environments deps deps gamma pfe deps gamma fe deps gamma applying inverse translation gamma axiom deps obtain primary axioms 
rules lookup lookup immediate correspondent lk lk deps fi omega axioms discovered sabry felleisen applying technique calculi continuations assignments 
intuition set axioms explained follows 
absence dynamic abstractions behaves call value calculus 
dynamic abstraction applied dlet construct created 
rule dlet propagate propagates dlet leaves syntax tree replaces occurrence dynamic variable value dynamic environment lookup lookup 
rule dlet propagate guarantees dynamic binding remains accessible extent application dynamic abstraction deleted dlet elim 
observe parallel evaluation possible dynamic environment duplicated operator operand reduced independently 
property section define parallel evaluation function 
obtain soundness completeness results lemma soundness terms deps deps lemma completeness terms deps deps gamma gamma theorem consequence lemmas 
theorem calculus equationally corresponds calculus deps 
calculus define partial evaluation relation value program prove equals calculus 
definition eval program eval definition give algorithm states specification satisfied evaluation procedure 
purpose section define procedure 
sequential evaluation sequential evaluation function defined 
relies notion evaluation context evaluation context term hole place subterm evaluate 
notation denote term obtained placing inside hole context transition rules necessary dlet intro dlet elim derived calculus 
rule lookup replacement dlet propagate dlet merge dlet lookup dlet lookup calculus 
state space xd dlet xd term xs xs xd value xs sv ar xs static variable xd dv ar xd dynamic variable dlet xd evaluation context transition rules xs fi xd dlet xd dlet intro dlet xd xd dlet xd xd lookup dlet xd dlet elim evaluation function program 
error 
ms ms stuck dynamically bound variables stuck terms dlet xd stuck xd xd fig 

sequential evaluation function intuitively value dynamic variable latest active binding variable 
framework latest active binding corresponds innermost dlet binds variable 
dynamic extent dlet construct period time dlet intro elimination dlet elim 
evaluation algorithm introduces concept stuck term defined occurrence dynamic variable evaluation context contain binding 
evaluation function defined total function returning value evaluation terminates evaluation diverges error stuck term reached 
correctness evaluation function established theorem relates eval eval observe eval may return value differs value returned eval calculus perform reductions inside abstractions 
theorem program eval iff eval implement lookup start dynamic variable evaluated search innermost enclosing dlet 
contained binding variable return associated value 
proceed enclosing dlet 
behaviour exactly corresponds search value associative list assoc scheme 
strategy usually referred deep binding section refine sequential evaluation function making associative list explicit 
show dynamic binding adds expressiveness functional language 
expressiveness section stated dynamic binding expressive programming technique sensible manner reduce programming patterns programs 
section give formal justification statement proving dynamic binding adds expressiveness purely functional language :10.1.1.51.4656:10.1.1.51.4656
define notion observational equivalence 
definition observational equivalence programming language evaluation function eval terms observationally equivalent written context programs eval defined equal eval defined equal shall denote observational equivalences call value calculus calculus respectively 
order prove dynamic binding adds expressiveness purely functional language consider lambda terms assuming existence primitive cons construct pairs :10.1.1.51.4656:10.1.1.51.4656
tf cons tf cons terms equivalent calculus cons cons 
example shows dynamic binding enables distinguish terms call value calculus distinguish 
result ae felleisen definition expressiveness thm conclude proposition 
macro express dynamic binding relative semantics exceptions class continuations state simulate exceptions :10.1.1.134.8272
show exceptions defined terms class continuations dynamic binding 
semantics ml raised exception returns exceptional value distinct normal value effect prune evaluation context handler able deal exception 
merging mechanism aborts computation mechanism fetches handler exception handler longer executed dynamic environment exception raised 
result approach give semantics kinds exceptions ones 
order model effect extend sequential evaluation function felleisen friedman abort operator 
sake simplicity assume exists exception type discrimination kind exception performed handler 
assume existence distinguished dynamic variable ed give semantics ml style exceptions 
exception raised latest active handler called escapes applies dynamic environment handle dynamic environment exception raised hand exist kinds exceptions exceptions common lisp errors conditions 
essentially offer opportunity resume computation point exception raised 
sequel variant queinnec monitors usage class continuation appears rule handle duplicates evaluation context observe continuation downward way amounts popping frames stack 
term handle xed abort raise xed fig 

ml style exceptions give essence exceptions 
primitives monitor signal play role handler raise ml style exceptions 
note signal binary function takes value boolean indicating exception raised 
monitor xed old xed xed old signal xed fig 

exceptions handle monitor installs exception handler duration computation 
exception signalled latest active handler called dynamic environment signalled exception 
exception signalled handler handled handler existed monitor called ed shadowed duration execution handler accessible normal computation resumes 
exception signalled argument signal true value returned handler returned signal computation continues exactly dynamic environment approach define semantics exception advantages 
model effect appropriate primitive abortion handler installation dynamic binding ability model different kinds semantics exceptions 
second defining semantics exceptions assignments weakens theory assignments break equivalences hold presence exceptions definition provides precise characterisation theory exceptions :10.1.1.51.4656
refinement refine evaluation function representing dynamic environment explicitly associative list 
separating evaluation context dynamic environment facilitate design parallel evaluation function section 
displays state space transition rules deep binding strategy 
dynamic environment represented new dlet construct appear outermost level configuration called state 
list bindings ffi regarded global stack initially empty evaluation starts 
binding pushed binding list time dynamic abstraction applied popped dynamic extent application 
section dlet construct modelling dynamic extent dynamic abstraction application dlet construct longer appears inside terms introduce pop term playing role created dynamic abstraction applied destroyed dynamic extent popping top binding binding list 
theorem establishes correctness deep binding strategy 
semantics assumes exists initial handler evaluation proceed 
state space dlet ffi state db xd pop term xs xs xd value ffi ffi xd binding list xs sv ar xs static variable xd dv ar xd dynamic variable pop evaluation context transition rules dlet ffi xs db dlet ffi fi dlet ffi xd db dlet ffix pop dlet extend dlet ffi xd db dlet ffi lk xd ffi lookup dlet ffix pop db dlet ffi pop evaluation function dlet 
db dlet db dlet error dlet 
db ms ms stuck db stuck state stuck db lk xd ffix dlet ffi xd xd dom ffi lk xd ffix lk xd ffi xd xd fig 

deep binding theorem eval eval db deep binding technique simple implement bindings pushed binding list ffi application time dynamic abstractions popped extent 
lookup operation inefficient requires searching dynamic list operation linear length 
exist techniques improve lookup operation 
shallow binding technique consists indexing dynamic environment variable names 
optimisation called shallow binding value cell associate dynamic variable fixed location contains correct binding variable lookup operation simply requires read content location 
parallel evaluation section observed axiom dlet propagate particularly suitable parallel evaluation allowed independent evaluation operator operand duplicating dynamic environment 
known deep binding strategy adapted parallel evaluation associative list representing dynamic environment shared different tasks 
previous follow parallelism annotation approach programmer uses annotation indicate expressions may evaluated parallel 
semantics described purely functional framework presence class continuations assignments 
semantics presence dynamic binding 
set terms augmented construct add set values placeholder variable represents result computation progress 
addition new construct double goal binds value second models potential evaluation parallel component mandatory term evaluated evaluation sequential speculative value known needed terminates 
state space dlet ffi dlet ffi error state xd term pop ffi error pv xs xs xd proper value runtime value av alue xs xd applicable value pop ffi seq 
ev 
context ev 
context transition rules dlet ffi 
ae dlet ffi xs dlet ffi error av alue fi dlet ffi xd 
dlet ffix pop dlet extend dlet ffi xd 
ae dlet ffi ffi dlet ffi error xd dom ffi lookup dlet ffix pop 
dlet ffi pop dlet ffi error 
error error dlet ffi 
dlet ffi ffi ltc dlet ffi ffi 
dlet ffi id dlet ffi ffi 
dlet ffi dlet ffi fp fp ffi fork dlet ffi 
pg join dlet ffi 
dlet ffi 
speculative 
reflexive 



transitive evaluation function program dlet 
dlet dlet 

error dlet 
ms ms stuck db dlet 
error fig 

parallel evaluation differences important observe valid evaluation context 
evaluation allowed proceed inside body possibly change dynamic environment fork unsound 
rule ltc stands lazy task creation replaces expression ffi interpreted mark indicating task may created :10.1.1.17.101
runtime elects create new task fork creates expression mandatory component argument argument speculative component new state evaluating context filled placeholder variable scope duplicated dynamic environment ffi runtime elect spawn new task evaluation proceed argument 
rules ltc id specify sequential behaviour value value value argument 
evaluation mandatory component terminates rule join substitutes value placeholder speculative state 
rule speculative indicates speculative transitions allowed body 
defines relation 
meaning steps involved reduction mandatory 
correctness evaluation function follows modified diamond property observation number pop terms state smaller equal length dynamic environment 
theorem eval db eval far implementation concerned rule ltc indicate dynamic environment duplicated 
refinement system indicates suffices duplicate pointer associative list long list remains accessible shared store 
rule ltc adds overhead duplicating dynamic environment dynamic variables 
feeley describes implementation avoids cost lazily recreating dynamic environment task stolen 
due orthogonality assignments dynamic binding previous results assignments merged framework 
adding assignments permits definition mutable dynamic variables construct dynamic set 

due purely dynamic nature semantics presence mutable dynamic variables offers parallelism observed 
interaction dynamic binding continuations scope 
related conference history programming languages mccarthy relates observed behaviour dynamic binding program higher order functions 
bug fixed introducing device function construct 
cartwright presents equational theory dynamic binding language extended explicit substitutions assumes call name parameter passing technique 
motivation fundamentally differs goal derive homomorphic model functional languages considering combinator 
axioms derived oe calculus axioms constructed proof equational correspondence calculus 
authors discuss issue tail recursion presence dynamic binding 
observe simple implementations fluid restore previous dynamic environment evaluating fluid body 
propose implementation strategy essence dynamic environment passing style solution 
programs dynamic environment passing style characterised fact require growth control state dynamic binding require growth heap space 
analogy continuation passing translation generates program function calls terminal position mean cps programs iterative 
feeley queinnec observe programs dynamic environment passing style reserve special register current dynamic environment 
non terminal call saves restores register strategy penalises programs dynamic binding especially byte code interpreters marginal cost extra register high 
prefer solution penalise programs price growth control state dynamic binding 
consequently believe implementors decide dynamic binding increase control state case result non iterative behaviour 
tradition syntactic theories continuations assignments syntactic theory dynamic binding 
theory helps deriving sequential evaluation function refined implementation deep binding 
integrate dynamic binding constructs framework parallel evaluation programs 
prove dynamic binding adds expressiveness purely functional language show dynamic binding suitable tool define semantics exceptions notions 
furthermore believe single framework integrating continuations side effects dynamic binding help proving implementation strategies fluid presence continuations 
daniel christian queinnec anonymous referees helpful comments 

john allen 
anatomy lisp 
mc hill 

henry baker 
shallow binding lisp 
comm 
acm 

henk barendregt 
lambda calculus syntax semantics volume studies logic foundations mathematics 
north holland 

robert cartwright 
lambda ultimate combinator 
lifschitz editor artificial intelligence mathematical theory computation papers honor john mccarthy pages 
academic press 

olivier danvy andrzej filinski 
abstracting control 
proceedings acm conference lisp functional programming pages june 

bruce duba matthias felleisen daniel friedman 
dynamic identifiers neat 
technical report indiana university computer science department 

marc feeley 
efficient general implementation futures large scale sharedmemory multiprocessors 
phd thesis brandeis university 

matthias felleisen 
expressive power programming languages 
proc 
european symposium programming lncs pages 
springer verlag 

matthias felleisen daniel friedman 
reduction semantics imperative higherorder languages 
parallel architecture languages europe lncs pages 

matthias felleisen daniel friedman 
syntactic theory sequential state 
theoretical computer science 

matthias felleisen daniel friedman eugene kohlbecker bruce duba 
syntactic theory sequential control 
theoretical computer science 

matthias felleisen robert hieb 
revised report syntactic theories sequential control state 
theoretical computer science 

andrzej filinski 
controlling effects 
phd thesis school computer science 
carnegie mellon university may 

cormac flanagan matthias felleisen 
semantics program optimization 
proceedings second annual acm sigact sigplan symposium principles programming languages january 

michael gordon 
operational reasoning denotational semantics 
proving improving programs pages arc july 

michael gordon 
semantic theory dynamic binding 
technical report stan cs stanford university august 

robert halstead jr new ideas parallel lisp language design implementation 
parallel lisp languages systems lncs pages 
springer verlag 

chris hanson 
mit scheme manual 
massachusetts inst 
tech jan 

christopher haynes daniel friedman 
embedding continuations procedural objects 
acm transactions programming languages systems 

robert hieb kent dybvig 
continuations concurrency 
second acm sigplan symposium principles practice parallel programming pages 

paul hudak simon peyton jones philip wadler editors 
report programming language haskell 


donald knuth 

addison wesley 

robert bil lewis dan richard stallman chris welt 
gnu emacs lisp manual edition 

john mccarthy 
recursive functions symbolic expressions computation machine part communications acm 

john mccarthy 
history lisp 
acm sigplan history programming languages conference acm monograph series pages june 

robin milner mads tofte robert harper 
definition standard ml 
mit press 

eric mohr david kranz robert halstead 
lazy task creation technique increasing granularity parallel programs 
proceedings acm conference lisp functional programming pages june 

david moon 
maclisp manual 
technical report mit project mac april 

luc moreau 
sound evaluation parallel functional programs class continuations 
phd thesis university li ege li ege belgium june 

luc moreau 
semantics scheme 
acm sigplan international conference functional programming icfp pages may 

luc moreau christian queinnec 
partial continuations difference continuations 
control operators 
international conference programming language implementation logic programming plilp lncs pages madrid spain september 
springer verlag 

joel moses 
function function lisp problem called environment problem 
project mac ai june 

randy osborne 
speculative computation multilisp 
parallel lisp languages systems lncs pages 
springer verlag 

julian grep editors 
definition june 

gordon plotkin 
call name call value calculus 
theoretical computer science pages 

christian queinnec 
lisp small pieces 
cambridge university press 
isbn 

christian queinnec david de roure 
design concurrent distributed language 
parallel symbolic computing languages systems applications lncs pages boston massachussetts october 
springer verlag 

christian queinnec bernard 
dynamic extent control operator partial continuations 
proceedings eighteenth annual acm sigact sigplan symposium principles programming languages pages 

jonathan rees william clinger editors 
revised report algorithmic language scheme 
lisp pointers july september 

amr sabry 
formal relationship direct continuation passing style optimizing compilers synthesis paradigms 
phd thesis rice university 

amr sabry matthias felleisen 
reasoning programs continuation passing style 
lisp symbolic computation november 

dorai sitaram matthias felleisen 
control delimiters hierarchies 
lisp symbolic computation 

guy lewis steele jr common lisp 
language 
digital press second edition 

carolyn talcott 
rum intensional theory function control abstractions 
proc 
workshop foundations logic functional programming lncs pages 
springer verlag 

larry wall tom christiansen randal schwartz 
programming perl 
reilly associates second edition edition 
