identifying modules concept analysis michael thomas reps university wisconsin madison west dayton street madison wi cs wisc edu describe general technique identifying modules legacy code 
method concept analysis branch lattice theory identify similarities set objects attributes 
discuss concept analysis identify potential modules positive negative information 
algorithmic framework construct lattice concepts program concept represents potential module 
existing software systems developed programming languages paradigms incorporate object oriented features design principles 
particular systems lack modular style making maintenance enhancement arduous task 
software engineer job difficult tools transform code explicit modules functionally equivalent object oriented code modules classes 
tool partially automate transformation legacy systems making easier maintain 
modularization programs offers added benefit increased opportunity code reuse 
major difficulty software modularization accurate identification potential modules classes 
describes technique known concept analysis help automate modularization 
main contributions ffl show apply concept analysis modularization problem 
focus variant modularization problem conversion program program appear icsm ieee int 
conf 
softw 
maint 
bari italy sept oct 
program struct types starting point program classes 
ffl previous modularization problem positive information modules identified properties function uses variable argument type 
case module identified values types depend example function uses fields struct queue fields struct stack 
concept analysis allows positive negative information incorporated modularization criterion 
see section ffl implemented prototype tool uses concept analysis propose programs 
implementation tested small medium sized examples 
largest example consists lines source code 
see section 
example consider implementation stacks queues shown 
queues represented stacks front back information shifted front stack back stack back stack empty 
queue functions stack fields indirectly calling stack functions 
stack queue functions written interleaved order able tease components apart separate classes client code 
discusses technique modules case classes identified legacy code 
resulting information supplied suitable transformation tool maps code code aforementioned example 
modularization algorithms able identify decomposition unable handle variant example stack queue tightly intertwined see section 
section show concept analysis able group code example separate queue stack modules 
section introduces contexts concept analysis algorithm building concept lattices contexts 
section discusses process identifying modules programs concept analysis 
section defines notion concept partition 
section discusses implementation 
section concerns related 
concept analysis primer concept analysis provides way identify sensible groupings objects common attributes 
illustrate concept analysis consider example crude classification group mammals cats chimpanzees dogs dolphins humans whales 
suppose consider attributes legged hair covered intelligent marine 
table shows animals considered attributes 
order understand basics concept analysis definitions required 
context triple finite sets objects attributes respectively binary relation mammal example objects different kinds mammals attributes characteristics legged binary relation table 
example tuple whales marine cats intelligent 
mappings oe fa aj rg common attributes fo oj rg common objects form galois connection 
mappings antimonotone oe oe extensive oe oe mammal example oe 
concept pair sets set objects extent set attributes intent oe 
concept maximal collection objects sharing common attributes 
example legged hair concept concept 
concept subconcept concept equivalently 
instance subconcept dolphins humans 
subconcept relation forms complete partial order concept lattice set concepts 
concept lattice mammal example shown 
fundamental theorem concept lattices relates subconcepts superconcepts follows significance theorem common superconcept set concepts computed intersecting intents finding common objects resulting intersection 
example application fundamental theorem follows covered intelligent humans dolphins 
computation corresponds fact lattice shown 
algorithms computing concept lattice context 
describe simple bottom algorithm 
important fact concepts contexts algorithm set objects smallest concept extent containing oe oe 
bottom element concept lattice oe oe concept consisting objects attributes empty set example 
initial step algorithm compute bottom element concept lattice 
step compute atomic concepts smallest concepts extent containing objects treated singleton set 
atomic concepts correspond elements concept lattice reachable bottom element step 
computation atomic concepts mammal example shown oe legged hair define queue size struct stack int base sp size struct queue struct stack front back struct stack int sz struct stack struct stack malloc sizeof struct stack base sp int malloc sz sizeof int size sz return struct queue struct queue struct queue malloc sizeof struct queue front queue size back queue size return int struct stack return sp base int struct queue return front back void push struct stack int sp sp overflow check void enq struct queue int push front int pop struct stack return sp return sp int deq struct queue return back front push back pop front return pop back const int queue size class stack private int base int sp int size public stack int sz base sp new int sz size sz int isempty return sp base int pop isempty return sp return sp void push int overflow check sp sp class queue private stack front back public queue front new stack queue size back new stack queue size int isempty return front isempty back isempty int deq isempty return back isempty front isempty back push front pop return back pop void enq int front push code implement queue stacks attributes legged hair covered intelligent marine cats chimpanzees objects dogs dolphins humans whales table crude characterization mammals 
algorithm closes set atomic concepts join initially worklist formed containing pairs atomic concepts worklist empty top chimpanzees dogs dolphins humans dolphins humans chimpanzees covered intelligent covered bot legged hair covered intelligent marine concept lattice accompanying key mammal example 
remove element worklist compute concept discovered add pairs concepts worklist 
process repeated worklist empty 
concept analysis identify potential modules main idea apply concept analysis problem identifying potential modules legacy code 
outline process follows 
build context objects functions defined input program attributes properties functions 
attributes properties relating functions data structures 
attributes discussed detail 

construct concept lattice context described section 
identify concept partitions collections concepts extents partition set objects 
concept partition corresponds possible modularization input program 
concept partitions discussed section 
applying concept analysis stack queue example consider stack queue example 
section demonstrate concept analysis identify module partition indicated code 
page 
define context 
objects attributes ff ff ff ff correspond functions properties functions indicated tables push enq pop deq ff return type struct stack ff return type struct queue ff argument type struct stack ff argument type struct queue ff uses fields struct stack ff uses fields struct queue context relation stack queue example ff ff ff ff ff ff step build concept lattice context described section 
concept lattice stack queue example key identifying lattice node labels corresponding concepts shown 
advantages concept analysis multiple possibilities modularization offered 
addition relationships concepts concept lattice offers insight structure proposed modules 
example atomic level initialization functions concepts distinct concepts functions con top universal concept fff queue concept fff stack concept fff ff enq deq fff ff push pop fff ff fff ff bot fff ff ff ff ff ff empty concept concept lattice corresponding key stack queue example 
cepts 
concepts correspond constructors sets member functions 
concept corresponds stack module corresponds queue module 
subconcept relationships indicate stack concept consists constructor concept member function concept 
adding complementary attributes stack queue example considered far demonstrated full power concept analysis brings modularization problem 
relatively straightforward separate code shown modules techniques described create grouping 
show concept analysis offers possibility go previously defined methods offers ability tease apart code sense tangled 
illustrate mean tangled code consider slightly modified stack queue example 
suppose functions enq written modify stack fields directly calling push int struct queue return front sp front base back sp back base void enq struct queue int front sp front sp may efficient code difficult maintain simple changes stack implementation may require changes queue code 
furthermore complicates process identifying separate modules 
apply concept analysis set attributes attribute ff uses fields struct stack applies enq 
context relation tangled stack queue code original sets objects attributes follows ff ff ff ff ff ff resulting concept lattice shown 
observe concept identified queue module concepts coincide stack module 
particular extent extent push concept stack concept consists push enq pop mixes stack operations queue operations 
problem attributes listed section 
reflect positive information 
distinguishing characteristic stack operations depend fields struct stack fields struct queue 
components need augment set attributes negative information case ff complement uses fields struct queue fields struct queue 
corresponding context ff ff ff ff ff ff ff top universal concept fff 
fff queue concept fff ff enq deq fff ff ff enq fff ff push pop fff ff fff ff bot fff ff ff ff ff ff empty concept concept lattice corresponding key tangled stack queue example attributes listed section 
resulting concept lattice corresponding key shown 
concept lattice contains concepts concept lattice additional concept corresponds stack module 
modularization identifies enq part queue module separate stack module operations direct stack fields 
raises issues subsequent toc code transformation phase 
able devise transformations remove dependences queue operations private members stack class introducing appropriate calls member functions stack class straightforward transformation simply friend mechanism shown class queue class stack friend class queue private public class queue private stack front back public int return front sp front base back sp back base void enq int front sp front sp choices attributes concept maximal collection objects having common properties 
cohesive module collection functions data structure having common properties 
employing concept analysis modularization problem reasonable objects correspond functions 
flexibility comes attributes 
wide variety attributes choose effort identify concepts modules program 
examples attributes reflect way struct data types 
instances may useful attributes capture properties 
possibilities attributes include ffl variable usage information related functions identified common global variables 
attribute capturing information form uses global variable 
ffl dataflow slicing information useful identifying modules 
attributes capturing information form may value flows statement part slice respect statement 
ffl information obtained type inferencing type inference uncover distinctions seemingly identical types 
example function declared type int theta int bool type inference discover general type form ff theta fi bool 
reveals type argument distinct type legacy code monolithic multiple tasks contained function 
cases may preferable objects correspond slices functions :10.1.1.50.4405
top universal concept fff fff queue concept fff ff stack concept fff ff enq deq fff ff ff enq fff ff ff push pop fff ff fff ff ff bot fff ff ff ff ff ff ff empty concept concept lattice corresponding key stack queue example 
second argument declared type 
attributes form argument type ff simply argument type int 
prevent functions grouped merely superficial similarities declared types arguments 
ffl disjunctions attributes user may aware certain properties input program similarity data structures 
disjunctive attributes allow user specify properties form 
example uses fields stack uses fields queue 
attributes context 
highlights advantages concept analysis approach modularization represents just single algorithm modularization provides framework obtaining collection different modularization algorithms 
concept module partitions far discussed concept lattice built program way concepts represent potential modules 
overlaps concepts group concepts represents potential modularization 
feasible partitions collections modules disjoint include functions input code 
limit number choices software engineer helpful identify partitions 
context concept partition set concepts extents form partition gamma gamma concept partition iff extents concepts cover object set pairwise disjoint 
terms program concept partition corresponds collection modules function program associated exactly module 
simple example consider concept lattice shown 
concept partitions context listed fc fc fc fc atomic partition 
combinations atomic concepts larger concepts 
consists stack module queue module 
trivial partition functions placed module 
looking concept partitions software engineer eliminate nonsensical possibilities 
preceding example appear partition module nonoverlapping concept deq belong 
atomic partition concept lattice concept partition consisting exactly atomic concepts 
recall atomic concepts concepts smallest extent containing objects treated singleton set 
instance see atomic concepts mammal example section 
concept lattice need atomic partition 
example lattice atomic partition atomic concepts overlap object chimpanzees extent concepts 
atomic partition concept lattice starting point choosing modularization program 
order develop tools concept partitions useful able guarantee existence atomic partitions 
achieved augmenting context negative information similar section 
details done algorithm find partitions concept lattice 
implementation results implemented prototype tool employs concept analysis propose programs 
written standard ml new jersey version conjunction interface tcl tk 
runs sun sparc solaris 
prototype takes program input builds context 
fed concept analyzer builds concepts bottom described section 
system front builds syntax tree annotated type information 
context constructed routines walk structure 
default context construction routines provided build contexts object set set functions defined input program attribute set consists attribute form uses fields struct userdefined struct type equivalent typedef input program 
examples analyzed implementation 
begun investigate larger examples 
particular prototype tool spec benchmark go faces go 
program consists roughly lines code functions user defined data types 
concept lattice fully complemented context associated functions data types consists concepts constructed seconds user time sparcstation mb ram 
partitioner identified possible partitions lattice roughly amount time 
case study program taken library computes convex hull set vertices plane 
program consists roughly lines code 
functions user defined struct data types representing vertices edges faces respectively 
context fed concept analyzer consisted functions object set attributes uses fields fields binary relation indicating function uses fields struct types 
concept analyzer built concepts corresponding lattice roughly second user time 
partitioner computed possible partitions concept lattice roughly seconds 
atomic partition groups functions concepts listed table 
partition indicates code cleanly break modules struct type 
assuming goal transform equivalent program concepts suggest possible modularization types concepts correspond classes vertex edge face respectively concept correspond driver module functions concepts form friend modules functions declared friend appropriate classes 
alternatively group concepts polyhedron class nested vertex edge face classes 
concept represent driver module 
possibility corresponds non atomic partitions 
related modularization reflects design decision inherently subjective modularization process fully automated 
user interaction required concept analysis approach offers certain advantages previously proposed techniques ability stay system opposed applying ad hoc methods user judges modularization system suggests unsatisfactory 
proposed modularization fine scale user move partition lattice 
see section 
proposed modularization coarse user add additional attributes generate concepts 
see section 
furthermore concept analysis really provides family modularization algorithms offering fixed technique different attributes chosen different situations 
reader referred pp 
extensive discussion literature modularization problem 
remainder section discuss relevant approach taken 
concept number user defined struct types functions main cleanup printout collinear volume convexity consistency print tetrahedron checks table atomic partition concept lattice derived liu wilde table object attribute relation context 
uses concept analysis analyze tables liu wilde propose powerful analysis 
propose user intervene ad hoc adjustments results modularization unsatisfactory 
explained concept analysis approach naturally generate variety possible decompositions different collections concepts partition set objects 
concept analysis approach general canfora identifies data types analyzing graph links functions argument types return types 
information captured context objects functions attributes possible argument return types example attributes ff ff attribute table section 
adding attributes indicate fields compound data types function done example powerful tool identifying potential modules technique described 
described expands data type identification technique described call dominance information introduce hierarchical nesting structure modules 
may possible combine techniques concept analysis approach 
canfora discuss types links cause undesirable clustering functions 
type coincidental links caused routines implement function overcome program slicing :10.1.1.50.4405
second type spurious links caused functions access supporting data structures object type 
approaches mentioned spurious links arise function accesses global variables different types 
described stumble examples exhibit spurious links 
approach analogous kind spurious link arises due functions access internal fields struct 
example tangled code example discussed section enq function uses fields struct stack struct queue 
additional discriminatory power concept analysis approach due fact able exploit positive negative information 
certain amount involving cluster analysis identify potential modules 
implicitly explicitly involves identification potential modules determining similarity measure pairs functions 
currently investigating link concept analysis cluster analysis 
concept analysis applied kinds problems 
concept analysis applied software engineering nora recs tool identify conflicts software configuration information 
contemporaneously lindig snelting independently explored idea applying concept analysis modularization problem 
studies context relations concept analysis relate function program global variables accessed function 
results reported lindig snelting case studies small medium sized fortran cobol programs encouraging 
cases concept lattice resulted identify useful ways decompose program modules 
believe results achieved approach concept analysis promising lindig snelting due factors ffl languages techniques applied fortran cobol case lindig snelting versus toc conversion problem variant modularization problem structure fortran cobol conversion modularization problems 
particular program struct types serve natural starting point program classes 
ffl lindig snelting context relations relate function program global variables accessed function 
context relations relate function program fields userdefined struct types function accesses ii types sub expressions occur function iii complements ii 
ffl employ negative information attributes form fields struct 
allows concepts identified similarities functions differences 
supported part national science foundation ccr defense advanced research projects agency arpa order monitored office naval research contract 
comments krishna das reported greatly appreciated 
carver 
greedy approach object identification imperative code 
third workshop program comprehension pages 
canfora cimitile munro 
improved algorithm identifying objects code 
software practice experience january 
canfora cimitile munro 
experiments identifying reusable data types program code 
second workshop program comprehension pages 
canfora de lucia di 
recovering architectural design software comprehension 
third workshop program comprehension pages 
cimitile munro 
program comprehension identification data types 
third workshop program comprehension pages 
godin missaoui 
incremental concept formation algorithms galois concept lattices 
computational intelligence 
horwitz reps binkley 
interprocedural slicing dependence graphs 
acm transactions programming languages systems january 
david victor basili 
system structure analysis clustering data bindings 
ieee transactions software engineering se august 
thomas kunz 
evaluating process clusters support automatic program understanding 
fourth workshop program comprehension pages 
christian lindig gregor snelting 
assessing modular structure legacy code mathematical concept analysis 
proceedings th international conference software engineering pages 
liu norman wilde 
identifying objects conventional procedural language example data design recovery 
conference software maintenance pages 
ieee computer society press november 
panos johnson 
new approach finding objects programs 
software maintenance research practice 
philip newcomb 
reengineering procedural objectoriented systems 
second working conference reverse engineering pages july 
robert callahan daniel jackson 
practical program understanding type inference 
technical report carnegie mellon university may 
melo hakim fran cois 
applying concept formation methods object identification procedural code 
technical report crim crim 
michael thomas reps program generalization software reuse 
fourth acm sigsoft symposium foundations software engineering pages san francisco october 
michael thomas reps identifying modules concept analysis 
technical report cs tr university wisconsin madison january 
gregor snelting 
reengineering configurations mathematical concept analysis 
acm transactions software engineering methodology april 
weiser 
program slicing 
ieee transactions software engineering se july 
rudolf wille 
restructuring lattice theory approach hierarchies concepts 
ivan rival editor ordered sets pages 
nato advanced study institute september 
alexander yeh david harris howard 
recovering data types object instances conventional procedural language 
second working conference reverse engineering pages 
