expressing object residency optimizations pointer type annotations eliot moss antony hosking object systems laboratory department computer science university massachusetts amherst ma usa sixth international workshop persistent object systems provence france september consider issues optimizing persistent programming languages 
particular show express optimizations object residency checks strongly typed persistent languages annotations pointer types 
annotations essentially extend refine type system language significant uses 
programmer express desired residency properties enforced language implementation compiler plus run time 
second separate persistence optimizer adds annotations remainder compiler simply obeys 
gives rise nice separation concerns supporting high performance persistence intelligent optimizer factored rest compiler 
addition modularity benefits separation allows explore value various optimizations implementing optimizer 
optimize programs hand compare optimized unoptimized code develop sound data deciding implement optimization 
approach similar source source optimizers means new idea case target language extension source language specifically designed easier compile 
applying approach ongoing implementation persistent modula 
type annotation approach context modula applicable strongly typed persistent programming language range kinds optimizations 
motivation developing run time support optimizing compiler persistent modula time 
process conceived number optimizations consider improve performance persistent programs hm hm compared approaches dealing things object faults attempts persistent objects currently resident process virtual address space persistent smalltalk implementation hm hm 
optimizations thought require reasonably powerful data flow analysis code transformations hoisting combining residency checks imposing special rules complicate compiler argument information modula see cdg cdg cdg nel har information persistence see ms mos mos mos hmb hm hm hos mos hm hm 
method call target object automatically resident execution method method code need contain checks uses target object 
implementing optimizations require lot effort back modern optimizing compiler gnu compiler back 
concluded best explore effectiveness variety optimizations trying implement 
willing hand optimize collection benchmark programs needed way express possible results optimizations 
point able control code emitted compiler 
working context statically typed compiled object oriented language modula persistence extensions decided try expressing results optimizations type system giving rise approach point 
organize remainder presentation follows 
describe relevant aspects persistent non persistent modula 
briefly review object faulting object residency checking enumerate ways implementing 
argue residency check optimization list residency related optimizations want explore 
explain types type conversions express residency knowledge residency checks show approach express desired optimizations various implementation approaches 
finish concluding remarks 
relevant aspects persistent modula modula strongly typed object oriented language tradition pascal modula 
modula adds object types single inheritance hierarchy automatic storage management garbage collection exception handling threads lightweight processes running address space generic interfaces modules templates expanded syntactically needed form members parameterized family interfaces modules 
concerned types procedure calls method calls modula assume reader grasp constructs intuitively knowledge pascal modula 
object oriented languages smalltalk gr trellis owl modula uniformly object oriented full collection primitive types integer real range enumeration type constructors record array ref proc addition object types 
assume example code fragments grasped intuitively knowledge pascal 
modula object type consists supertype object type possibly built type root zero new fields declared analogously record fields zero new methods names bound procedures invoked named method called zero overrides supertype method bindings syntax super object fields methods methods overrides overrides example shows trivial point data type giving methods manipulating points implementations giving representation implementation details subtype 
modula opaque types hide representation type rep actual type point 
type point data method implementations useful type point root object methods scale real point 
rep point object integer overrides scale scale point modula allows appropriately constrained self names scope respect order declaration easy define recursive types type ilist ref record integer ilist worthwhile note modula object types implicitly pointers dynamically allocated memory containing object fields method suite object object oriented form integer list type type olist object integer olist modula procedure call straightforward 
argument binding modes value default indicated var rights modify argument indicated readonly 
modula exception handling irrelevant describe 
modula method call respects ordinary procedure call 
target object explicitly listed method call interface implied object type seen scale point object type example 
note procedure bound scale include target object argument example procedure scale point rep real rep 
language sub type checking rules allow scale point implementation scale case 
example method call point scale far described non persistent modula 
add persistence modula changed little hm re interpreted ref mean possibly persistent instance likewise object types :10.1.1.34.5174
possibly persistent mean newly created instances need created store opposed existing main memory reachable persistent root object designated time checkpoint 
side note observe modula includes untraced ref addition ref untraced pointer types managed explicit allocation deallocation traced garbage collector 
useful occasion allocating fixed buffers 
hm added transient ref analogy untraced types transient pointer types refer instances persistent :10.1.1.34.5174
appear occasional uses ignore untraced transient pointer types irrelevant 
document interface foundation implementations 
opaque types relevant discuss 
modula method suite vector pointers code methods terminology virtual function table 
object faulting residency checking idea persistent programming language provide transparent access objects maintained persistent object store 
simply reading writing blocks data traditional file persistent programming language object store preserve object identity object unique identifier essence address possibly store objects refer objects forming graph structures modified modifications visible accesses unique object identifier 
adequate address space read map virtual memory entire object store reasons get assume implementation strategy preferred 
program runs need load objects demand persistent object store main virtual memory 
object fault attempt non resident object 
object faulting relies object residency checks implemented explicitly software performed implicitly hardware giving rise kind hardware trap non resident objects 
object faulting relies mechanisms load objects store memory ultimately write modified objects back 
complete environment integrate support concurrency control recovery distribution focus primarily object residency aspects persistent systems 
wide range object faulting schemes devised acc bc kk kae cm rms smr bbb ric scd wd hmb hos hm wk exhaustive 
scheme number distinct situations resident object presumably causing object fault versus non resident object 
concerned situations require compiler generate distinct code distinct situations give rise corresponding representations 
example schemes drive faulting memory protection traps object faulting entirely transparent compiled code smr scd representation apparently resident objects 
gathered evidence totally transparent schemes offer best performance hm hm hms 
interested schemes representation 
list range possible representations 
scheme may combine number subsets lot sense 
point program optimizer develop upper bound representations possible pointer general multiple representations may possible may able establish object resident situations may different representations 
observe schemes differ swizzle pointers convert possibly different formats persistent store main memory 
direct pointer direct virtual memory pointer apparently resident object object resident hardware traps may resident pointer requires check background swizzling reader may start mos wd wk 
pointer manipulation code pointers resident objects arranged prefetching pointers trap different performance characteristics ultimately care distinguish 
object identifier unique object identifier requires kind table lookup locate corresponding object data memory assumed complex require call lookup routine object resident avoids swizzling may incur repeated lookup costs indirect pointer pointer cell containing pointer object contents similar direct pointer scheme flexible need allocate address space object contents prior loading object need know object true size advance requires check fault block pointer fixed size block memory contains object unique identifier causes fault proxy object pointer object stands non resident object method suite methods load true object field access load object method call transparent indirect object pointer object stands resident object method suite methods forward calls true object field access forward explicitly method call transparent 
number schemes developed choosing appropriate subsets representations 
course representations require different code distinguishable pointer multiple possible representations compiler generate tests discriminate 
schemes give sense possibilities ffl direct pointer completely transparent requires hardware traps preloading reachable objects ffl direct pointer fault block persistent smalltalk implementation requires explicit checks discriminate system design localized primarily method invocation ffl direct pointer object identifier requires tag bit pointers may result excess object identifier lookups partly avoided faulting load pointer swizzle discovery ffl object identifier useful pointer traversed times program execution avoids overhead swizzling ffl direct pointer proxy object indirect object proxy indirect ordinary objects distinguishable field access method call transparent field access turned method call gain complete transparency possibly higher overhead ffl direct pointer proxy object avoiding indirect objects speeds resident objects requires removal indirections objects loaded costly residency optimizations consider residency checking optimizations want trying improve performance programs written persistent programming language 
list optimizations thought local subsumption dereference pointer multiple times piece straight line code force residency 
additionally impose appropriate rule pinning object preventing removed address space straight line code remaining uses need check residency 
note subsumption similar common subexpression elimination differs side effect idempotent 
global subsumption appropriate data flow analysis apply subsumption basic blocks intra inter procedurally 
result similar hoisting common subexpressions 
target object residency invoking method requires making target object resident method code assume target residency 
yield great improvements programs written object oriented style 
formal parameter assertions may useful require procedure method argument resident making call 
caller knows object resident checks needed caller callee 
hoisting perform residency checks near procedure eliminate checks caller knows object resident 
formal parameter assertions especially useful internal methods called public methods recursive calls non object oriented code 
procedure result assertions procedure returns newly created object guaranteed resident procedure caused object guaranteed resident entry procedure help caller downstream code know 
data type assertions case data type multiple levels pointers convenient fault levels objects may arrive anyway proper clustering avoid checks traversing levels 
accomplished associating residency assertions pointers inside data structures 
observe recursive data structures placing assertions recursion pointers field ilist type example may require large closure objects resident may idea objects 
original implementation programming language ric rc ric included optimization similar subsumption 
operated general model unit access byte ranges objects unify overlapping ranges space time 
applied somewhat ad hoc manner cfront implementation abandoned versions richardson departure group 
type inference techniques enable compiler know precise type avoid object oriented dispatch case need introduce explicit check 
clustering important issue affects performance noticeable incremental cpu overheads outside scope 
see discussion clustering 
converse sort assertion rarely traversed best kept object identifier form looked 
optimizations subsumption profitable negative effect pinning objects longer requiring support pinning may turn require compiler produced tables run time system determining objects pinned lines compiler support accurate garbage collection diw 
similarly target object residency probably idea rare target message method statically known 
formal parameter assertions require care prevent objects loaded 
data type assertions run risks high payoff 
may require profile feedback addition static analysis optimizer decisions 
types residency optimization describe detail central idea express persistence representation assertions qualifications pointer types 
convenient choose particular fairly interesting scheme basis presentation trust application schemes obvious 
example scheme representations proxy objects direct pointers object identifiers 
scheme includes exactly possible degrees knowledge implementation may concerning object residency state knowledge described non empty subset set allowed representations 
scheme allow precisely subsets proxy direct direct object identifier 
groupings avoid need discriminate dynamically pointers object identifiers puts fewer constraints representation object identifiers 
explains absence subsets containing object identifier 
second just useful requires exactly cases direct 
note certainly conceive allowing subsets clearly possible schemes approach 
ref indicate direct knowledge res ref resident id ref similar annotations object types 
sense types support operations id ref requires lookup dereference perform method call ref requires discrimination possible conversion dereference method call res ref supports operations directly 
define strict language field access permitted res ref method call allowed ref res ref supply conversion operators pairs annotations 
note kinds pointers equivalent level language semantics differ implementation properties 
situation analogous packed unpacked data structures represent values different ways 
strict language tiresome humans 
easy extend strict language allow operations pointer representations necessary conversions implied temporary variables discarded 
posit built functions ref res id perform explicit conversions syntax syntax really matter purposes 
practice pragmas new keywords annotated programs processed compilers important 
consider various optimizations represented annotations 
local subsumption introduce new local variable res ref multiple times unoptimized optimized tmp res ref res 
tmp 

tmp 
global subsumption introduce new res ref local variable set point want hoist residency check subsequently example needed 
target object residency issue having way express method object type target object residency assumptions insure procedures bound methods conform assumptions 
way accomplish associate annotations method names object types type point root object methods res scale real point 
procedure bound scale declare argument manner compatible method res annotation 
case res ref plain ref right id ref 
formal parameter result assertions similar target object residency tags associate tags procedure formals results procedure scale point res rep real res rep 
general target object residency annotations apply argument position procedure applies ordinary procedure call addition method calls 
necessary conversions performed caller arguments call results call result 
note res built function applied types objects 
data type assertion easy devise form assertions allow residency annotations types record fields object fields arrays parameter result annotations 
meaning manipulation rules bit subtle 
consider recursive type declaration type res object integer entire list resident 
entire list accessed may load objects necessary 
hardware trap driven loading software pre loading prevent loading hardware traps come fielding costs 
indicates assertions care 
problem wish different annotations underlying type program 
example suppose declaration type id object integer glance think convert object type type involve traversing list converting embedded 
unfortunately list referred pointers types simultaneously gives rise inconsistent assertions field objects 
difficulty artifact notation inherent program represent object consistently 
similar concerns precluded subtyping record types modula see language got spots discussions nel 
clear restriction consistent annotations significant performance impact 
additional note observe unroll recursive type fixed number times place different assertions place type loop 
appears require similar unrolling related recursive procedures iterative loops obvious want 
similar optimization suggested standard ml implementation sra 
clustering focused problem residency check optimization annotations propose bear relation clustering prefetching persistent data especially case data type assertions 
particular data type annotation indicates target pointer field resident basic options implementation force residency root data structure resident transparent probably protection trapping technique 
code generated case decide run time 
example set pointers objects resident arrive cluster root object protection traps excursions outside region 
possibly interesting hybrid approach set protection traps simultaneously requesting non resident clusters 
clusters arrive objects swizzled page protections turned course application hit protection barrier case wait anyway 
case annotations thought expressing existing clustering extent static method express expressing desired clustering 
note clustering global decision affecting applications data different applications different clustering preferences reach compromise 
replicate data different clustering induces tradeoffs data updated 
essential point clustering problem similar residency check optimization problem similar annotation schemes probably need separate annotations clustering residency optimization 
observe annotations discussed adequate control code produced adequate sophisticated control prefetch 
prefetch closely related residency wemay prefer annotations integrate residency prefetch guidance compiler run time system clustering handled separately 
note residency annotations essentially exist object store different programs different annotations problems 
shown control fairly precisely placement residency checks conversions express range interesting residency optimizations pointer type annotations 
technique appears reasonably simple effective goals separating residency optimization decisions implementation 
course general idea new source source transformations widely optimizing programs especially parallel machines 
type tagging approach suggested modula untraced ref ref types notion multiple representations value fairly obvious packed versus unpacked types 
similar annotation techniques distributed programming languages distinguish local versus remote forth 
take credit slightly new application old ideas 
tentatively conclude approach effective goals limits 
general technique 
similar annotations distributed programming languages approach extend situation 
believe pointer type annotations applied successfully indicating compiler knowledge concurrency control status 
lock system distinguish unlocked share mode locked exclusive mode locked 
residency case left object somewhat vague unspecified concurrency control probably important clear object unlocked 
difference locking semantically significant residency optimization affects performance semantics 
possible application pointer type annotations reducing recording objects modified persistent program executes 
modification noting analogous residency checking idempotent provided object written back store modifications 
similar techniques apply 
problem modification dynamic particularly static techniques 
generally exact limits applicability pointer type annotations optimization clear 
certainly source source transformation limited target language expressiveness 
example address calculation required array subscripts expressed directly fortran case point technique works application 
acc malcolm atkinson ken paul cockshott 
ps algol algol persistent heap 
acm sigplan july 
bbb francois bancilhon gilles benzaken claude delobel sophie patrick pfeffer philippe richard fernando velez 
design implementation object oriented database system 
dittrich dit pages 
bc brown cockshott 
persistent object management system 
technical report persistent programming research project university st andrews scotland 
black hutchinson jul levy carter 
distribution types emerald 
ieee transactions software engineering january 
cdg luca cardelli james donahue glassman mick jordan bill kalsow greg nelson 
modula report 
technical report orc dec systems research center olivetti research center palo alto menlo park ca 
cdg luca cardelli james donahue glassman mick jordan bill kalsow greg nelson 
modula report revised 
technical report dec src dec systems research center olivetti research center palo alto menlo park ca november 
cdg luca cardelli james donahue glassman mick jordan bill kalsow greg nelson 
modula language definition 
nelson nel chapter pages 
cm george copeland david maier 
making smalltalk database system 
proceedings acm sigmod international conference management data pages boston massachusetts june 
acm sigmod rec 

dit dittrich editor 
proceedings second international workshop object oriented database systems volume lecture notes computer science bad am stein federal republic germany september 
advances object oriented database systems springer verlag 
diw amer diwan 
stack tracing statically typed language october 
position oopsla workshop garbage collection 
amer diwan eliot moss richard hudson 
compiler support garbage collection statically typed language 
conference programming language design implementation pages san francisco california june 
sigplan acm press 
alan dearle gail shaw stanley zdonik editors 
proceedings fourth international workshop persistent object systems martha vineyard massachusetts september 
published implementing persistent object bases principles practice morgan kaufmann 
gr adele goldberg david robson 
smalltalk language implementation 
addison wesley 
har harbison 
modula 
prentice hall new jersey 
antony hosking eric brown eliot moss 
update logging persistent programming languages comparative performance evaluation 
proceedings nineteenth international conference large data bases pages dublin ireland august 
morgan kaufmann 
hm antony hosking eliot moss :10.1.1.34.5174
compile time optimisations persistence 
dearle pages 
hm antony hosking eliot moss 
compiler support persistent programming 
coins technical report university massachusetts amherst ma march 
hm antony hosking eliot moss 
object fault handling persistent programming languages performance evaluation 
proceedings conference object oriented programming systems languages applications pages washington dc october 
hm antony hosking eliot moss 
protection traps alternatives memory management object oriented language 
proceedings fourteenth acm symposium operating systems principles pages asheville nc december 
hmb antony hosking eliot moss cynthia bliss 
design object faulting persistent smalltalk 
coins technical report university massachusetts amherst ma may 
richard hudson eliot moss amer diwan christopher weight 
language independent garbage collector toolkit 
coins technical report university massachusetts amherst september 
hms antony hosking eliot moss darko 
comparative performance evaluation write barrier implementations 
proceedings conference object oriented programming systems languages applications pages vancouver canada october 
acm sigplan 
october 
hos antony hosking 
main memory management persistence october 
position oopsla workshop garbage collection 
kae ted 
virtual memory narrow machine object oriented language 
oopsla oop pages 
kk ted glenn krasner 
loom large object oriented memory smalltalk systems 
glenn krasner editor smalltalk bits history words advice chapter pages 
addison wesley 
charles lamb gordon landis jack orenstein dan weinreb 
objectstore database system 
communications acm october 
mos eliot moss 
implementing persistence object oriented language 
coins technical report university massachusetts amherst ma september 
mos eliot moss 
addressing large distributed collections persistent objects mneme project approach 
richard hull ron morrison david stemple editors proceedings second international workshop database programming languages pages beach oregon june 
morgan kaufmann 
available coins technical report university massachusetts 
mos eliot moss 
design mneme persistent object store 
acm trans 
inf 
syst april 
mos eliot moss 
working persistent objects swizzle swizzle 
ieee transactions software engineering august 
ms eliot moss steven 
managing persistent data mneme designing reliable shared object interface 
dittrich dit pages 
nel greg nelson editor 
systems programming modula 
prentice hall new jersey 
oop proceedings conference object oriented programming systems languages applications portland oregon september 
acm sigplan 
november 
rc joel richardson michael carey 
persistence language issues implementation 
software practice experience december 
ric joel edward richardson 
persistent systems implementation language 
phd thesis computer sciences department university wisconsin madison wi august 
available computer sciences technical report 
ric joel richardson 
compiled item faulting new technique managing persistent language 
dearle pages 
rms steve fred andrew straw 
integration database management object oriented programming language 
dittrich dit pages 
craig schaffert cooper bruce mike kilian carrie 
trellis owl 
oopsla oop pages 
scd schuh carey dewitt 
persistence revisited implementation experiences 
dearle pages 
vivek singhal kakkad paul wilson 
texas efficient portable persistent store 
proceedings fifth international workshop persistent object systems pages san italy september 
smr andrew straw fred steve 
object management persistent smalltalk system 
software practice experience august 
sra zhong shao john reppy andrew appel 
unrolling lists 
acm conference lisp functional programming orlando florida june 
wd seth white david dewitt 
performance study alternative object faulting pointer swizzling strategies 
proceedings eighteenth international conference large data bases pages vancouver canada august 
morgan kaufmann 
wk paul wilson kakkad 
pointer swizzling page fault time efficiently compatibly supporting huge address spaces standard hardware 
proceedings international workshop object orientation operating systems pages paris france september 
ieee press 
