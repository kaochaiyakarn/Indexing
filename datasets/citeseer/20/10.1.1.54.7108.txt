interprocedural coincidence theorem jens knoop bernhard steffen interprocedural generalization known intraprocedural coincidence theorem kam ullman provides sufficient condition equivalence meet paths mop solution maximal fixed point mfp solution data flow analysis problem 
generalization covers arbitrary imperative programs recursive procedures global local variables formal value parameters 
absence procedures reduces classical intraprocedural version 
particular stack approach generalizes coincidence theorems barth sharir pnueli setup properly deal local variables recursive procedures 
motivation data flow analysis classical method static analysis programs supports generation efficient object code optimizing compilers cf 
mj 
imperative languages provides information program states may occur program points execution 
theoretically founded data flow analyses interpretation cf 
cc 
point approach replace full semantics simpler version tailored deal specific problem 
usually semantics specified local semantic functional gives meaning program statement terms transformation function lattice 
elements express data flow information interest 
global semantics results globalization strategies operational meet paths mop strategy denotational maximal fixed point mfp strategy sense kam ullman ku 
mop strategy directly mimics possible program executions meets intersects information corresponding program paths reaching program point consideration 
specifies optimal result globalization general effective 
mfp strategy iteratively approximates greatest solution system equations express consistency pre conditions post conditions terms data flow information pre condition statement implied post conditions predecessors post condition implied result transforming pre condition meaning statement 
general leads suboptimal algorithmic description 
proceedings th international conference compiler construction cc paderborn germany springer verlag lncs 
version slightly updated 
institut fur informatik und praktische mathematik christian universitat 
kiel part done author supported deutsche forschungsgemeinschaft la 
lehrstuhl fur informatik ii technische hochschule aachen 
aachen 
strategies lead mop solution mfp solution respectively 
operational denotational flavour strategies particularly apparent interprocedural setting 
intraprocedural coincidence theorem ku states coincidence mop solution mfp solution case distributive local semantic functionals see section 
interprocedural generalization theorem cf 
interprocedural coincidence theorem covers arbitrary imperative programs recursive procedures global local variables formal value parameters 
absence procedures reduces classical intraprocedural version kam ullman 
point generalization stacks lattice elements data flow information necessary properly deal local variables recursive procedures 
stacks directly mimic run time stacks run time systems maintaining activation records different procedure incarnations 
operational mop strategy exhaustively stack structure turns denotational mfp strategy needs stacks length 
related semantically reasoning interprocedural data flow analysis considered cousot cousot cc rosen ro jones muchnick jm bourdoncle bo 
rosen ro proved correctness interprocedural data flow analysis algorithm computing maximal fixed point solution provides information variable modified preserved 
algorithm tailored specific problems clear generalize approach arbitrary interpretations 
general situation investigated cc jm leading highly technical definitions difficult apply 
ro papers address correctness aspect optimality 
holds approach bo considers correctness data flow analyses respect collecting semantics program 
correctness optimality considered barth ba ba sharir pnueli sp independently proposed interprocedural version coincidence theorem kam ullman 
approaches properly deal local variables recursive procedures require store information local variables treating recursive procedure call 
structure sketching intraprocedural setting section recall formal framework interprocedural data flow analysis section define versions semantics programs procedures section operational caused interprocedural meet paths strategy denotational caused interprocedural maximal fixed point strategy 
subsequently section presents main results section sketches applications section contains 
appendix provides detailed data flow analysis algorithms 
intraprocedural setting section summarize intraprocedural setting data flow analysis characterized separate independent investigation procedures program 
common represent procedures directed flow graphs node set edge set nodes represent statements edges nondeterministic branching structure corresponding procedure 
pred df succ df denote set immediate predecessors successors construction flow graphs described 
node respectively 
denote unique start node node assumed possess predecessors successors respectively 
finite path sequence nodes gamma 
denotes set finite paths set finite paths predecessor denotes number node occurrences unique path length 
assume node lies path complete semi lattice elements intended express relevant data flow information local semantics flow graph semantic functional 
gives meaning node terms transformation simplicity assumed associated identity local semantics easily extended cover finite paths 
path define df id ffi global semantics results globalization strategies operational meet paths mop strategy denotational maximal fixed point mfp strategy sense kam ullman ku 
mop strategy directly mimics possible program executions meets intersects informations belong program path reaching program point consideration mop solution mop directly reflects desires general effective 
mfp strategy iteratively approximates greatest solution system equations specifies consistency pre conditions post conditions expressed terms equation system pre post pred post pre denoting greatest solution equation system respect start information pre post solution mfp strategy defined mfp solution mfp pre general leads suboptimal algorithmic description 
global notions semantics operational precisely mimics intention denotational algorithmic character 
fact consider mop strategy mean direct specification data flow analysis problems mfp strategy algorithmic realization problems 
view rises question correctness safety completeness optimality algorithms 
elegant answer questions need notions complete semi lattice function called ffl monotonic iff implies ffl distributive iff uc ff known distributivity stronger requirement monotonicity sense lemma function monotonic iff uc ff lemma denote complete semi lattice 
cf 
ku theorem safety theorem flow graph mfp solution correct safe approximation mop solution mfp mop semantic functions monotonic 
distributivity semantic functions yields completeness optimality 
follows known intraprocedural coincidence theorem ku theorem coincidence theorem flow graph mfp solution complete optimal mop solution mop mfp semantic functions distributive 
interprocedural notions interprocedural setting represent programs pi systems recursive procedure definitions pi list formal value parameters list local variables 
assumed denote main program called 
procedure declarations pi 
simplicity assume static procedure nesting encloses variables main program global variables procedures accessed 
denotational approach operational approach require different representations programs pi flow graph systems interprocedural flow graphs 
flow graph systems denotational approach works systems flow graphs disjoint sets nodes edges procedure pi including main program represented directed flow graph sense section 
df fn denotes set nodes df fe set edges set nodes representing procedure calls 
need functions denotes power set operator ffl fg fg df iff explicit algorithms appendix integrating static procedure nesting straightforward 
ffl callee callee df iff procedure call ffl caller caller df fn callee ffl start fs start df kg ffl fe df kg 
intuitively fg maps node flow graph system corresponding flow graph callee call node called procedure caller procedure set call nodes start procedure start node node respectively 
illustrative flow graph system 
call psi ff omega phi omega phi psi ff call psi ff omega phi omega phi psi ff flow graph system interprocedural flow graphs operational approach requires explicit representation interprocedural control flow caused procedure calls 
achieved combining flow graphs interprocedural flow graph cf 
sp 
detail results applying step procedure node algorithm flow graph system 
replace new nodes call node nc return node nr nc set predecessors successors nr set successors predecessors 

draw edge nc start callee callee nr denote set call nodes return nodes respectively pred df set immediate interprocedural predecessors identify set nodes set nodes get interpretation independent notion program point 
psi ff omega phi omega phi psi ff psi ff omega phi omega phi psi ff omega psi ff phi psi omega phi ff omega psi phi ff omega psi phi ff interprocedural flow graph shows interprocedural flow graph corresponds flow graph system 
interprocedural paths notion finite path introduced section naturally applies interprocedural flow graphs 
due special nature procedure calls finite path represents valid execution 
example path possible path 
led definition interprocedural valid paths sp definition interprocedural path 

interprocedural path iff tuple results deleting nodes formed sense ffl return node formed ffl smallest index rg return node 
formed iff gamma call node matching remaining sequence deleting gamma formed 

call node return node said correspond eliminated simultaneously procedure 

ip denotes set interprocedural paths ip set interprocedural paths predecessor nc called match nr vice versa 
complete interprocedural paths order determine semantics procedure calls need deal complete interprocedural paths start fg characterized fact procedure calls completed subsequent return 
guarantees occurrences start fg belong procedure incarnation 
definition complete interprocedural path 
interprocedural path ip start fg called complete possesses equally occurrences procedure call return nodes fi fi 
cip start fg cip start fg denote set complete interprocedural paths start fg start fg predecessor respectively 
realizes intention consequence property interprocedural paths lemma ip interprocedural path pairs corresponding call return nodes 
integer intervals disjoint included 
pattern illustrated nr assumed pairs corresponding call return nodes nc nc nr nc nc nr nr nr ip complete interprocedural paths lemma easily proved important lemma fs ip pair corresponding call return nodes 
gamma cip start callee callee underlying program pi procedures flow graph system interprocedural flow graph collapse flow graph special case framework coincides standard intraprocedural framework 
conventions rest assume arbitrary fixed program pi flow graph system interprocedural flow graph node assumed lie interprocedural path possibly indexed nodes node nc nr denote corresponding call node return node respectively 
semantics section new interprocedural versions meet paths strategy maximal fixed point strategy 
define global semantics interprocedural flow graphs flow graph systems respectively 
point presentation extension data flow information way mimics run time stacks run time systems 
local semantic functional intraprocedural counterpart interprocedural meet paths solution directly records possible program executions lead particular program point 
presence recursive procedures necessary stacks lattice elements lattice order record part history relevant returning nested procedure calls 
local semantic functional type 
stack stack stack denotes set non empty stacks components manipulated means operations ffl stack ffl push stack theta stack ffl pop stack stack ffl top stack intuitively creates new stack single component push puts new component top argument stack pop removes top component top delivers content top component affecting argument stack 
top components stacks affected operations 
stack version run time stacks run time systems maintaining activation records different procedure incarnations 
intuitively top component stack contains data flow information corresponding currently valid activation record data flow informations remaining stack components correspond activation records preceding finished procedure calls 
contrast concrete run time stack variables global currently activated procedure accessed means static dynamic link chains components data flow analysis stack assumed contain information related current procedure incarnation information related global variables 
data flow analysis stacks directly reflect nesting procedure incarnations current call sequence 
formally local semantic functional setting defined stk stack stk df push pop stk top stk push stk top stk push pop pop stk top pop stk top stk consider operation usual stack order exclude empty stacks irrelevant framework 
dealing empty stacks 
static dynamic link chains just technical mean getting efficient implementations run time systems 
framework aspect neglected harm cf 

allows local semantic functionals affect top components data flow analysis stacks 

denotes straightforward extension semantic functional section interprocedural flow graphs theta function described 
intuition definition follows execution ordinary statement affects currently valid activation record 
modelled simply modifying top component stack representing current data flow information 
procedure call requires generation new activation record 
reflected pushing new element top stack results modifying top component stack parameter transfer 
treatment return statements demonstrates necessity introducing stacks framework 
returning procedure call essentially requires removal activation record belonging called procedure reactivation predecessor 
observation important 
effect directly recursive procedure global variable needs maintained local variables reset values call time 
need consider data flow information valid immediately entering procedure available top pop stk information valid executing body available top stk order compute data flow information valid returning called procedure 
function theta models computation 
popping top component stack replacing subsequent component top pop stk top stk reflects process completing procedure call 
structure semantic functions df stack stack denote set functions stack stack df stk stack pop stk pop stk df stk stack pop stk stk df stk stack pop stk pop pop stk lemma 
fo 
fc 
fr intuitively means semantic function ordinary statement affects top component argument stack semantic function call statement simply adds new top component argument stack return statement replaces upper components argument stack new component 
lemma easy consequence properties fo fc fr stk defined stacks components fact automatically taken care reasonable analysis context 
lemma fr fo fc ffi ffi ffi fo formal development requires derived notions monotonicity distributivity definition monotonicity distributivity function fo fc fr called ffl monotonic iff monotonic ffl distributive iff distributive significant part defined cases ffl fo fc defined df top ffl fr theta defined df top push lemma shows effort checking preconditions interprocedural safety theorem interprocedural coincidence theorem comparable effort necessary intraprocedural counterparts cf 
section 
lemma monotonic distributive monotonic distributive monotonic distributive conventions consider monotonicity distributivity generalization usual monotonicity distributivity identifying lattice elements unique representations component stacks 
extend meet operation stacks way stk stack df stk stk meet set stacks just component stack containing meet top components single component 
interprocedural meet paths solution analogously section local semantics extended cover finite interprocedural paths 
path ip define stack stack df id stack ffi intraprocedural counterpart cf 
ku interprocedural meet paths solution directly records possible program executions leading particular program point 
important interprocedural path ip stack stk stack top stk data flow information relevant node executing components stk correspond activation records valid identifying component stacks content unique component formal definition interprocedural meet paths solution solution ip note theta lattice interprocedural maximal fixed point solution addition equational characterization intraprocedural case equation system flow graph systems need preprocess determines meaning call nodes terms meaning called procedures 
requires auxiliary semantic functional gives meaning flow graphs 
essentially transforms data flow information assumed valid entry procedure contains corresponding data flow information valid execution particular meaning function th procedure 
formally full preprocess determining meaning call nodes characterized definition 
stack stack 
stack stack defined greatest solution equation system df id stack uf ffi pred fg df nn nr ffi callee ffi nc id stack denotes identity stack componentwise meet operation fo effect procedure call determined steps reflecting phases execution ffl entering called procedure nc creates new activation record transforming content top component stack semantics call node pushing stack 
usually semantics call nodes reflect parameter transfer 
ffl evaluating call callee computes effect procedure body 
note affects top component argument stack 
ffl leaving called procedure nr removes activation record related current procedure call popping top component stack replacing subsequent component data flow information representing effect procedure call relative call site 
applying lemma obtain lemma fo lemma important shows stacks occurring iterative computation solution components 
contrast strategy size stacks contributing solution general unbounded 
allows prove termination usual way 
remember idc related identity stack 
fo fo stk stack top stk top stk top stk 
usual induces inclusion relation fo iff computation starts component stack cf 
equation system algorithm 
fixing meaning call nodes plays essentially role local semantic functional section 
formally interprocedural maximal fixed point strategy characterized equation system 
intraprocedural counterpart strategy labels node pre information pre post information post top components greatest solution equation system respect equation system pre mc pre caller fg fs post pred fg post pre identifying stack having single component content component obtain intraprocedural case solution pre main results main step proof main results taken proving main lemma proof full detail ks 
lemma main lemma semantic functions 
monotonic uf cip nc nr 
distributive uf cip nc nr having established result interprocedural safety theorem interprocedural coincidence theorem proved intraprocedural case 
omit proofs 
intraprocedural case theorem states solution correct approximation solution local semantic functions monotonic theorem interprocedural safety theorem flow graph system corresponding interprocedural flow graph solution correct approximation solution semantics nodes monotonic function 
intraprocedural case distributivity semantic functions yields optimality completeness theorem interprocedural coincidence theorem flow graph system corresponding interprocedural flow graph solution solution coincide semantics nodes distributive function 
proofs ks 
note lemma allows check monotonicity distributivity semantic functions simply checking properties semantic functions reduction functions additional effort comparison intraprocedural case arises checking reduction functions 
applications section sketch applications interprocedural coincidence theorem 
omit details examples require setup 
sk propose algorithm interprocedural constant propagation constant folding generalizes improves previous techniques interprocedural constant propagation cf 
cc jm 
algorithm determines finite interprocedural constants interprocedural analogue set finite constants introduced sk 
intraprocedural case finite interprocedural constants purely operational characterization sense strategy purely denotational characterization sense strategy 
interprocedural coincidence theorem yields equivalence characterizations 
second example concerns interprocedural versions classical bit vector data flow analyses determining available expressions reaching definitions live variables busy expressions cf 
optimal elimination interprocedural partial redundancies 
cases interprocedural coincidence theorem allows prove optimality algorithms programs recursive procedures global local variables formal value parameters ks 
interprocedural generalization known intraprocedural coincidence theorem kam ullman ku covers arbitrary programs recursive procedures global local variables formal value parameters 
theorem reduces classical intraprocedural version absence procedures delivers sufficient condition coincidence interprocedural meet paths strategy interprocedural maximal fixed point strategy generalizes previous results cf 
ba ba sp deal properly local variables recursive procedures 
results formulated framework interpretation covering wide range data flow analyses 
allen control flow analysis 
sigplan 

ba barth systeme 
university kaiserslautern germany 
ba barth interprocedural data flow systems 
proceedings th gi conference dortmund germany springer verlag lncs 
application suggested giving details sharir pnueli sp 
problem heuristically dealt mo 
detailed presentation interprocedural bit vector data flow analyses ks 
bo bourdoncle interprocedural interpretation block structured languages nested procedures aliasing 
proceedings nd plilp linkoping sweden springer verlag lncs 
cc cousot cousot interpretation unified lattice model static analysis programs construction approximation fixpoints 
proceedings th popl los angeles california 
cc cousot cousot static determination dynamic properties recursive procedures 
neuhold 
ed 
proceedings nd ifip tc working conference formal description programming concepts st andrews canada 
callahan cooper kennedy torczon interprocedural constant propagation 
proceedings sigplan symp 
compiler construction sigplan 

hecht flow analysis computer programs 
elsevier north holland 
jm jones muchnick flexible approach interprocedural data flow analysis programs recursive data structures 
proceedings th popl albuquerque new mexico 
ki kildall unified approach global program optimization 
proceedings st popl boston massachusetts 
ks knoop steffen interprocedural coincidence theorem 
informatik berichte nr 
technische hochschule aachen aachen germany 
ks knoop steffen optimal interprocedural partial redundancy elimination 
proceedings th cc paderborn germany october 
technical report department computer science university paderborn germany 
ks knoop steffen efficient optimal bit vector data flow analyses uniform interprocedural framework 
appear 
ku kam ullman monotone data flow analysis frameworks 
acta informatica 
la langmaack procedures open subroutines 
part acta informatica 
mo morel data flow analysis global optimization 

ed 
methods tools compiler construction 
cambridge university press 
myers precise inter procedural data flow algorithm 
proceedings th popl williamsburg virginia 
mj muchnick jones 
eds 
program flow analysis theory applications 
prentice hall englewood cliffs new jersey 
morel renvoise interprocedural elimination partial redundancies 
mj 
ro rosen data flow analysis procedural languages 
journal acm 
sk steffen knoop finite constants characterizations new decidable set constants 
proceedings th mfcs por poland springer verlag lncs 
extended version appeared theoretical computer science 
sk steffen knoop finite interprocedural constants 
appear 
sp sharir pnueli approaches interprocedural data flow analysis 
mj 
algorithms section provides algorithms compute solution 
algorithm preprocess determines semantics call nodes algorithm computation semantic functionals input flow graph system complete semi lattice node nn monotonic function stack stack fo identity nodes fs node monotonic functions nc stack stack fc nr stack stack fr output annotation functions stored gtr stands global transformation stored ltr stands local transformation representing greatest solution equation system 
fo stack stack fo denotes universal function assumed contain function fo id stack identity stack 
variable workset controls iterative process 
elements tuples components nodes flow graph system second components functions stack stack fo specify new approximation function node component 
note due mutual interdependence definitions iterative approximation superposed interprocedural iteration step updates semantics call nodes 
initialization annotation arrays gtr ltr variable workset forall gtr fo ltr ffi fo ffi mc ltr fi od workset id stack fs ltr ffi gtr pred fg fo iterative fixed point computation workset workset workset gtr gtr gtr gtr fe forall caller fg ltr ltr ffi gtr ffi workset workset ltr ffi gtr succ fg od workset workset ltr ffi gtr succ fg fi fi od order simplify formulation central property algorithm abbreviate values ltr gtr th execution loop ltr gtr respectively 
theorem proved straightforward fashion cf 
ki theorem particular gtr ltr termination algorithm 
second algorithm computes solution algorithm computation solution input flow graph system semantic functional node function nc start information output annotation data flow informations annotation stored pre post informations stored post component stacks characterize valid data flow information entry exit node 

denotes universal data flow information assumed contain data flow information 
variable workset controls iterative process 
elements tuples components nodes flow graph system second components elements stack specifying new approximation pre information node component 
initialization annotation arrays pre post variable workset forall pre post od workset stk stk post pred fg 
stk fs stk mc pre caller fg 
iterative fixed point computation workset stk workset workset stk pre pre stk pre pre stk post pre workset workset post succ fg workset workset start callee mc pre fi fi od start information abbreviate values pre post th execution loop pre post 
analogy theorem theorem particular pre termination algorithm 
