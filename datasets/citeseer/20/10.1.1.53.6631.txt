analysis benchmark characteristics benchmark performance prediction usc cs rafael saavedra alan smith department computer science university southern california los angeles ca saavedra usc edu computer science division university california berkeley ca september analysis benchmark characteristics benchmark performance prediction rafael saavedra alan jay smith standard benchmarking provides run times programs machines fails provide insight results obtained terms machine program characteristics fails provide run times program machine programs machine 
developed machineindependent model program execution characterize machine performance program execution 
merging machine program characterizations estimate execution time arbitrary machine program combinations 
technique allows identify operations machine programs dominate benchmark results 
information helps designers improving performance machines users tuning applications better utilize performance existing machines 
apply methodology characterize benchmarks predict execution times 
extensive run time statistics large set benchmarks including spec perfect club suites 
show statistics identify important shortcomings programs 
addition give execution time estimates large sample programs machines compare benchmark results 
develop metric program similarity possible classify benchmarks respect large set characteristics 
material research supported principally nasa ncc part national science foundation mip mip ccr state california micro program international business machines philips laboratories apple computer intel mitsubishi electric sun microsystems digital equipment 
available computer science technical report usc cs university southern california computer science technical report ucb csd uc berkeley 
computer science department henry computer science center university southern california los angeles california mail saavedra usc edu 
computer science division eecs department university california berkeley california 

benchmarking process running specific program workload specific machine system measuring resulting performance 
technique clearly provides accurate evaluation performance machine workload 
benchmarks complete applications ucb dong mips executed parts program kernels bail synthetic programs 
unfortunately benchmarking fails provide insight results obtained terms machine program characteristics fails provide run times program machine program machine dong 
benchmarking fails characterize program machine 
show limitations overcome help performance model concept high level machine 
machine model consists set operations representing particular programming language basic operators language constructs programs 
special benchmark called machine characterizer measure experimentally time takes execute operation 
frequency counts obtained instrumenting running benchmarks 
machine program characterizations combined obtain execution time predictions 
results show predict accuracy execution time arbitrary programs large spectrum machines demonstrating validity model 
result methodology able individually evaluate machine benchmark explain results individual benchmarking experiments 
describe machine doesn exist predict accuracy performance workload 
previous discussed methodology gave depth presentation machine characterization saav 
focus program characterization execution time prediction note overlaps saav small extent regard discussion necessary background methodology 
explain programs characterized extensive statistics large set programs including perfect club spec benchmarks 
discuss benchmarks measure evaluate effectiveness cases results surprising 
dynamic statistics benchmarks define metric similarity programs similar programs exhibit similar relative performance machines 
structure follows 
section overview methodology explain main concepts discuss program analysis execution time prediction 
proceed section describing set benchmarks study 
section deals execution time prediction 
predictions large set machine program combinations compare real execution times 
section extensive analysis benchmarks 
concept program similarity section 
section ends summary 
presentation self contained assume familiarity previous 

model system description section overview model briefly describe components system 
machine characterizer described detail saav principally concerned execution predictor program analyzer 

machine model model fortran language equally applies algorithmic languages 
fortran chosen relatively simple majority standard benchmarks written fortran principal agency funding nasa interested language 
consider computer fortran machine run time program linear sum execution times fortran abstraction operations executed 
total execution time program machine just linear combination number times operation executed depends program multiplied time takes execute operation depends machine represent machine performance vector program characterization vector respectively 
equation decomposes naturally components machine characterizer program analyzer execution predictor 
machine characterizer runs experiments obtain vector dynamic statistics program represented vector obtained program analyzer 
vectors execution predictor computes total execution time program machine assume rest programs written fortran compiled optimization turn executed scalar mode 
statistics reflect assumptions 
saav show model extended successfully include effects compiler optimization cache misses 

linear models noted execution prediction linear sum execution times executed equation shows linear model 
linear models past fit parametric model set benchmark results approach entirely different curve fitting 
parameter values result direct measurement inferred solution fitted model 
specific point aspect methodology misunderstood past 

machine characterizer machine characterizer program uses narrow spectrum benchmarking measure execution time operation 
cases timing loop interest change run time due operation 
easily isolated complicated methods 
operations model saav benchmark set expanded time additional needed 
number type operations directly related kind language constructs fortran 
associated arithmetic operations trigonometric functions 
addition parameters procedure call array index calculation logical operations branches loops 
appendix tables set parameters small description operation measures 
note obtaining accurate measurements tricky operations take nanoseconds clocks machines run hertz 
get accurate measurements run loops large numbers times repeat loop measurement times 
residual errors due clock resolution external events interrupts multiprogramming activity variations hit ratio cache paging 
issues discussed detail saav 

program analyzer analysis programs consists phases static analysis dynamic analysis 
static phase count number occurrences line source code 
dynamic phase instrument source code give counts number executions line source code compile run instrumented version 
instrumented version tends run slower uninstrumented version 
program input data number basic blocks program 

designate number static occurrences operation block matrix size represents complete static statistics program 

number times basic block executed matrix gives dynamic statistics basic block 
vector matrix related equation 
obtaining dynamic statistics way possible compute execution time predictions basic blocks program 
methodology described permits measure machines programs compute run time predictions combinations 
note methodology apply cases 
execution history program precision dependent case numerical analysis programs number vary machine machine 
second number may vary execution history real time dependent machine characterizer example real time dependent program number times loop executed function machine speed clock resolution 
programs consider execution histories precision time independent original version track perfect club benchmarks exhibited execution histories due inconsistency passing constant parameters 
version problem 

execution prediction execution predictor program computes expected execution time program machine corresponding program machine characterizations 
addition produce detailed information execution time sets basic blocks individual operations contribute total time 
program statistics trfd benchmark ibm rs lines processed operation times executed fraction execution time fraction add exec time store exec time add exec time mult exec time divide exec time trans exec time store exec time add exec time mult exec time divide exec time exp exec time trans exec time store exec time add exec time mult exec time trans exec time andl exec time sin exec time dou exec time dou exec time proc proc exec time exec time arr exec time arr exec time ini exec time lop exec time ini exec time lop exec time predicted execution time secs execution time estimate trfd benchmark program run ibm rs 
shows sample output produced execution predictor 
line gives number times particular executed fraction total represents 
expected execution time contributed fraction total 
line reports expected execution time program 
statistics execution predictor provide information factors contribute execution time level operations individual basic blocks 
example shows time spent computing address dimensional array element arr 
operation represents operations program column 
comparing execution predictor outputs different machines program see kind imbalance machines execution time larger expected saav 

related papers proposed different approaches execution time prediction significant differences degrees accuracy applicability 
attempts ranged simple markov chain models rama complex approaches involve solving set recursive performance equations hick 
mention proposals somewhat related concept machine model static dynamic program statistics 
way compare machines analysis similar level machine instruction set peut 
approach permits comparisons machines implement instruction set 
context project alle execution time prediction proposed technique help automatic partitioning parallel programs tasks 
execution profiles obtained indirectly collecting statistics loops possible unstructured program combining analysis control dependence graph 
bala prototype static performance estimator parallel compiler guide data partitioning decisions 
performance estimates computed machine measurements obtained set routines called training set 
training set similar machine characterizer 
addition basic cpu measurements training set contains tests measure performance communication primitives loosely synchronous distributed memory machine 
compiler static analysis program combines information data produced training set 
prototype performance estimator implemented interactive parallel programming environment bala 
contrast execution time predictions compiler incorporate dynamic program information user supply lower upper bounds symbolic variables loops branching probabilities statements default probabilities provided compiler 

benchmark programs study assembled analyzed large number scientific programs written fortran representing different application domains 
programs classified groups spec benchmarks perfect club benchmarks small generic benchmarks 
table gives short description program 
list perfect benchmarks omitted program spice included spec benchmarks spice 
benchmark spice input data set 
case spice perfect club spec versions different data sets characterized executions include relevant examples 
spec benchmarks doduc double monte carlo simulation nuclear reactor component fpppp bytes computation electron integral tomcatv bytes mesh generation thompson solver matrix bytes matrix operations linpack routines nasa double collection kernels typical nasa ames applications 
spice double analog circuit simulation analysis program benchmark double mos amplifier schmitt circuit tunnel diode double ttl edge triggered register double cmos digital shift register double grey code counter double mos amplifier transient phase perfect double pla circuit toronto double differential comparator perfect club benchmarks adm single air pollution simulation arc double dimensional fluid solver euler equations flo single transonic inviscid flow past airfoil ocean single dimension ocean simulation spec single weather simulation bdna double molecular dynamic package simulation nucleic acids mdg double molecular dynamics simulation liquid water qcd single quantum trfd double simulating electron integral transformation dyfesm single structural dynamics benchmark finite element mg single depth migration code track double missile tracking various applications synthetic benchmarks alamos single set loops measure execution rates basic vector operations baskett single backtrack algorithm solve conway baskett puzzle single uses sieve algorithm obtain primes linpack single standard benchmark solves systems linear equations dong livermore bytes livermore loops mandelbrot single computes mapping grid shell single sort numbers shell algorithm smith bytes loops measure different aspects machine performance single synthetic benchmark algol statistics table description spec perfect club small benchmarks 
program spice include different models 
second column indicates floating point declarations absolute relative precision 
programs absolute declarations include number bytes 

floating point precision fortran precision floating point variable specified absolutely number bytes real relatively words single double 
interpretation terms compiler machine dependent benchmarks consider see table relative declarations means measurements taken cray machines see table directly comparable taken machines 
chose modify source code avoid problem 

spec benchmark suite systems performance evaluation cooperative spec formed machine manufacturers available believable industry standard benchmark results 
main efforts spec areas selecting set non trivial applications benchmarks formulating rules execution benchmarks making public performance results obtained spec suite 
spec suite consists fortran programs taken scientific systems domains spec spec 
second set spec benchmarks available consider 
benchmark ratio execution time machine measured vax 
performance measure defined geometric mean 
study mention spec benchmarks refer fortran programs suite plus additional input models spice 
give brief explanation programs doduc monte carlo simulation time evolution nuclear reactor component 
little vectorizable code abundance short branches loops 
fpppp quantum chemistry benchmark measures performance style computation electron integral derivative occurs gaussian series programs 
tomcatv small lines highly vectorizable mesh generation program 
double precision floating point benchmark 
matrix code performs various matrix multiplications including transposes linpack routines saxpy matrices order 
percent execution single basic block inside saxpy 
nasa collection kernels representing kind algorithms fluid flow problems nasa ames research center 
kernels highly vectorizable 
spice general purpose circuit simulation program nonlinear dc nonlinear transient linear ac analysis 
program popular cad tool widely industry 
models programs benchmark perfect toronto 
perfect examples included spec perfect club benchmarks 

perfect club suite perfect club benchmark suite set thirteen scientific programs intended represent supercomputer scientific workloads 
performance perfect club approach defined harmonic mean mflops millions floating point operations second rate program machine 
number flops program determined number floating point instructions executed cray mp cray mp performance monitor 
perfect programs classified different groups depending type problem solved fluid flow chemical physical engineering design signal processing 
programs fluid flow group adm arc flo ocean spec 
adm simulates concentration deposition patterns environments solving complete system hydrodynamic equations 
arc implicit finite difference code analyzing dimensional fluid flow problems solving euler equations 
flo performs analysis transonic inviscid flow past airfoil solving unsteady euler equations dimensional domain 
multigrid strategy code 
ocean dimensional ocean simulation 
spec provides global spectral model simulate atmospheric flow 
weather simulation codes normally consists modules preprocessing computing normal mode coefficients forecasting postprocessing 
spec includes forecasting part 
programs chemical physical group bdna mdg qcd trfd 
bdna molecular dynamics package simulations hydration structure dynamics nucleic acids 
algorithms solving translational rotational equations motion 
input benchmark simulation hydration structure potassium counter ions water molecules dna 
mdg molecular dynamic simulation water molecules 
intra interactions considered 
newtonian equations motion solved sixth order predictor corrector method 
qcd original developed caltech mark hypercube represents gauge theory simulation strong interactions binds turn constituents nuclear matter 
trfd represents kernel simulates computational aspects electron integral transformation 
integral transformation formulated series matrix multiplications program 
size matrices kept completely main memory 
engineering design programs dyfesm spice described spec benchmarks 
dyfesm finite element structural dynamics code 
signal processing programs mg track 
md seismic migration code investigate geological structure earth 
signals different frequencies measured earth surface extrapolated backwards time get dimensional image structure surface 
track determine course set unknown number targets rocket observations targets taken sensors regular time intervals 
algorithms estimate position velocity acceleration components 

small programs synthetic benchmarks group programs consists small applications popular synthetic benchmarks 
small applications baskett mandelbrot shell 
synthetic benchmarks alamos linpack livermore smith 
description programs saav 

predicting execution times execution predictor obtain estimates programs table machines shown table 
results 
addition tables appendix report actual execution time predicted execution error pred real real percent 
minus plus sign error corresponds prediction smaller greater real time 
show arithmetic mean root mean square errors machines programs 
results appendix see average error programs root mean square 
subset programs execute correctly machines time research problems may corrected time 
table characteristics machines machine name location operating compiler memory integer real system version single single double cray mp reynolds nas nasa gov cft mw cray navier nas nasa com cft mw cray mp nasa ames cos cft mw nex sx edu vm cms fort sx mw convex convex riacs edu unix fc mb ibm berkeley edu vm cms fortran mb ibm rs coyote berkeley edu aix xl fortran mb ibm rt pc loki berkeley edu acis mb mips berkeley edu risc os mb mips berkeley edu bsd mb decstation berkeley edu ultrix mb sparcstation genesis berkeley edu sunos mb sun venus berkeley edu unix mb sun berkeley edu unix mb vax berkeley edu unix bsd mb vax atlas berkeley edu ultrix mb vax pioneer arc nasa gov ultrix mb vax wilbur arc nasa gov unix bsd mb motorola berkeley edu unix mb amdahl nas nasa gov uts mb table characteristics machines 
size data type implementations number bits 
reasons internal compiler errors run time errors invalid results 
livermore loops example program executed machines ibm rs gave run time error 
careful analysis program reveals compiler generating incorrect code 
programs perfect suite problems mainly shortcomings programs 
example track gave invalid results workstations fixing bug involving passing parameter mg needed mb disk space temporary file workstations spec gave internal compiler error machines mips processors motorola program terminated 
results show accurate predictions general reproduce apparent anomalies fact cray mp faster ibm rs qcd slower mdg 
note relative declarations precision cray computing results twice precision rs 
performance double precision floating point arithmetic times slower single precision emulated software 
conversely workstations arithmetic double bit precision 
observed difference relative performance qcd mdg easily explained looking respective dynamic statistics 
qcd executes single precision mdg double precision benchmark 
table summarize accuracy run time predictions 
results show predictions fall real execution times 
predictions error 
results represent program machine combinations encompassing machines programs 
results consider characterization machines programs done high level model 
real execution time sec sec real execution time real execution time sec real execution time sec sec real execution time decstation decstation vax sun sun dod tom fpp mat nas spi qcd dod fpp tom adm trf mat flo oce mdg spi arc nas era bas man lin liv tra smi ala dod qcd fpp tom adm trf flo mat oce spe nas spi mdg tra qcd dod fpp adm tom mat flo trf spi mdg arc nas oce era bas man lin liv ala smi real execution time sec real execution time sec sec real execution time real execution time sec sec real execution time real execution time sec sec real execution time ibm rs mips motorola sparcstation cray mp cray mp ibm era bas lin smi ala fpp man qcd dod adm tom spi nas mdg oce spe mat flo trf qcd adm tra flo spe oce trf mg arc mdg era bas man lin liv ala smi era man bas lin smi ala era man lin liv ala qcd smi dod fpp adm tom trf mdg nas arc spi bas era bas man lin liv ala smi qcd dod fpp trf tom mat flo oce mdg arc era bas man lin liv smi ala dod fpp tom mat spi nas comparison real predicted execution times 
predictions computed program dynamic distributions machine characterizations 
vertical distance diagonal represents predicted error 
table error distribution execution time predictions table error distribution predicted execution times 
error interval indicate number programs total having errors fall inside interval percentages inside parenthesis 
error computed relative distance real execution time 
maximum discrepancy predictions occurs matrix average error root mean square error 
predictions program consistently underestimate execution time machines program number cache tlb misses significant model consider factor 
saav extend model include effects locality show programs high ratios run time predictions improve significantly 
benchmarks spec perfect suite tend low cache tlb ratios prediction errors problem matrix 

single number performance may misleading frequently necessary desirable describe performance machine single number 
table actual predicted geometric means normalized execution times percentage error 
clearly see results estimates accurate cases difference 
cases available show numbers note results unoptimized code spec figures best optimized results 
cray mp ibm amdahl convex ibm rs sparcstation motorola actual mean prediction difference mips dec vax vax vax sun average actual mean prediction difference table real predicted geometric means normalized benchmark results 
execution times normalized respect vax 
machines show published spec ratios 
reason numbers higher real predicted geometric means contrast measurements spec results optimized codes 

program characterization reasons important know way benchmark uses machine operations benchmark performs frequently 
information allows understand extent benchmark may considered representative shows program may tuned indicates goodness fit program machine 
methodology information provided dynamic statistics program 

normalized dynamic distributions complete normalized dynamic statistics benchmarks including data sets spice tables appendix program give fraction respect total operation executed 
executed frequently indicated entry 
identify executed operations program number smaller point size left corresponding entry 
detailed counts voluminous provide easy grasp results figures summarize results numbers graphs tables appendix 
basic block statement statistics shows distribution statements classified assignments procedure calls statements branches loop iterations see tables appendix similar figures cluster benchmarks similarity distributions 
cluster benchmark belongs indicated roman numeral top bar 
results show programs perfect suite distributions differ significantly benchmarks suite 
particular programs qcd mdg bdna execute unusually large fraction procedure calls 
similar observation case statements programs qcd mdg track 
track executes unusually large number branches 
spec perfect suites similar distributions 
spice model doduc programs execute large fraction statements branches 
statements branches doduc large number statements 
distribution statements provides additional data 
distributions programs fpppp bdna similar sense show large fraction assignments small fraction loops 
consistent observation important basic block fpppp contains assignments 
table give average distributions statements spec perfect club small benchmarks 
indicate average programs 
numbers correspond average dynamic distributions shown 
worth observing data perfect club methodology counts flops benchmarks dominated floating point operations 
rest term program refers code particular set data 
source code different input data considered different program 
alamos livermore mandelbrot smith toronto benchmark matrix fpppp assignments procedure calls statements branches loops assignments procedure calls statements branches loops ii ii vi iii iii real single integer complex real double qcd track ocean mg flo spec programs iii iii iii iii viii ii iv iii iii ix ii iv iii iii ii distribution statements distribution operations figures distribution statement types distribution arithmetic logical operations data type precision 
bar loops represents computational kernels benchmark livermore ignoring rest computation 
bar labeled roman numeral identifying benchmarks similar distributions 
give average distributions suite programs 
models spice perfect considered computation averages 
distribution statements average spec perfect various progs assignments procedure calls statements branches loops table average dynamic distributions statements suites benchmarks 

arithmetic logical operations figures depict distribution operations type compute see tables appendix 
clear graphs program operations data types dominant 
respect perfect benchmarks classified way adm dyfesm flo spec execute mainly floating point single precision operators mdg bdna arc trfd floating point double precision operators qcd mg floating point single precision integer operators track floating point double precision integer ocean integer complex operators 
results suggest inadequacy counting flops performance measure 
similar classification obtained spec benchmarks 
respect distribution arithmetic operators shows largest fraction correspond addition subtraction followed multiplication 
operations division exponentiation comparison relatively infrequent 
distribution operations average spec perfect various progs real single real double integer complex logical distribution arithmetic operators average spec perfect various progs add subtract multiply quotient exponentiation comparison table average dynamic distributions arithmetic logical operations suites benchmarks 
qcd track ocean mg flo spec baskett linpack loops shell average average programs qcd track ocean mg flo spec baskett linpack loops shell average average programs ii ii iv iii ii vii iv 
array scalar variables run time affected need compute addresses array data extra time needed scalar data 
frequencies scalar dimensional arrays shown 
see perfect benchmarks proportion array larger scalar 
perfect benchmark highest fraction scalar operands bdna spec benchmarks doduc fpppp models spice lean scalar processing 
distribution number dimensions shows programs large portion dimensional arrays smaller fraction case dimensions 
programs adm arc flo contain large number arrays dimensions 
nasa program contains dimensional array 
compilers compute array addresses calculating indices offset relative base element base element may member array 

dimensional array address addr addr 
addr 
offset 
offset 
elem 


represents set dimensions elem number bytes element 
compilers equation optimization disabled requires adds multiplies 
scientific programs array address computation significant fraction total execution time 
example benchmark matrix account machines unoptimized execution time 
optimization array address computations strength reduced simple additions see saav handle case 
results show average number dimensions array perfect spec benchmarks respectively 
probability operand array greater perfect benchmarks vs 
distribution operands average spec perfect various progs scalar array array array array table average dynamic distributions operands arithmetic expressions suites benchmarks 
baskett linpack loops shell qcd track ocean mg flo spec toronto benchmark matrix fpppp average average average average floating point integer operations array access viii viii iii vii iii vii iii iii iii distribution execution time cray mp vii vii figures distribution execution time ibm rs cray mp 

execution time distribution interesting measurements fraction run time consumed various types operations function program machine 
examples figures show distribution execution time ibm rs cray mp 
decompose execution time classes floating point arithmetic array access computation integer logical arithmetic operations 
distributions obtained execution model dynamic statistics programs machine characterizations 
previous assertion scientific programs floating point computation evident figures 
example programs qcd ocean dyfesm spend time executing operations floating point arithmetic array address computation 
evident 
total time rs spent doing floating point arithmetic 
numerical values benchmark suite table 
distribution execution time ibm rs average spec perfect various progs floating point array access integer operations distribution execution time cray mp average spec perfect various progs floating point array access integer operations table average dynamic distributions execution time suites benchmarks ibm rs cray mp 
figures evident time distributions rs cray mp different programs executed scalar mode machines 
average fraction time cray mp spends executing floating point operations significantly rs 
results surprising cray mp designed high performance floating point 
noted benchmarks double precision cray bits double precision cray times slower bit single precision 
effect seen clearly programs doduc spice mdg track bdna arc trfd 
program statistics easily compute performance programs execute bit quantities machines 
case compute fraction time represented floating point operations cray mp decreases higher rs 
note example power methodology able compute performance doesn exist 
results show large fraction time spent ibm rs array address computation 
example program flo extensive dimensional arrays 
contrast distributions mandelbrot clearly show scalar codes completely dominated floating point computation 
remember statistics correspond unoptimized programs 
optimization fraction time spent computing array smaller optimizers cases replace array address computations simple add precomputing offset consecutive element array 
corresponds applying strength reduction backward code motion 
decstation motorola mips sparcstation decstation vax vax cray mp nec sx cray amdahl vax ibm rs hp floating point array access integer operations average time distributions 
distributions computed programs 
models spice perfect considered computation averages 
show average time distribution machines 
case supercomputers cray mp nec sx cray single double precision correspond bits 
results show vax hp rs machines processors floatingpoint contribution 
contribution address array computation varies cray mp decstation decstation mips 
contribution integer operations exhibit variation ranging 
adm mdg bdna dyfesm arc trfd toronto benchmark matrix fpppp shell loops linpack baskett average average average programs ii iii iii ii iii iv iii ii ii ii adm mdg bdna dyfesm arc trfd toronto benchmark matrix fpppp average ii ii iv iv ii ii iii ii ii iii iii ii ii iii iv distribution basic blocks noted compute running time machine didn exist cray double precision bits 
simple example extremely powerful application evaluation methodology 
define arbitrary synthetic machine machine setting values desire determine performance machine workload 
example estimate effect fast floating point slow loads stores 

dynamic distribution basic blocks shows fraction basic block executions accounted frequently executed basic blocks 
basic block segment code executed sequentially entry exit point 
implicit assumption benchmark users large program long execution time represents difficult interesting benchmark 
argument criticize synthetic kernel benchmarks motivations real applications perfect spec suites 
results show programs perfect spec suites simple execution patterns small number basic blocks determine total execution time 
perfect benchmark results show programs bdna trfd important blocks account operations total blocks respectively 
perfect benchmarks operations blocks 
observation spec benchmarks 
fact matrix basic block containing single statement amounts operations executed 
average blocks account total time perfect spec benchmarks 
distribution basic blocks average spec perfect various progs blocks blocks blocks blocks blocks blocks table portion basic block executions accounted frequent th frequent suites benchmarks 

quantifying benchmark instability skewness large fraction execution time benchmark accounted small amount code relative running time benchmark may vary widely machines depending execution time relevant machine benchmark results may unstable 
describe extent execution time concentrated small number basic blocks degree skewness benchmark 
statistical coefficient skewness concept 
define skewness metric basic blocks frequency th frequently executed basic block 
program skewness program skewness matrix nasa mandelbrot mdg linpack smith bdna qcd tomcatv livermore baskett mg spice trfd flo shell arc dyfesm track spec fpppp adm ocean doduc alamos table skewness ordered basic block distribution spec perfect small benchmarks 
skewness defined inverse mean distribution 
table gives amount skewness basic blocks programs 
results show matrix mandelbrot linpack ones largest skewness 

optimization matrix reasons detect unstable highly skewed programs optimization efforts may easily concentrated relevant code 
focussed optimization efforts may program unsuitable benchmarking purposes 
benchmark matrix clear example situation amount skewness high spec results program put question effectiveness benchmark 
example spec cdc machine mips microprocessor matrix reported spec jumped 
similar situation exists new hp series 
hp matrix reported times larger second largest spec 
furthermore matrix ignored computation performance machine decreases 
reason dramatic performance improvements machines pre processor inline levels routines way expose matrix multiply algorithm core computation matrix 
pre processor replaces algorithm library function call implements matrix multiply blocking tiling algorithm 
blocking algorithm algorithm performed sub blocks matrices smaller cache significantly reducing number cache tlb misses 
matrix uses matrices size larger current cache sizes 
non blocking matrix multiply algorithms generate misses order matrices larger data cache size blocking algorithm generates misses 

effective benchmarks 
aspects consider evaluating effectiveness cpu benchmark 
program exercises various functional units pipeline refers program behaves respect memory system 
program executes different sequences instructions may test pipeline functional units necessarily memory system 
livermore loops example 
consists small kernels 
kernel executed times order obtain meaningful observation 
kernel touch floating point numbers data sits comfortably caches 
iteration memory system tested 
furthermore kernels consist instructions fit small instruction caches 
spec results ibm rs clearly show performance affected demands benchmark memory system 
example benchmark matrix dominated single statement ibm fortran compiler optimize decomposing single multiply add instruction 
ibm rs program lower 
contrast program tomcatv times larger principal basic blocks complex matrix 
main difference main basic blocks programs number memory requests floatingpoint operation executed 
matrix average read floatingpoint operation little re registers machine memory speed limited benchmark 
studies spec benchmarks show programs low ratios cache configurations normal existing workstations 
effect memory system run times considered saav 
distribution parameters average spec perfect various progs params params params params params params table portion executions accounted frequent frequent suites benchmarks 

distribution shows cumulative distribution operations different benchmark suites 
bar indicates bottom number different operations executed benchmark 
results show programs execute small number different operations matrix extreme example 
averages suites programs table 
compute skewness ordered distribution way basic blocks inverse expected value distribution results shown table 
programs largest values skewness matrix alamos 
results show doduc spec benchmark lowest amount skewness distribution basic blocks 
program skewness program skewness matrix smith alamos bdna spice shell flo tomcatv ocean trfd spec fpppp livermore linpack adm dyfesm qcd arc track mandelbrot nasa baskett mdg doduc mg table skewness ordered operation distribution spec perfect small benchmarks 
skewness defined inverse mean distribution 

characterizing ordered distribution operations argued average program distribution executed operations blocks geometric knut 
means executed operation program accounts fraction total second residual 

cumulative distribution approximated represents th executed operations constants 
th residual cumulative distribution point minus th residual 
show fitted actual average distributions suite programs may seen geometric distribution fit 
clearly shows average operations account operations operations 
programs consist small number different operations executed times 
operations benchmarks 

spice benchmark section discuss detail differences data sets spice benchmark 
spice normally considered performance purposes example large cpu bound scalar double precision floating point benchmark small fraction complex arithmetic negligible vectorization 
large size code data sizes vax running ultrix kbytes mbytes respectively expected test instruction data caches 
spec suite uses input time consuming bipolar circuit model called perfect club uses pla circuit called perfect 
spec perfect small measured fitted measured fitted fitted measured measured fitted number parameters number parameters number parameters number parameters programs programs programs programs df df df df fitted actual cumulative distributions function important operations executed benchmark 
equation fit actual distributions 
addition graph indicates values coefficient correlation number degrees freedom 
coefficients correlation significant level 
selected mainly long execution time shall see execution behavior typical measure spice believed measure 
table see appendix gives general statistics data models spice 
results show number operations executed orders magnitude larger maximum models 
basic blocks executed 
contrast number basic blocks touched benchmark 
abnormal feature lowest fraction assignments executed arithmetic expressions rest represent simple memory memory operations 
models assignments amount average statements arithmetic expressions total 
distinctive feature small fraction procedure calls large number branches executes 
significant results 
distribution arithmetic logical operations shows mainly integer benchmark operations involve addition comparison integers 
models percentage floating point operations reaches 
reason executes integer operations basic blocks basic block 
eq 
go go similar integer basic blocks account operations 
data structures spice designed handle large circuits execution time spent traversing 
contrast case benchmark perfect executed blocks account operations consist floating point operations 
integer blocks represent execution time vax cray 
statistics suggest adequate benchmark testing scalar double precision arithmetic 
better input models spice benchmark perfect 

measuring similarity benchmarks benchmark suite representative real workload little point filling benchmark suite programs provide similar loads machine 
section address problem measuring benchmark similarity presenting different metrics program similarity comparing 
dynamic statistics earlier 
rationale metric expect programs execute similar operations tend produce similar runtime results 
metric works benchmarks yield proportional performance variety machines considered similar 
results show metrics highly correlated similar measure generally similar 
note metric easier compute measure benchmark run machine preferred 

program similarity metric dynamic statistics simplify benchmark characterization clustering grouped reduced parameters represents aspect machine implementation parameters listed table 
note reduced parameters saav ones better represent various aspects machine architecture 
expect language fortran parameters correspond floating point operations 
integer arithmetic logical arithmetic procedure calls memory bandwidth intrinsic functions 
integer floating point division assigned single parameter 
change flow execution branches loop instructions assigned single parameter 
reduced parameters memory bandwidth division integer addition logical operations integer multiplication intrinsic functions single precision addition procedure calls single precision multiplication address computation double precision addition branches iteration double precision multiplication table thirteen reduced parameters definition program similarity 
parameter represents subset basic operations value obtained adding contributions dynamic distribution 
integer floating point division merged single parameter 
formula metric program similarity squared euclidean distance dimension weighted average run time accounted parameter averaged set programs 


vectors containing reduced statistics programs distance programs value parameter averaged machines 
computed similarity distance program pairs see table appendix pairs largest smallest differences 
included programs perfect input data sets spice 
average distance programs standard deviation 
shows clustering programs distances 
pairs programs having distance joined bidirectional arrow 
thickness arrow related magnitude distance 
similar programs trfd matrix distance 
distances find pairwise relations programs dyfesm linpack alamos 
programs trfd matrix dyfesm linpack similarities go dynamic distributions 
programs property executed basic blocks syntactic variations code saxpy consists adding vector product constant vector shown statement note ibm rs special instruction speed execution types statements 
machine multiply add instruction takes arguments performs multiply adds product third argument leaves result fourth argument 
eliminating normalization round operations multiply add execution time operation significantly reduced compared multiply followed add 
clusters 
programs containing linpack member includes programs dominated single precision floating point arithmetic 
cluster having programs contains benchmarks dominated double precision floating point arithmetic 
subset programs cluster containing programs trfd matrix nasa arc tomcatv form node complete subgraph 
distances pairs elements smaller 
smallest cluster elements contains programs significant integer floating point arithmetic 
include diagram programs smallest distance program larger 
represented isolated nodes value smallest distance indicated name 
linpack alamos adm dyfesm qcd mg matrix nasa arc bdna trfd mdg track perfect shell smith fpppp mandelbrot ocean baskett tomcatv flo spec doduc livermore principal clusters perfect spec small benchmarks 
distance represented thickness arrow 
programs smallest distance program greater show name magnitude smallest distance 

minimizing benchmark set purpose suite benchmarks represent target workload 
constraint minimize number actual benchmarks 
results far show individual benchmarks highly skewed respect generation operations clusters shown suggest subsets suites test essentially aspects performance 
acceptable variety benchmark measurements obtained subset programs analyzed earlier 
better approach run benchmark machine characterizer 
note machine characterizer measures run time possible accurately estimate performance characterized machine distribution having run benchmarks 
distribution chosen weighted sum set existing benchmarks estimate target existing workload manner 

amount skewness programs distribution errors earlier discussed sections noted benchmarks concentrate execution small number 
expect predictions running time benchmarks highly skewed distributions execution show greater errors skewed distributions 
follows directly assumption errors measuring times random cancellation errors summing small number large values larger number small values 
explained rigorously considering formula variance sum random variables 
tested hypothesis prediction errors programs skewed distribution basic blocks operations tend larger skewed distributions 
distributions shown appendix 
examination shows correlation prediction error skewness frequency basic block execution 
small amount correlation skewness execution distribution prediction error 
lack correlation due factors programs highly skewed distributions emphasize floating point measurement errors small 
prediction errors due factors cache misses errors measurement execution times 

program similarity benchmark results motivation proposing metric program similarity identify groups programs having similar characteristics similar programs show proportional run times number different machines 
section examine hypothesis 
introduce concept benchmark equivalence 
definition execution time program machine programs benchmark equivalent pair machines condition true execution times obtained program differ execution times program machines multiplicative factor machine 
different programs exactly satisfy definition benchmark equivalence 
define weaker concept execution time similarity measure far programs full equivalence 
sets benchmark results define execution time similarity benchmarks computing coefficient variation variable coefficient variation measures execution times program inferred execution times program 
linpack alamos adm dyfesm qcd mg matrix nasa arc bdna trfd mdg track perfect shell smith fpppp mandelbrot ocean baskett tomcatv flo doduc livermore spec principal clusters perfect spec small benchmarks run time similarity metric 
distance represented thickness arrow 
programs benchmark equivalent zero coefficient variation 
table appendix similar programs coefficient variation metric computed execution times see appendix 
show clustering diagram similar 
diagram shows defined clusters 
contains basically integer programs shell baskett smith 
cluster formed matrix alamos livermore linpack 
largest cluster centered programs tomcatv adm doduc flo nasa programs connected clusters unstructured way 
defined different metrics benchmark similarity program characteristics see execution time results compare metrics see exists correlation way rank pairs programs 
measure level significance spearman rank correlation coefficient defined difference ranking particular pair metrics 
similarity metrics coefficient indicates correlation level significance better 
metrics point 
horizontal axis corresponds metric dispersion execution time results vertical axis correspond metric dynamic program statistics 
graph represents pair benchmark programs 
results indicate significant positive correlation metrics level 
visually see metrics correlate reasonable 
means benchmarks differ widely frequently chances give inconsistent performance comparisons pairs machines relative benchmarks conversely 
benchmarks quite different benchmark may rate machine faster benchmark may rate faster suggests measure program similarity sufficiently valid eliminate redundant benchmarks large set 

limitations model limitations linear high level model software experiments characterize machine performance 
briefly mention important 
depth discussion see saav 
main sources error results model grouped classes 
corresponds elements machine architecture captured model 
model described account cache tlb misses extension model saav adds factor 
computing rank correlation coefficient set program pairs metrics 
number pairs benchmark results compute coefficient variation half total number pairs 
coefficient variability program similarity metrics program similarity metrics 
horizontal axis corresponds metric computed benchmark execution times vertical axis computed dynamic program statistics 
results exhibit significant positive correlation 
successfully capture aspects machine architecture manifested performance certain sequences single isolation ibm rs multiply add instruction discuss 
able account hardware software interlocks non linear interactions consecutive machine instructions effectiveness branch prediction lee effect timing branch distance direction 
accounted specialized architectural features vector operations vector registers 
source errors corresponds limitations measuring tools factors independent programs measured resolution intrusiveness clock random noise external events interrupts page faults multiprogramming curr 
important mention model results reflect unoptimized code 
shown saav model extended surprising success prediction running times optimized codes 
worth making specific mention trends high performance microprocessor computer architecture 
newest machines ibm rs issue instruction cycle machines called superscalar vliw long instruction word depending design 
observed level performance machines function actual amount concurrency achieved 
level concurrency function operations available executed parallel operations conflict operands functional units 
model considers operations individually currently able determine achieved level concurrency 
concurrency manifested execution machine characterizer machine concurrency measure faster times 
average able predict level speedup 
unfortunately accuracy average need apply predictions running times individual programs 
fact observed case ibm rs 
machine standard deviation errors percent largest machines 
furthermore results rs gives maximum positive negative errors 
note errors larger machines predictions quite accurate 
new technique doesn introduce new difficulties 
specific type pipelining individual functional units pipelined example multiply execution time 
introduces problems ordinary pipelining terms pipeline interlocks functional unit operand conflicts 
interlocks conflicts analyzed accurately level model cpu pipeline 

summary discussed program characterization execution time prediction context machine model 
aspects methodology allows investigate characteristics benchmarks compute accurate execution time estimates arbitrary fortran programs 
approach algebraic languages different characteristics fortran 
cases larger number parameters needed special care taken characterization library functions execution input dependent string library functions number results applications research methodology allows analyze behavior individual machines identify strong weak points 
analyze individual benchmark programs determine operations execute frequently accurately predict running time machines characterized 
determine time goes aids greatly tuning programs run faster specific machines 
evaluate suitability individual benchmarks sets benchmarks tools evaluation 
identify redundant benchmarks set 
estimate performance proposed workloads real machines real workloads proposed machines proposed workloads proposed machines 
part research extensive statistics spec perfect club benchmark suites illustrated identify deficiencies benchmarks 
related appears saav extend methodology analysis optimized code saav extend methodology consider cache tlb misses 
see saav concentrates machine characterization 
stevens jr providing access facilities nasa ames david culler luis miguel run programs machines 
scott mips assisted spec benchmarks oscar barbara useful suggestions 
bibliography alle allen burke charles cytron ferrante overview analysis system multiprocessing 
proc 
supercomputing conf 
bala kennedy kremer mckinley editor interactive parallel programming tool proc 
supercomputing conf reno nevada november 
bail bailey barton nas kernel benchmark program nasa technical memorandum august 
bala fox kennedy kremer static performance estimator guide data partitioning decisions third acm sigplan symp 
principles practice parallel prog williamsburg virginia april pp 

beizer micro analysis computer system performance van nostrand new york 
clapp volz mudge real time performance benchmarks ada comm 
acm vol august pp 

synthetic benchmark computer journal vol february pp 

curr causes variability cpu time computer measurement evaluation share project vol 
pp 

cybenko pointer kuck supercomputer performance evaluation perfect benchmarks university illinois center supercomputing tech 
rept 
march 
doduc fortran execution time benchmark preparation version march 
dong dongarra martin computer benchmarking paths pitfalls computer vol july pp 

dong dongarra performance various computers standard linear equations software fortran environment comp 
arch 
news vol march pp 

gee hill smith cache performance spec benchmark suite submitted publication uc berkeley tech 
rept 
ucb csd october 
gee smith tlb performance spec benchmark suite preparation 
groves risc system processor architecture ibm risc system technology sa ibm pp 

hick hickey cohen automating program analysis acm vol 
january pp 

kobayashi dynamic profile instruction sequences ibm system ieee trans 
computers vol 
september pp 

kobayashi dynamic characteristics loops ieee trans 
computers vol 
february pp 

knut knuth empirical study fortran programs software practice experience vol 
pp 

mcmahon livermore fortran kernels computer test floating point performance range llnl december 
mips mips computer systems mips unix benchmarks performance brief cpu benchmarks issue june 
olsson markstein risc system floating point unit ibm risc system technology sa ibm pp 

peut instruction timing model cpu performance fourth annual symp 
computer arch vol march pp 

hill cache performance integer spec benchmarks risc comp 
arch 
news vol 
june pp 

pond ponder analytical look linear performance models llnl tech 
rept 
jc september 
rama ramamoorthy discrete markov analysis computer programs proc 
acm nat 
conf pp 

saav saavedra barrera machine characterization benchmark performance prediction uc berkeley tech 
rept 
ucb csd june 
saav saavedra barrera smith machine characterization high level language machine ieee trans 
comp 
vol december pp 

saav saavedra barrera smith benchmarking machine characterization model uc berkeley tech 
rept 
ucb csd november 
saav saavedra barrera cpu performance evaluation execution time time prediction narrow spectrum benchmarking ph thesis uc berkeley tech 
rept 
ucb csd february 
saav saavedra smith benchmarking optimizing compilers submitted publication usc tech 
rept 
usc cs uc berkeley tech 
rept 
ucb csd august 
saav saavedra smith measuring cache tlb performance preparation 
sarkar determining average program execution times variance proc 
sigplan conf 
prog 
lang 
design impl portland june pp 

spec spec spec newsletter benchmark results vol issue winter 
spec spec spec newsletter vol issue spring 
vol issue winter 
vol issue spring 
ucb berkeley cad ic group 
spice eecs erl industrial program uc berkeley march 
dhrystone benchmark rationale version measurement rules sigplan notices vol august 
understanding supercomputer benchmarks datamation september pp 

appendix multiplication multiplication division division appendix operation doduc fpppp tomcatv matrix nasa average andl arr addi sins benchmark perfect toronto average table benchmark perfect toronto average andl arr addi sins adm qcd mdg track bdna ocean average table adm qcd mdg track bdna ocean average andl arr addi sins dyfesm mg arc flo trfd spec average table dyfesm mg arc flo trfd spec average andl arr addi sins ecdl table goto arr arr sins logd maxd maxc modi maxi conj table appendix program size basic blocks executed loop iter assignments memory transfers expressions expr program size basic blocks executed loop iter assignments memory transfers expressions expr memory transfers expr branches computed goto memory transfers expr statements branches computed goto compare compare integer compare table compare compare integer compare table compare compare integer compare table program doduc fpppp tomcatv matrix nasa average simple arrays dim dims dims dims program benchmark perfect toronto average simple arrays dim dims dims dims program adm qcd mdg track bdna ocean average simple arrays dim dims dims dims program dyfesm mg arc flo trfd spec average simple arrays dim dims dims dims program alamos baskett linpack liver average simple arrays dim dims dims dims program loops mand shell smith average simple arrays dim dims dims dims table distribution simple array variables spec perfect club small benchmarks 
appendix doduc fpppp tomcatv system real pred error real pred error real pred error sec sec sec sec sec sec ibm rs mips motorola decstation decstation sparcstation vax vax sun average matrix nasa spice average system real pred error real pred error real pred error error error sec sec sec sec sec sec ibm rs mips motorola decstation decstation sparcstation vax vax sun average table execution estimates actual running times spec benchmarks 
real times predictions seconds errors percentage 
adm qcd mdg track bdna ocean dyfesm mg arc flo trfd spec alamos baskett linpack livermore mandelbrot shell smith skewness skewness basic blocks amount skewness ordered distributions basic blocks operations amount error execution prediction 
table distribution execution times 
similar programs produce similar distributions corresponding ratios execution times machines close constant 
alamos linpack livermore clear examples program similarity respect execution time distributions 
